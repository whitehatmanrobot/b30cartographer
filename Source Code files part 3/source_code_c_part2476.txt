A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_26_1:    // Soundtracks with Loc Text
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_3_26_1() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_26_2:    // Nicknames with Loc Text
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_3_26_2() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_26_3:    // MU Names with Loc Text
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_3_26_3() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_26_4:    // Saved Game Names with Loc Text
        {
            if( wcslen( pCertMenu->m_pwszTitleID ) != 8 )
            {
                // TODO: Display an error message
                return 2;
            }

            char pszTitleID[9];
            ZeroMemory( pszTitleID, 9 );

            sprintf( pszTitleID, "%ls", pCertMenu->m_pwszTitleID );

            if( FAILED( pCertMenu->m_CertReqs.Req10_3_26_4( pszTitleID ) ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_33:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_3_33() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_6_05:
        {
            if( wcslen( pCertMenu->m_pwszTitleID ) != 8 )
            {
                // TODO: Display an error message
                return 2;
            }

            char pszTitleID[9];
            ZeroMemory( pszTitleID, 9 );

            sprintf( pszTitleID, "%ls", pCertMenu->m_pwszTitleID );

            if( FAILED( pCertMenu->m_CertReqs.Req10_6_05( pszTitleID ) ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_CLEANUP:
        {
            if( FAILED( pCertMenu->m_CertReqs.CleanUp( NULL ) ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    }

    return dwReturnVal;
}


// Draw a box on the screen of the specified color
void CCertMenu::DrawBox( float x1, float y1, float x2, float y2, DWORD dwColor )
{
    struct MYVERTEX box[5];

    box[0].v.x = x1; box[0].v.y = y2; box[0].v.z = 0.000001f; box[0].fRHW = 1.0f/box[0].v.z; box[0].cDiffuse = dwColor;
    box[1].v.x = x1; box[1].v.y = y1; box[1].v.z = 0.000001f; box[1].fRHW = 1.0f/box[1].v.z; box[1].cDiffuse = dwColor;
    box[2].v.x = x2; box[2].v.y = y1; box[2].v.z = 0.000001f; box[2].fRHW = 1.0f/box[2].v.z; box[2].cDiffuse = dwColor;
    box[3].v.x = x2; box[3].v.y = y2; box[3].v.z = 0.000001f; box[3].fRHW = 1.0f/box[3].v.z; box[3].cDiffuse = dwColor;
    box[4].v.x = x1; box[4].v.y = y2; box[4].v.z = 0.000001f; box[4].fRHW = 1.0f/box[4].v.z; box[4].cDiffuse = dwColor;

    g_pD3DDevice->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE );
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG2 );
    g_pD3DDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, 4, box, sizeof( struct MYVERTEX ) );
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
}


// Draw a box on the screen based on the percentage passed in
// The box will be centered on the screen
void CCertMenu::DrawBoxPercentBased( float fPercentage, DWORD dwColor )
{
    // Calculate the pixel width / height based on the resolution
    float fScreenWidth = (float)::GetScreenWidth();
    float fScreenHeight = (float)::GetScreenHeight();

    float fBoxWidth = ( fScreenWidth * fPercentage ) / 100.0f;
    float fBoxHeight = ( fScreenHeight * fPercentage ) / 100.0f;

    float x1 = ( fScreenWidth - fBoxWidth ) / 2.0f;
    float x2 = fScreenWidth - x1;
    float y1 = ( fScreenHeight - fBoxHeight ) / 2.0f;
    float y2 = fScreenHeight - y1;

    DrawBox( x1, y1, x2, y2, dwColor );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\certmenu.h ===
/*****************************************************
*** certmenu.h
***
*** Header file for our XShell Certification menu 
*** class.  This is a standard menu contains a list
*** of menu items to be selected.
***
*** by James N. Helm
*** May 26th, 2001
***
*****************************************************/

#ifndef _CERTMENU_H_
#define _CERTMENU_H_

#include "menuscreen.h"
#include "hexkeypadmenu.h"      // Used to get Title ID's
#include "dumpcachemenu.h"      // Used to dump the cache partition for a specified Title
#include "languagemenu.h"       // Used to set the Xbox Language
#include "timezonemenu.h"       // Used to set the Xbox TimeZone
#include "eepromsettingsmenu.h" // Used to display the EEPROM Settings

#include "certreqs.h"       // Certifcation Requirements Configuration Object

class CCertMenu : public CMenuScreen
{
public:
    CCertMenu( CXItem* pParent );
    ~CCertMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );     // Initialize our font and settings
    void    Leave( CXItem* pItem );         // Should be called whenever a user deactivates this item
private:
    // Private Properties
    unsigned int    m_uiTopItemIndex;   // Index of the top item being displayed
    CCertReqs       m_CertReqs;         // Used to configure the Xbox for certain Cert Requirments
    BOOL            m_bProcessing;      // Used to determine if the menu is processing a user command
    BOOL            m_bStartThread;     // Used to determine when we should kick off our thread
    BOOL            m_bDisableInput;    // Used to determine if the menu should continue processing input
    HANDLE          m_hThread;          // Handle for our processing thread
    BOOL            m_bAborting;        // Used to determine if we are aborting a process

    WCHAR           m_pwszTitleID[MENU_CERT_TITLE_ID_STR_LEN+1];   // Used to hold our Title ID
    BOOL            m_bDispHDTVSafe;    // Used to determine if we should display the HDTV Safe Area
    BOOL            m_bDispNonHDTVSafe; // Used to display the Non-HDTV Safe Area

    CHexKeypadMenu      m_HexKeypadMenu;    // Used to get Title ID's
    CDumpCacheMenu      m_DumpCacheMenu;    // Used to prompt the user to delete a particular cache partition
    CLanguageMenu       m_LanguageMenu;     // Used to set the Xbox Language
    CTimeZoneMenu       m_TimeZoneMenu;     // Used to set the Xbox Time Zone
    CEEPROMSettingsMenu m_EEPROMMenu;       // Used to display the EEPROM Settings

    // Private Methods
    void AdjustDisplayArrows();                     // Adjust the UP and DOWN arrows on the screen
    void DrawBox( float x1,                         // Draw a box on the screen of the specified color
                  float y1,
                  float x2,
                  float y2,
                  DWORD dwColor );
    void DrawBoxPercentBased( float fPercentage,    // Draw a box on the screen based on the percentage passed in
                              DWORD dwColor );

    static friend DWORD WINAPI ProcessDataThreadFunc( LPVOID lpParameter );  // Thread Function
};

#endif // _CERTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\certreqs.h ===
/*****************************************************
*** certreqs.h
***
*** Header file for our Certification Requirements 
*** class.  This class will configure the Xbox in
*** various ways to satisfy certain certification
*** requirements
***
*** by James N. Helm
*** May 26th, 2001
***
*****************************************************/

#ifndef _CERTREQS_H_
#define _CERTREQS_H_

class CCertReqs
{
public:
    // Constructors and Destructor
    CCertReqs();
    ~CCertReqs();

    // Public Properties
    
    // Public Methods
    HRESULT Req10_1_11();                           // Removes all System Files: Soundtracks and Nicknames
    HRESULT Req10_1_12();                           // List all global settings
    HRESULT Req10_2_01();                           // Fragments the TDATA and UDATA partitions
    HRESULT Req10_2_02();                           // Removes all Soundtracks
    HRESULT Req10_2_07( char pszTitleID[9] );       // Fills udata\<titleid> with 4096 entries
    HRESULT Req10_2_10( DWORD dwTitleID );          // Clears Utility partition for <titleid>
    HRESULT Req10_2_18();                           // Draws outline of non-HDTV safe area
    HRESULT Req10_2_19();                           // Draws outline of HDTV safe area
    // HRESULT Req10_3_02();                           // Fills udata area, but with less than 4096 entries
    // HRESULT Req10_3_03();                           // Fills tdata area, but with less than 4096 entries
    HRESULT Req10_3_04( DWORD dwFileSize );         // Fills tdata and udata area
    HRESULT Req10_3_11();                           // Lists available blocks for all attached memory devices
    HRESULT Req10_3_14();                           // Change Language Setting
    HRESULT Req10_3_15();                           // Change Time Zone Setting
    HRESULT Req10_3_26_1();                         // Create Soundtrack names with localized text
    HRESULT Req10_3_26_2();                         // Create Nicknames with localized text
    HRESULT Req10_3_26_3();                         // Create MU names with localized text
    HRESULT Req10_3_26_4( char pszTitleID[9] );     // Create Saved Game names with localized text
    HRESULT Req10_3_33();                           // Makes list of all files on console, both hard disk and MUs
    HRESULT Req10_6_05(  char pszTitleID[9] );      // Corrupts Saved Games for a specific Title

    HRESULT CleanUp( char* pszStartDir );           // Clean up any files created by the cert process
    HRESULT CleanDir( char* pszDir, char* pszFileExtension );

private:
    // Private Properties
    BOOL m_bUtilityMounted;                         // Used to determine if the utility drive was already mounted
    
    // Private Methods
    void DumpFiles( char* pszDirName,               // Dump files to our hard disk
                    char* pszDestFile,
                    unsigned int uiPartitionNumber );
};

#define FILE_DATA_FILELIST_FILENAME     FILE_EXECUTABLE_DIRECTORY_A "\\xbox_all_files.xdk"
#define FILE_DATA_PARTITION_PATTERN     "\\Device\\Harddisk0\\Partition"
#define FILE_DATA_DUMPFILE_LINK_DRIVE   'W'

#endif // _CERTREQS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\certreqs.cpp ===
/*****************************************************
*** certreqs.cpp
***
*** CPP file for our Certification Requirements 
*** class.  This class will configure the Xbox in
*** various ways to satisfy certain certification
*** requirements
***
*** by James N. Helm
*** May 26th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "certreqs.h"

extern CHardDrive   g_XboxHardDrive;    // Used to configure the Xbox Hard Drive
extern DWORD        g_dwInsertedMUs;    // Tracks which MUs are inserted or removed
extern CMemoryUnit  g_MemoryUnits[8];   // Memory Units that can be inserted, or removed

// Constructors
CCertReqs::CCertReqs()
: m_bUtilityMounted( FALSE )
{
}

// Destructor
CCertReqs::~CCertReqs()
{
}

// Configures the Xbox for the cert requirment
// Removes all System Files: Soundtracks and Nicknames
HRESULT CCertReqs::Req10_1_11()
{
    HRESULT hr = S_OK;

    // Remove Nicknames
    if( FAILED( g_XboxHardDrive.RemoveAllNicknames() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_1_11():Failed to delete the Nicknames!!" );

        hr = E_FAIL;
    }

    // Remove Soundtracks
    if( FAILED( g_XboxHardDrive.RemoveAllSoundtracks() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_1_11():Failed to delete the Soundtracks!!" );

        hr = E_FAIL;
    }

    return hr;
}


// Configures the Xbox for the cert requirment
// List all global settings
HRESULT CCertReqs::Req10_1_12()
{
    return S_OK;
}


// Configures the Xbox for the cert requirment
// Fragments tdata and udata
// #define _PERF
#define PERF_READFILE_NUM_TIMES     100
#define PERF_NUM_FILES_TO_USE       10
#define PERF_FILE_SIZE              5120000 // 10240000
#define PERF_BUFFER_SIZE            PERF_FILE_SIZE // 4096
#define PERF_FILE_NUM_READ_LOOPS    ( PERF_FILE_SIZE / PERF_BUFFER_SIZE )
HRESULT CCertReqs::Req10_2_01()
{
#ifdef _PERF
    // Clear out the partition
    g_XboxHardDrive.UnMapDrive( FILE_DATA_UDATA_DRIVE_LETTER_A );
    g_XboxHardDrive.DeleteDirectory( "c:\\udata" );
    CreateDirectory( "c:\\udata", NULL );
    g_XboxHardDrive.MapDrive( FILE_DATA_UDATA_DRIVE_LETTER_A, FILE_DATA_UDATA_PATH_A );

    // Write files
    char pszFileName[MAX_PATH];
    ZeroMemory( pszFileName, MAX_PATH );
    LARGE_INTEGER liFileSize;
    liFileSize.QuadPart = PERF_FILE_SIZE;
    for( unsigned int x = 0; x < PERF_NUM_FILES_TO_USE; x++ )
    {
        sprintf( pszFileName, "c:\\udata\\file_%d", x );
        g_XboxHardDrive.CreateFileOfSize( pszFileName, liFileSize );
    }

    // Read the files and time it
    DWORD dwTimeBeforeFrag = GetTickCount();

    BYTE* buffer = new BYTE[PERF_BUFFER_SIZE];
    if( NULL == buffer )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Failed to allocate buffer memory!!" );

        return E_FAIL;
    }

    for( unsigned int xx = 0; xx < PERF_READFILE_NUM_TIMES; xx++ )
    {
        //XDBGWRN( APP_TITLE_NAME_A, "xx - '%d'", xx );
        for( unsigned int x = 0; x < PERF_NUM_FILES_TO_USE; x++ )
        {
            //XDBGWRN( APP_TITLE_NAME_A, "x - '%d'", xx );
            sprintf( pszFileName, "c:\\udata\\file_%d", x );

            // Dump the file info to our destination file
            HANDLE hInFile = CreateFile( pszFileName,
                                         GENERIC_READ,
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );

            if( INVALID_HANDLE_VALUE == hInFile )
            {
                XDBGWRN( APP_TITLE_NAME_A, "Failed to read the file - '%s'", pszFileName );

                continue;
            }

            DWORD dwNumRead;
            for( unsigned int y = 0; y < PERF_FILE_NUM_READ_LOOPS; y++ )
            {
                if( !ReadFile( hInFile,
                               buffer,
                               PERF_BUFFER_SIZE,
                               &dwNumRead,
                               NULL ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "Failed to read the file block from file!! - '%s'", pszFileName );
                }
            }

            CloseHandle( hInFile );
            hInFile = NULL;
        }
    }

    dwTimeBeforeFrag = GetTickCount() - dwTimeBeforeFrag;

    // Fragment the partition
    g_XboxHardDrive.CreateFragTempFiles();
    g_XboxHardDrive.FragmentTree( "c:\\udata" );
    g_XboxHardDrive.DeleteDirectory( MEMORY_AREA_FRAG_FILE_DIR );

    // Read the files and time it
    DWORD dwTimeAfterFrag = GetTickCount();

    for( unsigned int xx = 0; xx < PERF_READFILE_NUM_TIMES; xx++ )
    {
        for( unsigned int x = 0; x < PERF_NUM_FILES_TO_USE; x++ )
        {
            sprintf( pszFileName, "c:\\udata\\file_%d", x );

            // Dump the file info to our destination file
            HANDLE hInFile = CreateFile( pszFileName,
                                         GENERIC_READ,
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );

            if( INVALID_HANDLE_VALUE == hInFile )
            {
                XDBGWRN( APP_TITLE_NAME_A, "Failed to read the file - '%s'", pszFileName );

                continue;
            }

            DWORD dwNumRead;
            for( unsigned int y = 0; y < PERF_FILE_NUM_READ_LOOPS; y++ )
            {
                if( !ReadFile( hInFile,
                               buffer,
                               PERF_BUFFER_SIZE,
                               &dwNumRead,
                               NULL ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "Failed to read the file block from file!! - '%s'", pszFileName );
                }
            }

            CloseHandle( hInFile );
            hInFile = NULL;
        }
    }

    dwTimeAfterFrag = GetTickCount() - dwTimeAfterFrag;

    XDBGWRN( APP_TITLE_NAME_A, "Time First  - '%d'", dwTimeBeforeFrag );
    XDBGWRN( APP_TITLE_NAME_A, "Time Second - '%d'", dwTimeAfterFrag );

    // Free our memory
    if( buffer )
    {
        delete[] buffer;
        buffer = NULL;
    }

    g_XboxHardDrive.UnMapDrive( FILE_DATA_UDATA_DRIVE_LETTER_A );
    g_XboxHardDrive.DeleteDirectory( "c:\\udata" );
    CreateDirectory( "c:\\udata", NULL );
    g_XboxHardDrive.MapDrive( FILE_DATA_UDATA_DRIVE_LETTER_A, FILE_DATA_UDATA_PATH_A );
#else // _PERF
    // Mount our utility drive if it hasn't been mounted already
    if( !m_bUtilityMounted )
    {
        m_bUtilityMounted = XMountUtilityDrive( TRUE );
    }

    if( !m_bUtilityMounted )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Req10_2_01():Failed to mount the utility drive!! Error - '0x%0.8X (%d)'", GetLastError(), GetLastError() );

        return E_FAIL;
    }

    // Create our temporary files used in fragmentation
    g_XboxHardDrive.CreateFragTempFiles();

    // Process the TDATA directory
    g_XboxHardDrive.FragmentTree( "c:\\tdata" );

    // Process the UDATA directory
    g_XboxHardDrive.FragmentTree( "c:\\udata" );

    // Clean up our directories
    g_XboxHardDrive.DeleteDirectory( MEMORY_AREA_FRAG_FILE_DIR );
#endif // _PERF

    return S_OK;
}


// Configures the Xbox for the cert requirment
// Removes all Soundtracks
HRESULT CCertReqs::Req10_2_02()
{
    return g_XboxHardDrive.RemoveAllSoundtracks();
}


// Configures the Xbox for the cert requirment
// Fills udata\<titleid> with 4096 entries
HRESULT CCertReqs::Req10_2_07( char pszTitleID[9] )
{
    if( !pszTitleID )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_2_07():Invalid paramter passed in!!" );
        
        return E_INVALIDARG;
    }

    char pszFullPath[MAX_PATH];
    ZeroMemory( pszFullPath, MAX_PATH );

    _snprintf( pszFullPath, MAX_PATH - 1, "%c:\\%s", FILE_DATA_UDATA_DRIVE_LETTER_A, pszTitleID );

    // Create the TITLE ID Directory if it doesn't exist
    CreateDirectory( pszFullPath, NULL );

    // Fill the TITLE ID Directory with 4096 entries
    for( unsigned int x = 0; ( x < 4096 ) && ( g_XboxHardDrive.GetAbortProcess() != TRUE ); x++ )
    {
        _snprintf( pszFullPath, MAX_PATH - 1, "%c:\\%s\\%s%d.xdk", FILE_DATA_UDATA_DRIVE_LETTER_A, pszTitleID, FILE_DATA_DIR_ENTRY_PATTERN, x );

        DWORD dwReturn = g_XboxHardDrive.CreateZeroByteFile( pszFullPath );

        if( ERROR_DISK_FULL == dwReturn )
        {
            break;
        }
    }

    return S_OK;
}


// Configures the Xbox for the cert requirment
// Clears Utility partition for <titleid>
HRESULT CCertReqs::Req10_2_10( DWORD dwTitleID )
{
    XapiDeleteCachePartition( dwTitleID );

    return S_OK;
}


// Configures the Xbox for the cert requirment
// Draws outline of non-HDTV safe area
HRESULT CCertReqs::Req10_2_18()
{
    return S_OK;
}


// Configures the Xbox for the cert requirment
// Draws outline of HDTV safe area
HRESULT CCertReqs::Req10_2_19()
{
    return S_OK;
}

/*
// Configures the Xbox for the cert requirment
// Fills udata area, but with less than 4096 entries
HRESULT CCertReqs::Req10_3_02()
{
    DWORD dwNumBlocksFree = g_XboxHardDrive.GetFreeBlocks();

    if( 0 == dwNumBlocksFree )
    {
        // Bail early, since we have no work to do

        return S_OK;
    }

    // Setup the proper path
    char pszFullPath[4];
    ZeroMemory( pszFullPath, 4 );

    sprintf( pszFullPath, "%c:\\", FILE_DATA_UDATA_DRIVE_LETTER_A );

    // Fill the UDATA area
    g_XboxHardDrive.FillArea( pszFullPath, dwNumBlocksFree );

    return S_OK;
}


// Configures the Xbox for the cert requirment
// Fills tdata area, but with less than 4096 entries
HRESULT CCertReqs::Req10_3_03()
{
    DWORD dwNumBlocksFree = g_XboxHardDrive.GetFreeBlocks();

    if( 0 == dwNumBlocksFree )
    {
        // Bail early, since we have no work to do

        return S_OK;
    }

    // Setup the proper path
    char pszFullPath[4];
    ZeroMemory( pszFullPath, 4 );

    sprintf( pszFullPath, "%c:\\", FILE_DATA_TDATA_DRIVE_LETTER_A );

    // Fill the TDATA area
    g_XboxHardDrive.FillArea( pszFullPath, dwNumBlocksFree );

    return S_OK;
}
*/

// Configures the Xbox for the cert requirment
// Fills tdata and udata area
HRESULT CCertReqs::Req10_3_04( DWORD dwFileSize )
{
    if( 0 == dwFileSize )
    {
        return S_OK;
    }

    DWORD dwNumBlocksFree = g_XboxHardDrive.GetFreeBlocks();

    XDBGTRC( APP_TITLE_NAME_A, "CCertReqs::Req10_3_04():Free - '%d', File - '%d'", dwNumBlocksFree, dwFileSize );

    if( 0 == dwNumBlocksFree )
    {
        // Bail early, since we have no work to do

        return S_OK;
    }

    if( dwFileSize > dwNumBlocksFree ) 
    {
        dwFileSize = dwNumBlocksFree;
    }

    // Setup the proper path
    unsigned int uiStrLen = strlen(FILE_EXECUTABLE_DIRECTORY_A)+1;
    char* pszFullPath = new char[uiStrLen+1];
    if( NULL == pszFullPath )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_04():Could not allocate memory!!" );

        return E_OUTOFMEMORY;
    }
    else
    {
        ZeroMemory( pszFullPath, uiStrLen + 1 );

        _snprintf( pszFullPath, uiStrLen, "%hs\\", FILE_EXECUTABLE_DIRECTORY_A );

        // Fill the UDATA are with the correct file
        g_XboxHardDrive.FillArea( pszFullPath, dwFileSize );

        delete[] pszFullPath;
        pszFullPath = NULL;
    }

    return S_OK;
}


// Configures the Xbox for the cert requirment
// Lists available blocks for all attached memory devices
HRESULT CCertReqs::Req10_3_11()
{
    return S_OK;
}


// Configures the Xbox for the cert requirment
// Change Language Setting
HRESULT CCertReqs::Req10_3_14()
{
    return S_OK;
}


// Configures the Xbox for the cert requirment
// Change Time Zone Setting
HRESULT CCertReqs::Req10_3_15()
{
    return S_OK;
}

// Configures the Xbox for the cert requirment
// Create Soundtrack names with localized text
HRESULT CCertReqs::Req10_3_26_1()
{
    //
    // Create Soundtrack Names
    //

    // Create soundtracks with localized Text
    if( !DashBeginUsingSoundtracks() )
    //
    // We failed to open the ST Database, so we can't create the soundtrack
    //
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_26_1():Failed to Begin Using Soundtracks!!" );

        return E_FAIL;
    }
    else
    //
    // We opened the ST Database, so we can create the soundtrack
    //
    {
        DWORD dwCurrentST = 0;

        if( !DashAddSoundtrack( STRING_DATA_LOC_CHARS, &dwCurrentST ) )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_26_1():Failed to add the Soundtrack!!" );
        }

        DashEndUsingSoundtracks();
    }

    return S_OK;
}


// Configures the Xbox for the cert requirment
// Create Nicknames with localized text
HRESULT CCertReqs::Req10_3_26_2()
{
    //
    // Create Nicknames
    //

    // Create Nicknames with localized text
    if( !XSetNickname( STRING_DATA_LOC_CHARS, TRUE ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_26_4():Failed to Set the Nickname!!" );

        return E_FAIL;
    }

    return S_OK;
}

// Configures the Xbox for the cert requirment
// Creates MU names with localized text
HRESULT CCertReqs::Req10_3_26_3()
{
    //
    // Create MU Names
    //

    // Enumerate Any Inserted MUs
    for( unsigned int x = 0; x < NUM_XBOX_MU_SLOTS; ++x )
    {
        if( g_MemoryUnits[x].IsMounted() )
        {
            // Mount any MU that are inserted, name them, and then unmount them
            g_MemoryUnits[x].Name( STRING_DATA_LOC_CHARS );
        }
    }

    return S_OK;
}


// Configures the Xbox for the cert requirment
// Creates Saved Game names with localized text
HRESULT CCertReqs::Req10_3_26_4( char pszTitleID[9] )
{
    if( !pszTitleID )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_26_4():Invalid paramter passed in!!" );
        
        return E_INVALIDARG;
    }

    //
    // Create Saved Games
    //
    
    // Create Directory for Specified Title
    char* pszDirName = new char[MAX_PATH+1];
    if( NULL == pszDirName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_26_4():Failed to allocate memory!!" );
    }
    else
    {
        ZeroMemory( pszDirName, MAX_PATH + 1 );
        
        _snprintf( pszDirName, MAX_PATH, "%hc:\\%hs", FILE_DATA_UDATA_DRIVE_LETTER_A, pszTitleID );
        CreateDirectory( pszDirName, NULL );

        delete[] pszDirName;
        pszDirName = NULL;
    }    
    
    // Map Directory for Specified Title
    g_XboxHardDrive.MapUDataToTitleID( pszTitleID );

    // Create Saved Games with Localized Text
    char* pszSaveGamePath = new char[MAX_PATH+1];
    if( NULL == pszSaveGamePath )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_26_4():Failed to allocate memory!!" );
    }
    else
    {
        ZeroMemory( pszSaveGamePath, MAX_PATH+1 );
        DWORD dwReturn = XCreateSaveGame( "U:\\",
                                          STRING_DATA_LOC_CHARS,
                                          OPEN_ALWAYS,
                                          0,
                                          pszSaveGamePath,
                                          MAX_PATH );

        if( ERROR_SUCCESS != dwReturn )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_26_4():Failed to create the Saved Game!! Error - '0x%.8X (%d)'", dwReturn, dwReturn );
        }

        delete[] pszSaveGamePath;
        pszSaveGamePath = NULL;
    }

    // Clean up
    g_XboxHardDrive.MapUDataToOrigLoc();

    return S_OK;
}


// Configures the Xbox for the cert requirment
// Makes list of all files on console, both hard disk and MUs
HRESULT CCertReqs::Req10_3_33()
{
    // Delete the log file
    if( !DeleteFile( FILE_DATA_FILELIST_FILENAME ) )
    {
        if( ERROR_FILE_NOT_FOUND != GetLastError() )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_33():Failed to delete the file!! - '%s', Error - '0x%.8X (%d)'", FILE_DATA_FILELIST_FILENAME, GetLastError(), GetLastError() );
        }
    }

    char pszDriveRootPath[3];
    ZeroMemory( pszDriveRootPath, 3 );

    sprintf( pszDriveRootPath, "%c:", FILE_DATA_DUMPFILE_LINK_DRIVE );

    // List all the files on each partition
    char pszFullPath[MAX_PATH];

    //
    // Process the two main partitions on the Hard Drive
    //
    for( unsigned int x = 1; x < 3; x++ )
    {
        ZeroMemory( pszFullPath, MAX_PATH );
        _snprintf( pszFullPath, MAX_PATH - 1, "%s%d", FILE_DATA_PARTITION_PATTERN, x );

        DWORD dwReturn = g_XboxHardDrive.MapDrive( FILE_DATA_DUMPFILE_LINK_DRIVE, pszFullPath );
        if( 0 != dwReturn )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_33():Failed to map drive!! - '%c', '%s', Error - '%d'", FILE_DATA_DUMPFILE_LINK_DRIVE, pszFullPath, dwReturn );
        }

        DumpFiles( pszDriveRootPath, FILE_DATA_FILELIST_FILENAME, x );

        dwReturn = g_XboxHardDrive.UnMapDrive( FILE_DATA_DUMPFILE_LINK_DRIVE );
        if( 0 != dwReturn )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_33():Failed to un-map drive!! - '%c', Error - '%d'", FILE_DATA_DUMPFILE_LINK_DRIVE, dwReturn );
        }
    }

    //
    // Process the cache partitions
    //
    for( unsigned int x = 0; x < *HalDiskCachePartitionCount; x++ )
    {
        ZeroMemory( pszFullPath, MAX_PATH );
        _snprintf( pszFullPath, MAX_PATH - 1, "%s%d", FILE_DATA_PARTITION_PATTERN, x + 3 );

        DWORD dwReturn = g_XboxHardDrive.MapDrive( FILE_DATA_DUMPFILE_LINK_DRIVE, pszFullPath );
        if( 0 != dwReturn )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_33():Failed to map drive!! - '%c', '%s', Error - '%d'", FILE_DATA_DUMPFILE_LINK_DRIVE, pszFullPath, dwReturn );
        }

        DumpFiles( pszDriveRootPath, FILE_DATA_FILELIST_FILENAME, x + 3 );

        dwReturn = g_XboxHardDrive.UnMapDrive( FILE_DATA_DUMPFILE_LINK_DRIVE );
        if( 0 != dwReturn )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_3_33():Failed to un-map drive!! - '%c', Error - '%d'", FILE_DATA_DUMPFILE_LINK_DRIVE, dwReturn );
        }
    }

    //
    // Process the MUs
    //

    // Dump the files that live on the MUs
    for( unsigned int x = 0; x < NUM_XBOX_MU_SLOTS; x++ )
    {
        if( g_MemoryUnits[x].IsMounted() )
        {
            ZeroMemory( pszFullPath, MAX_PATH);
            _snprintf( pszFullPath, MAX_PATH - 1, "%c:", g_MemoryUnits[x].GetUDataDrive() );

            DumpFiles( pszFullPath, FILE_DATA_FILELIST_FILENAME, x + 6 );
        }
    }

    return S_OK;
}

// Corrupt Saved Games for a specific Directory
HRESULT CorruptSavedGame( char* pszDirectory )
{
    char pszFindPattern[MAX_PATH+1];
    pszFindPattern[MAX_PATH] = '\0';

    _snprintf( pszFindPattern, MAX_PATH, "%hs*", pszDirectory );
    XDBGTRC( APP_TITLE_NAME_A, "CCertReqs::CorruptSavedGame():pszFindPattern - '%hs'", pszFindPattern );

    // Find each file in the directory, and corrupt it
    WIN32_FIND_DATA findData;
    ZeroMemory( &findData, sizeof( findData ) );

    HANDLE hFile = FindFirstFile( pszFindPattern, &findData );
    if( INVALID_HANDLE_VALUE != hFile )
    {
        do
        {
            // Check to see if it's a directory
            if( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
                if( '.' == findData.cFileName[0] )
                {
                    continue;
                }

                char pszDir[MAX_PATH+1];
                pszDir[MAX_PATH] = '\0';

                _snprintf( pszDir, MAX_PATH, "%hs%hs\\", pszDirectory, findData.cFileName );
                
                XDBGTRC( APP_TITLE_NAME_A, "CCertReqs::CorruptSavedGame():Corrupting Directory pszDir - '%hs'", pszDir );

                CorruptSavedGame( pszDir );
            }
            else // Must be a file
            {
                // Check to see if it's a meta file.  If it is, let's skip it
                if( 0 == _stricmp( "savemeta.xbx", findData.cFileName ) ||
                    0 == _stricmp( "saveimage.xbx", findData.cFileName ) )
                {
                    continue;
                }

                // Must not be a meta file, let's corrupt it
                char pszFilePath[MAX_PATH+1];
                pszFilePath[MAX_PATH] = '\0';

                _snprintf( pszFilePath, MAX_PATH, "%hs%hs", pszDirectory, findData.cFileName );

                XDBGTRC( APP_TITLE_NAME_A, "CCertReqs::CorruptSavedGame():Corrupting File pszFilePath - '%hs'", pszFilePath );

                HANDLE hCorruptFile = CreateFile( pszFilePath,
                                                  GENERIC_WRITE | GENERIC_READ,
                                                  0, // FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                  NULL,
                                                  OPEN_EXISTING,
                                                  FILE_ATTRIBUTE_NORMAL,
                                                  NULL );
                if( INVALID_HANDLE_VALUE != hCorruptFile )
                {
                    DWORD dwFileSize = GetFileSize( hCorruptFile, NULL );
                    SetFilePointer( hCorruptFile, ( dwFileSize / 2 ), NULL, FILE_BEGIN );

                    // Read the current byte of the file
                    BYTE bBuffer[1];
                    DWORD dwNumBytes;
                    if( ReadFile( hCorruptFile, bBuffer, 1, &dwNumBytes, NULL ) )
                    {
                        SetFilePointer( hCorruptFile, ( dwFileSize / 2 ), NULL, FILE_BEGIN );

                        bBuffer[0] ^= 0xFF;
                        if( !WriteFile( hCorruptFile, bBuffer, 1, &dwNumBytes, NULL ) )
                        {
                            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CorruptSavedGame():Failed to write the byte back to the file!! - '%hs', Error - '0x%0.8X (%d)'", pszFilePath, GetLastError(), GetLastError() );
                        }
                    }
                    else
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CorruptSavedGame():Failed to read a byte from the file!! - '%hs', Error - '0x%0.8X (%d)'", pszFilePath, GetLastError(), GetLastError() );
                    }

                    CloseHandle( hCorruptFile );
                    hCorruptFile = INVALID_HANDLE_VALUE;
                }
            }
        } while( FindNextFile( hFile, &findData ) );

        FindClose( hFile );
        hFile = INVALID_HANDLE_VALUE;
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CorruptSavedGame():Failed to find any files for - '%hs', Error - '0x%0.8X (%d)'", pszFindPattern, GetLastError(), GetLastError() );
    }

    return S_OK;    
}

// Corrupts Saved Games for a specific Title
HRESULT CCertReqs::Req10_6_05( char pszTitleID[9] )
{
    if( !pszTitleID )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_6_05():Invalid paramter passed in!!" );
        
        return E_INVALIDARG;
    }

    // Map the UData Drive to the Game Title
    if( FAILED( g_XboxHardDrive.MapUDataToTitleID( pszTitleID ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_6_05():Problem mapping UData for - '%hs'", pszTitleID );
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_6_05():Game Title does not exist!!" );

        g_XboxHardDrive.MapUDataToOrigLoc();

        return S_OK;
    }

    // Find each Saved Game for a specific Title, and Corrupt it
    XGAME_FIND_DATA gameFindData;
    ZeroMemory( &gameFindData, sizeof( gameFindData ) );

    HANDLE hSavedGame = XFindFirstSaveGame( "u:\\", &gameFindData );
    if( INVALID_HANDLE_VALUE != hSavedGame )
    {
        do
        {
            XDBGTRC( APP_TITLE_NAME_A, "CCertReqs::Req10_6_05():Corrupting Saved Game Named - '%ls'", gameFindData.szSaveGameName );
            CorruptSavedGame( gameFindData.szSaveGameDirectory );

        } while( XFindNextSaveGame( hSavedGame, &gameFindData ) );

        XFindClose( hSavedGame );
        hSavedGame = INVALID_HANDLE_VALUE;
    }
    else // Did not find a Saved Game
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::Req10_6_05():Did not find a Saved Game for Title - '%hs', Error - '0x%0.8X (%d)'", pszTitleID, GetLastError(), GetLastError() );
    }

    g_XboxHardDrive.MapUDataToOrigLoc();

    return S_OK;
}


// Will dump out file information to the specified Destination File
void CCertReqs::DumpFiles( char* pszDirName, char* pszDestFile, unsigned int uiPartitionNumber )
{
    if( NULL == pszDirName || NULL == pszDestFile )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::DumpFiles():Invalid parameter passed in!!" );

        return;
    }

    WIN32_FIND_DATA findData;
    char pszDirPattern[MAX_PATH];

    ZeroMemory( &findData, sizeof( findData ) );
    ZeroMemory( pszDirPattern, MAX_PATH );

    _snprintf( pszDirPattern, MAX_PATH - 1, "%s\\*", pszDirName );

    HANDLE hFile = FindFirstFile( pszDirPattern, &findData );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        if( ERROR_FILE_NOT_FOUND != GetLastError() )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::DumpFiles():FindFirstFile Failed!! - '%s', '0x%.8X (%d)'", pszDirPattern, GetLastError(), GetLastError() );
        }

        return;
    }

    do
    {
        // Skip the directories
        if( FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes )
        {
            char pszSubDirName[MAX_PATH];
            ZeroMemory( pszSubDirName, MAX_PATH );

            _snprintf( pszSubDirName, MAX_PATH - 1, "%s\\%s", pszDirName, findData.cFileName );
            DumpFiles( pszSubDirName, pszDestFile, uiPartitionNumber );

            continue;
        }

        // Dump the file info to our destination file
        HANDLE hOutputFile = CreateFile( pszDestFile,
                                         GENERIC_WRITE,
                                         0,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );

        if( INVALID_HANDLE_VALUE == hOutputFile )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::DumpFiles():Failed to open our log file!! - '%s', Error - '0x%.8X (%d)'", pszDestFile, GetLastError(), GetLastError() );

            continue;
        }
        else
        {
            char pszBuffer[MAX_PATH];
            SYSTEMTIME sysTime;
            DWORD dwBytesWritten = 0;

            ZeroMemory( pszBuffer, MAX_PATH );
            ZeroMemory( &sysTime, sizeof( sysTime ) );
            
            FileTimeToSystemTime( &findData.ftLastWriteTime, &sysTime );

            _snprintf( pszBuffer, MAX_PATH - 1, "Partition: %2d   %02d/%02d/%d   %02d:%02d/%02d   %10d   %s\\%s\r\n", 
                uiPartitionNumber,                                  // Partition the file lives on
                sysTime.wMonth, sysTime.wDay, sysTime.wYear,        // Date of the file
                sysTime.wHour, sysTime.wMinute, sysTime.wSecond,    // Time of the file
                findData.nFileSizeLow,                              // Size of the file
                pszDirName + 2, findData.cFileName );               // File path and name

            // Set the file pointer to the end of the file
            DWORD dwReturn = SetFilePointer( hOutputFile,
                                             0,
                                             NULL,
                                             FILE_END );

            if( 0xFFFFFFFF == dwReturn )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::DumpFiles():Failed to move our file pointer to the end of our file!! - '%s', Error - '0x%.8X (%d)'", pszDestFile, GetLastError(), GetLastError() );

                CloseHandle( hOutputFile );
                hOutputFile = NULL;

                continue;
            }

            
            // Log the file data
            if ( !WriteFile( hOutputFile,
                             pszBuffer,
                             strlen(pszBuffer),
                             &dwBytesWritten,
                             NULL ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::DumpFiles():Failed to write to the file!! - '%s', Error - '0x%.8X (%d)'", pszDestFile, GetLastError(), GetLastError() );
            }


            // Close the file
            CloseHandle( hOutputFile );
            hOutputFile = NULL;
        }

    } while( FindNextFile( hFile, &findData ) && ( g_XboxHardDrive.GetAbortProcess() != TRUE ) );

    // Close our find file
    FindClose( hFile );
    hFile = INVALID_HANDLE_VALUE;
}

// TODO: Move this to a library
HRESULT CleanTree( char* pszStartDir, char* pszFileExtension )
{
    if( ( NULL == pszStartDir ) || ( NULL == pszFileExtension ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanTree():Invalid paramter passed in!!" );

        return E_INVALIDARG;
    }

    char* pszDirPattern = new char[MAX_PATH+1];
    if( NULL == pszDirPattern )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanTree():Failed to allocate memory!!" );

        return E_FAIL;
    }

    ZeroMemory( pszDirPattern, MAX_PATH + 1 );
    _snprintf( pszDirPattern, MAX_PATH - 1, "%s\\*.*", pszStartDir );
    
    XDBGTRC( APP_TITLE_NAME_A, "CCertReqs::CleanTree():Directory Pattern - '%s'", pszDirPattern );

    HRESULT hr = S_OK;
    WIN32_FIND_DATA findData;
    ZeroMemory( &findData, sizeof( findData ) );

    HANDLE hFile = FindFirstFile( pszDirPattern, &findData );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        if( ERROR_FILE_NOT_FOUND != GetLastError() )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanTree():FindFirstFile Failed!! - '%s', '0x%.8X (%d)'", pszDirPattern, GetLastError(), GetLastError() );

            hr = E_FAIL;
        }
    }
    else
    {
        do
        {
            if ( findData.cFileName[0] == '.' )
            {
			    continue;
            }

            if ( ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
                char* pszNewDirPattern = new char[MAX_PATH+1];
                if( NULL == pszNewDirPattern )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanTree():Failed to allocate memory!!" );

                    continue;
                }
            
                ZeroMemory( pszNewDirPattern, MAX_PATH + 1 );
                _snprintf( pszNewDirPattern, MAX_PATH, "%s\\%s", pszStartDir, findData.cFileName );
                CleanTree( pszNewDirPattern, pszFileExtension );

                delete[] pszNewDirPattern;
                pszNewDirPattern = NULL;
            }
		    else
            //
            // It's a file
            //
		    {
                char* pszMatch = strstr( findData.cFileName, pszFileExtension );
                if( ( NULL != pszMatch ) && ( pszMatch == &findData.cFileName[strlen(findData.cFileName) - strlen(pszFileExtension)] ) )
                {
                    // Check to see if the file matches our pattern
                    char* pszFullFileName = new char[MAX_PATH+1];
                    if( NULL == pszFullFileName )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanTree():Failed to allocate memory!!" );

                        continue;
                    }

                    ZeroMemory( pszFullFileName, MAX_PATH + 1 );
                    _snprintf( pszFullFileName, MAX_PATH, "%s\\%s", pszStartDir, findData.cFileName );
			        if ( !DeleteFile( pszFullFileName ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanTree():Failed to delete file!! - '%s'", pszFullFileName );
                    }

                    delete[] pszFullFileName;
                    pszFullFileName = NULL;
                }
		    }
        } while( FindNextFile( hFile, &findData ) && ( g_XboxHardDrive.GetAbortProcess() != TRUE ) );

        // Close our find file
        FindClose( hFile );
        hFile = INVALID_HANDLE_VALUE;
    }

    delete[] pszDirPattern;
    pszDirPattern = NULL;

    return hr;
}


HRESULT CCertReqs::CleanDir( char* pszDir, char* pszFileExtension )
{
    if( ( NULL == pszDir ) || ( NULL == pszFileExtension ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanDir():Invalid paramter passed in!!" );

        return E_INVALIDARG;
    }

    char* pszDirPattern = new char[MAX_PATH+1];
    if( NULL == pszDirPattern )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanDir():Failed to allocate memory!!" );

        return E_FAIL;
    }

    ZeroMemory( pszDirPattern, MAX_PATH + 1 );
    _snprintf( pszDirPattern, MAX_PATH - 1, "%s\\*.*", pszDir );
    
    XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanDir():Directory Pattern - '%s'", pszDirPattern );

    HRESULT hr = S_OK;
    WIN32_FIND_DATA findData;
    ZeroMemory( &findData, sizeof( findData ) );

    HANDLE hFile = FindFirstFile( pszDirPattern, &findData );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanDir():FindFirstFile Failed!! - '%s', '0x%.8X (%d)'", pszDirPattern, GetLastError(), GetLastError() );

        hr = E_FAIL;
    }
    else
    {
        do
        {
            if ( ( findData.cFileName[0] == '.' ) ||
                 ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
			    continue;
            }

            //
            // It's a file
            //
            char* pszMatch = strstr( findData.cFileName, pszFileExtension );
            if( ( NULL != pszMatch ) && ( pszMatch == &findData.cFileName[strlen(findData.cFileName) - strlen(pszFileExtension)] ) )
            {
                // Check to see if the file matches our pattern
                char* pszFullFileName = new char[MAX_PATH+1];
                if( NULL == pszFullFileName )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanDir():Failed to allocate memory!!" );

                    continue;
                }

                ZeroMemory( pszFullFileName, MAX_PATH + 1 );
                _snprintf( pszFullFileName, MAX_PATH, "%s\\%s", pszDir, findData.cFileName );
			    if ( !DeleteFile( pszFullFileName ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CCertReqs::CleanDir():Failed to delete file!! - '%s'", pszFullFileName );
                }

                delete[] pszFullFileName;
                pszFullFileName = NULL;
            }
        } while( FindNextFile( hFile, &findData ) && ( g_XboxHardDrive.GetAbortProcess() != TRUE ) );

        // Close our find file
        FindClose( hFile );
        hFile = INVALID_HANDLE_VALUE;
    }

    delete[] pszDirPattern;
    pszDirPattern = NULL;

    return hr;
}


// Clean up any files created by the cert process
HRESULT CCertReqs::CleanUp( char* pszStartDir )
{
    if( NULL != pszStartDir )
    {
        CleanTree( pszStartDir, ".xdk" );
    }
    else
    {
        // Walk the Hard Drive and delete any XDK files
        CleanTree( "c:", ".xdk" );

        // Walk each MU and delete any XDK files
        for( unsigned int x = 0; x < NUM_XBOX_MU_SLOTS; x++ )
        {
            if( g_MemoryUnits[x].IsMounted() )
            {
                char pszDrivePath[3];
                pszDrivePath[2] = '\0';

                sprintf( pszDrivePath, "%c:", g_MemoryUnits[x].GetUDataDrive() );
                CleanTree( pszDrivePath, ".xdk" );
            }
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "XShell"

// Menu Titles
#define MENU_TITLE_ERRORMSG                     L"Error Message"
#define MENU_TITLE_DISPSET                      L"Settings : Video"
#define MENU_TITLE_IP                           L"Settings : IP Address"
#define MENU_TITLE_DNS                          L"Settings : DNS Address"
#define MENU_TITLE_SUBNET                       L"Settings : Subnet Mask"
#define MENU_TITLE_GATEWAY                      L"Settings : Gateway"
#define MENU_TITLE_MACHINE                      L"Settings : Machine Name"
#define MENU_TITLE_OPTIONS                      L"Options"
#define MENU_TITLE_ONLINE                       L"Online"
#define MENU_TITLE_GAMEREGION                   L"Options : Game Region"
#define MENU_TITLE_AVREGION                     L"Options : AV Region"
#define MENU_TITLE_VIDEORES                     L"Options : Video Resolution"
#define MENU_TITLE_NETWORK                      L"Options : Network Settings"
#define MENU_TITLE_CERT                         L"Options : Certification Tools"
#define MENU_TITLE_MEMORY                       L"Options : Memory Areas"
#define MENU_TITLE_MEMORYOPTIONS                L"Memory Areas : Options"
#define MENU_TITLE_MUFORMAT                     L"Memory Unit Format"
#define MENU_TITLE_MUUNFORMAT                   L"Memory Unit Unformat"
#define MENU_TITLE_MUNAME                       L"Memory Unit Name"
#define MENU_TITLE_MESSAGE                      L"Message"
#define MENU_TITLE_GENKEYBOARD                  L"Keyboard"
#define MENU_TITLE_HEXKEYPAD                    L"HEX Keypad"
#define MENU_TITLE_PASSCODE                     L"Passcode"
#define MENU_TITLE_YESNO                        L"Yes / No"
#define MENU_TITLE_DUMPCACHE                    L"Clear Cache Partition"
#define MENU_TITLE_LANGUAGE                     L"Language"
#define MENU_TITLE_TIMEZONES                    L"Time Zones"
#define MENU_TITLE_EEPROM                       L"EEPROM Settings"
#define MENU_TITLE_SYSINFO                      L"System Information"
#define MENU_TITLE_MADISPLAY                    L"Memory Area Display"
#define MENU_TITLE_OLUSER                       L"Xbox Hard Disk"
#define MENU_TITLE_OLUSEROPTION                 L"Online User Options"


// Texture Dimensions and Info
#define TEXTURE_MOVIESCREEN_WIDTH               512
#define TEXTURE_MOVIESCREEN_HEIGHT              512
#define TEXTURE_XDKTITLE_WIDTH                  512
#define TEXTURE_XDKTITLE_HEIGHT                 512
#define TEXTURE_XDKADDRESS_WIDTH                512
#define TEXTURE_XDKADDRESS_HEIGHT               512
#define TEXTURE_XDKADDRESS_PIXEL_WIDTH          230
#define TEXTURE_BUILDNO_WIDTH                   512
#define TEXTURE_BUILDNO_HEIGHT                  512

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_HDTV_SAFE_PERCENTAGE             90.0f
#define SCREEN_NONHDTV_SAFE_PERCENTAGE          85.0f

// Menubox constants
#define MENUBOX_MAINAREA_X1                     0.0f   // 102.0f
#define MENUBOX_MAINAREA_Y1                     0.0f   // 135.0f
#define MENUBOX_MAINAREA_X2                     434.0f // 536.0f
#define MENUBOX_MAINAREA_Y2                     224.0f // 367.0f

#define MENUBOX_TITLE_TEXT_XPOS                 2.0f
#define MENUBOX_TITLE_TEXT_YPOS                 0.0f
#define MENUBOX_TITLE_TEXT_FONT_HEIGHT          17
#define MENUBOX_TITLE_TEXT_COLOR                COLOR_WHITE

#define MENUBOX_NAMEADDR_TEXT_XPOS              1.0f
#define MENUBOX_NAMEADDR_TEXT_YPOS              0.0f
#define MENUBOX_NAMEADDR_TEXT_HEIGHT            14
#define MENUBOX_NAMEADDR_TEXT_COLOR             COLOR_WHITE

#define MENUBOX_BUILDNO_TEXT_XPOS               0.0f
#define MENUBOX_BUILDNO_TEXT_YPOS               0.0f
#define MENUBOX_BUILDNO_TEXT_HEIGHT             15 // MENUBOX_NAMEADDR_TEXT_HEIGHT
#define MENUBOX_BUILDNO_TEXT_COLOR              COLOR_WHITE

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    MENUBOX_MAINAREA_X2

#define MENUBOX_TEXT_TOP_BORDER                 7.0f // 10.0f
#define MENUBOX_TEXT_BOTTOM_BORDER              0.0f
#define MENUBOX_TEXT_LSIDE_BORDER               9.0f
#define MENUBOX_TEXT_RSIDE_BORDER               4.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )
#define MENUBOX_TEXTAREA_X_CENTER               ( MENUBOX_MAINAREA_X2 / 2 )
#define MENUBOX_TEXTAREA_Y_CENTER               ( MENUBOX_MAINAREA_Y2 / 2 )

// Display Settings Menu constants
#define DISPSETMENU_VIDEOHEADER_YPOS             14.0f      // Also in dispset.mnu file -- must be identical

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FONT_ALIAS_LEVEL                        0

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 60

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_LIGHT_YELLOW2                     0xFFDDD078
#define COLOR_YELLOW                            0xFFFFFF00
// #define COLOR_TVSAFE_YELLOW                     0xFFEFEF30
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515

#define COLOR_TVSAFE_GREEN                      0xFF2CDF2C
#define COLOR_TVSAFE_RED                        0xFF8D3232
#define COLOR_TVSAFE_BLUE                       0xFF20209F
#define COLOR_TVSAFE_YELLOW                     0xFFF0F02F
#define COLOR_DARK_GREY                         0xFF808080
#define COLOR_DIM_GREY                          0xFF272727

#define COLOR_A_BUTTON                          COLOR_TVSAFE_GREEN
#define COLOR_B_BUTTON                          COLOR_TVSAFE_RED
#define COLOR_X_BUTTON                          COLOR_TVSAFE_BLUE
#define COLOR_Y_BUTTON                          COLOR_TVSAFE_YELLOW
#define COLOR_L_BUTTON                          COLOR_DARK_GREY
#define COLOR_R_BUTTON                          COLOR_DARK_GREY
#define COLOR_WHITE_BUTTON                      COLOR_WHITE
#define COLOR_BLACK_BUTTON                      COLOR_DARK_GREY // COLOR_DIM_GREY
#define COLOR_START_BUTTON                      COLOR_DARK_GREY
#define COLOR_BACK_BUTTON                       COLOR_DARK_GREY
#define COLOR_DPAD_UP_BUTTON                    COLOR_DARK_GREY
#define COLOR_DPAD_DOWN_BUTTON                  COLOR_DARK_GREY
#define COLOR_DPAD_LEFT_BUTTON                  COLOR_DARK_GREY
#define COLOR_DPAD_RIGHT_BUTTON                 COLOR_DARK_GREY


#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW2
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

#define IPMENU_TITLE_IP_HEADER_TEXT             L"Title IP Address : "
#define IPMENU_DEBUG_IP_HEADER_TEXT             L"Debug IP Address : "

#define SUBNETMENU_HEADER_TEXT                  L"Subnet mask : "

#define GATEWAYMENU_HEADER_TEXT                 L"Gateway : "

// Launcher Menu Item Information
#define MENU_LAUNCH_TOP_BORDER_SIZE             0.0f // 10.0f

// Machine Name Menu Constants
#define MENU_MACHINENAME_INUSE_MESSAGE          L"That machine name is already in use..."
#define MENU_MACHINENAME_INUSE_YPOS             48.0f

// Machine Name Menu Constants
#define MENU_MACHINENAME_INUSE_MESSAGE          L"That machine name is already in use..."
#define MENU_MACHINENAME_INUSE_YPOS             48.0f

// IP Address Menu Constants
#define IPMENU_ADDRESS_INUSE_MESSAGE            L"That IP Address is already in use..."
#define IPMENU_ADDRESS_HEADER_TEXT_YPOS         24.0f
#define IPMENU_ADDRESS_INUSE_YPOS               48.0f

// DNS Address Menu Constants
#define DNSMENU_ADDRESS_HEADER_TEXT_YPOS        24.0f
#define DNSMENU_PRIMARY_DNS_HEADER_TEXT         L"Primary DNS : "
#define DNSMENU_SECONDARY_DNS_HEADER_TEXT       L"Secondary DNS : "

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_DARK_GREEN2
#define ITEM_HEADER_COLOR                       COLOR_DARK_GREEN2
#define ITEM_SELECTED_HEADER_COLOR              COLOR_YELLOW
#define ITEM_SELECTED_VALUE_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_SELECTED_TEXT_COLOR                SCREEN_DEFAULT_TEXT_FG_COLOR
#define ITEM_XBELIST_FONT_HEIGHT                17
#define ITEM_FORMATMU_FONT_HEIGHT               17
#define ITEM_OPTIONMENU_FONT_HEIGHT             17
#define ITEM_ONLINEMENU_FONT_HEIGHT             17
#define ITEM_LANGUAGEMENU_FONT_HEIGHT           17
#define ITEM_DUMPCACHEMENU_FONT_HEIGHT          17
#define ITEM_MADISPLAYMENU_FONT_HEIGHT          17
#define ITEM_OLUSERMENU_FONT_HEIGHT             17

// Memory Options Menu Screen constants
#define MENU_MEMORYOPTIONS_BUTTON_Y1            115
#define MENU_MEMORYOPTIONS_BUTTON_X1            100
#define MENU_MEMORYOPTIONS_OPTION1_TEXT         L"format"
#define MENU_MEMORYOPTIONS_OPTION2_TEXT         L"unformat"
#define MENU_MEMORYOPTIONS_OPTION3_TEXT         L"name"
#define MENU_MEMORYOPTIONS_OPTION4_TEXT         L"create file"
#define MENU_MEMORYOPTIONS_ACTION_TEXT          L"What would you like to do with"
#define MENU_MEMORYOPTOINS_ACTION_TEXT_YPOS     29.0f

// MU Name Dlg constants
#define MUNAMEDLG_MU_TEXT_YPOS                  14.0f
#define MUNAMEDLG_HEADER_YPOS                   42.0f
#define MUNAMEDLG_VALUE_XPOS                    ( MENUBOX_TEXTAREA_X_CENTER - 17.0F )

// MU Unformat Dlg constants
#define MUUNFORMATDLG_DELETE_MSG_YPOS           29.0f
#define MUUNFORMATDLG_DELETE_MSG                L"All data will be erased from"
#define MUUNFORMATDLG_FORMATTING_MSG            L"Unformatting..."
#define MUUNFORMATDLG_SUCCESS_MSG               L"Unformat Successful!"
#define MUUNFORMATDLG_FAIL_MSG                  L"Unformat Failed!"
#define MUUNFORMATDLG_MSG_PAUSE                 1500

// MU Format Dlg constants
#define MUFORMATDLG_UNAVAIL_MU_COLOR            COLOR_DARK_GREEN2
#define MUFORMATDLG_TOP_BORDER_SIZE             10.0f
#define MUFORMATDLG_AVAIL_MU_COLOR              SCREEN_DEFAULT_TEXT_FG_COLOR
#define MUFORMATDLG_SELECTED_MU_COLOR           ITEM_SELECTED_TEXT_COLOR
#define MUFORMATDLG_UNFORMATTED_MU_COLOR        COLOR_TVSAFE_YELLOW
#define MUFORMATDLG_DELETE_MSG_YPOS             29.0f
#define MUFORMATDLG_DELETE_MSG                  L"All data will be erased from"
#define MUFORMATDLG_FORMATTING_MSG              L"Formatting..."
#define MUFORMATDLG_SUCCESS_MSG                 L"Format Successful!"
#define MUFORMATDLG_FAIL_MSG                    L"Format Failed!"
#define MUFORMATDLG_MSG_PAUSE                   1500

// Error Message Menu constants
#define ERRORMSGMENU_BUTTON1_TEXT               L"ok"
#define ERRORMSGMENU_MSG_FG_COLOR               SCREEN_DEFAULT_TEXT_FG_COLOR
#define ERRORMSGMENU_MSG_BG_COLOR               SCREEN_DEFAULT_TEXT_BG_COLOR
#define ERRORMSGMENU_MSG_YPOS                    54.0f

//////////////////////////////////////////////
// Video Resolution Menu Items and Information
//////////////////////////////////////////////
#define VIDEORESMENU_FILENAME_A                 FILE_DATA_MENU_DIRECTORY_A "\\videores.mnu"


/////////////////////////////////////////
// Options Menu Items and Information
/////////////////////////////////////////
enum OptionsValues
{
    ENUM_OPTIONS_SET_GAMEREGION,
    ENUM_OPTIONS_SET_AVREGION,
    ENUM_OPTIONS_NETWORK,
    ENUM_OPTIONS_SET_VIDEORES,
    ENUM_OPTIONS_MEMORY,
    ENUM_OPTIONS_CERT_TOOLS,

    ENUM_OPTIONS_MAX_MENUITEMS
};

static WCHAR* g_pwszOptionsMenuItems[] = {
    L"Set the Xbox Game Region",
    L"Set the Xbox AV (Video) Region",
    L"Set the Xbox Network Settings",
    L"Set the XDK Launcher Video Resolution",
    L"Configure Memory Areas",
    L"Certification Tools"
};


/////////////////////////////////////////
// Online Menu Items and Information
/////////////////////////////////////////
enum OnlineValues
{
    ENUM_ONLINE_PING,
    ENUM_ONLINE_CREATEUSER,
    ENUM_ONLINE_MANAGEUSERS,

    ENUM_ONLINE_MAX_MENUITEMS
};

static WCHAR* g_pwszOnlineMenuItems[] = {
    L"Ping",
    L"Create a User Account",
    L"Manage Existing User Accounts"
};

#define ONLINE_PING_IN_PROGRESS_MSG             L"Ping in Progress... Please Wait"
#define ONLINE_PING_SUCCESS_MSG                 L"Successful"
#define ONLINE_PING_FAILED_MSG                  L"Failed!"
#define ONLINE_CREATE_USER_IN_PROGRESS_MSG      L"Creating User... Please Wait"
#define ONLINE_CREATE_USER_SUCCESS_MSG          L"Successful"
#define ONLINE_CREATE_USER_FAILED_MSG           L"Failed!"

////////////////////////////////////////////
// Memory Area Display Items and Information
////////////////////////////////////////////
#define MADISPLAYMENU_FILENAME_A                FILE_DATA_MENU_DIRECTORY_A "\\madisplay.mnu"
#define MADISPLAYMENU_TOP_BORDER_SIZE           0.0f
#define MADISPLAYMENU_UNFORMATTED_MU_COLOR      COLOR_TVSAFE_YELLOW
#define MADISPLAYMENU_AVAIL_MU_COLOR            SCREEN_DEFAULT_TEXT_FG_COLOR

///////////////////////////////////////////
// Certification Menu Items and Information
///////////////////////////////////////////
enum CertMenu
{
    CERTMENU_ITEM_REQUIREMENT10_1_11,
    CERTMENU_ITEM_REQUIREMENT10_1_12,
    CERTMENU_ITEM_REQUIREMENT10_2_01,
    CERTMENU_ITEM_REQUIREMENT10_2_02,
    CERTMENU_ITEM_REQUIREMENT10_2_07,
    CERTMENU_ITEM_REQUIREMENT10_2_10,
    CERTMENU_ITEM_REQUIREMENT10_2_18,
    CERTMENU_ITEM_REQUIREMENT10_2_19,
    CERTMENU_ITEM_REQUIREMENT10_3_04,
    CERTMENU_ITEM_REQUIREMENT10_3_11,
    CERTMENU_ITEM_REQUIREMENT10_3_14,
    CERTMENU_ITEM_REQUIREMENT10_3_15,
    CERTMENU_ITEM_REQUIREMENT10_3_26_1,
    CERTMENU_ITEM_REQUIREMENT10_3_26_2,
    CERTMENU_ITEM_REQUIREMENT10_3_26_3,
    CERTMENU_ITEM_REQUIREMENT10_3_26_4,
    CERTMENU_ITEM_REQUIREMENT10_3_33,
    CERTMENU_ITEM_REQUIREMENT10_6_05,
    CERTMENU_ITEM_CLEANUP,
    
    CERTMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_pwszCertMenuItems[] = {
    L"1-11 Remove system files: Soundtracks & Nicknames",
    L"1-12 List all global settings",
    L"2-01 Fragments Title and User data directories",
    L"2-02 Removes all soundtracks",
    L"2-07 Fills User Data directory with 4096 entries",
    L"2-10 Clears utility partition for <titleid>",
    L"2-18 Draws outline of non-HDTV safe area (white)",
    L"2-19 Draws outline of HDTV safe area (yellow)",
    L"3-02, 3-03, 3-04 Fills Title and User data directories",
    L"3-11 Lists available blocks for all memory devices",
    L"3-14 Change language setting",
    L"3-15 Change time zone setting",
    L"3-26 Create Soundtracks with localized text",
    L"3-26 Create Nicknames with localized text",
    L"3-26 Create MU names with localized text",
    L"3-26 Create Saved Game names with localized text",
    L"3-33 List all files on Xbox; hard disk and MUs",
    L"6-05 Corrupt saved games for <titleid>",
    L"Clean up temp files created by the Cert Tools"
};

#define MENU_CERT_MENU_FILENAME_A               FILE_DATA_MENU_DIRECTORY_A "\\cert.mnu"
#define MENU_CERT_NUM_ITEMS_TO_DISPLAY          8
#define MENU_CERT_PROCESSING_TEXT               L"Processing..."
#define MENU_CERT_TITLE_ID_STR_LEN              8

/////////////////////////////////////////
// Online User Menu Items and Information
/////////////////////////////////////////
#define MENU_OLUSER_MENU_FILENAME_A             FILE_DATA_MENU_DIRECTORY_A "\\oluser.mnu"
#define MENU_OLUSER_NUM_ITEMS_TO_DISPLAY        8

/////////////////////////////////////////////////
// Online User Option Menu Items and Information
/////////////////////////////////////////////////
#define MENU_OLUSEROPTION_MENU_FILENAME_A       FILE_DATA_MENU_DIRECTORY_A "\\oluseropt.mnu"

//////////////////////////////////////
// Yes / No Menu Items and Information
//////////////////////////////////////
#define MENU_YESNO_MENU_FILENAME_A              FILE_DATA_MENU_DIRECTORY_A "\\yesno.mnu"

///////////////////////////////////////////
// Dump Cache partition Information
///////////////////////////////////////////
#define MENU_DUMPCACHE_MENU_FILENAME_A          FILE_DATA_MENU_DIRECTORY_A "\\dumpcache.mnu"
#define MENU_DUMPCACHE_NUM_ITEMS_TO_DISPLAY     8
#define MENU_DUMPCACHE_NOITEM_TEXT              L"There are no Titles using a cache partition"


/////////////////////////////////////////
// AV Region Menu Items and Information
/////////////////////////////////////////
enum AVRegionMenu
{
    AVREGIONMENU_ITEM_REGION1,
    AVREGIONMENU_ITEM_REGION2,
    AVREGIONMENU_ITEM_REGION3,
    
    AVREGIONMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_pwszAVRegionMenuItems[] = {
    L"NTSC-M",
    L"NTSC-J",
    L"PAL-I"
};

#define MENU_AVREGION_MENU_FILENAME_A           FILE_DATA_MENU_DIRECTORY_A "\\avreg.mnu"
#define MENU_AVREGION_NUM_COLS                  1
#define MENU_AVREGION_NUM_ROWS                  AVREGIONMENU_ITEM_NUM_ITEMS
#define MENU_AVREGION_LINE_WIDTH                1.0f
#define MENU_AVREGION_BUTTON_Y1                 90
#define MENU_AVREGION_BUTTON_TEXT_BORDER        16
#define MENU_AVREGION_CURRENT_REGION_TEXT       L"Current Xbox AV Region: "
#define MENU_AVREGION_TEXT_Y1                   20.0f


/////////////////////////////////////////////
// EEPROM Settings Menu Items and Information
/////////////////////////////////////////////
#define EEPROMMENU_FILENAME_A                   FILE_DATA_MENU_DIRECTORY_A "\\eeprom.mnu"

#ifdef _DEBUG
    #define EEPROMMENU_NUM_ITEMS                    72
#else // _DEBUG
    #define EEPROMMENU_NUM_ITEMS                    8
#endif // _DEBUG

#define EEPROMMENU_NUM_ITEMS_TO_DISPLAY         8


/////////////////////////////////////
// SYSINFO Menu Items and Information
/////////////////////////////////////
#define SYSINFOMENU_FILENAME_A                  FILE_DATA_MENU_DIRECTORY_A "\\sysinfo.mnu"
#define SYSINFOMENU_NUM_ITEMS                   16
#define SYSINFOMENU_NUM_ITEMS_TO_DISPLAY        8

/////////////////////////////////////////
// Game Region Menu Items and Information
/////////////////////////////////////////
#define GAMEREGION_NONE 0

enum GameRegionMenu
{
    GAMEREGIONMENU_ITEM_REGION1,
    GAMEREGIONMENU_ITEM_REGION2,
    GAMEREGIONMENU_ITEM_REGION3,

    GAMEREGIONMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_pwszGameRegionMenuItems[] = {
    L"Region 1 (North America)",
    L"Region 2 (Japan)",
    L"Region 3 (Rest of the World)"
};

#define MENU_GAMEREGION_MENU_FILENAME_A         FILE_DATA_MENU_DIRECTORY_A "\\gamereg.mnu"
#define MENU_GAMEREGION_NUM_COLS                1
#define MENU_GAMEREGION_NUM_ROWS                GAMEREGIONMENU_ITEM_NUM_ITEMS
#define MENU_GAMEREGION_LINE_WIDTH              1.0f
#define MENU_GAMEREGION_BUTTON_X1               65
#define MENU_GAMEREGION_BUTTON_Y1               90
#define MENU_GAMEREGION_BUTTON_WIDTH            300
#define MENU_GAMEREGION_CURRENT_REGION_TEXT     L"Current Xbox Game Region: "
#define MENU_GAMEREGION_TEXT_Y1                 20.0f


//////////////////////////////////////////////
// Generic Keyboard Menu Items and Information
//////////////////////////////////////////////
#define MENU_GENKEYBOARD_MENU_FILENAME          FILE_DATA_MENU_DIRECTORY_A "\\genkey.mnu"


/////////////////////////////////////////////
// Generic Message Menu Items and Information
/////////////////////////////////////////////
#define MENU_MESSAGE_MENU_FILENAME              FILE_DATA_MENU_DIRECTORY_A "\\message.mnu"


//////////////////////////////////////////////
// Generic Keyboard Menu Items and Information
//////////////////////////////////////////////
#define MENU_PASSCODE_MENU_FILENAME             FILE_DATA_MENU_DIRECTORY_A "\\passcode.mnu"
#define MENU_PASSCODE_ENTER_CODE_MSG            L"Enter a 4 Control Passcode:"
#define MENU_PASSCODE_INVALID_MSG               L"You must enter 0 or 4 items"
#define MENU_PASSCODE_HELP_TEXT1                L"(Left-Thumb Button to restart)"


//////////////////////////////////////
// Language Menu Items and Information
//////////////////////////////////////

enum LanguageMenu
{
    LANGUAGEMENU_ITEM_NOT_SET,
    LANGUAGEMENU_ITEM_ENGLISH,
    LANGUAGEMENU_ITEM_JAPANESE,
    LANGUAGEMENU_ITEM_GERMAN,
    LANGUAGEMENU_ITEM_FRENCH,
    LANGUAGEMENU_ITEM_SPANISH,
    LANGUAGEMENU_ITEM_ITALIAN,

    LANGUAGEMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_pwszLanguageMenuItems[] = {
    L"No Language Set",
    L"English",
    L"Japanese",
    L"German",
    L"French",
    L"Spanish",
    L"Italian"
};

#define MENU_LANGUAGE_MENU_FILENAME_A           FILE_DATA_MENU_DIRECTORY_A "\\language.mnu"


/////////////////////////////////////
// Network Menu Items and Information
/////////////////////////////////////
enum NetworkMenu
{
    NETWORKMENU_ITEM_IPADDRESS,
    NETWORKMENU_ITEM_DEBUGIPADDRESS,
	NETWORKMENU_ITEM_PRIMARYDNS,
	NETWORKMENU_ITEM_SECONDARYDNS,
    NETWORKMENU_ITEM_SUBNETMASK,
    NETWORKMENU_ITEM_GATEWAY,
    NETWORKMENU_ITEM_MACHINENAME,
    
    NETWORKMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_pwszNetworkMenuItems[] = {
    L"Title IP address :",
    L"Debug IP address :",
	L"Primary DNS :",
	L"Secondary DNS :",
    L"Subnet mask :",
    L"Gateway :",
    L"Machine name :"
};

#define NETWORKMENU_FILENAME_A                  FILE_DATA_MENU_DIRECTORY_A "\\network.mnu"
#define NETWORKMENU_OPTIONHEADER_COLOR          ITEM_HEADER_COLOR
#define NETWORKMENU_IPADDR_YPOS                 12.0f
#define NETWORKMENU_DEBUGIPADDR_YPOS            40.0f
#define NETWORKMENU_PRIMARYDNS_YPOS				68.0f
#define NETWORKMENU_SECONDARYDNS_YPOS           96.0f
#define NETWORKMENU_SUBNET_YPOS                 124.0f
#define NETWORKMENU_GATEWY_YPOS                 152.0f
#define NETWORKMENU_MANAME_YPOS                 180.0f

static float g_fNetworkItemYPos[] = {
    NETWORKMENU_IPADDR_YPOS,             // Item 0
    NETWORKMENU_DEBUGIPADDR_YPOS,        // Item 1
	NETWORKMENU_PRIMARYDNS_YPOS,		 // Item 2
	NETWORKMENU_SECONDARYDNS_YPOS,		 // Item 3
    NETWORKMENU_SUBNET_YPOS,             // Item 4
    NETWORKMENU_GATEWY_YPOS,             // Item 5
    NETWORKMENU_MANAME_YPOS              // Item 6
};


///////////////////////////////////////////
// Keypad and Keyboard location information
///////////////////////////////////////////
#define KEYBOARD_LINE_WIDTH                     1.0f
#define KEYPAD_LINE_WIDTH                       1.0f
#define KEYBOARD_TOPROW_Y1                       75
#define KEYBOARD_TOPROW_X1                        8
#define KEYPAD_TOPROW_Y1                         75
#define KEYPAD_TOPROW_X1                        108
#define MENU_DISPSET_BUTTON_Y1                   51
#define MENU_DISPSET_BUTTON_X1                  108
#define MUFORMATDLG_BUTTON_Y1                   115
#define MUFORMATDLG_BUTTON_X1                   163
#define MUUNFORMATDLG_BUTTON_Y1                 115
#define MUUNFORMATDLG_BUTTON_X1                 163
#define ERRORMSGMENU_BUTTON_Y1                  135
#define ERRORMSGMENU_BUTTON_X1                  163
#define KEYBOARD_MACHINENAMEHEADER_YPOS         24.0f                  // Must be identical to data in 'machine.mnu'
#define KEYPAD_IPADDRHEADER_YPOS                24.0f

///////////////////////////////////////////////
// Hex Keypad location and constant information
///////////////////////////////////////////////
#define HEXKEYPAD_LINE_WIDTH                     1.0f
#define HEXKEYPAD_TEXT_Y1                        24.0f
#define HEXKEYPAD_VALUE_Y1                       47.0f
#define HEXKEYPAD_TOPROW_Y1                      75
#define HEXKEYPAD_TOPROW_X1                      70
#define HEXKEYPAD_TOPROW_LARGE_BUTTONS_X1        HEXKEYPAD_TOPROW_X1 + 183;

//
// File path and location constants
//
#define FILE_EXECUTABLE_DEVICE_PATH_A           "\\Device\\Harddisk0\\Partition1"
#define FILE_DASH_PARTITION_PATH_A              "\\Device\\Harddisk0\\Partition2"
#define FILE_DVDDRIVE_PARTITION_PATH_A          "\\Device\\CdRom0"
#define FILE_DATA_UDATA_DRIVE_LETTER_A          'X'
#define FILE_DATA_TDATA_DRIVE_LETTER_A          'V'
#define FILE_DATA_UDATA_PATH_A                  "\\Device\\Harddisk0\\partition1\\udata"
#define FILE_DATA_DVD_DRIVE_A                   "a:"
#define FILE_DEVELOPER_DRIVE_A                  "e:"
#define FILE_EXECUTABLE_DRIVE_A                 "c:"
#define FILE_EXECUTABLE_PATH_A                  "\\devkit"
#define FILE_EXECUTABLE_DIRECTORY_A             FILE_EXECUTABLE_DRIVE_A FILE_EXECUTABLE_PATH_A
#define FILE_EXECUTABLE_EXENSION_A              ".XBE"
#define FILE_DATA_DRIVE_A                       "y:"
#define FILE_DATA_DRIVE                         L"y:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE L"\\media"
#define FILE_DATA_MENU_DIRECTORY_A              FILE_DATA_DRIVE_A "\\menus"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_3DINFO_DIRECTORY_A            FILE_DATA_DRIVE_A "\\3dinfo"
#define FILE_DATA_SOUND_DIRECTORY_A             FILE_DATA_DRIVE_A "\\sounds"
#define FILE_DATA_DATA_DIRECTORY_A              FILE_DATA_DRIVE_A "\\data"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_BUTTON_FONT_FILENAME          FILE_DATA_MEDIA_DIRECTORY L"\\xboxdings.ttf"
#define FILE_DATA_XDASH_TITLEID                 "fffe0000"
#define FILE_DATA_DIR_ENTRY_PATTERN             "xdk_entry_"
#define FILE_DATA_DASHBOARD_DRIVE_A             "y:"
#define FILE_DATA_DASHBOARD_DIRECTORY_A         FILE_DATA_DASHBOARD_DRIVE_A ""  // Empty if it's the root directory
#define FILE_DATA_DASHBOARD_FILENAME_A          "XBOXDASH.XBE"
#define FILE_DATA_ONLINE_DASHBOARD_FILENAME_A   "XONLINEDASH.XBE"
#define FILE_DATA_DASHBOARD_LOCATION_A          FILE_DATA_DASHBOARD_DIRECTORY_A "\\" FILE_DATA_DASHBOARD_FILENAME_A
#define FILE_DATA_ONLINE_DASHBOARD_LOCATION_A   FILE_DATA_DASHBOARD_DIRECTORY_A "\\" FILE_DATA_ONLINE_DASHBOARD_FILENAME_A
#define FILE_DATA_DEFAULT_FILENAME_A            "DEFAULT.XBE"
#define FILE_DATA_DEFAULT_LOCATION_A            FILE_DATA_DVD_DRIVE_A "\\" FILE_DATA_DEFAULT_FILENAME_A

#define FILE_DATA_CACHE_SIZE                    524288

#define STRING_DATA_LOC_CHARS                   L"\x0E01\x30E1\x30E2\x30EA\x0001\x0002\x0003"

////////////////////////////////////
// XShell Sounds & Sound Information
////////////////////////////////////
#define SOUND_SELECT_BUTTON                     FILE_DATA_SOUND_DIRECTORY_A "\\select_button.wav"
#define SOUND_BACK_BUTTON                       FILE_DATA_SOUND_DIRECTORY_A "\\back_button.wav"
#define SOUND_MENU_ITEM_SELECT                  FILE_DATA_SOUND_DIRECTORY_A "\\menu_item_select.wav"
#define SOUND_KEYBOARD_STROKE                   FILE_DATA_SOUND_DIRECTORY_A "\\keyboard_stroke.wav"

#define SOUND_VOLUME_ADJUST                     -1200

enum ShellSounds
{
    ENUM_SOUND_SELECT = 0,
    ENUM_SOUND_BACK,
    ENUM_SOUND_MENU_ITEM_SELECT,
    ENUM_SOUND_KEYBOARD_STROKE,

    ENUM_SOUND_NUM_SOUNDS
};

// Data value limits
#define DATAVALUE_IPADDRESS_LENGTH              15
#define DATAVALUE_MACHINENAME_LENGTH            20
#define DATAVALUE_DISPLAYSETTING_TEXT_LENGTH    20

// Controller and Xbox Port and Slot Information
#define NUM_XBOX_MU_SLOTS                       8

// Joystick and Button Dead Zone and Threshold info
#define JOYSTICK_DEAD_ZONE                      20000       // 0 - 32768
#define BUTTON_THRESHOLD                        32          // 0 - 255

// USB Contant declarations for # of MU's and Controllers
static XDEVICE_PREALLOC_TYPE g_deviceTypes[] = 
{
    { XDEVICE_TYPE_GAMEPAD, 4 },
    { XDEVICE_TYPE_MEMORY_UNIT, 8 }
};

// Memory Unit BitMasks used for detection
static DWORD g_dwMUBitMask[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};

static WCHAR* g_pwszMUPortNames[] = {
    L"Memory Unit 1A",
    L"Memory Unit 1B",
    L"Memory Unit 2A",
    L"Memory Unit 2B",
    L"Memory Unit 3A",
    L"Memory Unit 3B",
    L"Memory Unit 4A",
    L"Memory Unit 4B"
};

// Display Settings
enum DisplaySettings
{
    ENUM_DISPSET_TEXT_NTSC_M = 0,
    ENUM_DISPSET_TEXT_NTSC_J,
    ENUM_DISPSET_TEXT_PAL_I,
    ENUM_DISPSET_TEXT_CUSTOM
};

static WCHAR* g_pwszDISPLAYSETTINGS[] = {
    L"NTSC (Mex/Can/US)",
    L"NTSC (Japan)",
    L"PAL (Europe)",
    L"Custom (xbsetcfg)"
};

// XShell Menu Identifiers
enum XShellMenuIds
{
    ENUM_SHELLMENUID_LAUNCH = 0,
    ENUM_SHELLMENUID_MEMORY,
    ENUM_SHELLMENUID_OPTIONS,
    ENUM_SHELLMENUID_OPTIONS_NETWORK,
    ENUM_SHELLMENUID_OPTIONS_GAMEREGION,
    ENUM_SHELLMENUID_OPTIONS_AVREGION,
    ENUM_SHELLMENUID_OPTIONS_MEMORY,
    ENUM_SHELLMENUID_OPTIONS_CERT,
    ENUM_SHELLMENUID_NETWORK_IPADDRESS,
    ENUM_SHELLMENUID_NETWORK_SUBNET,
	ENUM_SHELLMENUID_NETWORK_PRIMARYDNS,
	ENUM_SHELLMENUID_NETWORK_SECONDARYDNS,
    ENUM_SHELLMENUID_NETWORK_GATEWAY,
    ENUM_SHELLMENUID_NETWORK_MACHINENAME
};

// XShell States (bit mask)
#define SHELLSTATE_NORMAL       0
#define SHELLSTATE_ERROR        1
#define SHELLSTATE_NOCONFIG     2

// XShell Errors
// This list should stay in sync with the "g_pwszERRORCODEMSG" list
#define ERRORCODE_NO_ERROR          0
#define ERRORCODE_INVALID_XBE       1
#define ERRORCODE_UNKNOWN_ERROR     2

// This list should stay in sync with the "ERRORCODE" defines
static WCHAR* g_pwszERRORCODEMSG[] = {
    L"No Error Has Occurred",
    L"An Error Occurred Loading an Xbox Executable",
    L"An Unknown Error Has Occurred"
};

// Screen item locations
#define ITEM_MACHINENAME_DATA_X                 ( MENUBOX_TEXTAREA_X_CENTER - 17.0F )

// Default Vertex structure for the XboxVideo
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

// Vertex Definitions
#define D3DFVF_D3DVERTEX    ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE )
#define D3DFVF_TEXVERTEX    ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX1 )
#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\cworkerthread.cpp ===
/*****************************************************************************

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    CWorkerThread.cpp

Abstract:

    Base class for handling worker threads

Author:

    Josh Poley (jpoley)

*****************************************************************************/
#include "stdafx.h"
#include "cworkerthread.h"


/*****************************************************************************

Routine Description:

    LocalThreadFunct

Arguments:

    LPVOID lpParameter  - a valid CWorkerThread class

Return Value:

    0 on error, ~0 on execption, or the thread's exit value

Notes:


*****************************************************************************/
static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter)
{
    DWORD returnCode = 0;
    CWorkerThread *localPointer = (CWorkerThread*)lpParameter;

    if(!localPointer)
    {
        // a valid CWorkerThread class must be supplied via the lpParameter!
        //_ASSERT(localPointer);
        return 0;
    }

    // turn off the exit flag and set notification values
    localPointer->Lock();
    localPointer->bExit = FALSE;
    localPointer->Unlock();

    // set the thread id
    localPointer->SetThreadID(GetCurrentThreadId());

    // run the main thread function (this is the custom function)
    returnCode = localPointer->ThreadFunct();

    // invalidate the thread handle & id
    localPointer->SetThreadID((DWORD)~0x0L);
    localPointer->SetThreadHandle((DWORD)~0x0L);

    // store the return code from the main thread function
    localPointer->Lock();
    localPointer->dwThreadExitCode = returnCode;
    localPointer->Unlock();

    // exit thread
    return returnCode;
}

/*****************************************************************************

Routine Description:

    CWorkerThread::Run
    start up a worker thread

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
void CWorkerThread::Run(void)
{
    DWORD handle = _beginthread((void (__cdecl *)(void *))LocalThreadFunct, 0, this);
    SetThreadHandle(handle);
}

/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread()
{
    InitializeCriticalSection(&criter);
    SetThreadHandle((DWORD)~0x0L);
    SetThreadID((DWORD)~0x0L);

    Lock();

    dwLocalThreadID = 0;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
}

/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    DWORD localID

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread(DWORD localID)
{
    InitializeCriticalSection(&criter);
    SetThreadHandle((DWORD)~0x0L);
    SetThreadID((DWORD)~0x0L);

    Lock();

    dwLocalThreadID = localID;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
}

/*****************************************************************************

Routine Description:

    CWorkerThread::~CWorkerThread
    worker thread data destructor

Arguments:

    none

Return Value:

    none

Notes:

    If the thread does not exit, this function will be caught in an infinate 
        loop.

*****************************************************************************/
CWorkerThread::~CWorkerThread()
{
    if(GetThreadHandle() != (DWORD)~0x0L)
    {
        DWORD timeout = 1000; // start with 1 sec

        // if your code infinite loops here, you have a blocking problem
        while(!SoftBreak(timeout))
        {
            timeout *= 2;
            if(timeout == 64000)
            {
                XDBGWRN( APP_TITLE_NAME_A, "CWorkerThread::~CWorkerThread(): Possible deadlock" );
            }
        }
    }

    DeleteCriticalSection(&criter);
}

/*****************************************************************************

Routine Description:

    CWorkerThread::SoftBreak

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timedout before the thread exited

Notes:

*****************************************************************************/
BOOL CWorkerThread::SoftBreak(DWORD dwTimeOut)
{
    Lock();
    bExit = TRUE;
    Unlock();

    return WaitForExit(dwTimeOut);
}

/*****************************************************************************

Routine Description:

    CWorkerThread::WaitForExit

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timeout was reached

Notes:

*****************************************************************************/
BOOL CWorkerThread::WaitForExit(DWORD dwTimeOut)
{
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(GetThreadHandle() != (DWORD)~0x0L)
    {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
        {
            return FALSE;
        }
    }

    return TRUE;
}


/*****************************************************************************

Routine Description:

    CWorkerThread::Lock

Arguments:

    DWORD dwTimeOut - timeout value in ms
   
Return Value:

    TRUE - critical section entered, FALSE - timeout

Notes:

*****************************************************************************/
#ifdef _WIN32_WINNT // TryEnterCriticalSection only available on NT
#include "winbase.h"
BOOL CWorkerThread::Lock(DWORD dwTimeOut)
{
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(!TryEnterCriticalSection(&criter))
    {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
        {
            return FALSE;
        }
    }

    return TRUE;
}
#endif


/*****************************************************************************

Routine Description:

    CWorkerThread::SuspendThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API SuspendThread

*****************************************************************************/
DWORD CWorkerThread::SuspendThread(void)
{
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != (DWORD)~0x0L)
    {
        return ::SuspendThread((void*)dwHandle);
    }

    return 0xFFFFFFFF;
}

/*****************************************************************************

Routine Description:

    CWorkerThread::ResumeThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API ResumeThread

*****************************************************************************/
DWORD CWorkerThread::ResumeThread(void)
{
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != (DWORD)~0x0L)
    {
        return ::ResumeThread((void*)dwHandle);
    }

    return 0xFFFFFFFF;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\dumpcachemenu.cpp ===
/*****************************************************
*** dumpcachemenu.cpp
***
*** CPP file for our XShell Dump Cache partition
*** menu class.  This is a standard menu contains a
*** list of menu items to be selected.
***
*** by James N. Helm
*** May 30th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "dumpcachemenu.h"

extern CSoundCollection g_Sounds;               // Used to generate all sounds for the XShell
extern BOOL             g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
extern BOOL             g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow
extern XFONT*           g_pFont;

// Constructors
CDumpCacheMenu::CDumpCacheMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_dwTitleID( 0l ),
m_uiTopItemIndex( 0 ),
m_pCacheEntries( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "CDumpCacheMenu::CDumpCacheMenu(ex)" );

    m_uiNumItems = 0;
    SetSelectedItem( 0 );

    SetTitle( MENU_TITLE_DUMPCACHE );
}


// Destructor
CDumpCacheMenu::~CDumpCacheMenu()
{
    if( m_pCacheEntries )
    {
        delete[] m_pCacheEntries;
        m_pCacheEntries = NULL;
    }
}

// Draws a menu on to the screen
void CDumpCacheMenu::Action( CUDTexture* pTexture )
{
    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }
    
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_DUMPCACHEMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_DUMPCACHEMENU_FONT_HEIGHT;

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    if( 0 == GetNumItems() )
    {
        float XPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MENU_DUMPCACHE_NOITEM_TEXT ) / 2.0f );
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * 3 );

        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", MENU_DUMPCACHE_NOITEM_TEXT );
    }
    else
    {
        // Draw a box behind the currently highlighted choice
        float X1Pos = MENUBOX_SELECTBAR_X1;
        float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - ITEM_SELECTOR_BORDER_SPACE;
        float X2Pos = MENUBOX_SELECTBAR_X2;
        float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
    
        pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

        //
        // Draw our Menu Items
        //

        for( unsigned int x = m_uiTopItemIndex; x < ( MENU_DUMPCACHE_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); x++ )
        {
            // Make sure we don't try to draw items that don't exist
            if( x >= GetNumItems() )
            {
                break;
            }

            float XPos = MENUBOX_TEXTAREA_X1;
            float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

            pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%0.8X", m_pCacheEntries[x].dwTitleId );
        }
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CDumpCacheMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CDumpCacheMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() < (int)m_uiTopItemIndex )
                    {
                        m_uiTopItemIndex = GetSelectedItem();

                        AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() >= (int)( MENU_DUMPCACHE_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ) )
                    {
                        m_uiTopItemIndex += 1;

                        AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CDumpCacheMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, or input is disabled, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            if( GetNumItems() > 0 )
            {
                m_dwTitleID = m_pCacheEntries[GetSelectedItem()].dwTitleId;                
            }

            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT CDumpCacheMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CDumpCacheMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    return hr;
}


// Should be called whenever a user leaves the menu
void CDumpCacheMenu::Leave( CXItem* pItem )
{
    // Call our base class Leave
    CMenuScreen::Leave( pItem );

    g_bDisplayUpArrow = FALSE;
    g_bDisplayDownArrow = FALSE;
}

// This CDumpCacheMenu be called whenever the user enters this menu
void CDumpCacheMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Set our selected item to the top of the menu
    SetSelectedItem( 0 );

    // Make sure the proper arrows are displayed
    AdjustDisplayArrows();

    // Populate our CACHE Entries
    m_dwTitleID = 0l;
    m_uiNumItems = 0;
    DWORD dwNumCacheEntries = 0l;

    // First, get the number of entries in the cache
    XapiGetCachePartitions( NULL, 0l, &dwNumCacheEntries );

    if( dwNumCacheEntries > 0l )
    {
        if( m_pCacheEntries )
        {
            delete[] m_pCacheEntries;
            m_pCacheEntries = NULL;
        }

        m_pCacheEntries = new X_CACHE_DB_ENTRY[dwNumCacheEntries];
        ZeroMemory( m_pCacheEntries, sizeof( X_CACHE_DB_ENTRY ) * dwNumCacheEntries );

        XapiGetCachePartitions( m_pCacheEntries, sizeof( X_CACHE_DB_ENTRY ) * dwNumCacheEntries, &dwNumCacheEntries );

        m_uiNumItems = dwNumCacheEntries;
    }
}


// Adjust the UP and DOWN arrows on the screen
void CDumpCacheMenu::AdjustDisplayArrows()
{
    // Decide if we need to turn on the Up Arrow
    if( 0 == m_uiTopItemIndex )
    //
    // We can turn off the Up Arrow, because there is nothing above us
    //
    {
        g_bDisplayUpArrow = FALSE;
    }
    else
    //
    // We have to turn on the Up Arrow, because a menu choice is above us
    //
    {
        g_bDisplayUpArrow = TRUE;
    }

    // Decide if we need to turn on the Down Arrow
    if( ( GetNumItems() < MENU_DUMPCACHE_NUM_ITEMS_TO_DISPLAY ) ||
        ( ( m_uiTopItemIndex + MENU_DUMPCACHE_NUM_ITEMS_TO_DISPLAY ) == GetNumItems() ) )
    //
    // We can turn off the Down arrow, because nothing is below us
    //
    {
        g_bDisplayDownArrow = FALSE;
    }
    else
    //
    // We have to turn on the Down Arrow, because there are menu choices below us
    //
    {
        g_bDisplayDownArrow = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\dnsmenu.cpp ===
/*****************************************************
*** dnsmenu.cpp
***
*** CPP file for our XShell DNS address menu class.
***
*** by James Helm
*** November 13th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "dnsmenu.h"

// extern BOOL             g_bUpdateNameAddrTexture; // Determines if we need to update the machine name & IP Address
extern CXSettings       g_XboxSettings;           // Settings that are stored on the Xbox
extern CSoundCollection g_Sounds;                 // Used to generate all sounds for the XShell

// Constructors
CDNSMenu::CDNSMenu( CXItem* pParent )
: CKeypadMenu( pParent ),
m_bSetPrimaryDNS( TRUE )
{
    // Use DHCP should be disabled
    m_keyPad[3][3].setRender(FALSE);

    SetTitle( MENU_TITLE_DNS );
}


// Destructor
CDNSMenu::~CDNSMenu()
{
}


// Draws a menu on to the screen
void CDNSMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Let our base menu draw the items from the data file
    CKeypadMenu::Action( pTexture );

    pTexture->Lock();

    // Draw the DNS Title Header Information
    float fXPos;
    float fYPos = DNSMENU_ADDRESS_HEADER_TEXT_YPOS;

    if( m_bSetPrimaryDNS )
    {
        fXPos = MENUBOX_TEXTAREA_X_CENTER - GetStringPixelWidth( DNSMENU_PRIMARY_DNS_HEADER_TEXT );
        pTexture->DrawText( fXPos, fYPos, COLOR_MEDIUM_GREEN, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", DNSMENU_PRIMARY_DNS_HEADER_TEXT );
    }
    else
    {
        fXPos = MENUBOX_TEXTAREA_X_CENTER - GetStringPixelWidth( DNSMENU_SECONDARY_DNS_HEADER_TEXT );
        pTexture->DrawText( fXPos, fYPos, COLOR_MEDIUM_GREEN, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", DNSMENU_SECONDARY_DNS_HEADER_TEXT );
    }

    pTexture->Unlock();
}


// Handles input (of the BUTTONS) for the current menu
void CDNSMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )		//backspace
			{
				int len = wcslen( m_pwszAddress );
				
				if(len > 0)
				{
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

					len = len - 1;
					m_pwszAddress[len] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok" ) )		//ok
			{
                // See if the user is trying to set an address
                if( m_pwszAddress[0] != 0 )
                {
                    // Check to see if our IP Address is already in use
                    // If so, warn the user, and do NOT set the IP Address
                    char pszIPAddress[DATAVALUE_IPADDRESS_LENGTH+1];
                    _snprintf( pszIPAddress, DATAVALUE_IPADDRESS_LENGTH, "%ls", m_pwszAddress );

                    if( m_bSetPrimaryDNS )
                    {
                        if( strcmp( g_XboxSettings.GetPrimaryDNS(), pszIPAddress ) == 0 )
                        {
                            m_bUpdateTexture = TRUE;

                            // TODO: Play Error Sound

                            return;
                        }
                    }
                    else
                    {
                        if( strcmp( g_XboxSettings.GetSecondaryDNS(), pszIPAddress ) == 0 )
                        {
                            m_bUpdateTexture = TRUE;

                            // TODO: Play Error Sound

                            return;
                        }
                    }
                }

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( m_bSetPrimaryDNS )
                {
                    if( FAILED( g_XboxSettings.SetPrimaryDNS( m_pwszAddress ) ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CDNSMenu::HandleInput():Failed to store the settings!!" );
                    }
                }
                else
                {
                    if( FAILED( g_XboxSettings.SetSecondaryDNS( m_pwszAddress ) ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CDNSMenu::HandleInput():Failed to store the settings!!" );
                    }
                }

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel" ) )	//cancel
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an IP Address
                if( wcslen( m_pwszAddress ) < DATAVALUE_IPADDRESS_LENGTH )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

				    wcscat(m_pwszAddress, m_keyPad[m_xKeypos][m_yKeypos].resultChar);
                }
			}
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
			int len = wcslen( m_pwszAddress );
			
			if(len > 0)
			{
                m_bUpdateTexture = TRUE;

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

				len = len - 1;
				m_pwszAddress[len] = L'\0';
			}

            break;
        }
    }
}


// This will be called whenever the user enters this menu
void CDNSMenu::Leave( CXItem* pItem )
{
    // Call our base-class leave
    CKeypadMenu::Leave( pItem );
}

// This will be called whenever the user enters this menu
void CDNSMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Make sure we don't process the first keypress, and set our item back to 0
    m_bDropKeyPress = TRUE;
    m_xKeypos = m_yKeypos = 0;
}

// Used to determine if we should set the Title IP, or the Debug IP Address (TRUE for Title)
void CDNSMenu::SetPrimaryDNS( BOOL bSetPrimary )
{
    m_bSetPrimaryDNS = bSetPrimary;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\dnsmenu.h ===
/*****************************************************
*** dnsmenu.h
***
*** Header file for our XShell DNS address menu class.
***
*** by James Helm
*** November 13th, 2001
***
*****************************************************/

#ifndef _DNSMENU_H_
#define _DNSMENU_H_

#include "keypadmenu.h"  // Base menu type

class CDNSMenu : public CKeypadMenu
{
public:
    // Constructors and Destructors
    CDNSMenu( CXItem* pParent );
    ~CDNSMenu();

    // Public Methods
    void Enter();                           // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );    // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );

    void SetPrimaryDNS( BOOL bSetPrimary ); // Used to determine if we should set the Primary or Secondary DNS Address (TRUE for Primary)


private:
    void Leave( CXItem* pItem );            // This will be called whenever a user leaves this menu
    
    BOOL m_bSetPrimaryDNS;                  // If TRUE, the menu will set the Primary DNS Address, otherwise the Secondary DNS Address
};

#endif // _DNSMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\cworkerthread.h ===
/*****************************************************************************

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    CWorkerThread.h

Abstract:

    Base class for handling worker threads

Author:

    Josh Poley (jpoley)

Notes:

    If you get the following error:
        error C2065: '_beginthread' : undeclared identifier
    Then you are building your project in single threaded mode, switch it 
    to multi-threaded.

*****************************************************************************/

#ifndef _CWORKERTHRAD_H_
#define _CWORKERTHRAD_H_

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

// #include <winsock2.h>
// #include <crtdbg.h>
#include <process.h>    //_beginthread, _endthread

static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

/*****************************************************************************

Class Description:

    Worker thread class

Methods:



Data:



NOTE: 
    
    Remember to nest any member read/write with Lock and Unlock 

    In the implementation of the ThreadFunct function, the user must check 
        the bExit flag and exit gracefully if set.

*****************************************************************************/
class __declspec(dllexport) CWorkerThread
    {
    private:
        CRITICAL_SECTION criter;
        DWORD dwThreadHandle;
        DWORD dwThreadID;
        DWORD dwThreadExitCode;

    protected:
        BOOL bExit;

        DWORD dwLocalThreadID;

    // constructors / destructors
    public:
        CWorkerThread();
        CWorkerThread(DWORD localID);
        virtual ~CWorkerThread();

    // public access and information
    public:
        void Lock(void) { EnterCriticalSection(&criter); }
        void Unlock(void) { LeaveCriticalSection(&criter); }

        #ifdef _WIN32_WINNT
        BOOL Lock(DWORD dwTimeOut);
        #endif

        DWORD GetThreadHandle(void) { Lock(); DWORD h = dwThreadHandle; Unlock(); return h; }
        DWORD GetThreadID(void) { Lock(); DWORD id = dwThreadID; Unlock(); return id; }
        DWORD GetLocalThreadID(void) { Lock(); DWORD id = dwLocalThreadID; Unlock(); return id; }
        void  SetLocalThreadID(DWORD id) { Lock(); dwLocalThreadID = id; Unlock(); }
        DWORD GetThreadExitCode(void) { Lock(); DWORD e = dwThreadExitCode; Unlock(); return e; }
        BOOL  GetExitFlag(void) { Lock(); BOOL e = bExit; Unlock(); return e; }

        void Run(void);
        virtual BOOL SoftBreak(DWORD dwTimeOut);

        BOOL WaitForExit(DWORD dwTimeOut);

        // thread manipulation
        DWORD SuspendThread(void);
        DWORD ResumeThread(void);

    // internal functions
    private:
        void SetThreadHandle(DWORD h) { Lock(); dwThreadHandle = h; Unlock(); }
        void SetThreadID(DWORD id) { Lock(); dwThreadID = id; Unlock(); }
        void SetThreadExitCode(DWORD c) { Lock(); dwThreadExitCode = c; Unlock(); }

        friend DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

    // overrideable functions
    public:
        /*****************************************************************************
        NOTE: in the implementation of this function, the user must check 
               the bExit flag and exit gracefully if set:
        while(1)
            {
            if(GetExitFlag()) break;
            }
        *****************************************************************************/
        virtual DWORD ThreadFunct(void) { return 0; }
    };

#endif // _CWORKERTHRAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\eepromsettingsmenu.h ===
/*****************************************************
*** eepromsettingsmenu.h
***
*** Header file for our XShell EEPROM settings menu 
*** class.  This menu will display all of the
*** EEPROM settings and allow the user to scroll
*** through this list.
***
*** by James N. Helm
*** June 6th, 2001
***
*****************************************************/

#ifndef _EEPROMSETTINGSMENU_H_
#define _EEPROMSETTINGSMENU_H_

#include "menuscreen.h"

class CEEPROMSettingsMenu : public CMenuScreen
{
public:
    CEEPROMSettingsMenu( CXItem* pParent );
    ~CEEPROMSettingsMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );     // Initialize our font and settings
    void    Leave( CXItem* pItem );         // Should be called whenever a user deactivates this item
private:
    // Private Properties
    unsigned int    m_uiTopItemIndex;                                   // Index of the top item being displayed
    WCHAR*          m_pawszMenuItems[EEPROMMENU_NUM_ITEMS];             // Used to hold our displayed menu items

    // Private Methods
    void AdjustDisplayArrows();         // Adjust the UP and DOWN arrows on the screen
};

#endif // _EEPROMSETTINGSMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\dumpcachemenu.h ===
/*****************************************************
*** dumpcachemenu.h
***
*** Header file for our XShell Dump Cache partition
*** menu class.  This is a standard menu contains a
*** list of menu items to be selected.
***
*** by James N. Helm
*** May 30th, 2001
***
*****************************************************/

#ifndef _DUMPCACHEMENU_H_
#define _DUMPCACHEMENU_H_

#include "menuscreen.h"

class CDumpCacheMenu : public CMenuScreen
{
public:
    CDumpCacheMenu( CXItem* pParent );
    ~CDumpCacheMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );                         // Initialize our font and settings
    void    Leave( CXItem* pItem );                             // Should be called whenever a user deactivates this item
    DWORD   GetSelectedTitleID() { return m_dwTitleID; };       // Return the TitleID of the selected item to dump

private:
    // Private Properties
    DWORD               m_dwTitleID;            // Title ID of the selected item to dump
    unsigned int        m_uiTopItemIndex;       // Index of the top item being displayed
    DWORD               m_dwNumCacheEntries;    // Used to hold the number of cache entries we have
    PX_CACHE_DB_ENTRY   m_pCacheEntries;        // Used to hold our cache entries

    // Private Methods
    void AdjustDisplayArrows();         // Adjust the UP and DOWN arrows on the screen
};

#endif // _CERTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\eepromsettingsmenu.cpp ===
/*****************************************************
*** eepromsettingsmenu.cpp
***
*** CPP file for our XShell EEPROM settings menu 
*** class.  This menu will display all of the
*** EEPROM settings and allow the user to scroll
*** through this list.
***
*** by James N. Helm
*** June 6th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "eepromsettingsmenu.h"

void ArrayToHexString( OUT char* pszBuffer, IN ULONG cbBufferSize, IN BYTE* achArray, IN ULONG cbArraySize );

extern CXSettings           g_XboxSettings;         // Settings that are stored on the Xbox
extern CSoundCollection     g_Sounds;               // Used to generate all sounds for the XShell
extern BOOL                 g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
extern BOOL                 g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow
extern XFONT*               g_pFont;

// Constructors
CEEPROMSettingsMenu::CEEPROMSettingsMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_uiTopItemIndex( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "CEEPROMSettingsMenu::CEEPROMSettingsMenu(ex)" );

    m_uiNumItems = EEPROMMENU_NUM_ITEMS;
    SetSelectedItem( 0 );

    for( unsigned int x = 0; x < EEPROMMENU_NUM_ITEMS; x++ )
    {
        m_pawszMenuItems[x] = new WCHAR[MAX_PATH+1];
        ZeroMemory( m_pawszMenuItems[x], sizeof( WCHAR ) * MAX_PATH+1 );
    }

    SetTitle( MENU_TITLE_EEPROM );
}


// Destructor
CEEPROMSettingsMenu::~CEEPROMSettingsMenu()
{
    // Clean up memory
    for( unsigned int x = 0; x < EEPROMMENU_NUM_ITEMS; x++ )
    {
        if( m_pawszMenuItems[x] )
        {
            delete[] m_pawszMenuItems[x];
            m_pawszMenuItems[x] = NULL;
        }
    }    
}


// Draws a menu on to the screen
void CEEPROMSettingsMenu::Action( CUDTexture* pTexture )
{
    g_XboxSettings.LoadSettings();
    if( g_XboxSettings.SettingsHaveChanged() )
    {
        m_bUpdateTexture = TRUE;
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_OPTIONMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_OPTIONMENU_FONT_HEIGHT;

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    //
    // Populate our Menu Item WCHAR array
    //
    unsigned int uiIndex = 0;
    UCHAR pszOutBuffer[MAX_PATH+1];
    UCHAR pszBuffer[MAX_PATH+1];
    WCHAR pwszBuffer[MAX_PATH+1];

    // New Global Checksum
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"XDK EEPROM Checksum:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetNewGlobalChecksum() );

    // New Factory Checksum
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"XDK Factory Checksum:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetNewFactoryChecksum() );

    // New User Checksum
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"XDK User Checksum:");
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetNewUserChecksum() );

    // New Encrypted Checksum
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"XDK Encrypted Checksum:");
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetNewEncryptedChecksum() );

#ifdef _DEBUG   // If you remove this, you MUST also remove it from CONSTANTS.H, or XShell will crash

    // Factory Checksum
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Factory Checksum:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetFactoryChecksum() );

    // Factory SerialNumber
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    ZeroMemory( pszOutBuffer, MAX_PATH+1 );
    g_XboxSettings.GetFactorySerialNumber( pszBuffer, MAX_PATH );
    ArrayToHexString( (char*)pszOutBuffer, MAX_PATH, (BYTE*)pszBuffer, SETTINGS_FACTORY_SERIAL_NUM_SIZE );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Factory Serial Number:");
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %hs", pszOutBuffer );

    // Factory EthernetAddr
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    ZeroMemory( pszOutBuffer, MAX_PATH+1 );
    g_XboxSettings.GetFactoryEthernetAddr( pszBuffer, MAX_PATH );
    ArrayToHexString( (char*)pszOutBuffer, MAX_PATH, (BYTE*)pszBuffer, SETTINGS_FACTORY_ETHERNET_SIZE );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Factory Ethernet Addr:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %hs", pszOutBuffer );

    // Factory Reserved1
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    ZeroMemory( pszOutBuffer, MAX_PATH+1 );
    g_XboxSettings.GetFactoryReserved1( pszBuffer, MAX_PATH );
    ArrayToHexString( (char*)pszOutBuffer, MAX_PATH, (BYTE*)pszBuffer, SETTINGS_FACTORY_RESERVED1_SIZE );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Factory Reserved1:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %hs", pszOutBuffer );

    // Factory OnlineKey
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    ZeroMemory( pszOutBuffer, MAX_PATH+1 );
    g_XboxSettings.GetFactoryOnlineKey( pszBuffer, MAX_PATH );
    ArrayToHexString( (char*)pszOutBuffer, MAX_PATH, (BYTE*)pszBuffer, SETTINGS_FACTORY_ONLINEKEY_SIZE );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Factory Online Key:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %hs", pszOutBuffer );

    // Factory AVRegion
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Factory AV Region:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetFactoryAVRegion() );

    // Factory Reserved2
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Factory Reserved2:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetFactoryReserved2() );

    // Spacers
    //_snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"" );
    //_snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"" );

    // User Checksum
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Checksum:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserChecksum() );

    // User Time Zone Bias
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Time Zone Bias:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserTimeZoneBias() );

    // User Time Zone Std Name
    ZeroMemory( pwszBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
    g_XboxSettings.GetUserTimeZoneStdName( pwszBuffer, MAX_PATH );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Time Zone Std Name:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %ls", pwszBuffer );

    // User Time Zone Dlt Name
    ZeroMemory( pwszBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
    g_XboxSettings.GetUserTimeZoneDltName( pwszBuffer, MAX_PATH );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Time Zone Dlt Name:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %ls", pwszBuffer );

    // User Time Zone Std Date
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    XBOX_TIMEZONE_DATE* tzdate = (XBOX_TIMEZONE_DATE*) pszBuffer;
    g_XboxSettings.GetUserTimeZoneStdDate( tzdate, MAX_PATH );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Time Zone Std Date: ");
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %.2d/%.2d/%.2d/%.2d", tzdate->Month, tzdate->Day, tzdate->DayOfWeek, tzdate->Hour);

    // User Time Zone Dlt Date
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    g_XboxSettings.GetUserTimeZoneDltDate( tzdate, MAX_PATH );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Time Zone Dlt Date: ");
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %.2d/%.2d/%.2d/%.2d", tzdate->Month, tzdate->Day, tzdate->DayOfWeek, tzdate->Hour);

    // User Reserved
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    ZeroMemory( pszOutBuffer, MAX_PATH+1 );
    g_XboxSettings.GetUserReserved( (ULONG*)pszBuffer, MAX_PATH );
    ArrayToHexString( (char*)pszOutBuffer, MAX_PATH, (BYTE*)pszBuffer, SETTINGS_USER_RESERVED_SIZE * sizeof( ULONG ) );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Reserved:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %hs", pszOutBuffer );

    // User Time Zone Std Bias
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Time Zone Std Bias:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserTimeZoneStdBias() );

    // User Time Zone Dlt Bias
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Time Zone Dlt Bias:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserTimeZoneDltBias() );

    // User Language
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Language:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserLanguage() );

    // User Video Flags
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Video Flags:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserVideoFlags() );

    // User Audio Flags
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Audio Flags:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserAudioFlags() );

    // User Parental Control Games
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Parental Control Games:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserParentalControlGames() );

    // User Parental Control Password
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Parental Control Password:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserParentalControlPassword() );

    // User Parental Control Movies
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Parental Control Movies:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserParentalControlMovies() );

    // User Online IP Address
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Online IP Address:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserOnlineIpAddress() );

    // User Online DNS Address
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Online DNS Address:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserOnlineDnsAddress() );

    // User Online Default Gateway Address
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Online Default Gateway Address:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserOnlineDefaultGatewayAddress() );

    // User Online Subnet Mask
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Online Subnet Mask:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserOnlineSubnetMask() );

    // User Misc Flags
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User Misc Flags:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserMiscFlags() );

    // User DVD Region
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"User DVD Region:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetUserDvdRegion() );

    // Encrypted Checksum
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    ZeroMemory( pszOutBuffer, MAX_PATH+1 );
    g_XboxSettings.GetEncChecksum( pszBuffer, MAX_PATH );
    ArrayToHexString( (char*)pszOutBuffer, MAX_PATH, (BYTE*)pszBuffer, SETTINGS_ENC_CHECKSUM_SIZE );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Encrypted Checksum:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %hs", pszOutBuffer );

    // Encrypted Confounder
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    ZeroMemory( pszOutBuffer, MAX_PATH+1 );
    g_XboxSettings.GetEncConfounder( pszBuffer, MAX_PATH );
    ArrayToHexString( (char*)pszOutBuffer, MAX_PATH, (BYTE*)pszBuffer, SETTINGS_ENC_CONFOUNDER_SIZE );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Encrypted Confounder:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %hs", pszOutBuffer );

    // Encrypted HD Key
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    ZeroMemory( pszOutBuffer, MAX_PATH+1 );
    g_XboxSettings.GetEncHDKey( pszBuffer, MAX_PATH );
    ArrayToHexString( (char*)pszOutBuffer, MAX_PATH, (BYTE*)pszBuffer, SETTINGS_ENC_HDKEY_SIZE );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Encrypted HD Key:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  %hs", pszOutBuffer );

    // Encrypted Game Region
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Encrypted Game Region:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"  0x%.8X", g_XboxSettings.GetEncGameRegion() );
#endif // _DEBUG

    ASSERT( EEPROMMENU_NUM_ITEMS == uiIndex );

    //
    // Draw our Menu Items
    //

    for( unsigned int x = m_uiTopItemIndex; x < ( EEPROMMENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); x++ )
    {
        // Make sure we don't try to draw too many items
        if( x == GetNumItems() )
        {
            break;
        }

        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

        DWORD dwColor;
        if( ( x % 2 ) == 0 )
        {
            dwColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
        }
        else
        {
            dwColor = COLOR_DARK_GREEN2;
        }

        pTexture->DrawText( XPos, YPos, dwColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_pawszMenuItems[x] );
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CEEPROMSettingsMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CEEPROMSettingsMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( m_uiTopItemIndex != 0 )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                m_uiTopItemIndex -= EEPROMMENU_NUM_ITEMS_TO_DISPLAY;

                AdjustDisplayArrows();
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( m_uiTopItemIndex < ( GetNumItems() - EEPROMMENU_NUM_ITEMS_TO_DISPLAY ) )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                m_uiTopItemIndex += EEPROMMENU_NUM_ITEMS_TO_DISPLAY;

                AdjustDisplayArrows();
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CEEPROMSettingsMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, or input is disabled, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT CEEPROMSettingsMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CEEPROMSettingsMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    return hr;
}


// Should be called whenever a user leaves the menu
void CEEPROMSettingsMenu::Leave( CXItem* pItem )
{
    // Call our base class Leave
    CMenuScreen::Leave( pItem );

    g_bDisplayUpArrow = FALSE;
    g_bDisplayDownArrow = FALSE;
}


// This will be called whenever the user enters this menu
void CEEPROMSettingsMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Set our selected item to the top of the menu
    // SetSelectedItem( 0 );

    // Make sure the proper arrows are displayed
    AdjustDisplayArrows();
}


// Adjust the UP and DOWN arrows on the screen
void CEEPROMSettingsMenu::AdjustDisplayArrows()
{
    // Decide if we need to turn on the Up Arrow
    if( 0 == m_uiTopItemIndex )
    //
    // We can turn off the Up Arrow, because there is nothing above us
    //
    {
        g_bDisplayUpArrow = FALSE;
    }
    else
    //
    // We have to turn on the Up Arrow, because a menu choice is above us
    //
    {
        g_bDisplayUpArrow = TRUE;
    }

    // Decide if we need to turn on the Down Arrow
    if( ( m_uiTopItemIndex + EEPROMMENU_NUM_ITEMS_TO_DISPLAY ) == EEPROMMENU_NUM_ITEMS )
    //
    // We can turn off the Down arrow, because nothing is below us
    //
    {
        g_bDisplayDownArrow = FALSE;
    }
    else
    //
    // We have to turn on the Down Arrow, because there are menu choices below us
    //
    {
        g_bDisplayDownArrow = TRUE;
    }
}


// Takes a arrach of characters and converts them to a char* of hex values
void ArrayToHexString( OUT char* pszBuffer, IN ULONG cbBufferSize, IN BYTE* achArray, IN ULONG cbArraySize )
{
    if( ( NULL == pszBuffer ) || ( NULL == achArray ) )
    {
        return;
    }

    ASSERT( cbBufferSize >= ( ( cbArraySize * 2 ) + 1 ) );

    unsigned int iIndex = 0;
    unsigned int iNumChars = cbArraySize * 2;
    for ( unsigned int i = 0; i < iNumChars; i+=2 )
    {
        sprintf( pszBuffer + i, "%02X", achArray[iIndex++] );
    }

    pszBuffer[iNumChars+1] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\ErrorMsgMenu.cpp ===
/*****************************************************
*** errormsgmenu.cpp
***
*** CPP file for our XShell Error Message class.
*** This screen will display an error message and an
*** "ok" menu choice
***
*** by James N. Helm
*** January 17th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "errormsgmenu.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructors

CErrorMsgMenu::CErrorMsgMenu( CXItem* pParent )
: CKeypadMenu( pParent ),
m_dwErrorCode( ERRORCODE_NO_ERROR )
{
    XDBGTRC( APP_TITLE_NAME_A, "CErrorMsgMenu::CErrorMsgMenu(ex)" );

    GenerateKeypad();
	m_xKeypos = ERRORMSGMENU_NUM_COLS - 1;
	m_yKeypos = 0;

    SetTitle( MENU_TITLE_ERRORMSG );
}


// Destructor
CErrorMsgMenu::~CErrorMsgMenu()
{
}

// Draws a menu on to the screen
void CErrorMsgMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CKeypadMenu::Action( pTexture );

    // Display the error message specified to the user
    pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszERRORCODEMSG[m_dwErrorCode] ) / 2.0f ), ERRORMSGMENU_MSG_YPOS, ERRORMSGMENU_MSG_FG_COLOR, ERRORMSGMENU_MSG_BG_COLOR, L"%s", g_pwszERRORCODEMSG[m_dwErrorCode] );

    // Lock our texture so we can render to it
    pTexture->Unlock();
}


void CErrorMsgMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = 1;
	int ygrid  = ERRORMSGMENU_NUM_ROWS;
	int xstart = ERRORMSGMENU_BUTTON_X1;
	int ystart = ERRORMSGMENU_BUTTON_Y1;
	int width  = 103;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = ERRORMSGMENU_NUM_ROWS;
	xstart = 323;
	ystart = ERRORMSGMENU_BUTTON_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	
	currentx = xstart;
	currenty = ystart;
	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

	// Set the text of the key
    m_keyPad[0][0].defineText( ERRORMSGMENU_BUTTON1_TEXT );
}


BOOL CErrorMsgMenu::renderKeypad( CUDTexture* pTexture )
{
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < ERRORMSGMENU_NUM_COLS; x++)
	{
		for(int y = 0; y < ERRORMSGMENU_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our texture so we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    dwCharColor = ITEM_SELECTED_TEXT_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, KEYPAD_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// Handle any requests for the joystick (thumb-pad)
void CErrorMsgMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CErrorMsgMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
			if( ( m_yKeypos != 0 ) && ( m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos--;
			}
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
			if( ( m_yKeypos != ( ERRORMSGMENU_NUM_ROWS - 1 ) ) && ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos++;
			}
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CErrorMsgMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, ERRORMSGMENU_BUTTON1_TEXT ) )		//Ok
			{
                m_bDropKeyPress = TRUE;
                m_xKeypos = m_yKeypos = 0;

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    }
}


// This will be called whenever the user enters this menu
void CErrorMsgMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Set the focus to our OK button
	m_xKeypos = ERRORMSGMENU_NUM_COLS - 1;
	m_yKeypos = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gameregionmenu.cpp ===
/*****************************************************
*** gameregionmenu.cpp
***
*** CPP file for our Game Region menu class.  This
*** class will allow a user to select a new game
*** region
***
*** by James Helm
*** May 11th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "gameregionmenu.h"

extern CXSettings       g_XboxSettings;     // Xbox Settings Object
extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructor
CGameRegionMenu::CGameRegionMenu( CXItem* pParent )
: CKeypadMenu( pParent )
{
    XDBGTRC( APP_TITLE_NAME_A, "CGameRegionMenu::CGameRegionMenu( CXItem )" );

    // Set the number of items on the menu
    m_uiNumItems = GAMEREGIONMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

	GenerateKeypad();

    // Default the key to the TOP Button
	m_xKeypos = 0;
	m_yKeypos = 0;

    SetTitle( MENU_TITLE_GAMEREGION );
}


// Destructor
CGameRegionMenu::~CGameRegionMenu()
{
}

// Draws a menu on to the screen
void CGameRegionMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );
    
    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    //
	// Render the current Game Region Text
    //
    int iStringPixelWidth = GetStringPixelWidth( MENU_GAMEREGION_CURRENT_REGION_TEXT );
    float fXPos = MENUBOX_TEXTAREA_X_CENTER - ( iStringPixelWidth / 2.0f );
    float fYPos = MENU_GAMEREGION_TEXT_Y1;
    pTexture->DrawText( fXPos, fYPos, ITEM_HEADER_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", MENU_GAMEREGION_CURRENT_REGION_TEXT );

    iStringPixelWidth = GetStringPixelWidth( g_pwszGameRegionMenuItems[GetGameRegion()] );
    fXPos = MENUBOX_TEXTAREA_X_CENTER - ( iStringPixelWidth / 2.0f );
    unsigned int uiFontHeight, uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );
    fYPos = MENU_GAMEREGION_TEXT_Y1 + uiFontHeight + ITEM_VERT_SPACING;
    pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszGameRegionMenuItems[GetGameRegion()] );
    
    //
    // Draw our keypad / Game Region Menu Items
    //
	renderKeypad( pTexture );

    // Unlock our Texture
    pTexture->Unlock();
}

// Handles input (of the BUTTONS) for the current menu
void CGameRegionMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Don't update the setting unless the user is on one of the buttons
            if( 0 == m_xKeypos )
            {
                m_bUpdateTexture = TRUE;

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Set the Game Region in to the Config Sector
                HRESULT hr = SetGameRegion( m_yKeypos ); // m_yKeypos will map to the enum GameRegionMenu items
                if( FAILED( hr ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::HandleInput():Failed to set the Game Region!! Region - '%d', Error - '0x%X.08'", m_yKeypos, hr );
                }
                else
                {
                    XDBGTRC( APP_TITLE_NAME_A, "CGameRegionMenu::HandleInput():Successfully set the Game Region!!" );
                }

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    }
}

// Handles input (of the CONTROLS) for the current menu
void CGameRegionMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( m_yKeypos != 0 )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                m_yKeypos--;
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( m_yKeypos < ( GAMEREGIONMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos++;
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            break;
        }
	}
}


void CGameRegionMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = MENU_GAMEREGION_NUM_COLS;
	int ygrid  = MENU_GAMEREGION_NUM_ROWS;
	int xstart = MENU_GAMEREGION_BUTTON_X1;
	int ystart = MENU_GAMEREGION_BUTTON_Y1;
	int width  = MENU_GAMEREGION_BUTTON_WIDTH;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    // Set the text of the keys
    for( int z = 0; z < GAMEREGIONMENU_ITEM_NUM_ITEMS; z++ )
    {
        m_keyPad[0][z].defineText(g_pwszGameRegionMenuItems[z]);
    }
}


BOOL CGameRegionMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < MENU_GAMEREGION_NUM_COLS; x++)
	{
		for(int y = 0; y < MENU_GAMEREGION_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    
                    dwCharColor = ITEM_SELECTED_VALUE_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, MENU_GAMEREGION_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar );

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}

// This will be called whenever the user enters this menu
void CGameRegionMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Default the key to the currently selection option
	m_xKeypos = 0;
	m_yKeypos = GetGameRegion(); // 0;

    // Make sure our settings are up to date
    g_XboxSettings.LoadSettings();
}


// Get the Game Region in a 'menu-friendly' format
DWORD CGameRegionMenu::GetGameRegion()
{
    switch( g_XboxSettings.GetGameRegion() )
    {
    case XC_GAME_REGION_NA:
        {
            return GAMEREGIONMENU_ITEM_REGION1;

            break;
        }
    case XC_GAME_REGION_JAPAN:
        {
            return GAMEREGIONMENU_ITEM_REGION2;

            break;
        }
    case XC_GAME_REGION_RESTOFWORLD:
        {
            return GAMEREGIONMENU_ITEM_REGION3;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::GetGameRegion():Received unknown Game Region from Config Sector!! Region - '%d'", g_XboxSettings.GetGameRegion() );
            XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::GetGameRegion():Setting Game Region to - '%d'", XC_GAME_REGION_NA );

            HRESULT hr = g_XboxSettings.SetGameRegion( XC_GAME_REGION_NA );
            if( FAILED( hr ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::GetGameRegion():Failed to Set the Game Region!! Region - '%d', Error - '0x%0.8X (%d)'", XC_GAME_REGION_NA, hr, hr );
            }

            break;
        }
    }

    return GAMEREGION_NONE;
}


// Set the Game Region using our 'menu-friendly' format
HRESULT CGameRegionMenu::SetGameRegion( DWORD dwGameRegion )
{
    DWORD dwConfigSectorGameRegion = 0;

    switch( dwGameRegion )
    {
    case GAMEREGIONMENU_ITEM_REGION1:
        {
            dwConfigSectorGameRegion = XC_GAME_REGION_NA;

            break;
        }
    case GAMEREGIONMENU_ITEM_REGION2:
        {
            dwConfigSectorGameRegion = XC_GAME_REGION_JAPAN;

            break;
        }
    case GAMEREGIONMENU_ITEM_REGION3:
        {
            dwConfigSectorGameRegion = XC_GAME_REGION_RESTOFWORLD;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::SetGameRegion():Invalid Game Region Passed In - '%d'", dwGameRegion );

            return E_INVALIDARG;
        }
    }

    HRESULT hr = g_XboxSettings.SetGameRegion( dwConfigSectorGameRegion );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::SetGameRegion():Failed to set the Game Region!! Region - '%d', Error - '0x%0.8X (%d)'", dwConfigSectorGameRegion, hr, hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\ErrorMsgMenu.h ===
/*****************************************************
*** errormsgmenu.h
***
*** Header file for our XShell Error Message class.
*** This screen will display an error message and an
*** "ok" menu choice
***
*** by James N. Helm
*** January 17th, 2001
***
*****************************************************/

#ifndef _ERRORMSGMENU_H_
#define _ERRORMSGMENU_H_

#include "keypadmenu.h"

#define ERRORMSGMENU_NUM_ROWS    1
#define ERRORMSGMENU_NUM_COLS    1

class CErrorMsgMenu : public CKeypadMenu
{
public:
    CErrorMsgMenu( CXItem* pParent );
    ~CErrorMsgMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    void SetErrorCode( DWORD dwErrorCode ) { m_dwErrorCode = dwErrorCode; };    // Set the Error Code for the message the menu should display

private:
    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pTexture );

    // Properties
    DWORD m_dwErrorCode;
};

#endif // _ERRORMSGMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gameregionmenu.h ===
/*****************************************************
*** gameregionmenu.h
***
*** Header file for our Game Region menu class.  This
*** class will allow a user to select a new game
*** region
***
*** by James Helm
*** May 11th, 2001
***
*****************************************************/

#ifndef _GAMEREGIONMENU_H_
#define _GAMEREGIONMENU_H_

#include "keypadmenu.h"  // Base menu type

class CGameRegionMenu : public CKeypadMenu
{
public:
    // Constructors and Destructor
    CGameRegionMenu( CXItem* pParent );
    ~CGameRegionMenu();

    // Methods
    void Enter();                                                       // This will be called whenever the user enters this menu
    void Action( CUDTexture* pTexture );                                // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );   // Handle input to the buttons
    void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

private:
    // Properties
    Key m_keyPad[MENU_GAMEREGION_NUM_COLS][MENU_GAMEREGION_NUM_ROWS];   // Keypad

    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pTexture );

    DWORD GetGameRegion();                          // Get the Game Region in a 'menu-friendly' format
    HRESULT SetGameRegion( DWORD dwGameRegion );    // Set the Game Region using our 'menu-friendly' format
};

#endif // _GAMEREGIONMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\genkeyboardmenu.h ===
/*****************************************************
*** genkeyboardmenu.h
***
*** Header file for our Generic Keyboard Menu class.
*** This is a base menu type
***
*** by James N. Helm
*** December 6th, 2000
***
*** Modified for XDK Launcher February 13th, 2002
***
*****************************************************/

#ifndef _GENKEYBOARDMENU_H_
#define _GENKEYBOARDMENU_H_

const unsigned int gc_uiGENKEYBOARD_NUM_ROWS =         4;
const unsigned int gc_uiGENKEYBOARD_NUM_COLS =         10;

const unsigned int gc_uiGENKEYBOARD_TOPROW_Y1 =        75;
const unsigned int gc_uiGENKEYBOARD_TOPROW_X1 =        8;

const unsigned int gc_uiGENKEYBOARD_TEXTSTRING_Y1 =    24;
const unsigned int gc_uiGENKEYBOARD_VALUE_Y1 =         48;

const float gc_fGENKEYBOARD_LINE_WIDTH =               1.0f;

#include "key.h"         // TODO: Replace all instances of "Key" class with "CKey" class
#include "menuscreen.h"  // Base menu type

enum GenKeyboardStates
{
    ENUM_GENKEYBOARDSTATE_FIRST_STATE = 0,
    ENUM_GENKEYBOARDSTATE_LOWER_ALPHA = 0,
    ENUM_GENKEYBOARDSTATE_UPPER_ALPHA,
    ENUM_GENKEYBOARDSTATE_SYMBOLS,
    
    ENUM_GENKEYBOARDSTATE_NUM_STATES
};

class CGenKeyboardMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CGenKeyboardMenu( CXItem* pParent );
    virtual ~CGenKeyboardMenu();

    // Process drawing and input for a menu screen
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

    virtual HRESULT Init( char* menuFileName );             // Initialize the Menu

    HRESULT SetInfo( WCHAR* pwszTextString,                 // This should be called before the Keyboard is invoked
                     unsigned int uiLength,
                     WCHAR* pwszValueDefault = NULL );

    BOOL GetCancelled() { return m_bCancelled; };           // Used to determine if the user cancelled the keyboard
    WCHAR* GetValue() { return m_pwszValueBuffer; };        // Return a pointer to the user entered value

protected:
    // Properties
    WCHAR*          m_pwszTextString;                                           // The string that will be displayed to the user
    WCHAR           m_pwszValueBuffer[MAX_PATH+1];                              // Will hold the information that is collected
    unsigned int    m_uiLength;                                                 // Maximum size of the string to collect
    BOOL            m_bCancelled;                                               // Used to determine if the user cancelled the keyboard
	int             m_xKeypos;                                                  // Current X position on the Keyboard
    int             m_yKeypos;                                                  // Current Y position on the Keyboard
    unsigned char   m_ucState;                                                  // Used to determine which keys are displayed to the user
    BOOL            m_bShift;                                                   // Used to determine if the user has "shifted" the keyboard
	CKey            m_keyPad[gc_uiGENKEYBOARD_NUM_COLS][gc_uiGENKEYBOARD_NUM_ROWS];   // Each Key displayed on the Keyboard
    BOOL            m_bKeyFirstPress;                                           // Used to determine if the user has pressed a key before
	
    // Private Methods
	virtual void GenerateKeypad(void);                  // Create the keypad that will be used
	virtual BOOL renderKeypad( CUDTexture* pTexture );  // Draw the keypad on to the our texture
};

#endif // _GENKEYBOARDMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gatewaymenu.h ===
/*****************************************************
*** gatewaymenu.h
***
*** Header file for our XShell Gateway menu class.
***
*** by Victor Blanco
*** December 2nd, 2000
***
*****************************************************/

#ifndef _GATEWAYMENU_H_
#define _GATEWAYMENU_H_

#include "keypadmenu.h"  // Base menu type

class CGatewayMenu : public CKeypadMenu
{
public:
    // Constructors and Destructors
    CGatewayMenu( CXItem* pParent );
    ~CGatewayMenu();

    // Public Members
    void Enter();                           // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );    // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );

    // Public Methods

private:
};

#endif // _GATEWAYMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gatewaymenu.cpp ===
/*****************************************************
*** gatewaymenu.cpp
***
*** CPP file for our XShell Gateway class.
***
*** by Victor Blanco
*** December 2nd, 2000
***
*****************************************************/

#include "stdafx.h"
#include "gatewaymenu.h"

extern CXSettings       g_XboxSettings;     // Settings that are stored on the Xbox
extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructors
CGatewayMenu::CGatewayMenu( CXItem* pParent )
: CKeypadMenu( pParent )
{
    // Use DHCP should be disabled
    m_keyPad[3][3].setRender(FALSE);

    SetTitle( MENU_TITLE_GATEWAY );
}


// Destructor
CGatewayMenu::~CGatewayMenu()
{
}


// Draws a menu on to the screen
void CGatewayMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Let our base menu draw the items from the data file
    CKeypadMenu::Action( pTexture );

    pTexture->Lock();

    // Draw the Subnet Header Information
    float fXPos= MENUBOX_TEXTAREA_X_CENTER - GetStringPixelWidth( GATEWAYMENU_HEADER_TEXT );
    float fYPos = 24.0;

    pTexture->DrawText( fXPos, fYPos, COLOR_MEDIUM_GREEN, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", GATEWAYMENU_HEADER_TEXT );

    pTexture->Unlock();
}


// Handles input (of the BUTTONS) for the current menu
void CGatewayMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )		//backspace
			{
				int len = wcslen( m_pwszAddress );
				
				if(len > 0)
				{
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

					len = len - 1;
					m_pwszAddress[len] = L'\0';
				}
			}
			else if(0 == wcscmp(m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok"))		//ok
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( FAILED( g_XboxSettings.SetGateway( m_pwszAddress ) ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CGatewayMenu::HandleInput():Failed to store the settings!!" );
                }

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else if(0 == wcscmp(m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel"))	//cancel
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an Gateway
                if( wcslen( m_pwszAddress ) < DATAVALUE_IPADDRESS_LENGTH )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

				    wcscat( m_pwszAddress, m_keyPad[m_xKeypos][m_yKeypos].resultChar );
                }
			}
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
			int len = wcslen( m_pwszAddress );
			
			if(len > 0)
			{
                m_bUpdateTexture = TRUE;

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

				len = len - 1;
				m_pwszAddress[len] = L'\0';
			}
            break;
        }
    }
}


// This will be called whenever the user enters this menu
void CGatewayMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Make sure we don't process our first keypress, and set the position back to 0
    m_bDropKeyPress = TRUE;
    m_xKeypos = m_yKeypos = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gouraudgroup.h ===
#ifndef _GOURAUDGROUP_H_
#define _GOURAUDGROUP_H_

#include "gouraudobject.h"

class GouraudGroup
{

public:
    // Constructors and Destructors
    GouraudGroup( void );
	~GouraudGroup( void );

    // Public Properties
	DWORD		    m_dwTotalObjects;
	GouraudObject*  m_pObjects;

    // Public Methods
	void render( IDirect3DDevice8* pD3DDevice );
	void renderStrip( IDirect3DDevice8* pD3DDevice );
	void loadMDL( char* pszFilename, IDirect3DDevice8* pD3DDevice );
	void loadStrippedMDL( char* pszFilename, IDirect3DDevice8* pD3DDevice );
};

#endif // _GOURAUDGROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\genkeyboardmenu.cpp ===
/*****************************************************
*** genkeyboardmenu.cpp
***
*** CPP file for our Generic Keyboard Menu class.
*** This is a base menu type
***
*** by James N. Helm
*** December 6th, 2000
***
*** Modified for XDK Launcher February 13th, 2002
***
*****************************************************/

#include "stdafx.h"
#include "genkeyboardmenu.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructors
CGenKeyboardMenu::CGenKeyboardMenu( CXItem* pParent ) :
CMenuScreen( pParent ),
m_pwszTextString( NULL ),
m_uiLength( 0 ),
m_bCancelled( FALSE ),
m_xKeypos( gc_uiGENKEYBOARD_NUM_COLS - 1 ),
m_yKeypos( 0 ),
m_ucState( 0 ),
m_bShift( FALSE ),
m_bKeyFirstPress( TRUE )
{
    ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );

    GenerateKeypad();

    SetTitle( MENU_TITLE_GENKEYBOARD );
}


// Destructor
CGenKeyboardMenu::~CGenKeyboardMenu()
{
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }
}


// Initialize the Menu
HRESULT CGenKeyboardMenu::Init( char* menuFileName )
{
    HRESULT hr = CMenuScreen::Init( menuFileName );
    if( FAILED( hr ) )
        XDBGWRN( APP_TITLE_NAME_A, "CGenKeyboardMenu::Init():Failed to initialize base class!!" );

    return hr;
}


// Draws a menu on to the screen
void CGenKeyboardMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

	// Draw our keypad
	renderKeypad( pTexture );

	// Draw our User defined Text
    pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( m_pwszTextString ) / 2 ), (float)gc_uiGENKEYBOARD_TEXTSTRING_Y1, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", m_pwszTextString );

    // Draw the current value on to the screen
    pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( m_pwszValueBuffer ) / 2 ), (float)gc_uiGENKEYBOARD_VALUE_Y1, ITEM_HEADER_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", m_pwszValueBuffer );

    // Unlock our texture
    pTexture->Unlock();
}


// Handles input (of the CONTROLS) for the current menu
void CGenKeyboardMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Wrap the cursor
            if( 0 == m_yKeypos )
                m_yKeypos = gc_uiGENKEYBOARD_NUM_ROWS - 1;
            else // m_yKeypos > 0
                m_yKeypos--;

            for( int x = m_yKeypos; x >= 0; x-- )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( 0 != wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) ) )
                {
                    UpdateTexture();

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    m_yKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Wrap the cursor
            if( ( gc_uiGENKEYBOARD_NUM_ROWS - 1 ) == m_yKeypos )
                m_yKeypos = 0;
            else // m_yKeypos < ( gc_uiGENKEYBOARD_NUM_ROWS - 1 )
                m_yKeypos++;
            
            for( int x = m_yKeypos; x < gc_uiGENKEYBOARD_NUM_ROWS; x++ )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    m_yKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            // Wrap the cursor
            if( 0 == m_xKeypos )
                m_xKeypos = gc_uiGENKEYBOARD_NUM_COLS - 1;
            else // m_xKeypos > 0
                m_xKeypos--;
            
            for( int x = m_xKeypos; x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Wrap the cursor
            if( ( gc_uiGENKEYBOARD_NUM_COLS - 1 ) == m_xKeypos )
                m_xKeypos = 0;
            else // m_xKeypos < ( gc_uiGENKEYBOARD_NUM_COLS - 1 )
                m_xKeypos++;

            for( int x = m_xKeypos; x < gc_uiGENKEYBOARD_NUM_COLS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_LEFT_THUMB:    // Shift
        {
            UpdateTexture();

            m_bShift = !m_bShift;

            GenerateKeypad();

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CGenKeyboardMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"" ) )              //backspace
			{
                m_bKeyFirstPress = FALSE;

				int len = wcslen( m_pwszValueBuffer );
				
				if( len > 0 )
				{
                    UpdateTexture();

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

					m_pwszValueBuffer[len - 1] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"ok" ) )        //ok
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( GetParent() )   // Go Back one menu
                    Leave( GetParent() );
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"cancel" ) )    //cancel
			{
                m_bCancelled = TRUE;

                if( GetParent() )   // Go Back one menu
                {
                    // Play the Select Sound
                    g_Sounds.PlaySelectSound();

                    Leave( GetParent() );
                }
			}
			else
			{
                if( m_bKeyFirstPress )
                {
                    m_bKeyFirstPress = FALSE;
                    ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
                }

                // Ensure we don't exceed the limit of our buffer
                if( wcslen( m_pwszValueBuffer ) < m_uiLength )
                {
                    UpdateTexture();

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

                    if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"space" ) )    //space bar
                        wcscat( m_pwszValueBuffer, L" " );  // Space bar
                    else    // Normal character
                    {
    				    wcscat( m_pwszValueBuffer, m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar );

                        // Fix our shift state if necessary
                        if( m_bShift )
                        {
                            m_bShift = FALSE;
                            GenerateKeypad();
                        }
                    }
                }
			}

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            if( GetParent() )   // Go Back one menu
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_X:    // State Change
        {
            UpdateTexture();

            // Play the keyboard stroke sound
            g_Sounds.PlayKeyboardStrokeSound();

            m_ucState++;
            if( m_ucState >= ENUM_GENKEYBOARDSTATE_NUM_STATES )
                m_ucState = ENUM_GENKEYBOARDSTATE_FIRST_STATE;

            GenerateKeypad();

            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
            m_bKeyFirstPress = FALSE;
			int len = wcslen( m_pwszValueBuffer );
			
			if( len > 0 )
			{
                UpdateTexture();

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

				m_pwszValueBuffer[len - 1] = L'\0';
			}

            break;
        }
    case BUTTON_BLACK:  // Space
        {
            if( m_bKeyFirstPress )
            {
                m_bKeyFirstPress = FALSE;
                ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
            }

            // Ensure we don't exceed the limit of an IP Address
            if( wcslen( m_pwszValueBuffer ) < m_uiLength )
            {
                UpdateTexture();

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                wcscat( m_pwszValueBuffer, L" " );  // Space bar
            }

            break;
        }
    }
}


// Generate the kepad we will be using
void CGenKeyboardMenu::GenerateKeypad(void) 
{
	
	// First create numberpad
	int xgrid  = gc_uiGENKEYBOARD_NUM_COLS - 1;
	int ygrid  = gc_uiGENKEYBOARD_NUM_ROWS;
	int xstart = gc_uiGENKEYBOARD_TOPROW_X1;
	int ystart = gc_uiGENKEYBOARD_TOPROW_Y1;
	int width  = 32;
	int height = 32;
	int spacer = 2;
	int currentx = xstart;
	int currenty = ystart;

	WCHAR buffer[3];
    ZeroMemory( buffer, sizeof( WCHAR ) * 3 );

    unsigned short alpha = 48;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
			buffer[0] = alpha;
			m_keyPad[x][y].defineText(buffer);
			alpha++;
			
            if( ENUM_GENKEYBOARDSTATE_SYMBOLS == m_ucState )
            {
                if( 65 == alpha )
                    alpha = 33;
                if( 48 == alpha )
                    alpha = 91;
                if( 94 == alpha )
                    alpha = 95;
                if( 97 == alpha )
                    alpha = 123;
            }
            else if( ENUM_GENKEYBOARDSTATE_UPPER_ALPHA == m_ucState )
            {
                if( 58 == alpha )
                {
                    if( m_bShift )
                        alpha = 97;
                    else
                        alpha = 65;
                }
            }
            else if( ENUM_GENKEYBOARDSTATE_LOWER_ALPHA == m_ucState )
            {
                if( 58 == alpha )
                {
                    if( m_bShift )
                        alpha = 65;
                    else
                        alpha = 97;
                }
            }
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = gc_uiGENKEYBOARD_NUM_ROWS;
	xstart = gc_uiGENKEYBOARD_TOPROW_X1 + 313;
	ystart = gc_uiGENKEYBOARD_TOPROW_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	currentx = xstart;
	currenty = ystart;

	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}
	
	m_keyPad[9][0].defineText(L"ok");
	m_keyPad[9][1].defineText(L"cancel");
	m_keyPad[9][2].defineText(L"space");
	m_keyPad[9][3].defineText(L"");

}


// Draw our keypad
BOOL CGenKeyboardMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < gc_uiGENKEYBOARD_NUM_COLS; x++)
	{
		for(int y = 0; y < gc_uiGENKEYBOARD_NUM_ROWS; y++)
		{
			if( m_keyPad[x][y].getRender() && ( wcscmp( m_keyPad[x][y].m_pwszResultChar, L"place" ) != 0 ) )
			{
                // Lock our texture so that we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    
                    dwCharColor = ITEM_SELECTED_TEXT_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, gc_fGENKEYBOARD_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// This will be called whenever this menu is entered / activated
void CGenKeyboardMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Default the focus to the OK Button
	m_xKeypos = gc_uiGENKEYBOARD_NUM_COLS - 1;
    m_yKeypos = 0;

    // Make sure our cancelled option is set to FALSE
    m_bCancelled = FALSE;

    // Put the keyboard in it's original state
    m_bKeyFirstPress = TRUE;
    m_bShift = FALSE;
    m_ucState = ENUM_GENKEYBOARDSTATE_FIRST_STATE;
    GenerateKeypad();
}


// This should be called before the Keyboard is invoked
HRESULT CGenKeyboardMenu::SetInfo( WCHAR* pwszTextString, unsigned int uiLength, WCHAR* pwszValueDefault/*=NULL*/ )
{
    if( NULL == pwszTextString )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGenKeyboardMenu::SetInfo():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    if( NULL != m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }

    m_pwszTextString = new WCHAR[wcslen(pwszTextString)+1];
    wcscpy( m_pwszTextString, pwszTextString );

    // Set the length of the string
    // TODO: Check to make sure it will fit in the buffer!!
    m_uiLength = uiLength;

    // Copy the default value (if any) in to our value buffer
    if( NULL != pwszValueDefault )
        wcsncpy( m_pwszValueBuffer, pwszValueDefault, MAX_PATH );
    else
        m_pwszValueBuffer[0] = L'\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gouraudobject.h ===
#ifndef _GOURAUDOBJECT_H_
#define _GOURAUDOBJECT_H_

#include "3dobject.h"

typedef struct _XRAYVERTEX 
{
    D3DXVECTOR3 p;         // position
	D3DXVECTOR3 n;	       // normal
	DWORD       diffuse;   // diffuse color
} XRAYVERTEX;

class GouraudObject : public C3DObject
{
public:
    // Constructors and Destructors
    GouraudObject(void);
    ~GouraudObject(void);

    // Public Properties
	IDirect3DVertexBuffer8* m_pVB;
	IDirect3DIndexBuffer8*  m_pIB;

    // Initial Object description
	WORD        m_wNumVertices;
	XRAYVERTEX* m_pVertex;
	WORD        m_wNumFaces;
	Face*	    m_pFace;

    // Tri-stripped object
	DWORD		m_dwPrimitiveCount;
	DWORD       m_dwNumVertices;
	DWORD		m_dwStrippedIndexCount;  // Tristrip count
    WORD*       m_pwStrippedIndices;     // Tristrip indices

	D3DXMATRIX  m_holdMatrix;

    // Public Methods
	void render( IDirect3DDevice8* pD3DDevice );
	void renderStrip( IDirect3DDevice8* pD3DDevice );
	void loadMDL( FILE* pfInput, IDirect3DDevice8* pD3DDevice );
	void loadMDL( char* pszFilename, IDirect3DDevice8* pD3DDevice );
	void loadStrippedMDL( FILE* pfInput, IDirect3DDevice8* pD3DDevice );
};

#endif // _GOURAUDOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gouraudgroup.cpp ===
#include "stdafx.h"
#include "gouraudgroup.h"


// Constructor	
GouraudGroup::GouraudGroup(void) :
m_dwTotalObjects( 0 ),
m_pObjects( NULL )
{
}


// Destructor
GouraudGroup::~GouraudGroup(void) 
{
    // Clean up our objects
    if( m_pObjects )
    {
        delete[] m_pObjects;
        m_pObjects = NULL;
    }
}


// Render our Group
void GouraudGroup::render( IDirect3DDevice8* pD3DDevice )
{
	for( DWORD i = 0; i < m_dwTotalObjects; ++i )
	{
		m_pObjects[i].render( pD3DDevice );
	}
}


// Render our Group
void GouraudGroup::renderStrip( IDirect3DDevice8* pD3DDevice )
{
	for( DWORD i = 0; i < m_dwTotalObjects; ++i )
	{
		m_pObjects[i].renderStrip( pD3DDevice );
	}
}


// Load the models for our group
void GouraudGroup::loadMDL( char* pszFilename, IDirect3DDevice8* pD3DDevice )
{
	FILE* pfInput;

    pfInput = fopen( pszFilename, "rb" );

    if( !pfInput )
    {
        XDBGERR( APP_TITLE_NAME_A, "GouraudGroup::loadMDL( char* ):Failed to open the file - '%s'!!", pszFilename );

        return;
    }
    
	fread( &m_dwTotalObjects, sizeof(DWORD), 1, pfInput );

    // Clean up our objects
    if( m_pObjects )
    {
        delete[] m_pObjects;
        m_pObjects = NULL;
    }

    m_pObjects = new GouraudObject[m_dwTotalObjects];
	
    for( DWORD i = 0; i < m_dwTotalObjects; ++i )
	{	
		m_pObjects[i].loadMDL( pfInput, pD3DDevice );
	}
	
    fclose( pfInput );
}


// Load the models for our group
void GouraudGroup::loadStrippedMDL( char* pszFilename, IDirect3DDevice8* pD3DDevice )
{
	FILE* pfInput;

	pfInput = fopen( pszFilename, "rb" );

    if( !pfInput )
    {
        XDBGERR( APP_TITLE_NAME_A, "GouraudGroup::loadStrippedMDL( char* ):Failed to open the file - '%s'!!", pszFilename );

        return;
    }

	fread( &m_dwTotalObjects, sizeof(DWORD), 1, pfInput );

    // Clean up our objects
    if( m_pObjects )
    {
        delete[] m_pObjects;
        m_pObjects = NULL;
    }
	
    m_pObjects = new GouraudObject[m_dwTotalObjects];
	
    for( DWORD i = 0; i < m_dwTotalObjects; ++i )
	{	
		m_pObjects[i].loadStrippedMDL( pfInput, pD3DDevice );

        XDBGTRC( APP_TITLE_NAME_A, "GouraudGroup::loadStrippedMDL( char* ):Loaded object %d of %d to file", i + 1, m_dwTotalObjects );
	}

    fclose( pfInput );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gouraudobject.cpp ===
#include "stdafx.h"
#include "gouraudobject.h"


// Constructor
GouraudObject::GouraudObject( void ) :
m_pVB( NULL ),
m_pIB( NULL ),
m_wNumVertices( 0 ),
m_pVertex( NULL ),
m_wNumFaces( 0 ),
m_pFace( NULL ),
m_dwPrimitiveCount( 0 ),
m_dwNumVertices( 0 ),
m_dwStrippedIndexCount( 0 ),
m_pwStrippedIndices( NULL )
{

}

// Destructor
GouraudObject::~GouraudObject( void ) 
{
    // Clean up our Vertex Buffer
    if( m_pVB )
    {
        m_pVB->Release();
        m_pVB = NULL;
    }

    // Clean up our Index Buffer
    if( m_pIB )
    {
        m_pIB->Release();
        m_pIB = NULL;
    }

    // Clean up our vertices
    if( m_pVertex )
    {
        delete[] m_pVertex;
        m_pVertex = NULL;
    }

    // Clean up our faces
    if( m_pFace )
    {
        delete[] m_pFace;
        m_pFace = NULL;
    }

    // Clean up our Stripped Indices
    if( m_pwStrippedIndices )
    {
        delete[] m_pwStrippedIndices;
        m_pwStrippedIndices = NULL;
    }
}


void GouraudObject::render( IDirect3DDevice8 *pD3DDevice )
{
	pD3DDevice->SetTransform( D3DTS_WORLD, &m_ObjectMatrix );

	pD3DDevice->SetStreamSource( 0, m_pVB, sizeof(XRAYVERTEX) );
	pD3DDevice->SetIndices( m_pIB, 0 );

	pD3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,
		                              0,
									  m_wNumVertices,
									  0,
									  m_wNumFaces );
}

void GouraudObject::renderStrip( IDirect3DDevice8* pD3DDevice )
{
	pD3DDevice->SetTransform( D3DTS_WORLD, &m_ObjectMatrix );

	pD3DDevice->SetStreamSource( 0, m_pVB, sizeof(XRAYVERTEX));
	pD3DDevice->SetIndices( m_pIB, 0 );

	pD3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP , 
		                              0, 
									  m_dwNumVertices, 
									  0, 
									  m_dwPrimitiveCount );
}

void GouraudObject::loadMDL( char* pszFilename, IDirect3DDevice8* pD3DDevice )
{
	FILE* pfInput;
	int   iTotalObjects;

	pfInput = fopen( pszFilename, "rb" );

    if( !pfInput )
    {
        XDBGERR( APP_TITLE_NAME_A, "GouraudObject::loadMDL( char* ):Failed to open the file - '%s'!!", pszFilename );

        return;
    }

	fread( &iTotalObjects, sizeof(DWORD), 1, pfInput );
	loadMDL( pfInput, pD3DDevice );
	fclose( pfInput );
}

void GouraudObject::loadMDL( FILE* pfInput, IDirect3DDevice8* pD3DDevice )
{
	//
	// Read vertices, normals, and diffuse for object
	//	
	fread( &m_wNumVertices, sizeof(WORD), 1, pfInput );

    // Clean up our vertices
    if( m_pVertex )
    {
        delete[] m_pVertex;
        m_pVertex = NULL;
    }

	m_pVertex = new XRAYVERTEX[m_wNumVertices];
	
    for( WORD i = 0; i < m_wNumVertices; ++i )
	{
		fread( &m_pVertex[i].p.x, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].p.y, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].p.z, sizeof(float), 1, pfInput );

		fread( &m_pVertex[i].n.x, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].n.y, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].n.z, sizeof(float), 1, pfInput );

		fread( &m_pVertex[i].diffuse, sizeof(DWORD), 1, pfInput );
	}

	//
	// Read face list for object
	//
	fread( &m_wNumFaces, sizeof(WORD), 1, pfInput );

    // Clean up our faces
    if( m_pFace )
    {
        delete[] m_pFace;
        m_pFace = NULL;
    }

	m_pFace = new Face[m_wNumFaces];

	for( i = 0; i < m_wNumFaces; ++i )
	{
		fread( &m_pFace[i].point[0], sizeof(WORD), 1, pfInput );
		fread( &m_pFace[i].point[1], sizeof(WORD), 1, pfInput );
		fread( &m_pFace[i].point[2], sizeof(WORD), 1, pfInput );
	}

	D3DXMatrixIdentity( &m_ObjectMatrix );
	m_TranslateVector.x = 0.0f;
	m_TranslateVector.y = 0.0f;
	m_TranslateVector.z = 0.0f;
	m_TranslateVector.w = 1.0f;

	//
	// Create a vertex buffer for the object
	//

    // Make sure this is cleared before we create another one
    if( m_pVB )
    {
        m_pVB->Release();
        m_pVB = NULL;
    }

    if( FAILED( pD3DDevice->CreateVertexBuffer( m_wNumVertices * sizeof(XRAYVERTEX),
                                                0,
                                                D3DFVF_D3DVERTEX,
                                                D3DPOOL_DEFAULT, 
                                                &m_pVB ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudObject::loadMDL( FILE* ):Failed to create a Vertex Buffer!!" );
	}

	//
	// Fill the vertex buffer
	//
	XRAYVERTEX* pVertices;
	if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudObject::loadMDL( FILE* ):Failed to lock the Vertex Buffer!!" );
	}

	for( i = 0; i < m_wNumVertices; ++i )
	{
		pVertices[i] = m_pVertex[i];
	}
	
    m_pVB->Unlock();


	//
	// Create an index buffer for the object
	//

    // Make sure this is cleared before we create another one
    if( m_pIB )
    {
        m_pIB->Release();
        m_pIB = NULL;
    }

	if( FAILED( pD3DDevice->CreateIndexBuffer( m_wNumFaces * 3 * sizeof(WORD),
                                               D3DUSAGE_WRITEONLY,
                                               D3DFMT_INDEX16,
                                               D3DPOOL_DEFAULT,
                                               &m_pIB ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudObject::loadMDL( FILE* ):Failed to create an Index Buffer!!" );
	}

	WORD* pIndices;
	if( FAILED( m_pIB->Lock( 0, 0, (BYTE**)&pIndices, 0 ) ) )  
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudObject::loadMDL( FILE* ):Failed to lock the Index Buffer!!" );
	}

	int counter = 0;
	for( i = 0; i < m_wNumFaces; ++i )
	{
		pIndices[counter++] = m_pFace[i].point[0];
		pIndices[counter++] = m_pFace[i].point[1];
		pIndices[counter++] = m_pFace[i].point[2];
	}
	
	m_pIB->Unlock();

}

void GouraudObject::loadStrippedMDL( FILE* pfInput, IDirect3DDevice8 *pD3DDevice )
{
	//
	// Read vertices, normals, and diffuse for object
	//
	fread( &m_dwNumVertices, sizeof(DWORD), 1, pfInput );

    // Clean up our vertices
    if( m_pVertex )
    {
        delete[] m_pVertex;
        m_pVertex = NULL;
    }

	m_pVertex = new XRAYVERTEX[m_dwNumVertices];

	for( DWORD i = 0; i < m_dwNumVertices; ++i )
	{
		fread( &m_pVertex[i].p.x, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].p.y, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].p.z, sizeof(float), 1, pfInput );

		fread( &m_pVertex[i].n.x, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].n.y, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].n.z, sizeof(float), 1, pfInput );

		fread( &m_pVertex[i].diffuse, sizeof(DWORD), 1, pfInput );
	}

	//
	// Read face list for object
	//
	fread( &m_dwStrippedIndexCount, sizeof(DWORD), 1, pfInput );

    // Clean up our Stripped Indices
    if( m_pwStrippedIndices )
    {
        delete[] m_pwStrippedIndices;
        m_pwStrippedIndices = NULL;
    }

	m_pwStrippedIndices = new WORD[m_dwStrippedIndexCount];

	for( i = 0; i < m_dwStrippedIndexCount; ++i )
	{
		fread( &m_pwStrippedIndices[i], sizeof(WORD), 1, pfInput );
	}

	m_dwPrimitiveCount = m_dwStrippedIndexCount - 2;

	D3DXMatrixIdentity( &m_ObjectMatrix );
	m_TranslateVector.x = 0.0f;
	m_TranslateVector.y = 0.0f;
	m_TranslateVector.z = 0.0f;
	m_TranslateVector.w = 1.0f;

	//
	// Create and fill the vertex buffer
	//
    
    // Make sure this is cleared before we create another one
    if( m_pVB )
    {
        m_pVB->Release();
        m_pVB = NULL;
    }
 	
    if( FAILED( pD3DDevice->CreateVertexBuffer( m_dwNumVertices * sizeof(XRAYVERTEX),
                                                0, //D3DUSAGE_WRITEONLY,
                                                D3DFVF_D3DVERTEX,
                                                D3DPOOL_DEFAULT, 
                                                &m_pVB ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudObject::loadStrippedMDL( FILE* ):Failed to create a Vertex Buffer!!" );
	}

	XRAYVERTEX* pVertices;
	if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudObject::loadStrippedMDL( FILE* ):Failed to lock the Vertex Buffer!!" );
	}
	
    memcpy( pVertices, m_pVertex, m_dwNumVertices * sizeof(XRAYVERTEX) );

	m_pVB->Unlock();

	//
	// Create an index buffer for the object
	//

    // Make sure this is cleared before we create another one
    if( m_pIB )
    {
        m_pIB->Release();
        m_pIB = NULL;
    }
	if( FAILED( pD3DDevice->CreateIndexBuffer( m_dwStrippedIndexCount * sizeof(WORD),
                                               D3DUSAGE_WRITEONLY,
                                               D3DFMT_INDEX16,
                                               D3DPOOL_DEFAULT,
                                               &m_pIB ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudObject::loadStrippedMDL( FILE* ):Failed to create an Index Buffer!!" );
	}

    WORD* pIndices;
	if( FAILED( m_pIB->Lock( 0, 0, (BYTE**)&pIndices, 0 ) ) )  
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudObject::loadStrippedMDL( FILE* ):Failed to lock the Index Buffer!!" );
	}
	
    memcpy( pIndices, m_pwStrippedIndices, m_dwStrippedIndexCount * sizeof(WORD) );
	
	m_pIB->Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\key.h ===
#ifndef _KEY_H
#define _KEY_H

class CKey
{
public:
	int m_iXOrigin, m_iYOrigin;		// x,y coordinate of the key's upper left pixel
	int m_iWidth, m_iHeight;		// width and height of the key
	DWORD m_dwSelectColor;			// color to hilight the key with upon selection
	WCHAR* m_pwszResultChar;        // value attached to the key
	BOOL m_fRender;				    // should the key be rendered?

	// Constructors and Destructors
	CKey();
	~CKey();

	void define( int iX, int iY, int iW, int iH, DWORD dwColor );
	void defineText( WCHAR* pwszResult );
	void setRender( BOOL fValue );
	BOOL getRender( void );
};

#endif // _KEY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gouraudtexobject.h ===
#ifndef _GOURAUDTEXOBJECT_H_
#define _GOURAUDTEXOBJECT_H_

#include "3dobject.h"

typedef struct _TEXVERTEX 
{
    D3DXVECTOR3 p;         // position
	D3DXVECTOR3 n;	       // normal
	DWORD       diffuse;   // diffuse color
	FLOAT       tu, tv;    // The texture coordinates
} TEXVERTEX;

class TexFace : public Face
{

public:
    WORD m_wTexPoint[3];

};

class TextureVert
{

public:
	FLOAT m_tu, m_tv;

};

class GouraudTexObject : public C3DObject
{

public:
    // Constructors and Destructors
    GouraudTexObject(void);
    ~GouraudTexObject(void);

    // Public Properties
	char		            m_pszTextureName[30];
	WORD                    m_wNumVertices;
	TEXVERTEX*              m_pVertex;
	WORD                    m_wNumFaces;
	TexFace*                m_pFace;

    WORD                    m_wNumTexVertices;
    TextureVert*            m_pTextureVertex;

	IDirect3DVertexBuffer8* m_pVB;
	LPDIRECT3DTEXTURE8      m_pTexture;

	D3DXMATRIX              m_HoldMatrix;

	// Public Methods
	void loadTexture( char texture[30], IDirect3DDevice8* pd3dDevice );
	void render( IDirect3DDevice8* pd3dDevice );
	void loadMDL( FILE *input, IDirect3DDevice8* pd3dDevice );
	void loadMDL( char *filename, IDirect3DDevice8* pd3dDevice );
};

#endif // _GOURAUDTEXOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\hexkeypadmenu.h ===
/*****************************************************
*** hexkeypadmenu.h
***
*** Header file for our XShell hex keypad menu class.
*** This class will allow the user to input a hex
*** value, and return that value to the caller.
***
*** by James Helm
*** May 28th, 2001
***
*****************************************************/

#ifndef _HEXKEYPADMENU_H_
#define _HEXKEYPADMENU_H_

#define HEXKEYPAD_NUM_COLS    4
#define HEXKEYPAD_NUM_ROWS    6

#include "menuscreen.h"  // Base menu type

class CHexKeypadMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CHexKeypadMenu( CXItem* pParent );
    virtual ~CHexKeypadMenu();

    // Methods
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    HRESULT SetInfo( WCHAR* pwszTextString,                 // This should be called before the Key pad is invoked
                     WCHAR* pwszValueBuffer,
                     unsigned int uiValueSize );

protected:
    // Properties
    WCHAR* m_pwszTextString;                                // The string that will be displayed to the user
    WCHAR* m_pwszValueBuffer;                               // Will hold the information that is collected
    unsigned int m_uiValueSize;                             // The length of the value you wish to collect
    BOOL m_bDropKeyPress;                                   // Used to prevent the 'instant' keypress when a user navigates in here
	int m_xKeypos;                                          // X Position of the current Key on the Keypad
    int m_yKeypos;                                          // Y Position of the current Key on the Keypad
	Key m_keyPad[HEXKEYPAD_NUM_ROWS][HEXKEYPAD_NUM_COLS];   // Information for each Key appearing on the Keypad

    // Private Methods
	virtual void GenerateKeypad(void);                      // Creates the keypad
	virtual BOOL renderKeypad( CUDTexture* pTexture );      // Renders the Keypad on to the texture
};

#endif // _HEXKEYPADMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\hexkeypadmenu.cpp ===
/*****************************************************
*** hexkeypadmenu.cpp
***
*** CPP file for our XShell hex keypad menu class.
*** This class will allow the user to input a hex
*** value, and return that value to the caller.
***
*** by James Helm
*** May 28th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "hexkeypadmenu.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell


// Constructors
CHexKeypadMenu::CHexKeypadMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_pwszTextString( NULL ),
m_pwszValueBuffer( NULL ),
m_uiValueSize( 0 ),
m_bDropKeyPress( TRUE )
{
	GenerateKeypad();

    // Default the focus to the OK button
	m_xKeypos = HEXKEYPAD_NUM_ROWS - 1;
	m_yKeypos = 0;

    SetTitle( MENU_TITLE_HEXKEYPAD );
}


// Destructor
CHexKeypadMenu::~CHexKeypadMenu()
{
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }
}


// Draws a menu on to the screen
void CHexKeypadMenu::Action( CUDTexture* pTexture )
{
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

	// Draw our keypad
	renderKeypad( pTexture );

	// Draw our User defined Text
    pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( m_pwszTextString ) / 2.0f ), HEXKEYPAD_TEXT_Y1, ITEM_HEADER_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_pwszTextString );

    // Draw the current value on to the screen
    pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( m_pwszValueBuffer ) / 2.0f ), HEXKEYPAD_VALUE_Y1, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_pwszValueBuffer );
    
    // Unlock our texture
    pTexture->Unlock();
}


// Handle the Joystick Input
void CHexKeypadMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CHexKeypadMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            BOOL bWrap = TRUE;
            for( int x = ( m_yKeypos - 1 ); x >= 0; x-- )
            {
                if( m_keyPad[m_xKeypos][x].getRender() )
                {
                    m_yKeypos = x;
                    bWrap = FALSE;

                    break;
                }
            }

            if( bWrap )
            {
                m_yKeypos = HEXKEYPAD_NUM_COLS - 1;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_yKeypos--;
                }
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            BOOL bWrap = TRUE;
            for( int x = ( m_yKeypos + 1 ); x < HEXKEYPAD_NUM_COLS; x++ )
            {
                if( m_keyPad[m_xKeypos][x].getRender() )
                {
                    m_yKeypos = x;
                    bWrap = FALSE;
                
                    break;
                }
            }

            if( bWrap )
            {
                m_yKeypos = 0;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_yKeypos++;
                }
            }
            
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            BOOL bWrap = TRUE;
            for( int x = ( m_xKeypos - 1 ); x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].resultChar, L"place" ) != 0 ) )
                {
                    m_xKeypos = x;
                    bWrap = FALSE;
                
                    break;
                }
            }

            if( bWrap )
            {
                m_xKeypos = HEXKEYPAD_NUM_ROWS - 1;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_xKeypos--;
                }
            }

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            BOOL bWrap = TRUE;
            for( int x = ( m_xKeypos + 1 ); x < HEXKEYPAD_NUM_ROWS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].resultChar, L"place" ) != 0 ) )
                {
                    m_xKeypos = x;
                    bWrap = FALSE;
                
                    break;
                }
            }
            
            if( bWrap )
            {
                m_xKeypos = 0;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_xKeypos++;
                }
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CHexKeypadMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )                //backspace
			{
				int len = wcslen( m_pwszValueBuffer );
				
				if( len > 0 )
				{
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

					m_pwszValueBuffer[len - 1] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok" ) )          //ok
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel" ) )      //cancel
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Set the text to nothing
                m_pwszValueBuffer[0] = '\0';

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an IP Address
                if( wcslen( m_pwszValueBuffer ) < m_uiValueSize )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

				    wcscat( m_pwszValueBuffer, m_keyPad[m_xKeypos][m_yKeypos].resultChar );
                }
			}
            break;
        }
    case BUTTON_B:
        {
            // Set the text to nothing
            m_pwszValueBuffer[0] = '\0';

            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
			int len = wcslen( m_pwszValueBuffer );
			
			if( len > 0 )
			{
                m_bUpdateTexture = TRUE;

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

				m_pwszValueBuffer[len - 1] = L'\0';
			}

            break;
        }
    }
}


void CHexKeypadMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = HEXKEYPAD_NUM_ROWS - 1;
	int ygrid  = HEXKEYPAD_NUM_COLS;
	int xstart = HEXKEYPAD_TOPROW_X1;
	int ystart = HEXKEYPAD_TOPROW_Y1;
	int width  = 32;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

    for(int y = 0; y < ygrid; y++)
    {
	    for(int x = 0; x < xgrid; x++)
	    {
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
            if( 1 == x )
            {
                currentx += width + ( spacer * 3 );
            }
            else
            {
                currentx += width + spacer;
            }
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = HEXKEYPAD_NUM_COLS;
	xstart = HEXKEYPAD_TOPROW_LARGE_BUTTONS_X1;
	ystart = HEXKEYPAD_TOPROW_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	
	currentx = xstart;
	currenty = ystart;
    for(int y = 0; y < ygrid; y++)
    {
	    for(int x = xbase; x < (xbase + xgrid); x++)
	    {
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
            currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

	// Set the text of the keys
	m_keyPad[0][0].defineText(L"A");        m_keyPad[1][0].defineText(L"D");        m_keyPad[2][0].defineText(L"1");        m_keyPad[3][0].defineText(L"2");    m_keyPad[4][0].defineText(L"3");        m_keyPad[5][0].defineText(L"ok");
    m_keyPad[0][1].defineText(L"B");        m_keyPad[1][1].defineText(L"E");        m_keyPad[2][1].defineText(L"4");        m_keyPad[3][1].defineText(L"5");    m_keyPad[4][1].defineText(L"6");        m_keyPad[5][1].defineText(L"cancel");
    m_keyPad[0][2].defineText(L"C");        m_keyPad[1][2].defineText(L"F");        m_keyPad[2][2].defineText(L"7");        m_keyPad[3][2].defineText(L"8");    m_keyPad[4][2].defineText(L"9");        m_keyPad[5][2].defineText(L"");
    m_keyPad[0][3].defineText(L"place");    m_keyPad[1][3].defineText(L"place");    m_keyPad[2][3].defineText(L"place");    m_keyPad[3][3].defineText(L"0");    m_keyPad[4][3].defineText(L"place");    m_keyPad[5][3].defineText(L"place");

    // Make sure we don't render any buttons that are place holders
    for(int x = 0; x < HEXKEYPAD_NUM_ROWS; x++)
    {
	    for(int y = 0; y < HEXKEYPAD_NUM_COLS; y++)
        {
            if( 0 == wcscmp( m_keyPad[x][y].resultChar, L"place" ) )
            {
                m_keyPad[x][y].setRender( FALSE );
            }
        }
    }
}


BOOL CHexKeypadMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < HEXKEYPAD_NUM_ROWS; x++)
	{
		for(int y = 0; y < HEXKEYPAD_NUM_COLS; y++)
		{
			if( m_keyPad[x][y].getRender() )
			{
                // XDBGWRN( APP_TITLE_NAME_A, "CHexKeypadMenu::renderKeypad():x - '%d', y - '%d'", x, y );

                // Lock our Texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
                    // Draw the selector box around the currently highlighted number
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    
                    dwCharColor = ITEM_SELECTED_VALUE_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, HEXKEYPAD_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// This will be called whenever this menu is entered / activated
void CHexKeypadMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Make sure we don't process the first keypress
    m_bDropKeyPress = TRUE;

    // Default the focus to the OK button
	m_xKeypos = HEXKEYPAD_NUM_ROWS - 1;
	m_yKeypos = 0;
}


// This should be called before the Key pad is invoked
HRESULT CHexKeypadMenu::SetInfo( WCHAR* pwszTextString, WCHAR* pwszValueBuffer, unsigned int uiValueSize )
{
    // Check to make sure we were passed valid buffers
    if( ( !pwszTextString ) || ( !pwszValueBuffer ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CHexKeypadMenu::SetInfo():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    // Clean up memory if necessary
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }

    // Set our properties
    int iStrLen = wcslen( pwszTextString );
    m_pwszTextString = new WCHAR[iStrLen + 1];
    if( NULL == m_pwszTextString )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CHexKeypadMenu::SetInfo():Failed to allocate memory!!" );

        return E_FAIL;
    }
    else
    {
        ZeroMemory( m_pwszTextString, sizeof( WCHAR ) * ( iStrLen + 1 ) );
        wcscpy( m_pwszTextString, pwszTextString );
    }
    
    m_pwszValueBuffer = pwszValueBuffer;
    m_uiValueSize = uiValueSize;

    // Clear Memory
    // m_pwszValueBuffer[0] = L'\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\key.cpp ===
#include "stdafx.h"
#include "key.h"

// Key Class by Victor Blanco
CKey::CKey()
:
m_iXOrigin( 0 ),
m_iYOrigin( 0 ),
m_iWidth( 0 ),
m_iHeight( 0 ),		
m_dwSelectColor( 0x00000000 ),
m_fRender( TRUE ),
m_pwszResultChar( NULL )
{
}

CKey::~CKey()
{
    if( m_pwszResultChar )
    {
        delete[] m_pwszResultChar;
        m_pwszResultChar = NULL;
    }
}

void CKey::define( int iX, int iY, int iW, int iH, DWORD dwColor )
{
	m_iXOrigin = iX;
	m_iYOrigin = iY;
	m_iWidth = iW;
	m_iHeight = iH;		
	m_dwSelectColor = dwColor;	
}

void CKey::defineText( WCHAR* pwszResult )
{
    if( !pwszResult )
    {
        return;
    }

    // Make sure we don't cause a memory leak
    if( m_pwszResultChar )
    {
        delete[] m_pwszResultChar;
        m_pwszResultChar = NULL;
    }

    m_pwszResultChar = _wcsdup( pwszResult );
}

void CKey::setRender( BOOL fValue )
{
	m_fRender = fValue;
}

BOOL CKey::getRender( void )
{
	return m_fRender;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\ipmenu.h ===
/*****************************************************
*** ipmenu.h
***
*** Header file for our XShell IP address menu class.
***
*** by Victor Blanco
*** December 2nd, 2000
***
*****************************************************/

#ifndef _IPMENU_H_
#define _IPMENU_H_

#include "keypadmenu.h"  // Base menu type

class CIPMenu : public CKeypadMenu
{
public:
    // Constructors and Destructors
    CIPMenu( CXItem* pParent );
    ~CIPMenu();

    // Public Methods
    void Enter();                           // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );    // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );

    void SetTitleIP( BOOL bSetTitle );      // Used to determine if we should set the Title IP, or the Debug IP Address (TRUE for Title)


private:
    void Leave( CXItem* pItem );            // This will be called whenever a user leaves this menu
    
    BOOL m_bSetTitleIP;                     // If TRUE, the menu will set the TITLE IP Address, otherwise the DEBUG IP Address
    BOOL m_bDisplayInUseMessage;            // Used when the IP Address is already in use
};

#endif // _IPMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\gouraudtexobject.cpp ===
#include "stdafx.h"
#include "gouraudtexobject.h"

// Constructor
GouraudTexObject::GouraudTexObject( void ) :
m_wNumVertices( 0 ),
m_pVertex( NULL ),
m_wNumFaces( 0 ),
m_pFace( NULL ),
m_pVB( NULL ),
m_pTexture( NULL ),
m_wNumTexVertices( 0 ),
m_pTextureVertex( NULL )
{
    ZeroMemory( m_pszTextureName, 30 );
}

// Desctructor
GouraudTexObject::~GouraudTexObject( void )
{
    // Clean up our vertices
    if( m_pVertex )
    {
        delete[] m_pVertex;
        m_pVertex = NULL;
    }

    // Clean up our faces
    if( m_pFace )
    {
        delete[] m_pFace;
        m_pFace = NULL;
    }
}


// Load our Texture from a file
void GouraudTexObject::loadTexture( char pszTexture[30], IDirect3DDevice8* pD3DDevice )
{
    if( ( NULL == pszTexture ) || ( NULL == pD3DDevice ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "GouraudTexObject::loadTexture():Invalid parameter passed in!!" );

        return;
    }

    _snprintf( m_pszTextureName, 29, "%s", pszTexture );
    
    XDBGTRC( APP_TITLE_NAME_A, "GouraudTexObject::loadTexture():pszTexture       - '%hs'", pszTexture );
    XDBGTRC( APP_TITLE_NAME_A, "GouraudTexObject::loadTexture():m_pszTextureName - '%hs'", m_pszTextureName );

	//
	// Load the appropriate texture
	//
    if( m_pTexture )
    {
        m_pTexture->Release();
        m_pTexture = NULL;
    }

	if( FAILED( D3DXCreateTextureFromFile( pD3DDevice, m_pszTextureName, &m_pTexture ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudTexObject::loadTexture():Unable to load the texture!!" );
	}
}

void GouraudTexObject::render( IDirect3DDevice8* pD3DDevice )
{
	
	D3DXMatrixTranslation( &m_HoldMatrix, m_TranslateVector.x, m_TranslateVector.y, m_TranslateVector.z );
	
//	D3DXMatrixMultiply( &m_HoldMatrix, &m_ObjectMatrix, &m_HoldMatrix );
//	D3DXMatrixMultiply( &m_WorkMatrix, &m_WorkMatrix, &m_HoldMatrix );
	D3DXMatrixMultiply( &m_WorkMatrix, &m_WorkMatrix, &m_ObjectMatrix);
//	pD3DDevice->SetTransform( D3DTS_WORLD, &m_WorkMatrix );
	pD3DDevice->SetTransform( D3DTS_WORLD, &m_ObjectMatrix );


	pD3DDevice->SetStreamSource( 0, m_pVB, sizeof(TEXVERTEX) );
	pD3DDevice->SetVertexShader( D3DFVF_TEXVERTEX );

    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLELIST , 0, m_wNumFaces );
}

void GouraudTexObject::loadMDL( char* pszFilename, IDirect3DDevice8* pD3DDevice )
{
	FILE* pfInput;
	DWORD dwTotalObjects;

	pfInput = fopen( pszFilename, "rb" );

    if( !pfInput )
    {
        XDBGERR( APP_TITLE_NAME_A, "GouraudTexObject::loadMDL( char* ):Failed to open the file - '%s'!!", pszFilename );

        return;
    }

	fread( &dwTotalObjects, sizeof(DWORD), 1, pfInput );

	loadMDL( pfInput, pD3DDevice );
	fclose( pfInput );
}

void GouraudTexObject::loadMDL( FILE* pfInput, IDirect3DDevice8* pD3DDevice )
{
	//
	// Read vertices, normals, and diffuse for object
	//
	fread( &m_wNumVertices, sizeof(WORD), 1, pfInput );

    // Clean up our vertices
    if( m_pVertex )
    {
        delete[] m_pVertex;
        m_pVertex = NULL;
    }
	
    m_pVertex = new TEXVERTEX[m_wNumVertices];

	for( WORD i = 0; i < m_wNumVertices; ++i )
	{
		fread( &m_pVertex[i].p.x, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].p.y, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].p.z, sizeof(float), 1, pfInput );

		fread( &m_pVertex[i].n.x, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].n.y, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].n.z, sizeof(float), 1, pfInput );

		fread( &m_pVertex[i].diffuse, sizeof(DWORD), 1, pfInput );

        /*
		fread( &m_pVertex[i].tu, sizeof(float), 1, pfInput );
		fread( &m_pVertex[i].tv, sizeof(float), 1, pfInput );

        m_pVertex[i].tv += 1.0f;
        
        m_pVertex[i].tu *= MENUBOX_MAINAREA_X2;
        m_pVertex[i].tv *= MENUBOX_MAINAREA_Y2;
        */
	}

	//
	// Read in a list of the vertex coordinates
	//
	fread( &m_wNumTexVertices, sizeof(WORD), 1, pfInput );

    if( m_pTextureVertex )
    {
        delete[] m_pTextureVertex;
        m_pTextureVertex = NULL;
    }

	m_pTextureVertex  = new TextureVert[m_wNumTexVertices];

	for( i = 0; i < m_wNumTexVertices; i++ )
	{
		fread( &m_pTextureVertex[i].m_tu, sizeof(float), 1, pfInput );
		fread( &m_pTextureVertex[i].m_tv, sizeof(float), 1, pfInput );
    }

    //
	// Read face list for object
	//
	fread( &m_wNumFaces, sizeof(WORD), 1, pfInput );

    // Clean up our faces
    if( m_pFace )
    {
        delete[] m_pFace;
        m_pFace = NULL;
    }

	m_pFace = new TexFace[m_wNumFaces];

	for( i = 0; i < m_wNumFaces; ++i )
	{
		fread( &m_pFace[i].point[0], sizeof(WORD), 1, pfInput );
		fread( &m_pFace[i].point[1], sizeof(WORD), 1, pfInput );
		fread( &m_pFace[i].point[2], sizeof(WORD), 1, pfInput );

		fread( &m_pFace[i].m_wTexPoint[0], sizeof(WORD), 1, pfInput );
		fread( &m_pFace[i].m_wTexPoint[1], sizeof(WORD), 1, pfInput );
		fread( &m_pFace[i].m_wTexPoint[2], sizeof(WORD), 1, pfInput );
	}

	D3DXMatrixIdentity( &m_ObjectMatrix );
	m_TranslateVector.x = 0.0f;
	m_TranslateVector.y = 0.0f;
	m_TranslateVector.z = 0.0f;
	m_TranslateVector.w = 1.0f;

	//
	// Create a vertex buffer for the object
	//
    if( m_pVB )
    {
        m_pVB->Release();
        m_pVB = NULL;
    }

	if( FAILED( pD3DDevice->CreateVertexBuffer( m_wNumFaces * 3 * sizeof(TEXVERTEX),
                                                0,  /* Usage */
                                                D3DFVF_TEXVERTEX,
                                                D3DPOOL_DEFAULT, 
                                                &m_pVB ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudTexObject::loadMDL(FILE*):Failed to create a Vertex Buffer!!" );
	}

	//
	// Fill the vertex buffer
	//
	TEXVERTEX* pVertices;
	if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
        XDBGWRN( APP_TITLE_NAME_A, "GouraudTexObject::loadMDL(FILE*):Failed to lock the Vertex Buffer!!" );
	}
	
    //memcpy( pVertices, m_pVertex, sizeof(m_pVertex) );
	int counter = 0;
    for( i = 0; i < m_wNumFaces; ++i )
	{
		m_pVertex[m_pFace[i].point[0]].tu = m_pTextureVertex[m_pFace[i].m_wTexPoint[0]].m_tu;
		m_pVertex[m_pFace[i].point[0]].tv = m_pTextureVertex[m_pFace[i].m_wTexPoint[0]].m_tv;
		pVertices[counter++] = m_pVertex[m_pFace[i].point[0]];

		m_pVertex[m_pFace[i].point[1]].tu = m_pTextureVertex[m_pFace[i].m_wTexPoint[1]].m_tu;
		m_pVertex[m_pFace[i].point[1]].tv = m_pTextureVertex[m_pFace[i].m_wTexPoint[1]].m_tv;
		pVertices[counter++] = m_pVertex[m_pFace[i].point[1]];

		m_pVertex[m_pFace[i].point[2]].tu = m_pTextureVertex[m_pFace[i].m_wTexPoint[2]].m_tu;
		m_pVertex[m_pFace[i].point[2]].tv = m_pTextureVertex[m_pFace[i].m_wTexPoint[2]].m_tv;
		pVertices[counter++] = m_pVertex[m_pFace[i].point[2]];
	}

    m_pVB->Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\ipmenu.cpp ===
/*****************************************************
*** ipmenu.cpp
***
*** CPP file for our XShell ip menu class.
***
*** by Victor Blanco
*** December 2nd, 2000
***
*****************************************************/

#include "stdafx.h"
#include "ipmenu.h"

extern BOOL             g_bUpdateNameAddrTexture; // Determines if we need to update the machine name & IP Address
extern CXSettings       g_XboxSettings;           // Settings that are stored on the Xbox
extern CSoundCollection g_Sounds;                 // Used to generate all sounds for the XShell

// Constructors
CIPMenu::CIPMenu( CXItem* pParent )
: CKeypadMenu( pParent ),
m_bSetTitleIP( TRUE ),
m_bDisplayInUseMessage( FALSE )
{
    SetTitle( MENU_TITLE_IP );
}


// Destructor
CIPMenu::~CIPMenu()
{
}


// Draws a menu on to the screen
void CIPMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Let our base menu draw the items from the data file
    CKeypadMenu::Action( pTexture );

    pTexture->Lock();

    // Draw the IP Title Header Information
    float fXPos;
    float fYPos = IPMENU_ADDRESS_HEADER_TEXT_YPOS;

    if( m_bSetTitleIP )
    {
        fXPos = MENUBOX_TEXTAREA_X_CENTER - GetStringPixelWidth( IPMENU_TITLE_IP_HEADER_TEXT );
        pTexture->DrawText( fXPos, fYPos, COLOR_MEDIUM_GREEN, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", IPMENU_TITLE_IP_HEADER_TEXT );
    }
    else
    {
        fXPos = MENUBOX_TEXTAREA_X_CENTER - GetStringPixelWidth( IPMENU_DEBUG_IP_HEADER_TEXT );
        pTexture->DrawText( fXPos, fYPos, COLOR_MEDIUM_GREEN, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", IPMENU_DEBUG_IP_HEADER_TEXT );
    }

    // Draw the Machine Name in use error message if needed
    if( m_bDisplayInUseMessage )
    {
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( IPMENU_ADDRESS_INUSE_MESSAGE ) / 2.0f ), IPMENU_ADDRESS_INUSE_YPOS, COLOR_TVSAFE_RED, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", IPMENU_ADDRESS_INUSE_MESSAGE );
    }

    pTexture->Unlock();
}


// Handles input (of the BUTTONS) for the current menu
void CIPMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )		//backspace
			{
				int len = wcslen( m_pwszAddress );
				
				if(len > 0)
				{
                    m_bUpdateTexture = TRUE;
                    m_bDisplayInUseMessage = FALSE;  // Make sure our in use message is disabled

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

					len = len - 1;
					m_pwszAddress[len] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok" ) )		//ok
			{
                // See if the user is trying to set an address
                if( m_pwszAddress[0] != 0 )
                {
                    // Check to see if our IP Address is already in use
                    // If so, warn the user, and do NOT set the IP Address
                    char pszIPAddress[DATAVALUE_IPADDRESS_LENGTH+1];
                    _snprintf( pszIPAddress, DATAVALUE_IPADDRESS_LENGTH, "%ls", m_pwszAddress );

                    if( m_bSetTitleIP )
                    {
                        if( strcmp( g_XboxSettings.GetDebugIPAddress(), pszIPAddress ) == 0 )
                        {
                            m_bUpdateTexture = TRUE;
                            m_bDisplayInUseMessage = TRUE;

                            // TODO: Play Error Sound

                            return;
                        }
                    }
                    else
                    {
                        if( strcmp( g_XboxSettings.GetIPAddress(), pszIPAddress ) == 0 )
                        {
                            m_bUpdateTexture = TRUE;
                            m_bDisplayInUseMessage = TRUE;

                            // TODO: Play Error Sound

                            return;
                        }
                    }
                }

                g_bUpdateNameAddrTexture = TRUE;    // Update our Name / Addr Texture

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( m_bSetTitleIP )
                {
                    if( FAILED( g_XboxSettings.SetIPAddress( m_pwszAddress ) ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CIPMenu::HandleInput():Failed to store the settings!!" );
                    }
                }
                else
                {
                    if( FAILED( g_XboxSettings.SetDebugIPAddress( m_pwszAddress ) ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CIPMenu::HandleInput():Failed to store the settings!!" );
                    }
                }

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel" ) )	//cancel
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"use dhcp" ) )	//dhcp
			{
                g_bUpdateNameAddrTexture = TRUE;    // Update our Name / Addr Texture

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( m_bSetTitleIP )
                {
                    if( FAILED( g_XboxSettings.SetIPAddress( "\0" ) ) )
                    {
                        XDBGERR( APP_TITLE_NAME_A, "CIPMenu::HandleInput():Failed to store the settings!!" );
                    }
                }
                else
                {
                    if( FAILED( g_XboxSettings.SetDebugIPAddress( "\0" ) ) )
                    {
                        XDBGERR( APP_TITLE_NAME_A, "CIPMenu::HandleInput():Failed to store the settings!!" );
                    }
                }

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an IP Address
                if( wcslen( m_pwszAddress ) < DATAVALUE_IPADDRESS_LENGTH )
                {
                    m_bUpdateTexture = TRUE;
                    m_bDisplayInUseMessage = FALSE;  // Make sure our in use message is disabled

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

				    wcscat(m_pwszAddress, m_keyPad[m_xKeypos][m_yKeypos].resultChar);
                }
			}
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
			int len = wcslen( m_pwszAddress );
			
			if(len > 0)
			{
                m_bUpdateTexture = TRUE;
                m_bDisplayInUseMessage = FALSE;  // Make sure our in use message is disabled

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

				len = len - 1;
				m_pwszAddress[len] = L'\0';
			}

            break;
        }
    }
}


// This will be called whenever the user enters this menu
void CIPMenu::Leave( CXItem* pItem )
{
    // Call our base-class leave
    CKeypadMenu::Leave( pItem );

    m_bDisplayInUseMessage = FALSE;
}

// This will be called whenever the user enters this menu
void CIPMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Make sure we don't process the first keypress, and set our item back to 0
    m_bDropKeyPress = TRUE;
    m_xKeypos = m_yKeypos = 0;
}

// Used to determine if we should set the Title IP, or the Debug IP Address (TRUE for Title)
void CIPMenu::SetTitleIP( BOOL bSetTitle )
{
    m_bSetTitleIP = bSetTitle;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\keyboardmenu.cpp ===
/*****************************************************
*** keyboardmenu.cpp
***
*** CPP file for our Keyboard Menu class.
***
*** by James N. Helm
*** December 6th, 2000
***
*****************************************************/

#include "stdafx.h"
#include "keyboardmenu.h"

extern CXSettings       g_XboxSettings; // Settings that are stored on the Xbox
extern CSoundCollection g_Sounds;       // Used to generate all sounds for the XShell

// Constructors
CKeyboardMenu::CKeyboardMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_bDropKeyPress( TRUE ),
m_bShift( FALSE )
{
	GenerateKeypad();

    // Default the focus to the OK Button
	m_xKeypos = KEYBOARD_NUM_COLS - 1;
    m_yKeypos = 0;
}


// Destructor
CKeyboardMenu::~CKeyboardMenu()
{
}


// Draws a menu on to the screen
void CKeyboardMenu::Action( CUDTexture* pTexture )
{
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

	// Draw our keypad
	renderKeypad( pTexture );

    // Unlock our texture
    pTexture->Unlock();
}


// Handle the Joystick Input
void CKeyboardMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CKeyboardMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            if( 0 == m_yKeypos )    // Wrap the cursor
            {
                m_yKeypos = 3;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_yKeypos--;
                }
            }
			else if( ( m_yKeypos != 0 ) && ( m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
				m_yKeypos--;
			}
			else if( ( m_yKeypos != 0 ) && ( !m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
				m_yKeypos = m_yKeypos - 2;
			}

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            if( 3 == m_yKeypos )    // Wrap the cursor
            {
                m_yKeypos = 0;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_yKeypos++;
                }
            }
            else if( ( m_yKeypos != 3 ) && ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) )
			{
				m_yKeypos++;
			}
			else if( ( m_yKeypos != 3 ) && ( !m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) )
			{
				m_yKeypos = m_yKeypos + 2;
			}

            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            if( ( 0 == m_xKeypos ) || ( !m_keyPad[m_xKeypos - 1][m_yKeypos].getRender() ) )   // Wrap the cursor
            {
                m_xKeypos = 9;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_xKeypos--;
                }
            }
            else    // m_xKeypos != 0
			{
				m_xKeypos--;
			}

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            if( ( 9 == m_xKeypos ) || ( !m_keyPad[m_xKeypos + 1][m_yKeypos].getRender() ) )    // Wrap the cursor
            {
                m_xKeypos = 0;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_xKeypos++;
                }
            }
            else if( ( m_xKeypos != 9 ) && ( m_keyPad[m_xKeypos + 1][m_yKeypos].getRender())) 
			{
				m_xKeypos++;
			}
			else if((m_xKeypos != 9) && (!m_keyPad[m_xKeypos + 1][m_yKeypos].getRender()))
			{
                m_xKeypos++;
				m_yKeypos--;
			}

            break;
        }
    case CONTROL_LEFT_THUMB:    // Shift
        {
            m_bUpdateTexture = TRUE;
            m_bShift = !m_bShift;

            GenerateKeypad();

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CKeyboardMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )        //backspace
			{
                XDBGTRC( APP_TITLE_NAME_A, "CKeyboardMenu::HandleInput():BackSpace Selected" );

                m_bUpdateTexture = TRUE;

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok" ) )  //ok
			{
                XDBGTRC( APP_TITLE_NAME_A, "CKeyboardMenu::HandleInput():Ok Selected" );

                // Play the Select Sound
                g_Sounds.PlaySelectSound();
                
                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel" ) )  //cancel
			{
                XDBGTRC( APP_TITLE_NAME_A, "CKeyboardMenu::HandleInput():Cancel Selected" );

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    }
}


// Generate the kepad we will be using
void CKeyboardMenu::GenerateKeypad(void) 
{
	
	XDBGTRC( APP_TITLE_NAME_A, "Generating Alpha-Numeric Keypad" );

	// First create numberpad
	int xgrid  = KEYBOARD_NUM_COLS - 1;
	int ygrid  = KEYBOARD_NUM_ROWS;
	int xstart = KEYBOARD_TOPROW_X1;
	int ystart = KEYBOARD_TOPROW_Y1;
	int width  = 32;
	int height = 32;
	int spacer = 2;
	int currentx = xstart;
	int currenty = ystart;

	WCHAR buffer[3];
	buffer[1] = '\0';
	unsigned short alpha = 48;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
			buffer[0] = alpha;
			m_keyPad[x][y].defineText(buffer);
			alpha++;
			
			//cycle to letters after we hit 9
			if(alpha == 58)
            {
                if( m_bShift )
                {
                    alpha = 65;
                }
                else
                {
                    alpha = 97;
                }
            }
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = KEYBOARD_NUM_ROWS;
	xstart = KEYBOARD_TOPROW_X1 + 313;
	ystart = KEYBOARD_TOPROW_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	currentx = xstart;
	currenty = ystart;

	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;

			// clear out placeholder
			//if(y == 2) m_keyPad[x][y].setRender(FALSE);
		}
		currentx = xstart;
		currenty += height + spacer;
	}
	
	m_keyPad[9][0].defineText(L"ok");
	m_keyPad[9][1].defineText(L"cancel");
	m_keyPad[9][2].defineText(L"-");
	m_keyPad[9][3].defineText(L"");

}


// Draw our keypad
BOOL CKeyboardMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < KEYBOARD_NUM_COLS; x++)
	{
		for(int y = 0; y < KEYBOARD_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our texture so that we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    dwCharColor = ITEM_SELECTED_TEXT_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, KEYBOARD_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar);

                // Unlock our texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}

// This will be called whenever this menu is entered / activated
void CKeyboardMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Make sure we don't process the first keypress, and set our menu item back to 0
    m_bDropKeyPress = TRUE;

    // Default the focus to the OK Button
	m_xKeypos = KEYBOARD_NUM_COLS - 1;
    m_yKeypos = 0;

    // Toggle the SHIFT key off
    if( m_bShift )
    {
        m_bShift = FALSE;
        GenerateKeypad();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\keyboardmenu.h ===
/*****************************************************
*** keyboardmenu.h
***
*** Header file for our Keyboard Menu class.
*** This is a base menu type
***
*** by James N. Helm
*** December 6th, 2000
***
*****************************************************/

#ifndef _KEYBOARDMENU_H_
#define _KEYBOARDMENU_H_

#define KEYBOARD_NUM_ROWS    4
#define KEYBOARD_NUM_COLS    10

#include "menuscreen.h"  // Base menu type

class CKeyboardMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CKeyboardMenu( CXItem* pParent );
    virtual ~CKeyboardMenu();

    // Process drawing and input for a menu screen
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods

protected:
	int         m_xKeypos;                                          // Current X position on the Keyboard
    int         m_yKeypos;                                          // Current Y position on the Keyboard
	Key         m_keyPad[KEYBOARD_NUM_COLS][KEYBOARD_NUM_ROWS];     // Each Key displayed on the Keyboard
    BOOL        m_bDropKeyPress;                                    // Used to prevent the 'instant' keypress when a user navigates in here
    BOOL        m_bShift;                                           // Used to determine if the keyboard is in "Shift" mode
	
    // Private Methods
	virtual void GenerateKeypad(void);                  // Create the keypad that will be used
	virtual BOOL renderKeypad( CUDTexture* pTexture );  // Draw the keypad on to the our texture
};

#endif // _MACHINENAMEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\keypadmenu.cpp ===
/*****************************************************
*** keypadmenu.cpp
***
*** CPP file for our XShell keypad menu class.
***
*** by James Helm
*** December 5th, 2000
***
*****************************************************/

#include "stdafx.h"
#include "keypadmenu.h"

extern CXSettings       g_XboxSettings; // Settings that are stored on the Xbox
extern CSoundCollection g_Sounds;       // Used to generate all sounds for the XShell

// Constructors
CKeypadMenu::CKeypadMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_bDropKeyPress( TRUE )
{
	GenerateKeypad();

    // Default the focus to the OK button
	m_xKeypos = KEYPAD_NUM_COLS - 1;
	m_yKeypos = 0;

	ZeroMemory( m_pwszAddress, sizeof( WCHAR ) * DATAVALUE_IPADDRESS_LENGTH + 1 );
}


// Destructor
CKeypadMenu::~CKeypadMenu()
{
}


// Draws a menu on to the screen
void CKeypadMenu::Action( CUDTexture* pTexture )
{
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

	// Draw our keypad
	renderKeypad( pTexture );

	// Draw our IP Address field
	// float fXPos = MENUBOX_TEXTAREA_X_CENTER - 17.0f;
    float fXPos = MENUBOX_TEXTAREA_X_CENTER;
    float fYPos = KEYPAD_IPADDRHEADER_YPOS;
	pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", m_pwszAddress );

    // Unlock our texture
    pTexture->Unlock();
}


// Handle the Joystick Input
void CKeypadMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CKeypadMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            if( 0 == m_yKeypos )    // Wrap the cursor
            {
                m_yKeypos = 3;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_yKeypos--;
                }
            }
            else if( ( m_yKeypos != 0 ) && ( m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
				m_yKeypos--;
			}
			else if( ( m_yKeypos != 0 ) && ( !m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
				m_yKeypos = m_yKeypos - 2;
			}
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            if( 3 == m_yKeypos )    // Wrap the cursor
            {
                m_yKeypos = 0;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_yKeypos++;
                }
            }
            else if( ( m_yKeypos != 3 ) && ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) )
			{
				m_yKeypos++;
			}
			else if( ( m_yKeypos != 3 ) && ( !m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) )
			{
                // Hack when DHCP is disabled
                if( m_keyPad[m_xKeypos][m_yKeypos + 2].getRender() )
                {
				    m_yKeypos = m_yKeypos + 2;
                }
			}
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            if( ( 0 == m_xKeypos ) || ( !m_keyPad[m_xKeypos - 1][m_yKeypos].getRender() ) )   // Wrap the cursor
            {
                m_xKeypos = 3;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_xKeypos--;
                }
            }
            else // m_xKeypos != 0
			{
				m_xKeypos--;
			}
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            m_bUpdateTexture = TRUE;

            // Play the Menu Item Select Sound
            g_Sounds.PlayMenuItemSelectSound();

            if( ( 3 == m_xKeypos ) || ( !m_keyPad[m_xKeypos + 1][m_yKeypos].getRender() ) )    // Wrap the cursor
            {
                m_xKeypos = 0;
                while( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_xKeypos++;
                }
            }
            else if( ( m_xKeypos != 3 ) && ( m_keyPad[m_xKeypos + 1][m_yKeypos].getRender())) 
			{
				m_xKeypos++;
			}
			else if((m_xKeypos != 3) && (!m_keyPad[m_xKeypos + 1][m_yKeypos].getRender()))
			{
				m_xKeypos++;
				m_yKeypos--;

                // This is a hack when we use this keypad with the DHCP button disabled
                if( !m_keyPad[m_xKeypos][m_yKeypos].getRender() )
                {
                    m_yKeypos--;
                }
			}
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CKeypadMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )            //backspace
			{
				int len = wcslen( m_pwszAddress );
				
				if(len > 0)
				{
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

					len = len - 1;
					m_pwszAddress[len] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok" ) )      //ok
			{
                XDBGTRC( APP_TITLE_NAME_A, "CKeypadMenu::HandleInput():OK Pressed..." );

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel" ) )   //cancel
			{
                XDBGTRC( APP_TITLE_NAME_A, "CKeypadMenu::HandleInput():Cancel Pressed..." );

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"use dhcp" ) )    //dhcp
			{
                XDBGTRC( APP_TITLE_NAME_A, "CKeypadMenu::HandleInput():Use DHCP Pressed..." );

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an IP Address
                if( wcslen( m_pwszAddress ) < DATAVALUE_IPADDRESS_LENGTH )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

				    wcscat( m_pwszAddress, m_keyPad[m_xKeypos][m_yKeypos].resultChar );
                }
			}
            break;
        }
    case BUTTON_B:
        {
            XDBGTRC( APP_TITLE_NAME_A, "CKeypadMenu::HandleInput():Back Pressed..." );

            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
			int len = wcslen( m_pwszAddress );
			
			if(len > 0)
			{
                m_bUpdateTexture = TRUE;

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

				len = len - 1;
				m_pwszAddress[len] = L'\0';
			}

            break;
        }
    }
}


void CKeypadMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = 3;
	int ygrid  = 4;
	int xstart = KEYPAD_TOPROW_X1;
	int ystart = KEYPAD_TOPROW_Y1;
	int width  = 32;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = 4;
	xstart = KEYPAD_TOPROW_X1 + 113;
	ystart = KEYPAD_TOPROW_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	
	currentx = xstart;
	currenty = ystart;
	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;

			// clear out placeholder
			if(y == 2) m_keyPad[x][y].setRender(FALSE);
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Set the text of the keys
	m_keyPad[0][0].defineText(L"1");  m_keyPad[1][0].defineText(L"2");  m_keyPad[2][0].defineText(L"3");
	m_keyPad[0][1].defineText(L"4");  m_keyPad[1][1].defineText(L"5");  m_keyPad[2][1].defineText(L"6");
	m_keyPad[0][2].defineText(L"7");  m_keyPad[1][2].defineText(L"8");	m_keyPad[2][2].defineText(L"9");
	m_keyPad[0][3].defineText(L".");  m_keyPad[1][3].defineText(L"0");	m_keyPad[2][3].defineText(L"");
	m_keyPad[3][0].defineText(L"ok");
	m_keyPad[3][1].defineText(L"cancel");
	m_keyPad[3][2].defineText(L"place");
	m_keyPad[3][3].defineText(L"use dhcp");
}


BOOL CKeypadMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < KEYPAD_NUM_ROWS; x++)
	{
		for(int y = 0; y < KEYPAD_NUM_COLS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our Texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
                    // Draw the selector box around the currently highlighted number
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    
                    dwCharColor = ITEM_SELECTED_TEXT_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, KEYPAD_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// Sets the IP address in to our local member
HRESULT CKeypadMenu::SetAddress( char* Address )
{
    if( !Address )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CKeypadMenu::SetAddress( char ):Address was not set!!" );

        return E_INVALIDARG;
    }

    ZeroMemory( m_pwszAddress, sizeof( WCHAR ) * DATAVALUE_IPADDRESS_LENGTH + 1 );
    _snwprintf( m_pwszAddress, DATAVALUE_IPADDRESS_LENGTH + 1, L"%S", Address );

    return S_OK;
}


// Sets the IP address in to our local member
HRESULT CKeypadMenu::SetAddress( WCHAR* Address )
{
    if( !Address )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CKeypadMenu::SetAddress( WCHAR ):Address was not set!!" );

        return E_INVALIDARG;
    }

    ZeroMemory( m_pwszAddress, sizeof( WCHAR ) * DATAVALUE_IPADDRESS_LENGTH + 1 );
    _snwprintf( m_pwszAddress, DATAVALUE_IPADDRESS_LENGTH + 1, Address );

    return S_OK;
}

// This will be called whenever this menu is entered / activated
void CKeypadMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Make sure we don't process our first keypress, and set our item back to 0
    m_bDropKeyPress = TRUE;
    m_xKeypos = m_yKeypos = 0;

    // Default the focus to the OK button
	m_xKeypos = KEYPAD_NUM_COLS - 1;
	m_yKeypos = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\keypadmenu.h ===
/*****************************************************
*** keypadmenu.h
***
*** Header file for our XShell keypad menu class.
***
*** by James Helm
*** December 5th, 2000
***
*****************************************************/

#ifndef _KEYPADMENU_H_
#define _KEYPADMENU_H_

#define KEYPAD_NUM_ROWS    4
#define KEYPAD_NUM_COLS    4

#include "menuscreen.h"  // Base menu type

class CKeypadMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CKeypadMenu( CXItem* pParent );
    virtual ~CKeypadMenu();

    // Methods
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    HRESULT SetAddress( char* Address );                    // Sets the Address in to our local member
    HRESULT SetAddress( WCHAR* Address );                   // Sets the Address in to our local member

protected:
// Properties
    WCHAR	 m_pwszAddress[DATAVALUE_IPADDRESS_LENGTH + 1];     // Holds the Address until the user is ready to commit
    BOOL     m_bDropKeyPress;                                   // Used to prevent the 'instant' keypress when a user navigates in here
	int m_xKeypos;                                              // X Position of the current Key on the Keypad
    int m_yKeypos;                                              // Y Position of the current Key on the Keypad
	Key m_keyPad[KEYPAD_NUM_ROWS][KEYPAD_NUM_COLS];             // Information for each Key appearing on the Keypad

    // Private Methods
	virtual void GenerateKeypad(void);                      // Creates the keypad
	virtual BOOL renderKeypad( CUDTexture* pTexture );      // Renders the Keypad on to the texture
};

#endif // _KEYPADMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\languagemenu.h ===
/*****************************************************
*** languagemenu.h
***
*** Header file for our XShell language menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** June 2nd, 2001
***
*****************************************************/

#ifndef _LANGUAGEMENU_H_
#define _LANGUAGEMENU_H_

#include "menuscreen.h"

class CLanguageMenu : public CMenuScreen
{
public:
    CLanguageMenu( CXItem* pParent );
    ~CLanguageMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );     // Initialize our font and settings

private:

};

#endif // _LANGUAGEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\launchmenu.cpp ===
/*****************************************************
*** launchmenu.cpp
***
*** CPP file for our XShell Launch menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 2nd, 2000
***
*****************************************************/

#include "stdafx.h"
#include "launchmenu.h"

#include "..\..\..\ntos\inc\xlaunch.h"

struct MYTEXVERTEX
{
    D3DXVECTOR3 v;
    float       fRHW;
    D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

extern BOOL                 g_bDisplayBButton;      // Used to determine if we should render the B Button
extern BOOL                 g_bUpdateTitleTexture;  // Update the Title Texture
extern CSoundCollection     g_Sounds;               // Used to generate all sounds for the XShell
extern USBManager           Controllers;            // Used to determine what buttons / direction the user is pressing
extern CXSettings           g_XboxSettings;         // Settings that are stored on the Xbox
extern char                 g_pszKeyCombo[5];       // Used to determine the last 4 keys the user has entered
extern unsigned int         g_uiKeyPos;             // Used to track which keypress the user is on


extern IDirect3DDevice8*    g_pD3DDevice;

extern XFONT*               g_pFont;

// Constructors
CLaunchMenu::CLaunchMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_OptionsMenu( NULL ),
m_OnlineMenu( NULL ),
m_SysInfoMenu( NULL ),
m_uiPrevNumItems( 0 ),
m_bCheckedConfig( FALSE )
{
    XDBGTRC( APP_TITLE_NAME_A, "CLaunchMenu::CLaunchMenu( CXItem )" );

    ZeroMemory( m_pszSecretKeyCombo, 5 );
    ComputeSecretKey( m_pszSecretKeyCombo );

    XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::CLaunchMenu( CXItem )m_pszSecretKeyCombo - '%s'", m_pszSecretKeyCombo );
}

// Destructor
CLaunchMenu::~CLaunchMenu()
{
}

// Initialize the Menu
HRESULT CLaunchMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CLaunchMenu::Init()" );

    CMenuScreen::Init( menuFileName );

    // Initialize and Start our directory monitor
    m_XBEDirMonitor.Init();
    m_XBEDirMonitor.Run();

    // Obtain a pointer to the correct XBE List object from our thread
    m_pXBEList = m_XBEDirMonitor.GetXBEListPtr();

    XDBGTRC( APP_TITLE_NAME_A, "CLaunchMenu::Init():GetNumItems() - '%d'", GetNumItems() );

    m_uiPrevNumItems = GetNumItems();

    if( 0 == GetNumItems() )
    {
        SetInitialSelectState();
    }
    else
    {
        SetSelectedItem( 0 );
        SetSelectorPos( 0 );
        SetTopIndexOfItem( 0 );

        AdjustDisplayArrows();
    }

    // Get our screen information
    ImportScreenItems( menuFileName );

    // Get the height of the font
    unsigned int decent;
    GetFontSize( &m_uiFontHeightOfItem, &decent );

    // Setup our sub-menus
    m_OptionsMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\options.mnu" );
    m_OptionsMenu.SetParent( this );

    m_OnlineMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\online.mnu" );
    m_OnlineMenu.SetParent( this );

    m_SysInfoMenu.Init( SYSINFOMENU_FILENAME_A );
    m_SysInfoMenu.SetParent( this );

    return S_OK;
}


// Draws a menu on to the screen
void CLaunchMenu::Action( CUDTexture* pTexture )
{
    if( m_pXBEList != m_XBEDirMonitor.GetXBEListPtr() )
    {
        m_bUpdateTexture = TRUE;
    }

    // Get the XBEList pointer to display our items
    m_pXBEList = m_XBEDirMonitor.GetXBEListPtr();

    // If it's not time to update our texture, simply return outta here
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset for next frame
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    // If the user has changed the number of items, update!!
    if( m_uiPrevNumItems != GetNumItems() )
    {
        if( 0 == GetNumItems() )
        {
            SetInitialSelectState();
        }
        else if ( GetNumItems() >= m_uiPrevNumItems ) // If the amount is larger, we don't need to reset to the top
        {
            SetTopIndexOfItem( GetTopIndexOfItem() ); // Do this to update the Bottom Index correctly
            AdjustDisplayArrows();
        }
        else // Reset everything to the top of the menu
        {
            SetSelectedItem( 0 );
            SetTopIndexOfItem( 0 );
            SetSelectorPos( 0 );
            AdjustDisplayArrows();
        }

        m_uiPrevNumItems = GetNumItems();  // Reset our previous counter
    }

    // Draw our XBE items if we need to
    if( GetNumItems() > 0 )
    {
        // Update our Font Height
        XFONT_SetTextHeight( g_pFont, ITEM_XBELIST_FONT_HEIGHT );
        m_uiFontHeightOfItem = ITEM_XBELIST_FONT_HEIGHT;

        // Draw a box behind the currently highlighted choice
        float X1Pos = MENUBOX_SELECTBAR_X1;
        float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENU_LAUNCH_TOP_BORDER_SIZE + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectorPos() ) - ITEM_SELECTOR_BORDER_SPACE;
        float X2Pos = MENUBOX_SELECTBAR_X2;
        float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );

        pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

        // Draw the XBE files on to our screen
        for( unsigned int x = GetTopIndexOfItem(); x <= GetBottomIndexOfItem(); ++x )
        {
            float XPos = MENUBOX_TEXTAREA_X1;
            float YPos = MENUBOX_TEXTAREA_Y1 + MENU_LAUNCH_TOP_BORDER_SIZE + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - GetTopIndexOfItem() ) );

            // Create a buffer that can hold the title name, XBE name + extension, a space, 2 parens and a NULL
            int bufLen = XBEIMAGE_TITLE_NAME_LENGTH + MAX_PATH + 8;
            WCHAR* pwszDisplayString = new WCHAR[bufLen];
            if( !pwszDisplayString )
            {
                XDBGERR( APP_TITLE_NAME_A, "CLaunchMenu::Action():Failed to allocate memory!!" );

				break;  // Break out of our loop so that we don't try to mess with the buffer
            }

            // NULL out our new memory
            ZeroMemory( pwszDisplayString, sizeof( WCHAR ) * bufLen );

            // If the friendly title is null, only display the XBE Name
            if( L'\0' == m_pXBEList->GetXBETitle( x )[0] )
            {
                _snwprintf( pwszDisplayString, bufLen - 1, L"%hs", m_pXBEList->GetXBEName( x ) );
            }
            else  // Display the friendly name and the XBE Name
            {
#ifdef COOL_XDASH
                _snwprintf( pwszDisplayString, bufLen - 1, L"%ls", m_pXBEList->GetXBETitle( x ) );
#else
                _snwprintf( pwszDisplayString, bufLen - 1, L"%ls (%hs)", m_pXBEList->GetXBETitle( x ), m_pXBEList->GetXBEName( x ) );
#endif // COOL_XDASH
            }
            // pScreen->TruncateStringToFit( pwszDisplayString, bufLen, XPos, MENUBOX_SELECTBAR_X2 - 7.0f );

            // If we are on the currently selected item, let's set the text color
            DWORD dwTextCol;
            if( GetSelectedItem() == (int)x )
            {
                dwTextCol = ITEM_SELECTED_TEXT_COLOR;
            }
            else
            {
                dwTextCol = SCREEN_DEFAULT_TEXT_FG_COLOR;
            }

            pTexture->DrawText( XPos, YPos, dwTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%ls", pwszDisplayString );

            delete[] pwszDisplayString;
            pwszDisplayString = NULL;
        }

        m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
        XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );
    }

    // Unlock our texture and restore our render target
    pTexture->Unlock();

    /////////////////////
    // Draw # XBE Message
    /////////////////////

    // Lock the Title Texture so we can render on to it

    // Signal that our title texture is going to change
    g_bUpdateTitleTexture = TRUE;

    #define LM_BUFFSIZE 60

    WCHAR tempBuff[LM_BUFFSIZE+1];
    ZeroMemory( tempBuff, ( LM_BUFFSIZE + 1 ) * sizeof( WCHAR ) );

    if( 1 == GetNumItems() )
    {
        _snwprintf( tempBuff, LM_BUFFSIZE, L"%d Xbox executable", GetNumItems() );
    }
    else
    {
        _snwprintf( tempBuff, LM_BUFFSIZE, L"%d Xbox executables", GetNumItems() );
    }

    SetTitle( tempBuff );
}


// Get the number of items that should be displayed on the screen
unsigned int CLaunchMenu::GetNumItemsToDisplay()
{
    unsigned int uiReturnVal = 0;
    float panelHeight = MENUBOX_TEXTAREA_Y2 - MENUBOX_TEXTAREA_Y1;

    uiReturnVal = (unsigned int)( ( panelHeight - MENU_LAUNCH_TOP_BORDER_SIZE ) / ( ITEM_XBELIST_FONT_HEIGHT + ITEM_VERT_SPACING ) );
    return uiReturnVal;
}


// Handle the Joystick Input
void CLaunchMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CLaunchMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Check the secret key to see if we should display the special menu
    if( ProcessSecretKey() )
    {
        return;
    }

    // Font height of our XBE Items
    XFONT_SetTextHeight( g_pFont, ITEM_XBELIST_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_XBELIST_FONT_HEIGHT;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() > 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    // Flag our texture to be updated, since the selection has changed
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );

                    // Adjust the screen appropriately
                    if( GetSelectorPos() > 0 )
                    {
                        SetSelectorPos( GetSelectorPos() - 1 );
                    }
                    else
                    {
                        SetTopIndexOfItem( GetTopIndexOfItem() - 1 );
                    }

                    AdjustDisplayArrows();
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() > 0 )
            {
                if( (unsigned int)GetSelectedItem() < ( GetNumItems() - 1 ) )
                {
                    // Flag our texture to be updated, since the selection has changed
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );

                    // Adjust the screen appropriately
                    if( GetSelectorPos() < ( GetNumItemsToDisplay() - 1 ) )
                    {
                        SetSelectorPos( GetSelectorPos() + 1 );
                    }
                    else
                    {
                        SetTopIndexOfItem( GetTopIndexOfItem() + 1 );
                    }

                    AdjustDisplayArrows();
                }
            }
            break;
        }
	}

    // Restoring Font Height
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
}


// Handles input for the current menu
void CLaunchMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Check the secret key to see if we should display the special menu
    if( ProcessSecretKey() )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                char* pszDirname = new char[MAX_PATH+1];
                char* pszFilename = new char[MAX_PATH+1];
                if( ( NULL == pszDirname ) || ( NULL == pszFilename ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::HandleInput():Failed to allocate memory!!  Can't reboot to the title!!" );
                }
                else
                {
                    ZeroMemory( pszDirname, MAX_PATH + 1 );
                    ZeroMemory( pszFilename, MAX_PATH + 1 );

                    _snprintf( pszFilename, MAX_PATH, "%s%s", m_pXBEList->GetXBEName( GetSelectedItem() ), FILE_EXECUTABLE_EXENSION_A );

                    if( ( strcmp( "", m_pXBEList->GetXBEDir( GetSelectedItem() ) ) == 0 ) &&
                        ( ( strcmp( FILE_DATA_DASHBOARD_FILENAME_A, pszFilename ) == 0 ) ||
                        ( ( strcmp( FILE_DATA_ONLINE_DASHBOARD_FILENAME_A, pszFilename ) == 0 ) ) ) )
                    //
                    // Check to see if we are dealing with the Dashboard or Online Dashboard (special case #1)
                    //
                    {
                        _snprintf( pszDirname, MAX_PATH, "%s%s", FILE_DASH_PARTITION_PATH_A, m_pXBEList->GetXBEDir( GetSelectedItem() ) );
                    }
                    else if( ( strcmp( "", m_pXBEList->GetXBEDir( GetSelectedItem() ) ) == 0 ) &&
                           ( strcmp( FILE_DATA_DEFAULT_FILENAME_A, pszFilename ) == 0 ) )
                    //
                    // Check to see if we are dealing with the DEFAULT.XBE from the DVD Drive (special case #2)
                    //
                    {
                        _snprintf( pszDirname, MAX_PATH, "%s%s", FILE_DVDDRIVE_PARTITION_PATH_A, m_pXBEList->GetXBEDir( GetSelectedItem() ) );
                    }
                    else
                    //
                    // No special case.  Must be dealing with an XBE from our \devkit directory
                    //
                    {
                        _snprintf( pszDirname, MAX_PATH, "%s%s", FILE_EXECUTABLE_DEVICE_PATH_A, m_pXBEList->GetXBEDir( GetSelectedItem() ) );
                    }

                    DWORD dwSleepTime = 0;
                    // Let the Select Sound finish before we launch
                    while( g_Sounds.IsSoundPlaying( ENUM_SOUND_SELECT ) && ( dwSleepTime < 5000 ) )
                    {
                        dwSleepTime += 10;
                        Sleep( 10 );
                    }

                    //////////////////////////////
                    // Display our logo screen
                    //////////////////////////////
                    CUDTexture SplashTexture;

                    if( g_XboxSettings.GetWidescreen() )
                        SplashTexture.Initialize(g_pD3DDevice, "y:\\images\\logow.bmp", 512, 512 );
                    else
                        SplashTexture.Initialize(g_pD3DDevice, "y:\\images\\logo.bmp", 512, 512 );

                    IDirect3DVertexBuffer8* pVB = NULL;
                    MYTEXVERTEX* pb = NULL;

                    g_pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &pVB );

                    pVB->Lock( 0, 0, (BYTE**)&pb, 0 );

                    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f; pb[0].tv = 0.0f;
                    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = 1.0f; pb[1].tv = 0.0f;
                    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = 1.0f; pb[2].tv = 1.0f;
                    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f; pb[3].tv = 1.0f;

                    pVB->Unlock();

                    // Make sure that edge antialiasing is off for the following objects
                    DWORD dwEdgeCurrentState = 0;

                    g_pD3DDevice->GetRenderState( D3DRS_EDGEANTIALIAS, &dwEdgeCurrentState );
                    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );

                    g_pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
                    g_pD3DDevice->SetStreamSource( 0, pVB, sizeof( MYTEXVERTEX ) );
                    g_pD3DDevice->SetTexture( 0, SplashTexture.GetTexture() );
                    g_pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
                    g_pD3DDevice->SetTexture( 0, NULL );

                    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, dwEdgeCurrentState );

                    pVB->Release();
                    pVB = NULL;

                    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );

                    g_pD3DDevice->PersistDisplay();

                    // Make sure our Background Thread is gone before we call the reboot API
                    if( !m_XBEDirMonitor.SoftBreak( 60000 ) )   // If there are a lot of XBE's, this could take a long time
                        XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::HandleInput():Failed to Shutdown our background XBE Search Thread!!" );

                    // Launch the title that the user selected
                    XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::HandleInput():Filename  - '%s'", pszFilename );
                    XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::HandleInput():Directory - '%s'", pszDirname );
                    NTSTATUS status = WriteTitleInfoAndReboot( pszFilename, pszDirname, LDT_NONE, 0, NULL );
                    if( FAILED( status ) ) // !NT_SUCCESS( status ) ) // API says this returns NTSTATUS, but I think it's an HRESULT
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::HandleInput():Failed to launch title!! NTSTATUS - '0x%.8X (%d)'", status, status );
                    }
                }

                if( pszDirname )
                {
                    delete[] pszDirname;
                    pszDirname = NULL;
                }

                if( pszFilename )
                {
                    delete[] pszFilename;
                    pszFilename = NULL;
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                // SetSelectedItem( 0 );
                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_X:
        {
            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            Leave( &m_OptionsMenu );

            break;
        }
    case BUTTON_Y:
        {
            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            // Go to the Online Menu
            Leave( &m_OnlineMenu );

            break;
        }
    case BUTTON_WHITE:
        {
            break;
        }
    }
}


// Set the selector position on the screen
HRESULT CLaunchMenu::SetSelectorPos( unsigned int index )
{
    if( index >= GetNumItemsToDisplay() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::SetSelectorPos():Invalid index passed!! - '%d', MAX - '%d'", index, GetNumItemsToDisplay() - 1 );

        return E_INVALIDARG;
    }

    m_nSelectorPos = index;

    return S_OK;
}


// Set the top index of item that should be displayed on our screen
HRESULT CLaunchMenu::SetTopIndexOfItem( unsigned int index )
{
    // Make sure the passed in index is either 0, or within the realm of display
    if( ( ( index + GetNumItemsToDisplay() - 1 ) < GetNumItems() ) || ( 0 == index) )
    {
        m_nTopIndexOfItem = index;
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::SetTopIndexOfItem():Invalid index passed!! - '%d'", index );

        return E_INVALIDARG;
    }

    if( 0 == GetNumItems() )
    {
        SetBottomIndexOfItem( 0 );
    }
    else if( GetNumItems() < GetNumItemsToDisplay() )
    {
        SetBottomIndexOfItem( GetNumItems() - 1 );
    }
    else
    {
        SetBottomIndexOfItem( m_nTopIndexOfItem + GetNumItemsToDisplay() - 1 );
    }

    return S_OK;
}


// Set the bottom index of item that should be displayed on our screen
HRESULT CLaunchMenu::SetBottomIndexOfItem( unsigned int index )
{
    if( index > GetNumItems() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CLaunchMenu::SetBottomIndexOfItem():Invalid index passed!! - '%d', MAX - '%d'", index, GetNumItems() - 1 );

        return E_INVALIDARG;
    }

    m_nBottomIndexOfItem = index;

    return S_OK;
}


// Adjust whether we display the up and down arrows
void CLaunchMenu::AdjustDisplayArrows()
{
    // Set the arrows

    if( 0 == GetNumItems() )
    {
        SetDisplayUpArrow( FALSE );
        SetDisplayDownArrow( FALSE );

        return;
    }

    // Top arrow
    if( GetTopIndexOfItem() > 0 )
    {
        SetDisplayUpArrow( TRUE );
    }
    else
    {
        SetDisplayUpArrow( FALSE );
    }


    // Bottom arrow
    if( GetBottomIndexOfItem() < ( GetNumItems() - 1 ) )
    {
        SetDisplayDownArrow( TRUE );
    }
    else
    {
        SetDisplayDownArrow( FALSE );
    }
}


// Set the initial select state
void CLaunchMenu::SetInitialSelectState()
{
    SetSelectedItem( 0 );
    SetSelectorPos( 0 );
    SetTopIndexOfItem( 0 );
    SetBottomIndexOfItem( 0 );
    SetDisplayUpArrow( FALSE );
    SetDisplayDownArrow( FALSE );
}


// Get a pointer to a sub-menu
CXItem* CLaunchMenu::GetItemPtr( enum XShellMenuIds menuId )
{
    CXItem* pReturn = NULL;

    if( ENUM_SHELLMENUID_OPTIONS == menuId )
    {
        pReturn = &m_OptionsMenu;
    }

    return pReturn;
}


// Should be called whenever a user leaves the menu
void CLaunchMenu::Leave( CXItem* pItem )
{
    CMenuScreen::Leave( pItem );

    // Set the B Button to be displayed
    g_bDisplayBButton = TRUE;

    // Make sure we turn off the Up and Down arrows
    SetDisplayUpArrow( FALSE );
    SetDisplayDownArrow( FALSE );
}

// This will be called whenever the user enters this menu
void CLaunchMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Set the B Button to be hidden
    g_bDisplayBButton = FALSE;

    // Make sure our display arrows are acting correctly
    AdjustDisplayArrows();

    // Reset our secret key combo
    ZeroMemory( g_pszKeyCombo, 5 );
    g_uiKeyPos = 0;
}


// Checks the secret key to see if we should display the 'secret' menu
BOOL CLaunchMenu::ProcessSecretKey()
{
	XDBGTRC( APP_TITLE_NAME_A, "g_pszKeyCombo - '%c'", g_pszKeyCombo[g_uiKeyPos] );

    // Check to see if the user entered the special key combo for the Secret Hardware menu
    if( g_pszKeyCombo[g_uiKeyPos] != m_pszSecretKeyCombo[g_uiKeyPos] )
    {
        g_uiKeyPos = 0; // Reset our Key Sequence
    }
    else
    {
        // Check to see if we found our key sequence.  If so, take us to the secret menu
        if( 4 == ++g_uiKeyPos )
        {
            g_uiKeyPos = 0;

            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            Leave( &m_SysInfoMenu );

            return TRUE;
        }
    }

    return FALSE;
}

// These should never change
#define SECRET_RAND_KEY "\xAC\x21\x07\x1B\xB5\x94\xE8\x23\x50\x33\x4A\x71\x72\x7A\xD5\x91"
#define SECRET_RAND_KEY_LEN SYMMETRIC_KEY_LEN

// A   - A Button
// B   - B Button
// Y   - Y Button
// X   - X Button
// L   - bLack Button
// W   - White Button
// U   - DPAD Up
// D   - DPAD Down
// F   - DPAD leFt
// R   - DPAD Right
// T   - Left-Thumb Button
// I   - rIght-Thumb Position
// E   - lEft trigger button
// O   - right trigger buttOn
void CLaunchMenu::ComputeSecretKey( char* Buffer )
{
    if( NULL == Buffer )
    {
        return;
    }

    BYTE Digest[XC_SERVICE_DIGEST_SIZE];
    WORD* pwDigestWORD = (WORD*)(&Digest[0]);
    int i = 4;

    BYTE pbMacAddress[SETTINGS_FACTORY_ETHERNET_SIZE + 1];
    ZeroMemory( pbMacAddress, SETTINGS_FACTORY_ETHERNET_SIZE + 1 );

    g_XboxSettings.GetFactoryEthernetAddr( pbMacAddress, SETTINGS_FACTORY_ETHERNET_SIZE );

    for( int x = 0; x < SETTINGS_FACTORY_ETHERNET_SIZE; x++ )
        XDBGTRC( APP_TITLE_NAME_A, "pbMacAddress - '%X'", pbMacAddress[x] );

    // Don't use "A" or "X" button in the combination
    char* secretKeyMap = "BYLWUDFRTIEO";

    XcHMAC( (LPBYTE)SECRET_RAND_KEY, SECRET_RAND_KEY_LEN,
            pbMacAddress, SETTINGS_FACTORY_ETHERNET_SIZE,
            NULL, 0,
            Digest );

    RtlZeroMemory( Buffer, 4 );
    while ( --i >= 0 )
    {
        Buffer[i] = secretKeyMap[ (*pwDigestWORD++) % 12 ];
    }
}

NTSTATUS CLaunchMenu::WriteTitleInfoAndReboot(LPCSTR pszLaunchPath, LPCSTR pszDDrivePath,
    DWORD dwLaunchDataType, DWORD dwTitleId, PLAUNCH_DATA pLaunchData)
{
    extern PLAUNCH_DATA_PAGE *LaunchDataPage;
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    PSTR pszOutput;
    int cch;

    if (NULL == *LaunchDataPage)
    {
        *LaunchDataPage = (PLAUNCH_DATA_PAGE)MmAllocateContiguousMemory(PAGE_SIZE);
    }

    if (NULL == *LaunchDataPage)
    {
        return STATUS_NO_MEMORY;
    }

    MmPersistContiguousMemory(*LaunchDataPage, PAGE_SIZE, TRUE);

    if (!pszDDrivePath)
    {
        pszDDrivePath = "\\Device\\Cdrom0";
    }

    pszOutput = ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath;

    ASSERT(PAGE_SIZE == sizeof(LAUNCH_DATA_PAGE));

    RtlZeroMemory(*LaunchDataPage, PAGE_SIZE);

    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwLaunchDataType = dwLaunchDataType;
    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwTitleId = dwTitleId;

    if (dwLaunchDataType != LDT_NONE)
    {
        memcpy(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->LaunchData,
               pLaunchData,
               sizeof(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->LaunchData));
    }

    if (NULL != pszLaunchPath)
    {
        if (lstrcmpiA(pszDDrivePath, "\\Device\\Harddisk0\\Partition2") == 0)
        {
            lstrcpynA(pszOutput, "\\Device\\Harddisk0\\Partition2\\",
                      ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - 1);
            cch = strlen(pszOutput);
            lstrcpynA(&(pszOutput[cch]),
                      pszLaunchPath,
                      ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - (cch));
        }
        else
        {
            lstrcpynA(pszOutput,
                      pszDDrivePath,
                      ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - 1);

            cch = strlen(pszOutput);
            pszOutput[cch++] = TITLE_PATH_DELIMITER;

            lstrcpynA(&(pszOutput[cch]),
                      pszLaunchPath,
                      ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - (cch));
        }
    }

    // Notify the debugger that we're about to reboot and then reboot
    DmTell(DMTELL_REBOOT, NULL);

    HalReturnToFirmware(HalQuickRebootRoutine);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\languagemenu.cpp ===
/*****************************************************
*** languagemenu.cpp
***
*** CPP file for our XShell language menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** June 2nd, 2001
***
*****************************************************/

#include "stdafx.h"
#include "languagemenu.h"

extern CXSettings       g_XboxSettings;     // Xbox Settings Object
extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell
extern XFONT*           g_pFont;

// Constructors
CLanguageMenu::CLanguageMenu( CXItem* pParent )
: CMenuScreen( pParent )
{
    XDBGTRC( APP_TITLE_NAME_A, "CLanguageMenu::CLanguageMenu(ex)" );

    m_uiNumItems = LANGUAGEMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    SetTitle( MENU_TITLE_LANGUAGE );
}


// Destructor
CLanguageMenu::~CLanguageMenu()
{
}

// Draws a menu on to the screen
void CLanguageMenu::Action( CUDTexture* pTexture )
{
    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }
    
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_LANGUAGEMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_LANGUAGEMENU_FONT_HEIGHT;

    // Draw a box behind the currently highlighted choice
    float X1Pos = MENUBOX_SELECTBAR_X1;
    float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - ITEM_SELECTOR_BORDER_SPACE;
    float X2Pos = MENUBOX_SELECTBAR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
    
    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

    //
    // Draw our Menu Items
    //

    for( unsigned int x = 0; x < LANGUAGEMENU_ITEM_NUM_ITEMS; x++ )
    {
        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszLanguageMenuItems[x] );
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CLanguageMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CLanguageMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CLanguageMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( FAILED( g_XboxSettings.SetLanguage( GetSelectedItem() ) ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CLanguageMenu::HandleInput():Failed to set the Language in to the config sector!!" );
                }

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT CLanguageMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CLanguageMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    return hr;
}


// This will be called whenever the user enters this menu
void CLanguageMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Make sure our settings are up to date
    g_XboxSettings.LoadSettings();

    // Default the selection to the currently selected language
    SetSelectedItem( g_XboxSettings.GetLanguage() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\machinenamemenu.h ===
/*****************************************************
*** machinenamemenu.h
***
*** Header file for our XShell Machine Name menu
*** class.
***
*** by Victor Blanco
*** December 2nd, 2000
***
*****************************************************/

#ifndef _MACHINENAMEMENU_H_
#define _MACHINENAMEMENU_H_

#include "keyboardmenu.h"  // Base Menu Type

class CMachineNameMenu : public CKeyboardMenu
{
public:
    // Constructors and Destructors
    CMachineNameMenu( CXItem* pParent );
    ~CMachineNameMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );

    // Public Methods
    HRESULT SetMachineName( char* MachineName );                // Sets the MachineName in to our local member
    HRESULT SetMachineName( WCHAR* MachineName );               // Sets the MachineName in to our local member

private:
	WCHAR	 m_MachineName[DATAVALUE_MACHINENAME_LENGTH + 1];   // Holds the MachineName until the user is ready to commit
    BOOL     m_bDisplayInUseMessage;                            // Used when the machine name is already in use

    // Private Methods
    void Leave( CXItem* pItem );                                // This should be called whenever a user leaves this menu
};

#endif // _MACHINENAMEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\machinenamemenu.cpp ===
/*****************************************************
*** machinenamemenu.cpp
***
*** CPP file for our XShell Machine Name class.
***
*** by Victor Blanco
*** December 2nd, 2000
***
*****************************************************/

#include "stdafx.h"
#include "machinenamemenu.h"
#include "launchmenu.h"

extern CXItem*          g_pRootMenu;                // Pointer to the menu that is our "main, or root" menu
extern DWORD            g_dwShellState;             // Defines the current state of the XShell
extern BOOL             g_bUpdateNameAddrTexture;   // Determines if we need to update the machine name & IP Address
extern CXSettings       g_XboxSettings;             // Settings that are stored on the Xbox
extern CSoundCollection g_Sounds;                   // Used to generate all sounds for the XShell

// Constructors
CMachineNameMenu::CMachineNameMenu( CXItem* pParent )
: CKeyboardMenu( pParent ),
m_bDisplayInUseMessage( FALSE )
{
	ZeroMemory( m_MachineName, sizeof( WCHAR ) * DATAVALUE_MACHINENAME_LENGTH + 1 );

    SetTitle( MENU_TITLE_MACHINE );
}


// Destructor
CMachineNameMenu::~CMachineNameMenu()
{
}


// Draws a menu on to the screen
void CMachineNameMenu::Action( CUDTexture* pTexture )
{
    // If we don't need to update our texture, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Toggle our Texture Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    CKeyboardMenu::Action( pTexture );

	// Draw our MachineName field
	pTexture->DrawText( ITEM_MACHINENAME_DATA_X, KEYBOARD_MACHINENAMEHEADER_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_MachineName );

    // Draw the Machine Name in use error message if needed
    if( m_bDisplayInUseMessage )
    {
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MENU_MACHINENAME_INUSE_MESSAGE ) / 2.0f ), MENU_MACHINENAME_INUSE_YPOS, COLOR_TVSAFE_RED, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", MENU_MACHINENAME_INUSE_MESSAGE );
    }

    // Unlock our Texture
    pTexture->Unlock();
}


// Handles input (of the BUTTONS) for the current menu
void CMachineNameMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )            //backspace
			{
				int len = wcslen( m_MachineName );
				
				if(len > 0)
				{
                    m_bUpdateTexture = TRUE;
                    m_bDisplayInUseMessage = FALSE;  // Make sure our in use message is disabled

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

					len = len - 1;
					m_MachineName[len] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok" ) )      //ok
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( FAILED( g_XboxSettings.SetMachineName( m_MachineName ) ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CMachineNameMenu::HandleInput():Failed to set the machine name, already in use!!" );

                    m_bUpdateTexture = TRUE;
                    m_bDisplayInUseMessage = TRUE;

                    return;
                }

                g_bUpdateNameAddrTexture = TRUE;    // We changed the machine name, update the Name/Addr Texture
                
                // If we are in Config Mode, return to the root
                if( SHELLSTATE_NOCONFIG & g_dwShellState )
                {
                    g_dwShellState &= ~SHELLSTATE_NOCONFIG;     // Set the state back to normal

                    Leave( g_pRootMenu );                       // Return to the root menu
                }
                else if( GetParent() )                          // Go Back one menu
                {
                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel" ) )  //cancel
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // If we are in Config Mode, return to the root
                if( SHELLSTATE_NOCONFIG & g_dwShellState )
                {
                    g_dwShellState &= ~SHELLSTATE_NOCONFIG;     // Set the state back to normal
                    Leave( g_pRootMenu );                   // Return to the root menu
                }
                else if( GetParent() ) // Go Back one menu
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an MachineName
                if( wcslen( m_MachineName ) < DATAVALUE_MACHINENAME_LENGTH )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

				    wcscat( m_MachineName, m_keyPad[m_xKeypos][m_yKeypos].resultChar );

                    m_bDisplayInUseMessage = FALSE;  // Make sure our in use message is disabled
                    
                    if( m_bShift )
                    {
                        m_bShift = FALSE;                // Make sure we toggle out of shift mode
                        GenerateKeypad();
                    }
                }
			}
            break;
        }
    case BUTTON_B:
        {
            // If we are in Config Mode, return to the root
            if( SHELLSTATE_NOCONFIG & g_dwShellState )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                g_dwShellState &= ~SHELLSTATE_NOCONFIG; // Set the state back to normal
                Leave( g_pRootMenu );               // Return to the root menu
            }
            else if( GetParent() ) // Go Back one menu
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
			int len = wcslen( m_MachineName );
			
			if(len > 0)
			{
                m_bUpdateTexture = TRUE;
                m_bDisplayInUseMessage = FALSE;  // Make sure our in use message is disabled

                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

				len = len - 1;
				m_MachineName[len] = L'\0';
			}

            break;
        }
    }
}


// Sets the MachineName in to our local member
HRESULT CMachineNameMenu::SetMachineName( char* MachineName )
{
    if( !MachineName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMachineNameMenu::SetMachineName( char ):MachineName was not set!!" );

        return E_INVALIDARG;
    }

    ZeroMemory( m_MachineName, sizeof( WCHAR ) * DATAVALUE_MACHINENAME_LENGTH + 1 );
    _snwprintf( m_MachineName, DATAVALUE_MACHINENAME_LENGTH, L"%S", MachineName );

    return S_OK;
}


// Sets the MachineName in to our local member
HRESULT CMachineNameMenu::SetMachineName( WCHAR* MachineName )
{
    if( !MachineName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMachineNameMenu::SetMachineName( WCHAR ):MachineName was not set!!" );

        return E_INVALIDARG;
    }

    ZeroMemory( m_MachineName, sizeof( WCHAR ) * DATAVALUE_MACHINENAME_LENGTH + 1 );
    _snwprintf( m_MachineName, DATAVALUE_MACHINENAME_LENGTH, MachineName );

    return S_OK;
}


// This should be called whenever a user leaves this menu
void CMachineNameMenu::Leave( CXItem* pItem )
{
    // Call our base-class leave
    CKeyboardMenu::Leave( pItem );

    if( m_bShift )
    {
        m_bShift = FALSE;
        GenerateKeypad();
    }
    m_bDisplayInUseMessage = FALSE;
    m_bDropKeyPress = TRUE;
    m_xKeypos = m_yKeypos = 0;
}


// This will be called whenever the user enters this menu
void CMachineNameMenu::Enter()
{
    // Call the base-class enter
    CKeyboardMenu::Enter();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\madisplaymenu.h ===
/*****************************************************
*** madisplaymenu.h
***
*** Header file for our XShell Memory Area Display 
*** menu class.  This class will list out all Memory
*** devices on the system, and display their names
*** in the proper format, with the amount of space
*** free on each device
***
*** by James N. Helm
*** June 7th, 2001
***
*****************************************************/

#ifndef _MADISPLAYMENU_H_
#define _MADISPLAYMENU_H_

#include "menuscreen.h"  // Base menu type
#include "xonlinefuncs.h"

enum MemAreaIndexMappings
{
    ENUM_MADISPLAY_MU1A,
    ENUM_MADISPLAY_MU1B,
    ENUM_MADISPLAY_MU2A,
    ENUM_MADISPLAY_MU2B,
    ENUM_MADISPLAY_MU3A,
    ENUM_MADISPLAY_MU3B,
    ENUM_MADISPLAY_MU4A,
    ENUM_MADISPLAY_MU4B,
    ENUM_MADISPLAY_HARD_DRIVE
};

class CMADisplayMenu : public CMenuScreen
{
public:
    CMADisplayMenu( CXItem* pParent );
    ~CMADisplayMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );
    BOOL GetCancelled() { return m_bCancelled; };           // Used to determine if the user cancelled the menu
    void SetInfo( BOOL bDisplaySize,                        // Sets the menu to allow certain actions
                  BOOL bAllowSelect );
    unsigned int GetSelectedMemArea();                      // Returns the Memory Area that the user selected

    // Public Methods
    HRESULT Init( char* menuFileName );     // Initialize our font and settings

private:
    // Private Properties
    BOOL m_bCancelled;                                              // Used to determine if the user cancelled the MA Display Menu
    BOOL m_bDisplaySize;                                            // Used to determine if the menu should display sizes, or num users
    BOOL m_bAllowSelect;                                            // Used to determine if the user should be allowed to select a menu or not
    XONLINE_USER  m_aOnlineUsers[XONLINE_MAX_STORED_ONLINE_USERS];  // Online users that will live on Memory Areas

    // Private Methods
    void Leave( CXItem* pItem );            // This should be called whenever a user leaves this menu
};

#define MEMORY_AREA_HIDDEN_BLOCK_BOUNDS 50000

#endif // _MADISPLAYMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\launchmenu.h ===
/*****************************************************
*** launchmenu.h
***
*** Header file for our XShell Launch menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 2nd, 2000
***
*****************************************************/

#ifndef _LAUNCHMENU_H_
#define _LAUNCHMENU_H_

extern BOOL g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
extern BOOL g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow

#include "menuscreen.h"  // Base menu type

// Submenus
#include "optionsmenu.h"
#include "onlinemenu.h"
#include "sysinfomenu.h"

// Thread to enumerate XBEs
#include "xbedirmonitor.h"

class CLaunchMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CLaunchMenu( CXItem* pParent );
    ~CLaunchMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT      Init( char* menuFileName );                                    // Initialize the Menu
    unsigned int GetSelectorPos() const { return m_nSelectorPos; };             // Get the index of the selector bar on our screen
    unsigned int GetTopIndexOfItem() const { return m_nTopIndexOfItem; };       // Get the index in our list of the top item that is being displayed on the screen
    unsigned int GetBottomIndexOfItem() const { return m_nBottomIndexOfItem; }; // Get the index in our list of the top item that is being displayed on the screen
    unsigned int GetNumItems() { return m_pXBEList->GetNumItems(); };           // Return the number of menu items on our current screen
    unsigned int GetNumItemsToDisplay();                                        // Get the number of items that should be displayed on the screen
    CXItem* GetItemPtr( enum XShellMenuIds menuID );                            // Returns a pointer to a sub-menu

    HRESULT SetSelectorPos( unsigned int index );                               // Set the Selector position on our screen (index)
    HRESULT SetTopIndexOfItem( unsigned int index );                            // Set the top index of item that should be displayed on our screen
    HRESULT SetBottomIndexOfItem( unsigned int index );                         // Set the bottom index of item that should be displayed on our screen

    void SetDisplayDownArrow( BOOL bChoice ) { g_bDisplayDownArrow = bChoice; };
    void SetDisplayUpArrow( BOOL bChoice )   { g_bDisplayUpArrow = bChoice; };

    static NTSTATUS WriteTitleInfoAndReboot(LPCSTR pszLaunchPath, LPCSTR pszDDrivePath,
        DWORD dwLaunchDataType, DWORD dwTitleId, PLAUNCH_DATA pLaunchData);

private:
    // Vertext structure
    struct TEXVERTEX
    {
	    float       x, y, z, rhw; // position
	    D3DCOLOR    cDiffuse;     // color
        float       tu, tv;       // Texture coordinates
    };

    // The custom FVF, which describes the custom vertex structure.
    #define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)

    CXBEList*      m_pXBEList;              // Pointer to an XBEList object used to display information on our menu
    CXBEDirMonitor m_XBEDirMonitor;         // Monitors our XBE directory so that we can deal with changes
    unsigned int   m_nSelectorPos;          // The position of the selector on our screen (index)
    unsigned int   m_nTopIndexOfItem;       // Index in our list of the first item to be displayed on our screen
    unsigned int   m_nBottomIndexOfItem;    // Index in our list of the first item to be displayed on our screen
    BOOL           m_bCheckedConfig;        // Checks if the machine name has been set, if not, on FIRST load, will send the user to config
    unsigned int   m_uiPrevNumItems;        // The number of XBE Items had during our last scan
    IDirect3DVertexBuffer8* m_pVB;          // Vertex Buffer for our texture
    TEXVERTEX      m_TVB[4];                // Texture Vertext Buffer
    char           m_pszSecretKeyCombo[5];  // Used to determine when to display the 'Secret' info screen

    // Menus
    COptionsMenu   m_OptionsMenu;           // Options Menu off of the root
    COnlineMenu    m_OnlineMenu;            // Online Menu off of the root
    CSysInfoMenu   m_SysInfoMenu;           // System Information Menu

    // Methods
    void AdjustDisplayArrows();             // Adjust the helpful scrolling arrows
    void SetInitialSelectState();           // Adjust our menu to it's initial (empty) state
    void Leave( CXItem* pItem );            // This should be called whenever a user leaves this menu
    BOOL ProcessSecretKey();                // Checks the secret key to see if we should display the 'secret' menu
    void ComputeSecretKey( char* Buffer );  // Computes the secret key based upon the MAC Address
};

#endif // _LAUNCHMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\memorymenu.h ===
/*****************************************************
*** memorymenu.h
***
*** Header file for our XShell Format menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** January 10th, 2001
***
*****************************************************/

#ifndef _MEMORYMENU_H_
#define _MEMORYMENU_H_

#include "menuscreen.h"  // Base menu type

// Sub Menus
#include "memoryoptions.h"

class CMemoryMenu : public CMenuScreen
{
public:
    CMemoryMenu( CXItem* pParent );
    ~CMemoryMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );     // Initialize our font and settings

private:
    // Menus
    CMemoryOptions m_MemoryOptionsMenu;     // The Memory Options Menu Screen

    // Private Methods
};

#endif // _MEMORYMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\madisplaymenu.cpp ===
/*****************************************************
*** madisplaymenu.cpp
***
*** CPP file for our XShell Memory Area Display 
*** menu class.  This class will list out all Memory
*** devices on the system, and display their names
*** in the proper format, with the amount of space
*** free on each device
***
*** by James N. Helm
*** June 7th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "madisplaymenu.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell
extern BOOL             g_bMUsChanged;      // Tracks whether MU's have been inserted or removed
extern DWORD            g_dwInsertedMUs;    // Tracks which MUs are inserted or removed
extern CMemoryUnit      g_MemoryUnits[8];   // Memory Units that can be inserted, or removed
extern CHardDrive       g_XboxHardDrive;    // Used to configure the Xbox Hard Drive
extern XFONT*           g_pFont;

// Constructors
CMADisplayMenu::CMADisplayMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_bCancelled( FALSE ),
m_bDisplaySize( TRUE ),
m_bAllowSelect( FALSE )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMADisplayMenu::CMADisplayMenu(ex)" );

    m_uiNumItems = NUM_XBOX_MU_SLOTS + 1;
    SetSelectedItem( 0 );

    // Zero out our users
    ZeroMemory( m_aOnlineUsers, sizeof( m_aOnlineUsers ) );

    SetTitle( MENU_TITLE_MADISPLAY );
}


// Destructor
CMADisplayMenu::~CMADisplayMenu()
{
}


// Draws a menu on to the screen
void CMADisplayMenu::Action( CUDTexture* pTexture )
{
    // If the state has changed, update our texture and our previous mask
    if( g_bMUsChanged || m_bUpdateTexture )
        m_bUpdateTexture = TRUE;

    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
        return;
    else // reset the texture flag to FALSE
        m_bUpdateTexture = FALSE;

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    // List our Controllers and MU's (if needed)
    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_MADISPLAYMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_MADISPLAYMENU_FONT_HEIGHT;

    // Draw a selector if needed
    if( ( GetNumItems() - 1 ) != GetSelectedItem() ) // A Memory Unit must be selected
    {
        // Make sure our selected item still exists
        if( !( g_dwInsertedMUs & g_dwMUBitMask[GetSelectedItem()] ) )
        {
            // Determine if there is another item we can select
            for( int y = 0; y < NUM_XBOX_MU_SLOTS; ++y )
            {
                if( g_dwInsertedMUs & g_dwMUBitMask[y] )
                    break;
            }

            SetSelectedItem( y );
        }
    }

    if( m_bAllowSelect )
    {
        float X1Pos = MENUBOX_SELECTBAR_X1;
        float Y1Pos = MENUBOX_TEXTAREA_Y1 + MADISPLAYMENU_TOP_BORDER_SIZE + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - ITEM_SELECTOR_BORDER_SPACE;
        float X2Pos = MENUBOX_SELECTBAR_X2;
        float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
        
        pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );
    }

    // Draw the MU Devices items
    for( unsigned int x = 0; x < NUM_XBOX_MU_SLOTS; ++x )
    {
        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MADISPLAYMENU_TOP_BORDER_SIZE + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        // Skip any MU's that are not inserted
        if( !( g_dwInsertedMUs & g_dwMUBitMask[x] ) )
        {
            pTexture->DrawText( XPos, YPos, MUFORMATDLG_UNAVAIL_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", g_MemoryUnits[x].GetDefaultNamePtr() );
            continue;
        }
        
        // Check to see if our MU is formatted or not
        if( !g_MemoryUnits[x].IsFormatted() )
        //
        // No, the MU is not formatted, display the appropriate message
        //
        {
            pTexture->DrawText( XPos, YPos, MADISPLAYMENU_UNFORMATTED_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls (Not Formatted)", g_MemoryUnits[x].GetDefaultNamePtr() );
        }
        else
        //
        // Yes, the MU is formatted, display the appropriate message
        //
        {
            if( m_bDisplaySize )
            {
                // Check to see if the MU has a name
                if( g_MemoryUnits[x].IsNamed() )    // Yes, the MU has a name
                    pTexture->DrawText( XPos, YPos, MADISPLAYMENU_AVAIL_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls - %ls (%d/%d)", g_MemoryUnits[x].GetDefaultNamePtr(), g_MemoryUnits[x].GetNamePtr(), g_MemoryUnits[x].GetFreeBlocks(), g_MemoryUnits[x].GetTotalBlocks() - 1 );
                else    // No, the MU doesn't have a name
                    pTexture->DrawText( XPos, YPos, MADISPLAYMENU_AVAIL_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls (%d/%d)", g_MemoryUnits[x].GetDefaultNamePtr(), g_MemoryUnits[x].GetFreeBlocks(), g_MemoryUnits[x].GetTotalBlocks() - 1 );
            }
            else // Display user information
            {
                // Get the name (if any) of user from each memory area
                BOOL bUserExists = FALSE;
                HRESULT hr = OnlineGetUserFromMU( g_MemoryUnits[x].GetPort(),
                                                  g_MemoryUnits[x].GetSlot(),
                                                  (PXONLINE_USER) m_aOnlineUsers,
                                                  &bUserExists );
                if( FAILED( hr ) )
                    XDBGWRN( APP_TITLE_NAME_A, "CMADisplayMenu::Action():Failed to get the users from the MU!! - '#%d', Error - '0x%08X', '%d'", x, hr, hr );

                CHAR pszMessage[MAX_PATH+1];
                pszMessage[MAX_PATH] = '\0';

                if( bUserExists )
                    sprintf( pszMessage, "%hs.%hs", m_aOnlineUsers[0].name, m_aOnlineUsers[0].kingdom );
                else
                    strcpy( pszMessage, "0 Users" );                    

                // Display the proper message to the user (No MU Name)
                pTexture->DrawText( XPos, YPos, MADISPLAYMENU_AVAIL_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls (%hs)", g_MemoryUnits[x].GetDefaultNamePtr(), pszMessage );
            }
        }
    }

    float XPos = MENUBOX_TEXTAREA_X1;
    float YPos = MENUBOX_TEXTAREA_Y1 + MADISPLAYMENU_TOP_BORDER_SIZE + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

    if( m_bDisplaySize )
    {
        // Add the block sizes to the hard drive memory unit
        if( g_XboxHardDrive.GetFreeBlocks() >= MEMORY_AREA_HIDDEN_BLOCK_BOUNDS )
            pTexture->DrawText( XPos, YPos, MADISPLAYMENU_AVAIL_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s (%d+ blocks available)", g_XboxHardDrive.GetDefaultNamePtr(), MEMORY_AREA_HIDDEN_BLOCK_BOUNDS );
        else
            pTexture->DrawText( XPos, YPos, MADISPLAYMENU_AVAIL_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s (%d blocks available)", g_XboxHardDrive.GetDefaultNamePtr(), g_XboxHardDrive.GetFreeBlocks() );
    }
    else // Display Users
    {
        // Get the number of users that live on the Hard Drive
        DWORD dwNumUsers = 0;
        HRESULT hr = OnlineGetUsersFromHD( (PXONLINE_USER) m_aOnlineUsers, &dwNumUsers );
        if( FAILED( hr ) )
            XDBGWRN( APP_TITLE_NAME_A, "CMADisplayMenu::Action():Failed to get the users from the hard drive!!" );

        if( 1 == dwNumUsers )
            pTexture->DrawText( XPos, YPos, MADISPLAYMENU_AVAIL_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s (%hs.%hs)", g_XboxHardDrive.GetDefaultNamePtr(), m_aOnlineUsers[0].name, m_aOnlineUsers[0].kingdom );
        else
            pTexture->DrawText( XPos, YPos, MADISPLAYMENU_AVAIL_MU_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s (%d %ls)", g_XboxHardDrive.GetDefaultNamePtr(), dwNumUsers, dwNumUsers == 1 ? L"User" : L"Users" );
    }


    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock our texture and restore our render target
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CMADisplayMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CMADisplayMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
            return;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( ( GetNumItems() != 0 ) && m_bAllowSelect && ( GetSelectedItem() > 0 ) )
            {
                for( int x = GetSelectedItem() - 1; x >= 0; --x )
                {
                    if( g_dwInsertedMUs & g_dwMUBitMask[x] )
                    {
                        // Since we are changing the selection, mark our texture for updating
                        m_bUpdateTexture = TRUE;

                        // Play the Menu Item Select Sound
                        g_Sounds.PlayMenuItemSelectSound();

                        SetSelectedItem( x );

                        break;
                    }
                }
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( ( GetNumItems() != 0 ) && m_bAllowSelect && ( GetSelectedItem() < (int)( GetNumItems() - 1 ) ) )
            {
                for( int x = GetSelectedItem() + 1; x < NUM_XBOX_MU_SLOTS; ++x )
                {
                    if( g_dwInsertedMUs & g_dwMUBitMask[x] )
                        break;
                }

                // Since we are changing the selection, mark our texture for updating
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                SetSelectedItem( x );
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CMADisplayMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            // Go Back one menu
            if( GetParent() )
                Leave( GetParent() );

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            // Play the Back Sound
            g_Sounds.PlayBackSound();

            // Go Back one menu
            if( GetParent() )
                Leave( GetParent() );

            break;
        }
    }
}


// Initialize the Menu
HRESULT CMADisplayMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMADisplayMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    return hr;
}


// This will be called whenever the user leaves this menu
void CMADisplayMenu::Leave( CXItem* pItem )
{
    CMenuScreen::Leave( pItem );

    // Reset the menu to it's defaults
    SetTitle( MENU_TITLE_MADISPLAY );
    SetInfo( TRUE, FALSE );
}


// This will be called whenever the user enters this menu
void CMADisplayMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Reset our cancelled state
    m_bCancelled = FALSE;

    // Zero out our users
    ZeroMemory( m_aOnlineUsers, sizeof( m_aOnlineUsers ) );

    // SetSelectedItem( 0 );
}


// Returns the Memory Area that the user selected
unsigned int CMADisplayMenu::GetSelectedMemArea()
{
    // Hard Drive Selected
    if( ( GetNumItems() - 1 ) == GetSelectedItem() )
        return 0;

    return( GetSelectedItem() + 1 );
}


// Sets the menu to allow certain actions
void CMADisplayMenu::SetInfo( BOOL bDisplaySize, BOOL bAllowSelect )
{
    m_bDisplaySize = bDisplaySize;
    m_bAllowSelect = bAllowSelect;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\memorymenu.cpp ===
/*****************************************************
*** memorymenu.cpp
***
*** CPP file for our XShell Memory menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** January 10th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "memorymenu.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell
extern BOOL             g_bMUsChanged;      // Tracks whether MU's have been inserted or removed
extern DWORD            g_dwInsertedMUs;    // Tracks which MUs are inserted or removed
extern CMemoryUnit      g_MemoryUnits[8];   // Memory Units that can be inserted, or removed
extern XFONT*           g_pFont;

// Constructors
CMemoryMenu::CMemoryMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_MemoryOptionsMenu( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMemoryMenu::CMemoryMenu(ex)" );

    m_uiNumItems = NUM_XBOX_MU_SLOTS;
    SetSelectedItem( 0 );

    SetTitle( MENU_TITLE_MEMORY );
}


// Destructor
CMemoryMenu::~CMemoryMenu()
{
}


// Draws a menu on to the screen
void CMemoryMenu::Action( CUDTexture* pTexture )
{
    // If the state has changed, update our texture and our previous mask
    if( g_bMUsChanged || m_bUpdateTexture )
    {
        m_bUpdateTexture = TRUE;
    }

    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // reset the texture flag to FALSE
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    // List our Controllers and MU's (if needed)
    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_FORMATMU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_FORMATMU_FONT_HEIGHT;

    BOOL bDrawSelector = TRUE;

    // Draw a box behind the currently highlighted choice if needed
    if( !( g_dwInsertedMUs & g_dwMUBitMask[GetSelectedItem()] ) )
    {
        bDrawSelector = FALSE;

        // Determine if there is another item we can select
        for( int y = 0; y < NUM_XBOX_MU_SLOTS; ++y )
        {
            if( g_dwInsertedMUs & g_dwMUBitMask[y] )
            {
                SetSelectedItem( y );
                bDrawSelector = TRUE;
                break;
            }
        }
    }

    // Draw the selector bar if we have to
    if( bDrawSelector )
    {
        float X1Pos = MENUBOX_SELECTBAR_X1;
        float Y1Pos = MENUBOX_TEXTAREA_Y1 + MUFORMATDLG_TOP_BORDER_SIZE + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - ITEM_SELECTOR_BORDER_SPACE;
        float X2Pos = MENUBOX_SELECTBAR_X2;
        float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
        
        pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );
    }

    // Draw the MU Devices items
    for( unsigned int x = 0; x < NUM_XBOX_MU_SLOTS; ++x )
    {
        DWORD dwColor;

        // Check to see if the MU is inserted
        if( g_dwInsertedMUs & g_dwMUBitMask[x] )
        //
        // Yes, the MU is inserted
        //
        {
            // Check to see if the MU is formatted
            if( !g_MemoryUnits[x].IsFormatted() )
            //
            // No, it's not formatted, color the MU accordingly
            //
            {
                dwColor = MUFORMATDLG_UNFORMATTED_MU_COLOR;
            }
            else
            //
            // Yes, it is formatted, determine if it's the selected MU, and color it
            // accordingly
            //
            {
                // Check to see if the MU is selected
                if( GetSelectedItem() == (int)x )
                //
                // Yes, the current MU is the selected one
                //
                {
                    dwColor = MUFORMATDLG_SELECTED_MU_COLOR;
                }
                else
                //
                // No, the current MU is not the selected one
                //
                {
                    dwColor = MUFORMATDLG_AVAIL_MU_COLOR;
                }
            }
        }
        else
        //
        // No, the MU is not inserted
        //
        {
            dwColor = MUFORMATDLG_UNAVAIL_MU_COLOR;
        }
        
        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MUFORMATDLG_TOP_BORDER_SIZE + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        // Check to see if our MU is formatted or not
        if( ( g_dwInsertedMUs & g_dwMUBitMask[x] ) && ( !g_MemoryUnits[x].IsFormatted() ) )
        //
        // No, the MU is not formatted, display the appropriate message
        //
        {
            pTexture->DrawText( XPos, YPos, dwColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s (Not Formatted)", g_pwszMUPortNames[x] );
        }
        else
        //
        // Yes, the MU is formatted, display the appropriate message
        //
        {
            // Check to see if the MU has a name
            WCHAR pwszCurrentMUName[MAX_MUNAME];
            ZeroMemory( pwszCurrentMUName, sizeof( WCHAR ) * MAX_MUNAME );

            g_MemoryUnits[x].GetName( pwszCurrentMUName, MAX_MUNAME );

            if( pwszCurrentMUName[0] != '\0' )
            //
            // Yes, the MU has a name
            //
            {
                pTexture->DrawText( XPos, YPos, dwColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s (%s)", g_pwszMUPortNames[x], pwszCurrentMUName );
            }
            else
            //
            // No, the MU doesn't have a name
            //
            {
                pTexture->DrawText( XPos, YPos, dwColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszMUPortNames[x] );
            }
        }
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock our texture and restore our render target
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CMemoryMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CMemoryMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                for( int x = GetSelectedItem() - 1; x >= 0; --x )
                {
                    if( g_dwInsertedMUs & g_dwMUBitMask[x] )
                    {
                        // Since we are changing the selection, mark our texture for updating
                        m_bUpdateTexture = TRUE;

                        // Play the Menu Item Select Sound
                        g_Sounds.PlayMenuItemSelectSound();

                        SetSelectedItem( x );

                        break;
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                for( int x = GetSelectedItem() + 1; x < NUM_XBOX_MU_SLOTS; ++x )
                {
                    if( g_dwInsertedMUs & g_dwMUBitMask[x] )
                    {
                        // Since we are changing the selection, mark our texture for updating
                        m_bUpdateTexture = TRUE;

                        // Play the Menu Item Select Sound
                        g_Sounds.PlayMenuItemSelectSound();

                        SetSelectedItem( x );

                        break;
                    }
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CMemoryMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any MUs inserted
            if( g_dwInsertedMUs & g_dwMUBitMask[GetSelectedItem()] )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                m_MemoryOptionsMenu.SetMemoryUnit( &g_MemoryUnits[GetSelectedItem()] );

                Leave( &m_MemoryOptionsMenu );
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT CMemoryMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMemoryMenu::Init()" );

    CMenuScreen::Init( menuFileName );

    // Init our Memory Options Menu Screen
    m_MemoryOptionsMenu.SetParent( this ); // Must call this BEFORE Init, since Init of MemOpts will use "GetParent()"
    m_MemoryOptionsMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\memopts.mnu" );

    return S_OK;
}


// This will be called whenever the user enters this menu
void CMemoryMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\memoryoptions.h ===
/*****************************************************
*** memoryoptions.h
***
*** Header file for our XShell Memory Options class.
*** This screen will allow the user to select an
*** action that they would like to perform on a
*** memory area
***
*** by James N. Helm
*** February 15th, 2001
***
*****************************************************/

#ifndef _MEMORYOPTIONS_H_
#define _MEMORYOPTIONS_H_

#include "keypadmenu.h"

#include "memoryunit.h"

// Sub-Menus
#include "hexkeypadmenu.h"
#include "muformat.h"
#include "muunformat.h"
#include "muname.h"

#define MEMORYOPTIONS_NUM_ROWS    2
#define MEMORYOPTIONS_NUM_COLS    2

class CMemoryOptions : public CKeypadMenu
{
public:
    CMemoryOptions( CXItem* pParent );
    ~CMemoryOptions();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();                                       // Should be called when this menu is entered / activated
    
    void Action( CUDTexture* pTexture );
    
    void HandleInput( enum BUTTONS buttonPressed,
                      BOOL bFirstPress );
    
    void HandleInput( enum CONTROLS controlPressed,
                      BOOL bFirstPress );

    void HandleInput( enum JOYSTICK joystick, 
                      int nThumbY,
                      int nThumbX,
                      BOOL bFirstYPress,
                      BOOL bFirstXPress );

    // Public Methods
    HRESULT SetMemoryUnit( CMemoryUnit* pMemoryUnit );  // Set the address of the Memory Unit to be used
    HRESULT Init( char* menuFileName );                 // Initialize the Menu

private:
    CMemoryUnit*    m_pMemoryUnit;          // Active Memory Unit
    WCHAR           m_pwszBlockCount[4];    // Used to hold our block count for MUs
    BOOL            m_bCollectingBlocks;    // Used to determine the block size of the file to create

    // Menus
    CMUFormat       m_MUFormatDlg;          // The dialog-like menu to Format an MU
    CMUUnFormat     m_MUUnFormatDlg;        // The dialog-like menu to Format an MU
    CMUName         m_MUNameDlg;            // The dialog-like menu to Name an MU
    CHexKeypadMenu  m_HexKeypadMenu;        // Used to get Title ID's

    // Private Methods
    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pScreen );
    void Leave( CXItem* pItem );    // This will be called whenever this menu is exited
};

#endif // _MEMORYOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\memoryoptions.cpp ===
/*****************************************************
*** memoryoptions.cpp
***
*** CPP file for our XShell Memory Options class.
*** This screen will allow the user to select an
*** action that they would like to perform on a
*** memory area
***
*** by James N. Helm
*** February 15th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "memoryoptions.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell
extern BOOL             g_bMUsChanged;      // Tracks whether MU's have been inserted or removed
extern DWORD            g_dwInsertedMUs;    // Tracks which MUs are inserted or removed

// Constructors
CMemoryOptions::CMemoryOptions( CXItem* pParent )
: CKeypadMenu( pParent ),
m_pMemoryUnit( NULL ),
m_MUFormatDlg( NULL ),
m_MUUnFormatDlg( NULL ),
m_MUNameDlg( NULL ),
m_HexKeypadMenu( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMemoryOptions::CMemoryOptions(ex)" );

    m_uiNumItems = NUM_XBOX_MU_SLOTS;
    SetSelectedItem( 0 );

    GenerateKeypad();
	m_xKeypos = 0;
	m_yKeypos = 0;

    SetTitle( MENU_TITLE_MEMORYOPTIONS );

    ZeroMemory( m_pwszBlockCount, sizeof( WCHAR ) * 4 );

    // Set the parent of our HexKeypad Menu to be this menu
    m_HexKeypadMenu.SetParent( this );
}


// Destructor
CMemoryOptions::~CMemoryOptions()
{
}

// Initialize the Menu
HRESULT CMemoryOptions::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMemoryOptions::Init()" );

    CKeypadMenu::Init( menuFileName );

    // Initialize our MU Format Dialog-Like Menu
    m_MUFormatDlg.Init( FILE_DATA_MENU_DIRECTORY_A "\\muformat.mnu" );
    m_MUFormatDlg.SetParent( GetParent() );

    // Initialize our MU Format Dialog-Like Menu
    m_MUUnFormatDlg.Init( FILE_DATA_MENU_DIRECTORY_A "\\muunformat.mnu" );
    m_MUUnFormatDlg.SetParent( GetParent() );

    // Init our MU Name Dialog Menu
    m_MUNameDlg.Init( FILE_DATA_MENU_DIRECTORY_A "\\muname.mnu" );
    m_MUNameDlg.SetParent( GetParent() );

    return S_OK;
}


// Draws a menu on to the screen
void CMemoryOptions::Action( CUDTexture* pTexture )
{
    //
    // Ensure the MU we are dealing with is still plugged in
    //
    
    // Determine the state of the MU's and Controllers
    // If the MU is no longer plugged in, immediately return to the previous screen
    if( !( g_dwInsertedMUs & g_dwMUBitMask[GetSelectedItem()] ) )
    {
        if( GetParent() )
        {
            Leave( GetParent() );
        }
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Check to see if we should create our MU file, and then leave
    if( m_bCollectingBlocks )
    {
        m_bCollectingBlocks = FALSE;

        // Check to see if the user set a value
        if( '\0' != m_pwszBlockCount[0] )
        {
            // Store the value in to a usable number
            WCHAR* pwszStopString = NULL;
            DWORD dwFileSize = wcstol( m_pwszBlockCount, &pwszStopString, 10 );

            if( dwFileSize > m_pMemoryUnit->GetFreeBlocks() )
            {
                dwFileSize = m_pMemoryUnit->GetFreeBlocks();
            }

            // Create the file on the MU
            char pszDir[4];

            sprintf( pszDir, "%c:\\", m_pMemoryUnit->GetUDataDrive() );
            m_pMemoryUnit->FillArea( pszDir, dwFileSize );
        }

        // Exit this menu
        Leave( GetParent() );

        return;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CKeypadMenu::Action( pTexture );

    // Draw our Text Message
    pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MENU_MEMORYOPTIONS_ACTION_TEXT ) / 2.0f ), MENU_MEMORYOPTOINS_ACTION_TEXT_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", MENU_MEMORYOPTIONS_ACTION_TEXT );

    // Insert the MU and Port the user is dealing with on to the texture
    WCHAR pwszMUName[MAX_MUNAME];
    ZeroMemory( pwszMUName, sizeof( WCHAR ) * MAX_MUNAME );

    m_pMemoryUnit->GetName( pwszMUName, MAX_MUNAME );
    if( L'\0' == pwszMUName[0] )
    //
    // The MU doesn't have a name, so don't use it
    //
    {
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszMUPortNames[GetSelectedItem()] ) / 2.0f ), MENU_MEMORYOPTOINS_ACTION_TEXT_YPOS + m_uiFontHeightOfItem + ITEM_SELECTOR_BORDER_SPACE, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszMUPortNames[GetSelectedItem()] );
    }
    else
    //
    // The MU has a name, so use it
    //
    {
        WCHAR pwszFullMUName[255];
        ZeroMemory( pwszFullMUName, sizeof( WCHAR ) * 255 );

        wsprintf( pwszFullMUName, L"%s (%s)", g_pwszMUPortNames[GetSelectedItem()], pwszMUName );
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( pwszFullMUName ) / 2.0f ), MENU_MEMORYOPTOINS_ACTION_TEXT_YPOS + m_uiFontHeightOfItem + ITEM_SELECTOR_BORDER_SPACE, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", pwszFullMUName );
    }

    // Unlock our texture
    pTexture->Unlock();
}


void CMemoryOptions::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = 1;
	int width  = 103;
	int height = 32;
	int spacer = 10;
	int ygrid  = MEMORYOPTIONS_NUM_ROWS;
	int xstart = MENU_MEMORYOPTIONS_BUTTON_X1;
	int ystart = MENU_MEMORYOPTIONS_BUTTON_Y1;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	width  = 103;
	height = 32;
	spacer = 10;
    ygrid  = MEMORYOPTIONS_NUM_ROWS;
	xstart = MENU_MEMORYOPTIONS_BUTTON_X1 + width + spacer;
	ystart = MENU_MEMORYOPTIONS_BUTTON_Y1;
	
	currentx = xstart;
	currenty = ystart;
	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Set the text of the keys
    m_keyPad[0][0].defineText( MENU_MEMORYOPTIONS_OPTION1_TEXT ); m_keyPad[1][0].defineText( MENU_MEMORYOPTIONS_OPTION3_TEXT );
    m_keyPad[0][1].defineText( MENU_MEMORYOPTIONS_OPTION2_TEXT ); m_keyPad[1][1].defineText( MENU_MEMORYOPTIONS_OPTION4_TEXT );
}


BOOL CMemoryOptions::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < MEMORYOPTIONS_NUM_COLS; x++)
	{
		for(int y = 0; y < MEMORYOPTIONS_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                //
                // BUGBUG: HARDCODE: If the MU isn't formatted, don't display the 2nd button
                // The second button is the "Name" button
                //
                if( ( y != 0 || x != 0 ) && ( !m_pMemoryUnit->IsFormatted() ) )
                {
                    break;
                }

                if( !m_pMemoryUnit->IsFormatted() )
                {
                    if( y == 0 && x == 0 )
                    {
                        // Correct our button placement if there is only one button on this screen
                        m_keyPad[x][y].xorigin += 65;
                    }
                    else
                    {
                        break;
                    };
                }

                // Lock our Texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    dwCharColor = ITEM_SELECTED_TEXT_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, KEYPAD_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar);

                // Unlock our Texture
                pTexture->Unlock();

                // Correct our button placement if there is only one button on this screen
                if( !m_pMemoryUnit->IsFormatted() )
                {
                    m_keyPad[x][y].xorigin -= 65;
                }
            }
		}
	}
	
	return TRUE;
}


// Handle any requests for the joystick (thumb-pad)
void CMemoryOptions::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CMemoryOptions::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
			if( ( m_yKeypos != 0 ) && ( m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos--;
			}

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
			if( ( m_yKeypos != ( MEMORYOPTIONS_NUM_ROWS - 1 ) ) &&
                ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) &&
                ( TRUE == m_pMemoryUnit->IsFormatted() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos++;
			}

            break;
        }
    case CONTROL_DPAD_LEFT:
        {
			if( ( m_xKeypos != 0 ) && ( m_keyPad[m_xKeypos - 1][m_yKeypos].getRender() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_xKeypos--;
			}

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
			if( ( m_xKeypos != ( MEMORYOPTIONS_NUM_COLS - 1 ) ) &&
                ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) &&
                ( m_pMemoryUnit->IsFormatted() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_xKeypos++;
			}

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CMemoryOptions::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, MENU_MEMORYOPTIONS_OPTION1_TEXT ) )      // format
			{
                m_bUpdateTexture = TRUE;

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                m_MUFormatDlg.SetMemoryUnit( m_pMemoryUnit );
                Leave( &m_MUFormatDlg );
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, MENU_MEMORYOPTIONS_OPTION2_TEXT ) )  // unformat
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                m_MUUnFormatDlg.SetMemoryUnit( m_pMemoryUnit );
                Leave( &m_MUUnFormatDlg );
    		}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, MENU_MEMORYOPTIONS_OPTION3_TEXT ) )  // name
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                m_MUNameDlg.SetMemoryUnit( m_pMemoryUnit );
                Leave( &m_MUNameDlg );
    		}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, MENU_MEMORYOPTIONS_OPTION4_TEXT ) )  // create file
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                WCHAR pwszUserPrompt[50];
                pwszUserPrompt[49] = L'\0';

                _snwprintf( pwszUserPrompt, 49, L"Free Blocks %d. Enter File Size in Blocks:", m_pMemoryUnit->GetFreeBlocks() );

                // Ask the user for the block amount
                // Get the TITLE ID from the Hex Keypad
                m_pwszBlockCount[0] = L'\0';
                m_HexKeypadMenu.SetInfo( pwszUserPrompt, m_pwszBlockCount, 3 );
                m_bCollectingBlocks = TRUE;

                Leave( &m_HexKeypadMenu );
    		}

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// This will be called whenever this menu is exited
void CMemoryOptions::Leave( CXItem* pItem )
{
    // Call the base-class Leave
    CKeypadMenu::Leave( pItem );
}

// This will be called whenever this menu is entered / activated
void CMemoryOptions::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Default the focus to the format button
	m_xKeypos = 0;
	m_yKeypos = 0;

    // Make sure we don't process the first keypress
    m_bDropKeyPress = TRUE;
}


// Sets the local member to point at the proper memory unit
HRESULT CMemoryOptions::SetMemoryUnit( CMemoryUnit* pMemoryUnit )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMemoryOptions::SetMemoryUnit()" );

    if( !pMemoryUnit )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMemoryOptions::SetMemoryUnit():Invalid Argument passed in!!" );

        return E_INVALIDARG;
    }

    m_pMemoryUnit = pMemoryUnit;

    // Set the Selected Item via an index
    SetSelectedItem( m_pMemoryUnit->GetIndex() );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\messagemenu.cpp ===
/*****************************************************
*** messagemenu.h
***
*** CPP file for our Message Menu class.
*** This menu will present a message to the user, and
*** simply allow them to navigate back from where they
*** came.
***
*** by James N. Helm
*** December 11th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "messagemenu.h"

extern CSoundCollection g_Sounds;   // Used to generate all sounds for the XShell

// Constructors and Destructor
CMessageMenu::CMessageMenu( CXItem* pParent ) :
CMenuScreen( pParent )
{
    // Zero out our buffers
    for( unsigned int x = 0; x < gc_uiMESS_MENU_NUM_TEXT_LINES; x++ )
        ZeroMemory( m_apwszTextMessage[x], sizeof( WCHAR ) * ( MAX_PATH + 1 ) );

    SetTitle( MENU_TITLE_MESSAGE );
}

CMessageMenu::~CMessageMenu()
{
}

// Initialize the Menu
HRESULT CMessageMenu::Init( char* menuFileName )
{
    HRESULT hr = CMenuScreen::Init( menuFileName );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMessageMenu::Init():Failed to initialize base class!!" );
        return hr;
    }

    return hr;
}


// Override so that we can render our own menu items
void CMessageMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

	// Draw our Menu Items
	RenderMenuItems( pTexture );

    // Unlock our texture
    pTexture->Unlock();
}


// Render the menu items properly on our menu
void CMessageMenu::RenderMenuItems( CUDTexture* pTexture )
{
    float fXPos = 0.0f;
    float fYPos = 0.0f;

    // Render the text message
    for( unsigned int x = 0; x < gc_uiMESS_MENU_NUM_TEXT_LINES; x++ )
    {
		WCHAR* pwszMessagePtr = m_apwszTextMessage[x];
		DWORD dwFGColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
		DWORD dwBGColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

		// Determine if the user wants to display this line of text in a different color
		if( 0 == wcsncmp( m_apwszTextMessage[x], L"/c", 2 ) )
		{
			pwszMessagePtr += 2;	// Skip the initial "/c"

			// Read the DWORD FG color out of the line
			WCHAR* pwszStopString = NULL;
			dwFGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwFGColor )
                XDBGWRN( APP_TITLE_NAME_A, "CMessageMenu::RenderMenuItems():Possible error in conversion of the FG color (DWORD)" );

			// Skip over the FG color and the space
			pwszMessagePtr = pwszStopString + 1;

			// Read the DWORD BG color out of the line
			dwBGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwBGColor )
                XDBGWRN( APP_TITLE_NAME_A, "CMessageMenu::RenderMenuItems():Possible error in conversion of the BG color (DWORD)" );

			// Skip over the BG color and the space
			pwszMessagePtr = pwszStopString + 1;
		}

		fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( pwszMessagePtr ) / 2 );
        fYPos = gc_fMESSAGE_TEXT_YPOS + ( x * ( m_uiFontHeightOfItem + ITEM_VERT_SPACING ) );

        pTexture->DrawText( fXPos, fYPos, dwFGColor, dwBGColor, L"%ls", pwszMessagePtr );
    }

    // Render the OK Button
    int iTextWidth = GetStringPixelWidth( L"Ok" ) / 2;
    fXPos = MENUBOX_TEXTAREA_X_CENTER - iTextWidth;
    fYPos = gc_fOK_BUTTON_YPOS;

    // Draw the box and highlight
    pTexture->DrawBox( fXPos - gc_fOK_BUTTON_BORDER,
                       fYPos - gc_fOK_BUTTON_BORDER,
                       fXPos + ( iTextWidth * 2 ) + gc_fOK_BUTTON_BORDER,
                       fYPos + m_uiFontHeightOfItem + gc_fOK_BUTTON_BORDER,
                       ITEM_SELECTOR_COLOR );

    pTexture->DrawOutline( fXPos - gc_fOK_BUTTON_BORDER,
                           fYPos - gc_fOK_BUTTON_BORDER,
                           fXPos + ( iTextWidth * 2 ) + gc_fOK_BUTTON_BORDER,
                           fYPos + m_uiFontHeightOfItem + gc_fOK_BUTTON_BORDER,
                           2,
                           SCREEN_DEFAULT_TEXT_FG_COLOR );

    // Draw the text on the button
    pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Ok" );

}


// Handles input (of the BUTTONS) for the current menu
void CMessageMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
    case BUTTON_B:
        {
            if( GetParent() )   // Go Back one menu
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Used to set the text message that will be displayed to the user
void CMessageMenu::SetText( WCHAR* pwszMessage )
{
    if( NULL == pwszMessage )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMessageMenu::SetText():Invalid argument(s) passed in!!" );
        return;
    }

    // Clear out any current text
    ZeroMemory( m_apwszTextMessage, sizeof( m_apwszTextMessage ) );

    for( unsigned int x = 0; x < gc_uiMESS_MENU_NUM_TEXT_LINES; x++ )
    {
        unsigned int uiCount = 0;
        while( ( *pwszMessage != L'\n' ) && ( *pwszMessage != L'\0' ) )
        {
            m_apwszTextMessage[x][uiCount] = *pwszMessage;
            uiCount++;
            pwszMessage++;

            // Exit when we find the end of the current string
            if( uiCount == MAX_PATH + 1 )
                break;
        }
        m_apwszTextMessage[x][uiCount] = L'\0';

        // Exit early if we are at the end of the message
        if( *pwszMessage == L'\0' )
            break;

        uiCount++;
        pwszMessage++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\messagemenu.h ===
/*****************************************************
*** messagemenu.h
***
*** Header file for our Message Menu class.
*** This menu will present a message to the user, and
*** simply allow them to navigate back from where they
*** came.
***
*** by James N. Helm
*** December 11th, 2001
***
*****************************************************/

#ifndef _MESSAGEMENU_H_
#define _MESSAGEMENU_H_

#include "menuscreen.h"

const float gc_fMESSAGE_TEXT_YPOS =                 24.0f;
const float gc_fOK_BUTTON_YPOS =                    160.0f;
const float gc_fOK_BUTTON_BORDER =                  10.0f;

const unsigned int gc_uiMESS_MENU_NUM_TEXT_LINES =  5;

class CMessageMenu : public CMenuScreen
{
public:
    // Constructors and Destructor
    CMessageMenu( CXItem* pParent );
    ~CMessageMenu();

    // Public Methods
    HRESULT Init( char* menuFileName );             // Initialize the Menu
    void Action( CUDTexture* pTexture );            // Override so that we can render our own menu items
    void HandleInput( enum BUTTONS buttonPressed,   // Handles input (of the BUTTONS) for the current menu
                      BOOL bFirstPress );
    void SetText( WCHAR* pwszMessage );             // Used to set the text message that will be displayed to the user
protected:
    void RenderMenuItems( CUDTexture* pTexture );   // Render the menu items properly on our menu

private:
    WCHAR m_apwszTextMessage[gc_uiMESS_MENU_NUM_TEXT_LINES][MAX_PATH+1];	// Used to hold the text message
};

#endif // _MESSAGEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\menuscreen.h ===
/*****************************************************
*** menuscreen.h
***
*** Header file for our XShell Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 1st , 2000
***
*****************************************************/

#ifndef _MENUSCREEN_H_
#define _MENUSCREEN_H_

#include "screenitems.h"

class CMenuScreen : public CXItem
{
public:
    // Constructors and Destructors
    CMenuScreen( CXItem* pParent );
    virtual ~CMenuScreen();

    // Public Methods
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    virtual HRESULT      Init( char* menuFileName );                                    // Initialize the Menu
    virtual void         Enter();                                                       // This should be called whenever the menu is entered or activated
    virtual unsigned int GetNumItems() { return m_uiNumItems; };                        // Return the number of menu items on our current screen
    virtual int          GetSelectedItem() const { return m_nSelectedItem; };           // Get the indext of the currently selected item on the screen
    virtual unsigned int GetFontHeightOfItem() const { return m_uiFontHeightOfItem; };  // The font height of a screen item
    virtual HRESULT      SetSelectedItem( int itemNumber );                             // Set the currently selected item on the screen
    virtual void         UpdateTexture() { m_bUpdateTexture = TRUE; };                  // Call this when the texture should be updated
                                                                                        // TODO: Replace everybody's update with this function call

protected:
    CLinkedList< CScreenItem* >       m_ScreenItems;        // List of pointers to screen items that will be rendered

    WCHAR*            m_pwszMenuTitle;                      // Title of the current menu
    int               m_nSelectedItem;                      // The currently selected item in the list
    unsigned int      m_uiFontHeightOfItem;                 // The font height of an item
    unsigned int      m_uiNumItems;                         // The number of items on the menu
    DWORD             m_keyPressDelayTimer;                 // Used to temper the speed of holding down the d-pad
    DWORD             m_keyPressDelayInterval;              // The current interval to delay before processing a keypress
    int               m_nJoystickDeadZone;                  // The dead zone for the joysticks

    // Methods
    virtual void    Leave( CXItem* pItem );                     // Should be called whenever a user deactivates this item
    virtual BOOL HandleInputDelay( BOOL bFirstPress );          // Handle the default delay before for Input - TRUE if button should be processed
    virtual HRESULT ImportScreenItems( char* menuFileName );    // Add item info to the current screen
    virtual HRESULT AddTextItemFromFile( FILE* menuFile );      // Add a Text Item to our Screen from a file
    virtual HRESULT AddPanelItemFromFile( FILE* menuFile );     // Add a Panel Item to our Screen from a file
    virtual HRESULT AddHeaderItemFromFile( FILE* menuFile );    // Add a Header Item to our Screen from a file
    virtual HRESULT AddLineItemFromFile( FILE* menuFile );      // Add a Line Item to our Screen from a file
    virtual HRESULT AddOutlineItemFromFile( FILE* menuFile );   // Add a Outline Item to our Screen from a file
    virtual HRESULT AddBitmapItemFromFile( FILE* menuFile );    // Add a Bitmap Item to our Screen from a file
};

class Key
{
public:
	int xorigin, yorigin;		// x,y coordinate of the key's upper left pixel
	int width, height;			// width and height of the key
	DWORD selectColor;			// color to hilight the key with upon selection
	WCHAR* resultChar;			// value attached to the key
	BOOL render;				// should the key be rendered?

	// Constructors and Destructors
	Key();
	~Key();

	void define(int x, int y, int w, int h, DWORD color);
	void defineText(WCHAR* result);
	void setRender(BOOL value);
	BOOL getRender(void);
};

#endif // _MENUSCREEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\menuscreen.cpp ===
/*****************************************************
*** menuscreen.cpp
***
*** CPP file for our XShell Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
*** 
*** by James N. Helm
*** December 1st, 2000
*** 
*****************************************************/

#include "stdafx.h"
#include "menuscreen.h"

extern CXItem*          g_pCurrentScreen;       // Pointer to the current menu object
extern BOOL             g_bUpdateTitleTexture;  // Update the Title Texture
extern CSoundCollection g_Sounds;               // Used to generate all sounds for the XShell

// Constructor
CMenuScreen::CMenuScreen( CXItem* pParent )
: CXItem( pParent ),
m_nSelectedItem( 0 ),
m_uiFontHeightOfItem( 0 ),
m_uiNumItems( 0 ),
m_nJoystickDeadZone( JOYSTICK_DEAD_ZONE )
{
    m_ScreenItems.SetDeleteDataItem( TRUE );

    m_keyPressDelayTimer = GetTickCount();
}


// Destructor
CMenuScreen::~CMenuScreen()
{
    if( NULL != m_pwszMenuTitle )
    {
        delete[] m_pwszMenuTitle;
        m_pwszMenuTitle = NULL;
    }
}


// Draws a menu on to the screen
void CMenuScreen::Action( CUDTexture* pTexture )
{
    pTexture->Lock();

    // Draw the screen items
    m_ScreenItems.MoveTo( 0 ); // Start at the 1st Item
    for( unsigned int x = 0; x < m_ScreenItems.GetNumItems(); ++x )
    {
        m_ScreenItems.GetCurrentNode()->Render( pTexture );
        m_ScreenItems.MoveNext();
    }

    pTexture->Unlock();
} 


// Add the screen and text of the item that will be drawn on to the screen
// to our object
HRESULT CMenuScreen::ImportScreenItems( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems()" );

    if( !menuFileName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems():menuFileName not set!!" );

        return E_INVALIDARG;
    }

    FILE* menuFile = fopen( menuFileName, "r" );

    if( !menuFile )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems():fopen failed!! - '%s'", menuFileName );

        return E_FAIL;
    }

    HRESULT hr = S_OK;
    WCHAR itemType;
    BOOL bEOF = FALSE;

    while( !bEOF )
    {
        itemType = fgetwc( menuFile );
        if( feof( menuFile ) )
        {
            bEOF = TRUE;
            continue;
        }

        if( L't' == itemType )
        {
            hr = AddTextItemFromFile( menuFile );
        }
        else if( L'p' == itemType )
        {
            hr = AddPanelItemFromFile( menuFile );
        }
        else if( L'l' == itemType )
        {
            hr = AddLineItemFromFile( menuFile );
        }
        else if( L'h' == itemType )
        {
            hr = AddHeaderItemFromFile( menuFile );
        }
        else if( L'o' == itemType )
        {
            hr = AddOutlineItemFromFile( menuFile );
        }
        else if( L'i' == itemType )
        {
            hr = AddBitmapItemFromFile( menuFile );
        }

        // Move to the next line
        while( itemType = fgetwc( menuFile ) )
        {
            if( feof( menuFile ) )
            {
                bEOF = TRUE;
                break;
            }

            if( 10 == itemType )
            {
                break;
            }
        }

        // Check to see if there was a problem, and return if there was
        if( FAILED( hr ) )
        {
            fclose( menuFile );
            return hr;
        }
    }

    fclose( menuFile );

    return S_OK;
}


// Initialize the Menu
HRESULT CMenuScreen::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::Init()" );

    // Get our screen information
    ImportScreenItems( menuFileName );

    // Get the height of the font
    unsigned int decent;
    GetFontSize( &m_uiFontHeightOfItem, &decent );

    return S_OK;
}


// Add a text item to our current screen from a file
HRESULT CMenuScreen::AddTextItemFromFile( FILE* menuFile )
{
    CTextItem* pTextItem = new CTextItem;
    if( !pTextItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddTextItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fXPos, fYPos;
    DWORD dwFGColor, dwBGColor;
    WCHAR pwszText[SCREEN_ITEM_TEXT_LENGTH];
    
    ZeroMemory( pwszText, sizeof( WCHAR ) * SCREEN_ITEM_TEXT_LENGTH );
    
    fscanf( menuFile,   "%f", &fXPos );
    fscanf( menuFile,   "%f", &fYPos );
    fscanf( menuFile,   "%X", &dwFGColor );
    fscanf( menuFile,   "%X", &dwBGColor );
    fwscanf( menuFile, L"%s", pwszText );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddTextItemFromFile():\n  fXPos: %f\n  fYPos: %f\n  dwFGColor: %X\n  dwBGColor: %X\n  pwszText: %S", fXPos, fYPos, dwFGColor, dwBGColor, pwszText );
    
    // Convert any "_" characters in to spaces
    WCHAR* pChar;
    while( pChar = wcsstr( pwszText, L"_" ) )
    {
        *pChar = L' ';
    }

    // Update the item with the information that we pulled from the file
    pTextItem->UpdateItem( pwszText, fXPos, fYPos, dwFGColor, dwBGColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pTextItem );
    
    return S_OK;
}


// Add a panel item to our current screen
HRESULT CMenuScreen::AddPanelItemFromFile( FILE* menuFile )
{
    CPanelItem* pPanelItem = new CPanelItem;
    if( !pPanelItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddPanelItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fX1Pos, fY1Pos, fX2Pos, fY2Pos;
    DWORD dwColor;

    fscanf( menuFile,   "%f", &fX1Pos );
    fscanf( menuFile,   "%f", &fY1Pos );
    fscanf( menuFile,   "%f", &fX2Pos );
    fscanf( menuFile,   "%f", &fY2Pos );
    fscanf( menuFile,   "%x", &dwColor );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddPanelItemFromFile():\n  fX1Pos: %f\n  fY1Pos: %f\n  fX2Pos: %f\n  Y2Pos: %f\n  dwColor: %X", fX1Pos, fY1Pos, fX2Pos, fY2Pos, dwColor );

    // Update the item with the information that we pulled from the file
    pPanelItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pPanelItem );

    return S_OK;
}


// Add a line to our current screen
HRESULT CMenuScreen::AddLineItemFromFile( FILE* menuFile )
{
    CLineItem* pLineItem = new CLineItem;
    if( !pLineItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddLineItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth;
    DWORD dwColor;

    fscanf( menuFile,   "%f", &fX1Pos );
    fscanf( menuFile,   "%f", &fY1Pos );
    fscanf( menuFile,   "%f", &fX2Pos );
    fscanf( menuFile,   "%f", &fY2Pos );
    fscanf( menuFile,   "%f", &fWidth );
    fscanf( menuFile,   "%x", &dwColor );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddLineItemFromFile():\n  fX1Pos: %f\n  fY1Pos: %f\n  fX2Pos: %f\n  fY2Pos: %f\n  fWidth: %f\n  dwColor: %X", fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth, dwColor );

    // Update the item with the information that we pulled from the file
    pLineItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pLineItem );

    return S_OK;
}


// Add a line to our current screen
HRESULT CMenuScreen::AddOutlineItemFromFile( FILE* menuFile )
{
    COutlineItem* pOutlineItem = new COutlineItem;
    if( !pOutlineItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddOutlineItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth;
    DWORD dwColor;

    fscanf( menuFile,   "%f", &fX1Pos );
    fscanf( menuFile,   "%f", &fY1Pos );
    fscanf( menuFile,   "%f", &fX2Pos );
    fscanf( menuFile,   "%f", &fY2Pos );
    fscanf( menuFile,   "%f", &fWidth );
    fscanf( menuFile,   "%x", &dwColor );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddOutlineItemFromFile():\n  fX1Pos: %f\n  fY1Pos: %f\n  fX2Pos: %f\n  fY2Pos: %f\n  fWidth: %f\n  dwColor: %X", fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth, dwColor );

    // Update the item with the information that we pulled from the file
    pOutlineItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pOutlineItem );

    return S_OK;
}


// Add a Bitmap Item to our Screen from a file
HRESULT CMenuScreen::AddBitmapItemFromFile( FILE* menuFile )
{
    CBitmapItem* pBitmapItem = new CBitmapItem;
    if( !pBitmapItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddBitmapItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    int x, y;
    char filename[MAX_PATH];
    char imagename[MAX_PATH];
    ZeroMemory( filename, MAX_PATH );
    ZeroMemory( imagename, MAX_PATH );

    fscanf( menuFile,   "%d", &x );
    fscanf( menuFile,   "%d", &y );
    fscanf( menuFile,   "%s", imagename );

    _snprintf( filename, MAX_PATH, "%s\\%s", FILE_DATA_IMAGE_DIRECTORY_A, imagename );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddBitmapItemFromFile():\n  XPos: %d\n  YPos: %d\n  Bitmap: %s", x, y, filename );

    // Update the item with the information that we pulled from the file
    pBitmapItem->UpdateItem( filename, x, y );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pBitmapItem );

    return S_OK;

}

// Add a panel item to our current screen
HRESULT CMenuScreen::AddHeaderItemFromFile( FILE* menuFile )
{
    CTextItem* pHeaderItem = new CTextItem;
    if( !pHeaderItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddHeaderItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fXPos, fYPos;
    DWORD dwFGColor, dwBGColor;
    WCHAR pwszText[SCREEN_ITEM_TEXT_LENGTH];
    
    ZeroMemory( pwszText, sizeof( WCHAR ) * SCREEN_ITEM_TEXT_LENGTH );
    
    fscanf( menuFile,   "%f", &fXPos );
    fscanf( menuFile,   "%f", &fYPos );
    fscanf( menuFile,   "%X", &dwFGColor );
    fscanf( menuFile,   "%X", &dwBGColor );
    fwscanf( menuFile, L"%s", pwszText );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddHeaderItemFromFile():\n  fXPos: %f\n  fYPos: %f\n  dwFGColor: %X\n  dwBGColor: %X\n  pwszText: %S", fXPos, fYPos, dwFGColor, dwBGColor, pwszText );
    
    // Convert any "_" characters in to spaces
    WCHAR* pChar;
    while( pChar = wcsstr( pwszText, L"_" ) )
    {
        *pChar = L' ';
    }

    // Update the item with the information that we pulled from the file
    pHeaderItem->UpdateItem( pwszText, fXPos, fYPos, dwFGColor, dwBGColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pHeaderItem );
    
    return S_OK;
}


// Handles input (of the CONTROLS) for the current menu
void CMenuScreen::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( (unsigned int)GetSelectedItem() < ( GetNumItems() - 1 ) )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CMenuScreen::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    }
}


// Handle any requests for the joystick (thumb-pad)
void CMenuScreen::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Yxc
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Sets the currently selected item on our screen
HRESULT CMenuScreen::SetSelectedItem( int itemNumber )
{
    if( ( itemNumber < 0 ) || ( (unsigned int)itemNumber > GetNumItems() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::SetSelectedItem():Tried to select item out of range! - '%d', MAX - '%d'", itemNumber, GetNumItems() - 1 );

        return E_INVALIDARG;
    }

    m_nSelectedItem = itemNumber;

    return S_OK;
}


// Should be called whenever a user enters or activates this menu
void CMenuScreen::Enter()
{
    // Also signal the texture to be updated when a user enters a menu
    m_bUpdateTexture = TRUE;
    g_bUpdateTitleTexture = TRUE;   // Update the Title Texture
}


// Should be called whenever a user leaves the menu
void CMenuScreen::Leave( CXItem* pItem )
{
    g_pCurrentScreen = pItem;
}

// Handle the default delay before for Input
BOOL CMenuScreen::HandleInputDelay( BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return FALSE;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    return TRUE;
}

// Key Class by Victor Blanco
Key::Key()
{
	xorigin = 0;
	yorigin = 0;
	width = 0;
	height = 0;		
	selectColor = 0x00000000;
	render = TRUE;
    resultChar = NULL;
}

Key::~Key()
{
    if( resultChar )
    {
        delete[] resultChar;
        resultChar = NULL;
    }
}

void Key::define(int x, int y, int w, int h, DWORD color)
{
	xorigin = x;
	yorigin = y;
	width = w;
	height = h;		
	selectColor = color;	
}

void Key::defineText(WCHAR* result)
{
	int length = wcslen(result);
	resultChar = new WCHAR[length + 1];
	wcscpy(resultChar, result);
}

void Key::setRender(BOOL value) {
	render = value;
}

BOOL Key::getRender(void) {
	return render;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\MUformat.h ===
/*****************************************************
*** muformat.h
***
*** Header file for our XShell MU Format class.
*** This screen will format a selected Memory Unit.
***
*** by James N. Helm
*** January 11th, 2001
***
*****************************************************/

#ifndef _MUFORMAT_H_
#define _MUFORMAT_H_

#include "keypadmenu.h"
#include "muformatthread.h"
#include "memoryunit.h"

#define MUFORMAT_NUM_ROWS    2
#define MUFORMAT_NUM_COLS    1

class CMUFormat : public CKeypadMenu
{
public:
    CMUFormat( CXItem* pParent );
    ~CMUFormat();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Should be called when this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT SetMemoryUnit( CMemoryUnit* pMemoryUnit );  // Set the address of the Memory Unit to be used

private:
    CMemoryUnit*    m_pMemoryUnit;              // Active Memory Unit

    BOOL            m_bFormatMU;                // Used to signal when the MU should be formatted
    BOOL            m_bFormatBegun;             // Used to determine if we have kicked off a format
    BOOL            m_bSleepAndExit;            // Used to signal the menu it's time to pause, and leave
    CMUFormatThread m_MUFormatThread;           // Thread object used to format an MU
    BOOL            m_bDisableInput;            // Used to disable user input
    DWORD           m_dwTimeSlept;              // Used to determine how long we've paused

    // Private Methods
    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pScreen );
    void Leave( CXItem* pItem );        // Will be called whenever the user leaves this menu
};

#endif // _MUFORMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\muformatthread.cpp ===
/*****************************************************
*** muformatthread.cpp
***
*** CPP file for our MU Format Thread class.
*** This class will format an MU in a background
*** thread, and report the result to the caller
***
*** by James N. Helm
*** February 9th, 2001
***
*****************************************************/
#include "stdafx.h"
#include "muformatthread.h"

// Constructor
CMUFormatThread::CMUFormatThread() :
m_bFormatComplete( TRUE ),
m_bFormatSuccessful( FALSE ),
m_pMemoryUnit( NULL )
{
}

// Destructor
CMUFormatThread::~CMUFormatThread()
{
}

/*****************************************************************************

Routine Description:

    ThreadFunct

    This function will format an MU and store the result of the format

Arguments:

    none

Return Value:


Notes:

    See CWorkerThread.h & CWorkerThread.cpp for more information on this
    member function.

*****************************************************************************/
DWORD CMUFormatThread::ThreadFunct(void)
{
    // Format the MU

    BOOL bFormatSuccessful;
    if( FAILED( m_pMemoryUnit->Format( TRUE ) ) )
    {
        bFormatSuccessful = FALSE;
    }
    else
    {
        bFormatSuccessful = TRUE;
    }
    
    Lock();

    m_bFormatSuccessful = bFormatSuccessful;
    m_bFormatComplete = TRUE;
    
    Unlock();

    XDBGTRC( APP_TITLE_NAME_A, "CMUFormatThread::ThreadFunct():Exiting..." );
    
    return 0;
}


// Informs the caller if the format in progress is complete
BOOL CMUFormatThread::IsFormatComplete()
{
    BOOL bReturn;

    Lock(); // Protect our memory
    
    bReturn = m_bFormatComplete;

    Unlock();

    return bReturn;
}


// Informs the caller if the format was successful or not
BOOL CMUFormatThread::IsFormatSuccessful()
{
    BOOL bReturn;

    Lock(); // Protect our memory
    
    bReturn = m_bFormatSuccessful;

    Unlock();

    return bReturn;
}


// Set the Port and the Slot you wish to format, and begin the format
void CMUFormatThread::BeginFormat( CMemoryUnit* pMemoryUnit )
{
    // Verify we have a valid pointer
    if( !pMemoryUnit )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMUFormatThread::BeginFormat():Invalid pointer passed in!!" );

        return;
    }

    Lock(); // Protect our memory

    // Make sure we don't start the thread twice
    if( TRUE == m_bFormatComplete )
    {
        m_pMemoryUnit = pMemoryUnit;

        m_bFormatSuccessful = FALSE;
        m_bFormatComplete = FALSE;

        // Begin the Format
        Run();
    }

    Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\MUformat.cpp ===
/*****************************************************
*** muformat.cpp
***
*** CPP file for our XShell MU Format class.
*** This screen will format a selected Memory Unit.
***
*** by James N. Helm
*** January 11th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "muformat.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell
extern BOOL             g_bMUsChanged;      // Tracks whether MU's have been inserted or removed
extern DWORD            g_dwInsertedMUs;    // Tracks which MUs are inserted or removed

// Constructors
CMUFormat::CMUFormat( CXItem* pParent )
: CKeypadMenu( pParent ),
m_pMemoryUnit( NULL ),
m_bFormatMU( FALSE ),
m_bFormatBegun( FALSE ),
m_bSleepAndExit( FALSE ),
m_bDisableInput( FALSE ),
m_dwTimeSlept( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMUFormat::CMUFormat(ex)" );

    m_uiNumItems = NUM_XBOX_MU_SLOTS;
    SetSelectedItem( 0 );

    GenerateKeypad();
	m_xKeypos = 0;
	m_yKeypos = 0;

    SetTitle( MENU_TITLE_MUFORMAT );
}


// Destructor
CMUFormat::~CMUFormat()
{
}

// Draws a menu on to the screen
void CMUFormat::Action( CUDTexture* pTexture )
{
    //
    // Ensure the MU we are dealing with is still plugged in
    //

    // Determine the state of the MU's and Controllers
    DWORD dwDeviceInsertions;
    DWORD dwDeviceRemovals;

    if( g_bMUsChanged )
    {
        // If the MU is no longer plugged in, immediately return to the previous screen
        if( !( g_dwInsertedMUs & g_dwMUBitMask[GetSelectedItem()] ) && ( !m_bFormatMU ) )
        {
            if( GetParent() )
            {
                Leave( GetParent() );
            }
        }
    }


    // Check to see if the MU is formatting, if so, check the status, and
    // determine if the texture should be updated
    if( m_bFormatMU )
    {
        // Ensure the user cannot leave the menu -- Disable button input
        m_bDisableInput = TRUE;

        if( m_bFormatBegun )
        {
            if( m_MUFormatThread.IsFormatComplete() )
            {
                m_bUpdateTexture = TRUE;

                // Signal the menu to pause, and then return to the previous menu
                if( FALSE == m_bSleepAndExit )
                {
                    // Setup our and sleep timer
                    m_dwTimeSlept = GetTickCount();
                    
                    m_bSleepAndExit = TRUE;
                }
            }
        }
        else
        {
            m_bUpdateTexture = TRUE;
            m_bFormatBegun = TRUE;

            // Begin the format
            m_MUFormatThread.BeginFormat( m_pMemoryUnit );
        }

        // Check to see if it's time to exit this menu
        if( m_bSleepAndExit )
        {
            // Make sure our final Texture message made it to the user
            // BUGBUG: This feels like a hack
            if( ( GetTickCount() - m_dwTimeSlept ) > MUFORMATDLG_MSG_PAUSE )
            {
                Leave( GetParent() );
            }
        }
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CKeypadMenu::Action( pTexture );

    // Insert the MU and Port the user is dealing with on to the texture
    WCHAR pwszMUName[MAX_MUNAME];
    ZeroMemory( pwszMUName, sizeof( WCHAR ) * MAX_MUNAME );

    m_pMemoryUnit->GetName( pwszMUName, MAX_MUNAME );
    if( L'\0' == pwszMUName[0] )
    //
    // The MU doesn't have a name, so don't use it
    //
    {
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszMUPortNames[GetSelectedItem()] ) / 2.0f ), MUFORMATDLG_DELETE_MSG_YPOS + m_uiFontHeightOfItem + ITEM_SELECTOR_BORDER_SPACE, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszMUPortNames[GetSelectedItem()] );
    }
    else
    //
    // The MU has a name, so use it
    //
    {
        WCHAR pwszFullMUName[255];
        ZeroMemory( pwszFullMUName, sizeof( WCHAR ) * 255 );

        wsprintf( pwszFullMUName, L"%s (%s)", g_pwszMUPortNames[GetSelectedItem()], pwszMUName );
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( pwszFullMUName ) / 2.0f ), MUFORMATDLG_DELETE_MSG_YPOS + m_uiFontHeightOfItem + ITEM_SELECTOR_BORDER_SPACE, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", pwszFullMUName );
    }

    // Perform the format if the user has selected it
    if( m_bFormatMU )
    {
        WCHAR wpszMUActionText[30];                             // Used to display action text on the screen (i.e., formatting, etc)
        ZeroMemory( wpszMUActionText, 30 * sizeof( WCHAR ) );

        // Update our texture with the info that we are formatting
        _snwprintf( wpszMUActionText, 29, MUFORMATDLG_FORMATTING_MSG );

        pTexture->DrawBox( MENUBOX_MAINAREA_X1, MUFORMATDLG_DELETE_MSG_YPOS, MENUBOX_MAINAREA_X2, MUFORMATDLG_DELETE_MSG_YPOS + m_uiFontHeightOfItem, SCREEN_DEFAULT_TEXT_BG_COLOR );
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER  - ( GetStringPixelWidth( wpszMUActionText ) / 2.0f ), MUFORMATDLG_DELETE_MSG_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", wpszMUActionText );

        // If the formatting has begun, check it's status, and update the
        // texture if necessary
        if( m_bFormatBegun )
        {
            if( m_MUFormatThread.IsFormatComplete() )
            {
                // Print the result of the format on to our texture
                if( m_MUFormatThread.IsFormatSuccessful() )
                {
                    _snwprintf( wpszMUActionText, 29, MUFORMATDLG_SUCCESS_MSG );
                }
                else
                {
                    _snwprintf( wpszMUActionText, 29, MUFORMATDLG_FAIL_MSG );
                }
                
                pTexture->DrawBox( MENUBOX_MAINAREA_X1, MUFORMATDLG_DELETE_MSG_YPOS, MENUBOX_MAINAREA_X2, MUFORMATDLG_DELETE_MSG_YPOS + m_uiFontHeightOfItem, SCREEN_DEFAULT_TEXT_BG_COLOR );
                pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER  - ( GetStringPixelWidth( wpszMUActionText ) / 2.0f ), MUFORMATDLG_DELETE_MSG_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", wpszMUActionText );
            }
        }
    }
    else // The user is not formatting an MU, display the warning message
    {
        // Draw our Text Message
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MUFORMATDLG_DELETE_MSG ) / 2.0f ), MUFORMATDLG_DELETE_MSG_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", MUFORMATDLG_DELETE_MSG );
    }

    // Unlock our texture
    pTexture->Unlock();
}


void CMUFormat::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = 1;
	int ygrid  = MUFORMAT_NUM_ROWS;
	int xstart = MUFORMATDLG_BUTTON_X1;
	int ystart = MUFORMATDLG_BUTTON_Y1;
	int width  = 103;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = MUFORMAT_NUM_ROWS;
	xstart = 323;
	ystart = MUFORMATDLG_BUTTON_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	
	currentx = xstart;
	currenty = ystart;
	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Set the text of the keys
    m_keyPad[0][0].defineText(L"yes");
    m_keyPad[0][1].defineText(L"no");
}


BOOL CMUFormat::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < MUFORMAT_NUM_COLS; x++)
	{
		for(int y = 0; y < MUFORMAT_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our Texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    dwCharColor = ITEM_SELECTED_TEXT_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, KEYPAD_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// Handle any requests for the joystick (thumb-pad)
void CMUFormat::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    // If the input is disabled, simply return, and do not process any commands
    if( m_bDisableInput )
    {
        return;
    }

    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CMUFormat::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If the input is disabled, simply return, and do not process any commands
    if( m_bDisableInput )
    {
        return;
    }

    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
			if( ( m_yKeypos != 0 ) && ( m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos--;
			}
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
			if( ( m_yKeypos != ( MUFORMAT_NUM_ROWS - 1 ) ) && ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos++;
			}
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CMUFormat::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If the input is disabled, simply return, and do not process any commands
    if( m_bDisableInput )
    {
        return;
    }

    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"yes" ) )      //Yes
			{
                m_bUpdateTexture = TRUE;

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                m_bFormatMU = TRUE;
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"no" ) )  //No
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Sets the local member to point at the proper memory unit
HRESULT CMUFormat::SetMemoryUnit( CMemoryUnit* pMemoryUnit )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMUFormat::SetMemoryUnit()" );

    if( !pMemoryUnit )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMUFormat::SetMemoryUnit():Invalid Argument passed in!!" );

        return E_INVALIDARG;
    }

    m_pMemoryUnit = pMemoryUnit;

    // Set the Selected Item via an index
    SetSelectedItem( m_pMemoryUnit->GetIndex() );

    return S_OK;
}


// This will be called whenever this menu is exited
void CMUFormat::Leave( CXItem* pItem )
{
    // Call our base-class Leave
    CKeypadMenu::Leave( pItem );
}


// This will be called whenever this menu is entered / activated
void CMUFormat::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Ensure our input is enabled when the user arrives
    m_bDisableInput = FALSE;

    // Toggle the Format status
    m_bFormatMU = FALSE;
    m_bFormatBegun = FALSE;

    // Ensure the menu is not marked exit the next time the user visits
    m_bSleepAndExit = FALSE;

    // Default the focus to the yes button
	m_xKeypos = MUFORMAT_NUM_COLS - 1;
	m_yKeypos = 0;

    // Make sure we don't process the first keypress
    m_bDropKeyPress = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\muname.cpp ===
/*****************************************************
*** muname.cpp
***
*** CPP file for our XShell MU Name class.
*** This screen will name a selected Memory Unit.
***
*** by James N. Helm
*** February 15th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "muname.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell
extern BOOL             g_bMUsChanged;      // Tracks whether MU's have been inserted or removed
extern DWORD            g_dwInsertedMUs;    // Tracks which MUs are inserted or removed

// Constructors
CMUName::CMUName( CXItem* pParent )
: CKeyboardMenu( pParent ),
m_pMemoryUnit( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMUName::CMUName(ex)" );

    m_uiNumItems = NUM_XBOX_MU_SLOTS;
    SetSelectedItem( 0 );

    ZeroMemory( m_pwszMUName, sizeof( WCHAR ) * MAX_MUNAME );

    SetTitle( MENU_TITLE_MUNAME );
}


// Destructor
CMUName::~CMUName()
{
}

// Draws a menu on to the screen
void CMUName::Action( CUDTexture* pTexture )
{
    //
    // Ensure the MU we are dealing with is still plugged in
    //

    // Determine the state of the MU's and Controllers
    DWORD dwDeviceInsertions;
    DWORD dwDeviceRemovals;

    if( g_bMUsChanged )
    {
        // If the MU is no longer plugged in, immediately return to the previous screen
        if( !( g_dwInsertedMUs & g_dwMUBitMask[GetSelectedItem()] ) )
        {
            if( GetParent() )
            {
                Leave( GetParent() );
            }
        }
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CKeyboardMenu::Action( pTexture );

    // Insert the MU and Port the user is dealing with on to the texture
    pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszMUPortNames[GetSelectedItem()] ) / 2.0f ), MUNAMEDLG_MU_TEXT_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszMUPortNames[GetSelectedItem()] );

	// Draw our MU Name field
	pTexture->DrawText( MUNAMEDLG_VALUE_XPOS, MUNAMEDLG_HEADER_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_pwszMUName );

    // Unlock our texture
    pTexture->Unlock();
}


// Handles input (of the BUTTONS) for the current menu
void CMUName::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
        m_bDropKeyPress = FALSE;

    if ( m_bDropKeyPress )
        return;

    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )            //backspace
			{
				int len = wcslen( m_pwszMUName );
				
				if( len > 0 )
				{
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

					len = len - 1;
					m_pwszMUName[len] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok" ) )      //ok
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Write the name to the MU
                if( FAILED( m_pMemoryUnit->Name( m_pwszMUName ) ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CMUName::HandleInput():Failed to write the name to the MU!!" );
                }

                if( GetParent() )   // Go Back one menu
                    Leave( GetParent() );
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel" ) )  //cancel
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( GetParent() )   // Go Back one menu
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an MU name
                if( wcslen( m_pwszMUName ) < MAX_MUNAME - 1 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

				    wcscat( m_pwszMUName, m_keyPad[m_xKeypos][m_yKeypos].resultChar );
                }
			}
            break;
        }
    case BUTTON_B:
        {
            if( GetParent() )   // Go Back one menu
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Sets the local member to point at the proper memory unit
HRESULT CMUName::SetMemoryUnit( CMemoryUnit* pMemoryUnit )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMUName::SetMemoryUnit()" );

    if( !pMemoryUnit )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMUName::SetMemoryUnit():Invalid Argument passed in!!" );

        return E_INVALIDARG;
    }

    m_pMemoryUnit = pMemoryUnit;

    // Set the Selected Item via an index
    SetSelectedItem( m_pMemoryUnit->GetIndex() );

    return S_OK;
}


// This will be called whenever this menu is entered / activated
void CMUName::Enter()
{
    // Call the base-class enter
    CKeyboardMenu::Enter();

    // Make sure we don't process the first keypress and reset our item to 0
    m_bDropKeyPress = TRUE;

    // Setup the MU Name -- Remove the previous name, and load any existing name off of the disk
    ZeroMemory( m_pwszMUName, sizeof( WCHAR ) * MAX_MUNAME );  // Destroy any previous name

    m_pMemoryUnit->GetName( m_pwszMUName, MAX_MUNAME );
}


// Should be called whenever a user leaves the menu
void CMUName::Leave( CXItem* pItem )
{
    CKeyboardMenu::Leave( pItem );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\muname.h ===
/*****************************************************
*** muname.h
***
*** Header file for our XShell MU Name class.
*** This screen will name a selected Memory Unit.
***
*** by James N. Helm
*** February 15th, 2001
***
*****************************************************/

#ifndef _MUNAME_H_
#define _MUNAME_H_

#include "keyboardmenu.h"   // Base Menu Type
#include "memoryunit.h"

class CMUName : public CKeyboardMenu
{
public:
    CMUName( CXItem* pParent );
    ~CMUName();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Should be called when this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );

    // Public Methods
    HRESULT SetMemoryUnit( CMemoryUnit* pMemoryUnit );  // Set the address of the Memory Unit to be used

private:
    CMemoryUnit* m_pMemoryUnit;                     // Active Memory Unit
    WCHAR m_pwszMUName[MAX_MUNAME];                 // The name of the current MU

    // Private Methods
    void Leave( CXItem* pItem );                                        // This should be called whenever a user leaves this menu
};

#endif // _MUNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\muformatthread.h ===
/*****************************************************
*** muformatthread.h
***
*** Header file for our MU Format Thread class.
*** This class will format an MU in a background
*** thread, and report the result to the caller
***
*** by James N. Helm
*** February 9th, 2001
***
*****************************************************/

#ifndef _MUFORMATTHREAD_H_
#define _MUFORMATTHREAD_H_

#include "cworkerthread.h"
#include "memoryunit.h"

class CMUFormatThread : public CWorkerThread
{
public:
    // Constructors and Destructor
    CMUFormatThread();
    ~CMUFormatThread();

    // Properties

    // Methods
    BOOL IsFormatComplete();                                                                    // Informs the caller if the format in progress is complete
    BOOL IsFormatSuccessful();                                                                  // Informs the caller if the format was successful or not
    void BeginFormat( CMemoryUnit* pMemoryUnit );                                              // Set the Port and the Slot you wish to format

private:

    // Properties
    BOOL m_bFormatComplete;             // TRUE if there is no format in progress, otherwise FALSE
    BOOL m_bFormatSuccessful;           // TRUE if the format was successful, otherwise FALSE
    CMemoryUnit* m_pMemoryUnit;         // Active Memory Unit

    // Methods
    /*****************************************************************************
    NOTE: in the implementation of this function, the user must check 
           the bExit flag and exit gracefully if set:
    while(1)
        {
        if(GetExitFlag()) break;
        }
    *****************************************************************************/
    DWORD ThreadFunct(void);
};

#endif // _MUFORMATTHREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\MUunformat.cpp ===
/*****************************************************
*** muunformat.h
***
*** Header file for our XShell MU UnFormat class.
*** This screen will unformat a selected Memory Unit.
***
*** by James N. Helm
*** June 22nd, 2001
***
*****************************************************/

#include "stdafx.h"
#include "muunformat.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell
extern BOOL             g_bMUsChanged;      // Tracks whether MU's have been inserted or removed
extern DWORD            g_dwInsertedMUs;    // Tracks which MUs are inserted or removed

// Constructors
CMUUnFormat::CMUUnFormat( CXItem* pParent )
: CKeypadMenu( pParent ),
m_pMemoryUnit( NULL ),
m_bUnFormatMU( FALSE ),
m_bUnFormatBegun( FALSE ),
m_bSleepAndExit( FALSE ),
m_bDisableInput( FALSE ),
m_dwTimeSlept( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMUUnFormat::CMUUnFormat(ex)" );

    m_uiNumItems = NUM_XBOX_MU_SLOTS;
    SetSelectedItem( 0 );

    GenerateKeypad();
	m_xKeypos = 0;
	m_yKeypos = 0;

    SetTitle( MENU_TITLE_MUUNFORMAT );
}


// Destructor
CMUUnFormat::~CMUUnFormat()
{
}

// Draws a menu on to the screen
void CMUUnFormat::Action( CUDTexture* pTexture )
{
    //
    // Ensure the MU we are dealing with is still plugged in
    //

    // Determine the state of the MU's and Controllers
    if( g_bMUsChanged )
    {
        // If the MU is no longer plugged in, immediately return to the previous screen
        if( !( g_dwInsertedMUs & g_dwMUBitMask[GetSelectedItem()] ) && ( !m_bUnFormatMU ) )
        {
            if( GetParent() )
            {
                Leave( GetParent() );
            }
        }
    }


    // Check to see if the MU is formatting, if so, check the status, and
    // determine if the texture should be updated
    if( m_bUnFormatMU )
    {
        // Ensure the user cannot leave the menu -- Disable button input
        m_bDisableInput = TRUE;

        if( m_bUnFormatBegun )
        {
            if( m_MUUnFormatThread.IsUnFormatComplete() )
            {
                m_bUpdateTexture = TRUE;

                // Signal the menu to pause, and then return to the previous menu
                if( FALSE == m_bSleepAndExit )
                {
                    // Setup our and sleep timer
                    m_dwTimeSlept = GetTickCount();
                    
                    m_bSleepAndExit = TRUE;
                }
            }
        }
        else
        {
            m_bUpdateTexture = TRUE;
            m_bUnFormatBegun = TRUE;

            // Begin the format
            m_MUUnFormatThread.BeginUnFormat( m_pMemoryUnit );
        }

        // Check to see if it's time to exit this menu
        if( m_bSleepAndExit )
        {
            // Make sure our final Texture message made it to the user
            // BUGBUG: This feels like a hack
            if( ( GetTickCount() - m_dwTimeSlept ) > MUUNFORMATDLG_MSG_PAUSE )
            {
                Leave( GetParent() );
            }
        }
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CKeypadMenu::Action( pTexture );

    // Insert the MU and Port the user is dealing with on to the texture
    WCHAR pwszMUName[MAX_MUNAME];
    ZeroMemory( pwszMUName, sizeof( WCHAR ) * MAX_MUNAME );

    m_pMemoryUnit->GetName( pwszMUName, MAX_MUNAME );
    if( L'\0' == pwszMUName[0] )
    //
    // The MU doesn't have a name, so don't use it
    //
    {
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszMUPortNames[GetSelectedItem()] ) / 2.0f ), MUUNFORMATDLG_DELETE_MSG_YPOS + m_uiFontHeightOfItem + ITEM_SELECTOR_BORDER_SPACE, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszMUPortNames[GetSelectedItem()] );
    }
    else
    //
    // The MU has a name, so use it
    //
    {
        WCHAR pwszFullMUName[255];
        ZeroMemory( pwszFullMUName, sizeof( WCHAR ) * 255 );

        wsprintf( pwszFullMUName, L"%s (%s)", g_pwszMUPortNames[GetSelectedItem()], pwszMUName );
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( pwszFullMUName ) / 2.0f ), MUUNFORMATDLG_DELETE_MSG_YPOS + m_uiFontHeightOfItem + ITEM_SELECTOR_BORDER_SPACE, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", pwszFullMUName );
    }

    // Perform the format if the user has selected it
    if( m_bUnFormatMU )
    {
        WCHAR wpszMUActionText[30];                             // Used to display action text on the screen (i.e., formatting, etc)
        ZeroMemory( wpszMUActionText, 30 * sizeof( WCHAR ) );

        // Update our texture with the info that we are formatting
        _snwprintf( wpszMUActionText, 29, MUUNFORMATDLG_FORMATTING_MSG );

        pTexture->DrawBox( MENUBOX_MAINAREA_X1, MUUNFORMATDLG_DELETE_MSG_YPOS, MENUBOX_MAINAREA_X2, MUUNFORMATDLG_DELETE_MSG_YPOS + m_uiFontHeightOfItem, SCREEN_DEFAULT_TEXT_BG_COLOR );
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER  - ( GetStringPixelWidth( wpszMUActionText ) / 2.0f ), MUUNFORMATDLG_DELETE_MSG_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", wpszMUActionText );

        // If the formatting has begun, check it's status, and update the
        // texture if necessary
        if( m_bUnFormatBegun )
        {
            if( m_MUUnFormatThread.IsUnFormatComplete() )
            {
                // Print the result of the format on to our texture
                if( m_MUUnFormatThread.IsUnFormatSuccessful() )
                {
                    _snwprintf( wpszMUActionText, 29, MUUNFORMATDLG_SUCCESS_MSG );
                }
                else
                {
                    _snwprintf( wpszMUActionText, 29, MUUNFORMATDLG_FAIL_MSG );
                }
                
                pTexture->DrawBox( MENUBOX_MAINAREA_X1, MUUNFORMATDLG_DELETE_MSG_YPOS, MENUBOX_MAINAREA_X2, MUUNFORMATDLG_DELETE_MSG_YPOS + m_uiFontHeightOfItem, SCREEN_DEFAULT_TEXT_BG_COLOR );
                pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER  - ( GetStringPixelWidth( wpszMUActionText ) / 2.0f ), MUUNFORMATDLG_DELETE_MSG_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", wpszMUActionText );
            }
        }
    }
    else // The user is not formatting an MU, display the warning message
    {
        // Draw our Text Message
        pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MUUNFORMATDLG_DELETE_MSG ) / 2.0f ), MUUNFORMATDLG_DELETE_MSG_YPOS, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", MUUNFORMATDLG_DELETE_MSG );
    }

    // Unlock our texture
    pTexture->Unlock();
}


void CMUUnFormat::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = 1;
	int ygrid  = MUUNFORMAT_NUM_ROWS;
	int xstart = MUUNFORMATDLG_BUTTON_X1;
	int ystart = MUUNFORMATDLG_BUTTON_Y1;
	int width  = 103;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = MUUNFORMAT_NUM_ROWS;
	xstart = 323;
	ystart = MUUNFORMATDLG_BUTTON_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	
	currentx = xstart;
	currenty = ystart;
	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Set the text of the keys
    m_keyPad[0][0].defineText(L"yes");
    m_keyPad[0][1].defineText(L"no");
}


BOOL CMUUnFormat::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < MUUNFORMAT_NUM_COLS; x++)
	{
		for(int y = 0; y < MUUNFORMAT_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our Texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    dwCharColor = ITEM_SELECTED_TEXT_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, KEYPAD_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// Handle any requests for the joystick (thumb-pad)
void CMUUnFormat::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    // If the input is disabled, simply return, and do not process any commands
    if( m_bDisableInput )
    {
        return;
    }

    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CMUUnFormat::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If the input is disabled, simply return, and do not process any commands
    if( m_bDisableInput )
    {
        return;
    }

    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
			if( ( m_yKeypos != 0 ) && ( m_keyPad[m_xKeypos][m_yKeypos - 1].getRender() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos--;
			}
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
			if( ( m_yKeypos != ( MUUNFORMAT_NUM_ROWS - 1 ) ) && ( m_keyPad[m_xKeypos][m_yKeypos + 1].getRender() ) )
			{
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos++;
			}
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CMUUnFormat::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If the input is disabled, simply return, and do not process any commands
    if( m_bDisableInput )
    {
        return;
    }

    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"yes" ) )      //Yes
			{
                m_bUpdateTexture = TRUE;

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                m_bUnFormatMU = TRUE;
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"no" ) )  //No
			{
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Sets the local member to point at the proper memory unit
HRESULT CMUUnFormat::SetMemoryUnit( CMemoryUnit* pMemoryUnit )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMUUnFormat::SetMemoryUnit()" );

    if( !pMemoryUnit )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMUUnFormat::SetMemoryUnit():Invalid Argument passed in!!" );

        return E_INVALIDARG;
    }

    m_pMemoryUnit = pMemoryUnit;

    // Set the Selected Item via an index
    SetSelectedItem( m_pMemoryUnit->GetIndex() );

    return S_OK;
}


// This will be called whenever this menu is exited
void CMUUnFormat::Leave( CXItem* pItem )
{
    // Call our base-class Leave
    CKeypadMenu::Leave( pItem );
}


// This will be called whenever this menu is entered / activated
void CMUUnFormat::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Ensure our input is enabled when the user arrives
    m_bDisableInput = FALSE;

    // Toggle the Format status
    m_bUnFormatMU = FALSE;
    m_bUnFormatBegun = FALSE;

    // Ensure the menu is not marked exit the next time the user visits
    m_bSleepAndExit = FALSE;

    // Default the focus to the yes button
	m_xKeypos = MUUNFORMAT_NUM_COLS - 1;
	m_yKeypos = 0;

    // Make sure we don't process the first keypress
    m_bDropKeyPress = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\muunformatthread.h ===
/*****************************************************
*** muunformatthread.h
***
*** Header file for our MU Format Thread class.
*** This class will format an MU in a background
*** thread, and report the result to the caller
***
*** by James N. Helm
*** February 9th, 2001
***
*****************************************************/

#ifndef _MUUNFORMATTHREAD_H_
#define _MUUNFORMATTHREAD_H_

#include "cworkerthread.h"
#include "memoryunit.h"

class CMUUnFormatThread : public CWorkerThread
{
public:
    // Constructors and Destructor
    CMUUnFormatThread();
    ~CMUUnFormatThread();

    // Properties

    // Methods
    BOOL IsUnFormatComplete();                                                                    // Informs the caller if the format in progress is complete
    BOOL IsUnFormatSuccessful();                                                                  // Informs the caller if the format was successful or not
    void BeginUnFormat( CMemoryUnit* pMemoryUnit );                                              // Set the Port and the Slot you wish to format

private:

    // Properties
    BOOL m_bUnFormatComplete;             // TRUE if there is no format in progress, otherwise FALSE
    BOOL m_bUnFormatSuccessful;           // TRUE if the format was successful, otherwise FALSE
    CMemoryUnit* m_pMemoryUnit;         // Active Memory Unit

    // Methods
    /*****************************************************************************
    NOTE: in the implementation of this function, the user must check 
           the bExit flag and exit gracefully if set:
    while(1)
        {
        if(GetExitFlag()) break;
        }
    *****************************************************************************/
    DWORD ThreadFunct(void);
};

#endif // _MUUNFORMATTHREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\MUunformat.h ===
/*****************************************************
*** muunformat.h
***
*** Header file for our XShell MU UnFormat class.
*** This screen will unformat a selected Memory Unit.
***
*** by James N. Helm
*** June 22nd, 2001
***
*****************************************************/

#ifndef _MUUNFORMAT_H_
#define _MUUNFORMAT_H_

#include "keypadmenu.h"
#include "muunformatthread.h"
#include "memoryunit.h"

#define MUUNFORMAT_NUM_ROWS    2
#define MUUNFORMAT_NUM_COLS    1

class CMUUnFormat : public CKeypadMenu
{
public:
    CMUUnFormat( CXItem* pParent );
    ~CMUUnFormat();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Should be called when this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT SetMemoryUnit( CMemoryUnit* pMemoryUnit );  // Set the address of the Memory Unit to be used

private:
    CMemoryUnit*        m_pMemoryUnit;              // Active Memory Unit

    BOOL                m_bUnFormatMU;              // Used to signal when the MU should be formatted
    BOOL                m_bUnFormatBegun;           // Used to determine if we have kicked off a format
    BOOL                m_bSleepAndExit;            // Used to signal the menu it's time to pause, and leave
    CMUUnFormatThread   m_MUUnFormatThread;         // Thread object used to format an MU
    BOOL                m_bDisableInput;            // Used to disable user input
    DWORD               m_dwTimeSlept;              // Used to determine how long we've paused

    // Private Methods
    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pScreen );
    void Leave( CXItem* pItem );        // Will be called whenever the user leaves this menu
};

#endif // _MUUNFORMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\networkmenu.h ===
/*****************************************************
*** networkmenu.h
***
*** Header file for our XShell Network menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** May 19th, 2001
***
*****************************************************/

#ifndef _NETWORKMENU_H_
#define _NETWORKMENU_H_

/*
enum SettingsValues
{
    ENUM_DISPLAYSETTING = 0,
    ENUM_IPADDRESS,
    ENUM_SUBNETMASK,
    ENUM_GATEWAY,
    ENUM_MACHINENAME,

    ENUM_SETTINGS_MAX
};
*/

#include "menuscreen.h"

// Sub-Menus
#include "ipmenu.h"
#include "dnsmenu.h"
#include "subnetmenu.h"
#include "gatewaymenu.h"
#include "machinenamemenu.h"

class CNetworkMenu : public CMenuScreen
{
public:
    CNetworkMenu( CXItem* pParent );
    ~CNetworkMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );                 // Initialize our font and settings
    CXItem* GetItemPtr( enum XShellMenuIds menuID );    // Returns a pointer to a sub-menu

private:
    CIPMenu          m_IPMenu;              // IP Menu Object to get input from the user when entering an IP Address
    CSubnetMenu      m_SubnetMenu;          // Subnet Menu Object to get input from the user when entering a Subnet Mask
	CDNSMenu	     m_DNSMenu;				// DNS Menu Object to set the Primary and Secondary DNS Addresses on the Xbox
    CGatewayMenu     m_GatewayMenu;         // Gateway Object to get input from the user when entering a Gateway
    CMachineNameMenu m_MachineNameMenu;     // MachineName Object to get input from the user when entering a Machine Name
};

#endif // _NETWORKMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\olusermenu.cpp ===
/*****************************************************
*** olusermenu.cpp
***
*** CPP file for our XShell Online User menu 
*** class.  This menu will enumerate users for a
*** particular memory area and allow the user to
*** select one.
***
*** by James N. Helm
*** February 15th, 2002
***
*****************************************************/

#include "stdafx.h"
#include "olusermenu.h"

extern IDirect3DDevice8*    g_pD3DDevice;           // Pointer to our Direct3D Device Object
extern CSoundCollection     g_Sounds;               // Used to generate all sounds for the XShell
extern BOOL                 g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
extern BOOL                 g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow
extern XFONT*               g_pFont;

// Constructors
COLUserMenu::COLUserMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_uiTopItemIndex( 0 ),
m_bCancelled( FALSE ),
m_paHDUsers( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "COLUserMenu::COLUserMenu(ex)" );

    m_uiNumItems = 0;
    SetSelectedItem( 0 );

    SetTitle( MENU_TITLE_OLUSER );
}


// Destructor
COLUserMenu::~COLUserMenu()
{
}

// Draws a menu on to the screen
void COLUserMenu::Action( CUDTexture* pTexture )
{
    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
        return;
    else
        m_bUpdateTexture = FALSE;

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_OLUSERMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_OLUSERMENU_FONT_HEIGHT;

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    // Draw a box behind the currently highlighted choice
    float X1Pos = MENUBOX_SELECTBAR_X1;
    float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - ITEM_SELECTOR_BORDER_SPACE;
    float X2Pos = MENUBOX_SELECTBAR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
    
    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

    //
    // Draw our Menu Items
    //

    for( unsigned int x = m_uiTopItemIndex; x < ( MENU_OLUSER_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); x++ )
    {
        if( x == GetNumItems() )
        {
            break;
        }

        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

        // Enumerate the user names
        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%hs.%hs", m_paHDUsers[x].name, m_paHDUsers[x].kingdom );
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void COLUserMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void COLUserMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() < (int)m_uiTopItemIndex )
                    {
                        m_uiTopItemIndex = GetSelectedItem();

                        AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() >= (int)( MENU_OLUSER_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ) )
                    {
                        m_uiTopItemIndex += 1;

                        AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void COLUserMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, or input is disabled, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Return to the previous menu
                if( NULL != GetParent() )
                    Leave( GetParent() );
            }

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT COLUserMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "COLUserMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    return hr;
}


// Should be called whenever a user leaves the menu
void COLUserMenu::Leave( CXItem* pItem )
{
    // Call our base class Leave
    CMenuScreen::Leave( pItem );

    g_bDisplayUpArrow = FALSE;
    g_bDisplayDownArrow = FALSE;

    // Null out our pointer
    m_paHDUsers = NULL;
    m_uiNumItems = 0;
}

// This will be called whenever the user enters this menu
void COLUserMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Reset our cancelled state
    m_bCancelled = FALSE;

    // Set our selected item to the top of the menu
    SetSelectedItem( 0 );

    // Make sure the proper arrows are displayed
    AdjustDisplayArrows();
}


// Adjust the UP and DOWN arrows on the screen
void COLUserMenu::AdjustDisplayArrows()
{
    // Decide if we need to turn on the Up Arrow
    if( 0 == m_uiTopItemIndex )
        g_bDisplayUpArrow = FALSE;  // We can turn off the Up Arrow, because there is nothing above us
    else
        g_bDisplayUpArrow = TRUE;   // We have to turn on the Up Arrow, because a menu choice is above us

    // Decide if we need to turn on the Down Arrow
    if( ( m_uiTopItemIndex + MENU_OLUSER_NUM_ITEMS_TO_DISPLAY ) == GetNumItems() )
        g_bDisplayDownArrow = FALSE;    // We can turn off the Down arrow, because nothing is below us
    else
        g_bDisplayDownArrow = TRUE;     // We have to turn on the Down Arrow, because there are menu choices below us
}

// Store the user information in to the menu
void COLUserMenu::SetInfo( PXONLINE_USER aUsers, unsigned int uiNumUsers )
{
    if( NULL == aUsers )
        return;

    m_paHDUsers = aUsers;
    m_uiNumItems = uiNumUsers;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\muunformatthread.cpp ===
/*****************************************************
*** muformatthread.cpp
***
*** CPP file for our MU Format Thread class.
*** This class will format an MU in a background
*** thread, and report the result to the caller
***
*** by James N. Helm
*** February 9th, 2001
***
*****************************************************/
#include "stdafx.h"
#include "muunformatthread.h"

// Constructor
CMUUnFormatThread::CMUUnFormatThread() :
m_bUnFormatComplete( TRUE ),
m_bUnFormatSuccessful( FALSE ),
m_pMemoryUnit( NULL )
{
}

// Destructor
CMUUnFormatThread::~CMUUnFormatThread()
{
}

/*****************************************************************************

Routine Description:

    ThreadFunct

    This function will format an MU and store the result of the format

Arguments:

    none

Return Value:


Notes:

    See CWorkerThread.h & CWorkerThread.cpp for more information on this
    member function.

*****************************************************************************/
DWORD CMUUnFormatThread::ThreadFunct(void)
{
    // Format the MU

    BOOL bFormatSuccessful;
    if( FAILED( m_pMemoryUnit->Unformat() ) )
    {
        bFormatSuccessful = FALSE;
    }
    else
    {
        bFormatSuccessful = TRUE;
    }
    
    Lock();

    m_bUnFormatSuccessful = bFormatSuccessful;
    m_bUnFormatComplete = TRUE;
    
    Unlock();

    XDBGTRC( APP_TITLE_NAME_A, "CMUUnFormatThread::ThreadFunct():Exiting..." );
    
    return 0;
}


// Informs the caller if the format in progress is complete
BOOL CMUUnFormatThread::IsUnFormatComplete()
{
    BOOL bReturn;

    Lock(); // Protect our memory
    
    bReturn = m_bUnFormatComplete;

    Unlock();

    return bReturn;
}


// Informs the caller if the format was successful or not
BOOL CMUUnFormatThread::IsUnFormatSuccessful()
{
    BOOL bReturn;

    Lock(); // Protect our memory
    
    bReturn = m_bUnFormatSuccessful;

    Unlock();

    return bReturn;
}


// Set the Port and the Slot you wish to format, and begin the format
void CMUUnFormatThread::BeginUnFormat( CMemoryUnit* pMemoryUnit )
{
    // Verify we have a valid pointer
    if( !pMemoryUnit )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMUUnFormatThread::BeginFormat():Invalid pointer passed in!!" );

        return;
    }

    Lock(); // Protect our memory

    // Make sure we don't start the thread twice
    if( TRUE == m_bUnFormatComplete )
    {
        m_pMemoryUnit = pMemoryUnit;

        m_bUnFormatSuccessful = FALSE;
        m_bUnFormatComplete = FALSE;

        // Begin the Format
        Run();
    }

    Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\networkmenu.cpp ===
/*****************************************************
*** networkmenu.cpp
***
*** CPP file for our XShell Network menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** May 19th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "networkmenu.h"

extern CXSettings       g_XboxSettings;     // Settings that are stored on the Xbox
extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructors
CNetworkMenu::CNetworkMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_IPMenu( NULL ),
m_DNSMenu( NULL ),
m_SubnetMenu( NULL ),
m_GatewayMenu( NULL ),
m_MachineNameMenu( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "CNetworkMenu::CNetworkMenu(ex)" );

    m_uiNumItems = NETWORKMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    SetTitle( MENU_TITLE_NETWORK );
}


// Destructor
CNetworkMenu::~CNetworkMenu()
{
}


// Draws a menu on to the screen
void CNetworkMenu::Action( CUDTexture* pTexture )
{
    // Load the settings in to our object from the config sector of the Xbox
    g_XboxSettings.LoadSettings();

    // Check to see if the settings have changed.  If so, update the texture
    if( g_XboxSettings.SettingsHaveChanged() )
    {
        m_bUpdateTexture = TRUE;
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }
    
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    // Draw a box behind the currently highlighted choice
    float X1Pos = MENUBOX_SELECTBAR_X1;
    float Y1Pos = g_fNetworkItemYPos[GetSelectedItem()] - ITEM_SELECTOR_BORDER_SPACE;
    float X2Pos = MENUBOX_SELECTBAR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );

    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

    WCHAR wideString[100];
    DWORD dwHeadTextCol, dwValueTextCol;

    ///////////////////
    // Title IP Address
    ///////////////////

    // If we are on the currently selected item, let's set the text color
    if( GetSelectedItem() == (int)NETWORKMENU_ITEM_IPADDRESS )
    {
        dwHeadTextCol = ITEM_SELECTED_HEADER_COLOR;
        dwValueTextCol = ITEM_SELECTED_VALUE_COLOR;
    }
    else
    {
        dwHeadTextCol = NETWORKMENU_OPTIONHEADER_COLOR;
        dwValueTextCol = SCREEN_DEFAULT_TEXT_FG_COLOR;
    }

    float XPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszNetworkMenuItems[NETWORKMENU_ITEM_IPADDRESS] ) );
    pTexture->DrawText( XPos, NETWORKMENU_IPADDR_YPOS, dwHeadTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_pwszNetworkMenuItems[NETWORKMENU_ITEM_IPADDRESS] );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = MENUBOX_TEXTAREA_X_CENTER + 5.0f;

    // If our IP Address is null, display "dhcp" info
    if( '\0' == g_XboxSettings.GetIPAddress()[0] )
    {
        _snwprintf( wideString, 100, L"(use dhcp)" );
    }
    else
    {
        _snwprintf( wideString, 100, L"%S", g_XboxSettings.GetIPAddress() );
    }
    pTexture->DrawText( XPos, NETWORKMENU_IPADDR_YPOS, dwValueTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", wideString );


    ///////////////////
    // Debug IP Address
    ///////////////////

    // If we are on the currently selected item, let's set the text color
    if( GetSelectedItem() == (int)NETWORKMENU_ITEM_DEBUGIPADDRESS )
    {
        dwHeadTextCol = ITEM_SELECTED_HEADER_COLOR;
        dwValueTextCol = ITEM_SELECTED_VALUE_COLOR;
    }
    else
    {
        dwHeadTextCol = NETWORKMENU_OPTIONHEADER_COLOR;
        dwValueTextCol = SCREEN_DEFAULT_TEXT_FG_COLOR;
    }

    XPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszNetworkMenuItems[NETWORKMENU_ITEM_DEBUGIPADDRESS] ) );
    pTexture->DrawText( XPos, NETWORKMENU_DEBUGIPADDR_YPOS, dwHeadTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_pwszNetworkMenuItems[NETWORKMENU_ITEM_DEBUGIPADDRESS] );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = MENUBOX_TEXTAREA_X_CENTER + 5.0f;

    // If our Debug IP Address is null, display "dhcp" info
    if( '\0' == g_XboxSettings.GetDebugIPAddress()[0] )
    {
        _snwprintf( wideString, 100, L"(use dhcp)" );
    }
    else
    {
        _snwprintf( wideString, 100, L"%hs", g_XboxSettings.GetDebugIPAddress() );
    }
    pTexture->DrawText( XPos, NETWORKMENU_DEBUGIPADDR_YPOS, dwValueTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%ls", wideString );


    //////////////////////
    // Primary DNS Address
    //////////////////////

    // If we are on the currently selected item, let's set the text color
    if( GetSelectedItem() == (int)NETWORKMENU_ITEM_PRIMARYDNS )
    {
        dwHeadTextCol = ITEM_SELECTED_HEADER_COLOR;
        dwValueTextCol = ITEM_SELECTED_VALUE_COLOR;
    }
    else
    {
        dwHeadTextCol = NETWORKMENU_OPTIONHEADER_COLOR;
        dwValueTextCol = SCREEN_DEFAULT_TEXT_FG_COLOR;
    }

    XPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszNetworkMenuItems[NETWORKMENU_ITEM_PRIMARYDNS] ) );
    pTexture->DrawText( XPos, NETWORKMENU_PRIMARYDNS_YPOS, dwHeadTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_pwszNetworkMenuItems[NETWORKMENU_ITEM_PRIMARYDNS] );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = MENUBOX_TEXTAREA_X_CENTER + 5.0f;
	_snwprintf( wideString, 100, L"%S", g_XboxSettings.GetPrimaryDNS() );
    pTexture->DrawText( XPos, NETWORKMENU_PRIMARYDNS_YPOS, dwValueTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%ls", wideString );

    ////////////////////////
    // Secondary DNS Address
    ////////////////////////

    // If we are on the currently selected item, let's set the text color
    if( GetSelectedItem() == (int)NETWORKMENU_ITEM_SECONDARYDNS )
    {
        dwHeadTextCol = ITEM_SELECTED_HEADER_COLOR;
        dwValueTextCol = ITEM_SELECTED_VALUE_COLOR;
    }
    else
    {
        dwHeadTextCol = NETWORKMENU_OPTIONHEADER_COLOR;
        dwValueTextCol = SCREEN_DEFAULT_TEXT_FG_COLOR;
    }

    XPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszNetworkMenuItems[NETWORKMENU_ITEM_SECONDARYDNS] ) );
    pTexture->DrawText( XPos, NETWORKMENU_SECONDARYDNS_YPOS, dwHeadTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_pwszNetworkMenuItems[NETWORKMENU_ITEM_SECONDARYDNS] );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = MENUBOX_TEXTAREA_X_CENTER + 5.0f;
	_snwprintf( wideString, 100, L"%S", g_XboxSettings.GetSecondaryDNS() );
    pTexture->DrawText( XPos, NETWORKMENU_SECONDARYDNS_YPOS, dwValueTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%ls", wideString );


    ///////////////
    // Subnet Mask
    ///////////////

    // If we are on the currently selected item, let's set the text color
    if( GetSelectedItem() == (int)NETWORKMENU_ITEM_SUBNETMASK )
    {
        dwHeadTextCol = ITEM_SELECTED_HEADER_COLOR;
        dwValueTextCol = ITEM_SELECTED_VALUE_COLOR;
    }
    else
    {
        dwHeadTextCol = NETWORKMENU_OPTIONHEADER_COLOR;
        dwValueTextCol = SCREEN_DEFAULT_TEXT_FG_COLOR;
    }

    XPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszNetworkMenuItems[NETWORKMENU_ITEM_SUBNETMASK] ) );
    pTexture->DrawText( XPos, NETWORKMENU_SUBNET_YPOS, dwHeadTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_pwszNetworkMenuItems[NETWORKMENU_ITEM_SUBNETMASK] );
    
    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = MENUBOX_TEXTAREA_X_CENTER + 5.0f;
    _snwprintf( wideString, 100, L"%S", g_XboxSettings.GetSubnetMask() );
    pTexture->DrawText( XPos, NETWORKMENU_SUBNET_YPOS, dwValueTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", wideString );


    ///////////////
    // Gateway
    ///////////////

    // If we are on the currently selected item, let's set the text color
    if( GetSelectedItem() == (int)NETWORKMENU_ITEM_GATEWAY )
    {
        dwHeadTextCol = ITEM_SELECTED_HEADER_COLOR;
        dwValueTextCol = ITEM_SELECTED_VALUE_COLOR;
    }
    else
    {
        dwHeadTextCol = NETWORKMENU_OPTIONHEADER_COLOR;
        dwValueTextCol = SCREEN_DEFAULT_TEXT_FG_COLOR;
    }

    XPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszNetworkMenuItems[NETWORKMENU_ITEM_GATEWAY] ) );
    pTexture->DrawText( XPos, NETWORKMENU_GATEWY_YPOS, dwHeadTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_pwszNetworkMenuItems[NETWORKMENU_ITEM_GATEWAY] );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = MENUBOX_TEXTAREA_X_CENTER + 5.0f;
    _snwprintf( wideString, 100, L"%S", g_XboxSettings.GetGateway() );
    pTexture->DrawText( XPos, NETWORKMENU_GATEWY_YPOS, dwValueTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", wideString );


    ///////////////
    // Machine Name
    ///////////////

    // If we are on the currently selected item, let's set the text color
    if( GetSelectedItem() == (int)NETWORKMENU_ITEM_MACHINENAME )
    {
        dwHeadTextCol = ITEM_SELECTED_HEADER_COLOR;
        dwValueTextCol = ITEM_SELECTED_VALUE_COLOR;
    }
    else
    {
        dwHeadTextCol = NETWORKMENU_OPTIONHEADER_COLOR;
        dwValueTextCol = SCREEN_DEFAULT_TEXT_FG_COLOR;
    }

    XPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszNetworkMenuItems[NETWORKMENU_ITEM_MACHINENAME] ) );
    pTexture->DrawText( XPos, NETWORKMENU_MANAME_YPOS, dwHeadTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_pwszNetworkMenuItems[NETWORKMENU_ITEM_MACHINENAME] );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = MENUBOX_TEXTAREA_X_CENTER + 5.0f;
    _snwprintf( wideString, 100, L"%S", g_XboxSettings.GetMachineName() );
    pTexture->DrawText( XPos, NETWORKMENU_MANAME_YPOS, dwValueTextCol, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", wideString );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CNetworkMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CNetworkMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    // Check to see if we are on the display settings
                    // If so, skip over the Subnet Mask and Gateway if our IP Address is NULL
                    if( NETWORKMENU_ITEM_MACHINENAME == GetSelectedItem() )
                    {
                        if( ( '\0' == g_XboxSettings.GetIPAddress()[0] ) && ( '\0' == g_XboxSettings.GetDebugIPAddress()[0] ) )
                        {
                            SetSelectedItem( GetSelectedItem() - 5 );
                        }
                        else
                        {
                            SetSelectedItem( GetSelectedItem() - 1 );
                        }
                    }
                    else // Otherwise, just hop to the previous item
                    {
                        SetSelectedItem( GetSelectedItem() - 1 );
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    // If we have the IP Address highlighted, and it's set to NULL, we
                    // should skip over the Subnet mask and Gateway
                    if( NETWORKMENU_ITEM_DEBUGIPADDRESS == GetSelectedItem() )
                    {
                        if( ( '\0' == g_XboxSettings.GetIPAddress()[0] ) && ( '\0' == g_XboxSettings.GetDebugIPAddress()[0] ) )
                        {
                            SetSelectedItem( GetSelectedItem() + 5 );
                        }
                        else
                        {
                            SetSelectedItem( GetSelectedItem() + 1 );
                        }
                    }
                    else // Otherwise, just hop to the next item
                    {
                        SetSelectedItem( GetSelectedItem() + 1 );
                    }
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CNetworkMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                switch( GetSelectedItem() )
                {
                case NETWORKMENU_ITEM_IPADDRESS:
                    {
                        m_IPMenu.SetTitleIP( TRUE );
                        m_IPMenu.SetAddress( g_XboxSettings.GetIPAddress() );
                        Leave( &m_IPMenu );

                        break;                
                    }
                case NETWORKMENU_ITEM_DEBUGIPADDRESS:
                    {
                        m_IPMenu.SetTitleIP( FALSE );
                        m_IPMenu.SetAddress( g_XboxSettings.GetDebugIPAddress() );
                        Leave( &m_IPMenu );

                        break;                
                    }
				case NETWORKMENU_ITEM_PRIMARYDNS:
					{
						m_DNSMenu.SetPrimaryDNS( TRUE );
						m_DNSMenu.SetAddress( g_XboxSettings.GetPrimaryDNS() );
						Leave( &m_DNSMenu );

						break;
					}
				case NETWORKMENU_ITEM_SECONDARYDNS:
					{
						m_DNSMenu.SetPrimaryDNS( FALSE );
						m_DNSMenu.SetAddress( g_XboxSettings.GetSecondaryDNS() );
						Leave( &m_DNSMenu );

						break;
					}
                case NETWORKMENU_ITEM_SUBNETMASK:
                    {
                        m_SubnetMenu.SetAddress( g_XboxSettings.GetSubnetMask() );
                        Leave( &m_SubnetMenu );

                        break;
                    }
                case NETWORKMENU_ITEM_GATEWAY:
                    {
                        m_GatewayMenu.SetAddress( g_XboxSettings.GetGateway() );
                        Leave( &m_GatewayMenu );

                        break;
                    }
                case NETWORKMENU_ITEM_MACHINENAME:
                    {
                        m_MachineNameMenu.SetMachineName( g_XboxSettings.GetMachineName() );
                        Leave( &m_MachineNameMenu );

                        break;
                    }
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT CNetworkMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CNetworkMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    // Initialize our IP Menu
    m_IPMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\ip.mnu" );
    m_IPMenu.SetParent( this );

	m_DNSMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\dns.mnu" );
	m_DNSMenu.SetParent( this );

    // Initialize our Subnet Menu
    m_SubnetMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\subnet.mnu" );
    m_SubnetMenu.SetParent( this );

    // Initialize our Gateway Menu
    m_GatewayMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\gateway.mnu" );
    m_GatewayMenu.SetParent( this );

    // Initialize our Machine Name Menu
    m_MachineNameMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\machine.mnu" );
    m_MachineNameMenu.SetParent( this );

    return hr;
}


// Get a pointer to a sub-menu
CXItem* CNetworkMenu::GetItemPtr( enum XShellMenuIds menuId )
{
    CXItem* pReturn = NULL;

    if( ENUM_SHELLMENUID_NETWORK_IPADDRESS == menuId )
    {
        pReturn = &m_IPMenu;
    }
    else if( ENUM_SHELLMENUID_NETWORK_SUBNET == menuId )
    {
        pReturn = &m_SubnetMenu;
    }
    else if( ENUM_SHELLMENUID_NETWORK_PRIMARYDNS == menuId )
    {
        pReturn = &m_DNSMenu;
    }
    else if( ENUM_SHELLMENUID_NETWORK_SECONDARYDNS == menuId )
    {
        pReturn = &m_DNSMenu;
    }
    else if( ENUM_SHELLMENUID_NETWORK_GATEWAY == menuId )
    {
        pReturn = &m_GatewayMenu;
    }
    else if( ENUM_SHELLMENUID_NETWORK_MACHINENAME == menuId )
    {
        pReturn = &m_MachineNameMenu;
    }

    return pReturn;
}


// This will be called whenever the user enters this menu
void CNetworkMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\olusermenu.h ===
/*****************************************************
*** olusermenu.h
***
*** Header file for our XShell Online User menu 
*** class.  This menu will enumerate users for a
*** particular memory area and allow the user to
*** select one.
***
*** by James N. Helm
*** February 15th, 2002
***
*****************************************************/

#ifndef _OLUSERMENU_H_
#define _OLUSERMENU_H_

#include "menuscreen.h"

class COLUserMenu : public CMenuScreen
{
public:
    COLUserMenu( CXItem* pParent );
    ~COLUserMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );
    BOOL GetCancelled() { return m_bCancelled; };           // Used to determine if the user cancelled the menu
    unsigned int GetValue() { return GetSelectedItem(); };  // Return the index of the selected user
    void SetInfo( PXONLINE_USER aUsers,                     // Store the user information in to the menu
                  unsigned int uiNumUsers );

    // Public Methods
    HRESULT Init( char* menuFileName );     // Initialize our font and settings
    void    Leave( CXItem* pItem );         // Should be called whenever a user deactivates this item
private:
    // Private Properties
    unsigned int    m_uiTopItemIndex;                               // Index of the top item being displayed
    BOOL            m_bCancelled;                                   // Used to determine if the user cancelled the Menu
    PXONLINE_USER   m_paHDUsers;                                    // Users that will be read from the HD

    // Private Methods
    void AdjustDisplayArrows();                     // Adjust the UP and DOWN arrows on the screen
};

#endif // _OLUSERMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\optionsmenu.cpp ===
/*****************************************************
*** optionsmenu.cpp
***
*** CPP file for our XShell Options menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** May 19th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "optionsmenu.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell
extern XFONT*           g_pFont;

// Constructors
COptionsMenu::COptionsMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_GameRegionMenu( NULL ),
m_AVRegionMenu( NULL ),
m_VideoResMenu( NULL ),
m_MemoryMenu( NULL ),
m_NetworkMenu( NULL ),
m_CertMenu( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "COptionsMenu::COptionsMenu(ex)" );

    m_uiNumItems = ENUM_OPTIONS_MAX_MENUITEMS;
    SetSelectedItem( 0 );

    SetTitle( MENU_TITLE_OPTIONS );
}


// Destructor
COptionsMenu::~COptionsMenu()
{
}

// Draws a menu on to the screen
void COptionsMenu::Action( CUDTexture* pTexture )
{
    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }
    
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_OPTIONMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_OPTIONMENU_FONT_HEIGHT;

    // Draw a box behind the currently highlighted choice
    float X1Pos = MENUBOX_SELECTBAR_X1;
    float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - ITEM_SELECTOR_BORDER_SPACE;
    float X2Pos = MENUBOX_SELECTBAR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
    
    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

    //
    // Draw our Menu Items
    //

    for( unsigned int x = 0; x < ENUM_OPTIONS_MAX_MENUITEMS; x++ )
    {
        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszOptionsMenuItems[x] );
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void COptionsMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void COptionsMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void COptionsMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                switch( GetSelectedItem() )
                {
                case ENUM_OPTIONS_SET_GAMEREGION:
                    {
                        Leave( &m_GameRegionMenu );

                        break;
                    }
                case ENUM_OPTIONS_SET_AVREGION:
                    {
                        Leave( &m_AVRegionMenu );

                        break;
                    }
                case ENUM_OPTIONS_SET_VIDEORES:
                    {
                        Leave( &m_VideoResMenu );

                        break;
                    }
                case ENUM_OPTIONS_MEMORY:
                    {
                        Leave( &m_MemoryMenu );

                        break;
                    }
                case ENUM_OPTIONS_NETWORK:
                    {
                        Leave( &m_NetworkMenu );

                        break;
                    }
                case ENUM_OPTIONS_CERT_TOOLS:
                    {
                        Leave( &m_CertMenu );

                        break;
                    }
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT COptionsMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "COptionsMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    m_GameRegionMenu.Init( MENU_GAMEREGION_MENU_FILENAME_A );
    m_GameRegionMenu.SetParent( this );

    m_AVRegionMenu.Init( MENU_AVREGION_MENU_FILENAME_A );
    m_AVRegionMenu.SetParent( this );

    m_VideoResMenu.Init( VIDEORESMENU_FILENAME_A );
    m_VideoResMenu.SetParent( this );

    m_MemoryMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\memory.mnu" );
    m_MemoryMenu.SetParent( this );

    m_NetworkMenu.Init( NETWORKMENU_FILENAME_A );
    m_NetworkMenu.SetParent( this );

    m_CertMenu.Init( MENU_CERT_MENU_FILENAME_A );
    m_CertMenu.SetParent( this );

    return hr;
}


// Get a pointer to a sub-menu
CXItem* COptionsMenu::GetItemPtr( enum XShellMenuIds menuId )
{
    CXItem* pReturn = NULL;

    if( ENUM_SHELLMENUID_OPTIONS_NETWORK == menuId )
    {
        pReturn = &m_NetworkMenu;
    }
    else if( ENUM_SHELLMENUID_OPTIONS_GAMEREGION == menuId )
    {
        pReturn = &m_GameRegionMenu;
    }
    else if( ENUM_SHELLMENUID_OPTIONS_AVREGION == menuId )
    {
        pReturn = &m_AVRegionMenu;
    }
    else if( ENUM_SHELLMENUID_OPTIONS_MEMORY == menuId )
    {
        pReturn = &m_MemoryMenu;
    }
    else if( ENUM_SHELLMENUID_OPTIONS_CERT == menuId )
    {
        pReturn = &m_CertMenu;
    }

    return pReturn;
}


// This will be called whenever the user enters this menu
void COptionsMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\optionsmenu.h ===
/*****************************************************
*** optionsmenu.h
***
*** Header file for our XShell Options menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** May 19th, 2001
***
*****************************************************/

#ifndef _OPTIONSMENU_H_
#define _OPTIONSMENU_H_

#include "menuscreen.h"

// Sub-Menus
#include "gameregionmenu.h"
#include "certmenu.h"
#include "avregionmenu.h"
#include "videoresmenu.h"
#include "memorymenu.h"
#include "networkmenu.h"

class COptionsMenu : public CMenuScreen
{
public:
    COptionsMenu( CXItem* pParent );
    ~COptionsMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );                 // Initialize our font and settings
    CXItem* GetItemPtr( enum XShellMenuIds menuID );    // Returns a pointer to a sub-menu

private:
    CGameRegionMenu m_GameRegionMenu;           // Allows user to select the Xbox Game Region
    CAVRegionMenu   m_AVRegionMenu;             // Allows user to select the Xbox AV Region
    CVideoResMenu   m_VideoResMenu;             // Allows the user to set the XDK Launcher Video Resolution
    CMemoryMenu     m_MemoryMenu;               // Memory Unit options menu
    CNetworkMenu    m_NetworkMenu;              // Allows user to configure Xbox Network Settings
    CCertMenu       m_CertMenu;                 // Allows the user to execute the certification tools
};

#endif // _OPTIONSMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\onlinemenu.cpp ===
/*****************************************************
*** onlinemenu.cpp
***
*** CPP file for our XShell Online menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** February 8th, 2002
***
*****************************************************/

#include "stdafx.h"
#include "onlinemenu.h"

extern CSoundCollection g_Sounds;               // Used to generate all sounds for the XShell
extern CGenKeyboardMenu g_GenKeyboardMenu;      // Generic Virutal Keyboard menu
extern CMADisplayMenu   g_MADisplayMenu;        // Used to display our Memory Areas
extern XFONT*           g_pFont;
extern BOOL             g_bDisplayBButton;      // Used to determine if we should render the B Button
extern BOOL             g_bDisplayAButton;      // Used to determine if we should render the A Button
extern CMemoryUnit      g_MemoryUnits[8];       // Memory Units that can be inserted, or removed

// Constructors
COnlineMenu::COnlineMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_UserEvent( ENUM_ONLINE_NO_ACTION ),
m_hrOnlineResult( S_OK ),
m_bDisableInput( FALSE ),
m_hrPingResult( S_OK ),
m_bPNetPinged( FALSE ),
m_hrCreateResult( S_OK ),
m_bUserCreated( FALSE ),
m_hThreadHandle( NULL ),
m_OLUserMenu( NULL ),
m_OLUserOptionMenu( NULL ),
m_PassCodeMenu( NULL ),
m_uiSourceMA( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "COnlineMenu::COnlineMenu(ex)" );

    m_uiNumItems = ENUM_ONLINE_MAX_MENUITEMS;
    SetSelectedItem( 0 );

    // Zero out our User Array
    ZeroMemory( m_aOnlineUsers, sizeof( m_aOnlineUsers ) );

    SetTitle( MENU_TITLE_ONLINE );
}


// Destructor
COnlineMenu::~COnlineMenu()
{
}

// Draws a menu on to the screen
void COnlineMenu::Action( CUDTexture* pTexture )
{
    // Don't do anything if we are running our thread (input is already disabled)
    DWORD dwThreadExitCode;
    if( GetExitCodeThread( m_hThreadHandle, &dwThreadExitCode ) )
    {
        if( STILL_ACTIVE == dwThreadExitCode )
            return;
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
        return;
    else
        m_bUpdateTexture = FALSE;

    // Used to hold a generic message for one of our sub-menus
    WCHAR pwszMessage[MAX_PATH+1];
    pwszMessage[MAX_PATH] = L'\0';

    switch( m_UserEvent )
    {
    case ENUM_ONLINE_NO_ACTION:     // Draw the menu as normal
        {
            // Lock our texture and set it as the render target
            pTexture->Lock();
            pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

#ifdef _DEBUG // This removes the picture on the Online Menu
            // Let our base menu class draw all the items pulled from the MNU file
            CMenuScreen::Action( pTexture );
#endif // _DEBUG

            // Update our Font Height
            XFONT_SetTextHeight( g_pFont, ITEM_ONLINEMENU_FONT_HEIGHT );
            m_uiFontHeightOfItem = ITEM_ONLINEMENU_FONT_HEIGHT;

            // Draw a box behind the currently highlighted choice
            float X1Pos = MENUBOX_SELECTBAR_X1;
            float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - ITEM_SELECTOR_BORDER_SPACE;
            float X2Pos = MENUBOX_SELECTBAR_X2;
            float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
            
            pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

            //
            // Draw our Menu Items
            //
            for( unsigned int x = 0; x < GetNumItems(); x++ )
            {
                float XPos = MENUBOX_TEXTAREA_X1;
                float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

                // Determine which menu item we are dealing with, and draw the text accordingly
                switch( x )
                {
                case ENUM_ONLINE_PING:
                    {
                        if( m_bPNetPinged )
                        {
                            if( SUCCEEDED( m_hrPingResult ) )
                                pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls %hs (%ls)", g_pwszOnlineMenuItems[x], OnlineGetCurrentCluster(), ONLINE_PING_SUCCESS_MSG );
                            else
                                pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls %hs (%ls 0x%08X)", g_pwszOnlineMenuItems[x], OnlineGetCurrentCluster(), ONLINE_PING_FAILED_MSG, m_hrPingResult );
                        }
                        else
                        {
                            pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls %hs", g_pwszOnlineMenuItems[x], OnlineGetCurrentCluster() );
                        }

                        break;
                    }
                case ENUM_ONLINE_CREATEUSER:
                    {
                        if( m_bUserCreated )
                        {
                            if( SUCCEEDED( m_hrCreateResult ) )
                                pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls (%ls)", g_pwszOnlineMenuItems[x], ONLINE_CREATE_USER_SUCCESS_MSG );
                            else
                                pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls (%ls 0x%08X)", g_pwszOnlineMenuItems[x], ONLINE_CREATE_USER_FAILED_MSG, m_hrCreateResult );
                        }
                        else
                        {
                            pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", g_pwszOnlineMenuItems[x] );
                        }

                        break;
                    }
                default:
                    {
                        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszOnlineMenuItems[x] );
                    }
                }
            }

            // Correct our Font Height
            m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
            XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

            // Unlock the texture
            pTexture->Unlock();

            break;
        }
    case ENUM_ONLINE_PING_START:    // Draw our "ping in progress" message
        {
            m_UserEvent = ENUM_ONLINE_PING_IN_PROGRESS;
            UpdateTexture();

            // Lock our texture and set it as the render target
            pTexture->Lock();
            pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

            // Have to do this a second time because the base class action might interfere
            // Update our Font Height
            XFONT_SetTextHeight( g_pFont, ITEM_ONLINEMENU_FONT_HEIGHT );
            m_uiFontHeightOfItem = ITEM_ONLINEMENU_FONT_HEIGHT;

            pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( ONLINE_PING_IN_PROGRESS_MSG ) / 2 ),
                                MENUBOX_TEXTAREA_Y_CENTER - ( m_uiFontHeightOfItem / 2 ),
                                SCREEN_DEFAULT_TEXT_FG_COLOR,
                                SCREEN_DEFAULT_TEXT_BG_COLOR,
                                L"%ls",
                                ONLINE_PING_IN_PROGRESS_MSG );

            // Correct our Font Height
            m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
            XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

            // Unlock the texture
            pTexture->Unlock();

            break;
        }
    case ENUM_ONLINE_PING_COMPLETE:
        {
            m_UserEvent = ENUM_ONLINE_NO_ACTION;
            m_bDisableInput = FALSE;
            g_bDisplayBButton = TRUE;
            g_bDisplayAButton = TRUE;
            UpdateTexture();

            // Close the thread handle
            CloseHandle( m_hThreadHandle );
            m_hThreadHandle = NULL;

            // Display a message with the results on it
            if( SUCCEEDED( m_hrPingResult ) )
                ::DisplayMessage( L"Ping Results", L"\nThe Ping Was Successful" );
            else
                ::DisplayMessage( L"Ping Results", L"The Ping Failed!\n0x%08X (%d)", m_hrPingResult, m_hrPingResult );

            break;
        }
    case ENUM_ONLINE_GET_USERNAME:
        {
            m_UserEvent = ENUM_ONLINE_NO_ACTION;
            UpdateTexture();

            if( !g_GenKeyboardMenu.GetCancelled() )
            {
                // Check to see if it's a valid user name; If not, message the user
                if( !OnlineIsNameValid( g_GenKeyboardMenu.GetValue() ) )
                {
                    m_UserEvent = ENUM_ONLINE_GOT_INVALIDNAME;
                    ::DisplayMessage( L"Invalid User Name", L"The name must be at least 5 characters\nbeginning with a letter.  It may only\ncontain letters, numbers, and\nunderscores (_)." );
                    return;
                }
                else // Collect the passcode
                {
                    m_UserEvent = ENUM_ONLINE_GET_PASSCODE;
                    Leave( &m_PassCodeMenu );
                }
            }

            break;
        }
    case ENUM_ONLINE_GOT_INVALIDNAME:
        {
            m_UserEvent = ENUM_ONLINE_NO_ACTION;
            UpdateTexture();

            CreateUserStart( g_GenKeyboardMenu.GetValue() );
            break;
        }
    case ENUM_ONLINE_GET_PASSCODE:
        {
            m_UserEvent = ENUM_ONLINE_NO_ACTION;
            UpdateTexture();

            if( !m_PassCodeMenu.GetCancelled() )
                m_UserEvent = ENUM_ONLINE_GENERATE_USER_START;

            break;
        }
    case ENUM_ONLINE_GENERATE_USER_START:    // Draw our "Create in progress" message
        {
            m_UserEvent = ENUM_ONLINE_GENERATE_USER_IN_PROGRESS;
            UpdateTexture();

            // Lock our texture and set it as the render target
            pTexture->Lock();
            pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

            // Have to do this a second time because the base class action might interfere
            // Update our Font Height
            XFONT_SetTextHeight( g_pFont, ITEM_ONLINEMENU_FONT_HEIGHT );
            m_uiFontHeightOfItem = ITEM_ONLINEMENU_FONT_HEIGHT;

            pTexture->DrawText( MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( ONLINE_CREATE_USER_IN_PROGRESS_MSG ) / 2 ),
                                MENUBOX_TEXTAREA_Y_CENTER - ( m_uiFontHeightOfItem / 2 ),
                                SCREEN_DEFAULT_TEXT_FG_COLOR,
                                SCREEN_DEFAULT_TEXT_BG_COLOR,
                                L"%ls",
                                ONLINE_CREATE_USER_IN_PROGRESS_MSG );

            // Correct our Font Height
            m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
            XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

            // Unlock the texture
            pTexture->Unlock();

            break;
        }
    case ENUM_ONLINE_GENERATE_USER_COMPLETE:
        {
            m_UserEvent = ENUM_ONLINE_NO_ACTION;
            m_bDisableInput = FALSE;
            g_bDisplayBButton = TRUE;
            g_bDisplayAButton = TRUE;
            UpdateTexture();

            // Close the thread handle
            CloseHandle( m_hThreadHandle );
            m_hThreadHandle = NULL;

            // Display a message with the results on it
            if( SUCCEEDED( m_hrCreateResult ) )
            {
                ::DisplayMessage( L"Create User Results", L"\nThe User Was Created Successfully" );
                return;
            }
            else
            {
                if( XONLINE_S_ACCOUNTS_NAME_TAKEN == m_hrCreateResult ) // March XDK Hack --> || ( XONLINE_E_SERVER_ERROR == m_hrCreateResult ) )
                    ::DisplayMessage( L"Create User Results", L"That User Name Is Already In Use\nPlease Try Again With a Different Name" );
                else
                    ::DisplayMessage( L"Create User Results", L"Creating The User Failed!\n0x%08X (%d)", m_hrCreateResult, m_hrCreateResult );
                return;
            }

            break;
        }
    case ENUM_ONLINE_MANAGE_NAVTOGETSOURCEMEMAREA:
        {
            m_UserEvent = ENUM_ONLINE_MANAGE_GETMEMAREA;
            UpdateTexture();

            g_MADisplayMenu.SetTitle( L"Select Source" );
            g_MADisplayMenu.SetInfo( FALSE, TRUE );
            Leave( &g_MADisplayMenu );
            break;
        }
    case ENUM_ONLINE_MANAGE_NAVTOSOURCEMEMAREAUSERS:
        {
            //
            // Navigate back to the source memory area user display screen
            //
            m_UserEvent = ENUM_ONLINE_NO_ACTION;
            UpdateTexture();

            if( !NavToSourceMAUsers() )
                m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOGETSOURCEMEMAREA;

            break;
        }
    case ENUM_ONLINE_MANAGE_GETMEMAREA:
        {
            m_UserEvent = ENUM_ONLINE_NO_ACTION;
            UpdateTexture();

            if( !g_MADisplayMenu.GetCancelled() )
            {
                // Store the source memory area and prompt for a destination
                m_uiSourceMA = g_MADisplayMenu.GetSelectedItem();

                // Check to see if we are dealing with the Hard Drive
                if( ENUM_MADISPLAY_HARD_DRIVE == m_uiSourceMA )
                {
                    // Zero out our Online Users
                    ZeroMemory( m_aOnlineUsers, sizeof( m_aOnlineUsers ) );

                    // Get the users from the Hard Drive
                    DWORD dwNumUsers;
                    HRESULT hr = OnlineGetUsersFromHD( (PXONLINE_USER) m_aOnlineUsers, &dwNumUsers );
                    if( FAILED( hr ) )
                    {
                        m_UserEvent = ENUM_ONLINE_NO_ACTION;

                        ::DisplayErrorMessage( L"Obtaining users from the Hard Drive Failed!\n0x%08X (%d)", hr, hr );
                        return;
                    }

                    // Make sure there is at least one user.  If not, message the user
                    if( 0 == dwNumUsers )
                    {
                        m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOGETSOURCEMEMAREA;

                        ::DisplayMessage( L"No Users", L"There are no users to manage\non the Hard Drive" );
                        return;
                    }
                    else if( 1 == dwNumUsers )  // If there is only 1 user, skip the user select menu
                    {
                        // Go to the user options screen
                        m_UserEvent = ENUM_ONLINE_MANAGE_GETUSEROPTION;

                        m_OLUserMenu.SetSelectedItem( 0 );  // We use this menu to store our source user for HD copies
                        swprintf( pwszMessage, L"What would you like to do with\n%hs.%hs?", m_aOnlineUsers[0].name, m_aOnlineUsers[0].kingdom );

                        m_OLUserOptionMenu.SetText( pwszMessage );
                        Leave( &m_OLUserOptionMenu );
                        break;
                    }
                    else
                    {
                        m_UserEvent = ENUM_ONLINE_MANAGE_GETUSERFROMHD;

                        m_OLUserMenu.SetInfo( m_aOnlineUsers, dwNumUsers );
                        Leave( &m_OLUserMenu );
                        break;
                    }                    
                }
                else // Selected area must be memory unit
                {
                    // Prompt the user for a list of options (Copy and Delete)
                    m_UserEvent = ENUM_ONLINE_MANAGE_GETUSEROPTION;

                    // Get the user name off of the MU
                    BOOL bUserExists;
                    HRESULT hr = OnlineGetUserFromMU( g_MemoryUnits[m_uiSourceMA].GetPort(),
                                                      g_MemoryUnits[m_uiSourceMA].GetSlot(),
                                                      (PXONLINE_USER) m_aOnlineUsers,
                                                      &bUserExists );
                    if( FAILED( hr ) )
                    {
                        m_UserEvent = ENUM_ONLINE_NO_ACTION;

                        ::DisplayErrorMessage( L"Failed to get the user from the\nMemory Unit!!\n0x%08X (%d)", hr, hr );
                        return;
                    }

                    // If there is no user on the MU, message the user
                    if( !bUserExists )
                    {
                        m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOGETSOURCEMEMAREA;

                        ::DisplayMessage( L"No Users", L"There are no users to manage\non this Memory Area" );
                        return;
                    }

                    swprintf( pwszMessage,
                              L"What would you like to do with\n%hs.%hs?",
                              m_aOnlineUsers[0].name,
                              m_aOnlineUsers[0].kingdom );
                    
                    m_OLUserOptionMenu.SetText( pwszMessage );
                    Leave( &m_OLUserOptionMenu );
                }
            }

            break;
        }
    case ENUM_ONLINE_MANAGE_GETUSERFROMHD:
        {
            m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOGETSOURCEMEMAREA;
            UpdateTexture();

            if( !m_OLUserMenu.GetCancelled() )
            {
                m_UserEvent = ENUM_ONLINE_MANAGE_GETUSEROPTION;
                
                swprintf( pwszMessage, L"What would you like to do with\n%hs.%hs?", m_aOnlineUsers[m_OLUserMenu.GetValue()].name, m_aOnlineUsers[m_OLUserMenu.GetValue()].kingdom );
                
                m_OLUserOptionMenu.SetText( pwszMessage );
                Leave( &m_OLUserOptionMenu );
            }

            break;
        }
    case ENUM_ONLINE_MANAGE_GETUSEROPTION:
        {
            m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOSOURCEMEMAREAUSERS;
            UpdateTexture();

            // Check to see if the user cancelled the menu
            if( !m_OLUserOptionMenu.GetCancelled() )
            {
                switch( m_OLUserOptionMenu.GetOption() )
                {
                case ENUM_OLUSEROPTION_COPY:
                    {
                        m_UserEvent = ENUM_ONLINE_MANAGE_GETDESTMEMAREA;

                        // Ask the user for the destination memory area
                        // TODO: Check with PM -- Should user be allowed to select same destination as source?
                        // TODO: Probably, because once the user is read from a MA, that MA can be switched with another
                        g_MADisplayMenu.SetTitle( L"Select Destination" );
                        g_MADisplayMenu.SetInfo( FALSE, TRUE );
                        Leave( &g_MADisplayMenu );

                        break;
                    }
                case ENUM_OLUSEROPTION_DELETE:
                    {
                        m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOSOURCEMEMAREAUSERS;
                        UpdateTexture();

                        // Delete the specified user from the specified memory area
                        if( ENUM_MADISPLAY_HARD_DRIVE == m_uiSourceMA )
                        {
                            HRESULT hr = OnlineRemoveUserFromHD( &m_aOnlineUsers[m_OLUserMenu.GetValue()] );
                            if( FAILED( hr ) )
                            {
                                ::DisplayErrorMessage( L"Failed to remove the user\nfrom the hard drive!\n%hs.%hs\n0x%08X (%d)", m_aOnlineUsers[m_OLUserMenu.GetValue()].name, m_aOnlineUsers[m_OLUserMenu.GetValue()].kingdom, hr, hr );
                                return;
                            }
                            else // Successful!
                            {
                                ::DisplayMessage( L"Success", L"The user was successfully removed\nfrom the hard drive!\n%hs.%hs", m_aOnlineUsers[m_OLUserMenu.GetValue()].name, m_aOnlineUsers[m_OLUserMenu.GetValue()].kingdom );
                                return;
                            }
                        }
                        else // Must be a MU
                        {
                            // Set an empty user in to the MU
                            HRESULT hr = OnlineClearUserFromMU( g_MemoryUnits[m_uiSourceMA].GetUDataDrive() );
                            if( FAILED( hr ) )
                            {
                                ::DisplayErrorMessage( L"Failed to remove the user\nfrom the Memory Unit!\n%hs.%hs\n0x%08X (%d)", m_aOnlineUsers[0].name, m_aOnlineUsers[0].kingdom, hr, hr );
                                return;
                            }
                            else // Successful!
                            {
                                // Refresh the MU name (it probably changed)
                                g_MemoryUnits[m_uiSourceMA].RefreshName();

                                ::DisplayMessage( L"Success", L"The user was successfully removed\nfrom the Memory Unit!\n%hs.%hs", m_aOnlineUsers[0].name, m_aOnlineUsers[0].kingdom );
                                return;
                            }
                        }

                        break;
                    }
                }
            }

            break;
        }
    case ENUM_ONLINE_MANAGE_GETDESTMEMAREA:
        {
            m_UserEvent = ENUM_ONLINE_NO_ACTION;
            UpdateTexture();

            if( g_MADisplayMenu.GetCancelled() )
            {
                m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOSOURCEMEMAREAUSERS;
                ::DisplayMessage( L"Copy Cancelled", L"\nThe copy operation has been cancelled." );
                return;
            }
            else  // Did the user cancel the action?  If so, abort
            {
                unsigned int uiDestMemArea = g_MADisplayMenu.GetSelectedItem();
                PXONLINE_USER pSourceUser = NULL;

                if( ENUM_MADISPLAY_HARD_DRIVE == m_uiSourceMA )
                    pSourceUser = &m_aOnlineUsers[m_OLUserMenu.GetValue()];
                else // Source is the Memory Unit
                    pSourceUser = &m_aOnlineUsers[0];

                // Does destionation memory areas exist?
                if( ( ENUM_MADISPLAY_HARD_DRIVE != uiDestMemArea ) && ( !g_MemoryUnits[uiDestMemArea].IsMounted() ) )
                {
                    ::DisplayMessage( L"User Copy Aborted", L"The destination Memory Unit was removed\n\nCopy Aborted" );
                    return;
                }

                // If the destination is the hard drive, check to see if the name already exists
                if( ENUM_MADISPLAY_HARD_DRIVE == uiDestMemArea )
                {
                    BOOL bUserExists;
                    HRESULT hr = OnlineIsUserOnHD( pSourceUser->name, &bUserExists );
                    
                    // TODO: Message the user with an error
                    // if( FAILED( hr ) )                        

                    if( bUserExists )
                    {
                        m_UserEvent = ENUM_ONLINE_MANAGE_OVERWRITE;

                        ::DisplayYesNoMessage( L"Overwrite User", L"Would you like to overwrite the user\non the hard drive?\n%hs.%hs", pSourceUser->name, pSourceUser->kingdom );
                        return;
                    }
                    else // Check to see if the Hard Drive is full.  If so, message the user
                    {
                        DWORD dwNumUsers = 0;
                        XONLINE_USER  aOnlineUsers[XONLINE_MAX_STORED_ONLINE_USERS];

                        HRESULT hr = OnlineGetUsersFromHD( (PXONLINE_USER) aOnlineUsers, &dwNumUsers );
                        if( FAILED( hr ) )
                        {
                            swprintf( pwszMessage, L"Failed to retreive users from the\nHard Drive!!\n0x%08X (%d)", hr, hr );

                            // Message the user with the failure code
                            ::DisplayErrorMessage( L"Failed to retreive users from the\nHard Drive!!\n0x%08X (%d)", hr, hr );
                            return;
                        }

                        if( 8 == dwNumUsers )
                        {
                            ::DisplayMessage( L"Hard Drive Full", L"The hard drive contains the maximum\nnumber of users. (8).\nYou need to delete a user to continue" );
                            return;
                        }
                    }
                }
                else // Memory Unit
                {
                    BOOL bUserExists;
                    XONLINE_USER OnlineUser;

                    HRESULT hr = OnlineGetUserFromMU( g_MemoryUnits[uiDestMemArea].GetPort(),
                                                      g_MemoryUnits[uiDestMemArea].GetSlot(),
                                                      (PXONLINE_USER) &OnlineUser,
                                                      &bUserExists );
                    if( FAILED( hr ) )
                    {
                        ::DisplayErrorMessage( L"Failed to get the users from the\nMemory Unit!!\n0x%08X (%d)", hr, hr );
                        return;
                    }

                    if( bUserExists )
                    {
                        // Prompt for overwrite
                        m_UserEvent = ENUM_ONLINE_MANAGE_OVERWRITE;
                        
                        // TODO: Use the MU name as well as the destination user name
                        ::DisplayYesNoMessage( L"Overwrite User", L"Overwrite %hs.%hs\nwith %hs.%hs\non the Memory Unit?", OnlineUser.name, OnlineUser.kingdom, pSourceUser->name, pSourceUser->kingdom );
                        return;
                    }
                }

                // Copy the user to the destination memory area
                HRESULT hr = CopyUserToMA( pSourceUser, uiDestMemArea );

                // Make sure we return the user to the 'Select User' screen if possible,
                // or the 'Select Memory Area' screen if not possible.
                m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOSOURCEMEMAREAUSERS;

                if( FAILED( hr ) )
                {
                    // Message the user with the failure code
                    ::DisplayErrorMessage( L"Failed to Copy the user to the\nMemory Area!0x%08X (%d)", hr, hr );
                    return;
                }
                else
                {
                    // Report success to the user
                    ::DisplayMessage( L"User Copy Successful", L"Successfully copied the user to the\nmemory area!\n%hs.%hs", pSourceUser->name, pSourceUser->kingdom );
                    return;
                }
            }

            break;
        }
    case ENUM_ONLINE_MANAGE_OVERWRITE:
        {
            // Make sure we return the user to the 'Select User' screen if possible,
            // or the 'Select Memory Area' screen if not possible.
            m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOSOURCEMEMAREAUSERS;
            UpdateTexture();

            if( YesNoMenuCancelled() )
            {
                ::DisplayMessage( L"Copy Cancelled", L"\nThe copy operation has been cancelled." );
                return;
            }
            else
            {
                unsigned int uiDestMemArea = g_MADisplayMenu.GetSelectedItem();
                PXONLINE_USER pSourceUser = NULL;

                if( ENUM_MADISPLAY_HARD_DRIVE == m_uiSourceMA )
                    pSourceUser = &m_aOnlineUsers[m_OLUserMenu.GetValue()];
                else // Source is the Memory Unit
                    pSourceUser = &m_aOnlineUsers[0];

                // Does the destionation memory areas exist?
                if( ( ENUM_MADISPLAY_HARD_DRIVE != uiDestMemArea ) && ( !g_MemoryUnits[uiDestMemArea].IsMounted() ) )
                {
                    ::DisplayMessage( L"User Copy Aborted", L"The destination Memory Unit was removed\n\nCopy Aborted" );
                    return;
                }

                // Copy the user to the destination memory area
                HRESULT hr = CopyUserToMA( pSourceUser, uiDestMemArea );
                if( FAILED( hr ) )
                {
                    // Message the user with the failure code
                    ::DisplayErrorMessage( L"Failed to Copy the user to the\nMemory Area!0x%08X (%d)", hr, hr );
                    return;
                }
                else
                {
                    // Report success to the user
                    ::DisplayMessage( L"User Copy Successful", L"Successfully copied the user to the\nmemory area!\n%hs.%hs", pSourceUser->name, pSourceUser->kingdom );
                    return;
                }
            }

            break;
        }
    case ENUM_ONLINE_PING_IN_PROGRESS:  // These events need to be handled in a thread
    case ENUM_ONLINE_GENERATE_USER_IN_PROGRESS:
        {
            // Make sure no input is enabled before we create our thread
            m_bDisableInput = TRUE;

            // Disable the a and b buttons
            g_bDisplayBButton = FALSE;
            g_bDisplayAButton = FALSE;

            m_hThreadHandle = CreateThread( NULL,
                                            0,
                                            ProcessUserEvents,
                                            (void*) this,
                                            0,
                                            NULL );
            break;
        }
    }
}


// Handle any requests for the joystick (thumb-pad)
void COnlineMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    if( m_bDisableInput )
        return;

    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void COnlineMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( m_bDisableInput )
        return;

    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void COnlineMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( m_bDisableInput )
        return;

    // If it's a repeat press, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                switch( GetSelectedItem() )
                {
                case ENUM_ONLINE_PING:
                    {
                        // Ping the currently selected domain
                        m_UserEvent = ENUM_ONLINE_PING_START;
                        UpdateTexture();

                        break;
                    }
                case ENUM_ONLINE_CREATEUSER:
                    {
                        WCHAR pwszUserName[XONLINE_NAME_SIZE];
                        pwszUserName[XONLINE_NAME_SIZE - 1] = L'\0';

                        OnlineGenerateUserName( pwszUserName );
                        CreateUserStart( pwszUserName );

                        break;
                    }
                case ENUM_ONLINE_MANAGEUSERS:
                    {
                        // Manage Users
                        m_UserEvent = ENUM_ONLINE_MANAGE_NAVTOGETSOURCEMEMAREA;
                        UpdateTexture();

                        break;
                    }
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT COnlineMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "COnlineMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    //
    // Initialize Sub-Menus
    //

    m_PassCodeMenu.Init( MENU_PASSCODE_MENU_FILENAME );
    m_PassCodeMenu.SetParent( this );

    m_OLUserMenu.Init( MENU_OLUSER_MENU_FILENAME_A );
    m_OLUserMenu.SetParent( this );

    m_OLUserOptionMenu.Init( MENU_OLUSEROPTION_MENU_FILENAME_A );
    m_OLUserOptionMenu.SetParent( this );

    return hr;
}

DWORD WINAPI COnlineMenu::ProcessUserEvents( LPVOID lpParam )
{
    COnlineMenu* pOnlineMenu = (COnlineMenu*)lpParam;
    switch( pOnlineMenu->m_UserEvent )
    {
    case ENUM_ONLINE_PING_IN_PROGRESS:     // Draw the menu as normal
        {
            // Does a quick logon to the user account creation server
            pOnlineMenu->m_hrOnlineResult = OnlineQuickLoginStart();
            if( FAILED( pOnlineMenu->m_hrOnlineResult ) )
                XDBGWRN( APP_TITLE_NAME_A, "COnlineMenu::ProcessUserEvents():Failed to perform OnlineQuickLoginStart!! (0x%08X)", pOnlineMenu->m_hrOnlineResult );

            // Does a quick logoff to the user account creation server
            HRESULT hr = OnlineQuickLoginFinish(); 
            if( FAILED( hr ) )
                XDBGWRN( APP_TITLE_NAME_A, "COnlineMenu::ProcessUserEvents():Failed to perform OnlineQuickLoginFinish!! (0x%08X)", hr );

            // Store the Ping Result for later
            pOnlineMenu->m_hrPingResult = pOnlineMenu->m_hrOnlineResult;
            pOnlineMenu->m_UserEvent = ENUM_ONLINE_PING_COMPLETE;
            pOnlineMenu->m_bPNetPinged = TRUE;
            pOnlineMenu->UpdateTexture();

            break;
        }
    case ENUM_ONLINE_GENERATE_USER_IN_PROGRESS:
        {
            pOnlineMenu->m_UserEvent = ENUM_ONLINE_GENERATE_USER_COMPLETE;
            pOnlineMenu->m_bUserCreated = TRUE;

            XONLINE_USER OnlineUser;
            ZeroMemory( &OnlineUser, sizeof( OnlineUser ) );

            sprintf( OnlineUser.name, "%ls", g_GenKeyboardMenu.GetValue() );
            memcpy( OnlineUser.pin, pOnlineMenu->m_PassCodeMenu.GetValue(), XONLINE_PIN_LENGTH );
            strncpy( OnlineUser.kingdom, OnlineGetCurrentRealm(), XONLINE_KINGDOM_SIZE );    // TODO: Get this from an INI file somewhere

            // Set the require pin flag if necessary
            if( '\0' != OnlineUser.pin[0] )
                OnlineUser.dwUserOptions |= XONLINE_USER_OPTION_REQUIRE_PIN;

            pOnlineMenu->m_hrOnlineResult = OnlineGenerateUserAccount( &OnlineUser );
            if( FAILED( pOnlineMenu->m_hrOnlineResult ) )
                XDBGWRN( APP_TITLE_NAME_A, "COnlineMenu::ProcessUserEvents():Failed to Generate User Account!! Error - '0x%08X', '%d'", pOnlineMenu->m_hrOnlineResult, pOnlineMenu->m_hrOnlineResult );

            // Store this result to user later on our menu
            pOnlineMenu->m_hrCreateResult = pOnlineMenu->m_hrOnlineResult;

            pOnlineMenu->UpdateTexture();
            
            break;
        }
    }

    return 0;
}


// Will be called whenever the user enters this menu
void COnlineMenu::Enter()
{
    // Call the base class enter
    CMenuScreen::Enter();

    // Set our "global" menus to point to this menu
    g_GenKeyboardMenu.SetParent( this );
    g_MADisplayMenu.SetParent( this );
}


// Copies a user to the specified memory area
HRESULT COnlineMenu::CopyUserToMA( PXONLINE_USER pOnlineUser, unsigned int uiMemArea )
{
    HRESULT hr = S_OK;

    // Copy the user
    if( ENUM_MADISPLAY_HARD_DRIVE == uiMemArea )
    {
        hr = OnlineAddUserToHD( (PXONLINE_USER) pOnlineUser );
        if( FAILED( hr ) )
            XDBGWRN( APP_TITLE_NAME_A, "COnlineMenu::CopyUserToMA()OnlineAddUserToHD Failed!! - '0x%08X', '%d'", hr, hr );
    }
    else // Destination is an MU
    {
        hr = OnlineSetUserInMU( g_MemoryUnits[uiMemArea].GetUDataDrive(), (PXONLINE_USER) pOnlineUser );
        if( FAILED( hr ) )
            XDBGWRN( APP_TITLE_NAME_A, "COnlineMenu::CopyUserToMA()OnlineSetUserInMU Failed!! - '0x%08X', '%d'", hr, hr );
        else // Refresh the MU name (it probably changed)
            g_MemoryUnits[uiMemArea].RefreshName();
    }

    return hr;
}


// Used to start the Create User process
void COnlineMenu::CreateUserStart( WCHAR* pwszUserName )
{
    if( NULL == pwszUserName )
        return;

    // Check to see if the Hard Drive is full.  If so, message the user
    DWORD dwNumUsers = 0;
    HRESULT hr = OnlineGetUsersFromHD( (PXONLINE_USER) m_aOnlineUsers, &dwNumUsers );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "COnlineMenu::HandleInput():Failed to get the users from the hard drive!!" );
        ::DisplayErrorMessage( L"Obtaining users from the Hard Drive Failed!\n0x%08X (%d)", hr, hr );
        return;
    }

    // If the hard drive is full we need to message the user
    if( 8 == dwNumUsers )
    {
        ::DisplayMessage( L"Hard Drive Full", L"The hard drive contains the maximum\nnumber of users. (8).\nYou need to delete a user to continue" );
        return;
    }

    //Create a user on the currently selected domain
    m_UserEvent = ENUM_ONLINE_GET_USERNAME;

    g_GenKeyboardMenu.SetInfo( L"Enter a user name:", XONLINE_NAME_SIZE - 1, pwszUserName );
    g_GenKeyboardMenu.SetTitle( L"Online User Name" );

    Leave( &g_GenKeyboardMenu );
}


// Returns TRUE if it navigates to the Memory Area screen, FALSE if otherwise
BOOL COnlineMenu::NavToSourceMAUsers()
{
    return FALSE;

    /* Sean changed his mind on the flow, so for now, comment this out
    // Check to see if we are dealing with the Hard Drive
    if( ENUM_MADISPLAY_HARD_DRIVE == m_uiSourceMA )
    {
        // Zero out our Online Users
        ZeroMemory( m_aOnlineUsers, sizeof( m_aOnlineUsers ) );

        // Get the users from the Hard Drive
        DWORD dwNumUsers;
        HRESULT hr = OnlineGetUsersFromHD( (PXONLINE_USER) m_aOnlineUsers, &dwNumUsers );
        if( FAILED( hr ) )
        {
            m_UserEvent = ENUM_ONLINE_NO_ACTION;

            ::DisplayErrorMessage( L"Obtaining users from the Hard Drive Failed!\n0x%08X (%d)", hr, hr );
            return FALSE;
        }

        // Make sure there is at least one user.  If not, return FALSE
        if( ( 0 == dwNumUsers ) || ( 1 == dwNumUsers ) )
        {
            return FALSE;
        }
        else
        {
            m_UserEvent = ENUM_ONLINE_MANAGE_GETUSERFROMHD;

            m_OLUserMenu.SetInfo( m_aOnlineUsers, dwNumUsers );
            Leave( &m_OLUserMenu );
            return TRUE;
        }                    
    }
    else // Selected area must be memory unit
    {
        return FALSE;
    }
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\oluseroptionmenu.cpp ===
/*****************************************************
*** oluseroptionmenu.cpp
***
*** CPP file for our Online User Option menu class
*** This menu will present the user with a list of
*** options that can be performed on/with an Online
*** user.
***
*** by James N. Helm
*** February 15th, 2002
***
*****************************************************/

#include "stdafx.h"
#include "oluseroptionmenu.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructors
COLUserOptionMenu::COLUserOptionMenu( CXItem* pParent ) :
CMenuScreen( pParent ),
m_bCancelled( FALSE ),
m_xKeypos( 0 ),
m_yKeypos( 0 ),
m_uiSelectedOption( ENUM_OLUSEROPTION_COPY )
{
    // Zero out our buffers
    for( unsigned int x = 0; x < gc_uiOLUSEROPTION_NUM_TEXT_LINES; x++ )
        ZeroMemory( m_apwszTextMessage[x], sizeof( WCHAR ) * ( MAX_PATH + 1 ) );

    // Default Text
    SetText( L"What would you like to do with the\ncurrent user?" );

    GenerateKeypad();
}


// Destructor
COLUserOptionMenu::~COLUserOptionMenu()
{
}


// Initialize the Menu
HRESULT COLUserOptionMenu::Init( char* menuFileName )
{
    HRESULT hr = CMenuScreen::Init( menuFileName );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "COLUserOptionMenu::Init():Failed to initialize base class!!" );
        return hr;
    }

	// Set the menu title
	SetTitle( MENU_TITLE_OLUSEROPTION );

    return hr;
}


// Draws a menu on to the screen
void COLUserOptionMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

	// Draw our keypad
	renderKeypad( pTexture );

    // Render the text message
    for( unsigned int x = 0; x < gc_uiOLUSEROPTION_NUM_TEXT_LINES; x++ )
    {
		WCHAR* pwszMessagePtr = m_apwszTextMessage[x];
		DWORD dwFGColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
		DWORD dwBGColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

		// Determine if the user wants to display this line of text in a different color
		if( 0 == wcsncmp( m_apwszTextMessage[x], L"/c", 2 ) )
		{
			pwszMessagePtr += 2;	// Skip the initial "/c"

			// Read the DWORD FG color out of the line
			WCHAR* pwszStopString = NULL;
			dwFGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwFGColor )
				XDBGWRN( APP_TITLE_NAME_A, "CMessageMenu::RenderMenuItems():Possible error in conversion of the FG color (DWORD)\n" );

			// Skip over the FG color and the space
			pwszMessagePtr = pwszStopString + 1;

			// Read the DWORD BG color out of the line
			dwBGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwBGColor )
				XDBGWRN( APP_TITLE_NAME_A, "CMessageMenu::RenderMenuItems():Possible error in conversion of the BG color (DWORD)\n" );

			// Skip over the BG color and the space
			pwszMessagePtr = pwszStopString + 1;
		}

        float fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( pwszMessagePtr ) / 2 );
        float fYPos = gc_fOLUSEROPTION_TEXT_YPOS + ( x * ( m_uiFontHeightOfItem + ITEM_VERT_SPACING ) );

        pTexture->DrawText( fXPos, fYPos, dwFGColor, dwBGColor, L"%ls", pwszMessagePtr );
    }

    // Unlock our texture
    pTexture->Unlock();
}


// Handles input (of the CONTROLS) for the current menu
void COLUserOptionMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_LEFT:
        {
            // Wrap the cursor
            if( 0 == m_xKeypos )
                m_xKeypos = gc_uiOLUSEROPTION_NUM_COLS - 1;
            else // m_xKeypos > 0
                m_xKeypos--;
            
            for( int x = m_xKeypos; x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Wrap the cursor
            if( ( gc_uiOLUSEROPTION_NUM_COLS - 1 ) == m_xKeypos )
                m_xKeypos = 0;
            else // m_xKeypos < ( gc_uiOLUSEROPTION_NUM_COLS - 1 )
                m_xKeypos++;

            for( int x = m_xKeypos; x < gc_uiOLUSEROPTION_NUM_COLS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void COLUserOptionMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Only process the option if it's the first button press
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            // Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, gc_pwszOLUSEROPTION_COPY_TEXT ) )    // Copy
                m_uiSelectedOption = ENUM_OLUSEROPTION_COPY;
            else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, gc_pwszOLUSEROPTION_DELETE_TEXT ) )    // Delete
                m_uiSelectedOption = ENUM_OLUSEROPTION_DELETE;

            // Go back to the previous menu
            if( NULL != GetParent() )
                Leave( GetParent() );

            break;
        }
    case BUTTON_B:
        {
            m_uiSelectedOption = ENUM_OLUSEROPTION_NONE;
            m_bCancelled = TRUE;

            // Play the Back Sound
            g_Sounds.PlayBackSound();

            // Go back to the previous menu
            if( NULL != GetParent() )
                Leave( GetParent() );

            break;
        }
    }
}


// Generate the kepad we will be using
void COLUserOptionMenu::GenerateKeypad(void) 
{
	
	// Create the buttons
	int xstart = gc_uiOLUSEROPTION_TOPROW_X1;
	int ystart = gc_uiOLUSEROPTION_TOPROW_Y1;
	int width  = gc_uiOLUSEROPTION_BUTTON_WIDTH;
	int height = gc_uiOLUSEROPTION_BUTTON_HEIGHT;
	int spacer = gc_uiOLUSEROPTION_BUTTON_SPACER;
	int currentx = xstart;
	int currenty = ystart;

    for(int y = 0; y < gc_uiOLUSEROPTION_NUM_ROWS; y++)
	{
		for(int x = 0; x < gc_uiOLUSEROPTION_NUM_COLS; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    m_keyPad[0][0].defineText( (WCHAR*)gc_pwszOLUSEROPTION_COPY_TEXT );
    m_keyPad[1][0].defineText( (WCHAR*)gc_pwszOLUSEROPTION_DELETE_TEXT );
}


// Draw our keypad
BOOL COLUserOptionMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < gc_uiOLUSEROPTION_NUM_COLS; x++)
	{
		for(int y = 0; y < gc_uiOLUSEROPTION_NUM_ROWS; y++)
		{
			if( m_keyPad[x][y].getRender() && ( wcscmp( m_keyPad[x][y].m_pwszResultChar, L"place" ) != 0 ) )
			{
                // Lock our texture so that we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    
                    dwCharColor = ITEM_SELECTED_VALUE_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, gc_fOLUSEROPTION_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// This will be called whenever this menu is entered / activated
void COLUserOptionMenu::Leave( CXItem* pItem )
{
    // Call the base class leave to make sure we do the right thing
    CMenuScreen::Leave( pItem );

    // Default Text
    SetText( L"What would you like to do with the\ncurrent user?" );
}

// This will be called whenever this menu is entered / activated
void COLUserOptionMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Default the focus to the Copy Button
	m_xKeypos = 0;
    m_yKeypos = 0;

    // Make sure our cancelled option is set to FALSE
    m_bCancelled = FALSE;

    // Make sure our value is set to nothing
    m_uiSelectedOption = ENUM_OLUSEROPTION_NONE;
}


// Used to set the text message that will be displayed to the user
void COLUserOptionMenu::SetText( WCHAR* pwszMessage )
{
    if( NULL == pwszMessage )
    {
        XDBGWRN( APP_TITLE_NAME_A, "COLUserOptionMenu::SetText():Invalid argument(s) passed in!!" );

        return;
    }

    for( unsigned int x = 0; x < gc_uiOLUSEROPTION_NUM_TEXT_LINES; x++ )
    {
        unsigned int uiCount = 0;
        while( ( *pwszMessage != L'\n' ) && ( *pwszMessage != L'\0' ) )
        {
            m_apwszTextMessage[x][uiCount] = *pwszMessage;
            uiCount++;
            pwszMessage++;

            // Exit when we find the end of the current string
            if( uiCount == MAX_PATH + 1 )
                break;
        }
        m_apwszTextMessage[x][uiCount] = L'\0';

        // Exit early if we are at the end of the message
        if( *pwszMessage == L'\0' )
            break;

        uiCount++;
        pwszMessage++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\oluseroptionmenu.h ===
/*****************************************************
*** oluseroptionmenu.h
***
*** Header file for our Online User Option menu class
*** This menu will present the user with a list of
*** options that can be performed on/with an Online
*** user.
***
*** by James N. Helm
*** February 15th, 2002
***
*****************************************************/

#ifndef _OLUSEROPTIONMENU_H_
#define _OLUSEROPTIONMENU_H_

const unsigned int gc_uiOLUSEROPTION_NUM_ROWS =         1;     
const unsigned int gc_uiOLUSEROPTION_NUM_COLS =         2;     
                                                
const unsigned int gc_uiOLUSEROPTION_BUTTON_SPACER =    35;     
const unsigned int gc_uiOLUSEROPTION_BUTTON_HEIGHT =    40;     
const unsigned int gc_uiOLUSEROPTION_BUTTON_WIDTH =     100;     
                                                
const unsigned int gc_uiOLUSEROPTION_TOPROW_Y1 =        135;     
const unsigned int gc_uiOLUSEROPTION_TOPROW_X1 =        (unsigned int)MENUBOX_TEXTAREA_X_CENTER - ( gc_uiOLUSEROPTION_BUTTON_SPACER / 2 ) - gc_uiOLUSEROPTION_BUTTON_WIDTH;
                                                
const float gc_fOLUSEROPTION_TEXT_YPOS =                24.0f;
                                                
const float gc_fOLUSEROPTION_LINE_WIDTH =               1.0f;     

const WCHAR gc_pwszOLUSEROPTION_COPY_TEXT[] =           L"Copy";
const WCHAR gc_pwszOLUSEROPTION_DELETE_TEXT[] =         L"Delete";

const unsigned int gc_uiOLUSEROPTION_NUM_TEXT_LINES =   5;

enum OLUSEROPTION_OPTIONS
{
    ENUM_OLUSEROPTION_NONE,
    ENUM_OLUSEROPTION_COPY,
    ENUM_OLUSEROPTION_DELETE
};

#include "menuscreen.h"  // Base menu type
#include "key.h"

class COLUserOptionMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    COLUserOptionMenu( CXItem* pParent );
    virtual ~COLUserOptionMenu();

    // Process drawing and input for a menu screen
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

    virtual HRESULT Init( char* menuFileName );                 // Initialize the Menu
    void SetText( WCHAR* pwszMessage );                         // Used to set the text message that will be displayed to the user

    unsigned int GetOption() { return m_uiSelectedOption; };    // Get the value of what the user selected
    BOOL GetCancelled() { return m_bCancelled; };               // Used to determine if the user cancelled the keyboard

protected:
    // Properties
    WCHAR   m_apwszTextMessage[gc_uiNUM_TEXT_LINES][MAX_PATH+1];	// Used to hold the text message
    BOOL    m_bCancelled;                                           // Used to determine if the user cancelled the menu
	int     m_xKeypos;                                              // Current X position on the Keyboard
    int     m_yKeypos;                                              // Current Y position on the Keyboard
	CKey    m_keyPad[gc_uiOLUSEROPTION_NUM_COLS][gc_uiOLUSEROPTION_NUM_ROWS];     // Each Key displayed on the Keyboard
    unsigned int m_uiSelectedOption;                                // Used to determine the option that the user selected
	
    // Private Methods
    void Leave( CXItem* pItem );                        // This will be called whenever this menu is entered / activated
	virtual void GenerateKeypad(void);                  // Create the keypad that will be used
	virtual BOOL renderKeypad( CUDTexture* pTexture );  // Draw the keypad on to the our texture
};

#endif // _OLUSEROPTIONMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\passcodemenu.cpp ===
/*****************************************************
*** passcodemenu.h
***
*** Header file for our Passcode Menu class.
***
*** by James N. Helm
*** February 13th, 2002
***
*****************************************************/

#include "stdafx.h"
#include "passcodemenu.h"

extern CSoundCollection g_Sounds;   // Used to generate all sounds for the XShell
extern USBManager Controllers;      // Used to determine what buttons / direction the user is pressing
extern BOOL g_bToggleIPInfo;        // Menu's can use this to turn off toggling of the IP Address info

// Constructors
CPassCodeMenu::CPassCodeMenu( CXItem* pParent ) :
m_usPassCodeIndex( 0 ),
CMenuScreen( pParent ),
m_bCancelled( FALSE ),
m_pButtonFont( NULL ),
m_bDisplayInvalidMsg( FALSE )
{
    ZeroMemory( &m_pbyPassCode, XONLINE_PIN_LENGTH );

    SetTitle( MENU_TITLE_PASSCODE );
}


// Destructor
CPassCodeMenu::~CPassCodeMenu()
{
    if( NULL != m_pButtonFont )
    {
        XFONT_Release( m_pButtonFont );
        m_pButtonFont = NULL;
    }
}


// Initialize the Menu
HRESULT CPassCodeMenu::Init( char* menuFileName )
{
    HRESULT hr = CMenuScreen::Init( menuFileName );
    if( FAILED( hr ) )
        XDBGWRN( APP_TITLE_NAME_A, "CPassCodeMenu::Init():Failed to initialize base class!!" );

    // Open the Button Font for this menu
    XFONT_OpenTrueTypeFont( FILE_DATA_BUTTON_FONT_FILENAME, 4096, &m_pButtonFont );

    if( NULL == m_pButtonFont )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CPassCodeMenu::CPassCodeMenu():Failed to open the Button Font!!" );
    }
    else
    {
        XFONT_SetTextColor( m_pButtonFont, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetBkColor( m_pButtonFont, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_pButtonFont, 30 );
        XFONT_SetTextAntialiasLevel( m_pButtonFont, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_pButtonFont, FONT_DEFAULT_STYLE );
    }

    return hr;
}


// Draws a menu on to the screen
void CPassCodeMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    // Draw our enter message
    float fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MENU_PASSCODE_ENTER_CODE_MSG ) / 2 );
    float fYPos = 24;
    pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", MENU_PASSCODE_ENTER_CODE_MSG );

    // Draw our invalid message if needed
    if( m_bDisplayInvalidMsg )
    {
        fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MENU_PASSCODE_INVALID_MSG ) / 2 );
        fYPos += m_uiFontHeightOfItem + ITEM_VERT_SPACING;
        pTexture->DrawText( fXPos, fYPos, COLOR_TVSAFE_RED, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", MENU_PASSCODE_INVALID_MSG );
    }

    // Draw our help text
    fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MENU_PASSCODE_HELP_TEXT1 ) / 2 );
    fYPos = 170;
    pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", MENU_PASSCODE_HELP_TEXT1 );
    
    // Draw boxes to surround our passcode
    float fBoxStartXPos = 60;
    float fBoxStartYPos = 90;
    float fBoxBuffer = 30;
    float fBoxWidth = 60;
    float fBoxHeight = 60;

    fXPos = fBoxStartXPos;
    fYPos = fBoxStartYPos;
    for( unsigned int x = 0; x < XONLINE_PIN_LENGTH; x++ )
    {
        pTexture->DrawOutline( fXPos, fYPos, fXPos + fBoxWidth, fYPos + fBoxHeight, 2, SCREEN_DEFAULT_TEXT_FG_COLOR );
        fXPos += fBoxWidth + fBoxBuffer;
    }


    // Draw our current passcode
    fXPos = fBoxStartXPos + 13;
    fYPos = fBoxStartYPos + 15;
    char cDisplayChar = 0;
    DWORD dwFGColor;
    for( unsigned int x = 0; x < XONLINE_PIN_LENGTH; x++ )
    {
        // If the code is 0, then the user has not yet entered a value for it
        if( 0 == m_pbyPassCode[x] )
            break;

        switch( m_pbyPassCode[x] )
        {
        case 1: // DPAD UP
            {
                dwFGColor = COLOR_DPAD_UP_BUTTON;
                cDisplayChar = 'Q';
                break;
            }
        case 2: // DPAD DOWN
            {
                dwFGColor = COLOR_DPAD_DOWN_BUTTON;
                cDisplayChar = 'M';
                break;
            }
        case 3: // DPAD LEFT
            {
                dwFGColor = COLOR_DPAD_LEFT_BUTTON;
                cDisplayChar = 'K';
                break;
            }
        case 4: // DPAD RIGHT
            {
                dwFGColor = COLOR_DPAD_RIGHT_BUTTON;
                cDisplayChar = 'O';
                break;
            }
        case 5: // X BUTTON
            {
                dwFGColor = COLOR_X_BUTTON;
                cDisplayChar = 'C';
                break;
            }
        case 6: // Y BUTTON
            {
                dwFGColor = COLOR_Y_BUTTON;
                cDisplayChar = 'D';
                break;
            }
        case 7: // BLACK BUTTON
            {
                dwFGColor = COLOR_BLACK_BUTTON;
                cDisplayChar = 'J';
                break;
            }
        case 8: // WHITE BUTTON
            {
                dwFGColor = COLOR_WHITE_BUTTON;
                cDisplayChar = 'I';
                break;
            }
        case 9: // LEFT TRIGGER BUTTON
            {
                dwFGColor = COLOR_L_BUTTON;
                cDisplayChar = 'E';
                break;
            }
        case 10: // RIGHT TRIGGER BUTTON
            {
                dwFGColor = COLOR_R_BUTTON;
                cDisplayChar = 'F';
                break;
            }
        }
        
        pTexture->DrawText( m_pButtonFont, fXPos, fYPos, dwFGColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%hc", cDisplayChar );
        fXPos += fBoxWidth + fBoxBuffer;
    }

    // Unlock our texture
    pTexture->Unlock();
}


// Handles input (of the CONTROLS) for the current menu
void CPassCodeMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !bFirstPress )
        return;

    m_bDisplayInvalidMsg = FALSE;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 1;
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 2;
            }

            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 3;
            }

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 4;
            }

            break;
        }
    case CONTROL_LEFT_THUMB:
        {
            UpdateTexture();

            m_usPassCodeIndex = 0;
            ZeroMemory( &m_pbyPassCode, XONLINE_PIN_LENGTH );

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CPassCodeMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !bFirstPress )
        return;

    m_bDisplayInvalidMsg = FALSE;

    // BUGBUG: Don't really have to do this for all buttons, but since so many of them trigger it
    // BUGBUG: We'll put this here
    UpdateTexture();

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            // Check to see if the user has entered in enough passcode digits
            if( ( m_usPassCodeIndex != XONLINE_PIN_LENGTH ) && ( 0 != m_usPassCodeIndex ) )
            {
                m_bDisplayInvalidMsg = TRUE;
                break;
            }

            if( GetParent() )   // Go Back one menu
                Leave( GetParent() );

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            if( GetParent() )   // Go Back one menu
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_X:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 5;
            }
            break;
        }
    case BUTTON_Y:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 6;
            }
            break;
        }
    case BUTTON_BLACK:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 7;
            }
            break;
        }
    case BUTTON_WHITE:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 8;
            }
            break;
        }
    case BUTTON_LEFT_TRIGGER:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 9;
            }
            break;
        }
    case BUTTON_RIGHT_TRIGGER:
        {
            if( m_usPassCodeIndex < XONLINE_PIN_LENGTH )
            {
                // Play the keyboard stroke sound
                g_Sounds.PlayKeyboardStrokeSound();

                m_pbyPassCode[m_usPassCodeIndex++] = 10;
            }
            break;
        }
    }
}


// This will be called when the user leaves this menu
void CPassCodeMenu::Leave( CXItem* pItem )
{
    CMenuScreen::Leave( pItem );

    // Turn on updating of the address texture
    g_bToggleIPInfo = TRUE;
}


// This will be called whenever this menu is entered / activated
void CPassCodeMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Make sure our cancelled option is set to FALSE
    m_bCancelled = FALSE;

    // Put the keyboard in it's original state
    m_bDisplayInvalidMsg = FALSE;
    m_usPassCodeIndex = 0;
    ZeroMemory( &m_pbyPassCode, XONLINE_PIN_LENGTH );

    // Turn off updating of the address texture
    g_bToggleIPInfo = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\screenitem.cpp ===
/*****************************************************
*** screenitem.cpp
***
*** CPP file for our abstract base class for a
*** generic screen item.
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#include "stdafx.h"
#include "screenitem.h"

// Constructor
CScreenItem::CScreenItem()
{
};

// Destructor
CScreenItem::~CScreenItem()
{ 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\onlinemenu.h ===
/*****************************************************
*** onlinemenu.h
***
*** Header file for our XShell Online menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** February 8th, 2002
***
*****************************************************/

#ifndef _ONLINEMENU_H_
#define _ONLINEMENU_H_

#include "menuscreen.h"
#include "xonlinefuncs.h"

// Sub menus
#include "olusermenu.h"
#include "oluseroptionmenu.h"
#include "passcodemenu.h"

enum OnlineUserEvents
{
    ENUM_ONLINE_NO_ACTION,
    ENUM_ONLINE_PING_START,
    ENUM_ONLINE_PING_IN_PROGRESS,
    ENUM_ONLINE_PING_COMPLETE,
    ENUM_ONLINE_GET_USERNAME,
    ENUM_ONLINE_GOT_INVALIDNAME,
    ENUM_ONLINE_GET_PASSCODE,
    ENUM_ONLINE_GENERATE_USER_START,
    ENUM_ONLINE_GENERATE_USER_IN_PROGRESS,
    ENUM_ONLINE_GENERATE_USER_COMPLETE,
    ENUM_ONLINE_MANAGE_GETMEMAREA,
    ENUM_ONLINE_MANAGE_NAVTOGETSOURCEMEMAREA,
    ENUM_ONLINE_MANAGE_NAVTOSOURCEMEMAREAUSERS,
    ENUM_ONLINE_MANAGE_GETUSERFROMHD,
    ENUM_ONLINE_MANAGE_GETUSEROPTION,
    ENUM_ONLINE_MANAGE_GETDESTMEMAREA,
    ENUM_ONLINE_MANAGE_OVERWRITE
};

class COnlineMenu : public CMenuScreen
{
public:
    COnlineMenu( CXItem* pParent );
    ~COnlineMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );
    void Enter();   // Will be called whenever the user enters this menu

    // Public Methods
    HRESULT Init( char* menuFileName );         // Initialize our font and settings

private:
    // Private Properties
    OnlineUserEvents m_UserEvent;               // Used to track the current user event
    HRESULT m_hrOnlineResult;                   // Used to track success or failure of an Online Task
    BOOL m_bDisableInput;                       // Used to disable input for the menu
    HRESULT m_hrPingResult;                     // Used to track the success or failure of a Partner Net Ping
    BOOL m_bPNetPinged;                         // Used to determine if we've attempted a ping to Partner Net
    HRESULT m_hrCreateResult;                   // Used to track the success or failure of creating a user
    BOOL m_bUserCreated;                        // Used to determine if we've attempted to create a user previously
    HANDLE m_hThreadHandle;                     // Handle to our worker thread
    unsigned int m_uiSourceMA;                  // Used to track the source memory area for a copy

    // Online Users
    XONLINE_USER  m_aOnlineUsers[XONLINE_MAX_STORED_ONLINE_USERS]; // Online users that will live on Memory Areas

    CPassCodeMenu       m_PassCodeMenu;         // Allows the user to set a PassCode
    COLUserMenu         m_OLUserMenu;           // Enumerates users on the hard drive
    COLUserOptionMenu   m_OLUserOptionMenu;     // Options for a user
    
    // Private Methods
    static DWORD WINAPI ProcessUserEvents( LPVOID lpParam );    // Handles User initiated events (runs in a separate thread)
    HRESULT CopyUserToMA( PXONLINE_USER pOnlineUser,            // Copies a user to the specified memory area
                          unsigned int uiMemArea );
    void CreateUserStart( WCHAR* pwszUserName );                // Used to start the Create User process
    BOOL NavToSourceMAUsers();                                  // Returns TRUE if it navigates to the Memory Area screen, FALSE if otherwise
};

#endif // _ONLINEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\passcodemenu.h ===
/*****************************************************
*** passcodemenu.h
***
*** Header file for our Passcode Menu class.
***
*** by James N. Helm
*** February 13th, 2002
***
*****************************************************/

#ifndef _PASSCODEMENU_H_
#define _PASSCODEMENU_H_

#include "menuscreen.h"  // Base menu type

class CPassCodeMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CPassCodeMenu( CXItem* pParent );
    virtual ~CPassCodeMenu();

    // Process drawing and input for a menu screen
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

    virtual HRESULT Init( char* menuFileName );             // Initialize the Menu

    BOOL GetCancelled() { return m_bCancelled; };           // Used to determine if the user cancelled the passcode menu
    BYTE* GetValue() { return m_pbyPassCode; };             // Return a pointer to the user entered passcode

protected:
    // Properties
    BYTE            m_pbyPassCode[XONLINE_PIN_LENGTH];
    unsigned short  m_usPassCodeIndex;                      // Used to track which character of the passcode we are working with
    BOOL            m_bCancelled;                           // Used to determine if the user cancelled the Pass Code Menu
    XFONT*          m_pButtonFont;                          // Font used to display button presses
    BOOL            m_bDisplayInvalidMsg;                   // Used to display the invalid passcode message

    // Methods
    void Leave( CXItem* pItem );                            // This will be called when the user leaves this menu
};

#endif // _PASSCODEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\screenitem.h ===
/*****************************************************
*** screenitem.h
***
*** Header file for our abstract base class for a
*** generic screen item.
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#ifndef _SCREENITEM_H_
#define _SCREENITEM_H_

class CScreenItem
{
public:
    // Constructors and Destructors
    CScreenItem();
    virtual ~CScreenItem();

    // Every screen item should know how to render itself
    virtual void Render( CUDTexture* pTexture ) = 0;

    virtual BOOL operator < ( const CScreenItem& item ) { return FALSE; };
    virtual BOOL operator > ( const CScreenItem& item ) { return FALSE; };
    virtual BOOL operator == ( const CScreenItem& item ) { return FALSE; };

protected:
};

#endif // _SCREENITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))
#define XFONT_TRUETYPE

#include <ntos.h>
#include <xapip.h>
#include <xtl.h>
#include <xfont.h>
#include <xdbg.h>
#include <stdio.h>
#include <xgmath.h>
#include <xbox.h>
#include <xboxp.h>
#include <xonlinep.h>
#include <dm.h>

// Libs
#include "usbmanager.h"
#include "xsettings.h"
#include "harddrive.h"
#include "memoryunit.h"
#include "linkedlist.h"
#include "bitmapfile.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "soundcollection.h"
#include "xitem.h"
#include "constants.h"
#include "genkeyboardmenu.h"
#include "messagemenu.h"
#include "madisplaymenu.h"
#include "yesnomenu.h"

// Forward declarations
HRESULT ProcessInput( void );
HRESULT SetupMenusAndItems( void );
void CheckMUs( void );
HRESULT CleanUp( void );
HRESULT InitDSound( void );
HRESULT InitD3D( UINT uiWidth,
                 UINT uiHeight,
                 DWORD dwFlags );
HRESULT Init3DObjects( void );
HRESULT Init( void );
unsigned int GetScreenWidth();      // Get the Width of the screen
unsigned int GetScreenHeight();     // Get the Height of the screen
void UpdateAddressTexture( CUDTexture* pTexture );
void UpdateTitleTexture( CUDTexture* pTexture );
void AlphaTexture( IDirect3DTexture8* pTexture,
                   DWORD dwColor );
void ProcessKeySequences();
DWORD WINAPI XGetLaunchInfoShell( OUT PDWORD pdwLaunchDataType,
                                  OUT PLD_LAUNCH_DASHBOARD pLaunchDashboard );
void DisplayMessage( WCHAR* pwszTitle,              // Used to display a generic message to the user
                     WCHAR* pwszFormat, ... );
void DisplayErrorMessage( WCHAR* pwszFormat, ... ); // Used to display a generic error message to the user
void DisplayYesNoMessage( WCHAR* pwszTitle,         // Used to display a generic YES/NO message to the user
                          WCHAR* pwszFormat, ... );
BOOL YesNoMenuCancelled();                          // Used to determine if the Yes/No menu was cancelled

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\SoundCollection.h ===
/*****************************************************
*** soundcollection.h
***
*** Header file for our Sound Collection class.
*** This class will contain all of the sounds for a
*** program, and allow them to be played
***
*** by James N. Helm
*** May 26th, 2001
***
*****************************************************/

#ifndef _SOUNDCOLLECTION_H_
#define _SOUNDCOLLECTION_H_

#include "wavemedia.h"

class CSoundCollection
{
public:
    // Constructors and Destructor
    CSoundCollection();
    ~CSoundCollection();

    // Public Properties
    
    // Public Methods
    HRESULT Init( LPDIRECTSOUND pDSound );      // Initialize our sounds
    BOOL IsSoundPlaying( DWORD dwSoundId );     // Returns TRUE if a sound is currently playing
    void PlaySound( DWORD dwSoundId );          // Allows the user to specify the Sound ID of the sound to be played
    void PlaySelectSound();                     // Plays the Select Button Sound
    void PlayBackSound();                       // Plays the Back Button Sound
    void PlayMenuItemSelectSound();             // Plays the Menu Item Select Sound
    void PlayKeyboardStrokeSound();             // Plays the Keyboard Stroke Sound
    void CleanUpSounds();                       // Used to clean up the sounds

private:
    // Private Properties
    CWaveMedia* m_pSoundArray;                  // Array of sounds to be used in the program

    // Private Methods
};

#endif // _SOUNDCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\soundcollection.cpp ===
/*****************************************************
*** soundcollection.cpp
***
*** CPP file for our Sound Collection class.
*** This class will contain all of the sounds for a
*** program, and allow them to be played
***
*** by James N. Helm
*** May 26th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "soundcollection.h"

extern CXSettings   g_XboxSettings; // Settings that are stored on the Xbox

// Constructor
CSoundCollection::CSoundCollection()
: m_pSoundArray( NULL )
{
    m_pSoundArray = new CWaveMedia[ENUM_SOUND_NUM_SOUNDS];   // Array of sounds to be used in the program
    if( NULL == m_pSoundArray )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSoundCollection::CSoundCollection():Failed to allocate memory!!" );
    }
}


// Destructor
CSoundCollection::~CSoundCollection()
{
    CleanUpSounds();
}


// Used to clean up the sounds
void CSoundCollection::CleanUpSounds()
{
    if( NULL != m_pSoundArray )
    {
        delete[] m_pSoundArray;
        m_pSoundArray = NULL;
    }
}


// Initialize our sounds
HRESULT CSoundCollection::Init( LPDIRECTSOUND pDSound )
{
    HRESULT hr = S_OK;

    // Initialize and load our sounds
    if( !m_pSoundArray[ENUM_SOUND_SELECT].Init( pDSound, SOUND_SELECT_BUTTON ) )
    {
        hr = E_FAIL;
    }

    if( !m_pSoundArray[ENUM_SOUND_BACK].Init( pDSound, SOUND_BACK_BUTTON ) )
    {
        hr = E_FAIL;
    }

    if( !m_pSoundArray[ENUM_SOUND_MENU_ITEM_SELECT].Init( pDSound, SOUND_MENU_ITEM_SELECT ) )
    {
        hr = E_FAIL;
    }

    if( !m_pSoundArray[ENUM_SOUND_KEYBOARD_STROKE].Init( pDSound, SOUND_KEYBOARD_STROKE ) )
    {
        hr = E_FAIL;
    }

    // Adjust the volume of all sounds
    for( unsigned int x = 0; x < ENUM_SOUND_NUM_SOUNDS; x++ )
    {
        m_pSoundArray[x].SetVolume( SOUND_VOLUME_ADJUST );
    }

    return hr;
}


// Returns TRUE if a sound is currently playing
BOOL CSoundCollection::IsSoundPlaying( DWORD dwSoundId )
{
    if( dwSoundId >= ENUM_SOUND_NUM_SOUNDS )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSoundCollection::IsSoundPlaying():SoundId is out of range!!" );

        return FALSE;
    }

    return m_pSoundArray[dwSoundId].IsPlaying();
}


// Allows the user to specify the Sound ID of the sound to be played
void CSoundCollection::PlaySound( DWORD dwSoundId )
{
    if( dwSoundId >= ENUM_SOUND_NUM_SOUNDS )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSoundCollection::PlaySound():SoundId is out of range!!" );

        return;
    }

    m_pSoundArray[dwSoundId].Play();
}


// Plays the Select Button Sound
void CSoundCollection::PlaySelectSound()
{
    m_pSoundArray[ENUM_SOUND_SELECT].Play();
}


// Plays the Back Button Sound
void CSoundCollection::PlayBackSound()
{
    m_pSoundArray[ENUM_SOUND_BACK].Play();
}


// Plays the Menu Item Select Sound
void CSoundCollection::PlayMenuItemSelectSound()
{
    m_pSoundArray[ENUM_SOUND_MENU_ITEM_SELECT].Play();
}


// Plays the Keyboard Stroke Sound
void CSoundCollection::PlayKeyboardStrokeSound()
{
    m_pSoundArray[ENUM_SOUND_KEYBOARD_STROKE].Play();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\subnetmenu.h ===
/*****************************************************
*** subnetmenu.h
***
*** Header file for our XShell subnet mask menu class.
***
*** by Victor Blanco
*** December 2nd, 2000
***
*****************************************************/

#ifndef _SUBNETMENU_H_
#define _SUBNETMENU_H_

#include "keypadmenu.h"

class CSubnetMenu : public CKeypadMenu
{
public:
    // Constructors and Destructors
    CSubnetMenu( CXItem* pParent );
    ~CSubnetMenu();

    // Public Members
    void Enter();                           // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );    // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );

    // Public Methods

private:
};

#endif // _SUBNETMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\subnetmenu.cpp ===
/*****************************************************
*** subnetmenu.cpp
***
*** CPP file for our XShell subnet mask menu class.
***
*** by Victor Blanco
*** December 2nd, 2000
***
*****************************************************/

#include "stdafx.h"
#include "subnetmenu.h"

extern CXSettings       g_XboxSettings;     // Settings that are stored on the Xbox
extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructors
CSubnetMenu::CSubnetMenu( CXItem* pParent )
: CKeypadMenu( pParent )
{
    // Use DHCP should be disabled
    m_keyPad[3][3].setRender(FALSE);

    SetTitle( MENU_TITLE_SUBNET );
}


// Destructor
CSubnetMenu::~CSubnetMenu()
{
}


// Draws a menu on to the screen
void CSubnetMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Let our base menu draw the items from the data file
    CKeypadMenu::Action( pTexture );

    pTexture->Lock();

    // Draw the Subnet Header Information
    float fXPos= MENUBOX_TEXTAREA_X_CENTER - GetStringPixelWidth( SUBNETMENU_HEADER_TEXT );
    float fYPos = 24.0;

    pTexture->DrawText( fXPos, fYPos, COLOR_MEDIUM_GREEN, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", SUBNETMENU_HEADER_TEXT );

    pTexture->Unlock();
}


// Handles input (of the BUTTONS) for the current menu
void CSubnetMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Deal with keyboard input
            if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"" ) )            //backspace
            {
                int len = wcslen( m_pwszAddress );

                if(len > 0)
                {
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

                    len = len - 1;
                    m_pwszAddress[len] = L'\0';
                }
            }
            else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"ok" ) )      //ok
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                if( FAILED( g_XboxSettings.SetSubnetMask( m_pwszAddress ) ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CSubnetMenu::HandleInput():Failed to store the settings!!" );
                }

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
            }
            else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].resultChar, L"cancel" ) )  //cancel
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
            }
            else
            {
                // Ensure we don't exceed the limit of an Subnet Mask
                if( wcslen( m_pwszAddress ) < DATAVALUE_IPADDRESS_LENGTH )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the keyboard stroke sound
                    g_Sounds.PlayKeyboardStrokeSound();

                    wcscat( m_pwszAddress, m_keyPad[m_xKeypos][m_yKeypos].resultChar );
                }
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
			int len = wcslen( m_pwszAddress );

			if(len > 0)
			{
				m_bUpdateTexture = TRUE;

				// Play the keyboard stroke sound
				g_Sounds.PlayKeyboardStrokeSound();

				len = len - 1;
				m_pwszAddress[len] = L'\0';
			}
			break;
		}
    }
}


// This will be called whenever the user enters this menu
void CSubnetMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Make sure we don't process the first keypres and set our item to 0
    m_bDropKeyPress = TRUE;
    m_xKeypos = m_yKeypos = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\screenitems.cpp ===
/*****************************************************
*** screenitems.cpp
***
*** CPP file for our screen item classes.
*** This file will contain the definition for all
*** types of screen items
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#include "stdafx.h"
#include "screenitems.h"

extern IDirect3DDevice8* g_pD3DDevice;  // Pointer to our Direct3D Device Object


/*****************************************************
/* CTextItem()
/****************************************************/

// Constructor
CTextItem::CTextItem() :
CScreenItem(),
m_pwszText( NULL ),
m_fXPos( 0.0f ),
m_fYPos( 0.0f ),
m_dwFGColor( 0L ),
m_dwBGColor( 0L )
{
}

// Destructor
CTextItem::~CTextItem()
{
    // Clean up our allocated memory
    if( m_pwszText )
    {
        delete[] m_pwszText;
        m_pwszText = NULL;
    }
}

// Allows the user to update the information for the Text Item
void CTextItem::UpdateItem( WCHAR* pwszText, float fXPos, float fYPos, DWORD dwFGColor, DWORD dwBGColor )
{
    // Ensure we were passed a valid pointer
    if( !pwszText )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CTextItem()::UpdateItem():pwszText was invalid!!" );

        return;
    }

    // If we have already set a text item, lets clear the memory so we can allocate new memory
    if( m_pwszText )
    {
        delete[] m_pwszText;
        m_pwszText = NULL;
    }

    // Create new memory and copy the string that was passed in by the user
    int iStrLen = wcslen( pwszText );
    m_pwszText = new WCHAR[iStrLen + 1];
    if( !m_pwszText )
    {
        // Check to see if we could allocate memory -- If not, assert!!
        XDBGERR( APP_TITLE_NAME_A, "CTextItem()::UpdateItem():Couldn't allocate memory!!" );
    }
    else
    {
        ZeroMemory( m_pwszText, sizeof( WCHAR ) * (iStrLen + 1) );
        wcscpy( m_pwszText, pwszText );
    }
   
    // Set our other parameters
    m_fXPos = fXPos;
    m_fYPos = fYPos;
    m_dwFGColor = dwFGColor;
    m_dwBGColor = dwBGColor;
}


// Used to render itself to the screen
void CTextItem::Render( CUDTexture* pTexture )
{
    pTexture->DrawText( m_fXPos, m_fYPos, m_dwFGColor, m_dwBGColor, L"%s", m_pwszText );
}

/*****************************************************
/* CPanelItem()
/****************************************************/

// Constructor
CPanelItem::CPanelItem() :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
CPanelItem::~CPanelItem()
{
}

// Allows the user to update the information for the Panel Item
void CPanelItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void CPanelItem::Render( CUDTexture* pTexture )
{
    pTexture->DrawBox( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_dwColor );
}


/*****************************************************
/* CLineItem()
/****************************************************/
// Constructor
CLineItem::CLineItem() :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_fWidth( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
CLineItem::~CLineItem()
{
}

// Allows the user to update the information for the Outline Item
void CLineItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_fWidth = fWidth;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void CLineItem::Render( CUDTexture* pTexture )
{
    pTexture->DrawLine( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_fWidth, m_dwColor );
}


/*****************************************************
/* COutlineItem()
/****************************************************/
// Constructor
COutlineItem::COutlineItem() :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_fWidth( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
COutlineItem::~COutlineItem()
{
}

// Allows the user to update the information for the Outline Item
void COutlineItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_fWidth = fWidth;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void COutlineItem::Render( CUDTexture* pTexture )
{
    pTexture->DrawOutline( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_fWidth, m_dwColor );
}


/*****************************************************
/* CBitmapItem()
/****************************************************/
// Constructor
CBitmapItem::CBitmapItem() :
CScreenItem(),
m_pszFilename( NULL ),
m_nXPos( 0 ),
m_nYPos( 0 )
{
}

// Destructor
CBitmapItem::~CBitmapItem()
{
    // Clean up our memory
    if( m_pszFilename )
    {
        delete[] m_pszFilename;
        m_pszFilename = NULL;
    }
}

// Allows the user to update the information for the Outline Item
void CBitmapItem::UpdateItem( char* pszFilename, int nXPos, int nYPos )
{
    // Ensure we were passed a valid pointer
    if( !pszFilename )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CBitmapItem()::UpdateItem():pszFilename was invalid!!" );

        return;
    }

    // If we have already set a text item, lets clear the memory so we can allocate new memory
    if( m_pszFilename )
    {
        delete[] m_pszFilename;
        m_pszFilename = NULL;
    }

    // Create new memory and copy the string that was passed in by the user
    int iStrLen = strlen( pszFilename );
    m_pszFilename = new char[iStrLen + 1];
    if( !m_pszFilename )
    {
        // Check to see if we could allocate memory -- If not, assert!!
        XDBGERR( APP_TITLE_NAME_A, "CBitmapItem()::UpdateItem():Couldn't allocate memory!!" );

        return;
    }
    else
    {
        ZeroMemory( m_pszFilename, iStrLen + 1 );
        strcpy( m_pszFilename, pszFilename );
    }

    m_nXPos = nXPos;
    m_nYPos = nYPos;

    m_Bitmap.read( m_nXPos, m_nYPos, m_pszFilename );
}

// Used to render itself to the screen
void CBitmapItem::Render( CUDTexture* pTexture )
{
    m_Bitmap.render( g_pD3DDevice, pTexture->GetTextureSurface() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\screenitems.h ===
/*****************************************************
*** screenitems.h
***
*** Header file for our screen item classes.
*** This file will contain the definition for all
*** types of screen items
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#ifndef _SCREENITEMS_H_
#define _SCREENITEMS_H_

#include "screenitem.h"

/*****************************************************
/* CTextItem()
/****************************************************/
class CTextItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CTextItem();
    ~CTextItem();

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( WCHAR* pwszText, float fXPos, float fYPos, DWORD dwFGColor, DWORD dwBGColor );

private:
    WCHAR* m_pwszText;
    float m_fXPos;
    float m_fYPos;
    DWORD m_dwFGColor;
    DWORD m_dwBGColor;
};


/*****************************************************
/* CPanelItem()
/****************************************************/
class CPanelItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CPanelItem();
    ~CPanelItem();

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        DWORD m_dwColor;
};


/*****************************************************
/* CLineItem()
/****************************************************/
class CLineItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CLineItem();
    ~CLineItem();

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        float m_fWidth;
        DWORD m_dwColor;
};


/*****************************************************
/* COutlineItem()
/****************************************************/
class COutlineItem : public CScreenItem
{
public:
    // Constructors and Destructors
    COutlineItem();
    ~COutlineItem();

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        float m_fWidth;
        DWORD m_dwColor;
};


/*****************************************************
/* CBitmapItem()
/****************************************************/
class CBitmapItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CBitmapItem();
    ~CBitmapItem();

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( char* pszFilename, int nXPos, int nYPos );

private:
    BitmapFile m_Bitmap;

    char* m_pszFilename;
    int m_nXPos;
    int m_nYPos;
};

#endif //_SCREENITEMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\sysinfomenu.h ===
/*****************************************************
*** sysinfomenu.h
***
*** Header file for our XShell System Information menu 
*** class.  This menu will display system information
*** and allow the user to scroll through this list.
***
*** by James N. Helm
*** August 7th, 2001
***
*****************************************************/

#ifndef _SYSINFOMENU_H_
#define _SYSINFOMENU_H_

#include "menuscreen.h"
#include "ntddscsi.h"

class CSysInfoMenu : public CMenuScreen
{
public:
    CSysInfoMenu( CXItem* pParent );
    ~CSysInfoMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );     // Initialize our font and settings
    void    Leave( CXItem* pItem );         // Should be called whenever a user deactivates this item
private:
    // Private Properties
    unsigned int    m_uiTopItemIndex;                           // Index of the top item being displayed
    WCHAR*          m_pawszMenuItems[SYSINFOMENU_NUM_ITEMS];    // Used to hold our displayed menu items
    BOOL            m_bDropKeyPress;                            // Used to prevent the 'instant' keypress when a user navigates in here

    DWORD           m_dwTickCount;                              // Used to update our texture every second

    // Private Methods
    void AdjustDisplayArrows();         // Adjust the UP and DOWN arrows on the screen
};

#endif // _SYSINFOMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\timezonemenu.h ===
/*****************************************************
*** timezonemenu.h
***
*** Header file for our XShell Time Zone menu 
*** class.  This is a standard menu contains a list
*** of menu items to be selected.
***
*** by James N. Helm
*** June 26th, 2001
***
*****************************************************/

#ifndef _TIMEZONEMENU_H_
#define _TIMEZONEMENU_H_

#include "menuscreen.h"

class CTimeZoneMenu : public CMenuScreen
{
public:
    CTimeZoneMenu( CXItem* pParent );
    ~CTimeZoneMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );     // Initialize our font and settings
    void    Leave( CXItem* pItem );         // Should be called whenever a user deactivates this item
private:
    // Private Properties
    unsigned int    m_uiTopItemIndex;   // Index of the top item being displayed

    // Private Methods
    void AdjustDisplayArrows();                     // Adjust the UP and DOWN arrows on the screen
};

#define TIMEZONEMENU_FONT_HEIGHT            17
#define TIMEZONEMENU_NUM_ITEMS_TO_DISPLAY   8
#define TIMEZONEMENU_FILENAME_A             FILE_DATA_MENU_DIRECTORY_A "\\timezone.mnu"

#endif // _TIMEZONEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\sysinfomenu.cpp ===
/*****************************************************
*** sysinfomenu.cpp
***
*** CPP file for our XShell System Information menu 
*** class.  This menu will display system information
*** and allow the user to scroll through this list.
***
*** by James N. Helm
*** August 7th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "sysinfomenu.h"

extern XFONT* g_pFont;

extern "C"
{
    DECLSPEC_IMPORT
    void
    WINAPI
    HalReadWritePCISpace(
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG RegisterNumber,
        IN PVOID Buffer,
        IN ULONG Length,
        IN BOOLEAN WritePCISpace
        );
    #define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
        HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );

    DECLSPEC_IMPORT
    void*
    WINAPI
    MmMapIoSpace(
        IN ULONG_PTR PhysicalAddress,
        IN SIZE_T NumberOfBytes,
        IN ULONG Protect
        );

    DECLSPEC_IMPORT
    void
    WINAPI
    MmUnmapIoSpace(
        IN PVOID BaseAddress,
        IN SIZE_T NumberOfBytes
        );
}

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

FORCEINLINE ULONG
REG_RD32(VOID* Ptr, ULONG Addr)
{
    return *((volatile DWORD*)((BYTE*)(Ptr) + (Addr)));
}


//////////////////////////////////////////////////////
//// Functions / Structures to access machine settings
//////////////////////////////////////////////////////
static DWORD WriteSMC(unsigned char addr, unsigned char value)
{
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
}

static DWORD ReadSMC(unsigned char addr)
{
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
}

static const char * const vmodes[] =
{
    "SDTV%20SCART%20Analog/Digital",
    "HDTV",
    "VGA",
    "RFU",
    "SDTV%20Analog/Digital",
    "Power%20Off",
    "SDTV%20Analog",
    "No%20Pack",
    "SMC%20Error"
};

static const char * const hwversions[] =
{
    "Unknown",
    "DVT3", 
    "DVT3",
    "DVT4/5"
};

static const char * const lang[] = 
{
    "Unknown",
    "English",
    "Japanese",
    "German",
    "French",
    "Spanish",
    "Italian"
};

static const char * const videostd[] =
{
    "Unknown",
    "NTSC_M",
    "NTSC_J",
    "PAL_I"
};

char* GetHWVersion(unsigned &hwver)
{
    // #define PAGE_SIZE                   4096
    #define ROM_SIZE                    (1024 * 1024)
    #define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
    #define ROM_VERSION_BYTE_OFFSET     0x78
    #define FLASH_BASE_ADDRESS          0xFFF00000
    #define FLASH_REGION_SIZE           (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

    LPBYTE RomBase = (LPBYTE)MmMapIoSpace(FLASH_BASE_ADDRESS, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE);

    if(RomBase == NULL) return (char*)hwversions[0];

    hwver = RomBase[ROM_VERSION_BYTE_OFFSET];

    MmUnmapIoSpace(RomBase, PAGE_SIZE);

    //
    // Init table version < 0x40: Old DVT 3 Boxes with NV2A A02 old metal 7 (NVCLK 155, CPU 665)
    // Init table version = 0x40: New DVT 3 Boxes with NV2A A02 new metal 7 (Faster)
    // Init table version >= 0x46: DVT4
    //
    //DebugPrint("hwver: 0x%X\n", hwver);

    if(hwver < 0x40) return (char*)hwversions[1];
    if(hwver == 0x40) return (char*)hwversions[2];
    if(hwver >= 0x46) return (char*)hwversions[3];
    return (char*)hwversions[0];
}


void DumpClocks(char *buffer, unsigned hwver)
{
    #define NV_PRAMDAC_NVPLL_COEFF 0x00680500 /* RW-4R */
    const float F_XTAL_135 = 13.5f;
    const float F_XTAL_166 = 16.6667f;

    PCI_SLOT_NUMBER SlotNumber;
    DWORD MPLLCoeff;
    DWORD m;
    DWORD n;
    DWORD p;
    DWORD fsbspeed;
    DWORD vcofreq;
    DWORD nvclk;
    DWORD nvpll;
    DWORD fsb_pdiv;
    DWORD mem_pdiv;
    DWORD mclk;
    DWORD cpuspeed;
    float XTAL;

    if(hwver >= 0x46) 
    {
        XTAL = F_XTAL_166;
    }
    else
    {
        XTAL = F_XTAL_135;
    }

    //
    // Read CR_CPU_MPLL_COEFF 
    //
    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = 0;
    SlotNumber.u.bits.FunctionNumber = 3;
    HalReadPCISpace(0, SlotNumber.u.AsULONG, 0x6C, &MPLLCoeff, sizeof(MPLLCoeff));

    m = MPLLCoeff & 0xFF;
    n = (MPLLCoeff >> 8) & 0xFF;

    if(m != 0)
    {
        //
        // Calculate cpu frequency
        //
        fsbspeed = (DWORD)((XTAL / m) * n);

        cpuspeed = (DWORD)((XTAL / m) * n * 11 / 2);
    
        //
        // Calculate nvclk
        //
        nvpll = REG_RD32((void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PRAMDAC_NVPLL_COEFF);
        m = nvpll & 0xFF;
        n = (nvpll >> 8)  & 0xFF;
        p = (nvpll >> 16) & 0xFF;
    
        nvclk = (m != 0) ? (DWORD)((n * XTAL / (1 << p) / m)) : 0;
    
        //
        // Calculate vco
        //
        m = MPLLCoeff & 0xFF;
        n = (MPLLCoeff >> 8) & 0xFF;
        fsb_pdiv = (MPLLCoeff >> 16) & 0xF;
        
        vcofreq = (DWORD)((XTAL / m) * (fsb_pdiv * 2 * n));
    
        //
        // Calculate mclk
        //
        mem_pdiv = (MPLLCoeff >> 20) & 0xF;
        mclk = (DWORD)(vcofreq / (2 * mem_pdiv));

        sprintf(buffer, "Crystal:%s, FSB:%d, CPU:%d, NVCLK:%d, VCO:%d, MCLK:%d",
            (hwver >= 0x46) ? "16.6" : "13.5", fsbspeed, cpuspeed, nvclk, vcofreq, mclk);
    }
    else
    {
        sprintf(buffer, "unknown");
    }
}


void GetDriveID(char* device, char* model, char* serial, char* firmware)
{
    unsigned i;
    DWORD returned;
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;


    RtlInitObjectString(&VolumeString, device);
    InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    status = NtCreateFile(&fileHandle,
                            SYNCHRONIZE|GENERIC_READ,
                            &ObjA,
                            &IoStatusBlock,
                            0,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ, FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_NONALERT);

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(strstr(device, "CdRom") != NULL) atapt->IdeReg.bCommandReg = 0xa1;
    else atapt->IdeReg.bCommandReg = 0xec;

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             FALSE);
    NtClose(fileHandle);

    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for ( i=0; i<sizeof(IdData->ModelNumber); i+=2 )
    {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
    }
    model[i] = 0;
    //DebugPrint("Model Number: %s\n", model);

    for ( i=0; i<sizeof(IdData->SerialNumber); i+=2 )
    {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
    }
    
    serial[i] = 0;
    //DebugPrint("Serial Number: %s\n", serial);

    for ( i=0; i<sizeof(IdData->FirmwareRevision); i+=2 )
    {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
    }
    
    firmware[i] = 0;
    //DebugPrint("Firmware Revision: %s\n", firmware);
}


// Trim spaces from the right side of a string
void RTrimString( char* pszString )
{
    // Trim spaces from the end of the string
    for( unsigned int x = strlen( pszString ) - 1; x >= 0; x-- )
    {
        if( pszString[x] != ' ' )
        {
            break;
        }
        else
        {
            pszString[x] = '\0';
        }
    }
}

void GetPeripheral(char *buffer);

//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////

extern CXSettings           g_XboxSettings;         // Settings that are stored on the Xbox
extern CSoundCollection     g_Sounds;               // Used to generate all sounds for the XShell
extern BOOL                 g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
extern BOOL                 g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow

// Constructors
CSysInfoMenu::CSysInfoMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_uiTopItemIndex( 0 ),
m_bDropKeyPress( TRUE )
{
    XDBGTRC( APP_TITLE_NAME_A, "CSysInfoMenu::CSysInfoMenu(ex)" );

    m_uiNumItems = SYSINFOMENU_NUM_ITEMS;
    SetSelectedItem( 0 );

    for( unsigned int x = 0; x < SYSINFOMENU_NUM_ITEMS; x++ )
    {
        m_pawszMenuItems[x] = new WCHAR[MAX_PATH+1];
        ZeroMemory( m_pawszMenuItems[x], sizeof( WCHAR ) * MAX_PATH+1 );
    }

    SetTitle( MENU_TITLE_SYSINFO );

    m_dwTickCount = GetTickCount();
}


// Destructor
CSysInfoMenu::~CSysInfoMenu()
{
    // Clean up memory
    for( unsigned int x = 0; x < SYSINFOMENU_NUM_ITEMS; x++ )
    {
        if( m_pawszMenuItems[x] )
        {
            delete[] m_pawszMenuItems[x];
            m_pawszMenuItems[x] = NULL;
        }
    }    
}


// Draws a menu on to the screen
void CSysInfoMenu::Action( CUDTexture* pTexture )
{
    g_XboxSettings.LoadSettings();
    if( g_XboxSettings.SettingsHaveChanged() )
    {
        m_bUpdateTexture = TRUE;
    }

    // Make sure our texture updates once a second
    if( GetTickCount() > ( m_dwTickCount + 1000 ) )
    {
        m_dwTickCount = GetTickCount();

        m_bUpdateTexture = TRUE;
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_OPTIONMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_OPTIONMENU_FONT_HEIGHT;

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    //
    // Populate our Menu Item WCHAR array
    //
    unsigned int uiIndex = 0;
    UCHAR pszOutBuffer[MAX_PATH+1];
    UCHAR pszBuffer[MAX_PATH+1];
    WCHAR pwszBuffer[MAX_PATH+1];

    //
    // Hardware Version Info
    //
    unsigned uiBaseInitTable = 0;
    char* pszHWVersion;
    char pszSMCVersion[4];

    // SMC Version
    pszSMCVersion[0] = (char)ReadSMC(0x01);
    pszSMCVersion[1] = (char)ReadSMC(0x01);
    pszSMCVersion[2] = (char)ReadSMC(0x01);
    pszSMCVersion[3] = '\0';


    pszHWVersion = GetHWVersion( uiBaseInitTable );

    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Hardware Version Information:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   %hs %hs,  SMC:%hs,  GPU:%X,  MCP:%X", pszHWVersion, (XboxHardwareInfo->Flags&XBOX_HW_FLAG_DEVKIT_KERNEL)?"DEVKIT":"RETAIL", pszSMCVersion, XboxHardwareInfo->GpuRevision, XboxHardwareInfo->McpRevision );


    //
    // Clock Speeds
    //
    char pszClocks[255];
    pszClocks[0] = '\0';

    DumpClocks( pszClocks, uiBaseInitTable );

    // Clock Speeds 1
    char pszClocks1[255];
    ZeroMemory( pszClocks1, 255 );
    char* pszClocks2 = NULL;

    pszClocks2 = strstr( pszClocks, "NVCLK" );  // REVIEW: Should we care about checking for this error case?
    if( NULL == pszClocks2 )
    {
        XDBGERR( APP_TITLE_NAME_A, "CSysInfoMenu::Action():Failed to find our expected string!!" );
    }
    strncpy( pszClocks1, pszClocks, pszClocks2 - pszClocks - 2 );

    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Clock Speeds 1:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   %hs", pszClocks1 );

    // Clock Speeds 2
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Clock Speeds 2:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   %hs", pszClocks2 );


    //
    // Disk Manufacturers
    //
    char cdModel[64], cdSerial[64], cdFirmware[64];
    char hdModel[64], hdSerial[64], hdFirmware[64];
    
    cdModel[0] = '\0';
    cdSerial[0] = '\0';
    cdFirmware[0] = '\0';
    hdModel[0] = '\0';
    hdSerial[0] = '\0';
    hdFirmware[0] = '\0';

    GetDriveID( "\\Device\\CdRom0", cdModel, cdSerial, cdFirmware );
    GetDriveID( "\\Device\\Harddisk0\\Partition0", hdModel, hdSerial, hdFirmware );

    RTrimString( cdModel );
    RTrimString( cdFirmware );
    RTrimString( hdModel );
    RTrimString( hdFirmware );

    // DVD Drive
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"DVD Drive:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   %hs (%hs)", cdModel, cdFirmware );

    // Hard Drive
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Hard Drive:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   %hs (%hs)", hdModel, hdFirmware );


    //
    // Memory Type
    //
    #define NV_PEXTDEV_BOOT_0                   0x00101000 // private\windows\directx\dxg\d3d8\se\nv_ref_2a.h
    #define XPCICFG_GPU_MEMORY_REGISTER_BASE_0  0xFD000000 // private\ntos\inc\xpcicfg.h

    // Get the total amount of memory available
    MEMORYSTATUS memStatus;
    ZeroMemory( &memStatus, sizeof( memStatus ) );

    GlobalMemoryStatus( &memStatus );

    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"Memory Type:" );

    if( ( REG_RD32( (void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PEXTDEV_BOOT_0 ) & 0x0000C0000 ) == 0 )
        _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   %dMB (Micron)", memStatus.dwTotalPhys / ( 1024 * 1024 ) );
    else
        _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   %dMB (Samsung)", memStatus.dwTotalPhys / ( 1024 * 1024 ) );


    //
    // SMC Information
    //
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"SMC Information:" );
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   CPUTemp:%d,  AIRTemp:%d,  Fan:%d,  Error:%d",  ReadSMC(0x09), ReadSMC(0x0A), ReadSMC(0x10), ReadSMC(0x0F) );


    //
    // USB Hub Information
    //
    _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"USB Hub Installed:" );
    
    if( XboxHardwareInfo->Flags & XBOX_HW_FLAG_INTERNAL_USB_HUB )
    {
        _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   Yes" );
    }
    else
    {
        _snwprintf( m_pawszMenuItems[uiIndex++], MAX_PATH, L"   No" );
    }

    ASSERT( SYSINFOMENU_NUM_ITEMS == uiIndex );

    //
    // Draw our Menu Items
    //

    for( unsigned int x = m_uiTopItemIndex; x < ( SYSINFOMENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); x++ )
    {
        // Make sure we don't try to draw too many items
        if( x == GetNumItems() )
        {
            break;
        }

        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

        DWORD dwColor;
        if( ( x % 2 ) == 0 )
        {
            dwColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
        }
        else
        {
            dwColor = COLOR_DARK_GREEN2;
        }

        pTexture->DrawText( XPos, YPos, dwColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_pawszMenuItems[x] );
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CSysInfoMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CSysInfoMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if( m_bDropKeyPress )
    {
        m_bDropKeyPress = FALSE;

        return;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( m_uiTopItemIndex != 0 )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                m_uiTopItemIndex -= SYSINFOMENU_NUM_ITEMS_TO_DISPLAY;

                AdjustDisplayArrows();
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( m_uiTopItemIndex < ( GetNumItems() - SYSINFOMENU_NUM_ITEMS_TO_DISPLAY ) )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                m_uiTopItemIndex += SYSINFOMENU_NUM_ITEMS_TO_DISPLAY;

                AdjustDisplayArrows();
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CSysInfoMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, or input is disabled, let's bail
    if( ( !bFirstPress ) || ( m_bDropKeyPress ) )
    {
        m_bDropKeyPress = FALSE;

        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT CSysInfoMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CSysInfoMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    return hr;
}


// Should be called whenever a user leaves the menu
void CSysInfoMenu::Leave( CXItem* pItem )
{
    // Call our base class Leave
    CMenuScreen::Leave( pItem );

    g_bDisplayUpArrow = FALSE;
    g_bDisplayDownArrow = FALSE;
}


// This will be called whenever the user enters this menu
void CSysInfoMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Set our selected item to the top of the menu
    // SetSelectedItem( 0 );

    // Make sure the proper arrows are displayed
    AdjustDisplayArrows();

    // Make sure we don't process the first keypress, and set our menu item back to 0
    m_bDropKeyPress = TRUE;
}


// Adjust the UP and DOWN arrows on the screen
void CSysInfoMenu::AdjustDisplayArrows()
{
    // Decide if we need to turn on the Up Arrow
    if( 0 == m_uiTopItemIndex )
    //
    // We can turn off the Up Arrow, because there is nothing above us
    //
    {
        g_bDisplayUpArrow = FALSE;
    }
    else
    //
    // We have to turn on the Up Arrow, because a menu choice is above us
    //
    {
        g_bDisplayUpArrow = TRUE;
    }

    // Decide if we need to turn on the Down Arrow
    if( SYSINFOMENU_NUM_ITEMS > ( m_uiTopItemIndex + SYSINFOMENU_NUM_ITEMS_TO_DISPLAY ) )
    //
    // We have to turn on the Down Arrow, because there are menu choices below us
    //
    {
        g_bDisplayDownArrow = TRUE;
    }
    else
    //
    // We can turn off the Down arrow, because nothing is below us
    //
    {
        g_bDisplayDownArrow = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\videoresmenu.h ===
/*****************************************************
*** videoresmenu.h
***
*** Header file for our XShell Video Resolution menu 
*** class.  This menu will allow the user to select
*** different screen resolutions and run the
*** XDK Launcher in that resolution
***
*** by James N. Helm
*** June 9th, 2001
***
*****************************************************/

#ifndef _VIDEORESMENU_H_
#define _VIDEORESMENU_H_

#include "menuscreen.h"

// Sub-Menus

class CVideoResMenu : public CMenuScreen
{
public:
    CVideoResMenu( CXItem* pParent );
    ~CVideoResMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( char* menuFileName );                 // Initialize our font and settings

private:
    typedef struct _VideoRes
    {
        unsigned int uiHeight;
        unsigned int uiWidth;
        unsigned int uiFlags;
    } VideoRes;

    VideoRes* m_pVideoRes;      // Holds a list of our supported video modes
    unsigned int m_uiNumRes;    // Number of Video Resolution modes we have

    // Private Methods

    void GetVideoResModes();    // This function will enumerate all of the valid video resolution modes
};

#endif // _VIDEORESMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\XBEDirMonitor.h ===
/*****************************************************
*** xbedirmonitor.h
***
*** Header file for our Directory Monitor class.
*** This class will monitor an XBE directory for
*** changes so that our XBE list can be kept up to
*** date
***
*** by James N. Helm
*** December 13th, 2000
***
*****************************************************/

#ifndef _XBEDIRMONITOR_H_
#define _XBEDIRMONITOR_H_

#include "cworkerthread.h"
#include "xbelist.h"

class CXBEDirMonitor : public CWorkerThread
{
public:
    // Constructors and Destructor
    CXBEDirMonitor();
    ~CXBEDirMonitor();

    // Properties
    // Methods
    CXBEList* GetXBEListPtr();          // Return a pointer to the most up to date XBE List
    void Init();                        // Initialize the Object
    BOOL SoftBreak(DWORD dwTimeOut);    // Used to stop the thread early

private:
    // Properties
    CXBEList m_XBEList1;                // List of XBE's that are found in the directory
    CXBEList m_XBEList2;                // List of XBE's that are found in the directory
    BOOL m_bList1InUse;                 // Used to determine if we are currently using list one, or list two
    CXBEList* m_pXBEList;               // XBE List currently in use by this class
    ULONG m_LastTrayStateChangeCount;

    // Methods
    /*****************************************************************************
    NOTE: in the implementation of this function, the user must check
           the bExit flag and exit gracefully if set:
    while(1)
        {
        if(GetExitFlag()) break;
        }
    *****************************************************************************/
    DWORD ThreadFunct(void);
    void PollTrayState(void);
};

#endif // _XBEDIRMONITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\xbedirmonitor.cpp ===
/*****************************************************
*** xbedirmonitor.cpp
***
*** CPP file for our Directory Monitor class.
*** This class will monitor an XBE directory for
*** changes so that our XBE list can be kept up to
*** date
***
*** by James N. Helm
*** December 13th, 2000
***
*****************************************************/

#include "stdafx.h"
#include "xbedirmonitor.h"

// Constructor
CXBEDirMonitor::CXBEDirMonitor()
: m_bList1InUse( FALSE ),
m_pXBEList( NULL ),
m_LastTrayStateChangeCount( 0 )
{
}

// Destructor
CXBEDirMonitor::~CXBEDirMonitor()
{
}

/*****************************************************************************

Routine Description:

    ThreadFunct

    This function will monitor the XBE directory for changes, and re-populate
    itself at each interval

Arguments:

    none

Return Value:


Notes:

    See CWorkerThread.h & CWorkerThread.cpp for more information on this
    member function.

*****************************************************************************/
DWORD CXBEDirMonitor::ThreadFunct(void)
{
    while( !GetExitFlag() )
    {
        // Re-poll our directory if needed
        Sleep( EXECUTABLE_DIRECTORY_POLL_INTERVAL );
        m_pXBEList->Init( FILE_EXECUTABLE_DIRECTORY_A, FILE_EXECUTABLE_EXENSION_A );

        Lock();

        if( m_bList1InUse )
        {
            m_bList1InUse = FALSE;
            m_pXBEList = &m_XBEList2;
        }
        else
        {
            m_bList1InUse = TRUE;
            m_pXBEList = &m_XBEList1;
        }

        Unlock();

        PollTrayState();
    }

    return 0;
}


// This function will initialize the object to a ready state, and should
// be called before calling "Run()" on the thread
void CXBEDirMonitor::Init()
{
    m_bList1InUse = TRUE;               // Default to using list #1
    m_pXBEList    = &m_XBEList1;        // XBE List currently in use by this class (List 1)

    // Initialize our XBE Lists
    m_XBEList1.Init( FILE_EXECUTABLE_DIRECTORY_A, FILE_EXECUTABLE_EXENSION_A );
    m_XBEList2.Init( FILE_EXECUTABLE_DIRECTORY_A, FILE_EXECUTABLE_EXENSION_A );
}


// This function will return a pointer to the most up to date XBE List
CXBEList* CXBEDirMonitor::GetXBEListPtr()
{
    CXBEList* pXBEReturn = NULL;

    Lock(); // Protect our memory

    if( m_bList1InUse )
    {
        pXBEReturn = &m_XBEList2;
    }
    else
    {
        pXBEReturn = &m_XBEList1;
    }

    Unlock();

    return pXBEReturn;
}

void CXBEDirMonitor::PollTrayState(void)
{
    ULONG TrayState;
    ULONG TrayStateChangeCount;
    OBJECT_STRING DeviceName;

    // Read the SMC tray state
    if (NT_SUCCESS(HalReadSMCTrayState(&TrayState, &TrayStateChangeCount))) {

        // If something has changed, then force a dismount of the DVD
        if (TrayStateChangeCount != m_LastTrayStateChangeCount) {
            RtlInitObjectString(&DeviceName, "\\??\\CdRom0:");
            IoDismountVolumeByName(&DeviceName);
            m_LastTrayStateChangeCount = TrayStateChangeCount;
        }
    }
}


BOOL CXBEDirMonitor::SoftBreak(DWORD dwTimeOut)
{
    Lock();
    m_XBEList1.SetStopXBEEnumeration( TRUE );
    m_XBEList2.SetStopXBEEnumeration( TRUE );
    Unlock();

    return CWorkerThread::SoftBreak( dwTimeOut );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\timezonemenu.cpp ===
/*****************************************************
*** timezonemenu.cpp
***
*** CPP file for our XShell Time Zone menu 
*** class.  This is a standard menu contains a list
*** of menu items to be selected.
***
*** by James N. Helm
*** June 26th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "timezonemenu.h"

extern CXSettings           g_XboxSettings;         // Settings that are stored on the Xbox
extern IDirect3DDevice8*    g_pD3DDevice;           // Pointer to our Direct3D Device Object
extern CSoundCollection     g_Sounds;               // Used to generate all sounds for the XShell
extern BOOL                 g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
extern BOOL                 g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow
extern XFONT*               g_pFont;

// Constructors
CTimeZoneMenu::CTimeZoneMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_uiTopItemIndex( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "CTimeZoneMenu::CTimeZoneMenu(ex)" );

    m_uiNumItems = XSETTINGS_TIMEZONECOUNT;
    
    // Make sure our settings are up to date
    g_XboxSettings.LoadSettings();

    SetSelectedItem( g_XboxSettings.GetCurrentTimeZoneIndex() );

    SetTitle( MENU_TITLE_TIMEZONES );
}


// Destructor
CTimeZoneMenu::~CTimeZoneMenu()
{
}

// Draws a menu on to the screen
void CTimeZoneMenu::Action( CUDTexture* pTexture )
{
    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Update our Font Height
    unsigned int uiDefaultFontHeight = m_uiFontHeightOfItem;
    XFONT_SetTextHeight( g_pFont, TIMEZONEMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = TIMEZONEMENU_FONT_HEIGHT;

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    // Draw a box behind the currently highlighted choice
    float X1Pos = MENUBOX_SELECTBAR_X1;
    float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - ITEM_SELECTOR_BORDER_SPACE;
    float X2Pos = MENUBOX_SELECTBAR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
    
    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

    //
    // Draw our Menu Items
    //

    for( unsigned int x = m_uiTopItemIndex; x < ( TIMEZONEMENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); x++ )
    {
        if( x == GetNumItems() )
        {
            break;
        }

        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

        // Display our timezone list on to our screen
        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%hs", g_timezoneinfo[x].dispname );
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = uiDefaultFontHeight;
    XFONT_SetTextHeight( g_pFont, uiDefaultFontHeight );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CTimeZoneMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CTimeZoneMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() < (int)m_uiTopItemIndex )
                    {
                        m_uiTopItemIndex = GetSelectedItem();

                        AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() >= (int)( TIMEZONEMENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ) )
                    {
                        m_uiTopItemIndex += 1;

                        AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CTimeZoneMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            m_bUpdateTexture = TRUE;

            // Set the Timezone in to the config sector
            if( FAILED( g_XboxSettings.SetTimeZoneInfo( (unsigned int)GetSelectedItem() ) ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CTimeZoneMenu::HandleInput()Failed to set the TimeZone!!" );
            }

            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CTimeZoneMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CTimeZoneMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    return hr;
}


// Should be called whenever a user leaves the menu
void CTimeZoneMenu::Leave( CXItem* pItem )
{
    // Call our base class Leave
    CMenuScreen::Leave( pItem );

    g_bDisplayUpArrow = FALSE;
    g_bDisplayDownArrow = FALSE;
}

// This will be called whenever the user enters this menu
void CTimeZoneMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Make sure we are dealing with the most up-to-date time zone
    g_XboxSettings.LoadSettings();

    // Set our selected item to the currently selected
    SetSelectedItem( g_XboxSettings.GetCurrentTimeZoneIndex() );
    if( ( GetSelectedItem() - TIMEZONEMENU_NUM_ITEMS_TO_DISPLAY ) < 0 )
    {
        m_uiTopItemIndex = 0;
    }
    else if( (unsigned int)( GetSelectedItem() + TIMEZONEMENU_NUM_ITEMS_TO_DISPLAY ) < GetNumItems() )
    {
        m_uiTopItemIndex = GetSelectedItem();
    }
    else
    {
        m_uiTopItemIndex = GetNumItems() - TIMEZONEMENU_NUM_ITEMS_TO_DISPLAY;
    }

    // Make sure the proper arrows are displayed
    AdjustDisplayArrows();
}


// Adjust the UP and DOWN arrows on the screen
void CTimeZoneMenu::AdjustDisplayArrows()
{
    // Decide if we need to turn on the Up Arrow
    if( 0 == m_uiTopItemIndex )
    //
    // We can turn off the Up Arrow, because there is nothing above us
    //
    {
        g_bDisplayUpArrow = FALSE;
    }
    else
    //
    // We have to turn on the Up Arrow, because a menu choice is above us
    //
    {
        g_bDisplayUpArrow = TRUE;
    }

    // Decide if we need to turn on the Down Arrow
    if( ( m_uiTopItemIndex + TIMEZONEMENU_NUM_ITEMS_TO_DISPLAY ) == GetNumItems() )
    //
    // We can turn off the Down arrow, because nothing is below us
    //
    {
        g_bDisplayDownArrow = FALSE;
    }
    else
    //
    // We have to turn on the Down Arrow, because there are menu choices below us
    //
    {
        g_bDisplayDownArrow = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\videoresmenu.cpp ===
/*****************************************************
*** videoresmenu.cpp
***
*** CPP file for our XShell Video Resolution menu 
*** class.  This menu will allow the user to select
*** different screen resolutions and run the
*** XDK Launcher in that resolution
***
*** by James N. Helm
*** June 9th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "videoresmenu.h"

extern IDirect3DDevice8* g_pD3DDevice;                  // Pointer to our Direct3D Device Object
extern CSoundCollection  g_Sounds;                      // Used to generate all sounds for the XShell
extern XFONT* g_pFont;

// Constructors
CVideoResMenu::CVideoResMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_pVideoRes( NULL ),
m_uiNumRes( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "CVideoResMenu::CVideoResMenu(ex)" );

    SetTitle( MENU_TITLE_VIDEORES );

    GetVideoResModes();
    m_uiNumItems = m_uiNumRes;
    SetSelectedItem( 0 );
}


// Destructor
CVideoResMenu::~CVideoResMenu()
{
    if( NULL != m_pVideoRes )
    {
        delete[] m_pVideoRes;
        m_pVideoRes = NULL;
    }
}

// Draws a menu on to the screen
void CVideoResMenu::Action( CUDTexture* pTexture )
{
    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }
    
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_OPTIONMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_OPTIONMENU_FONT_HEIGHT;

    // Draw a box behind the currently highlighted choice
    float X1Pos = MENUBOX_SELECTBAR_X1;
    float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - ITEM_SELECTOR_BORDER_SPACE;
    float X2Pos = MENUBOX_SELECTBAR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
    
    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

    //
    // Draw our Menu Items
    //

    /*
    for( unsigned int x = 0; x < ENUM_VIDEORES_MAX_MENUITEMS; x++ )
    {
        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszVideoResMenuItems[x] );
    }
    */
    for( unsigned int x = 0; x < m_uiNumRes; x++ )
    {
        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ux%u", m_pVideoRes[x].uiWidth, m_pVideoRes[x].uiHeight );
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CVideoResMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CVideoResMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetSelectedItem() > 0 )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                SetSelectedItem( GetSelectedItem() - 1 );
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                SetSelectedItem( GetSelectedItem() + 1 );
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CVideoResMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                m_bUpdateTexture = TRUE;

                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                /*
                DWORD dwFlags = 0;
                if( 240 == m_pVideoRes[GetSelectedItem()].uiHeight )
                {
                    dwFlags = D3DPRESENTFLAG_FIELD;
                }
                */

                ::InitD3D( m_pVideoRes[GetSelectedItem()].uiWidth, m_pVideoRes[GetSelectedItem()].uiHeight, m_pVideoRes[GetSelectedItem()].uiFlags );
                ::Init3DObjects();
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    }
}


// Initialize the Menu
HRESULT CVideoResMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CVideoResMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    return hr;
}


// This will be called whenever the user enters this menu
void CVideoResMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Determine which option should be highlighted
    unsigned int uiScreenWidth = ::GetScreenWidth();
    unsigned int uiScreenHeight = ::GetScreenHeight();

    for( unsigned int x = 0; x < m_uiNumRes; x++ )
    {
        if( ( uiScreenWidth == m_pVideoRes[x].uiWidth ) && ( uiScreenHeight == m_pVideoRes[x].uiHeight ) )
        {
            SetSelectedItem( x );
            
            break;
        }
    }
}


// This function will enumerate all of the valid video resolution modes
void CVideoResMenu::GetVideoResModes()
{
	// Query the number of display modes
    IDirect3D8* pD3D = NULL;
    
    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CVideoResMenu::GetVideoResModes():Failed to create our D3D pointer!!" );

        return;
    }

	DWORD dwNumModes = pD3D->GetAdapterModeCount( D3DADAPTER_DEFAULT );
    XDBGTRC( APP_TITLE_NAME_A, "CVideoResMenu::Enter():dwNumModes1 - '%d'", dwNumModes );

    // Enumerate the mode lists
    D3DDISPLAYMODE* pModeList = new D3DDISPLAYMODE[dwNumModes];
    if( NULL == pModeList )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CVideoResMenu::GetVideoResModes():Failed to allocate memory!!" );
    }
    else
    {
        D3DFORMAT formats[]	= 
	    { 
		    D3DFMT_D24S8, 
		    D3DFMT_D16, 
		    D3DFMT_F24S8, 
		    D3DFMT_F16, 
		    D3DFMT_D16_LOCKABLE 
	    };
        unsigned int uiNumFormats = sizeof( formats ) / sizeof( formats[0] );

        for( unsigned int uiIndex = 0, i = 0; i < dwNumModes; ++i )
	    {
		    if( pD3D->EnumAdapterModes( D3DADAPTER_DEFAULT, i, &pModeList[uiIndex] ) != D3D_OK )
		    {
                XDBGWRN( APP_TITLE_NAME_A, "CVideoResMenu::GetVideoResModes():Failed to enumerate mode - '%u'", i );
                /*
			    // Find the first valid depth format for the mode
			    for( unsigned int ii = 0; ii < uiNumFormats; ++ii )
			    {
				    // Is it a good match?
				    if( pD3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
												             pModeList[index].Format,
												             pModeList[index].Format,
												             formats[ii]) == D3D_OK )
				    {
					    ++index;
					    break;
				    }
			    }
                */
		    }
            else
            {
                ++uiIndex;
            }
	    }

	    dwNumModes = uiIndex;
        XDBGTRC( APP_TITLE_NAME_A, "CVideoResMenu::Enter():dwNumModes2 - '%d'", dwNumModes );

        m_pVideoRes = new VideoRes[dwNumModes];   // Holds a list of our supported video modes
        if( NULL == m_pVideoRes )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CVideoResMenu::GetVideoResModes():Failed to allocate memory!!" );
        }
        else
        {
            ZeroMemory( m_pVideoRes, sizeof( VideoRes ) * dwNumModes );
            BOOL bAddItem;

            for( unsigned int x = 0; x < dwNumModes; x++ )
            {
                bAddItem = TRUE;

                // Add the modes to our array, if it doesn't already exist in our matrix
                for( unsigned int xx = 0; xx < m_uiNumRes; xx++ )
                {
                    if( ( m_pVideoRes[xx].uiWidth == pModeList[x].Width ) && ( m_pVideoRes[xx].uiHeight == pModeList[x].Height ) )
                    {
                        bAddItem = FALSE;
                        
                        break;
                    }
                }

                if( bAddItem )
                {
                    m_pVideoRes[m_uiNumRes].uiWidth = pModeList[x].Width;
                    m_pVideoRes[m_uiNumRes].uiHeight = pModeList[x].Height;
                    m_pVideoRes[m_uiNumRes].uiFlags = pModeList[x].Flags;
                    
                    XDBGTRC( APP_TITLE_NAME_A, "CVideoResMenu::GetVideoResModes():Added #%u - '%ux%u', Flags = '%u'", m_uiNumRes, m_pVideoRes[m_uiNumRes].uiWidth, m_pVideoRes[m_uiNumRes].uiHeight, m_pVideoRes[m_uiNumRes].uiFlags );
                    
                    m_uiNumRes++;
                }
            }
        }
    }

    // If this wasn't created, we would have returned, so we can safely release without checking
    pD3D->Release();
    pD3D = NULL;

    if( NULL != pModeList )
    {
        delete[] pModeList;
        pModeList = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

XFONT *g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( g_pFont, string, length, &outlen );
	
    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN LPCWSTR string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\xshell.cpp ===
#include "stdafx.h"
#include "xlaunch.h"
#include "launchmenu.h"
#include "errormsgmenu.h"
#include "camera.h"
#include "gouraudgroup.h"
#include "gouraudobject.h"
#include "gouraudtexobject.h"
#include "xboxverp.h"

// Other globals
IDirect3DDevice8*      g_pD3DDevice = NULL;                 // Pointer to our Direct3D Device Object
LPDIRECTSOUND          g_pDSound = NULL;                    // Pointer to our DirectSound Object
USBManager             Controllers;                         // Used to determine what buttons / direction the user is pressing
CXSettings             g_XboxSettings;                      // Settings that are stored on the Xbox
CSoundCollection       g_Sounds;                            // Used to generate all sounds for the XShell
CHardDrive             g_XboxHardDrive;                     // Used to configure the Xbox Hard Drive
CMemoryUnit            g_MemoryUnits[8];                    // Memory Units that can be inserted, or removed
extern XFONT*          g_pFont;                             // Our Default Font Pointer
CUDTexture             g_MainTexture;                       // Main Texture for our menu data that all screens will render to
CUDTexture             g_XDKTitleTexture;                   // Texture for our XDK Title bar
CUDTexture             g_XDKAddressTexture;                 // Texture for our XDK Address information
CUDTexture             g_BuildNoTexture;                    // Texture that holds our Build Number
CXItem*                g_pPrevScreen = NULL;                // Used to determine when a user enters a new menu
CXItem*                g_pCurrentScreen = NULL;	            // Pointer to the current menu object
CXItem*                g_pRootMenu = NULL;                  // Pointer to the menu that is our "main, or root" menu
BOOL                   g_bNetOK = FALSE;                    // Determines if we should display the IP address
DWORD                  g_dwShellState = SHELLSTATE_NORMAL;  // Defines the current state of the XShell
BOOL                   g_bUpdateNameAddrTexture = TRUE;     // Determines if we need to update the machine name & IP Address
BOOL                   g_bHighlightAButton = FALSE;         // Used to render the A Button Highlight
BOOL                   g_bHighlightBButton = FALSE;         // Used to render the B Button Highlight
BOOL                   g_bDisplayBButton = TRUE;            // Used to determine if we should render the B Button
BOOL                   g_bDisplayAButton = TRUE;            // Used to determine if we should render the A Button
BOOL                   g_bDisplayUpArrow = FALSE;           // Used to determine if we should render the Up Arrow
BOOL                   g_bDisplayDownArrow = FALSE;         // Used to determine if we should render the Down Arrow
BOOL                   g_bUpdateTitleTexture = TRUE;        // Update the Title Texture
BOOL                   g_bToggleIPInfo = TRUE;              // Menu's can use this to turn off toggling of the IP Address info
int                    g_iDisplayAddress = 0;               // debug ip, debug enet, title ip, title enet

BOOL                   g_bMUsChanged = TRUE;                // Tracks whether MU's have been inserted or removed
DWORD                  g_dwInsertedMUs;                     // Tracks which MUs are inserted or removed

char                   g_pszKeyCombo[5];                    // Used to determine the last 4 keys the user has entered
unsigned int           g_uiKeyPos = 0;                      // Used to track which keypress the user is on


// Global 3D Objects
Camera                 g_mainCamera;
GouraudGroup           g_GGroup0;
GouraudGroup           g_GGroup1;
GouraudGroup           g_GTubes;    // Tubes for all objects
GouraudGroup           g_GGroup3;   // App Title, Up/Down Arrows, X/Y button info panel
GouraudGroup           g_GGroup4;
GouraudGroup           g_GGroup5;
GouraudGroup           g_GGroup6;
GouraudGroup           g_GGroup7;   // Outer Cell

GouraudTexObject       g_GTOMovieScreen;
GouraudTexObject       g_XDKtitle;
GouraudTexObject       g_XDKaddress;
GouraudTexObject       g_InnerCell;
GouraudTexObject       g_BuildNo;

// Global Menus are created here
CLaunchMenu            g_LaunchMenu( NULL );                // XBE Launch Menu
CErrorMsgMenu          g_ErrorMsgMenu( NULL );              // Error Msg Menu
CGenKeyboardMenu       g_GenKeyboardMenu( NULL );           // Generic Virutal Keyboard menu
                                                            // TODO: Replace other, non-generic keyboard menus with this
CMessageMenu           g_MessageMenu( NULL );               // Used to display generic messages
                                                            // TODO: Replace other, non-generic message menus with this
CMADisplayMenu         g_MADisplayMenu( NULL );             // Used to display our Memory Areas
CYesNoMenu             g_YesNoMenu( NULL );                 // Used to ask the user a YES / NO question
                                                            // TODO: Replace all current yes / no type menus with this


void _cdecl main()
{
    XDBGTRC( APP_TITLE_NAME_A, "***** main()" );

    DWORD dwEdgeCurrentState = 0;

    Init();

    do
    {
        // Check to see if the user has inserted or removed any Memory Units
        CheckMUs();

        // If the user switched menus, make sure we call "Enter" for the new menu
        if( g_pPrevScreen != g_pCurrentScreen )
        {
            g_pPrevScreen = g_pCurrentScreen;
            g_pCurrentScreen->Enter();
        }
        
		g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
		g_pD3DDevice->BeginScene();

        // g_mainCamera.noise( g_pD3DDevice );

        g_pD3DDevice->SetVertexShader( D3DFVF_D3DVERTEX );

        g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );

		g_GGroup7.renderStrip( g_pD3DDevice );      // Outer Cell

        g_pD3DDevice->SetTexture( 0, g_InnerCell.m_pTexture );
		g_InnerCell.render( g_pD3DDevice );  // Inner cell
		g_pD3DDevice->SetTexture( 0, NULL );

        /*
        ////////////////////////////////
        // Rotate Cell
        ////////////////////////////////

        float fNow = (float)GetTickCount();
        float fField = D3DX_PI / 4.0f;
        float fRpm = 0.05f;
        float fAngle = sinf((float)(fNow * D3DX_PI * fRpm / 60.0f)) * fField / 2.0f;

        g_GGroup7.m_pObjects->localRotateY( fAngle );
        g_InnerCell.localRotateY( fAngle );
        */

        ////////////////////////////////
        ////////////////////////////////

        g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

        g_GGroup6.renderStrip( g_pD3DDevice );  //Arm

        g_pD3DDevice->SetVertexShader( D3DFVF_D3DVERTEX );
       
        // g_GGroup0.renderStrip( g_pD3DDevice );      // A & B Button Spheres (4 objects)

        // Should we display the A Button?
        if( g_bDisplayAButton )
        {
            g_GGroup0.m_pObjects[2].renderStrip( g_pD3DDevice );        // A Button Inner Sphere
            g_GGroup0.m_pObjects[3].renderStrip( g_pD3DDevice );        // A Button Outer Sphere
            g_GTubes.m_pObjects[1].renderStrip( g_pD3DDevice );         // A button Tube
            g_GGroup3.m_pObjects[1].renderStrip( g_pD3DDevice );        // A Button Text

            // Check to see if we should highlight the A
            if( g_bHighlightAButton )
            {
                g_GGroup5.m_pObjects[0].renderStrip( g_pD3DDevice );    // A Button Highlight
            }

            g_GGroup4.m_pObjects[1].renderStrip( g_pD3DDevice );        // A Button Full Text

            g_GGroup1.m_pObjects[2].renderStrip( g_pD3DDevice );        // A Button tube joint
            g_GGroup1.m_pObjects[3].renderStrip( g_pD3DDevice );        // A Button tube joint
        }

        // Should we display the B Button
        if( g_bDisplayBButton )
        {
            g_GGroup0.m_pObjects[0].renderStrip( g_pD3DDevice );        // B Button Sphere
            g_GGroup0.m_pObjects[1].renderStrip( g_pD3DDevice );        // B Button Outer Sphere
            g_GTubes.m_pObjects[0].renderStrip( g_pD3DDevice );         // B button Tube
            g_GGroup3.m_pObjects[0].renderStrip( g_pD3DDevice );        // B Button Text

            // Check to see if we should highlight the B 
            if( g_bHighlightBButton )
            {
                g_GGroup5.m_pObjects[1].renderStrip( g_pD3DDevice );    // B Button Highlight
            }

            g_GGroup4.m_pObjects[0].renderStrip( g_pD3DDevice );        // B Button Full Text

            g_GGroup1.m_pObjects[0].renderStrip( g_pD3DDevice );        // B Button tube joint
            g_GGroup1.m_pObjects[1].renderStrip( g_pD3DDevice );        // B Button tube joint
        }

		// g_GGroup1.renderStrip( g_pD3DDevice );  // Frame around texture -- Main body of object (10 objects)
        // Object 0 - B Button tube joint
        // Object 1 - B Button tube joint
        // Object 2 - A Button tube joint
        // Object 3 - A Button tube joint
        g_GGroup1.m_pObjects[4].renderStrip( g_pD3DDevice );    // Frame - Left Panel
        g_GGroup1.m_pObjects[5].renderStrip( g_pD3DDevice );    // Frame - Top Panel (Title Panel)
        g_GGroup1.m_pObjects[6].renderStrip( g_pD3DDevice );    // Frame - Bottom Panel (Name/Address Panel)
        g_GGroup1.m_pObjects[7].renderStrip( g_pD3DDevice );    // Frame - Lower Left Corner Panel
        g_GGroup1.m_pObjects[8].renderStrip( g_pD3DDevice );    // Frame - Lower Right Corner Panel
        g_GGroup1.m_pObjects[9].renderStrip( g_pD3DDevice );    // Frame - Upper Right Corner Panel (X/Y Button Panel)

        g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );

        // g_GTubes.renderStrip( g_pD3DDevice );       // Tubes (4 objects)
        // Object 0 is B Button related (B Button Tube)
        g_GTubes.m_pObjects[2].renderStrip( g_pD3DDevice );     // Frame tube - Bottom (lower left corner)
        g_GTubes.m_pObjects[3].renderStrip( g_pD3DDevice );     // Frame tube - Arm (upper left corner)

        g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

        // g_GGroup3.renderStrip( g_pD3DDevice );   // Text and Title info (7 objects)
        // Object 0 is B Button related (B Button Text)
        g_GGroup3.m_pObjects[4].renderStrip( g_pD3DDevice );    // Application Title

        // Only render these items if we are on the Launcher Menu
        if( g_pCurrentScreen == &g_LaunchMenu )
        {
            g_GGroup3.m_pObjects[2].renderStrip( g_pD3DDevice );    // Y Button Info (Screen text)
            g_GGroup3.m_pObjects[3].renderStrip( g_pD3DDevice );    // X Button Info (Screen text)
        }

        // Check to see if we should display the "Up" arrow
        if( g_bDisplayUpArrow )
        {
            g_GGroup3.m_pObjects[5].renderStrip( g_pD3DDevice );    // Up Arrow
        }

        // Check to see if we should display the "Down" arrow
        if( g_bDisplayDownArrow )
        {
            g_GGroup3.m_pObjects[6].renderStrip( g_pD3DDevice );    // Down Arrow
        }

		// g_GGroup4.renderStrip( g_pD3DDevice );   // A & B full text (2 Objects)

        // Render our main movie-texture and process any input from the current menu / screen
        g_pCurrentScreen->Action( &g_MainTexture );
        ProcessInput();

        g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

        
        // Make sure that edge antialiasing is off for the following objects
        g_pD3DDevice->GetRenderState( D3DRS_EDGEANTIALIAS, &dwEdgeCurrentState );
        g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );

        //
        // Render the Main Movie Screen
        //
        g_pD3DDevice->SetTexture( 0, g_MainTexture.GetTexture() );
        g_GTOMovieScreen.render( g_pD3DDevice );
		g_pD3DDevice->SetTexture( 0, NULL );

        // Render the XDK Title
        if( g_bUpdateTitleTexture )
        {
            g_bUpdateTitleTexture = FALSE;  // Make sure we only update the texture once

            UpdateTitleTexture( &g_XDKTitleTexture );
        }
		g_pD3DDevice->SetTexture( 0, g_XDKTitleTexture.GetTexture() );
		g_XDKtitle.render( g_pD3DDevice );
		g_pD3DDevice->SetTexture( 0, NULL );

        // Render the XDK Address Information
        // This is updated when the user changes the IP Address or the Machine Name ONLY
        if( g_bUpdateNameAddrTexture )
        {
            g_bUpdateNameAddrTexture = FALSE;  // Make sure we only update the texture once

            UpdateAddressTexture( &g_XDKAddressTexture );
        }

        g_pD3DDevice->SetTexture( 0, g_XDKAddressTexture.GetTexture() );
		g_XDKaddress.render( g_pD3DDevice );
		g_pD3DDevice->SetTexture( 0, NULL );

        g_pD3DDevice->SetTexture( 0, g_BuildNoTexture.GetTexture() );
        g_BuildNo.render( g_pD3DDevice );
        g_pD3DDevice->SetTexture( 0, NULL );
		
        g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
        g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

        // Reset the EdgeAntialias information
        g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, dwEdgeCurrentState );

        g_pD3DDevice->EndScene();
		g_pD3DDevice->Present( NULL, NULL, NULL, NULL );

        ProcessKeySequences();

    } while( TRUE );

    CleanUp();

    XDBGTRC( APP_TITLE_NAME_A, "***** main()" );
}


// Initialize DSound
HRESULT InitDSound()
{
	HRESULT hr = S_OK;

    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDSound, NULL)))
	{
        XDBGWRN( APP_TITLE_NAME_A, "DirectSoundCreate FAILED!! Error - '0x%.08X'", hr );

        return hr;
	}

    return hr;
}


// Initialize Direct3D
HRESULT InitD3D( UINT uiWidth, UINT uiHeight, DWORD dwFlags )
{
    // Check to see if we are already initialized, and if so, release
    // the previous object
    if( NULL != g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    if( NULL == ( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitD3D():Failed to create our D3D Object!!" );

        return E_FAIL;
    }

    // Always do interlaced output on an HDTV.
    if( XGetAVPack() == XC_AV_PACK_HDTV )
    {
        dwFlags |= D3DPRESENTFLAG_INTERLACED;
    }

    // Check to see if the user wants widescreen mode
    if( g_XboxSettings.GetWidescreen() )
    {
        dwFlags |= D3DPRESENTFLAG_WIDESCREEN;
    }

	// Create our D3D Device Object
	D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );
	
	d3dpp.BackBufferWidth                 = uiWidth;    // SCREEN_WIDTH;
	d3dpp.BackBufferHeight                = uiHeight;   // SCREEN_HEIGHT;
	d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    if( uiWidth <= 1280 )
    {
        d3dpp.MultiSampleType             = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN; // D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR; // D3DMULTISAMPLE_NONE; // D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN; 
    }
	d3dpp.BackBufferCount                 = 1;
    d3dpp.Flags                           |= dwFlags;
	
    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
	d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT; // D3DPRESENT_INTERVAL_IMMEDIATE;
    
  	if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
	{
		XDBGWRN( APP_TITLE_NAME_A, "InitD3D():Failed to create our D3D Device Object!!" );
	}

    D3DDevice_SetSoftDisplayFilter(TRUE);

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;


    // Create our ViewPort
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = uiWidth;   // SCREEN_WIDTH;
    D3DViewport.Height = uiHeight;  // SCREEN_HEIGHT; 
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitD3D():Failed to set the D3D Viewport!!" );
    }

	g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
	g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS , FALSE ); // Must do this to enable Edge Antialiasing
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
	g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );
    if( uiWidth <= 1280 )
    {
        // g_pD3DDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS , TRUE );
    }

	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return hr;
}


// Initialize our 3D Objects for our scene
HRESULT Init3DObjects( void )
{
	g_GGroup0.loadStrippedMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj0.mdl", g_pD3DDevice );
	g_GGroup1.loadStrippedMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj1.mdl", g_pD3DDevice );
	g_GTubes.loadStrippedMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj2.mdl", g_pD3DDevice );
	g_GGroup3.loadStrippedMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj3.mdl", g_pD3DDevice );
	g_GGroup4.loadStrippedMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj4.mdl", g_pD3DDevice );
	g_GGroup5.loadStrippedMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj5.mdl", g_pD3DDevice );
	g_GGroup6.loadStrippedMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj6.mdl", g_pD3DDevice );
	g_GGroup7.loadStrippedMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj11.mdl", g_pD3DDevice );

    g_GTOMovieScreen.loadMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj7.mdl", g_pD3DDevice );
	// g_GTOMovieScreen.loadTexture( FILE_DATA_3DINFO_DIRECTORY_A "\\screenshot.bmp", g_pD3DDevice );

    g_XDKtitle.loadMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj8.mdl", g_pD3DDevice );
	// g_XDKtitle.loadTexture("t:\\screenshot.bmp", g_pD3DDevice );
    
    g_XDKaddress.loadMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj9.mdl", g_pD3DDevice );
	// g_XDKaddress.loadTexture("t:\\screenshot.bmp", g_pD3DDevice );

    g_InnerCell.loadMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj10.mdl", g_pD3DDevice );
    g_InnerCell.loadTexture( FILE_DATA_3DINFO_DIRECTORY_A  "\\cellwall.bmp", g_pD3DDevice );

    g_BuildNo.loadMDL( FILE_DATA_3DINFO_DIRECTORY_A "\\matobj12.mdl", g_pD3DDevice );

    //////////////////////////
    // Initialize Our Textures
    //////////////////////////
    g_MainTexture.Initialize( g_pD3DDevice, NULL, TEXTURE_MOVIESCREEN_WIDTH, TEXTURE_MOVIESCREEN_HEIGHT );
    g_XDKTitleTexture.Initialize( g_pD3DDevice, NULL, TEXTURE_XDKTITLE_WIDTH, TEXTURE_XDKTITLE_HEIGHT );
    g_XDKAddressTexture.Initialize( g_pD3DDevice, NULL, TEXTURE_XDKADDRESS_WIDTH, TEXTURE_XDKADDRESS_HEIGHT );
    g_BuildNoTexture.Initialize( g_pD3DDevice, NULL, TEXTURE_BUILDNO_WIDTH, TEXTURE_BUILDNO_HEIGHT );

    // Render the Build Number to the Texture
    g_BuildNoTexture.Lock();
    g_BuildNoTexture.Clear( COLOR_BLACK );
    XFONT_SetTextHeight( g_pFont, MENUBOX_BUILDNO_TEXT_HEIGHT );
    g_BuildNoTexture.DrawText( MENUBOX_BUILDNO_TEXT_XPOS, MENUBOX_BUILDNO_TEXT_YPOS, MENUBOX_BUILDNO_TEXT_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%hs", VER_PRODUCTVERSION_STR );
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );
    g_BuildNoTexture.Unlock();
    AlphaTexture( g_BuildNoTexture.GetTexture(), SCREEN_DEFAULT_TEXT_FG_COLOR );

    //////////////////////////////////////
    // Adjust the camera to our video mode
    //////////////////////////////////////
    g_mainCamera.readCAM( FILE_DATA_3DINFO_DIRECTORY_A "\\cameramainTV.cam" );

    // Set the Camera to Widescreen if needed
    if( g_XboxSettings.GetWidescreen() )
        g_mainCamera.SetWidescreen( TRUE );

	g_mainCamera.update( g_pD3DDevice );

    //
    // Make sure our textures are up to date
    //
    g_bUpdateNameAddrTexture = TRUE;
    g_bUpdateTitleTexture = TRUE;

    return S_OK;
}

#define FADE_LENGTH 500

void SetRamp(int coefficient)
{
    int i, value;
    D3DGAMMARAMP ramp;

    for (i = 0; i < 256; i++) {
        value = i * coefficient / FADE_LENGTH;
        ramp.red[i] = (BYTE)value;
        ramp.green[i] = (BYTE)value;
        ramp.blue[i] = (BYTE)value;
    }

    IDirect3DDevice8_SetGammaRamp(g_pD3DDevice,
            D3DSGR_NO_CALIBRATION | D3DSGR_IMMEDIATE,
            &ramp);
}

BOOL GammaFade(int startTime)
{
    int delta;

    delta = NtGetTickCount() - startTime;

    if (delta >= FADE_LENGTH) {
        SetRamp(FADE_LENGTH);
        return FALSE;
    } else {
        SetRamp(delta);
        return TRUE;
    }
}

// Initialize our application - video, sound, etc
HRESULT Init( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "Init()" );


    ////////////////////////////
    // Set the File System Cache
    ////////////////////////////
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    ///////////////////
    // Mount any MUs
    ///////////////////

    // Mount any MU that is inserted
    g_dwInsertedMUs = XGetDevices( XDEVICE_TYPE_MEMORY_UNIT );
    for( unsigned int x = 0; x < NUM_XBOX_MU_SLOTS; ++x )
    {
        if( g_dwInsertedMUs & g_dwMUBitMask[x] )
            g_MemoryUnits[x].Mount();
    }


    ///////////////////
    // Mount our Drives
    ///////////////////

    // Mount the C and the Y Drives
    g_XboxHardDrive.MapDrive( 'C', FILE_EXECUTABLE_DEVICE_PATH_A );
    g_XboxHardDrive.MapDrive( 'Y', FILE_DASH_PARTITION_PATH_A );
    
    /////////////////
    // Initialize D3D
    /////////////////
    if( FAILED( InitD3D( SCREEN_WIDTH, SCREEN_HEIGHT, 0 ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize D3D!!" );

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    if( NULL != g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }

    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

	if( NULL != g_pFont )
    {
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, FONT_DEFAULT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    ////////////////////////////
    // Initialize our 3D Objects
    ////////////////////////////
    if( FAILED( Init3DObjects() ) )
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our 3D Objects!!" );


    ////////////////////
    // Initialize DSound
    ////////////////////
    if( FAILED( InitDSound() ) )
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize DSound!!" );
    
    ////////////////////////
    // Initialize our Sounds
    ////////////////////////
    if( FAILED( g_Sounds.Init( g_pDSound ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Sounds!!" );
    

    //////////////////////////////
    // Initialize our Memory Units
    //////////////////////////////
    g_MemoryUnits[0].SetPortSlot( XDEVICE_PORT0, XDEVICE_TOP_SLOT );
    g_MemoryUnits[1].SetPortSlot( XDEVICE_PORT0, XDEVICE_BOTTOM_SLOT );
    g_MemoryUnits[2].SetPortSlot( XDEVICE_PORT1, XDEVICE_TOP_SLOT );
    g_MemoryUnits[3].SetPortSlot( XDEVICE_PORT1, XDEVICE_BOTTOM_SLOT );
    g_MemoryUnits[4].SetPortSlot( XDEVICE_PORT2, XDEVICE_TOP_SLOT );
    g_MemoryUnits[5].SetPortSlot( XDEVICE_PORT2, XDEVICE_BOTTOM_SLOT );
    g_MemoryUnits[6].SetPortSlot( XDEVICE_PORT3, XDEVICE_TOP_SLOT );
    g_MemoryUnits[7].SetPortSlot( XDEVICE_PORT3, XDEVICE_BOTTOM_SLOT );

    ////////////////////////
    // Get our Xbox Settings
    ////////////////////////
    g_XboxSettings.Init();

    /////////////////////////
    // Initialize Xbox Online
    /////////////////////////
    XONLINE_STARTUP_PARAMS xoStartup;
    ZeroMemory( &xoStartup, sizeof( xoStartup) );

    if( FAILED( XOnlineStartup( &xoStartup ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize XOnline! (Network Too!)" );
    }
    else
    {
        g_bNetOK = TRUE;
    }
        
    /*
    //////////////////
    // Initialize XNet
    //////////////////
    XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    int nXnetResult = XNetStartup( &xnsp );

    if( NO_ERROR == nXnetResult )
    {
        WSADATA wsaData;

        int WSAErr = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );

        if( 0 == WSAErr )
            g_bNetOK = TRUE;
        else
            XDBGWRN( APP_TITLE_NAME_A, "Init():WSAStartup had a failure!!" );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():XNetStartup had a failure!!" );
    }
    */
    
    ////////////////////////
    // Initialize Key Combo
    ////////////////////////
    ZeroMemory( g_pszKeyCombo, 5 );
    
    ////////////////////////
    // Setup Menus and Items
    ////////////////////////
    SetupMenusAndItems();

    ///////////////////////////////////////////////
    // Find out if any data was passed to the Shell
    ///////////////////////////////////////////////
    DWORD dwLaunchDataType = 0;
    LD_LAUNCH_DASHBOARD launchDashboard;

    ZeroMemory( &launchDashboard, sizeof( launchDashboard ) );

    // Determine if something is passing the shell some information
    if( ERROR_SUCCESS == XGetLaunchInfoShell( &dwLaunchDataType, &launchDashboard ) )
    {
        // Check to see what booted us, the Dashboard or a Title
        if( LDT_LAUNCH_DASHBOARD == dwLaunchDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "Init():LDT_LAUNCH_DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "    dwReason     - '%d'", launchDashboard.dwReason );
            XDBGWRN( APP_TITLE_NAME_A, "    dwContext    - '%d'", launchDashboard.dwContext );
            XDBGWRN( APP_TITLE_NAME_A, "    dwParameter1 - '%d'", launchDashboard.dwParameter1 );
            XDBGWRN( APP_TITLE_NAME_A, "    dwParameter2 - '%d'", launchDashboard.dwParameter2 );
        
            // Check to see if the error was "Invalid XBE" -- That's the only error
            // we care about for now.  Anything else is ignored
            if( ( XLD_LAUNCH_DASHBOARD_ERROR == launchDashboard.dwReason ) && ( XLD_ERROR_INVALID_XBE == launchDashboard.dwParameter1 ) )
            {
                g_dwShellState |= SHELLSTATE_ERROR;                         // Enables the "Error" bitmask in the shell state
                g_ErrorMsgMenu.SetParent( g_pRootMenu );                    // Set the Parent menu of the Error Message menu to the "root" menu
                g_pCurrentScreen = &g_ErrorMsgMenu;                         // Set the current screen to the error message

                g_ErrorMsgMenu.SetErrorCode( ERRORCODE_INVALID_XBE );       // Set the error code
            }
            else
            {
                // Check to see if we need to prompt the user for the DATE/TIME info
                if( ( XLD_LAUNCH_DASHBOARD_SETTINGS == launchDashboard.dwReason ) || ( XLD_LAUNCH_DASHBOARD_ERROR == launchDashboard.dwReason ) )
                {
                    // Check to see if the Dashboard exists
                    XDBGTRC( APP_TITLE_NAME_A, "Init(): Need to reboot to Dashboard to set settings..." );
                    if( g_XboxHardDrive.FileExists( FILE_DATA_DASHBOARD_LOCATION_A ) )
                    {
                        // If so, reboot to the Dashboard passing the relevant information
                        char pszDirname[MAX_PATH+1];
                        pszDirname[MAX_PATH] = 0;

                        _snprintf( pszDirname, MAX_PATH, "%s", FILE_DASH_PARTITION_PATH_A );
                        NTSTATUS status = XWriteTitleInfoAndReboot( FILE_DATA_DASHBOARD_FILENAME_A, pszDirname, LDT_LAUNCH_DASHBOARD, 0, (PLAUNCH_DATA)&launchDashboard );
                    }
                    else
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "Init(): Dashboard didn't exist, so settings might be incorrect!!" );
                    }
                }
            }
        }
        else if( LDT_FROM_DASHBOARD == dwLaunchDataType )
        {
            LD_FROM_DASHBOARD* pFromDash = (LD_FROM_DASHBOARD*)&launchDashboard;

            XDBGWRN( APP_TITLE_NAME_A, "Init():LD_FROM_DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "    dwContext    - '%d'", pFromDash->dwContext );
        }
    }


    //////////////////////////////////////////////////////////////////////////////////
    // Check to see if the user has configured their Xbox by checking the machine name
    //////////////////////////////////////////////////////////////////////////////////
    if( strcmp( g_XboxSettings.GetMachineName(), "" ) == 0 )
    {
        g_dwShellState |= SHELLSTATE_NOCONFIG;  // Enables the "No Config" bitmask in the shell state
        
        // Determine if we are already in an error state
        if( SHELLSTATE_ERROR & g_dwShellState )
        {
            // Set the Parent of the Error Message menu to the "Machine Name" menu
            g_ErrorMsgMenu.SetParent( g_LaunchMenu.GetItemPtr( ENUM_SHELLMENUID_OPTIONS )->GetItemPtr( ENUM_SHELLMENUID_OPTIONS_NETWORK )->GetItemPtr( ENUM_SHELLMENUID_NETWORK_MACHINENAME ) );
        }
        else
        {
            // Set the Current Menu to the Machine Name menu
            g_pCurrentScreen = g_LaunchMenu.GetItemPtr( ENUM_SHELLMENUID_OPTIONS )->GetItemPtr( ENUM_SHELLMENUID_OPTIONS_NETWORK )->GetItemPtr( ENUM_SHELLMENUID_NETWORK_MACHINENAME );  // Set the current screen to the Machine Name menu
        }
    }

    
    //////////////////////////////////////////////////
    // Check to see if we are in a good (normal) state
    //////////////////////////////////////////////////
    if( SHELLSTATE_NORMAL == g_dwShellState )
    {
        g_pCurrentScreen = g_pRootMenu; // Set the current menu to the "Root Menu"
    }

    return S_OK;
}

// Clean up our application (close drivers, etc)
HRESULT CleanUp( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CleanUp()" );

    // Clean up D3D
    if( NULL != g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    // Clean up DSound
    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }

    // Clean up the Font
    if( NULL != g_pFont )
    {
        XFONT_Release( g_pFont );
    }
    
    // Clean up XOnline
    if( g_bNetOK )
    {
        if( FAILED( XOnlineCleanup() ) )
            XDBGWRN( APP_TITLE_NAME_A, "CleanUp():Failed to cleanup XOnline!!" );
    }

    /*
    // Clean up XNet and WS
    // BUGBUG -- What happens if one or both of these fail, and we are calling cleanup??
    XNetCleanup();
    WSACleanup();
    */

    // Unmap our drives
    g_XboxHardDrive.UnMapDrive( 'C' );
    g_XboxHardDrive.UnMapDrive( 'Y' );

    return S_OK;
}


// Handle input from the user
HRESULT ProcessInput( void )
{
    BOOL bFirstPress;
    BOOL bFirstPress2;
    BOOL bFirstPress3;
    BOOL bFirstXPress;
    BOOL bFirstYPress;
    BOOL bRemoteButtonPressed = FALSE;  // Used to deal with the multiple controls mappings (A/OK/START, B/BACK)
    BOOL bControlPressed = FALSE;       // Used to deal with the multiple controls mappings (A/OK/START, B/BACK)
    BOOL bButtonPressed = FALSE;        // Used to deal with the multiple controls mappings (A/OK/START, B/BACK)
    int  nThumbY = 0;
    int  nThumbX = 0;

    // Update the state of all controllers
    Controllers.ProcessInput();

    // Check to see if our KeyPress position is the end of the buffer
    // If so, reset it
    if( g_uiKeyPos == 4 )
    {
        g_uiKeyPos = 0;
    }

    // START CONTROL / A BUTTON
    bControlPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_START, &bFirstPress );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_A, BUTTON_THRESHOLD, &bFirstPress2 );
    bRemoteButtonPressed = Controllers.IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_OK, &bFirstPress3 );
    if( bControlPressed || bButtonPressed || bRemoteButtonPressed )
    {
        XDBGTRC( APP_TITLE_NAME_A, "A/OK/START Pressed" );

        g_bHighlightAButton = TRUE; // Highlight the A Button

        // Check to see if one of the buttons is a 'repeat' press.  If so, report FALSE for first press
        if( bControlPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else if( bRemoteButtonPressed && ( !bFirstPress3 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

        // Update the combo with the A Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'A';
        }

        // For the "Start" Button, we will send the "A" button signal to the menu, so that act identically
        g_pCurrentScreen->HandleInput( BUTTON_A, bFirstPress );
    }
    else
    {
        g_bHighlightAButton = FALSE; // Make sure the A Button isn't highlighted
    }

    // BACK CONTROL / B BUTTON
    bControlPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_BACK, &bFirstPress );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_B, BUTTON_THRESHOLD, &bFirstPress2 );
    bRemoteButtonPressed = Controllers.IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_REPLAY, &bFirstPress3 );
    if( bControlPressed || bButtonPressed || bRemoteButtonPressed )
    {
        XDBGTRC( APP_TITLE_NAME_A, "B/BACK AGAIN/BACK Pressed" );

        g_bHighlightBButton = TRUE; // Highlight the B Button

        // Check to see if one of the buttons is a 'repeat' press.  If so, report FALSE for first press
        if( bControlPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else if( bRemoteButtonPressed && ( !bFirstPress3 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

        // Update the combo with the B Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'B';
        }

        // For the "Back" Button, we will send the "B" button signal to the menu, so that act identically
        g_pCurrentScreen->HandleInput( BUTTON_B, bFirstPress );
    }
    else
    {
        g_bHighlightBButton = FALSE; // Make sure the B Button isn't highlighted
    }

    // X MENU BUTTON
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_X, BUTTON_THRESHOLD, &bFirstPress );
    bRemoteButtonPressed = Controllers.IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_MENU, &bFirstPress2 );
    if( bButtonPressed || bRemoteButtonPressed )
    {
        if( bButtonPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

        // Update the combo with the X Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'X';
        }

        g_pCurrentScreen->HandleInput( BUTTON_X, bFirstPress );
    }

    // Y BUTTON
    if( Controllers.IsButtonPressed( PORT_ANY, BUTTON_Y, BUTTON_THRESHOLD, &bFirstPress ) )
    {
        // Update the combo with the Y Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'Y';
        }

        g_pCurrentScreen->HandleInput( BUTTON_Y, bFirstPress );
    }

    // BLACK BUTTON
    if( Controllers.IsButtonPressed( PORT_ANY, BUTTON_BLACK, BUTTON_THRESHOLD, &bFirstPress ) )
    {
        // HACK: toggle between IP address and MAC address
        if( ( bFirstPress ) && ( g_bToggleIPInfo ) )
        {
            g_iDisplayAddress += 1;
            if (g_iDisplayAddress >= 4)
                g_iDisplayAddress = 0;
            g_bUpdateNameAddrTexture = TRUE;
        }

        // Update the combo with the Black Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'L';
        }

        g_pCurrentScreen->HandleInput( BUTTON_BLACK, bFirstPress );
    }

    // WHITE BUTTON
    if( Controllers.IsButtonPressed( PORT_ANY, BUTTON_WHITE, BUTTON_THRESHOLD, &bFirstPress ) )
    {
        // Update the combo with the White Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'W';
        }

        g_pCurrentScreen->HandleInput( BUTTON_WHITE, bFirstPress );
    }


    // UP DPAD
    bControlPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_UP, &bFirstPress );
    bRemoteButtonPressed = Controllers.IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_UP, &bFirstPress2 );
    if( bControlPressed || bRemoteButtonPressed )
    {
        if( bControlPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

        // Update the combo with the DPAD Up Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'U';
        }

        g_pCurrentScreen->HandleInput( CONTROL_DPAD_UP, bFirstPress );
    }

    // DOWN DPAD / REMOTE DOWN
    bControlPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_DOWN, &bFirstPress );
    bRemoteButtonPressed = Controllers.IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_DOWN, &bFirstPress2 );
    if( bControlPressed || bRemoteButtonPressed )
    {
        if( bControlPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

        // Update the combo with the DPAD Down Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'D';
        }

        g_pCurrentScreen->HandleInput( CONTROL_DPAD_DOWN, bFirstPress );
    }

    // LEFT DPAD
    bControlPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_LEFT, &bFirstPress );
    bRemoteButtonPressed = Controllers.IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_LEFT, &bFirstPress2 );
    if( bControlPressed || bRemoteButtonPressed )
    {
        if( bControlPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

        // Update the combo with the DPAD Left Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'F';
        }

        g_pCurrentScreen->HandleInput( CONTROL_DPAD_LEFT, bFirstPress );
    }

    // RIGHT DPAD
    bControlPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_RIGHT, &bFirstPress );
    bRemoteButtonPressed = Controllers.IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_RIGHT, &bFirstPress2 );
    if( bControlPressed || bRemoteButtonPressed )
    {
        if( bControlPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

        // Update the combo with the DPAD Right Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'R';
        }

        g_pCurrentScreen->HandleInput( CONTROL_DPAD_RIGHT, bFirstPress );
    }

    // LEFT THUMB BUTTON
    bControlPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_LEFT_THUMB, &bFirstPress );
    if( bControlPressed )
    {
        // Update the combo with the Left Thumb Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'T';
        }

        g_pCurrentScreen->HandleInput( CONTROL_LEFT_THUMB, bFirstPress );
    }

    // RIGHT THUMB BUTTON
    bControlPressed = Controllers.IsControlPressed( PORT_ANY, CONTROL_RIGHT_THUMB, &bFirstPress );
    if( bControlPressed )
    {
        // Update the combo with the Right Thumb Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'I';
        }

        g_pCurrentScreen->HandleInput( CONTROL_RIGHT_THUMB, bFirstPress );
    }

    // LEFT TRIGGER BUTTON
    if( Controllers.IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER, BUTTON_THRESHOLD, &bFirstPress ) )
    {
        // Update the combo with the Left-Trigger Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'E';
        }

        g_pCurrentScreen->HandleInput( BUTTON_LEFT_TRIGGER, bFirstPress );
    }

    // Right Trigger Button
    if( Controllers.IsButtonPressed( PORT_ANY, BUTTON_RIGHT_TRIGGER, BUTTON_THRESHOLD, &bFirstPress ) )
    {
        // Update the combo with the Right Trigger Button Position
        if( bFirstPress )
        {
            g_pszKeyCombo[g_uiKeyPos] = 'O';
        }

        g_pCurrentScreen->HandleInput( BUTTON_RIGHT_TRIGGER, bFirstPress );
    }


    // LEFT THUMB STICK
    nThumbY = Controllers.GetJoystickY( PORT_ANY, JOYSTICK_LEFT, JOYSTICK_DEAD_ZONE, &bFirstYPress );
    nThumbX = Controllers.GetJoystickX( PORT_ANY, JOYSTICK_LEFT, JOYSTICK_DEAD_ZONE, &bFirstXPress );
    if( ( nThumbY != 0 ) || ( nThumbX != 0 ) )
    {
        g_pCurrentScreen->HandleInput( JOYSTICK_LEFT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
    }
    
    // RIGHT THUMB STICK
    nThumbY = Controllers.GetJoystickY( PORT_ANY, JOYSTICK_RIGHT, JOYSTICK_DEAD_ZONE, &bFirstYPress );
    nThumbX = Controllers.GetJoystickX( PORT_ANY, JOYSTICK_RIGHT, JOYSTICK_DEAD_ZONE, &bFirstXPress );
    if( ( nThumbY != 0 ) || ( nThumbX != 0 ) )
    {
        g_pCurrentScreen->HandleInput( JOYSTICK_RIGHT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
    }

    return S_OK;
}

// Setup our Menus and Items for our application
HRESULT SetupMenusAndItems( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "  SetupMenusAndItems()" );

    HRESULT hr = S_OK;

    g_pRootMenu = &g_LaunchMenu;    // Set the launch menu as our "root" menu

    // Setup the Launch Menu
    hr = g_LaunchMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\root.mnu" );
    if( FAILED( hr ) )
        XDBGERR( APP_TITLE_NAME_A, "SetupMenusAndItems():Failed to add the launch item info!!" );

    // Setup the Error Msg Menu
    hr = g_ErrorMsgMenu.Init( FILE_DATA_MENU_DIRECTORY_A "\\errormsg.mnu" );
    if( FAILED( hr ) )
        XDBGERR( APP_TITLE_NAME_A, "SetupMenusAndItems():Failed to add the error message item info!!" );

    // Setup the Generic Keyboard Menu
    hr = g_GenKeyboardMenu.Init( MENU_GENKEYBOARD_MENU_FILENAME );
    if( FAILED( hr ) )
        XDBGERR( APP_TITLE_NAME_A, "SetupMenusAndItems():Failed to Init the Generic Keyboard menu!!" );

    // Setup our Message Menu
    hr = g_MessageMenu.Init( MENU_MESSAGE_MENU_FILENAME );
    if( FAILED( hr ) )
        XDBGERR( APP_TITLE_NAME_A, "SetupMenusAndItems():Failed to Init the Generic Message menu!!" );

    // Setup our Memory Display Menu
    hr = g_MADisplayMenu.Init( MADISPLAYMENU_FILENAME_A );
    if( FAILED( hr ) )
        XDBGERR( APP_TITLE_NAME_A, "SetupMenusAndItems():Failed to Init the Memory Area Display menu!!" );

    // Setup our Yes / No Menu
    hr = g_YesNoMenu.Init( MENU_YESNO_MENU_FILENAME_A );
    if( FAILED( hr ) )
        XDBGERR( APP_TITLE_NAME_A, "SetupMenusAndItems():Failed to Init the Yes / No menu!!" );

    return hr;
};


// This is used to obtain any information that is being passed to the
// XShell
extern "C" {
extern PLAUNCH_DATA_PAGE *LaunchDataPage;
}

DWORD
WINAPI
XGetLaunchInfoShell(
    OUT PDWORD pdwLaunchDataType,
    OUT PLD_LAUNCH_DASHBOARD pLaunchDashboard
    )
{
    RIP_ON_NOT_TRUE("XGetLaunchInfoShell()", (pdwLaunchDataType != NULL));
    RIP_ON_NOT_TRUE("XGetLaunchInfoShell()", (pLaunchDashboard != NULL));

    if( *LaunchDataPage )
    {
        *pdwLaunchDataType = (*LaunchDataPage)->Header.dwLaunchDataType;

        if( (*LaunchDataPage)->Header.dwLaunchDataType == LDT_LAUNCH_DASHBOARD )
            memcpy( pLaunchDashboard, (*LaunchDataPage)->LaunchData, sizeof( LD_LAUNCH_DASHBOARD ) );
        else if( (*LaunchDataPage)->Header.dwLaunchDataType == LDT_FROM_DASHBOARD )
            memcpy( pLaunchDashboard, (*LaunchDataPage)->LaunchData, sizeof( LD_FROM_DASHBOARD ) );

        PLAUNCH_DATA_PAGE pTemp = *LaunchDataPage;
        *LaunchDataPage = NULL;
        MmFreeContiguousMemory(pTemp);

        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_FOUND;
    }
}


// Will update the texture with the XDK TITLE on it
void UpdateTitleTexture( CUDTexture* pTexture )
{
    // Render the title to the texture
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    XFONT_SetTextHeight( g_pFont, MENUBOX_TITLE_TEXT_FONT_HEIGHT );
    pTexture->DrawText( MENUBOX_TITLE_TEXT_XPOS, MENUBOX_TITLE_TEXT_YPOS, MENUBOX_TITLE_TEXT_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%ls", g_pCurrentScreen->GetTitle() );
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    pTexture->Unlock();

    AlphaTexture( pTexture->GetTexture(), SCREEN_DEFAULT_TEXT_FG_COLOR );
}


// Will update the texture with the machine name and IP Address of the current Xbox
void UpdateAddressTexture( CUDTexture* pTexture )
{
    /////////////////////////////////////
    // Draw the machine name & IP Address
    /////////////////////////////////////

    // Lock the Address Texture so we can render on to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    #define ADR_TEX_BUFFSIZE    128

    WCHAR tempBuff[ADR_TEX_BUFFSIZE];
    ZeroMemory( tempBuff, ADR_TEX_BUFFSIZE * sizeof( WCHAR ) );

    char* machineName = g_XboxSettings.GetMachineName();

    if (g_bNetOK)
    {
        XNADDR xnaddr;
        UINT iTimeout = 500;    // Five seconds maximum just in case

        if (g_iDisplayAddress >= 2)
            while (XNetGetTitleXnAddr(&xnaddr) == 0 && iTimeout-- > 0) Sleep(10);
        else
            while (XNetGetDebugXnAddr(&xnaddr) == 0 && iTimeout-- > 0) Sleep(10);

        if (g_iDisplayAddress & 1)
            _snwprintf(tempBuff, ADR_TEX_BUFFSIZE, L"%S (%02x-%02x-%02x-%02x-%02x-%02x%S",
                       machineName, xnaddr.abEnet[0], xnaddr.abEnet[1], xnaddr.abEnet[2],
                       xnaddr.abEnet[3], xnaddr.abEnet[4], xnaddr.abEnet[5],
                       (g_iDisplayAddress >= 2) ? ") T" : ") D");
        else
            _snwprintf(tempBuff, ADR_TEX_BUFFSIZE, L"%S (%d.%d.%d.%d%S", machineName,
                       xnaddr.ina.S_un.S_un_b.s_b1, xnaddr.ina.S_un.S_un_b.s_b2, 
                       xnaddr.ina.S_un.S_un_b.s_b3, xnaddr.ina.S_un.S_un_b.s_b4,
                       (g_iDisplayAddress >= 2) ? ") T" : ") D");
    }
    else
    {
        _snwprintf(tempBuff, ADR_TEX_BUFFSIZE, L"%S", machineName);
    }

    XFONT_SetTextHeight( g_pFont, MENUBOX_NAMEADDR_TEXT_HEIGHT );

    float XPos = ( TEXTURE_XDKADDRESS_PIXEL_WIDTH / 2.0f ) - ( GetStringPixelWidth( tempBuff ) / 2.0f );
    pTexture->DrawText( XPos, MENUBOX_NAMEADDR_TEXT_YPOS, MENUBOX_NAMEADDR_TEXT_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", tempBuff );

    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    pTexture->Unlock();

    // Make the texture background transparent
    AlphaTexture( pTexture->GetTexture(), SCREEN_DEFAULT_TEXT_FG_COLOR );
}


// Process Special Key-Sequences
void ProcessKeySequences()
{
    BOOL bFirstPress = FALSE;

    if( Controllers.IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER, BUTTON_THRESHOLD, &bFirstPress ) &&
        Controllers.IsButtonPressed( PORT_ANY, BUTTON_RIGHT_TRIGGER, BUTTON_THRESHOLD, &bFirstPress ) )
    {
        if( Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_UP, &bFirstPress ) )
        {
            // PAL-I
            g_XboxSettings.SetAVRegion( XSETTINGS_DISPLAY_SETTING_PAL_I );
            XLaunchNewImage( NULL, NULL );
        }
        else if( Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_RIGHT, &bFirstPress ) )
        {
            // NTSC-M
            g_XboxSettings.SetAVRegion( XSETTINGS_DISPLAY_SETTING_NTSC_M );
            XLaunchNewImage( NULL, NULL );
        }
        else if( Controllers.IsControlPressed( PORT_ANY, CONTROL_DPAD_LEFT, &bFirstPress ) )
        {
            // NTSC-J
            g_XboxSettings.SetAVRegion( XSETTINGS_DISPLAY_SETTING_NTSC_J );
            XLaunchNewImage( NULL, NULL );
        }
    }
}


void AlphaTexture( IDirect3DTexture8* pTexture, DWORD dwColor )
{
    D3DXCOLOR newColor = D3DXCOLOR(dwColor);

	HRESULT          hr;
	D3DSURFACE_DESC  desc;
	
	pTexture->GetLevelDesc(0, &desc);
	D3DFORMAT format = desc.Format;

    if(format == D3DFMT_LIN_A8R8G8B8)
	{	
		pTexture->GetLevelDesc(0, &desc);
		int width        = desc.Width;
		int height       = desc.Height;

		D3DLOCKED_RECT textureInfo;
		hr = pTexture->LockRect(0, &textureInfo, NULL, 0);
		if( FAILED( hr ))
		{
            XDBGWRN( APP_TITLE_NAME_A, "AlphaTexture():Failed to lock the texture!!" );
		}
		
		DWORD *p = (DWORD*)textureInfo.pBits;
		DWORD counter = 0;

		D3DXCOLOR pixelColor;

		// for(int j = 0; j < (width * height); j++)
        for(int j = 0; j < (width * 22); j++)
		{
			pixelColor = D3DCOLOR(p[j]);
			pixelColor.a = pixelColor.r;  // assuming pixels are white, set alpha
			pixelColor.r = newColor.r;
			pixelColor.g = newColor.g;
			pixelColor.b = newColor.b;
			p[j] = pixelColor;
		}

		pTexture->UnlockRect(0);
		D3DXFilterTexture(pTexture, NULL, 0, D3DX_FILTER_LINEAR);
	}
	else
	{
        XDBGWRN( APP_TITLE_NAME_A, "AlphaTexture():Invalid Texture Format!!" );
	}

}


// Get the current Width of the screen
unsigned int GetScreenWidth()
{
    D3DDISPLAYMODE  d3dDisplayMode;
    ZeroMemory( &d3dDisplayMode, sizeof( d3dDisplayMode ) );

    HRESULT hr = g_pD3DDevice->GetDisplayMode( &d3dDisplayMode );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::GetScreenWidth():Failed to get the Display Mode!! Error - '0x%.8X (%d)'", hr, hr );

        return 0;
    }

    return d3dDisplayMode.Width;
}


// Get the current Height of the screen
unsigned int GetScreenHeight()
{
    D3DDISPLAYMODE  d3dDisplayMode;
    ZeroMemory( &d3dDisplayMode, sizeof( d3dDisplayMode ) );

    HRESULT hr = g_pD3DDevice->GetDisplayMode( &d3dDisplayMode );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::GetScreenHeight():Failed to get the Display Mode!! Error - '0x%.8X (%d)'", hr, hr );

        return 0;
    }

    return d3dDisplayMode.Height;
}


// Check to see if an MU has been inserted or removed, and properly Mounts, or
// Dismounts the MUs
void CheckMUs( void )
{
    DWORD dwMUInsertions;
    DWORD dwMURemovals;

    // If the state has changed, update our texture and our previous mask
    g_bMUsChanged = XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwMUInsertions, &dwMURemovals );
    if( g_bMUsChanged )
    {
        // Mount or Unmount our MU's
        for( unsigned int x = 0; x < NUM_XBOX_MU_SLOTS; ++x )
        {
            // Check to see if the MU was removed
            if( dwMURemovals & g_dwMUBitMask[x] )
            {
                // Remove the MU from our Mask
                g_dwInsertedMUs = g_dwInsertedMUs & ( ~ g_dwMUBitMask[x] );

                // Unmount the MU
                g_MemoryUnits[x].Unmount();

            }

            // Check to see if the MU is inserted
            if( dwMUInsertions & g_dwMUBitMask[x] )
            {
                // Add the MU to our Mask
                g_dwInsertedMUs = g_dwInsertedMUs | g_dwMUBitMask[x];

                // Mount the MU
                g_MemoryUnits[x].Mount();
            }
        }
    }
}


// Used to display a generic message to the user
void DisplayMessage( WCHAR* pwszTitle, WCHAR* pwszFormat, ... )
{
    if( NULL == pwszFormat )
        return;

    WCHAR pwszBuffer[4096];

    va_list args;
    va_start( args, pwszFormat );

    vswprintf( pwszBuffer, pwszFormat, args );

    if( NULL == pwszTitle )
        g_MessageMenu.SetTitle( MENU_TITLE_MESSAGE );
    else
        g_MessageMenu.SetTitle( pwszTitle );

    g_MessageMenu.SetText( pwszBuffer );
    g_MessageMenu.SetParent( g_pCurrentScreen );

    g_pCurrentScreen->Leave( &g_MessageMenu );

    va_end(args);
}


// Used to display a generic error message to the user
void DisplayErrorMessage( WCHAR* pwszFormat, ... )
{
    if( NULL == pwszFormat )
        return;

    va_list args;
    va_start( args, pwszFormat );

    DisplayMessage( L"Error", pwszFormat, args );

    va_end(args);
}

// Used to display a generic error message to the user
void DisplayYesNoMessage( WCHAR* pwszTitle, WCHAR* pwszFormat, ... )
{
    if( NULL == pwszFormat )
        return;

    WCHAR pwszBuffer[4096];

    va_list args;
    va_start( args, pwszFormat );

    vswprintf( pwszBuffer, pwszFormat, args );

    if( NULL == pwszTitle )
        g_YesNoMenu.SetTitle( MENU_TITLE_YESNO );
    else
        g_YesNoMenu.SetTitle( pwszTitle );

    g_YesNoMenu.SetText( pwszBuffer );
    g_YesNoMenu.SetParent( g_pCurrentScreen );

    g_pCurrentScreen->Leave( &g_YesNoMenu );

    va_end(args);
}


// Used to determine if the Yes/No menu was cancelled
BOOL YesNoMenuCancelled()
{
    return g_YesNoMenu.GetCancelled();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\xonlinefuncs.cpp ===
/////////////////////////////////////////////////////////
// Much of the code in this file was originally written
// by Dan Rosenstein (danrose)
//
// It was copied and modified by James Helm (jimhelm)
// for use in the XDK Launcher on 2/12/2002
/////////////////////////////////////////////////////////

#include "stdafx.h"
#include "xonlinefuncs.h"

static XONLINETASK_HANDLE g_hOnlineTask = NULL;  // Global Online Task handle
static char g_pszOnlineClusterName[MAX_PATH+1];
static char g_pszOnlineRealmName[MAX_PATH+1];

///////////////////////////////////////////////////////////////////////////////
// Name: QuickLoginStart
// Description: does a quick logon to the user account creation server
///////////////////////////////////////////////////////////////////////////////
HRESULT OnlineQuickLoginStart( void )
{
	//
	// handles to communicate with Xbox Online
	//

	HRESULT hr = S_OK;
	HRESULT hrTask = S_OK;
	HANDLE hEvent = NULL;

	DWORD dwWait = 0;

	// create the event handle, make sure it is valid
	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	if ( NULL == hEvent )
        return( E_FAIL );

	// since no users will be logged in (this is just a ping), we
	// want to only hit the user account server
    DWORD aServices[] = { XONLINE_USER_ACCOUNT_SERVICE };

	// create the user array, zero it out
	XONLINE_USER aUsers[XONLINE_MAX_LOGON_USERS];
	ZeroMemory( aUsers, sizeof( aUsers ) );

	// generate the async logon to the user account service
	hr = XOnlineLogon( aUsers, 
                       aServices,
                       sizeof( aServices ) / sizeof( DWORD ),
                       hEvent,
                       &g_hOnlineTask );

    // pump the task handle until logon completes
	if ( SUCCEEDED( hr ) )
	{
		do
		{   
			// wait for data to be ready for processing
			dwWait = WaitForSingleObject( hEvent, ONLINE_ACCOUNT_WAIT_INTERVAL );

			// see if the wait failed due to memory
			if ( WAIT_FAILED == dwWait )
            {
				hr = E_FAIL;
                break;
            }

			// see if the wait timed out
			if ( WAIT_TIMEOUT == dwWait )
            {
				hr = E_FAIL;
                break;
            }

			// continue pumping the handle
			hrTask = XOnlineTaskContinue( g_hOnlineTask );

		} while( hrTask == XONLINETASK_S_RUNNING ); 
	}

    // close the event
    if ( NULL != hEvent )
    {
        CloseHandle( hEvent );
        hEvent = NULL;
    }

    // Return the proper error code
    if( XONLINETASK_S_RUNNING == hrTask )
        return( hr );
    else
        return XOnlineLogonTaskGetResults( g_hOnlineTask );
}


///////////////////////////////////////////////////////////////////////////////
// Name: QuickLoginFinish
// Description: does a quick logoff to the user account creation server
///////////////////////////////////////////////////////////////////////////////
HRESULT OnlineQuickLoginFinish( void )
{
	HRESULT hr = S_OK;

	// close the handle, wether we have falied or not
	if ( NULL != g_hOnlineTask )
    {
		hr = XOnlineTaskClose( g_hOnlineTask );
        g_hOnlineTask = NULL;
    }

	// spit back the hr
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Name: GenerateUserName
// Input: wszUserName - a WCHAR array of XONLINE_NAME_SIZE bytes to get 
//        the new user name                      
// Description: create a random user name based on the Ethernet MAC address
//              and 7 bytes of charecter values
///////////////////////////////////////////////////////////////////////////////
HRESULT OnlineGenerateUserName( WCHAR wszName[XONLINE_NAME_SIZE] )
{
    if( NULL == wszName )
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    char pszUserName[XONLINE_NAME_SIZE];
    pszUserName[XONLINE_NAME_SIZE - 1] = '\0';

    hr = OnlineGenerateUserName( pszUserName );
    if( FAILED( hr ) )
        return hr;

    // Convert the user name to a WCHAR string and copy it to the users string
    swprintf( wszName, L"%hs", pszUserName );

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Name: GenerateUserName
// Input: szUserName - an array of XONLINE_NAME_SIZE bytes to get 
//        the new user name                      
// Description: create a random user name based on the Ethernet MAC address
//              and 7 bytes of charecter values
///////////////////////////////////////////////////////////////////////////////
HRESULT OnlineGenerateUserName( CHAR szName[XONLINE_NAME_SIZE] )
{
    if( NULL == szName )
        return E_INVALIDARG;

	HRESULT hr = S_OK;

	DWORD dwStatus = 0;
	DWORD dwType = 0;
	DWORD cbResultLength = 0;

	CHAR abMacAddress[6];
    ZeroMemory( abMacAddress, 6 );

    // Clear out the memory that was passed to us
    ZeroMemory( szName, XONLINE_NAME_SIZE );

	// get the Ethernet MAC address
	dwStatus = ExQueryNonVolatileSetting( XC_FACTORY_ETHERNET_ADDR, &dwType, abMacAddress, 6, &cbResultLength );
	hr = NT_SUCCESS( dwStatus ) ? S_OK : E_FAIL;

    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Could not get ethernet MAC address!! Error - '0x%08X', '%d'", hr, hr );
        return hr;
    }

	// populate user name with the last 4 bytes of the ethernet mac address
	for ( DWORD i = 0; i < 4; i++ )
        sprintf( szName + i * 2, "%02x", (BYTE) abMacAddress[i + 2] );  // print the current byte

	// seed the random number generator
	srand( time( NULL ) );

	// stuff the last 7 bytes with a random char
	sprintf( szName + 8,
             "%c%c%c%c%c%c%c", 
             (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
             (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
             (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
             (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
             (BYTE) rand() % ( 'Z' - 'A' ) + 'A', 
             (BYTE) rand() % ( 'Z' - 'A' ) + 'A', 
             (BYTE) rand() % ( 'Z' - 'A' ) + 'A' );

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Name: GenerateUserAccount
// Input: pOnlineUser - the user to fill in                     
// Description: fill in and create a user
///////////////////////////////////////////////////////////////////////////////
HRESULT OnlineGenerateUserAccount( PXONLINE_USER pOnlineUser )
{
	HRESULT hr = S_OK;

    HRESULT hrCreateResult = S_OK;      // This will be used to return the actual return code of the account creation
	HRESULT hrTask = S_OK;
	HANDLE hEvent = NULL;

	XONLINETASK_HANDLE hTask = NULL;

	DWORD dwWait = 0;

	HRESULT hrGenName = S_OK;

    // Make sure we have room on the hard drive to store a new user
    DWORD dwNumUsers;
    XONLINE_USER aExistingUsers[XONLINE_MAX_STORED_ONLINE_USERS];

    hr = OnlineGetUsersFromHD( (PXONLINE_USER) aExistingUsers, &dwNumUsers );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():OnlineGetUsersFromHD Failed!! - '0x%08X', '%d'", hr, hr );
        return E_FAIL;
    }

    if( XONLINE_MAX_HD_ONLINE_USERS == dwNumUsers )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():Max users (%u) already exist on the hard drive!!", dwNumUsers );
        // BUGBUG: TODO: Return an error code so that the app can determine the hard drive is full!!
        return E_FAIL;
    }

    // Logon
    hr = OnlineQuickLoginStart();
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():Unable to logon!! - '0x%08X', '%d'", hr, hr );
        if( FAILED( OnlineQuickLoginFinish() ) )
            XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():OnlineQuickLoginFinish failed!!" );
        return hr;
    }

	// create the event handle, make sure it is valid
	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	if ( NULL == hEvent )
        return E_FAIL;

	// create the account
	hr = _XOnlineAccountTempCreate( (PXONLINE_USER) pOnlineUser, hEvent, &hTask );
    if( FAILED( hr ) )
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():_XOnlineAccountTempCreate Failed!! Error - '0x%08X', '%d'", hr, hr );

    if( SUCCEEDED( hr ) )
    {
	    // pump the task handle until user creation completes
	    do
	    {   
		    // wait for data to be ready for processing
		    dwWait = WaitForSingleObject( hEvent, ONLINE_ACCOUNT_WAIT_INTERVAL );

            if ( WAIT_FAILED == dwWait )
		    {
                hr = E_FAIL;
                break;
		    }
		    else if ( WAIT_TIMEOUT == dwWait )  // make sure the wait did not time out
		    {
			    hr = E_FAIL;
                break;
		    }

		    hrTask = XOnlineTaskContinue( hTask );  // continue pumping the handle
	    } while( XONLINETASK_S_RUNNING == hrTask );

        hrCreateResult = hrTask;
    }

    // if the name was taken, zero it out
    // TODO: Use this in an error message
	// if( XUAC_E_NAME_TAKEN == hrTask )

	// Now retrieve the created account
    if ( SUCCEEDED( hr ) && SUCCEEDED( hrCreateResult ) )
    {
		hr = _XOnlineAccountTempCreateGetResults( hTask, (PXONLINE_USER) pOnlineUser );
        if( FAILED( hr ) )
            XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():Creation of temp account failed!! Error - '0x%08X', '%d'", hr, hr );

        /*
        // close the handle, even if we have failed
	    if ( NULL != hTask )
	    {
		    hrTask = XOnlineTaskClose( hTask );
            if( FAILED( hrTask ) )
                XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():Could not close handle!! Error - '0x%08X', '%d'", hrTask, hrTask );
            else
		        hTask = NULL;
	    }
        */

        // Add the account to the hard drive
        if( SUCCEEDED( hr ) )
        {
            hr = _XOnlineAddUserToHD( (PXONLINE_USER) pOnlineUser );
            if( FAILED( hr ) )
                XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():Creation of temp account failed!! Error - '0x%08X', '%d'", hr, hr );

        }
    }

    // close down the handle
	if ( NULL != hTask )
	{
		hrTask = XOnlineTaskClose( hTask );
        if( FAILED( hrTask ) )
            XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():Could not close handle!! Error - '0x%08X', '%d'", hrTask, hrTask );
        else
		    hTask = NULL;
	}

    // Logoff
    hr = OnlineQuickLoginFinish();
    if( FAILED( hr ) )
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGenerateUserAccount():Failed to logoff!! - '0x%08X', '%d'", hr, hr );

    // close the event
    if ( NULL != hEvent )
    {
        CloseHandle( hEvent );
        hEvent = NULL;
    }

    // Return the proper error code
    if( XONLINETASK_S_RUNNING == hrCreateResult )
        return( hr );
    else
        return( hrCreateResult );
}

// Will retrieve users from the hard drive
HRESULT OnlineGetUsersFromHD( PXONLINE_USER paOnlineUsers, DWORD* pdwNumUsers )
{
    if( ( NULL == paOnlineUsers ) || ( NULL == pdwNumUsers ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGetNumHDUsers():Invalid argument(s) passed in!!" );
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    // Store 0 in the number of users (Not sure what the XOnline API does in a failure case)
    *pdwNumUsers = 0;

    // Zero out our array of users
    ZeroMemory( paOnlineUsers, sizeof( XONLINE_USER ) * XONLINE_MAX_STORED_ONLINE_USERS );
    
    hr = _XOnlineGetUsersFromHD( (PXONLINE_USER) paOnlineUsers, pdwNumUsers );
    if( FAILED( hr ) )
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGetUsersFromHD():Failed to get the users from the hard drive!!" );

    return hr;
}


// Will remove the specified user from the hard drive
HRESULT OnlineRemoveUserFromHD( PXONLINE_USER pOnlineUser )
{
    if( NULL == pOnlineUser )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineRemoveUserFromHD():Invalid argument(s) passed in!!" );
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    hr = _XOnlineRemoveUserFromHD( pOnlineUser );
    if( FAILED( hr ) )
        XDBGWRN( APP_TITLE_NAME_A, "OnlineRemoveUserFromHD():_XOnlineRemoveUserFromHD Failed! - '0x%08X', '%d'", hr, hr );

    return hr;
}


// Gets the user information from an MU and returns it
// We're wrapping the call to the XOnline API in case that API changes in the future
HRESULT OnlineGetUserFromMU( DWORD dwPort, DWORD dwSlot, PXONLINE_USER pOnlineUser, BOOL* pbUserExists/*=NULL*/ )
{
    if( NULL == pOnlineUser )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGetUserFromMU():Invalid argument(s) passed in!!" );
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    // Zero out the online user memory passed in
    ZeroMemory( pOnlineUser, sizeof( XONLINE_USER ) );

    hr = _XOnlineGetUserFromMU( dwPort, dwSlot, (PXONLINE_USER) pOnlineUser );
    if( FAILED( hr ) && ( XONLINE_E_NO_USER != hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGetUserFromMU():_XOnlineGetUserFromMU Failed!! - '0x%08X', '%d'", hr, hr );
    }
    else // Success or No User
    {
        if( XONLINE_E_NO_USER == hr )  // Check to see if the Online API returned "No User"
        {
            hr = S_OK;  // Don't return an error in this case
            if( NULL != pbUserExists)
                *pbUserExists = FALSE;
        }
        else // A user does exist on the MU
        {
            if( NULL != pbUserExists)
                *pbUserExists = TRUE;
        }
    }

    return hr;
}


// Will remove the user from the specified MU
HRESULT OnlineClearUserFromMU( char cDriveLetter )
{
    XONLINE_USER OnlineUser;
    ZeroMemory( &OnlineUser, sizeof( OnlineUser ) );

    return OnlineSetUserInMU( cDriveLetter, &OnlineUser );
}


// Will store the specified user on the specified MU
HRESULT OnlineSetUserInMU( char cDriveLetter, PXONLINE_USER pOnlineUser )
{
    if( NULL == pOnlineUser )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineSetUserInMU():Invalid argument(s) passed in!!" );
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    hr = _XOnlineSetUserInMU( cDriveLetter, (PXONLINE_USER) pOnlineUser );
    if( FAILED( hr ) )
        XDBGWRN( APP_TITLE_NAME_A, "OnlineSetUserInMU():_XOnlineSetUserInMU Failed!! - '0x%08X', '%d'", hr, hr );

    return hr;
}


// Will add a user to the hard drive
HRESULT OnlineAddUserToHD( PXONLINE_USER pOnlineUser )
{
    if( NULL == pOnlineUser )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineAddUserToHD():Invalid argument(s) passed in!!" );
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    hr = _XOnlineAddUserToHD( pOnlineUser );
    if( FAILED( hr ) )
        XDBGWRN( APP_TITLE_NAME_A, "OnlineAddUserToHD():_XOnlineAddUserToHD Failed!! - '0x%08X', '%d'", hr, hr );

    return hr;
}


// Will return true if the user already exists on the Hard Drive
HRESULT OnlineIsUserOnHD( char* pszUserName, BOOL* pbUserExists )
{
    if( ( NULL == pszUserName ) || ( NULL == pbUserExists ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineIsUserOnHD():Invalid argument(s) passed in!!" );
        return E_INVALIDARG;
    }

    *pbUserExists = FALSE;
    DWORD dwNumUsers;
    XONLINE_USER  aOnlineUsers[XONLINE_MAX_STORED_ONLINE_USERS];

    HRESULT hr = OnlineGetUsersFromHD( (PXONLINE_USER) aOnlineUsers, &dwNumUsers );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineIsUserOnHD():OnlineGetUsersFromHD Failed!! - '0x%08X', '%d'", hr, hr );
    }
    else
    {
        if( 0 == dwNumUsers )
        {
            XDBGWRN( APP_TITLE_NAME_A, "OnlineIsUserOnHD():No Users Found" );
        }
        else
        {
            for( unsigned int x = 0; x < dwNumUsers; x++ )
            {
                if( 0 == _stricmp( aOnlineUsers[x].name, pszUserName ) )
                {
                    *pbUserExists = TRUE;
                    break;
                }
            }
        }
    }

    return hr;
}


// Used to determine if a user name is valid before creating
BOOL OnlineIsNameValid( WCHAR* pwszUserName )
{
    if( NULL == pwszUserName ) 
        return FALSE;

    // Check the length
    unsigned int uiStrLength = wcslen( pwszUserName );
    if(  uiStrLength < ONLINE_USERNAME_MINIMUM_SIZE )
        return FALSE;

    // Make sure the name begins with a letter
    if( ( pwszUserName[0] < 'A' || pwszUserName[0] > 'z' ) ||
        ( pwszUserName[0] > 'Z' && pwszUserName[0] < 'a' ) )
        return FALSE;

    // Check for invalid characters
    for( unsigned int x = 0; x < uiStrLength; x++ )
    {
        // If invalid character, return FALSE
        if( NULL != wcschr( ONLINE_USERNAME_INVALID_CHARACTERS, pwszUserName[x] ) )
            return FALSE;
    }

    return TRUE;
}

// Get the current Realm users should be in
char* OnlineGetCurrentRealm()
{
    static bParsedINIForRealm = FALSE;

    if( !bParsedINIForRealm )
    {
        bParsedINIForRealm = TRUE;

        if( !OnlineGetValueFromINI( ONLINE_INI_REALM_KEYNAME, g_pszOnlineRealmName, MAX_PATH ) )
        {
            strcpy( g_pszOnlineRealmName, "Mar2002" );
        }
    }

    return g_pszOnlineRealmName;
}


// Get the current Cluster we are pointed to
char* OnlineGetCurrentCluster()
{
    static bParsedINIForCluster = FALSE;

    if( !bParsedINIForCluster )
    {
        bParsedINIForCluster = TRUE;
        if( !OnlineGetValueFromINI( ONLINE_INI_CLUSTER_KEYNAME, g_pszOnlineClusterName, MAX_PATH ) )
        {
            strcpy( g_pszOnlineClusterName, "PartnerNet" );
        }
    }

    return g_pszOnlineClusterName;
}


// Retreive a value from the XOnline INI
BOOL OnlineGetValueFromINI( char* pszKeyName, char* pszDestBuffer, unsigned int uiBufSize )
{
    BOOL bReturn = FALSE;
    FILE* pfInFile = fopen( ONLINE_INI_FILE_PATH, "rt" );
    if( NULL == pfInFile )
    {
        XDBGWRN( APP_TITLE_NAME_A, "OnlineGetValueFromINI():Unable to open the file!! - '%hs'", ONLINE_INI_FILE_PATH );
        return bReturn;
    }
    else
    {
        char pszFileLine[MAX_PATH+1];
        pszFileLine[MAX_PATH] = '\0';

        while( fgets( pszFileLine, MAX_PATH, pfInFile ) )
        {
            pszFileLine[strlen(pszFileLine)-1] = '\0';  // Remove the /n

            if( strstr( pszFileLine, pszKeyName )  )
            {
                char* pszEQLoc = strstr( pszFileLine, "=" );
                if( NULL == pszEQLoc )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "OnlineGetValueFromINI():Did not find '=' in file line!! - '%hs'", pszFileLine );
                    bReturn = FALSE;
                    break;
                }
                else
                {
                    pszEQLoc++; // Move the pointer over the equal sign
                    strcpy( pszDestBuffer, pszEQLoc );
                    bReturn = TRUE;
                    break;
                }
            }
        }

        fclose( pfInFile );
        pfInFile = NULL;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\xbelist.h ===
/*****************************************************
*** xbelist.h
***
*** Header file for our XBE List class.
*** This class will hold a linked list of XBE's that
*** will be populated from a directory.
***
*** by James N. Helm
*** December 2nd , 2000
***
*****************************************************/

#ifndef _XBELIST_H_
#define _XBELIST_H_

#include <xbeimage.h>

#define XBE_INITIAL_HEADER_SIZE     4096

class CXBEList
{
public:
    // Constructors and Destructors
    CXBEList();
    ~CXBEList();

    // Methods
    HRESULT Init( char* dirname, char* fileExt );                                               // Initialize the list from a directory, loading files of a certain type
    unsigned int GetNumItems() { return m_XBEItems.GetNumItems(); };                            // Get the number of items currently in our list
    char* GetXBEName( unsigned int index ) { return m_XBEItems[index]->filename; };             // Get the name of an XBE by index
    char* GetXBEDir( unsigned int index ) { return m_XBEItems[index]->directory; };             // Get the directory of an XBE by index
    WCHAR* GetXBETitle( unsigned int index ) { return m_XBEItems[index]->titleName; };          // The title name of the XBE as in the XBE CERT Information
    void SetStopXBEEnumeration( BOOL bStop ) { m_bStopEnumeration = bStop; };                   // Stops the enumeration of XBE's

private:
    class _XBEINFO
    {
    public:
        char directory[MAX_PATH + 1];
        char filename[MAX_PATH + 1];
        WCHAR titleName[XBEIMAGE_TITLE_NAME_LENGTH + 1];

        BOOL operator > ( const _XBEINFO& item )
        {
            if( _wcsicmp( titleName, item.titleName ) > 0 )
                return TRUE;

            return FALSE;
        }

        BOOL operator < ( const _XBEINFO& item )
        {
            if( _wcsicmp( titleName, item.titleName ) < 0 )
                return TRUE;

            return FALSE;
        }

        BOOL operator == ( const _XBEINFO& item )
        {
            if( _wcsicmp( titleName, item.titleName ) == 0 )
                return TRUE;

            return FALSE;
        }
    };

    // Private Properties
    CLinkedList< _XBEINFO* > m_XBEItems;                    // XBE Item list
    BOOL m_bInitialized;                                    // Determines if we've already populated
    BOOL m_bStopEnumeration;                                // Used to abort XBE Enumeration

    // Private Methods
#ifdef COOL_XDASH
    HRESULT LoadXBEs( char* dirname,                        // Load the XBEs in to our Linked List
                      char* fileExt,
                      unsigned short usLevel );
#else
    HRESULT LoadXBEs( char* dirname,                        // Load the XBEs in to our Linked List
                      char* fileExt );
#endif // COOL_XDASH
    HRESULT GetInfoFromXBE( _XBEINFO* currentXBE,           // Will parse an XBE file and return the Title Name and Publisher Name
                            BOOL& bValidXBE,
                            char* pszDrive );
    HRESULT ProcessFile( char* pszFileName,                 // Process a file and add it to our list if it is valid
                         char* pszDrive,
                         char* pszDirectory,
                         char* pszExtension );

    BOOL StopEnumeration() { return m_bStopEnumeration; };  // Used to determine if we should stop XBE Enumeration
};

#endif // _XBELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\xbelist.cpp ===
/*****************************************************
*** xbelist.cpp
***
*** CPP file for our XBE List class.
*** This class will hold a linked list of XBE's that
*** will be populated from a directory.
***
*** by James N. Helm
*** December 2nd , 2000
***
*****************************************************/

#include "stdafx.h"
#include "xbelist.h"

extern CHardDrive   g_XboxHardDrive;    // Used to configure the Xbox Hard Drive

// Constructor
CXBEList::CXBEList()
: m_bInitialized( FALSE ),
m_bStopEnumeration( FALSE )
{
    m_XBEItems.SetDeleteDataItem( TRUE );
    m_XBEItems.SetSortedList( TRUE );
}

// Destructor
CXBEList::~CXBEList()
{
}


// Will parse an XBE file and return the Title Name and Publisher Name
// If the XBE is valid, bValidXBE will be TRUE, otherwise FALSE
HRESULT CXBEList::GetInfoFromXBE( _XBEINFO* currentXBE, BOOL& bValidXBE, char* pszDrive )
{
    if( ( NULL == currentXBE ) || ( NULL == pszDrive ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Invalid arg passed in!!" );

        return E_INVALIDARG;
    }

    bValidXBE = FALSE;                      // Set the initial return BOOLean to 'FALSE' -- only set it to TRUE if we end up with a valid XBE
    PVOID pVarImageHeader = NULL;           // Pointer to our variable image header.
    DWORD dwCertLocationOffset = 0;         // Offset in the file where the CERT information lives
    int numRead = 0;                        // Number of 'pages' read using fread
    HRESULT hr = S_OK;                      // Return Code
    FILE* pXBEFile = NULL;                  // Used to open the XBE file
    char pszfileNameBuffer[MAX_PATH + 1];   // Used to hold the file name
    XBEIMAGE_HEADER InitialXBEHeader;       // Will hold the initial header of our XBE file

    // Clear our buffers our buffers
    ZeroMemory( pszfileNameBuffer, MAX_PATH + 1 );

    _snprintf( pszfileNameBuffer, MAX_PATH, "%s%s\\%s%s", pszDrive, currentXBE->directory, currentXBE->filename, FILE_EXECUTABLE_EXENSION_A );

    pXBEFile = fopen( pszfileNameBuffer, "rbR" );
    if( NULL == pXBEFile )
    {
        // Couldn't open the XBE file, return "FALSE" as to the XBE validity
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Failed to open the file!! - '%s'", pszfileNameBuffer );

        hr = S_OK;
        goto cleanup;
    }

    numRead = fread( &InitialXBEHeader, sizeof( XBEIMAGE_HEADER ), 1, pXBEFile );
    if( 1 != numRead )
    {
        // Header wasn't big enough to be a valid XBE file, return "FALSE" as to the XBE validity
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Header wasn't big enough - expected 1, got - '%d'", numRead );

        // Clean up and return
        hr = S_OK;
        goto cleanup;
    }

    if( InitialXBEHeader.Signature != XBEIMAGE_SIGNATURE )
    {
        // Signature didn't match, return "false" as to the XBE validity
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Invalid XBE signature" );

        // Clean up and return
        hr = S_OK;
        goto cleanup;
    }

    // Calculate the offset in the file where the CERT size is located
    dwCertLocationOffset = (ULONG)InitialXBEHeader.Certificate - (ULONG)InitialXBEHeader.BaseAddress;

    // Seek to that location in the file and read in the XBOX CERT
    if( 0 != fseek( pXBEFile, dwCertLocationOffset, SEEK_SET ) )
    {
        // Return FALSE
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Could not fseek to proper file location!! Tried - '%d'", dwCertLocationOffset );

        goto cleanup;
    }

    // Read in the information in to our XCERT
    XBEIMAGE_CERTIFICATE XBECert;
    numRead = fread( &XBECert, sizeof( XBEIMAGE_CERTIFICATE ), 1, pXBEFile );
    if( 1 != numRead )
    {
        // Return FALSE
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Could not read the CERT from the file!! - expected 1, got - '%d'", numRead );

        goto cleanup;
    }

    // Now that we have the cert, let's copy the Title Information and Publisher information in to our structure
    char titleName[XBEIMAGE_TITLE_NAME_LENGTH + 1];

    _snwprintf( currentXBE->titleName, XBEIMAGE_TITLE_NAME_LENGTH, L"%s", XBECert.TitleName );

    bValidXBE = TRUE;

cleanup:

    if( NULL != pXBEFile )
    {
        fclose( pXBEFile );
    }

    return hr;
}


// Initialize our list
//
// dirname - the name of the directory to parse
// fileExt - the extension of the file to use
HRESULT CXBEList::Init( char* dirname, char* fileExt )
{
    HRESULT hr = S_OK;

    if( m_bInitialized )
        hr = m_XBEItems.EmptyList();    // Ensure our list is empty

    if( SUCCEEDED( hr ) )
    {
        m_bInitialized = FALSE;
#ifdef COOL_XDASH
        hr = LoadXBEs( dirname, fileExt, 1 );
#else
        hr = LoadXBEs( dirname, fileExt );
#endif // COOL_XDASH

        if( StopEnumeration() )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CXBEList::Init():Aborting the XBE Load" );
            return hr;
        }

        // Check for the Dashboard on the Y partition
        if( g_XboxHardDrive.FileExists( FILE_DATA_DASHBOARD_LOCATION_A ) )
        {
            HRESULT hrFileStatus = ProcessFile( FILE_DATA_DASHBOARD_FILENAME_A, FILE_DATA_DASHBOARD_DRIVE_A, FILE_DATA_DASHBOARD_DIRECTORY_A, fileExt );
            if( FAILED( hrFileStatus ) )
                XDBGWRN( APP_TITLE_NAME_A, "CXBEList::Init():Failed to process the file!! File - '%hs', Dir - '%hs', Error - '0x%.8X (%d)'", FILE_DATA_DASHBOARD_FILENAME_A, FILE_DATA_DASHBOARD_DIRECTORY_A, hrFileStatus, hrFileStatus );
        }

        // Check for the Online Dashboard on the Y partition
        if( g_XboxHardDrive.FileExists( FILE_DATA_ONLINE_DASHBOARD_LOCATION_A ) )
        {
            HRESULT hrFileStatus = ProcessFile( FILE_DATA_ONLINE_DASHBOARD_FILENAME_A, FILE_DATA_DASHBOARD_DRIVE_A, FILE_DATA_DASHBOARD_DIRECTORY_A, fileExt );
            if( FAILED( hrFileStatus ) )
                XDBGWRN( APP_TITLE_NAME_A, "CXBEList::Init():Failed to process the file!! File - '%hs', Dir - '%hs', Error - '0x%.8X (%d)'", FILE_DATA_ONLINE_DASHBOARD_FILENAME_A, FILE_DATA_DASHBOARD_DIRECTORY_A, hrFileStatus, hrFileStatus );
        }

        // Check for DEFAULT.XBE on the A partition (DVD Drive)
        if( g_XboxHardDrive.FileExists( FILE_DATA_DEFAULT_LOCATION_A ) )
        {
            HRESULT hrFileStatus = ProcessFile( FILE_DATA_DEFAULT_FILENAME_A, FILE_DATA_DVD_DRIVE_A, FILE_DATA_DVD_DRIVE_A, fileExt );
            if( FAILED( hrFileStatus ) )
                XDBGWRN( APP_TITLE_NAME_A, "CXBEList::Init():Failed to process the file!! File - '%hs', Dir - '%hs', Error - '0x%.8X (%d)'", FILE_DATA_DEFAULT_FILENAME_A, FILE_DATA_DVD_DRIVE_A, hrFileStatus, hrFileStatus );
        }

        if( SUCCEEDED( hr ) )
            m_bInitialized = TRUE;
        else // Clean up our list if we are in a bad way
            m_XBEItems.EmptyList();
    }

    return hr;
}


// Load the XBEs in to our Linked List
#ifdef COOL_XDASH
HRESULT CXBEList::LoadXBEs( char* dirname, char* fileExt, unsigned short usLevel )
{
    if( usLevel >= 3 )
        return S_OK;
#else
HRESULT CXBEList::LoadXBEs( char* dirname, char* fileExt )
{
#endif // COOL_XDASH

    // Ensure we were passed valid parameters
    if( ( NULL == dirname ) || ( NULL == fileExt ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::LoadXBEs():Invalid arguments passed in!!" );

        return E_INVALIDARG;
    }

    char searchPath[MAX_PATH];
    char nextPath[MAX_PATH];
    _snprintf( searchPath, MAX_PATH, "%s\\*.*", dirname );

    WIN32_FIND_DATA wfd;
    HANDLE hFind;

    // Find the first file in the directory
    hFind = FindFirstFile( searchPath, &wfd );

    // If FindFirstFile failed with an error, return E_FAIL
    if( INVALID_HANDLE_VALUE == hFind )
    {
        return E_FAIL;
    }

    // Parse the directories looking for the correct file types
    do
    {
        // Skip over files that we are not interested in
		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM )
		{
			continue;
		}

		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )
		{
			continue;
		}

		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY )
		{
			continue;
		}

		if ( '.' == wfd.cFileName[0] )
		{
			continue;
		}

        // If we found a directory, recursively call this function
        if( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            _snprintf( nextPath, MAX_PATH, "%s\\%s", dirname, wfd.cFileName );
#ifdef COOL_XDASH
            LoadXBEs( nextPath, fileExt, usLevel + 1 );
#else
            LoadXBEs( nextPath, fileExt );
#endif // COOL_XDASH
        }
        else // Found a file, check for XBE
        {
            HRESULT hrFileStatus = ProcessFile( wfd.cFileName, FILE_EXECUTABLE_DRIVE_A, dirname, fileExt );
            if( FAILED( hrFileStatus ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CXBEList::LoadXBEs():Failed to process the file!! File - '%hs', Dir - '%hs', Error - '0x%.8X (%d)'", wfd.cFileName, dirname, hrFileStatus, hrFileStatus );
            }
        }

        if( StopEnumeration() )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CXBEList::LoadXBEs():Aborting the XBE Load" );
        }

    } while( FindNextFile( hFind, &wfd ) && ( !StopEnumeration() ) );

// cleanup:
    if( !FindClose( hFind ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::LoadXBEs():FindClose failed!! - (%d)", GetLastError() );
    }

    return S_OK;
}


// Process the file and add it to our XBE list if it's valid
HRESULT CXBEList::ProcessFile( char* pszFileName, char* pszDrive, char* pszDirectory, char* pszExtension )
{
    if( ( NULL == pszFileName ) || ( NULL == pszDirectory ) || ( NULL == pszExtension ) || ( NULL == pszDrive ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::ProcessFile():Invalid parameter passed in!!" );

        return E_INVALIDARG;
    }

    // Match the extension using the upcased version of the file name

    // Convert the filename to uppercase
    _strupr( pszFileName );

    // Process files that only END in .XBE
    char* pszExtention = pszFileName + ( strlen( pszFileName ) - 4 );

    if( 0 == strcmp( pszExtention, pszExtension ) )
    {
        _XBEINFO* pXBEInfo = new _XBEINFO;
        if( NULL == pXBEInfo )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CXBEList::ProcessFile():Failed to allocate memory!!" );

            return E_OUTOFMEMORY;
        }

        ZeroMemory( pXBEInfo, sizeof( _XBEINFO ) );

        _snprintf( pXBEInfo->directory, MAX_PATH, pszDirectory + 2 );


        unsigned int uiStrLen = strlen( pszFileName ) - strlen( pszExtension );
        strncpy( pXBEInfo->filename, pszFileName, uiStrLen );
        pXBEInfo->filename[uiStrLen] = '\0';

        XDBGTRC( APP_TITLE_NAME_A, "CXBEList::ProcessFile():Dir - '%hs', File - '%hs'", pXBEInfo->directory, pXBEInfo->filename );

        // Determine if it's a valid XBE, get the title and publisher info
        BOOL bValidXBE;
        if( FAILED( GetInfoFromXBE( pXBEInfo, bValidXBE, pszDrive ) ) )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CXBEList::ProcessFile(): Get Info Failed!!" );

            delete pXBEInfo;
            pXBEInfo = NULL;
        }
        else if( !bValidXBE )
        {
            XDBGTRC( APP_TITLE_NAME_A, "CXBEList::ProcessFile():Invalid XBE!!" );

            delete pXBEInfo;
            pXBEInfo = NULL;
        }
        else
        {
            m_XBEItems.AddNode( pXBEInfo );
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\xonlinefuncs.h ===
#ifndef _XONLINEFUNCS_H_
#define _XONLINEFUNCS_H_

#include <time.h>

#define ONLINE_ACCOUNT_WAIT_INTERVAL        30000                               // milliseconds
#define ONLINE_USERNAME_MINIMUM_SIZE        5                                   // characters
#define ONLINE_USERNAME_INVALID_CHARACTERS  L":; <=>?@!\"#$%&\'()*+,-./[\\]"    // TODO: What should these be?
#define ONLINE_INI_FILE_PATH                "C:\\DEVKIT\\XONLINE.INI"
#define ONLINE_INI_SECTION_NAME             "TestSettings"
#define ONLINE_INI_REALM_KEYNAME            "REALM"
#define ONLINE_INI_CLUSTER_KEYNAME          "CLUSTER"

HRESULT OnlineQuickLoginStart( void );                              // Does a quick login to the user account creation server
HRESULT OnlineQuickLoginFinish( void );                             // Does a quick logoff to the user account creation server
HRESULT OnlineGenerateUserName( CHAR szName[XONLINE_NAME_SIZE] );   // Create a random user name based on the Ethernet MAC address and 7 bytes of charecter values
HRESULT OnlineGenerateUserName( WCHAR wszName[XONLINE_NAME_SIZE] ); // Create a random user name based on the Ethernet MAC address and 7 bytes of charecter values
HRESULT OnlineGenerateUserAccount( PXONLINE_USER pOnlineUser );     // Create a user

HRESULT OnlineRemoveUserFromHD( PXONLINE_USER pOnlineUser );        // Will remove the specified user from the hard drive
HRESULT OnlineClearUserFromMU( char cDriveLetter );                 // Will remove the user from the specified MU
HRESULT OnlineSetUserInMU( char cDriveLetter,                       // Will store the specified user on the specified MU
                           PXONLINE_USER pOnlineUser );
HRESULT OnlineGetUserFromMU( DWORD dwPort,                          // Gets the user information from an MU and returns it
                             DWORD dwSlot,
                             PXONLINE_USER pOnlineUser,
                             BOOL* pbUserExists = NULL );
HRESULT OnlineGetUsersFromHD( PXONLINE_USER paOnlineUsers,          // Will retrieve users from the hard drive
                              DWORD* pdwNumUsers );
HRESULT OnlineIsUserOnHD( char* pszUserName,                        // Will return true if the user already exists on the Hard Drive
                          BOOL* pbUserExists );
HRESULT OnlineAddUserToHD( PXONLINE_USER pOnlineUser );             // Will add a user to the hard drive
BOOL OnlineIsNameValid( WCHAR* pwszUserName );                      // Used to determine if a user name is valid before creating

char* OnlineGetCurrentRealm();                                      // Get the current Realm users should be in
char* OnlineGetCurrentCluster();                                    // Get the current Cluster we are pointed to
BOOL OnlineGetValueFromINI( char* pszKeyName,                       // Retreive a value from the XOnline INI
                            char* pszDestBuffer,
                            unsigned int uiBufSize );

#endif // _XONLINEFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\yesnomenu.cpp ===
/*****************************************************
*** yesnomenu.h
***
*** CPP file for our Yes/No Menu class.
*** This will allow the user to select Yes or No
***
*** by James N. Helm
*** December 13th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "yesnomenu.h"

extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructors
CYesNoMenu::CYesNoMenu( CXItem* pParent ) :
CMenuScreen( pParent ),
m_bCancelled( FALSE ),
m_xKeypos( 0 ),
m_yKeypos( 0 )
{
    // Zero out our buffers
    for( unsigned int x = 0; x < gc_uiNUM_TEXT_LINES; x++ )
        ZeroMemory( m_apwszTextMessage[x], sizeof( WCHAR ) * ( MAX_PATH + 1 ) );

    GenerateKeypad();
}


// Destructor
CYesNoMenu::~CYesNoMenu()
{
}


// Initialize the Menu
HRESULT CYesNoMenu::Init( char* menuFileName )
{
    HRESULT hr = CMenuScreen::Init( menuFileName );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CYesNoMenu::Init():Failed to initialize base class!!" );
        return hr;
    }

	// Set the menu title
	SetTitle( MENU_TITLE_YESNO );

    return hr;
}


// Draws a menu on to the screen
void CYesNoMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

	// Draw our keypad
	renderKeypad( pTexture );

    // Render the text message
    for( unsigned int x = 0; x < gc_uiNUM_TEXT_LINES; x++ )
    {
		WCHAR* pwszMessagePtr = m_apwszTextMessage[x];
		DWORD dwFGColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
		DWORD dwBGColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

		// Determine if the user wants to display this line of text in a different color
		if( 0 == wcsncmp( m_apwszTextMessage[x], L"/c", 2 ) )
		{
			pwszMessagePtr += 2;	// Skip the initial "/c"

			// Read the DWORD FG color out of the line
			WCHAR* pwszStopString = NULL;
			dwFGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwFGColor )
				XDBGWRN( APP_TITLE_NAME_A, "CMessageMenu::RenderMenuItems():Possible error in conversion of the FG color (DWORD)\n" );

			// Skip over the FG color and the space
			pwszMessagePtr = pwszStopString + 1;

			// Read the DWORD BG color out of the line
			dwBGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwBGColor )
				XDBGWRN( APP_TITLE_NAME_A, "CMessageMenu::RenderMenuItems():Possible error in conversion of the BG color (DWORD)\n" );

			// Skip over the BG color and the space
			pwszMessagePtr = pwszStopString + 1;
		}

        float fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( pwszMessagePtr ) / 2 );
        float fYPos = gc_fYESNO_TEXT_YPOS + ( x * ( m_uiFontHeightOfItem + ITEM_VERT_SPACING ) );

        pTexture->DrawText( fXPos, fYPos, dwFGColor, dwBGColor, L"%ls", pwszMessagePtr );
    }

    // Unlock our texture
    pTexture->Unlock();
}


// Handles input (of the CONTROLS) for the current menu
void CYesNoMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_LEFT:
        {
            // Wrap the cursor
            if( 0 == m_xKeypos )
                m_xKeypos = gc_uiYESNO_NUM_COLS - 1;
            else // m_xKeypos > 0
                m_xKeypos--;
            
            for( int x = m_xKeypos; x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Wrap the cursor
            if( ( gc_uiYESNO_NUM_COLS - 1 ) == m_xKeypos )
                m_xKeypos = 0;
            else // m_xKeypos < ( gc_uiYESNO_NUM_COLS - 1 )
                m_xKeypos++;

            for( int x = m_xKeypos; x < gc_uiYESNO_NUM_COLS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CYesNoMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Play the Select Sound
            g_Sounds.PlaySelectSound();

            // Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"No" ) )    // No
                m_bCancelled = TRUE;

            // Go back to the previous menu
            if( NULL != GetParent() )
                Leave( GetParent() );

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            // Play the Back Sound
            g_Sounds.PlayBackSound();

            // Go back to the previous menu
            if( NULL != GetParent() )
                Leave( GetParent() );

            break;
        }
    }
}


// Generate the kepad we will be using
void CYesNoMenu::GenerateKeypad(void) 
{
	
	// Create the buttons
	int xstart = gc_uiYESNO_TOPROW_X1;
	int ystart = gc_uiYESNO_TOPROW_Y1;
	int width  = gc_uiYESNO_BUTTON_WIDTH;
	int height = gc_uiYESNO_BUTTON_HEIGHT;
	int spacer = gc_uiYESNO_BUTTON_SPACER;
	int currentx = xstart;
	int currenty = ystart;

    for(int y = 0; y < gc_uiYESNO_NUM_ROWS; y++)
	{
		for(int x = 0; x < gc_uiYESNO_NUM_COLS; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    m_keyPad[0][0].defineText( L"Yes" );
    m_keyPad[1][0].defineText( L"No" );
}


// Draw our keypad
BOOL CYesNoMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < gc_uiYESNO_NUM_COLS; x++)
	{
		for(int y = 0; y < gc_uiYESNO_NUM_ROWS; y++)
		{
			if( m_keyPad[x][y].getRender() && ( wcscmp( m_keyPad[x][y].m_pwszResultChar, L"place" ) != 0 ) )
			{
                // Lock our texture so that we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    
                    dwCharColor = ITEM_SELECTED_VALUE_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, gc_fYESNO_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// This will be called whenever this menu is entered / activated
void CYesNoMenu::Enter()
{
    XDBGWRN( APP_TITLE_NAME_A, "CYesNoMenu::Enter()" );
    
    // Call the base-class enter
    CMenuScreen::Enter();

    // Default the focus to the NO Button
	m_xKeypos = 1;
    m_yKeypos = 0;

    // Make sure our cancelled option is set to FALSE
    m_bCancelled = FALSE;
}


// Used to set the text message that will be displayed to the user
void CYesNoMenu::SetText( WCHAR* pwszMessage )
{
    if( NULL == pwszMessage )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CYesNoMenu::SetText():Invalid argument(s) passed in!!" );

        return;
    }

    for( unsigned int x = 0; x < gc_uiNUM_TEXT_LINES; x++ )
    {
        unsigned int uiCount = 0;
        while( ( *pwszMessage != L'\n' ) && ( *pwszMessage != L'\0' ) )
        {
            m_apwszTextMessage[x][uiCount] = *pwszMessage;
            uiCount++;
            pwszMessage++;

            // Exit when we find the end of the current string
            if( uiCount == MAX_PATH + 1 )
                break;
        }
        m_apwszTextMessage[x][uiCount] = L'\0';

        // Exit early if we are at the end of the message
        if( *pwszMessage == L'\0' )
            break;

        uiCount++;
        pwszMessage++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\btnpress\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const char* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\btnpress\bppch.h ===
#include <xtl.h>
#include <xdbg.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\btnpress\btnpress.c ===
#include "bppch.h"

//
// Imported from other modules.
//
VOID DrawMessage(LPCWSTR pcszText, int iProgPercent);
ULONG DebugPrint(PCHAR Format,...);


#define NO_PAD 0xFF

//
// Global variables related to the open gamepad.
//
HANDLE g_Pad = NULL;
UINT g_PadPort = NO_PAD;
PWSTR g_ButtonStrings[] = {
                    L"Button A pressed.",
                    L"Button B pressed.",
                    L"Button X pressed.",
                    L"Button Y pressed.",
                    L"Black button pressed.",
                    L"White button pressed.",
                    L"Left trigger pressed.",
                    L"Right trigger pressed."
                    };



void
pGetInitialGamepad (
    void
    )
{

    DWORD devices;
    int i;
    int c = XGetPortCount ();


    //
    // Get all connected gamepads.
    //
    devices = XGetDevices (XDEVICE_TYPE_GAMEPAD);

    for (i = 0; i < c; i++) {
        if ((1 << i) & devices) {
            //
            // Open the device.
            //
            DebugPrint("Gamepad found on port %u. Opening. \n", i);
            g_Pad = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);
            if (g_Pad) {
                g_PadPort = i;
                DebugPrint ("Gamepad successfully opened. (g_PadPort/g_Pad) (%u/%08x)\n", g_PadPort, g_Pad);
                break;
            }
        }
    }
}

void
pGetGamepadChanges (
    void
    )
{

    DWORD insertions, removals;
    int i;
    int c = XGetPortCount();


    //
    // Get any insertions or removals to gamepads.
    //
    if (XGetDeviceChanges (XDEVICE_TYPE_GAMEPAD, &insertions, &removals)) {
        if (removals && g_PadPort != NO_PAD) {
            if ((1 << g_PadPort) & removals) {

                //
                // our pad removed.
                //
                XInputClose (g_Pad);
                DebugPrint ("Gamepad in use on port %u removed.\n", g_PadPort);

                g_PadPort = NO_PAD;
                g_Pad = NULL;

                //
                // See if there are any otherse connected.
                //
                pGetInitialGamepad ();

            }
        }

        if (insertions && g_PadPort == NO_PAD) {

            for (i = 0; i < c; i++) {
                if ((1 << i) & insertions) {
                    //
                    // Open the device.
                    //
                    DebugPrint ("Gamepad found on port %u. Opening. \n", i);
                    g_Pad = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);
                    if (g_Pad) {
                        g_PadPort = i;
                        DebugPrint ("Gamepad successfully opened. (g_PadPort/g_Pad) (%u/%08x)\n", g_PadPort, g_Pad);
                        break;
                    }
                }
            }
        }
    }

}




void __cdecl main()
{

    XINPUT_STATE state;
    DWORD lastPacket;
    int i;

    //
    //  Initialize core peripheral port support
    //
    XInitDevices(0,NULL);

    //
    // Get any already connected gamepads.
    //
    pGetInitialGamepad ();

    //
    // Keep track of last packet -- this helps us determine if a new packet has been received or if it is the same
    // packet we asked for last time.
    //
    state.dwPacketNumber = 0;
    lastPacket = state.dwPacketNumber;

    while (1) {

        //
        // Look for
        //
        pGetGamepadChanges ();

        if (g_PadPort != NO_PAD && g_Pad) {

            if (ERROR_SUCCESS == XInputGetState (g_Pad, &state) && state.dwPacketNumber != lastPacket) {

                //
                // Update our last packet variable.
                //
                lastPacket = state.dwPacketNumber;

                for (i = 0; i < 8; i++) {

                    if (!state.Gamepad.bAnalogButtons[i]) {
                        continue;
                    }

                    DrawMessage (g_ButtonStrings[i], (state.Gamepad.bAnalogButtons[i] * 100) / 255);
                    break;

                }
                if (i == 8) {
                    DrawMessage (L"No button pressed.", 0);
                }


            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\btnpress\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    draw.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>

#include "d3d8.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.

        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;

        // Set the screen mode.

        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));

        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;

        // Create the device.

        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }

        // Now we no longer need the D3D interface so let's free it.

        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

extern "C" VOID DrawMessage(LPCWSTR pcszText, int iProgPercent)
{
    Draw draw;


    draw.FillRect(0, 0, 640, 480, 0x000080);            // Draw border in dark blue
    draw.FillRect(20, 20, 600, 440, 0);                 // Fill interior with black

    draw.DrawText(pcszText, 100, 100, 0xbbbbff);

    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        //draw.FillRect(x+ 50, y + 50, 210, 20, 0x000080);
        draw.FillRect(215, 220, 210, 40, 0x000080);

        //
        // Draw progress bar
        //

        draw.FillRect(220, 225, 2 * min(iProgPercent, 100), 30, 0xbbbbff);
        //draw.FillRect(x + 50 , y + 50, 2 * min(iProgPercent, 100), 15, 0xbbbbff);
    }
    draw.Present ();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\btnpress\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const char* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, 0) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\cpx\5lines.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    5lines.cpp

Abstract:

    Displays the 5 lines of info about Control Pads and MUs for Control Panel X

Author:

    Jason Gould (a-jasgou) May 2000

--*/
//Sample:
//"Pt ID Sz Btns b0 b1 b2 b3 b4 b5 b6 b7 Tp1x Tp1y Tp2x Tp2y S1 S2      TSec"
//"00 00 00 000C 00 10 20 30 40 50 60 70 7800 2900 8300 8100 02 00        74"
//"01 00 00 0010 00 10 20 30 40 50 60 70 8100 5E00 8100 8000 00 02         1"
//"02  ---No Device---                                                 12364"
//"03 00 00 0007 00 10 20 30 40 50 60 70 8700 7F00 2100 5600 03 02       100"

//#include "cpx.h"
#include <xtl.h>
#include <stdio.h>
#include "device.h"
#include "draw.h"
#include "mmu.h"

/*************************************************************************************
Function:	FormatString
Purpose:	set up a string that has all of the button-states, and other info about a given Duke
Params:		str is a pointer to the string to fill
			slot is the slot to get info about
*************************************************************************************/
VOID 
FormatString(
	OUT TCHAR * str, 
	IN	BYTE	slot
	)
{
	gpPGAMEPAD f;			//used to hold the info from the device
	TCHAR t[189] = {0};		//temporary string 
	
	f = gpGetState(slot);

	if(!gpDeviceExists(slot)) {					//if the device isn't plugged in ---
		swprintf(str,L"%02x  ---No Device---                                        %16I64d", 
			slot, gpTSecondAge(slot));
		return;
	} else {										//if there is a device there ---
		PUCHAR p = f->bAnalogButtons;

		int d1 = muGetDriveFromPortSlot(slot, XDEVICE_TOP_SLOT) ? 2 : 0;
		int d2 = muGetDriveFromPortSlot(slot, XDEVICE_BOTTOM_SLOT) ? 2 : 0;

		swprintf(str, 
			L"%02x %02x %02x %04x %02x %02x %02x %02x %02x %02x %02x %02x "     \
			L"%04hx %04hx %04hx %04hx %02x %02x %11d",
			slot, 0, sizeof(*f),
			f->wButtons, p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7],
			f->sThumbLX,f->sThumbLY,f->sThumbRX,f->sThumbRY,
			d1, d2, gpTSecondAge(slot));

	}
}

/*************************************************************************************
Function:	Display5Lines
Purpose:	set up and display the 5 lines of info about the control pads and MUs
Params:		none
Notes:		Until d3d is ported, we're logging this, which also DebugPrints it, but it 
			isn't displayed on the test machine.
*************************************************************************************/
VOID 
Display5Lines(
	)
{
	
	TCHAR str[189];
	drPrintf(0,0,L"Pt ID Sz Btns b0 b1 b2 b3 b4 b5 b6 b7 TpLx TpLy TpRx TpRy S1 S2        TSec");

	for(BYTE i = 0; i < gpMaxSlots(); i++)
	{
		FormatString(str, i);	//display the current button states on the top of the screen
		drPrintf(0, (float)(16*i + 16), str); 
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\yesnomenu.h ===
/*****************************************************
*** yesnomenu.h
***
*** Header file for our Yes/No Menu class.
*** This will allow the user to select Yes or No
***
*** by James N. Helm
*** December 13th, 2001
***
*****************************************************/

#ifndef _YESNOMENU_H_
#define _YESNOMENU_H_

const unsigned int gc_uiYESNO_NUM_ROWS =        1;     
const unsigned int gc_uiYESNO_NUM_COLS =        2;     
                                                
const unsigned int gc_uiYESNO_BUTTON_SPACER =   35;     
const unsigned int gc_uiYESNO_BUTTON_HEIGHT =   40;     
const unsigned int gc_uiYESNO_BUTTON_WIDTH =    100;     
                                                
const unsigned int gc_uiYESNO_TOPROW_Y1 =       135;     
const unsigned int gc_uiYESNO_TOPROW_X1 =       (unsigned int)MENUBOX_TEXTAREA_X_CENTER - ( gc_uiYESNO_BUTTON_SPACER / 2 ) - gc_uiYESNO_BUTTON_WIDTH;
                                                
const float gc_fYESNO_TEXT_YPOS =               24.0f;
                                                
const float gc_fYESNO_LINE_WIDTH =              1.0f;     

const unsigned int gc_uiNUM_TEXT_LINES =        5;

#include "menuscreen.h"  // Base menu type
#include "key.h"

class CYesNoMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CYesNoMenu( CXItem* pParent );
    virtual ~CYesNoMenu();

    // Process drawing and input for a menu screen
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

    virtual HRESULT Init( char* menuFileName );             // Initialize the Menu
    void SetText( WCHAR* pwszMessage );                     // Used to set the text message that will be displayed to the user
    BOOL GetCancelled() { return m_bCancelled; };           // Used to determine if the user cancelled the keyboard

protected:
    // Properties
    WCHAR   m_apwszTextMessage[gc_uiNUM_TEXT_LINES][MAX_PATH+1];	// Used to hold the text message
    BOOL    m_bCancelled;                                           // Used to determine if the user cancelled the menu
	int     m_xKeypos;                                              // Current X position on the Keyboard
    int     m_yKeypos;                                              // Current Y position on the Keyboard
	CKey    m_keyPad[gc_uiYESNO_NUM_COLS][gc_uiYESNO_NUM_ROWS];     // Each Key displayed on the Keyboard
	
    // Private Methods
	virtual void GenerateKeypad(void);                  // Create the keypad that will be used
	virtual BOOL renderKeypad( CUDTexture* pTexture );  // Draw the keypad on to the our texture
};

#endif // _YESNOMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\cpx\5lines.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    5lines.h

Abstract:

    function declarations for 5lines.cpp

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __5lines_h_
#define __5lines_h_

//#include "cpx.h"

VOID FormatString(TCHAR * str, BYTE slot);
VOID Display5Lines();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\cpx\cpx.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cpx.h

Abstract:

    function declarations, type definitions, includes, etc, for Control Panel X

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __cpx_h_
#define __cpx_h_

#include <xtl.h>
//#include "ccl.h"
#include "modes.h"

#ifndef UNICODE
#define UNICODE
#endif

#ifdef __cplusplus
extern "C" {
#endif

int DebugPrint(char* format, ...);

#ifdef __cplusplus
}
#endif

//the various modes... mainly used when switching control-pads
#define CONTEXT_GLOBAL       0	
#define CONTEXT_DUKEDISPLAY  1
#define CONTEXT_DUKECHECK    2 
#define CONTEXT_MEMORYFILE   3
#define CONTEXT_MEMORYSECTOR 4

//#define MAX_MODES   4
extern int MAX_MODES;

//*******************OTHER GLOBAL DATA************************************************
extern BOOL gQuit;									//should we quit now?
extern DWORD gMode;									//current mode (duke test, duke display, mem sector, mem file)
//extern CL gGlobalCommands;							//commands used globally: quit, switch mode, switch controller
extern ModeFunc gModeFunctions[];					//the main function for each mode
extern BYTE gCurrent;								//the index of the device we're looking at

#endif //!defined (__cpx_h_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\cpx\dukedisplay.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dukedisplay.cpp

Abstract:

    all functions necessary for DukeDisplay mode of CPX

Author:

    Jason Gould (a-jasgou) May 2000

--*/
//#include "cpx.h"
#include <xtl.h>
#include "cpx.h"
#include "modes.h"
//#include "ccl.h"
#include "device.h"
#include "5lines.h"
//#include "commands.h"

//static CL dispcommands;

//VOID DrawTheDuke()
//{
	//draw the duke here...
//}


/*************************************************************************************
Function:   DukeDisplay
Purpose:	the main function of DukeDisplay mode... calls all other necessary functions
Params:     context ---
			  STATUS_BOOT --- cpx just started
			  STATUS_ENTER --- we're entering dukedisplay mode
			  STATUS_NORMAL --- we're in dukedisplay mode, perform normal operations
			  STATUS_LEAVE --- we're leaving dukedisplay mode
			  STATUS_QUIT --- we're quitting cpx
Return:     none
*************************************************************************************/
VOID DukeDisplay(DWORD context, INT param)
{

	switch(context)
	{
	case STATUS_NORMAL:
		Display5Lines();						//update/show the 5 lines at the top
//		dispcommands.CheckControls();
//		DrawTheDuke();
		break;
	case STATUS_ENTER:
//		DebugPrint("Entering DukeDisplay mode\n");
		break;
	case STATUS_LEAVE:
//		DebugPrint("Leaving DukeDisplay mode\n");
		break;
	case STATUS_BOOT:
		{
//			BUTTONS b;
//			b.all = bSTART_PRESSED | bAB6_PRESSED;				//clear the buttons...
//			dispcommands.RegisterControl(b, SwitchController, CONTEXT_DUKEDISPLAY);//to switch controllers
		}
		break;
	case STATUS_QUIT:
//		dispcommands.~CL();
		break;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\cpx\commands.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    commands.cpp

Abstract:

    contains the various control functions that can be accessed from any CPX mode

Author:

    Jason Gould (a-jasgou) May 2000

--*/

#include <xtl.h>
#include "cpx.h"
#include "commands.h"
#include "modes.h"
#include "log.h"
#include "device.h"

/*************************************************************************************
Function:   QuitFunction
Purpose:	tell CPX to quit
Quick-Key:  start+select
Params:     context --- irrelevant
			repeat --- whether start+select is being repeated (irrelevant)
Return:     none
*************************************************************************************/
VOID QuitFunction(DWORD context, BOOL repeat, BYTE slot)
{
	if(!repeat) {
//		DebugPrint("Quit Quit Quit Quit Quit Quit Quit Quit Quit Quit Quit Quit Quit Quit Quit Quit\n");
		logDumpToDebug();
	}

	//logDeinit();

//	Sleep (10000);

}

/*************************************************************************************
Function:   ModeFunction
Purpose:	tell CPX to change modes
Quick-Key:  start+right trigger
Params:     context --- irrelevant
			repeat --- whether start+right is being repeated 
			  (we don't want to switch if it is being repeated, so it is relevant)
Return:     none
*************************************************************************************/
VOID ModeFunction(DWORD context, BOOL repeat, BYTE slot)
{
	if(!repeat) {
		gModeFunctions[gMode](STATUS_LEAVE, 0);
		gMode = (gMode + 1) % MAX_MODES;
		gModeFunctions[gMode](STATUS_ENTER, 0);
	}
	DebugPrint("MODE MODe MOde Mode mode... context %d, repeat %d, Mode %d\n",
		context,repeat,gMode);
}

/*************************************************************************************
Function:   SwitchController
Purpose:	tell CPX to look at a different controller
Quick-Key:  start+left trigger
Params:     context --- irrelevant at this point
			repeat --- we don't want repeats... we only do something if repeat == FALSE
Return:     none
*************************************************************************************/
VOID SwitchController(DWORD context, BOOL repeat, BYTE slot)
{
	if(repeat == FALSE)
	{
		switch (context)
		{
		case CONTEXT_DUKEDISPLAY:
		case CONTEXT_DUKECHECK:
		case CONTEXT_MEMORYFILE:
		case CONTEXT_MEMORYSECTOR:
			gCurrent = (gCurrent + 1) % gpMaxSlots();
			break;
		}
	}
//	DebugPrint("Controller Switch... context %d, repeat %d, New Current pad: %d\n", context,repeat,gMode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\cpx\commands.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    commands.h

Abstract:

    function declarations for commands.cpp

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __commands_h_
#define __commands_h_

//#include "cpx.h"

VOID QuitFunction(DWORD context, BOOL repeat, BYTE slot);
VOID ModeFunction(DWORD context, BOOL repeat, BYTE slot);
VOID SwitchController(DWORD context, BOOL repeat, BYTE slot);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod\dp.h ===
#ifndef __dp_h_
#define __dp_h_


#include "dukeprod.h"

BOXSTATUS  LeftTriggerTest(BOXSTATUS newstatus);
BOXSTATUS RightTriggerTest(BOXSTATUS newstatus);
BOXSTATUS LeftThumbStick1Test(BOXSTATUS newstatus);
BOXSTATUS RightThumbStick1Test(BOXSTATUS newstatus);
BOXSTATUS DPadTest(BOXSTATUS newstatus);
BOXSTATUS StartSelectTest(BOXSTATUS newstatus);
BOXSTATUS ButtonTest(BOXSTATUS newstatus);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod\dp.cpp ===
#define MINCROSSTALK 16

//#define __HAMMERHEAD__
//define __TWOPASS__

#include "xtl.h"
#include "Draw.h"
//#include "Device.h"
#include "dukeprod.h"
#include "dp.h"

#define countof(_x_) (sizeof(_x_) / sizeof(_x_[0]))

#define nc 8192
typedef struct {
	float x1;
	float y1;
	float x2;
	float y2;
	BOXSTATUS stat;
} BOXSTRUCT;

typedef struct {
	signed short minx;
	signed short miny;
	signed short maxx;
	signed short maxy;
	BOOL button;
	int index;
} TPTESTSTRUCT;


#pragma warning(disable : 4035)
__int64 __inline rdtsc() {_asm {rdtsc}}
int __inline rdtsci(){_asm{rdtsc}}
BYTE  __inline rolb( BYTE narf, int r){_asm{mov  al, narf}_asm{mov ecx,r}_asm{rol  al,cl}}
WORD  __inline rolw( WORD narf, int r){_asm{mov  ax, narf}_asm{mov ecx,r}_asm{rol  ax,cl}}
DWORD __inline rold(DWORD narf, int r){_asm{mov eax, narf}_asm{mov ecx,r}_asm{rol eax,cl}}
BYTE  __inline rorb( BYTE narf, int r){_asm{mov  al, narf}_asm{mov ecx,r}_asm{ror  al,cl}}
WORD  __inline rorw( WORD narf, int r){_asm{mov  ax, narf}_asm{mov ecx,r}_asm{ror  ax,cl}}
DWORD __inline rord(DWORD narf, int r){_asm{mov eax, narf}_asm{mov ecx,r}_asm{ror eax,cl}}
#pragma warning(default : 4035)

void drawbox(BOXSTRUCT* b)
{
	DWORD col; 

	switch(b->stat)
	{
	case notyet:
		col = 0xff0000ff;
		break;
	case testme:
		col = (rdtsci()&0x8000000) ? 0xffffffff : 0xff707070;	//blink grey, .4 second intravals
		break;
	case pending:
		col = 0xffffff00;
		break;
	case failed:
		col = 0xffff0000;
		break;
	case passed:
		col = 0xff00ff00;
		break;
	}

	drBox(b->x1, b->y1, b->x2, b->y2, col);
	
}

#define DRAWALL() { for(int __i_ = 0; __i_ < numtocheck; __i_++) drawbox(&bs[__i_]); }


/*
//template: to create a new test:
	copy this, 
	name it appropriately, 
	add a reference to dukeprod.cpp
	change the locations in the bs[] array
	add test code where the // is.


BOXSTATUS TEMPLATE(BOXSTATUS newstatus)
{
	static BOXSTRUCT bs[] = {
		{10,10,11,20,notyet},
		{12,10,15,20,notyet},
		{16,10,19,20,notyet},
		{20,10,23,20,notyet},
		{24,10,25,20,notyet}
	};
	static const int numtocheck = countof(bs);

	int i;
	BOOL doh = FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		//add test-checking code here

		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}
*/

BOXSTATUS LeftTriggerTest(BOXSTATUS newstatus)
{
	static BYTE roller = 0;
	static BOXSTRUCT bs[] = {
		{50,70,53,90,notyet},
		{54,70,61,90,notyet},
		{62,70,69,90,notyet},
		{70,70,77,90,notyet},
		{78,70,81,90,notyet},
		{54,62,58,66,notyet}
	};

	static const int numtocheck = countof(bs);

	BYTE data = gData->bAnalogButtons[GPL];
	int i;
	BOOL doh = FALSE;

	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
	drPrintf(50,50, L"T1");

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		roller = 0;
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data == 0)	
			bs[0].stat = passed;
		bs[1].stat = passed;
		bs[2].stat = passed;
		bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		if(bs[4].stat == passed) {
			if(data == 0 || bs[5].stat == passed) {		//retract!
				bs[5].stat = passed;
			} else {
				bs[5].stat = pending;
			}
		}
#else 
		if(data == 0)	
			bs[0].stat = passed;
		if(data > 0x00 && data <= 0x55)		
			bs[1].stat = passed;
		if(data > 0x55 && data <= 0xAA)		
			bs[2].stat = passed;
		if(data > 0xAA && data <  0xff)
			bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		roller |= (rolb(data, 1) ^ data);
		if(roller == 0xff) {
			if(bs[4].stat == passed) {
				if(data == 0 || bs[5].stat == passed) {	//retract!
					bs[5].stat = passed;
				} else {
					bs[5].stat = pending;
				}
			}
		}
#endif

		DRAWALL();
		drPrintf(50,30,L"Left Trigger: %02hx", data);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS RightTriggerTest(BOXSTATUS newstatus)
{
	static BYTE roller = 0;
	static BOXSTRUCT bs[] = {
		{520,70,523,90,notyet},
		{524,70,531,90,notyet},
		{532,70,539,90,notyet},
		{540,70,547,90,notyet},
		{548,70,551,90,notyet},
		{524,62,528,66,notyet}
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	BYTE data = gData->bAnalogButtons[GPR];
	int i;
	BOOL doh = FALSE;

	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
	drPrintf(520,50, L"T2");

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		roller = 0;
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data == 0)	
			bs[0].stat = passed;
		bs[1].stat = passed;
		bs[2].stat = passed;
		bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		if(bs[4].stat == passed) {
			if(data == 0 || bs[5].stat == passed) {		//retract!
				bs[5].stat = passed;
			} else {
				bs[5].stat = pending;
			}
		}
#else 
		if(data == 0)	
			bs[0].stat = passed;
		if(data > 0x00 && data <= 0x55)		
			bs[1].stat = passed;
		if(data > 0x55 && data <= 0xAA)		
			bs[2].stat = passed;
		if(data > 0xAA && data <  0xff)
			bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		roller |= (rolb(data, 1) ^ data);
		if(roller == 0xff) {
			if(bs[4].stat == passed) {
				if(data == 0 || bs[5].stat == passed) {	//retract!
					bs[5].stat = passed;
				} else {								
					bs[5].stat = pending;
				}
			}
		}
#endif
		DRAWALL();
		drPrintf(50,30,L"Right Trigger: %02hx", data);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}



BOXSTATUS LeftThumbStick1Test(BOXSTATUS newstatus)
{
	static TPTESTSTRUCT tp[] = {				//in-order checkoff
		{   -nc,   -nc,    nc,    nc,0, 9},
		{-16000,-16000, 16000, 16000,0, 4},

		{-16000, 16001, 16000, 32767,0, 1},
		{-32768, 16001,-16001, 32767,0, 0},
		{-32768,-16000,-16001, 16000,0, 3},
		{-32768,-32768,-16001,-16001,0, 6},
		{-16000,-32768, 16000,-16001,0, 7},
		{ 16001,-32768, 32767,-16001,0, 8},
		{ 16001,-16000, 32767, 16000,0, 5},
		{ 16001, 16001, 32767, 32767,0, 2},

#ifdef __TWOPASS__
		{-16000, 16001, 16000, 32767,1, 1},
		{-32768, 16001,-16001, 32767,1, 0},
		{-32768,-16000,-16001, 16000,1, 3},
		{-32768,-32768,-16001,-16001,1, 6},
		{-16000,-32768, 16000,-16001,1, 7},
		{ 16001,-32768, 32767,-16001,1, 8},
		{ 16001,-16000, 32767, 16000,1, 5},
		{ 16001, 16001, 32767, 32767,1, 2},

		{-16000,-16000, 16000, 16000,1, 4},
#endif
		//{     0,     0,     0,     0,1, 9},
		{   -nc,   -nc,    nc,    nc, 1, 9},
		{   -nc,   -nc,    nc,    nc, 0, 9}
		//{     0,     0,     0,     0,0, 9}
	};

	/*
	static TPTESTSTRUCT tp2[] = {					//any-order checkoff
		{(short)0x8000,(short)0x8000,(short)0x8000,(short)0x7fff,0,10},
		{(short)0x8001,(short)0x8000,(short)0xa000,(short)0x7fff,0,11},
		{(short)0xa001,(short)0x8000,(short)0xc000,(short)0x7fff,0,12},
		{(short)0xc001,(short)0x8000,(short)0xe000,(short)0x7fff,0,13},
		{(short)0xe001,(short)0x8000,(short)0xffff,(short)0x7fff,0,14},
		{(short)0x0000,(short)0x8000,(short)0x0000,(short)0x7fff,0,15},
		{(short)0x0001,(short)0x8000,(short)0x2000,(short)0x7fff,0,16},
		{(short)0x2001,(short)0x8000,(short)0x4000,(short)0x7fff,0,17},
		{(short)0x4001,(short)0x8000,(short)0x6000,(short)0x7fff,0,18},
		{(short)0x6001,(short)0x8000,(short)0x7ffe,(short)0x7fff,0,19},
		{(short)0x7fff,(short)0x8000,(short)0x7fff,(short)0x7fff,0,20},

		{(short)0x8000,(short)0x8000,(short)0x7fff,(short)0x8000,0,21},
		{(short)0x8000,(short)0x8001,(short)0x7fff,(short)0xa000,0,22},
		{(short)0x8000,(short)0xa001,(short)0x7fff,(short)0xc000,0,23},
		{(short)0x8000,(short)0xc001,(short)0x7fff,(short)0xe000,0,24},
		{(short)0x8000,(short)0xe001,(short)0x7fff,(short)0xffff,0,25},
		{(short)0x8000,(short)0x0000,(short)0x7fff,(short)0x0000,0,26},
		{(short)0x8000,(short)0x0001,(short)0x7fff,(short)0x2000,0,27},
		{(short)0x8000,(short)0x2001,(short)0x7fff,(short)0x4000,0,28},
		{(short)0x8000,(short)0x4001,(short)0x7fff,(short)0x6000,0,29},
		{(short)0x8000,(short)0x6001,(short)0x7fff,(short)0x7ffe,0,30},
		{(short)0x8000,(short)0x700f,(short)0x7fff,(short)0x7fff,0,31}
	};
*/

	static BOXSTRUCT bs[] = {
		{50,160,69,179,notyet},				//0
		{70,160,89,179,notyet},				//1
		{90,160,109,179,notyet},
		{50,180,69,199,notyet},				//3	
		{70,180,89,199,notyet},				//4
		{90,180,109,199,notyet},
		{50,200,69,219,notyet},				//6
		{70,200,89,219,notyet},
		{90,200,109,219,notyet},	

		{77,187,83,193,notyet},	//centered	//9
/*
		{42,150,46,154,notyet},	//   0x80	//10
		{47,150,51,154,notyet},	//to 0xa0
		{52,150,56,154,notyet},	//to 0xc0
		{57,150,61,154,notyet},	//to 0xe0
		{62,150,66,154,notyet},	//to 0xff
		{67,150,71,154,notyet},	//   0x00
		{72,150,76,154,notyet},	//to 0x20
		{77,150,81,154,notyet},	//to 0x40
		{82,150,86,154,notyet},	//to 0x60
		{87,150,91,154,notyet},	//to 0x7e
		{92,150,96,154,notyet},	//   0x7f	//20

		{105,212,109,216,notyet},	//   0x7f	//31
		{105,207,109,211,notyet},	//to 0x7e
		{105,202,109,206,notyet},	//to 0x60
		{105,197,109,201,notyet},	//to 0x40
		{105,192,109,196,notyet},	//to 0x20
		{105,187,109,191,notyet},	//   0x00
		{105,182,109,186,notyet},	//to 0xff
		{105,177,109,181,notyet},	//to 0xe0
		{105,172,109,176,notyet},	//to 0xc0
		{105,167,109,171,notyet},	//to 0xa0
		{105,162,109,166,notyet},	//   0x80	//21
*/
		{120,177,136,193,notyet}    //button	//32
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	BOOL doh = FALSE;
	static int c = 0;

	signed short x = gData->sThumbLX;
	signed short y = gData->sThumbLY;
	BOOL bp = (gData->wButtons & XINPUT_GAMEPAD_LEFT_THUMB) ? TRUE : FALSE;
//    DebugPrint("x=%d",x);

	// 
	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
	drPrintf(50,140, L"Left Stick");
	 
	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		if(c >= sizeof(tp) / sizeof(tp[0])) {
			bs[sizeof(bs)/sizeof(bs[0])-1].stat = passed;
		} else {
			if(x > tp[c].maxx || x < tp[c].minx || 
				y > tp[c].maxy || y < tp[c].miny ||
				bp != tp[c].button || ((tp[c].maxx | tp[c].minx | tp[c].maxy | tp[c].miny) && (!(x | y))) )
			{
				bs[tp[c].index].stat = testme;
				if(c!=(numtocheck-2)) bs[sizeof(bs)/sizeof(bs[0])-1].stat = tp[c].button ? testme : pending;
				else bs[sizeof(bs)/sizeof(bs[0])-1].stat=pending;
			} else {
				for(i = c + 1; i < sizeof(tp) / sizeof(tp[0]); i++)
				{
					if(tp[i].index == tp[c].index) {
						bs[tp[c].index].stat = pending;
						goto notdone;
					}
				}
				bs[tp[c].index].stat = passed;
notdone:

//				bs[tp[c].index].stat = tp[c].button ? passed : pending;
				c++;
			}
		}

/*
		for(i = 0; i < sizeof(tp2) / sizeof(tp2[0]); i++)
		{
			if(x > tp2[i].maxx || x < tp2[i].minx ||
				y > tp2[i].maxy || y < tp2[i].miny)
			{
				if(bs[tp2[i].index].stat != passed) bs[tp2[i].index].stat = testme;
			} else {
				bs[tp2[i].index].stat = passed;
			}
		}
*/

		::drPrintf(50,30,L"Left Thumb-Stick: X: %6hd   Y: %6hd  B: %s", 
			x, y, bp ? L"TRUE" : L"FALSE");
		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS DPadTest(BOXSTATUS newstatus)
{
	static struct {
		BYTE d[4];
	} bd[] = {
		{1,0,0,0},
		{1,0,1,0},
		{0,0,1,0},
		{0,1,1,0},
		{0,1,0,0},
		{0,1,0,1},
		{0,0,0,1},
		{1,0,0,1},
		{0,0,0,0}
	};
	static BOXSTRUCT bs[] = {
		{115,335,205,425,notyet},	//all?
		{150,340,170,360,notyet},	//up
		{120,340,140,360,notyet},	//upleft
		{120,370,140,390,notyet},	//left
		{120,400,140,420,notyet},	//downleft
		{150,400,170,420,notyet},	//down
		{180,400,200,420,notyet},	//downright
		{180,370,200,390,notyet},	//right
		{180,340,200,360,notyet},	//upright
		{150,370,170,390,notyet} 	//centered
	};
	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	static int c = 0;
	BOOL doh = FALSE;
	BYTE data[] = {
		gData->wButtons & XINPUT_GAMEPAD_DPAD_UP    ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_DOWN  ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_LEFT  ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ? 1 : 0
	};

	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
	drPrintf(120,315, L"DPad");

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 1;
		return notyet;
	case testme:
		for(i = 1; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(doh) {
			goto doh;
		}

		if(bs[0].stat == failed) {
			return failed;
		}

		return passed;
doh:
		if((data[0] && data[1]) || (data[2] && data[3])) {
			bs[0].stat = failed;
		}

		for (i = 0; i < 4; i++)	{
			if(data[i] != bd[c-1].d[i]) {
				bs[c].stat = testme;
				goto doh2;
			}
		}
		bs[c].stat = passed;
		c++;

doh2:

		DRAWALL();
		drPrintf(50,30,L"Up: %d  Down: %d  Left: %d  Right: %d",data[0],data[1],data[2],data[3]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}


BOXSTATUS StartSelectTest(BOXSTATUS newstatus)
{
	static BOXSTRUCT bs[] = {
		{240,400,250,410,notyet},
		{280,400,290,410,notyet}
	};
	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);
	static int c = 0;
	int i;
	BOOL doh = TRUE;
	BYTE data[] = {
		gData->wButtons & XINPUT_GAMEPAD_BACK     ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_START    ? 1 : 0,
	};


	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
	drPrintf(220,380, L"Back");
	drPrintf(272,380, L"Start");

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		switch (c) {
		case 0:
			if(data[0] == 0 || data[1] == 1) {
				bs[0].stat = testme;
			} else {
				bs[0].stat = pending;
				c++;
			}
			break;
		case 1:
			if(data[0] == 0) {
				bs[0].stat = passed;
				bs[1].stat = testme;
				c++;
			}
			break;
		case 2:
			if(data[0] == 1 || data[1] == 0) {
				bs[1].stat = testme;
			} else {
				bs[1].stat = pending;
				c++;
			}
			break;
		case 3:
			if(data[1] == 0) {
				bs[1].stat = passed;
				return passed;
			}
			break;
		}

		DRAWALL();
		drPrintf(50,30,L"Back: %d   Start: %d", data[0], data[1]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}


BOXSTATUS RightThumbStick1Test(BOXSTATUS newstatus)
{
	static TPTESTSTRUCT tp[] = {				//in-order checkoff
		{     -nc,     -nc,     nc,     nc,0, 9},
		{-16000, -16000,  16000,  16000,0, 4},

		{-16000, 16001, 16000, 32767,0, 1},
		{-32768, 16001,-16001, 32767,0, 0},
		{-32768,-16000,-16001, 16000,0, 3},
		{-32768,-32768,-16001,-16001,0, 6},
		{-16000,-32768, 16000,-16001,0, 7},
		{ 16001,-32768, 32767,-16001,0, 8},
		{ 16001,-16000, 32767, 16000,0, 5},
		{ 16001, 16001, 32767, 32767,0, 2},

#ifdef __TWOPASS__
		{-16000, 16001, 16000, 32767,1, 1},
		{-32768, 16001,-16001, 32767,1, 0},
		{-32768,-16000,-16001, 16000,1, 3},
		{-32768,-32768,-16001,-16001,1, 6},
		{-16000,-32768, 16000,-16001,1, 7},
		{ 16001,-32768, 32767,-16001,1, 8},
		{ 16001,-16000, 32767, 16000,1, 5},
		{ 16001, 16001, 32767, 32767,1, 2},

		{ -16000, -16000,  16000,  16000,1, 4},
#endif
		{   -nc,   -nc,    nc,    nc,1, 9},
		{   -nc,   -nc,    nc,    nc,0, 9}
		
		//{     0,     0,     0,     0,1, 9},
		//{     0,     0,     0,     0,0, 9}
	};

	/*
//#pragma warning (disable : 4309; disable : 4305)//either this, or (short)... ugh.
	static TPTESTSTRUCT tp2[] = {					//any-order checkoff
		{(short)0x8000,(short)0x8000,(short)0x8000,(short)0x7fff,0,10},
		{(short)0x8001,(short)0x8000,(short)0xa000,(short)0x7fff,0,11},
		{(short)0xa001,(short)0x8000,(short)0xc000,(short)0x7fff,0,12},
		{(short)0xc001,(short)0x8000,(short)0xe000,(short)0x7fff,0,13},
		{(short)0xe001,(short)0x8000,(short)0xffff,(short)0x7fff,0,14},
		{(short)0x0000,(short)0x8000,(short)0x0000,(short)0x7fff,0,15},
		{(short)0x0001,(short)0x8000,(short)0x2000,(short)0x7fff,0,16},
		{(short)0x2001,(short)0x8000,(short)0x4000,(short)0x7fff,0,17},
		{(short)0x4001,(short)0x8000,(short)0x6000,(short)0x7fff,0,18},
		{(short)0x6001,(short)0x8000,(short)0x7ffe,(short)0x7fff,0,19},
		{(short)0x7fff,(short)0x8000,(short)0x7fff,(short)0x7fff,0,20},

		{(short)0x8000,(short)0x8000,(short)0x7fff,(short)0x8000,0,21},
		{(short)0x8000,(short)0x8001,(short)0x7fff,(short)0xa000,0,22},
		{(short)0x8000,(short)0xa001,(short)0x7fff,(short)0xc000,0,23},
		{(short)0x8000,(short)0xc001,(short)0x7fff,(short)0xe000,0,24},
		{(short)0x8000,(short)0xe001,(short)0x7fff,(short)0xffff,0,25},
		{(short)0x8000,(short)0x0000,(short)0x7fff,(short)0x0000,0,26},
		{(short)0x8000,(short)0x0001,(short)0x7fff,(short)0x2000,0,27},
		{(short)0x8000,(short)0x2001,(short)0x7fff,(short)0x4000,0,28},
		{(short)0x8000,(short)0x4001,(short)0x7fff,(short)0x6000,0,29},
		{(short)0x8000,(short)0x6001,(short)0x7fff,(short)0x7ffe,0,30},
		{(short)0x8000,(short)0x700f,(short)0x7fff,(short)0x7fff,0,31}
	};
//#pragma warning(default : 4309; default : 4305)
*/

	static BOXSTRUCT bs[] = {
		{340,360,359,379,notyet},				//0
		{360,360,379,379,notyet},				//1
		{380,360,399,379,notyet},
		{340,380,359,399,notyet},				//3	
		{360,380,379,399,notyet},				//4
		{380,380,399,399,notyet},
		{340,400,359,419,notyet},				//6
		{360,400,379,419,notyet},
		{380,400,399,419,notyet},	
		{367,387,373,393,notyet},	//centered	//9
/*
		{342,350,346,354,notyet},	//   0x80	//10
		{347,350,351,354,notyet},	//to 0xa0
		{352,350,356,354,notyet},	//to 0xc0
		{357,350,361,354,notyet},	//to 0xe0
		{362,350,366,354,notyet},	//to 0xff
		{367,350,371,354,notyet},	//   0x00
		{372,350,376,354,notyet},	//to 0x20
		{377,350,381,354,notyet},	//to 0x40
		{382,350,386,354,notyet},	//to 0x60
		{387,350,391,354,notyet},	//to 0x7e
		{392,350,396,354,notyet},	//   0x7f	//20

		{405,412,409,416,notyet},	//   0x7f	//31
		{405,407,409,411,notyet},	//to 0x7e
		{405,402,409,406,notyet},	//to 0x60
		{405,397,409,401,notyet},	//to 0x40
		{405,392,409,396,notyet},	//to 0x20
		{405,387,409,391,notyet},	//   0x00
		{405,382,409,386,notyet},	//to 0xff
		{405,377,409,381,notyet},	//to 0xe0
		{405,372,409,376,notyet},	//to 0xc0
		{405,367,409,371,notyet},	//to 0xa0
		{405,362,409,366,notyet},	//   0x80	//21
		*/

		{410,377,426,393,notyet}    //button	//32
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	BOOL doh = FALSE;
	static int c = 0;

	signed short x = gData->sThumbRX;
	signed short y = gData->sThumbRY;
	BOOL bp = (gData->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB) ? TRUE : FALSE;

	
	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
	drPrintf(340,340, L"Right Stick");

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
//				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		if(c >= sizeof(tp) / sizeof(tp[0])) {
			bs[sizeof(bs)/sizeof(bs[0])-1].stat = passed;
		} else {
			if(x > tp[c].maxx || x < tp[c].minx || 
				y > tp[c].maxy || y < tp[c].miny ||
				bp != tp[c].button || ((tp[c].maxx | tp[c].minx | tp[c].maxy | tp[c].miny) && (!(x | y))) )
			{
				bs[tp[c].index].stat = testme;
				if(c!=(numtocheck-2)) bs[sizeof(bs)/sizeof(bs[0])-1].stat = tp[c].button ? testme : pending;
				else bs[sizeof(bs)/sizeof(bs[0])-1].stat=pending;
			} else {
				for(i = c + 1; i < sizeof(tp) / sizeof(tp[0]); i++)
				{
					if(tp[i].index == tp[c].index) {
						bs[tp[c].index].stat = pending;
						goto notdone;
					}
				}
				bs[tp[c].index].stat = passed;
notdone:

//				bs[tp[c].index].stat = tp[c].button ? passed : pending;
				c++;
			}
		}

/*
		for(i = 0; i < sizeof(tp2) / sizeof(tp2[0]); i++)
		{
			if(x > tp2[i].maxx || x < tp2[i].minx ||
				y > tp2[i].maxy || y < tp2[i].miny)
			{
				if(bs[tp2[i].index].stat != passed) bs[tp2[i].index].stat = testme;
			} else {
				bs[tp2[i].index].stat = passed;
			}
		}
*/

		::drPrintf(50,30,L"Right Thumb-Stick: X: %6hd   Y: %6hd  B: %s", 
			x, y, bp ? L"TRUE" : L"FALSE");
		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS ButtonTest(BOXSTATUS newstatus)
{

	static BOXSTRUCT bs[] = {
		{410,210,420,212,notyet},
		{410,212,420,216,notyet},
		{410,216,420,220,notyet},
		{410,220,420,224,notyet},
		{410,224,420,228,notyet},
		{424,210,428,228,notyet},

		{450,210,460,212,notyet},
		{450,212,460,216,notyet},
		{450,216,460,220,notyet},
		{450,220,460,224,notyet},
		{450,224,460,228,notyet},
		{464,210,468,228,notyet},

		{490,210,500,212,notyet},
		{490,212,500,216,notyet},
		{490,216,500,220,notyet},
		{490,220,500,224,notyet},
		{490,224,500,228,notyet},
		{504,210,508,228,notyet},

		{410,260,420,262,notyet},
		{410,262,420,266,notyet},
		{410,266,420,270,notyet},
		{410,270,420,274,notyet},
		{410,274,420,278,notyet},
		{424,260,428,278,notyet},

		{450,260,460,262,notyet},
		{450,262,460,266,notyet},
		{450,266,460,270,notyet},
		{450,270,460,274,notyet},
		{450,274,460,278,notyet},
		{464,260,468,278,notyet},

		{490,260,500,262,notyet},
		{490,262,500,266,notyet},
		{490,266,500,270,notyet},
		{490,270,500,274,notyet},
		{490,274,500,278,notyet},
		{504,260,508,278,notyet}
	};


	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	static int c = 0;
//	if(c >= 6) c = 0;

	int i;
	BOOL doh = FALSE;
	BOOL doh2 = FALSE;

	static BYTE otherdif[6] = {0,0,0,0,0,0};
	static BYTE roller = 0;

	BYTE data[] = {
		gData->bAnalogButtons[GPX],
		gData->bAnalogButtons[GPY],
		gData->bAnalogButtons[GPW],
		gData->bAnalogButtons[GPA],
		gData->bAnalogButtons[GPB],
		gData->bAnalogButtons[GPK]
	};


	
	// label buttons
	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
	drPrintf(410,190, L"X");
	drPrintf(450,190, L"Y");
	drPrintf(485,190, L"White");
	drPrintf(410,240, L"A");
	drPrintf(450,240, L"B");
	drPrintf(485,240, L"Black");


	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) 
		{
			bs[i].stat = notyet;
		}

		roller = 0;
		for(i = 1; i < 6; i++) 
		{
			otherdif[i] = 0x00;
		}
		otherdif[0] = 0xff;
		c = 0;

		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) 
		{
			if(bs[i].stat != passed) 
			{
				doh = TRUE;
			}
		}
		if(c < 6) {
			for(i = 0; i < 6; i++) 
			{
				if(bs[c * 6 + i].stat != passed) 
				{
					bs[c * 6 + i].stat = testme;
				}
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data[c] == 0) 
			bs[c * 6 + 4].stat = passed;
		bs[c * 6 + 3].stat = passed;
		bs[c * 6 + 2].stat = passed;
		bs[c * 6 + 1].stat = passed;
		if (data[c] == 0xff) 
			bs[c * 6 + 0].stat = passed;
#else
		if(data[c] == 0) 
			bs[c * 6 + 4].stat = passed;
		else if (data[c] < 0x55) 
			bs[c * 6 + 3].stat = passed;
		else if (data[c] < 0xaa) 
			bs[c * 6 + 2].stat = passed;
		else if (data[c] < 0xff) 
			bs[c * 6 + 1].stat = passed;
		if (data[c] == 0xff) 
			bs[c * 6 + 0].stat = passed;
#endif
		
		//check for crosstalk: if 3 or more buttons are being pressed, fail
		int NumButtonsPressed;
		for (i = 0, NumButtonsPressed = 0; i < 6; i++) 
		{
			if (data[i] > MINCROSSTALK) NumButtonsPressed++;
		}
		if (NumButtonsPressed >= 3)
		{
			return failed;
		}


		doh2 = FALSE;
		for(i = 0; i < 6; i++) {
			otherdif[i] |= data[c] ^ data[i]; //check for two buttons stuck to eachother
			if(otherdif[i] != 0xff) 
			{
				doh2 = TRUE;
			}
		}

		roller |= rolb(data[c], 1) ^ data[c]; //check for bits within the button stuck to eachother
		if(!doh2 
			#ifndef __HAMMERHEAD__
				&& roller == 0xff
			#endif
			) {		
			bs[c * 6 + 5].stat = pending;
		}

		for(i = 0; i < 6; i++) {
			if(bs[i * 6 + 5].stat == pending) 
			{
				if(bs[i * 6 + 4].stat == passed && data[i] == 0)
					bs[i * 6 + 5].stat = passed;
				else
					bs[i * 6 + 5].stat = pending;
			}
		}

		for(i = 0; i < 5; i++) 
		{
			if(bs[c * 6 + i].stat != passed) goto doh2;
		}
		if(bs[c * 6 + 5].stat != passed && bs[c * 6 + 5].stat != pending) 
		{
			goto doh2;
		}

		c++;
		for(i = 0; i < 6; i++) 
		{
			otherdif[i] = 0;		
		}
		roller = 0;
		otherdif[c] = 0xff;
doh2:
		DRAWALL();
		drPrintf(50,30,L"A:%02x  B:%02x  X:%02x  Y:%02x  Blk:%02x  Wht:%02x ",
			data[3],data[4],data[0],data[1],data[5],data[2]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) 
		{
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\cpx\dukedisplay.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dukedisplay.h

Abstract:

    function declarations for dukedisplay.cpp

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __dukedisplay_h_
#define __dukedisplay_h_

#include "cpx.h"

VOID DrawTheDuke();
VOID DukeDisplay(DWORD context, INT param);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\cpx\cpx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cpx.cpp

Abstract:

    initializes all global variables, contains main loop, init, and de-init for 
	Control Panel X

Author:

    Jason Gould (a-jasgou) May 2000

--*/

#ifdef NUGOOP
// #error nugoop defined!!
#endif

#include <xtl.h>
#include <stdio.h>
#include "cpx.h"
#include "ccl.h"
#include "5lines.h"
#include "commands.h"
#include "device.h"
#include "draw.h"
#include "dukedisplay.h"
#include "log.h"
//nclude "memoryfile.h"
//nclude "memorysector.h"
//#include "xpong.h"
#include "mmu.h"



//*******************OTHER GLOBAL DATA************************************************
BYTE						gCurrent					= 0;	//the index of the device we're looking at
BOOL						gQuit						= FALSE;
DWORD						gMode						= 0;
CL							gGlobalCommands;						//global commands, like "Quit", etc.
                                                                    //the modes of cpx

ModeFunc                    gModeFunctions  [] = {
									DukeDisplay
//									, 
//									DukeCheck, MemoryFile, MemorySector
//									#ifdef _UseXpong_
  //                                     , XPong
	//								#endif
							};
		

int							MAX_MODES = sizeof(gModeFunctions) / sizeof(gModeFunctions[0]);


/*************************************************************************************
Function:	DeviceLog
Purpose:	log changes in the control pads...
Params:		lastupdate --- the number of microseconds since we started reading the device
			slot --- the slot the device is in
			packet --- the packet number just received
			data --- the data that came from the device
*************************************************************************************/
void DeviceLog(UINT64 lastupdate, int slot, gpGAMEPAD* data, DWORD packet)
{
    CHAR c[100];
	const BYTE * pc;
	int i;

    sprintf(c, "%12I64u %02x %8x", lastupdate, slot, packet);
    for(pc = (BYTE*)data, i = 0; i < sizeof(*data); i++)
	{
        sprintf(c, "%s %02x", c, (unsigned int)(pc[i]));
	}
//  DebugPrint("%s\n", c);
	logLog("%s\r\n", c);

}

/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void init()
{
	int i;

	DWORD dwRet;

    DebugPrint("Welcome to Control Panel X: Built on %s at %s\n", __DATE__,__TIME__);
	logInit("t:\\cpxlog.log");

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

	gpInit(0);
	gpSetLogFunction(DeviceLog);

	drInit();

	muInit();
	
//	BUTTONS b;
//	b.all = bSTART_PRESSED | bBACK_PRESSED;		//start + select 
//	gGlobalCommands.RegisterControl(b, QuitFunction, CONTEXT_GLOBAL);	//trigger the save/quit function

//	b.all = bSTART_PRESSED | bAB7_PRESSED;			//start + right button
//	gGlobalCommands.RegisterControl(b, ModeFunction, CONTEXT_GLOBAL);	//trigger the change-mode function
	
	DebugPrint("Initializing modes\n");
	for(i = 0; i < MAX_MODES; i++) {
		gModeFunctions[i](STATUS_BOOT, 0);
	}
	gModeFunctions[gMode](STATUS_ENTER, 0);

	DebugPrint("Done with initialization!\n");
}



/*************************************************************************************
Function:	deinit
Purpose:	de-initialize all cpx stuff (NONE, since we never should quit!)
Params:		none
Out:		un-registers the callbacks for controlpads and MUs, tells all cpx modes to quit
Notes:		We shouldn't ever go here, since xbox only has one process, & this is it...
*************************************************************************************/
void deinit()
{
	DebugPrint("Quitting???? ...");
	logDeinit();

	gModeFunctions[gMode](STATUS_LEAVE, 0);
	for(int i = 0; i < MAX_MODES; i++) {
		gModeFunctions[i](STATUS_QUIT, 0);
	}

	gpDeinit();
	drDeinit();
	muDeinit();

	DebugPrint("gGlobalCommands.~CL()\n");
	gGlobalCommands.~CL();

	DebugPrint("Deinit is finished.\n");
	
}


/*************************************************************************************
Function:	wWinMain (...)
Purpose:	the entry-point of cpx. Calls init, does the main loop, then de-inits
Params:		irrelevant
Notes:		until d3d is ported, it can't display the console...
*************************************************************************************/
//DWORD WINAPI TestMain()
//int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow)

int __cdecl main()
{
//	_asm int 3;

	BOOL isinserted;
	BOOL repeat = 0;
	int i;
	init();

	gpPoll();
	Sleep(16);

	while(gQuit == FALSE) //loop until we're supposed to quit...
	{
		drCls();
		gpUpdateDeviceStateInfo();				//update the button state info...
		muGetDeviceMessages();

		isinserted = FALSE;
		for(i = 0; i < ::gpMaxSlots(); i++)	{
			if(::gpDeviceExists(i)) {
				isinserted = TRUE;
				repeat = FALSE;
			}
		}
		if(!isinserted && !repeat) {
			QuitFunction(0, FALSE, 0);
			repeat = TRUE;
		}

		gpPoll();
		gGlobalCommands.CheckControls();		//see if any commands are being presseed
		gModeFunctions[gMode](STATUS_NORMAL, 0);	//go to the appropriate mode
		drShowScreen();							//and draw the screen
	} 

	//we should theoretically never get here on xbox......

	deinit();


	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod\dukeprod.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cpx.h

Abstract:

    function declarations, type definitions, includes, etc, for Control Panel X

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __cpx_h_
#define __cpx_h_

//#include <windef.h>
//#include "ccl.h"
//#include "modes.h"

#ifndef UNICODE
#define UNICODE
#endif

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

#define MAX_SLOTS XGetPortCount()
//typedef enum {none, tested} padstatus;
typedef enum {notyet, testme, pending, failed, passed,never} BOXSTATUS;
typedef BOXSTATUS (*BOXFUNC)(BOXSTATUS newstatus);
extern BOXSTATUS gPadStatus[MAX_SLOTS];

#include "dp.h"
#include "device.h"

extern BOXFUNC gBoxFuncs[];
extern gpGAMEPAD * gData;
extern WORD gwControllerType;

// controller types
#define STANDARD_TYPE		1
#define ACHIBONO_TYPE		2
#define WHEEL_TYPE			10
#define ARCADE_STICK_TYPE	20

#endif //!defined (__cpx_h_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\base.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    base.h

Abstract:

   general base functions declarations, type definitions, includes, etc.
Author:

    Dennis Krueger <a-denkru>   May 2000

Revision History:

--*/
#ifndef __base_h_
#define __base_h_

#include <xtl.h>



#define BlueColor	0xff0000ff
#define GrayColor	0xff707070
#define RedColor	0xffff0000
#define GreenColor	0xff00ff00
#define YellowColor 0xffffff00



class CPoint
{
public:
	CPoint() {;};
	~CPoint() {;};

	int GetX() { return m_X; };
	int GetY() { return m_Y; };
	void SetX(int X) { m_X = X; };
	void SetY(int Y) { m_Y = Y; };
	void SetXY(int X, int Y) { m_X = X; m_Y = Y;};
private:	
	int m_X;
	int m_Y;
};

class CRect
{
public:
	CRect() { ; };
	CRect(CPoint TopLeft, CPoint BottomRight) { m_TopLeft = TopLeft; m_BottomRight = BottomRight;};

	~CRect() {;};
	void Set(CPoint TopLeft, CPoint BottomRight) { m_TopLeft = TopLeft; m_BottomRight = BottomRight; };
	void SetTopLeft(CPoint TopLeft) { m_TopLeft = TopLeft; };
	void SetBottomRight(CPoint BottomRight) { m_BottomRight = BottomRight; };
	CPoint GetTopLeft() { return m_TopLeft; };
	CPoint GetBottomRight() { return m_BottomRight; };
	void OffsetRect(CPoint Point);
	void Draw(DWORD dwColor);
private:
	CPoint m_TopLeft;
	CPoint m_BottomRight;
};


#endif // __base_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod\dukeprod.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dukeprod.cpp

Abstract:

    initializes all global variables, contains main loop, init, and stuff for duke production test

Author:

    Jason Gould (jgould) Aug 2000

Modified: 
	Jeff Keely		december 2000  -added mu code
	Jason Gould		january 2001   -added comments, renamed variables
    Bing Li         May 2001       -added better UI, less sensitive, print failed reason,and comments

--*/

#include "xtl.h"
#include <stdio.h>
#include "dukeprod.h"
#include "ccl.h"
#include "device.h"
#include "draw.h"
#include "mmu.h"
#include "Tsc.h"

#define countof(_x_) (sizeof(_x_) / sizeof(_x_[0]))




BOXSTATUS gPadStatus[MAX_SLOTS];

/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void init()
{
	int i;

	DWORD dwRet;

    DebugPrint("Welcome to Duke Production Test: Built on %s at %s\n", __DATE__,__TIME__);

    //Initialize core peripheral port support
    XInitDevices(0,NULL);
    

	gpInit(0);
	drInit();
	muInit();

	for(i = 0; i < MAX_SLOTS; i++) {
		gPadStatus[i] = notyet;
	}
	
	TscInit(0);

	DebugPrint("Done with initialization!\n");
}



/*************************************************************************************
Function:	deinit
Purpose:	de-initialize all cpx stuff (NONE, since we never should quit!)
Params:		none
Out:		un-registers the callbacks for controlpads and MUs, tells all cpx modes to quit
Notes:		We shouldn't ever go here, since xbox only has one process, & this is it...
*************************************************************************************/
void deinit()
{
	DebugPrint("Quitting???? ...");

//	gModeFunctions[gMode](STATUS_LEAVE, 0);
//	for(int i = 0; i < MAX_MODES; i++) {
//		gModeFunctions[i](STATUS_QUIT, 0);
//	}

	gpDeinit();
	drDeinit();
	muDeinit();

	DebugPrint("Deinit is finished.\n");
	
}



gpGAMEPAD * gData;
extern HANDLE gDeviceHandle[MAX_SLOTS]; // global handles in cpx lib


typedef enum {LeftTrigger, RightTrigger, LeftThumb, DPad, StartSelect, RightThumb, Button, Slot, TimeOut} FAILEDREASON;
 
FAILEDREASON gReason;

WORD	gwControllerType;

typedef struct {
	BOXFUNC BoxFunc;
	float secs;
	BOXSTATUS stat;
} TESTSTRUCT;

TESTSTRUCT tests[] = {
	{LeftTriggerTest     ,20, notyet},
	{RightTriggerTest    ,20, notyet},
	{LeftThumbStick1Test ,20, notyet},
	{DPadTest            ,20, notyet},
	{StartSelectTest     ,20, notyet},
	{RightThumbStick1Test,20, notyet},
	{ButtonTest          ,20, notyet}
};


bool muTop, muBottom;

BOXSTATUS test(int slot)
{
	int i, j;
	__int64 tim;
	BOXSTATUS overall = passed;
	muTop = false;
	muBottom = false;
    XINPUT_CAPABILITIES capabilities;

	gData = ::gpGetState(slot);


    HANDLE hDuke = gDeviceHandle[slot];
    XInputGetCapabilities(hDuke, &capabilities);

	for(i = 0; i < countof(tests); i++) 
	{
		tests[i].stat = notyet;
		 
		tests[i].BoxFunc(tests[i].stat);
		
		// reset exceptions
		switch(i)
		{
			case 0: // left trigger
			{
				if(!capabilities.In.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER])
					tests[i].stat = never;
				break;
			}

			case 1: // right trigger
			{
				if(!capabilities.In.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
					tests[i].stat = never;
				break;
			}

			case 2: // Left Thumbstick
			{
				if(!capabilities.In.Gamepad.wButtons && XINPUT_GAMEPAD_LEFT_THUMB)
					tests[i].stat = never;
				break;
			}
			case 3: // DPad Test
			{
				// 0x0f is the bits for all four directions
				// only 4-direction pads will be tested
				if(!capabilities.In.Gamepad.wButtons && 0x0f)
					tests[i].stat = never;
				break;
			}
			case 4: // StartSelect
			{
				if(!capabilities.In.Gamepad.wButtons && ( XINPUT_GAMEPAD_START ||	XINPUT_GAMEPAD_BACK ))
					tests[i].stat = never;
				break;
			}
			case 5: // RightThumbstick
			{
				if(!capabilities.In.Gamepad.wButtons && XINPUT_GAMEPAD_RIGHT_THUMB)
					tests[i].stat = never;
				break;
			}
			case 6: // Buttons
			{	for(int j = 0; j < 6; j++)
				{
					if(!capabilities.In.Gamepad.bAnalogButtons[j])
						tests[i].stat = never;
				}
				break;
			}

		} // end switch(i)


		tests[i].BoxFunc(tests[i].stat);


	}

	/*
	Please pardon the odd code here. 
	It was originally designed to run simultaneously with other tests that also used d3d.
	Since d3d isn't multithreaded, all drawing routine calls had to occur in the same thread,
	yet had to occur nearly simultaneously with other test code - Hence the repeated calling 
	& returning from functions...
  	*/ 
	
	for(i = 0; i < countof(tests); i++) {
		tim = TscBegin();
		tests[i].stat = testme;
		while(1) {
			drCls();

			gpUpdateDeviceStateInfo();				//update the button state info...
			if(!::gpDeviceExists(slot))	{
				return failed;
			}
			muGetDeviceMessages();

			gpPoll();
			gData = ::gpGetState(slot);


			gwControllerType = capabilities.SubType;

			drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
			
			switch (gwControllerType)
			{
				case STANDARD_TYPE:
					drPrintf(200,150, L"DUKE");
					break;

				case ACHIBONO_TYPE:
					drPrintf(200,150, L"AKEBONO");
					break;

				case WHEEL_TYPE:
					drPrintf(200,150, L"ERROR!!!!!!");
					break;

				case ARCADE_STICK_TYPE:
					drPrintf(200,150, L"ERROR!!!!!!");
					break;

				default:
					drPrintf(200,150, L"ERROR!!!!!!!");
			}
		
            drSetSize(8.0, 15.0, 0xff00ff00, 0xff000000); //default color				  
			

			for(j = 0; j < countof(tests); j++) {
//				DebugPrint("draw in testme loop\n");
				tests[j].stat = tests[j].BoxFunc(tests[j].stat);
				
			}

            
			int d1 = muGetDriveFromPortSlot(slot, XDEVICE_TOP_SLOT);
			if(d1 != 0) muTop = true;
			int d2 = muGetDriveFromPortSlot(slot, XDEVICE_BOTTOM_SLOT);
			if(d2 != 0) muBottom = true;

			
            if((muTop == false) & (muBottom == false)) gReason = Slot;



			drBox(230,50,330,80, muTop ? 0xff00ff00 : 0xfff0f0f0);
			drBox(230,90,330,120, muBottom ? 0xff00ff00 : 0xfff0f0f0);
			// label boxes
			drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
			drPrintf(345,58, L"Slot 1");
			drPrintf(345,98, L"Slot 2");

			DWORD r;
			BYTE data;
			XINPUT_FEEDBACK feedback;
			memset(&feedback, 0, sizeof(XINPUT_FEEDBACK));
			if(tests[0].stat == testme)	// if LeftTriggerTest is going, rumble left
			{
				data = gData->bAnalogButtons[GPL];


				feedback.Rumble.wLeftMotorSpeed= (data<<8) +data;
				r = gpInputSetState(slot, &feedback);
				if(r != ERROR_IO_PENDING)
					DebugPrint("gpInputSetState returned error %d\n", r);
				while(feedback.Header.dwStatus == ERROR_IO_PENDING)
					;
				if(feedback.Header.dwStatus != ERROR_SUCCESS)
					DebugPrint("Error: %d\n", feedback.Header.dwStatus);
			}
			if(tests[1].stat == testme)	// if RightTriggerTest is going, rumble right
			{
				data = gData->bAnalogButtons[GPR];
				feedback.Rumble.wRightMotorSpeed= (data<<8) +data;
				r = gpInputSetState(slot, &feedback);
				if(r != ERROR_IO_PENDING)
					DebugPrint("gpInputSetState returned error %d\n", r);
				while(feedback.Header.dwStatus == ERROR_IO_PENDING)
					;
				if(feedback.Header.dwStatus != ERROR_SUCCESS)
					DebugPrint("Error: %d\n", feedback.Header.dwStatus);
			}

		//	_asm int 3;
			drShowScreen();							

			if (TscTicksToFSeconds(TscCurrentTime(tim)) > tests[i].secs) {
				tests[i].stat = failed;
			} else {
				if(tests[i].stat == passed) {
					break;
				}
			}

			if(tests[i].stat == failed) {
				overall = failed;
				gReason = (FAILEDREASON) i;
				break;
			}
		}
	}
	return overall;
}

/*************************************************************************************
Function:	main()
Purpose:	the entry-point of cpx. Calls init, does the main loop, then de-inits
Params:		irrelevant
*************************************************************************************/
//DWORD WINAPI TestMain()
//int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow)
int __cdecl main()
{
//	_asm int 3;

	int i;
	init();

	gpPoll();
	Sleep(16);

	drCls();
	drShowScreen();

	while(1) //loop until we're supposed to quit...
	{
		gpUpdateDeviceStateInfo();				//update the button state info...
		muGetDeviceMessages();

		for(i = 0; i < MAX_SLOTS; i++) {
			if(!gpDeviceExists(i)) {
				::gPadStatus[i] = notyet;
			} else if (gPadStatus[i] == notyet) {
				 
				gPadStatus[i] = test(i);

/*
				drCls();
				if(gPadStatus[i] == passed && muTop && muBottom) {
					//passed
					drQuad(250, 350, 0xff00ff00, 550,  50, 0xff00ff00, 600, 100, 0xff00ff00, 300, 400, 0xff00ff00);
					drQuad(250, 450, 0xff00ff00, 300, 400, 0xff00ff00, 150, 250, 0xff00ff00, 100, 300, 0xff00ff00);
				} else {
					//failed
					switch(gReason) {
					   case LeftTrigger:  drPrintf(50,30, L"LeftTrigger Failed"); break;
					   case	RightTrigger: drPrintf(50,30, L"RightTrigger Failed"); break;
					   case LeftThumb:    drPrintf(50,30, L"LeftThumb Failed");break;
					   case DPad:         drPrintf(50,30, L"DPad Failed");break; 
					   case StartSelect:  drPrintf(50,30, L"StartSelect Failed");break;
					   case RightThumb:   drPrintf(50,30, L"RightThumb Failed");break;
					   case Button:       drPrintf(50,30, L"Button Failed");break;
					   case Slot:         drPrintf(50,30, L"Slot Failed");break;
					   case TimeOut:      drPrintf(50,30, L"TimeOut");break;
                       default :          drPrintf(50,30, L"Failed with Unknown Reason");

					}

					drQuad(200, 400, 0xffff0000, 550,  50, 0xffff0000, 600, 100, 0xffff0000, 250, 450, 0xffff0000);
					drQuad(600, 400, 0xffff0000, 250,  50, 0xffff0000, 200, 100, 0xffff0000, 550, 450, 0xffff0000);
				}
*/
				if(gPadStatus[i] == passed && muTop && muBottom) {
					//passed
					drSetSize(50, 100, 0xff00ff00, 0xff000000); //set the color
					drPrintf(240,180, L"PASSED");
					drQuad(240, 290, 0xff00ff00, 330,  220, 0xff00ff00, 340,235, 0xff00ff00, 250,300, 0xff00ff00);
					drQuad(250, 300, 0xff00ff00, 260,  290, 0xff00ff00, 230,260, 0xff00ff00, 220,270, 0xff00ff00);
				} else {
					//failed
					drSetSize(50, 100, 0xffff0000, 0xff000000); //set the color

					switch(gReason) {
					   case LeftTrigger:  drPrintf(210,180, L"LeftTrigger Failed"); break;
					   case	RightTrigger: drPrintf(210,180, L"RightTrigger Failed"); break;
					   case LeftThumb:    drPrintf(210,180, L"LeftThumb Failed");break;
					   case DPad:         drPrintf(210,180, L"DPad Failed");break; 
					   case StartSelect:  drPrintf(210,180, L"StartSelect Failed");break;
					   case RightThumb:   drPrintf(210,180, L"RightThumb Failed");break;
					   case Button:       drPrintf(210,180, L"Button Failed");break;
					   case Slot:         drPrintf(210,180, L"Slot Failed");break;
					   case TimeOut:      drPrintf(210,180, L"TimeOut");break;
                       default :          drPrintf(210,180, L"Failed with Unknown Reason");

					}

					drQuad(230, 295, 0xffff0000, 335,  220, 0xffff0000, 340, 225, 0xffff0000, 235, 300, 0xffff0000);
					drQuad(335, 300, 0xffff0000, 340,  295, 0xffff0000, 235, 220, 0xffff0000, 230, 225, 0xffff0000);
				}
				
				
				drShowScreen();
			}
		}
	}
//		gpPoll();
//		gGlobalCommands.CheckControls();		//see if any commands are being presseed
//		gModeFunctions[gMode](STATUS_NORMAL, 0);	//go to the appropriate mode
//		drShowScreen();							//and draw the screen
	

	//we should theoretically never get here on xbox......

	deinit();


	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\base.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    base.cpp

Abstract:

   implementation of general base functions classes and helper functions
Author:

    Dennis Krueger <a-denkru>   May 2000

Revision History:

--*/
#include "base.h"
#include <draw.h>

void
CRect::Draw(DWORD dwColor)
{
	drBox((float) m_TopLeft.GetX(),
		   (float) m_TopLeft.GetY(),
		   (float) m_BottomRight.GetX(),
		   (float) m_BottomRight.GetY(),
		   dwColor
		   );
};

void CRect::OffsetRect(CPoint Point)
{
	m_TopLeft.SetX(m_TopLeft.GetX() + Point.GetX());
	m_TopLeft.SetY(m_TopLeft.GetY() + Point.GetY());
	m_BottomRight.SetX(m_BottomRight.GetX() + Point.GetX());
	m_BottomRight.SetY(m_BottomRight.GetY() + Point.GetY());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\controls.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    controller.h

Abstract:

    function declarations, type definitions, includes, etc, for peripheral controls

Author:

    Dennis Krueger <a-denkru>   May 2000

Revision History:

--*/


#ifndef __controls_h_
#define __controls_h_

#include <xtl.h>

// controller types
#define STANDARD_TYPE		1
#define ACHIBONO_TYPE		2
#define WHEEL_TYPE			10
#define ARCADE_STICK_TYPE	20

class CController;  // forward

class CControl
{
public:
	CControl(CController * pController) { m_pController = pController;};
	virtual ~CControl() { ; } ;

	CController * m_pController;
};


class CAxis
{
public:
	CAxis() {;};
	~CAxis() {;};
	void SetResolution(SHORT Resolution) { m_Resolution = Resolution;};
	SHORT GetResolution() { return m_Resolution;};
private:
	SHORT m_Resolution;
};


class CAnalogButton:public CControl
{
public:
	CAnalogButton(CController * pController, int index);
	virtual ~CAnalogButton() { ; };
	BYTE GetState();
	BYTE	m_Resolution;
	int		m_Type;
	
};


class CDigitalButton:public CControl
{
public:
	CDigitalButton(CController * pController, WORD wType);
	virtual ~CDigitalButton() {;};
	BOOL GetState();

	WORD m_wType;

};


class CThumbstick:public CControl
{
public:
	CThumbstick(CController * pController, WORD wThumbType);
	virtual ~CThumbstick();

	SHORT GetX();
	SHORT GetY();
	BOOL  GetButtonState();

	BOOL  ExistsX() { return m_Axis[0].GetResolution() ? FALSE : TRUE; };
	BOOL  ExistsY() { return m_Axis[1].GetResolution() ? FALSE : TRUE; };
	BOOL  ExistsButton() { return m_pButton ? FALSE : TRUE; };


	WORD			m_wThumbType;
	CDigitalButton *	m_pButton;
	CAxis			m_Axis[2];  // x,y
};


class CDPad:public CControl
{
public:
	CDPad(CController * pController);
	virtual ~CDPad();

	CDigitalButton * m_pButton[4]; // UP,DOWN,LEFT,RIGHT
	BOOL GetUp();
	BOOL GetDown();
	BOOL GetLeft();
	BOOL GetRight();

};



class CController
{
public:
	CController();
	virtual ~CController();
	virtual DWORD Init(DWORD dwPort);
	void Refresh();
	
	XINPUT_STATE m_InputState;
	XINPUT_CAPABILITIES m_InputCaps;


// control members
	BYTE				m_SubType;
	HANDLE				m_Handle;
	DWORD				m_dwPort;
	CThumbstick	*		m_pThumbStick[2]; // Left and Right Thumbsticks
	CDPad	*			m_pDPad;
	CDigitalButton *	m_pStartButton;
	CDigitalButton	*	m_pBackButton;
	CAnalogButton	*	m_pAnalogButton[8]; // indexes are the same as the xinput_gamepad defines

private:

	DWORD			m_dwPacketNumber;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\dukeprod2.cpp ===
//-----------------------------------------------------------------------------
// File: DukeProd2.cpp
//
// Desc: General purpose test tool for input devices based on XBApplication Framework and
//		  Dukeprod
//
// Hist: Oct 01 2001 - Created
//
//
// Author:  Dennis Krueger <a-denkru>
//
// 
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <process.h>
#include "dukeprod2.h"
//#include "controls.h"
#include "draw.h"
#include "TestControls.h"

//-----------------------------------------------------------------------------
// Name: class CInputTestApp
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CInputTestApp 
{
public:
    CInputTestApp();
	~CInputTestApp();

    virtual HRESULT Initialize(BYTE bPort);
	virtual void Run();

	CTestController  * m_pController;

	BOOL	m_fStopRender;
	BOOL	m_fStopRefresh;
	HANDLE  m_hSynchRender;
	HANDLE  m_hSynchRefresh;

};


DWORD WINAPI Render(void * pParam);
DWORD WINAPI Refresh(void * pParam);

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    XInitDevices(0,NULL); // initialize the devices

	drInit();
	// find all attached controllers
	Sleep(2000);  // delay a couple seconds to allow emumeration to complete

	while(1) // run until rebooted
	{
		DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );
		if(0 == dwDeviceMask)
		{
			// no devices connected, continue to spin
			drCls();
			drSetSize(50, 100, 0xffff0000, 0xff000000); //set the color
			drPrintf(200,150, L"No Controller Detected!");
			drShowScreen();

			continue;
		}
		BYTE bPort = 0;
		for(int i = 1; i < 9;i <<= 1)
		{
			if(dwDeviceMask & i)
			{
				// found the first slot supporting a controller, exit
				break;
			}
			bPort++;
		}

		CInputTestApp * xbApp = new CInputTestApp();
		if( FAILED( xbApp->Initialize(bPort) ) )
			return;
		drCls();
		drShowScreen();
		xbApp->Run();
		delete xbApp; // end of test for this controller

	}
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CInputTestApp class
//-----------------------------------------------------------------------------
CInputTestApp::CInputTestApp() 
{
;
}

CInputTestApp::~CInputTestApp()
{
	delete m_pController;
}


void
CInputTestApp::Run()
{
	HANDLE hResult;

// spawn a refresh thread so we don't need to maintain that either
	m_fStopRefresh = FALSE;

	hResult = CreateThread(NULL,0,Refresh,this,0,NULL);
	if(NULL == hResult)
	{
		DWORD dwResult = GetLastError();
		return;
	}
	Sleep(0); // allow refresh thread to run

// spawn the render thread so we don't need to maintain it
	m_fStopRender = FALSE;
	hResult = CreateThread(NULL,0,Render,this,0,NULL);
	if(NULL == hResult)
	{
		DWORD dwResult = GetLastError();
		return;
	}

	BOOL fResult = m_pController->Test();
	while(FALSE == m_pController->m_fRemoved)
	{
		Sleep(0); // release quantum
		// spin until/if removed
	}
	m_fStopRefresh = TRUE; // turn off refresh
	m_fStopRender = TRUE; // stop rendering

	// wait for refresh and render to quit
	WaitForSingleObject(m_hSynchRefresh,INFINITE);
	WaitForSingleObject(m_hSynchRender,INFINITE);
	
	return;



}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CInputTestApp::Initialize(BYTE bPort)
{

	m_fStopRender = FALSE; // init flags
	m_fStopRefresh = FALSE;
    // init drawing from cpxlib
    // locate the controller to initialize
	m_hSynchRefresh = CreateEvent(NULL,FALSE,FALSE,NULL);
	if(NULL == m_hSynchRefresh) return E_FAIL;
	m_hSynchRender = CreateEvent(NULL,FALSE,FALSE,NULL);
	if(NULL == m_hSynchRender) return E_FAIL;



	// found the first port with a controller, this is the one we'll test
	m_pController = new CTestController;
	DWORD dwResult = m_pController->InitTest(bPort);
	if(0 != dwResult)
	{
		// failed init
		return E_FAIL;
	}

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
DWORD
WINAPI Refresh(void * pThis)
{
	DWORD dwResult;
	
	CInputTestApp * pApp = (CInputTestApp *) pThis;


	DWORD dwAddDevice,dwRemoveDevice, dwMuMask;
	// make mask for mu test
	dwMuMask = (1 << pApp->m_pController->m_dwPort) | (0x10000 << pApp->m_pController->m_dwPort); // check upper and lower slots on our port
	while(FALSE == pApp->m_fStopRefresh)
	{
		if(XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD,&dwAddDevice, &dwRemoveDevice))
		{
			// a controller has been added or removed, all we care about is removal for the
			// ...controller under test
			if(dwRemoveDevice & 1 << pApp->m_pController->m_dwPort)
			{
				// this controller has been removed, close up shop
				pApp->m_pController->m_fRemoved = TRUE;
				pApp->m_fStopRender = TRUE;
				pApp->m_fStopRefresh = TRUE;
				continue;
			}
		}

		dwResult = pApp->m_pController->Refresh();  // keep values fresh
		if(ERROR_DEVICE_NOT_CONNECTED == dwResult)
		{
			pApp->m_pController->m_fRemoved = TRUE;
			pApp->m_fStopRefresh = TRUE;
			pApp->m_fStopRender = TRUE;
			continue; // drop out of while
		}


		// maintain MU status here
        if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &dwAddDevice, &dwRemoveDevice))
		{
			if(dwAddDevice & dwMuMask) // catch either upper or lower port
			{
				if(dwAddDevice & 0xffff0000)
				{
					pApp->m_pController->m_dwSlot[1] = TRUE;
				}
				if(dwAddDevice & 0x0000ffff)
				{
					pApp->m_pController->m_dwSlot[0] = TRUE;
				}
			}
			// do removals after adds, the same port could have been inserted and removed during same call
#ifdef NEVER  // don't record removals
			if(dwRemoveDevice & dwMuMask) // catch either upper or lower port
			{
				if(dwRemoveDevice & 0xffff0000)
				{
					pApp->m_pController->m_dwSlot[1] = FALSE;
				}
				if(dwRemoveDevice & 0x0000ffff)
				{
					pApp->m_pController->m_dwSlot[0] = FALSE;
				}
			}
#endif // 0
		}


		Sleep(0); // release quantum
	}
	SetEvent(pApp->m_hSynchRefresh); // inform main loop we're done

	return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
DWORD WINAPI Render(void * pThis)
{
	CInputTestApp * pApp = (CInputTestApp *) pThis;
	
// setup frame rate

	UINT iFlasher = 0;

	while(FALSE == pApp->m_fStopRender)
	{
		Sleep(100); // refresh 10 times a second
		drCls();
		pApp->m_pController->Draw();
		drShowScreen();
		// toggle blink every .5 secs for display processes
		if(0 == ++iFlasher % 5) 
		{
			if(TRUE == pApp->m_pController->m_fFlash)
				 pApp->m_pController->m_fFlash = FALSE;
			else 
				pApp->m_pController->m_fFlash =  TRUE;
		}
		pApp->m_pController->DecCountDown(); // dec .1 sec count down timer for client test timeouts
	}
	pApp->m_pController->SetCountDown(0); // clear countdown timer to release any waiting tests
	SetEvent(pApp->m_hSynchRender); // inform main loop we're done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=xboxapp
PROJNAME=DukeProd

BROWSER_INFO=1

C_DEFINES=$(C_DEFINES)

XE_FLAGS   = $(XE_FLAGS) /TESTNAME:$(PROJNAME)  /INITFLAGS:0x00000000

XNOHARDISK=1

USE_LIBCMT=1


INCLUDES=\
	$(SDKDIR); \
	$(BASEDIR)\private\test\inc;\
    $(BASEDIR)\private\ntos\inc;\
	$(PRIVATE_INC_PATH);\
	$(BASEDIR)\private\test\inc\cpx;\
	$(SDK_INC_PATH);\
	$(BASEDIR)\private\test\common\include;\
    $(INCLUDES)

SOURCES=\
    dukeprod2.cpp\
	TestControls.cpp \
	base.cpp

LINKLIBS=\
	$(XDK_LIB_PATH)\d3d8$(D).lib                \
    $(XDK_LIB_PATH)\d3dx8$(D).lib				\
    $(XDK_LIB_PATH)\dsound$(D).lib              \
    $(XDK_LIB_PATH)\xgraphics$(D).lib			\
    $(SDK_LIB_PATH)\xfont$(D).lib               \
    $(BASEDIR)\private\test\lib\*\cpxlib.lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\dukeprod2.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dukeprod2.h

Abstract:

    function declarations, type definitions, includes, etc, for dukeprod2

Author:

    Dennis Krueger <a-denkru> Oct 2001

Revision History:

--*/
#ifndef __dukeprod2_h_
#define __dukeprod2_h_


#ifndef UNICODE
#define UNICODE
#endif

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

#define MAX_SLOTS XGetPortCount()


#endif //!defined (__cpx_h_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\Controls.cpp ===
//-----------------------------------------------------------------------------
// File: Controls.cpp
//
// Desc: Implementation of CController and CControl Classes
//
// Hist: Oct 01 2001 - Created
//
//
// Author:  Dennis Krueger <a-denkru>
//
// 
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "controls.h"
#include "testcontrols.h"

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif




WORD DPadButtonID[4] = {
	XINPUT_GAMEPAD_DPAD_UP,
	XINPUT_GAMEPAD_DPAD_DOWN,
	XINPUT_GAMEPAD_DPAD_LEFT,
	XINPUT_GAMEPAD_DPAD_RIGHT
};



// CDPad methods
CDPad::CDPad(CController * pController) : CControl(pController)
{
		WORD wMask = 1;
		for(int i = 0; i < 4; i++)
		{
			if(pController->m_InputCaps.In.Gamepad.wButtons & wMask)
			{
				m_pButton[i] = new CDigitalButton(pController,DPadButtonID[i]);
			}
			wMask <<= 1;
		}

}

CDPad::~CDPad()
{
	for(int i = 0; i<4; i++)
	{
		if(m_pButton[i]) delete m_pButton[i];
	}
}

BOOL
CDPad::GetUp()
{
	if(m_pButton[0]
		return m_pButton[0]->GetState();
	else
		return FALSE;
}

BOOL
CDPad::GetDown()
{
	if(m_pButton[1]
		return m_pButton[1]->GetState();
	else
		return FALSE;
}

BOOL
CDPad::GetLeft()
{
	if(m_pButton[2]
		return m_pButton[2]->GetState();
	else
		return FALSE;
}

BOOL
CDPad::GetRight()
{
	if(m_pButton[3]
		return m_pButton[3]->GetState();
	else
		return FALSE;
}

//CDigitalButton methods
CDigitalButton::CDigitalButton(CController * pController, WORD wType)
		:CControl(pController)
{
	m_wType = wType;
	m_pController = pController;
}

BOOL
CDigitalButton::GetState()
{
	return m_pController->m_InputState.Gamepad.wButtons & m_wType ? TRUE : FALSE;
}




// CAnalogButton methods
CAnalogButton::CAnalogButton(CController * pController, int index) : CControl(pController)
{
			m_Resolution = pController->m_InputCaps.In.Gamepad.bAnalogButtons[index];
			m_Type = index;

}

BYTE
CAnalogButton::GetState()
{

	return m_pController->m_InputState.Gamepad.bAnalogButtons[m_Type];
}


// CThumbstick methods
CThumbstick::CThumbstick(CController * pController,WORD wThumbType) : CControl(pController)
{
	m_wThumbType = wThumbType;
	if(XINPUT_GAMEPAD_LEFT_THUMB == wThumbType)
	{
		m_Axis[0].SetResolution(pController->m_InputCaps.In.Gamepad.sThumbLX);
		m_Axis[1].SetResolution(pController->m_InputCaps.In.Gamepad.sThumbLY);
	} else
	{
		m_Axis[0].SetResolution(pController->m_InputCaps.In.Gamepad.sThumbRX);
		m_Axis[1].SetResolution(pController->m_InputCaps.In.Gamepad.sThumbRY);
	}

	if(pController->m_InputCaps.In.Gamepad.wButtons & wThumbType)
	{
		m_pButton = new CDigitalButton(pController, wThumbType);
	} else
	{
		m_pButton = NULL;
	}
}



CThumbstick::~CThumbstick()
{
	if(m_pButton) delete m_pButton;
}

SHORT
CThumbstick::GetX()
{
	SHORT sState;
	if(XINPUT_GAMEPAD_LEFT_THUMB == m_wThumbType)
	{
		sState = m_pController->m_InputState.Gamepad.sThumbLX;
	} else
	{
		sState =  m_pController->m_InputState.Gamepad.sThumbRX;
	}
	return sState;
}

SHORT
CThumbstick::GetY()
{
	SHORT sState;
	if(XINPUT_GAMEPAD_LEFT_THUMB == m_wThumbType)
	{
		sState = m_pController->m_InputState.Gamepad.sThumbLY;
	} else
	{
		sState =  m_pController->m_InputState.Gamepad.sThumbRY;
	}
	return sState;
}

BOOL
CThumbstick::GetButtonState()
{
	return m_pController->m_InputState.Gamepad.wButtons & m_wThumbType ? TRUE : FALSE;
}


// Controller Class Methods
CController::CController()
{
	m_dwPacketNumber = 0;
	// set handles and pointers to NULL
	m_Handle = NULL;
	m_pDPad = NULL;
	for(int i = 0; i < 8; i++)
	{
		m_pAnalogButton[i] = NULL;
	}
	m_pThumbStick[0] = m_pThumbStick[1] = NULL;
	m_pStartButton = NULL;
	m_pBackButton = NULL;

}

CController::~CController()
{
	if(m_pDPad) delete m_pDPad;
	for(int i = 0; i<8; i++)
	{
		if(m_pAnalogButton[i]) delete m_pAnalogButton[i];
	}
	if(m_pThumbStick[0]) delete m_pThumbStick[0];
	if(m_pThumbStick[1]) delete m_pThumbStick[1];
	if(m_pStartButton) delete m_pStartButton;
	if(m_pBackButton) delete m_pBackButton;
	if(m_Handle) XInputClose(m_Handle);
}


DWORD
CController::Init(DWORD dwPort)
{
	DWORD	dwResult;
	WORD	wMask;

	// first open a handle to this controller
	m_Handle = XInputOpen(XDEVICE_TYPE_GAMEPAD,dwPort,XDEVICE_NO_SLOT,NULL);
	if(NULL == m_Handle)
		return GetLastError(); // failed

	// have open controller, populate controls
	m_dwPort = dwPort; // stash active port for this controller
	dwResult = XInputGetCapabilities(m_Handle, &m_InputCaps);
	if(ERROR_SUCCESS != dwResult)
	{
		XInputClose(m_Handle);
		m_Handle = NULL;
		return dwResult;
	}
	// got caps, now set existence flags for supported controls
	
	// DPAD
	if(m_InputCaps.In.Gamepad.wButtons & 0x000f) // test for any portion of dpad
	{
		m_pDPad = new CDPad(this);
	}
	
	// Start Button
	if(m_InputCaps.In.Gamepad.wButtons & XINPUT_GAMEPAD_START)
	{
		m_pStartButton = new CDigitalButton(this, XINPUT_GAMEPAD_START);
	}

	// Back Button
	if(m_InputCaps.In.Gamepad.wButtons & XINPUT_GAMEPAD_BACK)
	{
		m_pBackButton = new CDigitalButton(this,XINPUT_GAMEPAD_BACK);
	}

	// All Analog buttons

	for(int i = 0; i < 8 ; i++)
	{
		if(m_InputCaps.In.Gamepad.bAnalogButtons[i])
		{
			m_pAnalogButton[i] = new CAnalogButton(this,i);
		}
	}

	// Left Thumbstick
	if(m_InputCaps.In.Gamepad.sThumbLX || 
			m_InputCaps.In.Gamepad.sThumbLY ||
			(m_InputCaps.In.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB))
	{
		m_pThumbStick[0] = new CThumbstick(this,XINPUT_GAMEPAD_LEFT_THUMB);
	}

	// Right Thumbstick
	if(m_InputCaps.In.Gamepad.sThumbRX ||
				m_InputCaps.In.Gamepad.sThumbRY ||
				(m_InputCaps.In.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB))
	{
		m_pThumbStick[1] = new CThumbstick(this,XINPUT_GAMEPAD_RIGHT_THUMB);
	}

	return S_OK;
}

void CController::Refresh()
{
	DWORD dwResult;

	dwResult = XInputGetState(m_Handle,&m_InputState);
	if(ERROR_SUCCESS != dwResult)
		return;

	if(m_InputState.dwPacketNumber == m_dwPacketNumber)
		return; // nothing new
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\TestControls.cpp ===
//-----------------------------------------------------------------------------
// File: TestControls.cpp
//
// Desc: Implementation of Peripheral Tests based on the CController and CControl Classes
//
// Hist: Oct 08 2001 - Created
//
//
// Author:  Dennis Krueger <a-denkru>
//
// 
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "TestControls.h"

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

// screen position by control type for Standard Type

CPoint DukeStart[esMax];
CPoint AkiStart[esMax];

WCHAR * Labels[] = 
{
	L"A",
	L"B",
	L"X",
	L"Y",
	L"Black",
	L"White",
	L"T1",
	L"T2",
	L"Left Stick",
	L"DPad",
	L"Back",
	L"Start",
	L"Right Stick"
};

WCHAR * ControllerLabels[] =
{
	L"Standard Game Pad",
	L"Alternate Game Pad",
	L"Steering Wheel",
	L"Arcade Stick",
	L"Flight Stick",
	L"Board Controller"
};

DWORD CurrColor[] =
{
	BlueColor,
	YellowColor,
	GreenColor,
	RedColor,
	GrayColor
};

XINPUT_FEEDBACK gFeedback;


void InitAkiLocs()
{
	AkiStart[esLTrigger].SetXY(50,70); // Left Trigger 0
	AkiStart[esRTrigger].SetXY(520,70); // Right Trigger 1
	AkiStart[esLThumb].SetXY(50,160); // Left Thumb 2
	AkiStart[esDPad].SetXY(115,335); // DPad 3
	AkiStart[esBackButton].SetXY(60,250); // Back Button 4
	AkiStart[esStartButton].SetXY(105,250); // Start Button 5
	AkiStart[esRThumb].SetXY(340,360); // Right Thumb 6
	AkiStart[esX].SetXY(410,200); // X 7 
	AkiStart[esY].SetXY(450,170); // Y 8
	AkiStart[esWhite].SetXY(445,310); // White 9
	AkiStart[esA].SetXY(450,230); // A 10
	AkiStart[esB].SetXY(490,200); // B 11
	AkiStart[esBlack].SetXY(490,290);  // Black 12
}

void InitDukeLocs()
{

	DukeStart[esLTrigger].SetXY(50,70); // Left Trigger 0
	DukeStart[esRTrigger].SetXY(520,70); // Right Trigger 1
	DukeStart[esLThumb].SetXY(50,160); // Left Thumb 2
	DukeStart[esDPad].SetXY(115,335); // DPad 3
	DukeStart[esBackButton].SetXY(240,400); // Back Button 4
	DukeStart[esStartButton].SetXY(280,400); // Start Button 5
	DukeStart[esRThumb].SetXY(340,360); // Right Thumb 6
	DukeStart[esX].SetXY(410,210); // X 7 
	DukeStart[esY].SetXY(450,210); // Y 8
	DukeStart[esWhite].SetXY(490,210); // White 9
	DukeStart[esA].SetXY(410,260); // A 10
	DukeStart[esB].SetXY(450,260); // B 11
	DukeStart[esBlack].SetXY(490,260);  // Black 12
}


CTestAnalogButton::CTestAnalogButton(CTestController * pController, int index) 
						:CTestControl(pController)
{
	m_pTestController = pController;
	m_iSize = 20; // set size of box
	ZeroMemory(m_bTestResults,sizeof(m_bTestResults));
	m_Resolution = pController->m_pInputCaps->In.Gamepad.bAnalogButtons[index];
	m_iType = index;
}

void
CTestAnalogButton::Draw()
{
	CRect ThisRect;
	CPoint BottomRight;
	CPoint Offset;
	DWORD dwColor;
// 0 value is 4x10 rect
	ThisRect.SetTopLeft(m_Location);
	BottomRight.SetX(m_Location.GetX() + 4);
	BottomRight.SetY(m_Location.GetY() + m_iSize);
	ThisRect.SetBottomRight(BottomRight);
	if(m_pTestController->m_fFlash && m_bTestResults[0] == eTesting)
		dwColor = GrayColor;
	else
		dwColor = CurrColor[m_bTestResults[0]]; // get current color
	ThisRect.Draw(dwColor);

// setup for 16 2x10 rects	
	Offset.SetX(m_Location.GetX() + 4);
	Offset.SetY(m_Location.GetY());
	ThisRect.SetTopLeft(Offset);
	Offset.SetX(Offset.GetX()+4);
	Offset.SetY(Offset.GetY()+m_iSize);
	ThisRect.SetBottomRight(Offset);
	Offset.SetX(2);
	Offset.SetY(0);
	for(int i = 1; i<TESTREGIONS+1; i++)
	{
		if(m_pTestController->m_fFlash && m_bTestResults[i] == eTesting)
			dwColor = GrayColor;
		else
			dwColor = CurrColor[m_bTestResults[i]]; // get current color
		ThisRect.Draw(dwColor);
		ThisRect.OffsetRect(Offset);
	}

	// expand ending 255 value rect back to 4
	Offset = ThisRect.GetTopLeft(); // get current position
	Offset.SetX(Offset.GetX()+4);
	ThisRect.SetBottomRight(Offset);
	if(m_pTestController->m_fFlash && m_bTestResults[TESTREGIONS+1] == eTesting)
		dwColor = GrayColor;
	else
		dwColor = CurrColor[m_bTestResults[TESTREGIONS+1]]; // get current color
	ThisRect.Draw(dwColor);

	Offset.SetX(m_Location.GetX() + 5);
	Offset.SetY(m_Location.GetY() + m_iSize + 5);
	ThisRect.SetTopLeft(Offset);
	Offset.SetX(Offset.GetX() + 10);
	Offset.SetY(Offset.GetY() + 10);
	ThisRect.SetBottomRight(Offset);

	// put in "return to zero" button
	if(m_pTestController->m_fFlash && m_bTestResults[TESTREGIONS+2] == eTesting)
		dwColor = GrayColor;
	else
		dwColor = CurrColor[m_bTestResults[TESTREGIONS+2]]; // get current color
	
	ThisRect.Draw(dwColor);

	ThisRect.SetTopLeft(m_Location);  // reset to fron
	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the text color
	drPrintf((float)m_Location.GetX(),(float) m_Location.GetY() - 14, Labels[m_iType]);
	if(TRUE == m_fUnderTest)
	{
		drPrintf(70,30,L"%s = 0x%02X",Labels[m_iType],TGetState());
	}

}

BYTE
CTestAnalogButton::TGetState()
{
	return m_pTestController->m_pInputState->Gamepad.bAnalogButtons[m_iType];
}


BOOL
CTestAnalogButton::Test()
{
	
	DWORD	dwResult;
	BOOL	fResult = FALSE;
	// set test results to active
	for(int i = 0; i< TESTREGIONS+3; i++)
	{
		m_bTestResults[i] = eTesting;
	}
	m_fUnderTest = TRUE;
	m_bTestResults[1] = eGood;  // note: not gathering in the 1-32 range, too difficult to hit
	m_pTestController->SetCountDown(200); // 20 second countdown
	BYTE bCurrValue = 0;
	BOOL fFinalFlag = FALSE;
	BOOL fNotDone = TRUE;
	while(m_pTestController->GetCountDown())
	{
		bCurrValue = TGetState(); // get current value of control
		// test for cross talk each time we get the analog button state
		int ct = 0;
		for(int i = 0; i<8; i++)
		{
			if(0 < m_pTestController->m_pInputState->Gamepad.bAnalogButtons[i])
				ct++;
		}
		if(ct > 2) // got three or more positive analog buttons, fail crosstalk
			m_pTestController->m_fCrossTalk = TRUE;

		// distribute values among test results
		switch(bCurrValue)
		{
			// first test edge cases
			case 0:
				m_bTestResults[0] = eGood;
				if(TRUE == fFinalFlag)  // test for return to zero as final value
				{
					m_bTestResults[TESTREGIONS+2] = eGood;
					fNotDone = FALSE;
				}
				break;
			case 255:
				m_bTestResults[TESTREGIONS+1] = eGood;
			// distribute all other results among the TESTREGIONS elements up to 254
			default:
				m_bTestResults[(bCurrValue/(255/TESTREGIONS))+1] = eGood;
				break;
		}
		// check for completion
		fFinalFlag = TRUE;
		for(int i = 0; i<TESTREGIONS+2; i++)
		{
			if(eTesting == m_bTestResults[i])
			{
				fFinalFlag = FALSE;
				break; // no need to test further
			}
		}
		if(FALSE == fNotDone)
		{
			break;  // break out of while, we're complete
		}
		if(esLTrigger == m_iType || esRTrigger == m_iType)
		{
			if(bCurrValue)
			{
				// let's rumble
				ZeroMemory(&gFeedback,sizeof(XINPUT_FEEDBACK));
				if(esLTrigger == m_iType)
				{
					// make proportional to 64K
					gFeedback.Rumble.wLeftMotorSpeed = (bCurrValue<<8) + bCurrValue;
				} else
				{
					gFeedback.Rumble.wRightMotorSpeed = (bCurrValue<<8) +bCurrValue;
				}
				dwResult = XInputSetState(m_pTestController->m_Handle,&gFeedback);
				if(ERROR_IO_PENDING == dwResult)
				{
					// wait out i/o async pending condition
					while(dwResult == gFeedback.Header.dwStatus) ;
				}
			}
		}

		Sleep(0); // release quantum
	} // while
	
	// set any remaining incomplete test segments to fail after exiting timeout loop
	for(int i = 0; i <TESTREGIONS+3; i++)
	{
		if(eTesting == m_bTestResults[i])
			m_bTestResults[i] = eBad;
	}
				
	// ensure rumble pack turned of if handling triggers
	if(esLTrigger == m_iType || esRTrigger == m_iType)
	{
		if(esLTrigger == m_iType)
		{
			gFeedback.Rumble.wLeftMotorSpeed = 0;
		} else
		{
			gFeedback.Rumble.wRightMotorSpeed = 0;
		}
		dwResult = XInputSetState(m_pTestController->m_Handle,&gFeedback);
		if(ERROR_IO_PENDING == dwResult)
		{
			// wait out i/o async pending condition
			while(ERROR_IO_PENDING == gFeedback.Header.dwStatus) ;
		}
	}
	for(int i = 0; i < TESTREGIONS+3; i++)	
	{
		// return error if any test segments are bad
		if(eBad == m_bTestResults[i])
		{
			fResult = TRUE;
			break;
		}
	}
	m_fUnderTest = FALSE;
	return fResult;
}


BOOL
CTestDigitalButton::TGetState()
{
	
	return m_pTestController->m_pInputState->Gamepad.wButtons & m_wType ? TRUE : FALSE;
}


CTestDigitalButton::~CTestDigitalButton()
{
	;
}

CTestDigitalButton::CTestDigitalButton(CTestController * pController, WORD wType) 
							:CTestControl(pController)
{
	m_iSize = 20; // set size of box
	m_bTestResult = eNotyet;
	m_wType = wType;
}


void
CTestDigitalButton::Draw()
{
	int		LabelIndex;
	CRect	ThisRect;
	CPoint	BottomRight;
	DWORD	dwColor;

	// make a square with m_size sides
	ThisRect.SetTopLeft(m_Location);
	BottomRight.SetX(m_Location.GetX() + m_iSize);
	BottomRight.SetY(m_Location.GetY() + m_iSize);
	ThisRect.SetBottomRight(BottomRight);
	if(m_pTestController->m_fFlash && m_bTestResult == eTesting)
		dwColor = GrayColor;
	else
		dwColor = CurrColor[m_bTestResult]; // get current color
	ThisRect.Draw(dwColor);


	// start and back are the only discreet digital buttons, the others are either part of the dpad
	// ... or components of the thumbstick
	if(XINPUT_GAMEPAD_START == m_wType)
	{
		LabelIndex = esStartButton;
	} else
	{
		LabelIndex = esBackButton;
	}
	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the text color
	drPrintf((float)m_Location.GetX(),(float) m_Location.GetY() - 14, Labels[LabelIndex]);
	if(eTesting == m_bTestResult)
		drPrintf(70,30,L"Digital Button Status = 0x%04X",m_pTestController->m_pInputState->Gamepad.wButtons);

}

BOOL
CTestDigitalButton::Test()
{
	BOOL	fResult = FALSE;	// test complete
	BOOL	fGotOn = FALSE;		// detected set status
	BOOL	fButtonState;
	// set testing status
	m_bTestResult = eTesting;
	m_pTestController->SetCountDown(50); // allow 5 secs to get button pressed
	while(m_pTestController->GetCountDown())
	{
		fButtonState = TGetState();
		if(TRUE == fButtonState)
		{
			fGotOn = TRUE;
		} else if(TRUE == fGotOn) // if we've already found set
		{
			m_bTestResult = eGood; // zero after set
			break;
		}
	} // while
	if(eGood != m_bTestResult)
	{
		m_bTestResult = eBad;
		fResult = TRUE;
	}
	return fResult;
}

WORD DPadButtonID[4] = {
	XINPUT_GAMEPAD_DPAD_UP,
	XINPUT_GAMEPAD_DPAD_DOWN,
	XINPUT_GAMEPAD_DPAD_LEFT,
	XINPUT_GAMEPAD_DPAD_RIGHT
};


BYTE DPadTestMatrix[9];

// testdpad methods

CTestDPad::CTestDPad(CTestController * pController) : CTestControl(pController)
{
	WORD wMask = 1;
	for(int i = 0; i < 4; i++)
	{
		if(pController->m_pInputCaps->In.Gamepad.wButtons & wMask)
		{
			m_pButton[i] = new CTestDigitalButton(pController,DPadButtonID[i]);
		} else
		{
			m_pButton[i] = NULL;
		}
		wMask <<= 1;
	}

	// now assign the test matrix based on the supported buttons
	// first init to false
	for(int i = 0; i < 9; i++)
	{
		DPadTestMatrix[i] = 0;
	}

	DPadTestMatrix[4] = 0; // middle always true if DPad exists

	if(m_pButton[0]) // if up
	{
		DPadTestMatrix[1] = XINPUT_GAMEPAD_DPAD_UP; //up only
		if(m_pButton[2])
			DPadTestMatrix[0] = XINPUT_GAMEPAD_DPAD_UP | XINPUT_GAMEPAD_DPAD_LEFT; //up and left
		if(m_pButton[3])
			DPadTestMatrix[2] = XINPUT_GAMEPAD_DPAD_UP | XINPUT_GAMEPAD_DPAD_RIGHT; // up and right
	}
	if(m_pButton[1])
	{
		DPadTestMatrix[7] = XINPUT_GAMEPAD_DPAD_DOWN; // down
		if(m_pButton[2])
			DPadTestMatrix[6] = XINPUT_GAMEPAD_DPAD_DOWN | XINPUT_GAMEPAD_DPAD_LEFT; // down and left
		if(m_pButton[3])
			DPadTestMatrix[8] = XINPUT_GAMEPAD_DPAD_DOWN | XINPUT_GAMEPAD_DPAD_RIGHT; // down and right
	}
	if(m_pButton[2])
		DPadTestMatrix[3] = XINPUT_GAMEPAD_DPAD_LEFT;  // left
	if(m_pButton[3])
		DPadTestMatrix[5] = XINPUT_GAMEPAD_DPAD_RIGHT; // right

// test and draw truth matrix now set	
	CRect TempRect;
	CPoint TempPoint,TempPoint1,OffsetPoint;

	// init initial values of the 9 test locations
	m_iSize = 20;
	m_pTestController = pController;
	
	TempPoint.SetXY(0,0); TempPoint1.SetXY(m_iSize,m_iSize);

	TempRect.Set(TempPoint,TempPoint1);

	// set first row across
	m_TestRect[0] = TempRect;
	OffsetPoint.SetXY(m_iSize,0);
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[1] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[2] = TempRect;

	// set second row across
	TempPoint.SetXY(0,m_iSize); TempPoint1.SetXY(m_iSize,m_iSize*2);
	TempRect.Set(TempPoint,TempPoint1);
	m_TestRect[3] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[4] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[5] = TempRect;

	// set third row across
	TempPoint.SetXY(0,m_iSize*2); TempPoint1.SetXY(m_iSize,m_iSize*3);
	TempRect.Set(TempPoint,TempPoint1);
	m_TestRect[6] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[7] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[8] = TempRect;

	for(int i = 0; i < 9; i++)
	{
		m_bTestResults[i] = eNotyet;
	}
	// done with init
}

CTestDPad::~CTestDPad()
{
	for(int i = 0; i<4; i++)
	{
		if(m_pButton[i]) delete m_pButton[i];
	}
}


BOOL
CTestDPad::TGetUp()
{
	if(m_pButton[0])
		return m_pButton[0]->TGetState();
	else
		return FALSE;
}

BOOL
CTestDPad::TGetDown()
{
	if(m_pButton[1])
		return m_pButton[1]->TGetState();
	else
		return FALSE;
}

BOOL
CTestDPad::TGetLeft()
{
	if(m_pButton[2])
		return m_pButton[2]->TGetState();
	else
		return FALSE;
}

BOOL
CTestDPad::TGetRight()
{
	if(m_pButton[3])
		return m_pButton[3]->TGetState();
	else
		return FALSE;
}

void
CTestDPad::SetStart(CPoint Start)
{
	m_Location = Start; // save start
	// adjust the 9 boxes by the starting point
	for(int i = 0; i < 9; i++)
	{
		m_TestRect[i].OffsetRect(Start);
	}
}
	

void
CTestDPad::Draw()
{
	DWORD dwColor;
	
	// draw the testable area

	for(int i = 0; i< 9; i++)
	{
		if(DPadTestMatrix[i])
		{
			dwColor = CurrColor[m_bTestResults[i]];
			m_TestRect[i].Draw(dwColor);
		}
	}
	dwColor = CurrColor[m_bTestResults[4]];

	m_TestRect[4].Draw(dwColor); // middle is special case of all zeros

	// now draw label
	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the text color
	drPrintf((float)m_Location.GetX() + 4,(float) m_Location.GetY() - 14, Labels[esDPad]);
	// draw wButton value if under test
	if(TRUE == m_fUnderTest)
	{
		drPrintf(70,30,L"Digital Button Status = %04x",m_pTestController->m_pInputState->Gamepad.wButtons);
	}


}

int DPadTestOrder[9] = {1,0,3,6,7,8,5,2,4};

BOOL
CTestDPad::Test()
{
	BOOL fResult = FALSE; // set to ok
	int iTestNumber, iCurrTest = 0 ;
	m_pTestController->SetCountDown(200); // give twenty seconds
	m_fUnderTest = TRUE;
	while(m_pTestController->GetCountDown())
	{
		if(9 == iCurrTest) break;
		iTestNumber = DPadTestOrder[iCurrTest];
		if(DPadTestMatrix[iTestNumber] || 4 == iTestNumber)
		{
			m_bTestResults[iTestNumber] = eTesting;
		} else
		{
			iCurrTest++; // go on to next test
			continue;
		}
		if((m_pTestController->m_pInputState->Gamepad.wButtons & 0x0f) == DPadTestMatrix[iTestNumber])
		{
			m_bTestResults[iTestNumber] = eGood;
			iCurrTest++;
		}
	} // while
	for(int i = 0; i< 9; i++)
	{
		if(eGood != m_bTestResults[i])
		{
			m_bTestResults[i] = eBad;
			fResult = TRUE;
		}
	}
	m_fUnderTest = FALSE;
	return fResult;
}	




CTestThumbstick::CTestThumbstick(CTestController * pController, WORD wType) : CTestControl(pController)
{

	CRect TempRect;
	CPoint TempPoint,TempPoint1,OffsetPoint;
	fUnderTest = FALSE;
	// init initial values of the 9 test locations
	m_iSize = 20;

	// discover configuration of this thumbstick or wheel
	m_wThumbType = wType;
	if(XINPUT_GAMEPAD_LEFT_THUMB == wType)
	{
		m_X.SetResolution(pController->m_pInputCaps->In.Gamepad.sThumbLX);
		m_Y.SetResolution(pController->m_pInputCaps->In.Gamepad.sThumbLY);
	} else
	{
		m_X.SetResolution(pController->m_pInputCaps->In.Gamepad.sThumbRX);
		m_Y.SetResolution(pController->m_pInputCaps->In.Gamepad.sThumbRY);
	}

	if(pController->m_pInputCaps->In.Gamepad.wButtons & wType)
	{
		m_pTestButton = new CTestDigitalButton(pController, wType);
	} else
	{
		m_pTestButton = NULL;
	}

	// got configuration, now setup base test rects for drawing
	TempPoint.SetXY(0,0); TempPoint1.SetXY(m_iSize,m_iSize);

	TempRect.Set(TempPoint,TempPoint1);

	// set first row across
	m_TestRect[0] = TempRect;
	OffsetPoint.SetXY(m_iSize,0);
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[1] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[2] = TempRect;

	// set second row across
	TempPoint.SetXY(0,m_iSize); TempPoint1.SetXY(m_iSize,m_iSize*2);
	TempRect.Set(TempPoint,TempPoint1);
	m_TestRect[3] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[4] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[5] = TempRect;

	// set third row across
	TempPoint.SetXY(0,m_iSize*2); TempPoint1.SetXY(m_iSize,m_iSize*3);
	TempRect.Set(TempPoint,TempPoint1);
	m_TestRect[6] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[7] = TempRect;
	TempRect.OffsetRect(OffsetPoint);
	m_TestRect[8] = TempRect;

	m_TestRect[9] = m_TestRect[5];
	OffsetPoint.SetXY(30,-4);
	m_TestRect[9].OffsetRect(OffsetPoint); // move right and slightly up

	if(pController->m_pInputCaps->In.Gamepad.wButtons & wType)
	{
		m_pTestButton = new CTestDigitalButton(pController, wType);
	} else
	{
		m_pTestButton = NULL;
	}


	for(int i = 0; i < 10; i++)
	{
		
		m_bTestResults[i] = eNotyet;
	}
	// do X and Y axis exclusions
	if(0 == m_X.GetResolution() || 0 == m_Y.GetResolution()) // if missing either Axis
	{
		// don't test any corners
		m_bTestResults[0] = eNever;
		m_bTestResults[2] = eNever;
		m_bTestResults[6] = eNever;
		m_bTestResults[8] = eNever;
		if(0 == m_X.GetResolution())
		{
			// if missing X axis
			m_bTestResults[3] = eNever;
			m_bTestResults[5] = eNever;
		}
		if(0 == m_Y.GetResolution())
		{
			// if no Y axis
			m_bTestResults[1] = eNever;
			m_bTestResults[7] = eNever;
		}
	}
	// done with init

}

CTestThumbstick::~CTestThumbstick()
{
	if(m_pTestButton) delete m_pTestButton;
}

SHORT
CTestThumbstick::TGetX()
{
	SHORT sState;
	if(XINPUT_GAMEPAD_LEFT_THUMB == m_wThumbType)
	{
		sState = m_pTestController->m_pInputState->Gamepad.sThumbLX;
	} else
	{
		sState =  m_pTestController->m_pInputState->Gamepad.sThumbRX;
	}
	return sState;
}

SHORT
CTestThumbstick::TGetY()
{
	SHORT sState;
	if(XINPUT_GAMEPAD_LEFT_THUMB == m_wThumbType)
	{
		sState = m_pTestController->m_pInputState->Gamepad.sThumbLY;
	} else
	{
		sState =  m_pTestController->m_pInputState->Gamepad.sThumbRY;
	}
	return sState;
}

BOOL
CTestThumbstick::TGetButtonState()
{
	if(m_pTestButton)
	{
		return m_pTestButton->TGetState();
	} 
	return FALSE;
}



void
CTestThumbstick::SetStart(CPoint Start)
{
	m_Location = Start; // save start
	// adjust the 10 boxes by the starting point
	for(int i = 0; i < 10; i++)
	{
		m_TestRect[i].OffsetRect(Start);
	}
}
// index order of display blocks
// 0 1 2
// 3 4 5
// 6 7 8

short XVal[] =
{
	-24000,		// 0
	0,			// 1
	24000,		// 2
	-32767,		// 3
	0,			// 4
	32767,		// 5
	-24000,		// 6
	0,			// 7
	24000		// 8
};

short YVal[] =
{
	24000,		// 0
	32767,		// 1
	24000,		// 2
	0,			// 3
	0,			// 4
	0,			// 5
	-24000,		// 6
	-32768,		// 7
	-24000		// 8
};
	


void
CTestThumbstick::Draw()
{
	int iLabelIndex;
	DWORD dwColor;

	for(int i = 0; i < 10; i++)
	{
		dwColor = CurrColor[m_bTestResults[i]];  // get the color for the state of this box
		if(TRUE == fUnderTest) 
		{
			// check for flashing only if this control is being tested
			if(eTesting == m_bTestResults[i] && m_pTestController->m_fFlash)
			{
				dwColor = GrayColor;
			}
				
			::drPrintf(70,30,L"X Axis = %05d, Y Axis = %05d",TGetX(),TGetY());
		}
		if(9 == i && ExistsButton() )
		{
			// also draw small rect in middle to represent button
			CRect SmRect;
			CPoint TempPt;
			TempPt = m_TestRect[4].GetTopLeft();
			TempPt.SetX(TempPt.GetX() + 5);
			TempPt.SetY(TempPt.GetY() + 5);
			SmRect.SetTopLeft(TempPt);
			TempPt.SetX(TempPt.GetX() + 10);
			TempPt.SetY(TempPt.GetY() + 10);
			SmRect.SetBottomRight(TempPt);
			SmRect.Draw(dwColor);
		}

		if(eNever != m_bTestResults[i])
		{
			m_TestRect[i].Draw(dwColor);
		}
	}
		// also print x & y values during test

	if(XINPUT_GAMEPAD_LEFT_THUMB == m_wThumbType)
	{
		iLabelIndex = esLThumb;
	} else
	{
		iLabelIndex = esRThumb;
	}
	// draw label
	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the text color
	drPrintf((float)m_Location.GetX() + 4,(float) m_Location.GetY() - 16, Labels[iLabelIndex]);


}

int TestOrder[] = { 1,0,3,6,7,8,5,2 };

BOOL
CTestThumbstick::Test()
{
	int iTestNumber;
	int iCurrTest = 0;
	short sCurrX,sCurrY;
	BOOL fResult = FALSE;

	m_pTestController->SetCountDown(200); // 20 second countdown
	fUnderTest = TRUE;
	iTestNumber = TestOrder[0];
	while(m_pTestController->GetCountDown() && iCurrTest < 8)
	{
		sCurrX = TGetX();
		sCurrY = TGetY();
		
		if(eNever == m_bTestResults[iTestNumber])
		{
			iCurrTest++; // inc to next test
			iTestNumber = TestOrder[iCurrTest];
			continue; // move on to next test
		}

		if(eNotyet == m_bTestResults[iTestNumber])
			m_bTestResults[iTestNumber] = eTesting;

		BOOL XisOK = FALSE;
		BOOL YisOK = FALSE;

		if(0 == XVal[iTestNumber] && (sCurrX < 16000 && sCurrX > -16000))
		{
			// zero is don't care, only testing y
			XisOK = TRUE;
		} else if( ( (sCurrX  <= XVal[iTestNumber] )  && (XVal[iTestNumber] < 0) ) ||
					( (sCurrX >=XVal[iTestNumber]  ) && (XVal[iTestNumber] > 0) ) )
		{
			XisOK = TRUE;
		}

		
		if(0 == YVal[iTestNumber] && (sCurrY < 16000 && sCurrY > -16000))
		{
			// zero is don't care, only testing y
			YisOK = TRUE;
		} else if( ( (sCurrY <= YVal[iTestNumber])  && (YVal[iTestNumber] < 0) ) ||
					( (sCurrY >= YVal[iTestNumber] ) && (YVal[iTestNumber] > 0) ) )
		{
			YisOK = TRUE;
		}

		if(YisOK && XisOK)
		{
			m_bTestResults[iTestNumber] = eGood;
			iCurrTest++; // inc to next test
			iTestNumber = TestOrder[iCurrTest];
		}

	} // While
	// treat center as a special case
	m_bTestResults[4] = eTesting;
	while(m_pTestController->GetCountDown())
	{
		sCurrX = TGetX();
		sCurrY = TGetY();
		if((sCurrX < 4000 && sCurrX > -4000) &&
			(sCurrY < 4000 && sCurrY > -4000) )
		{
			m_bTestResults[4] = eGood;
			break;
		}
	}
	if(eTesting == m_bTestResults[4]) m_bTestResults[4] = eBad;
		
	// finally test button
	if(FALSE == ExistsButton())
	{
		m_bTestResults[9] = eGood;
	} else
	{
		m_bTestResults[9] = eTesting;
		while(m_pTestController->GetCountDown())
		{
			BOOL fState = m_pTestButton->TGetState();
			if(TRUE == fState )
			{
				m_bTestResults[9] = eGood;
				break;
			}
		}
		if(eGood != m_bTestResults[9])
		{
			m_bTestResults[9] = eBad;
		}
	}

	// reset any untested elements at timeout to bad
	for(int i = 0; i < 10; i++)
	{
		if(!eGood == m_bTestResults[i]  && !eNever == m_bTestResults[i])
		{
			m_bTestResults[i] = eBad;
			fResult = TRUE;
		}
	}
	for(int i = 0; i< 10; i++)
	{
		if(m_bTestResults[i] == eBad)
			fResult = TRUE;
	}

	fUnderTest = FALSE;
	return fResult;
}



// CTestController Class Methods
CTestController::CTestController()
{
	;
}

CTestController::~CTestController()
{
	if(m_pTDPad) delete m_pTDPad;
	for(int i = 0; i<8; i++)
	{
		if(m_pTAnalogButton[i]) delete m_pTAnalogButton[i];
	}
	if(m_pTThumbStick[0]) delete m_pTThumbStick[0];
	if(m_pTThumbStick[1]) delete m_pTThumbStick[1];
	if(m_pTStartButton) delete m_pTStartButton;
	if(m_pTBackButton) delete m_pTBackButton;
	if(m_Handle) XInputClose(m_Handle);
	if(m_pInputState) delete m_pInputState;
	if(m_pInputCaps) delete m_pInputCaps;
}

// order of test execution
int DukeOrder[13] = { 0,1,2,3,4,5,6,7,8,9,10,11,12};
int AkiOrder[13] =  {0,1,2,4,5,3,6,7,8,10,11,9,12 };


DWORD
CTestController::InitTest(DWORD dwPort)
{
	DWORD	dwResult;
	WORD	wMask;
	CPoint * pStartLocs;

	m_dwPacketNumber = 0;
	// set handles and pointers to NULL
	m_Handle = NULL;
	m_pTDPad = NULL;
	m_fCrossTalk = FALSE;

	for(int i = 0; i < 8; i++)
	{
		m_pTAnalogButton[i] = NULL;
	}
	m_pTThumbStick[0] = NULL;
	m_pTThumbStick[1] = NULL;
	m_pTStartButton = NULL;
	m_pTBackButton = NULL;
	m_fRemoved = FALSE;

	m_TestComplete = 0; // no tests are complete
	// first open a handle to this controller
	m_Handle = XInputOpen(XDEVICE_TYPE_GAMEPAD,dwPort,XDEVICE_NO_SLOT,NULL);
	if(NULL == m_Handle)
		return GetLastError(); // failed

	// have open controller, populate controls
	m_dwPort = dwPort; // stash active port for this controller
	m_fFlash = FALSE;
	m_TestCountDown = 0;

	m_pInputState = new XINPUT_STATE;
	if(NULL == m_pInputState)
	{
		return GetLastError();
	}

	m_pInputCaps = new XINPUT_CAPABILITIES;
	if(NULL == m_pInputCaps)
	{
		return GetLastError();
	}
	dwResult = XInputGetCapabilities(m_Handle, m_pInputCaps);
	if(ERROR_SUCCESS != dwResult)
	{
		XInputClose(m_Handle);
		m_Handle = NULL;
		return dwResult;
	}
	// init mutex used to protect the countdown timer
	m_hCountDownMutex = CreateMutex(
						NULL,		// security unused						
						FALSE,		// don't create owned
						NULL		// No name
						);

	if(NULL == m_hCountDownMutex)
	{
		XInputClose(m_Handle);
		dwResult = GetLastError();
		return dwResult;
	}
	m_SubType = m_pInputCaps->SubType;
	// set screen locations for the supported controls
	// setup test array
	switch (m_SubType)
	{
		case ACHIBONO_TYPE:
		{
			InitAkiLocs();
			pStartLocs = &AkiStart[0];
			m_piTestOrder = AkiOrder;
			break;
		}
		case WHEEL_TYPE:
		case ARCADE_STICK_TYPE:
		case STANDARD_TYPE:
		default:
		{
			InitDukeLocs();
			pStartLocs = &DukeStart[0];
			m_piTestOrder = DukeOrder;
			break;
		}

	}

	// got caps, now set existence flags for supported controls
	
	// DPAD
	if(m_pInputCaps->In.Gamepad.wButtons & 0x000f) // test for any portion of dpad
	{
		m_pTDPad = new CTestDPad(this);
		m_pTDPad->SetStart(pStartLocs[esDPad]);
	} else
		m_pTDPad = NULL;
	
	// Start Button
	if(m_pInputCaps->In.Gamepad.wButtons & XINPUT_GAMEPAD_START)
	{
		m_pTStartButton = new CTestDigitalButton(this, XINPUT_GAMEPAD_START);
		m_pTStartButton->SetStart(pStartLocs[esStartButton]);
	} else
		m_pTStartButton = NULL;

	// Back Button
	if(m_pInputCaps->In.Gamepad.wButtons & XINPUT_GAMEPAD_BACK)
	{
		m_pTBackButton = new CTestDigitalButton(this,XINPUT_GAMEPAD_BACK);
		m_pTBackButton->SetStart(pStartLocs[esBackButton]);
	} else
		m_pTBackButton = NULL;

	// All Analog buttons

	for(int i = 0; i < 8 ; i++)
	{
		if(m_pInputCaps->In.Gamepad.bAnalogButtons[i])
		{
			m_pTAnalogButton[i] = new CTestAnalogButton(this,(WORD)i);
			m_pTAnalogButton[i]->SetStart(pStartLocs[i]);
		} else
			m_pTAnalogButton[i] = NULL;
	}

	// Left Thumbstick
	if(m_pInputCaps->In.Gamepad.sThumbLX || 
			m_pInputCaps->In.Gamepad.sThumbLY ||
			(m_pInputCaps->In.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB)) 
	{
		m_pTThumbStick[0] = new CTestThumbstick(this,XINPUT_GAMEPAD_LEFT_THUMB);
		m_pTThumbStick[0]->SetStart(pStartLocs[esLThumb]);
	} else
		m_pTThumbStick[0] = NULL;

	// Right Thumbstick
	if(m_pInputCaps->In.Gamepad.sThumbRX ||
				m_pInputCaps->In.Gamepad.sThumbRY ||
				(m_pInputCaps->In.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB))
	{
		m_pTThumbStick[1] = new CTestThumbstick(this,XINPUT_GAMEPAD_RIGHT_THUMB);
		m_pTThumbStick[1]->SetStart(pStartLocs[esRThumb]);
	} else
		m_pTThumbStick[1] = NULL;

	m_dwSlot[0] = FALSE;
	m_dwSlot[1] = FALSE;


	return S_OK;
}

void
CTestController::DecCountDown()
{
	// acquire mutext
	WaitForSingleObject(m_hCountDownMutex,INFINITE);
	if(m_TestCountDown) m_TestCountDown--; // used as flag, don't dec past zero
	ReleaseMutex(m_hCountDownMutex);
}

void
CTestController::SetCountDown(int iVal)
{
	// acquire mutext
	WaitForSingleObject(m_hCountDownMutex,INFINITE);
	m_TestCountDown = iVal;
	ReleaseMutex(m_hCountDownMutex);
}

int
CTestController::GetCountDown()
{
	int iVal;
	// acquire mutext
	WaitForSingleObject(m_hCountDownMutex,INFINITE);
	iVal = m_TestCountDown;
	ReleaseMutex(m_hCountDownMutex);
	return iVal;
}

BOOL
CTestController::Test()
{
	BOOL fTResult;
	BOOL fOResult = FALSE;
	int iTestCounter = 0;
	BOOL fTesting = TRUE;
	// first setup array and order of tests based on controller type
// background tasks now tasking, we can get on with the tests
	// Left Trigger
	fTResult = FALSE; // cumulate results
	while(iTestCounter < 13)
	{
		if(TRUE == m_fRemoved) return FALSE; // bail if controller removed
		switch(m_piTestOrder[iTestCounter])
		{
			case 0:
				if(m_pTAnalogButton[esLTrigger])
					fTResult = m_pTAnalogButton[esLTrigger]->Test();
				break;
			case 1:
				if(m_pTAnalogButton[esRTrigger])
					fTResult = m_pTAnalogButton[esRTrigger]->Test();
				break;
			case 2:
				if(m_pTThumbStick[0])
					fTResult = m_pTThumbStick[0]->Test();
				break;
			case 3:
				if(m_pTDPad)
					fTResult = m_pTDPad->Test();
				break;
			case 4:
				if(m_pTBackButton)
					fTResult = m_pTBackButton->Test();
				break;
			case 5:
				if(m_pTStartButton)
					fTResult = m_pTStartButton->Test();
				break;
			case 6:
				if(m_pTThumbStick[1])
					fTResult = m_pTThumbStick[1]->Test();
				break;
			case 7:
				if(m_pTAnalogButton[esX])
					fTResult = m_pTAnalogButton[esX]->Test();
				break;
			case 8:
				if(m_pTAnalogButton[esY])
					fTResult = m_pTAnalogButton[esY]->Test();
				break;
			case 9:
				if(m_pTAnalogButton[esWhite])
					fTResult = m_pTAnalogButton[esWhite]->Test();
				break;
			case 10:
				if(m_pTAnalogButton[esA])
					fTResult = m_pTAnalogButton[esA]->Test();
				break;
			case 11:
				if(m_pTAnalogButton[esB])
					fTResult = m_pTAnalogButton[esB]->Test();
				break;
			case 12:
				if(m_pTAnalogButton[esBlack])
					fTResult = m_pTAnalogButton[esBlack]->Test();
				break;
		} // switch
		if(TRUE == fTResult)
			fOResult = TRUE;

		iTestCounter++;
	}

	if(TRUE == fOResult)
	{
		m_TestComplete = eBad;// failed at least one test
	} else
	{
		m_TestComplete = eGood; // succeeded
	}
	return fOResult;

}

DWORD CTestController::Refresh()
{
	DWORD dwResult;
	memset(m_pInputState,0x00,sizeof(XINPUT_STATE));
	dwResult = XInputGetState(m_Handle,m_pInputState);
	if(ERROR_SUCCESS != dwResult)
	{
		DebugPrint("GetInputState failed - %x\n",dwResult);
	}
	return dwResult;
}

void
CTestController::Draw()
{
	// advise each supported control to redraw themselves
	if(m_pTThumbStick[0]) m_pTThumbStick[0]->Draw();
	if(m_pTThumbStick[1]) m_pTThumbStick[1]->Draw();
	if(m_pTDPad) m_pTDPad->Draw();
	if(m_pTStartButton) m_pTStartButton->Draw();
	if(m_pTBackButton) m_pTBackButton->Draw();
	if(m_pTAnalogButton[esA]) m_pTAnalogButton[esA]->Draw();
	if(m_pTAnalogButton[esB]) m_pTAnalogButton[esB]->Draw();
	if(m_pTAnalogButton[esX]) m_pTAnalogButton[esX]->Draw();
	if(m_pTAnalogButton[esY]) m_pTAnalogButton[esY]->Draw();
	if(m_pTAnalogButton[esBlack]) m_pTAnalogButton[esBlack]->Draw();
	if(m_pTAnalogButton[esWhite]) m_pTAnalogButton[esWhite]->Draw();
	if(m_pTAnalogButton[esLTrigger]) m_pTAnalogButton[esLTrigger]->Draw();
	if(m_pTAnalogButton[esRTrigger]) m_pTAnalogButton[esRTrigger]->Draw();
	if(m_pTAnalogButton[esA]) m_pTAnalogButton[esA]->Draw();


		// MU's
	if(MUCOUNT)
	{
		drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
		drPrintf(345,58, L"Slot 1");
		drBox(230,50,330,80, m_dwSlot[0] ? 0xff00ff00 : 0xfff0f0f0);
		if(2 == MUCOUNT)
		{
			drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the color
			drPrintf(345,98, L"Slot 2");
			drBox(230,90,330,120, m_dwSlot[1] ? 0xff00ff00 : 0xfff0f0f0);
		}
	}
	// label boxes

// draw controller label
	int iLabelIndex = 0;
	switch (m_SubType)
	{
		case ACHIBONO_TYPE:
			iLabelIndex = 1;
			break;
		case WHEEL_TYPE:
			iLabelIndex = 2;
			break;
		case ARCADE_STICK_TYPE:
			iLabelIndex = 3;
			break;
		case FLIGHT_STICK_TYPE:
			iLabelIndex = 4;
			break;
		case BOARD_TYPE:
			iLabelIndex = 5;
			break;
		case STANDARD_TYPE:
		default:
			iLabelIndex = 0;
			break;
	}
	
	drSetSize(50, 100, 0x0000ffff, 0xff000000); //set the text color
	// maintain crosstalk
	DWORD dwColor;
	if(TRUE == m_fCrossTalk)
		dwColor = CurrColor[eBad];
	else
		dwColor = CurrColor[eGood];
	
	CRect CrossTalkRect;
	CPoint TempPt;
	TempPt.SetXY(500,30);
	CrossTalkRect.SetTopLeft(TempPt);
	TempPt.SetXY(510,40);
	CrossTalkRect.SetBottomRight(TempPt);
	CrossTalkRect.Draw(dwColor);
	drPrintf(515,30,L"CrossTalk");

	drPrintf(200,150, ControllerLabels[iLabelIndex]);

	drPrintf(500,400,L"Ver. 1.0"); // version string, should be maintained from resource
	// finally, if test is complet, draw success or failure
	if(m_TestComplete)
	{
		// check current MU Status, Gamepads fail if both slots not populated
		if(2 == MUCOUNT)
		{
				if( FALSE == m_dwSlot[0] || FALSE == m_dwSlot[1])
					m_TestComplete = eBad;
		} else if(1 == MUCOUNT)
		{
				if( FALSE == m_dwSlot[0] && FALSE == m_dwSlot[1])
				{
					m_TestComplete = eBad;
				}
		}
		if(TRUE == m_fCrossTalk)			
		{
			m_TestComplete = eBad; // fail crosstalk detected
		}

		if(eGood == m_TestComplete)
		{
			drSetSize(50, 100, 0xff00ff00, 0xff000000); //set the color
			drPrintf(240,180, L"PASSED");
			drQuad(240, 290, 0xff00ff00, 330,  220, 0xff00ff00, 340,235, 0xff00ff00, 250,300, 0xff00ff00);
			drQuad(250, 300, 0xff00ff00, 260,  290, 0xff00ff00, 230,260, 0xff00ff00, 220,270, 0xff00ff00);
		} else
		{
			drSetSize(50, 100, 0xffff0000, 0xff000000); //set the color
			drQuad(230, 295, 0xffff0000, 335,  220, 0xffff0000, 340, 225, 0xffff0000, 235, 300, 0xffff0000);
			drQuad(335, 300, 0xffff0000, 340,  295, 0xffff0000, 235, 220, 0xffff0000, 230, 225, 0xffff0000);
		}
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\devices.h ===
/*++
    The CHawkUnit class manages a single hawk unit.
    It records from the microphone, and then plays
    back the data with a 2 second delay through the headphone
    speaker.

    Both the headphone and microphone XMO's need to have
    a max attach buffer of at least two so that the always
    have an additional buffer queued.  The simplest scheme
    would have 4 XMEDIAPACKET contexts so that both the headphone
    and the microphone have two buffers queued at all times.
    This is a little wasteful.  Staggering can get away
    with only three buffers.

    So we could have three XMEDIAPACKET contexts to keep both XMO's
    from starving.  Say we have context permanently mapped to a
    fixed size buffer.  We would then attach the first buffer
    completed by the microphone to the headphone, 1 1/2
    buffer times after the microphone completes.  The playback
    latency would then be 1 1/2 buffer times.  So for a 2 
    second latency each buffer is 1 1/3 seconds for a total
    4 seconds of buffers.  This seems somewhat wasteful, the total
    buffer needed in theory should be very close to two seconds.

    A better way is to allocate a single large buffer, and have
    the XMEDIAPACKET contexts map a smaller region of it.  The stagger
    delay is then some multiple of the smaller region time.  If we
    want to use only three contexts, we need to delay an additional half
    of the small region time.  This is a pain to do cleanly assuming
    that your app is doing something besides streaming this one device
    (infact this app can play this trick with four hawks at a time.)
    However, since the context of a buffer (at least the part this
    class keeps track of) is only two DWORD, it makes very little sense
    to skimp, and we just go with four contexts.

    How big should the small region be?  The hawk XMO's run most
    efficiently if the small regions are a multiple of 8 USB frames
    (though this is not a requirement).  This will result in the fewest
    number of interrupts per bytes transferred.  Everytime one of these
    small buffers complete an event is signalled.  Presumably, we want
    to minimize this as well, so it is a good idea to make them as large
    as possible.  However, if the latency is N*the number of small regions,
    the full buffer must be (N+2)*smaller region.  So if you break the large
    region into 12 regions, you are using about 20% more buffer than the
    theoretical minimum.  22 regions wastes only 10%, etc.

    So our choice is to have 2080 ms of buffers, with each small region
    being only 40 ms, giving us a total of 52 regions.  The buffer is
    only 4% larger than it needs to be for a two second delay.

--*/
#include <xtl.h>
#define TEST_HAWK_SAMPLING_RATE 16000
#define XHAWK_PLAYBACK_BYTES_PER_MS (((ULONG)(TEST_HAWK_SAMPLING_RATE/1000.0))*2)
#define XHAWK_PLAYBACK_BUFFER_REGION_TIME 80
#define XHAWK_PLAYBACK_BUFFER_REGION_SIZE (XHAWK_PLAYBACK_BYTES_PER_MS*XHAWK_PLAYBACK_BUFFER_REGION_TIME)
#define XHAWK_PLAYBACK_PREBUFFER_REGIONS 50
#define XHAWK_PLAYBACK_TOTAL_REGIONS (XHAWK_PLAYBACK_PREBUFFER_REGIONS+2)
#define XHAWK_PLAYBACK_BUFFER_SIZE (XHAWK_PLAYBACK_BUFFER_REGION_SIZE*XHAWK_PLAYBACK_PREBUFFER_REGIONS)
class CHawkUnits;
struct PLAYBACK_MEDIABUFFER_CONTEXT
{
    DWORD        dwCompletedSize;
    DWORD        dwStatus;
};

struct PLAYBACK_REGION
{
    BYTE Data[XHAWK_PLAYBACK_BUFFER_REGION_SIZE];
};

class CHawkUnit
{
  public:

      CHawkUnit() :
        m_pMicrophone(NULL),
        m_pHeadphone(NULL),
        m_dwPortNumber(0),
        m_hEvent(NULL),
        m_dwMicrophoneRegionIndex(0),
        m_dwHeadphoneRegionIndex(0),
        m_dwMicrophoneContextIndex(0),
        m_dwHeadphoneContextIndex(0),
        m_fConnected(FALSE),
        m_fPreBuffering(FALSE),
        m_dwPreBufferRegions(0),
        m_dwBuffersReceived(0),
        m_dwBytesReceived(0),
        m_dwBuffersSent(0),
        m_dwBytesSent(0),
        m_dwErrorCount(0)
		
        {}

    ~CHawkUnit();
    void Init(DWORD dwPort, HANDLE hEvent);
    void Inserted();
    void Removed();
    int ProcessMicrophone();
	int ProcessHeadphones();
    void AttachMicrophoneContext(DWORD dwIndex);
    void AttachHeadphoneContext(DWORD dwIndex);
    
    void Log(WCHAR *pwstrText);
	BOOL IsConnected(){ return m_fConnected;};
	//
    //  These contexts are used to track the status
    //  of an attached media buffer.
    //
    PLAYBACK_MEDIABUFFER_CONTEXT m_MicrophoneContexts[2];
    PLAYBACK_MEDIABUFFER_CONTEXT m_HeadphoneContexts[2];
  private:

    //
    // XMO objects created on
    // call to Inserted.
    //
    
    XMediaObject *m_pMicrophone;
    XMediaObject *m_pHeadphone;

    //
    // Stuff given to us at init
    //
    DWORD m_dwPortNumber;
    HANDLE m_hEvent;
        
    //
    //  The buffer is just an array of regions,
    //  which are simply fixed sized arrays
    //  of bytes.
    //

    PLAYBACK_REGION m_Buffer[XHAWK_PLAYBACK_TOTAL_REGIONS];

    //
    //  m_dwMicrophoneRegionIndex (m_dwHeadphoneRegionIndex)
    //  is the next next region that needs to be attached to
    //  the microphone (headphone) XMO.
    //

    DWORD m_dwMicrophoneRegionIndex;
    DWORD m_dwHeadphoneRegionIndex;

    
    
    //
    //  m_dwMicrophoneContextIndex (m_dwHeadphoneContexIndex)
    //  is the next next region that the microphone (headphone) XMO,
    //  is expected to complete.
    //
    DWORD m_dwMicrophoneContextIndex;
    DWORD m_dwHeadphoneContextIndex;

    //
    //  Status.
    //
	
    BOOL	m_fConnected;
    BOOL	m_fPreBuffering;
    DWORD	m_dwPreBufferRegions;
    DWORD	m_dwBuffersReceived;
    DWORD	m_dwBytesReceived;
    DWORD	m_dwBuffersSent;
    DWORD	m_dwBytesSent;
    DWORD	m_dwErrorCount;
    
};

class CHawkUnits
{
    public:
        CHawkUnits();
        ~CHawkUnits();
		int FindConnections();
		int RecordSound(int iTime=0);
		int PlaySound();
        void Run();
    private:

        CHawkUnit m_pHawkUnits[4];
        HANDLE m_pProcessEvents[4];
		int m_iNumConnected;
		BOOL	m_fRecording;
		BOOL	m_fPlaying;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\devices.cpp ===
#define DSOUND_INCLUDE_XHAWK

#include "playback.h"

#if TEST_HAWK_SAMPLING_RATE == 8000
#pragma message ("Playback built for 8 ksamples/second")
#endif

#if TEST_HAWK_SAMPLING_RATE == 11025
#pragma message ("Playback built for 11.025 ksamples/second")
#endif

#if TEST_HAWK_SAMPLING_RATE == 16000
#pragma message ("Playback built for 16 ksamples/second")
#endif

#if TEST_HAWK_SAMPLING_RATE == 22050
#pragma message ("Playback built for 22.05 ksamples/second")
#endif

#if TEST_HAWK_SAMPLING_RATE == 24000
#pragma message ("Playback built for 24 ksamples/second")
#endif

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}


/*
**
**  Implementation of CHawkUnit that does play back test
**  on a single unit.
**
*/

void CHawkUnit::Init(DWORD dwPortNumber, HANDLE hEvent)
{
    m_dwPortNumber = dwPortNumber;
    m_hEvent = hEvent;
}

CHawkUnit::~CHawkUnit()
{
    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
    }
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
    }
}

void CHawkUnit::Inserted()
{
    Log(L"Hawk Inserted");
     HRESULT hr = 0;

    WAVEFORMATEX wfxFormat;
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = TEST_HAWK_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2*TEST_HAWK_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    //
    //  Create a microphone and a headphone.
    //
    hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, m_dwPortNumber , 2, &wfxFormat, &m_pMicrophone);
    if(SUCCEEDED(hr))
    {
       hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, m_dwPortNumber , 2, &wfxFormat, &m_pHeadphone);
       if(SUCCEEDED(hr))
       {
            m_dwMicrophoneRegionIndex = 0;
            m_dwHeadphoneRegionIndex = 0;
            m_dwMicrophoneContextIndex = 0;
            m_dwHeadphoneContextIndex = 0;
            m_fConnected = TRUE;
            m_fPreBuffering = TRUE;
            m_dwPreBufferRegions = 0;
            m_dwBuffersReceived = 0;
            m_dwBytesReceived = 0;
            m_dwBytesSent = 0;
            m_dwErrorCount = 0;
    
            
       } else
       {
            m_pMicrophone->Release();
            m_pMicrophone = NULL;
       }
    }
}


void CHawkUnit::Removed()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
    }
    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
    }
    m_fConnected = FALSE;
	m_dwBytesSent = 0;
	m_dwBytesReceived  = 0;
	m_dwBuffersReceived = 0;
	m_dwErrorCount = 0;

}



int CHawkUnit::ProcessMicrophone()
/*++
    
    This routine is called because this XMO's event
    was signaled.  Since we pass the same event with
    every buffer, we do not know whether the microphone or
    headphone completed.

--*/
{
   
    //
    //  Check for a completed microphone context first
    //
	if(m_dwBytesReceived >= XHAWK_PLAYBACK_BUFFER_SIZE)
			return 0;
    if(XMEDIAPACKET_STATUS_PENDING != m_MicrophoneContexts[m_dwMicrophoneContextIndex].dwStatus)
    {
        if(SUCCEEDED(m_MicrophoneContexts[m_dwMicrophoneContextIndex].dwStatus))
        {
            m_dwBuffersReceived++;
        } else
        {
            m_dwErrorCount++;
        }

        m_dwBytesReceived += m_MicrophoneContexts[m_dwMicrophoneContextIndex].dwCompletedSize;
        
        m_MicrophoneContexts[m_dwMicrophoneContextIndex].dwStatus = XMEDIAPACKET_STATUS_PENDING;
		
		if(m_dwBytesReceived >= XHAWK_PLAYBACK_BUFFER_SIZE)
			return 0;
        //
        //  If we are still connected, reattach the context
        //

        if(m_fConnected)
        {
            //
            //  Increment m_dwMicrophoneContextIndex
            //

            DWORD index = m_dwMicrophoneContextIndex;
            m_dwMicrophoneContextIndex = (m_dwMicrophoneContextIndex+1)%2;
            
            //
            //  Reattach the microphone context that just completed.
            //

            AttachMicrophoneContext(index);
            
            //
            //  If we prebuffer is complete, switch off the prebuffer flag
            //  and attach two headphone contexts.
            //

            
        } //m_fConnected
    }   //if microphone context no longer pending
	return 1;

}    

int CHawkUnit::ProcessHeadphones()
/*++
    
    This routine is called because this XMO's event
    was signaled.  Since we pass the same event with
    every buffer, we do not know whether the microphone or
    headphone completed.

--*/
{
   
	if(m_dwBytesSent >= XHAWK_PLAYBACK_BUFFER_SIZE)
			return 0;
    //
    //  Check for a completed headphone context first
    //

    if(XMEDIAPACKET_STATUS_PENDING != m_HeadphoneContexts[m_dwHeadphoneContextIndex].dwStatus)
    {
        if(SUCCEEDED(m_HeadphoneContexts[m_dwHeadphoneContextIndex].dwStatus))
        {
            m_dwBuffersSent++;
        } else
        {
            m_dwErrorCount++;
        }
        
        m_dwBytesSent += m_HeadphoneContexts[m_dwHeadphoneContextIndex].dwCompletedSize;

        m_HeadphoneContexts[m_dwHeadphoneContextIndex].dwStatus = XMEDIAPACKET_STATUS_PENDING;
		if(m_dwBytesSent >= XHAWK_PLAYBACK_BUFFER_SIZE)
			return 0;
        //
        //  If we are still connected, reattach the context
        //
        if(m_fConnected)
        {
            //
            //  Increment m_dwHeadphoneContextIndex
            //

            DWORD index = m_dwHeadphoneContextIndex;
            m_dwHeadphoneContextIndex = (m_dwHeadphoneContextIndex+1)%2;
            
            //
            //  Reattach the microphone context that just completed.
            //

            AttachHeadphoneContext(index);
        }
    }
	return 1;
}    



void CHawkUnit::AttachMicrophoneContext(DWORD dwIndex)
{
    XMEDIAPACKET MediaPacket;

     //
    //  Seup the size and pointer into our buffer
    //

    MediaPacket.dwMaxSize = XHAWK_PLAYBACK_BUFFER_REGION_SIZE;
    MediaPacket.pvBuffer = (PVOID)m_Buffer[m_dwMicrophoneRegionIndex].Data;

    //
    //  Adjust the region index for the next call
    //

    m_dwMicrophoneRegionIndex = (m_dwMicrophoneRegionIndex+1)%XHAWK_PLAYBACK_TOTAL_REGIONS;

    //
    //  Setup the pointers to our status and completed size pointers
    //

    MediaPacket.pdwCompletedSize = &m_MicrophoneContexts[dwIndex].dwCompletedSize;
    MediaPacket.pdwStatus = &m_MicrophoneContexts[dwIndex].dwStatus;

    //
    //  Initialize the event and timestamp
    //

    MediaPacket.hCompletionEvent = m_hEvent;

    //
    //  Submit the buffer
    //
    
    VERIFY_SUCCESS(m_pMicrophone->Process(NULL, &MediaPacket));
}

void CHawkUnit::AttachHeadphoneContext(DWORD dwIndex)
{
    XMEDIAPACKET MediaPacket;
    
    //
    //  Seup the size and pointer into our buffer
    //

    MediaPacket.dwMaxSize = XHAWK_PLAYBACK_BUFFER_REGION_SIZE;
    MediaPacket.pvBuffer = (PVOID)m_Buffer[m_dwHeadphoneRegionIndex].Data;

    //
    //  Adjust the region index for the next call
    //

    m_dwHeadphoneRegionIndex = (m_dwHeadphoneRegionIndex+1)%XHAWK_PLAYBACK_TOTAL_REGIONS;

    
    //
    //  Setup the pointers to our status and completed size pointers
    //

    MediaPacket.pdwCompletedSize = &m_HeadphoneContexts[dwIndex].dwCompletedSize;
    MediaPacket.pdwStatus = &m_HeadphoneContexts[dwIndex].dwStatus;

    //
    //  Initialize the event and timestamp
    //

    MediaPacket.hCompletionEvent = m_hEvent;

    //
    //  Submit the buffer
    //
    
    VERIFY_SUCCESS(m_pHeadphone->Process(&MediaPacket, NULL));
}
    


void CHawkUnit::Log(WCHAR *pwstrText)
{
    DebugPrint("%ws\n", pwstrText);
}

/*
**
**  Implementation of CHawkUnits that tracks multiple hawk units.
**
*/

CHawkUnits::CHawkUnits()
{  
	m_iNumConnected = 0;
	m_fRecording = FALSE;
	m_fPlaying = FALSE;
    for(int i=0; i<4; i++)
    {
        m_pProcessEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_pHawkUnits[i].Init(i,m_pProcessEvents[i]);
    }        
}
CHawkUnits::~CHawkUnits(){}


int CHawkUnits::FindConnections()
{
	int NumConnected = 0;
	int i;
	//
	//  Always check for hot-plugs
	//
	DWORD dwMicrophoneInsertions, dwHeadphoneInsertions, dwMicrophoneRemovals, dwHeadphoneRemovals;
	if(XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwMicrophoneInsertions, &dwMicrophoneRemovals))
	{
		if(!XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwHeadphoneInsertions, &dwHeadphoneRemovals))
		{
			DebugPrint("GetDeviceChanges does not match\n");
			_asm int 3;
		}
		if((dwMicrophoneInsertions != dwHeadphoneInsertions) ||
			(dwMicrophoneRemovals != dwHeadphoneRemovals))
		{
			DebugPrint("GetDeviceChanges does not match, different\n");
			_asm int 3;
		}
		//
		//  Loop over all the ports
		//
		for(i=0; i<4; i++)
		{
			//
			//  Handle Removal, if there is one.
			//
			if(dwMicrophoneRemovals&(1<<i))
			{
				m_pHawkUnits[i].Removed();
				NumConnected++;
				m_iNumConnected--;
				m_fRecording = FALSE;
				m_fPlaying = FALSE;           
			}
			//
			//  Handle Insertion, if there is one.
			//
			if(dwMicrophoneInsertions&(1<<i))
			{
				m_pHawkUnits[i].Inserted();
				NumConnected++;
				m_iNumConnected++;
				m_fRecording = FALSE;
				m_fPlaying = FALSE;
			}
		} //end of loop over ports
	}  //end of check for getting device changes
	return NumConnected;
}


int CHawkUnits::RecordSound(int iTime)
{
		if(!m_fRecording)
		{
			//
            //  Initialize the status of all the contexts
            //
			for(int i=0;i<4;i++)
			{
				if(m_pHawkUnits[i].IsConnected())
				{
					for(DWORD j=0;j<2;j++)
					{
						m_pHawkUnits[i].m_MicrophoneContexts[j].dwStatus = XMEDIAPACKET_STATUS_PENDING;
						m_pHawkUnits[i].m_HeadphoneContexts[j].dwStatus = XMEDIAPACKET_STATUS_PENDING;
					}
					//
					//  Attach two microphone contexts off the bat.
					//

					for(j=0; j < 2; j++)
					{
						m_pHawkUnits[i].AttachMicrophoneContext(j);
					}
					m_fRecording = TRUE;
				}
			}
		}
		if(!m_fRecording)
			return 0;
        //
        //  Wait until something happens, or 16 ms, whichever is first
        //
        
        DWORD dwReason = WaitForMultipleObjects(4, this->m_pProcessEvents, FALSE, 16);

        //
        //  If the wait expired due to one of the events, then call
        //  the appropriate hawk unit.
        //
        if((dwReason >= WAIT_OBJECT_0) && (dwReason <= WAIT_OBJECT_0+3))
        {
            int i = dwReason-WAIT_OBJECT_0;
            if(!m_pHawkUnits[i].ProcessMicrophone())
			{
				m_fRecording = FALSE;
				return 0;
			}			
        }
		return 1;
}

int CHawkUnits::PlaySound()
{
		if(!m_fPlaying)
		{
			for(int i=0;i<4;i++)
			{
				if(m_pHawkUnits[i].IsConnected())
				{
					for(DWORD j=0;j<2;j++)
					{
					   m_pHawkUnits[i].AttachHeadphoneContext(j);
					}
					m_fPlaying = TRUE;
				}
			}
		}
		if(!m_fPlaying)
			return 0;
        //
        //  Wait until something happens, or 16 ms, whichever is first
        //       
        DWORD dwReason = WaitForMultipleObjects(4, this->m_pProcessEvents, FALSE, 16);
        //
        //  If the wait expired due to one of the events, then call
        //  the appropriate hawk unit.
        //
        if((dwReason >= WAIT_OBJECT_0) && (dwReason <= WAIT_OBJECT_0+3))
        {
            int i = dwReason-WAIT_OBJECT_0;
            if(!m_pHawkUnits[i].ProcessHeadphones())
			{
				m_fPlaying = FALSE;
				return 0;
			}		
        }
		return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\dukeprod2\TestControls.h ===
#ifndef __testcontrols_h_
#define __testcontrols_h_
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testcontrols.h

Abstract:

    function declarations, type definitions, includes, etc, for testing peripheral controls

Author:

    Dennis Krueger <a-denkru>   May 2000

Revision History:

--*/

//#include "controls.h"
#include <xtl.h>
#include "base.h"
#include <draw.h>

// controller types
#define STANDARD_TYPE		1
#define ACHIBONO_TYPE		2
#define WHEEL_TYPE			0x10
#define ARCADE_STICK_TYPE	0x20
#define FLIGHT_STICK_TYPE	0x30
#define BOARD_TYPE			0x40




enum  {
	esA = 0,
	esB,
	esX,
	esY,
	esBlack,
	esWhite,
	esLTrigger,
	esRTrigger,
	esLThumb,
	esDPad,
	esBackButton,
	esStartButton,
	esRThumb,
	esMax
};

// test state flags
enum {
	eNotyet,
	eTesting,
	eGood,
	eBad,
	eNever
};

// Controller

class CTestController;


// Base Control class
class CTestControl
{
public:
	CTestControl(CTestController * pController) { m_pTestController = pController;};
	virtual ~CTestControl() { ; } ;
	void SetStart(CPoint Start) { m_Location = Start; };
	virtual void Draw() = 0;

protected:
	CPoint	m_Location;
	int		m_iSize;
	CTestController * m_pTestController;
};


// Analog Buttons

#define TESTREGIONS 8
#define TESTDEVISOR	    255/TESTREGIONS

class CTestAnalogButton:public CTestControl
{
public:
	CTestAnalogButton(CTestController * pController, int iType);
	virtual ~CTestAnalogButton() {;};
	void	Draw();
	BYTE	m_bTestResults[TESTREGIONS + 2 + 1]; // Test regions + 0 + 255 + button
	BOOL	Test();
	BYTE	TGetState();

	BYTE	m_Resolution;
	int		m_iType;
	BOOL	m_fUnderTest;


};

class CTestDigitalButton: public CTestControl
{
public:
	CTestDigitalButton(CTestController * pController, WORD wType);
	virtual	~CTestDigitalButton();
	void	Draw();
	BOOL	TGetState();
	BYTE	m_bTestResult;
	BOOL	Test();

	WORD m_wType;


};


class CTestDPad: public CTestControl
{
public:
	CTestDPad(CTestController * pController);
	virtual ~CTestDPad();
	void Draw();
	void SetStart(CPoint Start); // override base
	CTestDigitalButton * m_pButton[4]; // UP,DOWN,LEFT,RIGHT
	BOOL TGetUp();
	BOOL TGetDown();
	BOOL TGetLeft();
	BOOL TGetRight();
	BOOL Test();

private:
	CRect  m_TestRect[9]; // 
	BYTE	m_bTestResults[9];
	BOOL	m_fUnderTest;

};

class CAxis
{
public:
	CAxis() {;};
	~CAxis() {;};
	void SetResolution(SHORT Resolution) { m_Resolution = Resolution;};
	SHORT GetResolution() { return m_Resolution;};
private:
	SHORT m_Resolution;
};


class CTestThumbstick: public CTestControl
{
public:
	CTestThumbstick(CTestController * pController, WORD wThumbType);
	virtual ~CTestThumbstick();
	void	Draw();
	void	SetStart(CPoint Start);

	BOOL	ExistsX() { return m_X.GetResolution() ? TRUE : FALSE; };
	BOOL	ExistsY() { return m_Y.GetResolution() ? TRUE: FALSE ; };
	BOOL	ExistsButton() { return m_pTestButton ? TRUE : FALSE; };

	SHORT	TGetX();
	SHORT	TGetY();
	BOOL	TGetButtonState();
	BOOL	fUnderTest;
	BOOL	Test();

private:
	CTestDigitalButton * m_pTestButton;
	CRect	m_TestRect[10];
	BYTE	m_bTestResults[10];  // we test 10 components on a thumbstick
	CAxis	m_X;
	CAxis	m_Y;
	WORD	m_wThumbType;


};


class CTestController
{
public:
	virtual	~CTestController();
	virtual DWORD InitTest(DWORD dwPort);
	DWORD	Refresh();
	void	Draw();
	void	SetCountDown(int);
	int		GetCountDown();
	void	DecCountDown();
	BOOL	Test();


	CTestThumbstick		* m_pTThumbStick[2]; // Left and Right Thumbsticks
	CTestDPad			* m_pTDPad;
	CTestDigitalButton	* m_pTStartButton;
	CTestDigitalButton	* m_pTBackButton;
	CTestAnalogButton	* m_pTAnalogButton[8]; // indexes are the same as the xinput_gamepad defines

	XINPUT_STATE		* m_pInputState;
	XINPUT_CAPABILITIES * m_pInputCaps;

	BOOL				m_fFlash;
	BOOL				m_fRemoved;
	BOOL				m_fCrossTalk;

	BYTE				m_SubType;
	HANDLE				m_Handle;
	DWORD				m_dwPort;

	DWORD				m_dwPacketNumber;
	DWORD				m_dwSlot[2];
	DWORD				m_TestComplete;
	int	*				m_piTestOrder;

private:
	HANDLE				m_hCountDownMutex;
	int					m_TestCountDown;

};

// check which version we're building
#if  (MUCOUNTZERO)
#define		MUCOUNT 0
#elif defined (MUCOUNTONE)
#define		MUCOUNT 1
#elif defined (MUCOUNTTWO)
#define		MUCOUNT 2
#endif

#endif // __testcontrols_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\PlayBack.Cpp ===
//-----------------------------------------------------------------------------
// File: Playback.cpp
//

//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Playback.h"

CXHawkPlayback*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXHawkPlayback xbApp;

    if( FAILED(xbApp.Create()) )
        return;
	
    xbApp.Run();
}


//-----------------------------------------------------------------------------
// Name: CXHawkPlayback()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXHawkPlayback::CXHawkPlayback()
{
   	m_bStartedSound		= FALSE;
	m_bXHawkConnected	= FALSE;
	m_pNewSound			= NULL;
	m_eTestStep			= WAIT_FOR_ENUM;
    m_pVB				= NULL;

	memset(&m_pGamepadTexture,0,6*sizeof(void*));
	 // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
   

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
}


//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXHawkPlayback::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OutputDebugString( _T("XBApp: Creating Direct3D...\n") );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OutputDebugString( _T("XBApp: Unable to create Direct3D!\n") );
        return E_FAIL;
    }

    // Create the device
    OutputDebugString( _T("XBApp: Creating the D3D device...\n") );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OutputDebugString( _T("XBApp: Could not create D3D device!\n") );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Clear the backbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0x00ff0000, 1.0f, 0L );
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    
    // Initialize the app's device-dependent objects
    OutputDebugString( _T("XBApp: Initializing the app...\n") );
    if( FAILED( hr = Initialize() ) )
    {
        OutputDebugString( _T("XBApp: Call to Initialize() failed!\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXHawkPlayback::Initialize()
{
	 HRESULT hr;
    
     // Create the gamepad texture
    if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, "Textures\\insertx.bmp",
                                      &m_pGamepadTexture[0] ) ) )
        return E_FAIL;
	if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, "Textures\\Playx.bmp",
                                      &m_pGamepadTexture[1] ) ) )
        return E_FAIL;
	if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, "Textures\\Recordx.bmp",
                                      &m_pGamepadTexture[2] ) ) )
        return E_FAIL;
	if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, "Textures\\Listenx.bmp",
                                      &m_pGamepadTexture[3] ) ) )
        return E_FAIL;
	if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, "Textures\\Outputx.bmp",
                                      &m_pGamepadTexture[4] ) ) )
        return E_FAIL;
	if( FAILED( XBUtil_CreateTexture( m_pd3dDevice, "Textures\\Removex.bmp",
                                      &m_pGamepadTexture[5] ) ) )
        return E_FAIL;
		
    D3DSURFACE_DESC desc;
    m_pGamepadTexture[0]->GetLevelDesc( 0, &desc );
    FLOAT fBorderWidth  = 0;
    FLOAT fBorderHeight = 0;

    // Create a vertex buffer for rendering the help screen
    m_pd3dDevice->CreateVertexBuffer( 4*6*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                      0L, D3DPOOL_DEFAULT, &m_pVB );
    struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
    VERTEX* v;
    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 /* not supported on XBox D3DLOCK_DISCARD */ );
    v[0].p = D3DXVECTOR4(   0,   0, 0.0f, 0.0f );
    v[1].p = D3DXVECTOR4( 640,   0, 0.0f, 0.0f );
    v[2].p = D3DXVECTOR4(   0, 480, 0.0f, 0.0f );
    v[3].p = D3DXVECTOR4( 640, 480, 0.0f, 0.0f );
    v[0].tu = 0.0f-fBorderWidth; v[0].tv = 0.0f-fBorderHeight;     
    v[1].tu = 1.0f+fBorderWidth; v[1].tv = 0.0f-fBorderHeight; 
    v[2].tu = 0.0f-fBorderWidth; v[2].tv = 1.0f+fBorderHeight; 
    v[3].tu = 1.0f+fBorderWidth; v[3].tv = 1.0f+fBorderHeight; 
    m_pVB->Unlock();

		//Initialize core peripheral port support
   XDEVICE_PREALLOC_TYPE deviceTypes[] = 
    {
	   {XDEVICE_TYPE_GAMEPAD,2},
        {XDEVICE_TYPE_VOICE_MICROPHONE,1},
        {XDEVICE_TYPE_VOICE_HEADPHONE,1}
    };
    XInitDevices(sizeof(deviceTypes)/sizeof(XDEVICE_PREALLOC_TYPE),deviceTypes);
    OutputDebugString( _T("XBApp: Creating gamepad devices...\n") );
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        OutputDebugString( _T("XBApp: Call to CreateGamepads() failed!\n") );
        return hr;
    }

    m_pHawkUnits = new CHawkUnits;
	
   // Create the sounds
    m_pSound[0].Create( "Sounds\\SOUND-B.wav", 0 /* DSBCAPS_CTRL3D */ );
    m_pSound[1].Create( "Sounds\\SOUND-A.wav", 0 /* DSBCAPS_CTRL3D */ );
    m_pSound[2].Create( "Sounds\\SOUND-1.wav", 0 /* DSBCAPS_CTRL3D */ );
    m_pSound[3].Create( "Sounds\\SOUND-2.wav", 0 /* DSBCAPS_CTRL3D */ );
	m_pSound[4].Create( "Sounds\\SOUND-3.wav", 0 /* DSBCAPS_CTRL3D */ );

	m_pActiveSound = &m_pSound[0];

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXHawkPlayback::Run()
{
    OutputDebugString( _T("XBApp: Running the application...\n") );

	// Run the game loop, animating and rendering frames
    while( TRUE )
    {
		switch(m_eTestStep)
		{
			case WAIT_FOR_ENUM:
			{
				m_bXHawkConnected = m_pHawkUnits->FindConnections();
				if(m_bXHawkConnected)
				{
					
					m_eTestStep = WAIT_FOR_RECORD_BUTTON;
				}
				break;
			}			
			case WAIT_FOR_RECORD_BUTTON:
			{
				if(m_Gamepad[0].wPressedButtons & XINPUT_GAMEPAD_BACK )
				{				
					m_eTestStep = RECORD_SOUND;
					if( m_bStartedSound )
					{
						if(SUCCEEDED(m_pActiveSound->Stop()))
						m_bStartedSound = FALSE;
					}
					if(m_pNewSound)
						m_pActiveSound = m_pNewSound;
					// Play one of the 6 sounds
					if(m_pActiveSound && SUCCEEDED(m_pActiveSound->Play(DSBPLAY_LOOPING)))
							m_bStartedSound = TRUE;
					m_pNewSound = NULL;
					Sleep(500);
				}
				break;
			}
			case RECORD_SOUND:
			{
				
				
				if(!m_pHawkUnits->RecordSound(0) )
				{
					if(SUCCEEDED(m_pActiveSound->Stop()))
							m_bStartedSound = FALSE;
					m_eTestStep = WAIT_FOR_PLAY_BUTTON;
				}
				break;
			}
			case WAIT_FOR_PLAY_BUTTON:
			{
				if(m_Gamepad[0].wPressedButtons & XINPUT_GAMEPAD_START )
				{		
					m_eTestStep = PLAY_SOUND;	 
				}
				break;
			}
			case PLAY_SOUND:
			{
				if(!m_pHawkUnits->PlaySound() )
				{					
					m_eTestStep = WAIT_FOR_UNPLUG;
				}
				break;
			}
			case WAIT_FOR_UNPLUG:
			{
				break;
			}
		}
		BOOL bXHawkConnected	 = m_pHawkUnits->FindConnections();
				
		if(m_bXHawkConnected && bXHawkConnected)
		{
			if( m_bStartedSound )
			{
				 if(SUCCEEDED(m_pActiveSound->Stop()))
					m_bStartedSound = FALSE;
			}
			m_bXHawkConnected = FALSE;
			m_eTestStep = WAIT_FOR_ENUM;
		}
		//-----------------------------------------
        // Handle input
		//-----------------------------------------

		XBInput_GetInput( m_Gamepad );
				
		// Frame move the scene
		FrameMove();

		// Render the scene
		Render();

		// Finally, show the frame (swaps the backbuffer to the front)
		m_pd3dDevice->Present( NULL, NULL, NULL, NULL );		
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for
//       changing the .wav to be played.
//-----------------------------------------------------------------------------
HRESULT CXHawkPlayback::FrameMove()
{
	CXBSound* pNewSound = NULL;
	if( m_Gamepad[0].bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
	{
		pNewSound = &m_pSound[0];
	}
	if( m_Gamepad[0].bPressedAnalogButtons[XINPUT_GAMEPAD_B])
	{
		pNewSound = &m_pSound[1];
	}
	if( m_Gamepad[0].bPressedAnalogButtons[XINPUT_GAMEPAD_X])
	{
		pNewSound = &m_pSound[2];
	}
	if( m_Gamepad[0].bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
	{
		pNewSound = &m_pSound[3];
	}
	if( m_Gamepad[0].bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
	{
		pNewSound = &m_pSound[4];
	}
	if( m_Gamepad[0].bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
	{
		pNewSound = &m_pSound[0];
	}
	if(pNewSound)
		m_pNewSound = pNewSound;
   
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXHawkPlayback::Render()
{
    // Begin the scene
    m_pd3dDevice->BeginScene();

    // Set state to render the gamepad image
    m_pd3dDevice->SetTexture( 0, m_pGamepadTexture[m_eTestStep ] );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,    D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,    D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );

    // Render the gamepad image
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 6*sizeof(FLOAT) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // End the scene
    m_pd3dDevice->EndScene();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\XbApp.h ===
//-----------------------------------------------------------------------------
// File: XBApp.h
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <tchar.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class CXBApplication
// Desc: A base class for creating sample Xbox applications. To create a simple
//       Xbox application, simply derive this class and override the following
//       functions:
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class CXBApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
	D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device

    // Variables for timing
    BOOL       m_bPaused;           // Whether app time is paused by user
   
    // Members to init the XINPUT devices.
	XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
	DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize()            { return S_OK; }
    virtual HRESULT FrameMove()             { return S_OK; }
    virtual HRESULT Render()                { return S_OK; }
    virtual HRESULT Cleanup()               { return S_OK; }

public:
    // Functions to create, run, and clean up the application
    HRESULT Create();
    virtual HRESULT     Run();
    VOID    Destroy();

    // Internal constructor
    CXBApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\XbApp.Cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
CXBApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;




//-----------------------------------------------------------------------------
// Name: CXBApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBApplication::CXBApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
   

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OutputDebugString( _T("XBApp: Creating Direct3D...\n") );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OutputDebugString( _T("XBApp: Unable to create Direct3D!\n") );
        return E_FAIL;
    }

    // Create the device
    OutputDebugString( _T("XBApp: Creating the D3D device...\n") );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OutputDebugString( _T("XBApp: Could not create D3D device!\n") );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Clear the backbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0x00ff0000, 1.0f, 0L );
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    
    // Initialize the app's device-dependent objects
    OutputDebugString( _T("XBApp: Initializing the app...\n") );
    if( FAILED( hr = Initialize() ) )
    {
        OutputDebugString( _T("XBApp: Call to Initialize() failed!\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID CXBApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Run()
{
    OutputDebugString( _T("XBApp: Running the application...\n") );

   

    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        
        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}




//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXBApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, D3DLOCK_DISCARD );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\XbInput.Cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.25

// Threshold for analog buttons
#define XBINPUT_BUTTONTHRESHOLD 1

// Global instance of gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        if( dwRemovals & (1<<i) ) 
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
        }

        // Handle inserted devices
        if( dwInsertions & (1<<i) ) 
        {
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( pGamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            pGamepads[i].wButtons          = xiState.Gamepad.wButtons;
            pGamepads[i].bAnalogButtons[0] = xiState.Gamepad.bAnalogButtons[0];
            pGamepads[i].bAnalogButtons[1] = xiState.Gamepad.bAnalogButtons[1];
            pGamepads[i].bAnalogButtons[2] = xiState.Gamepad.bAnalogButtons[2];
            pGamepads[i].bAnalogButtons[3] = xiState.Gamepad.bAnalogButtons[3];
            pGamepads[i].bAnalogButtons[4] = xiState.Gamepad.bAnalogButtons[4];
            pGamepads[i].bAnalogButtons[5] = xiState.Gamepad.bAnalogButtons[5];
            pGamepads[i].bAnalogButtons[6] = xiState.Gamepad.bAnalogButtons[6];
            pGamepads[i].bAnalogButtons[7] = xiState.Gamepad.bAnalogButtons[7];
            pGamepads[i].sThumbLX          = xiState.Gamepad.sThumbLX;
            pGamepads[i].sThumbLY          = xiState.Gamepad.sThumbLY;
            pGamepads[i].sThumbRX          = xiState.Gamepad.sThumbRX;
            pGamepads[i].sThumbRY          = xiState.Gamepad.sThumbRY;

            // Put Xbox device input for the gamepad into our custom format
            pGamepads[i].fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fX1) < XBINPUT_DEADZONE )
                pGamepads[i].fX1 = 0.0f;

            pGamepads[i].fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fY1) < XBINPUT_DEADZONE )
                pGamepads[i].fY1 = 0.0f;

            pGamepads[i].fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fX2) < XBINPUT_DEADZONE )
                pGamepads[i].fX2 = 0.0f;

            pGamepads[i].fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fY2) < XBINPUT_DEADZONE ) 
                pGamepads[i].fY2 = 0.0f;

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed since the last
            // call. Here, we considered an analog button pressed (a boolean 
            // condition) if that value is >= the threshold.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] >= XBINPUT_BUTTONTHRESHOLD );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}



//-----------------------------------------------------------------------------
// Name: XBInput_GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* XBInput_GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( XBInput_IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: XBInput_IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL XBInput_IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 >  XBINPUT_DEADZONE ||
        pGamePad->fX1 < -XBINPUT_DEADZONE ||
        pGamePad->fY1 >  XBINPUT_DEADZONE ||
        pGamePad->fY1 < -XBINPUT_DEADZONE )
    {
        return TRUE;
    }

    if( pGamePad->fX2 >  XBINPUT_DEADZONE ||
        pGamePad->fX2 < -XBINPUT_DEADZONE ||
        pGamePad->fY2 >  XBINPUT_DEADZONE ||
        pGamePad->fY2 < -XBINPUT_DEADZONE )
    {
        return TRUE;
    }

    // Nothing active
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\playback.h ===
#include <xtl.h>
#include <dsound.h>

#include "devices.h"
#include "XBSound.h"
#include "xvoice.h"
#include "XbInput.h"
#include "XbUtil.h"
#include <xgraphics.h>


enum{
	WAIT_FOR_ENUM,
	WAIT_FOR_RECORD_BUTTON,
	RECORD_SOUND,
	WAIT_FOR_PLAY_BUTTON,
	PLAY_SOUND,
	WAIT_FOR_UNPLUG,

};


//-----------------------------------------------------------------------------
// Name: class CXHawkPlayback
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXHawkPlayback
{
private:
    // Main objects used for creating and rendering the 3D scene
	D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device

    // Variables for timing
    BOOL       m_bPaused;           // Whether app time is paused by user
   
    // Members to init the XINPUT devices.
	XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
	DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

    BOOL					m_bStartedSound;
	BOOL					m_bXHawkConnected;
	// Sounds
    CXBSound*               m_pActiveSound;
    CXBSound*               m_pNewSound;
    CXBSound                m_pSound[5];
	CHawkUnits*				m_pHawkUnits;
	int						m_eTestStep;
	LPDIRECT3DTEXTURE8      m_pGamepadTexture[6];
	LPDIRECT3DVERTEXBUFFER8 m_pVB;
public:
	// Functions to create, run, and clean up the application
    HRESULT Create();
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();
	HRESULT Run();
    CXHawkPlayback();
};

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}


#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\XbSound.h ===
//-----------------------------------------------------------------------------
// File: XBSound.h
//
// Desc: Helper class for reading a .wav file and playing it in a DirectSound
//       buffer.
//
// Hist: 12.15.00 - New for December XDK release
//       02.15.01 - Updated for March XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSOUND_H
#define XBSOUND_H
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: RIFFHEADER
// Desc: For parsing WAV files
//-----------------------------------------------------------------------------
struct RIFFHEADER
{
    FOURCC  fccChunkId;
    DWORD   dwDataSize;
};

#define RIFFCHUNK_FLAGS_VALID   0x00000001




//-----------------------------------------------------------------------------
// Name: class CRiffChunk
// Desc: RIFF chunk utility class
//-----------------------------------------------------------------------------
class CRiffChunk
{
    FOURCC            m_fccChunkId;       // Chunk identifier
    const CRiffChunk* m_pParentChunk;     // Parent chunk
    HANDLE            m_hFile;
    DWORD             m_dwDataOffset;     // Chunk data offset
    DWORD             m_dwDataSize;       // Chunk data size
    DWORD             m_dwFlags;          // Chunk flags

public:
    CRiffChunk();

    // Initialization
    VOID    Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk,
                        HANDLE hFile );
    HRESULT Open();
    BOOL    IsValid()     { return !!(m_dwFlags & RIFFCHUNK_FLAGS_VALID); }

    // Data
    HRESULT ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize );

    // Chunk information
    FOURCC  GetChunkId()  { return m_fccChunkId; }
    DWORD   GetDataSize() { return m_dwDataSize; }
};




//-----------------------------------------------------------------------------
// Name: class CWaveFile
// Desc: Wave file utility class
//-----------------------------------------------------------------------------
class CWaveFile
{
    HANDLE      m_hFile;            // File handle
    CRiffChunk  m_RiffChunk;        // RIFF chunk
    CRiffChunk  m_FormatChunk;      // Format chunk
    CRiffChunk  m_DataChunk;        // Data chunk
    
public:
    CWaveFile();
    ~CWaveFile();

    // Initialization
    HRESULT Open( const CHAR* strFileName );
    VOID    Close();

    // File format
    HRESULT GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize );

    // File data
    HRESULT ReadSample( DWORD dwPosition, VOID* pBuffer, DWORD dwBufferSize, 
                        DWORD* pdwRead );

    // File properties
    VOID    GetDuration( DWORD* pdwDuration ) { *pdwDuration = m_DataChunk.GetDataSize(); }
};




//-----------------------------------------------------------------------------
// Name: class CSound
// Desc: Encapsulates functionality of a DirectSound buffer.
//-----------------------------------------------------------------------------
class CXBSound
{
protected:
    LPDIRECTSOUNDBUFFER  m_pDSoundBuffer;
    WAVEFORMATEX         m_WaveFormat;
    DSBUFFERDESC         m_dsbd;
    DWORD                m_dwBufferSize;

public:
    HRESULT Create( const CHAR* strFileName, DWORD dwFlags = 0L );
    HRESULT Create( const WAVEFORMATEX* pwfxFormat, DWORD dwFlags,
                    const VOID* pBuffer, DWORD dwBytes );
    VOID    Destroy();

    HRESULT Play( DWORD dwFlags = 0L );
    HRESULT Stop();
    HRESULT SetPosition( const D3DXVECTOR3& vPosition );
    HRESULT SetVelocity( const D3DXVECTOR3& vVelocity );

    CXBSound();
    ~CXBSound();
};




#endif // XBSOUND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\XbInput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // Inherited members from XINPUT_GAMEPAD
	//
    // WORD    wButtons;
    // BYTE    bAnalogButtons[8];
    // SHORT   sThumbLX;
    // SHORT   sThumbLY;
    // SHORT   sThumbRX;
    // SHORT   sThumbRY;

    // Thumb stick values in range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // Buttons pressed since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;
};




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetPrimaryController()
// Desc: The first controller used by the player or the controller on the
//       lowest numbered slot. NULL if no controllers inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* XBInput_GetPrimaryController();




//-----------------------------------------------------------------------------
// Name: XBInput_IsAnyButtonActive()
// Desc: TRUE if any button or thumbstick depressed on the given controller
//-----------------------------------------------------------------------------
BOOL XBInput_IsAnyButtonActive( const XBGAMEPAD* );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\XbSound.Cpp ===
//-----------------------------------------------------------------------------
// File: XBSound.cpp
//
// Desc: Helper class for reading a .wav file and playing it in a DirectSound
//       buffer.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBSound.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// FourCC definitions
//-----------------------------------------------------------------------------
const DWORD FOURCC_RIFF   = 'FFIR';
const DWORD FOURCC_WAVE   = 'EVAW';
const DWORD FOURCC_FORMAT = ' tmf';
const DWORD FOURCC_DATA   = 'atad';




//-----------------------------------------------------------------------------
// Name: CRiffChunk()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CRiffChunk::CRiffChunk()
{
    // Initialize defaults
    m_fccChunkId   = 0;
    m_pParentChunk = NULL;
    m_hFile        = INVALID_HANDLE_VALUE;
    m_dwDataOffset = 0;
    m_dwDataSize   = 0;
    m_dwFlags      = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the object
//-----------------------------------------------------------------------------
VOID CRiffChunk::Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk, 
                             HANDLE hFile )
{
    m_fccChunkId   = fccChunkId;
    m_pParentChunk = pParentChunk;
    m_hFile        = hFile;
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Opens an existing chunk.
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::Open()
{
    RIFFHEADER rhRiffHeader;
    LONG       lOffset = 0;

    // Seek to the first byte of the parent chunk's data section
    if( m_pParentChunk )
    {
        lOffset = m_pParentChunk->m_dwDataOffset;

        // Special case the RIFF chunk
        if( FOURCC_RIFF == m_pParentChunk->m_fccChunkId )
            lOffset += sizeof(FOURCC);
    }
    
    // Read each child chunk header until we find the one we're looking for
    for( ;; )
    {
        if( INVALID_SET_FILE_POINTER == SetFilePointer( m_hFile, lOffset, NULL, FILE_BEGIN ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        DWORD dwRead;
        if( 0 == ReadFile( m_hFile, &rhRiffHeader, sizeof(rhRiffHeader), &dwRead, NULL ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        // Check if we found the one we're looking for
        if( m_fccChunkId == rhRiffHeader.fccChunkId )
        {
            // Save the chunk size and data offset
            m_dwDataOffset = lOffset + sizeof(rhRiffHeader);
            m_dwDataSize   = rhRiffHeader.dwDataSize;

            // Success
            m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

            return S_OK;
        }

        lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;
    }
}




//-----------------------------------------------------------------------------
// Name: Read()
// Desc: Reads from the file
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize )
{
    // Seek to the offset
    DWORD dwPosition = SetFilePointer( m_hFile, m_dwDataOffset+lOffset, NULL, FILE_BEGIN );
    if( INVALID_SET_FILE_POINTER == dwPosition )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Read from the file
    DWORD dwRead;
    if( 0 == ReadFile( m_hFile, pData, dwDataSize, &dwRead, NULL ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWaveFile::CWaveFile()
{
    m_hFile = INVALID_HANDLE_VALUE;
}




//-----------------------------------------------------------------------------
// Name: ~CWaveFile()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWaveFile::~CWaveFile()
{
    Close();
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Initializes the object.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Open( const CHAR* strFileName )
{
    // If we're already open, close
    Close();
    
    // Open the file
    m_hFile = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, 0L, NULL );
    if( INVALID_HANDLE_VALUE == m_hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Initialize the chunk objects
    m_RiffChunk.Initialize( FOURCC_RIFF, NULL, m_hFile );
    m_FormatChunk.Initialize( FOURCC_FORMAT, &m_RiffChunk, m_hFile );
    m_DataChunk.Initialize( FOURCC_DATA, &m_RiffChunk, m_hFile );

    HRESULT hr = m_RiffChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_FormatChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_DataChunk.Open();
    if( FAILED(hr) )
        return hr;

    // Validate the file type
    FOURCC fccType;
    hr = m_RiffChunk.ReadData( 0, &fccType, sizeof(fccType) );
    if( FAILED(hr) )
        return hr;

    if( FOURCC_WAVE != fccType )
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetFormat()
// Desc: Gets the wave file format
//-----------------------------------------------------------------------------
HRESULT CWaveFile::GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize )
{
    DWORD dwValidSize = m_FormatChunk.GetDataSize();

    if( NULL == pwfxFormat || 0 == dwFormatSize )
        return E_INVALIDARG;

    // Read the format chunk into the buffer
    HRESULT hr = m_FormatChunk.ReadData( 0, pwfxFormat, min(dwFormatSize, dwValidSize) );
    if( FAILED(hr) )
        return hr;

    // Zero out remaining bytes, in case enough bytes were not read
    if( dwFormatSize > dwValidSize )
        ZeroMemory( (BYTE*)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ReadSample()
// Desc: Reads data from the audio file.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ReadSample( DWORD dwPosition, VOID* pBuffer, 
                               DWORD dwBufferSize, DWORD* pdwRead )
{                                   
    // Don't read past the end of the data chunk
    DWORD dwDuration;
    GetDuration( &dwDuration );

    if( dwPosition + dwBufferSize > dwDuration )
        dwBufferSize = dwDuration - dwPosition;

    HRESULT hr = S_OK;
    if( dwBufferSize )
        hr = m_DataChunk.ReadData( (LONG)dwPosition, pBuffer, dwBufferSize );

    if( pdwRead )
        *pdwRead = dwBufferSize;

    return hr;
}




//-----------------------------------------------------------------------------
// Name: Close()
// Desc: Closes the object
//-----------------------------------------------------------------------------
VOID CWaveFile::Close()
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }
}




//-----------------------------------------------------------------------------
// Name: CXBSound()
// Desc: 
//-----------------------------------------------------------------------------
CXBSound::CXBSound()
{
    m_pDSoundBuffer = NULL;
    m_dwBufferSize  = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CXBSound()
// Desc: 
//-----------------------------------------------------------------------------
CXBSound::~CXBSound()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the sound. Sound is buffered to memory allocated internally
//       by DirectSound.
//-----------------------------------------------------------------------------
HRESULT CXBSound::Create( const CHAR* strFileName, DWORD dwFlags )
{
    // Find the media file
    CHAR strWavePath[512];
    HRESULT   hr;
    if( FAILED( hr = XBUtil_FindMediaFile( strWavePath, strFileName ) ) )
        return hr;

    // Open the .wav file
    CWaveFile waveFile;
    hr = waveFile.Open( strWavePath );
    if( FAILED(hr) )
        return hr;

    // Get the WAVEFORMAT structure for the .wav file
    hr = waveFile.GetFormat( &m_WaveFormat, sizeof(WAVEFORMATEX) );
    if( FAILED(hr) )
        return hr;

    // Get the size of the .wav file
    waveFile.GetDuration( &m_dwBufferSize );

    // Create the sound buffer
    hr = Create( &m_WaveFormat, dwFlags, NULL, m_dwBufferSize );
    if( FAILED(hr) )
        return hr;

    // Lock the buffer so it can be filled
    VOID* pLock1 = NULL;
    VOID* pLock2 = NULL;
    DWORD dwLockSize1 = 0L;
    DWORD dwLockSize2 = 0L;
    hr = m_pDSoundBuffer->Lock( 0L, m_dsbd.dwBufferBytes, &pLock1, &dwLockSize1, 
                                &pLock2, &dwLockSize2, 0L );
    if( FAILED(hr) )
        return hr;

    // Read the wave file data into the buffer
    hr = waveFile.ReadSample( 0L, pLock1, dwLockSize1, NULL );
    if( FAILED(hr) )
        return hr;

    // Unlock the buffer
    hr = m_pDSoundBuffer->Unlock( &pLock1, dwLockSize1, &pLock2, dwLockSize2 );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the sound and tells DirectSound where the sound data will be
//       stored. If pBuffer is NULL, DirectSound handles buffer creation.
//-----------------------------------------------------------------------------
HRESULT CXBSound::Create( const WAVEFORMATEX* pwfxFormat, DWORD dwFlags,
                          const VOID* pBuffer, DWORD dwBytes )
{
    // Setup the sound buffer description
    ZeroMemory( &m_dsbd, sizeof(DSBUFFERDESC) );
    m_dsbd.dwSize      = sizeof(DSBUFFERDESC);
    m_dsbd.dwFlags     = dwFlags;
    m_dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;

    // If pBuffer is non-NULL, dwBufferBytes will be zero, which informs
    // DirectSoundCreateBuffer that we will presently be using SetBufferData().
    // Otherwise, we set dwBufferBytes to the size of the WAV data, potentially
    // including alignment bytes.
    if( pBuffer == NULL )
    {
        m_dsbd.dwBufferBytes = ( 0 == m_WaveFormat.nBlockAlign ) ? dwBytes : 
                                 dwBytes - ( dwBytes % m_WaveFormat.nBlockAlign );
    }

    // Create the sound buffer. (Note: on Xbox, we do not need a DSound object)
    Destroy();
	DirectSoundUseLightHRTF();
    HRESULT hr = DirectSoundCreateBuffer( &m_dsbd, &m_pDSoundBuffer);
    if( FAILED(hr) )
        return hr;

    // If buffer specified, tell DirectSound to use it
    if( pBuffer != NULL )
    {
        hr = m_pDSoundBuffer->SetBufferData( (LPVOID)pBuffer, dwBytes );
        if( FAILED(hr) )
            return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the resources used by the sound
//-----------------------------------------------------------------------------
VOID CXBSound::Destroy()
{
    SAFE_RELEASE( m_pDSoundBuffer );
}




//-----------------------------------------------------------------------------
// Name: Play()
// Desc: Plays the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::Play( DWORD dwFlags ) 
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->Play( 0, 0, dwFlags );
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stops the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::Stop() 
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->Stop();
}




//-----------------------------------------------------------------------------
// Name: SetPosition()
// Desc: Positions the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetPosition( const D3DXVECTOR3& v ) 
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetPosition( v.x, v.y, v.z, DS3D_IMMEDIATE );
}




//-----------------------------------------------------------------------------
// Name: SetVelocity()
// Desc: Sets the sound's velocity
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetVelocity( const D3DXVECTOR3& v ) 
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetVelocity( v.x, v.y, v.z, DS3D_IMMEDIATE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\XbUtil.Cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";


#if 0
typedef struct D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} aD3DVOLUME_DESC;
#endif


//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
	DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
	DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

	BYTE* pSrcBits = new BYTE[ dwTextureSize ];
	memcpy( pSrcBits, pLock->pBits, dwTextureSize );
	
#if 1
	RECT  rect  = { 0, 0, pDesc->Width, pDesc->Height };
	POINT point = { 0, 0 };
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, &rect, pLock->pBits, 
		             pLock->Pitch, &point, dwPixelSize );
#else
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
		             0, NULL, dwPixelSize );
#endif

	SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
	DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
	DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

	BYTE* pSrcBits = new BYTE[ dwTextureSize ];
	memcpy( pSrcBits, pLock->pBits, dwTextureSize );
	
#if 1
	D3DBOX    box   = { 0, 0, pDesc->Width, pDesc->Height, 0, pDesc->Depth };
	XGPOINT3D point = { 0, 0, 0 };
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, &box, pLock->pBits,
		            pLock->RowPitch, pLock->SlicePitch, &point, dwPixelSize );
#else
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
		            0, 0, NULL, dwPixelSize );
#endif

	SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
	DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
	DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

	BYTE* pSrcBits = new BYTE[ dwTextureSize ];
	memcpy( pSrcBits, pLock->pBits, dwTextureSize );
	
#if 1
	RECT  rect  = { 0, 0, pDesc->Width, pDesc->Height };
	POINT point = { 0, 0 };
    XGSwizzleRect( pSrcBits, pLock->Pitch, &rect, pLock->pBits,
		          pDesc->Width, pDesc->Height, &point, dwPixelSize );
#else
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
		          pDesc->Width, pDesc->Height, 
				  NULL, dwPixelSize );
#endif

	SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
	DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
	DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

	BYTE* pSrcBits = new BYTE[ dwTextureSize ];
	memcpy( pSrcBits, pLock->pBits, dwTextureSize );
	
#if 1
	D3DBOX    box   = { 0, 0, pDesc->Width, pDesc->Height, 0, pDesc->Depth };
	XGPOINT3D point = { 0, 0, 0 };
    XGSwizzleBox( pSrcBits, pLock->RowPitch, pLock->SlicePitch, &box, pLock->pBits,
		          pDesc->Width, pDesc->Height, pDesc->Depth, &point, dwPixelSize );
#else
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
		          pDesc->Width, pDesc->Height, pDesc->Depth, 
				  NULL, dwPixelSize );
#endif

	SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( lock.pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    pSurface->UnlockRect();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
	// Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

	// Handle position
	DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
	if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
	else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

	// Handle blend weights
	if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
	if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
	if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
	if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

	// Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 5, D3DVSDT_D3DCOLOR );

	// Handle texture coordinates
	DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

	for( DWORD i=0; i<dwNumTextures; i++ )
	{
		DWORD dwNumTexCoords = 0;
		if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
		if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
		if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
		if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
			dwNumTexCoords = D3DVSDT_FLOAT4;

		Declaration[decl++] = D3DVSD_REG( 6 + i, dwNumTexCoords );
	}

	// End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_NOSYSLOCK) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\hawkprod\XbUtil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\ccl.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ccl.cpp

Abstract:

    defines all methods of the class CL, which deals with lists of controls on CPX,
	and also the functions they use

Author:

    Jason Gould (a-jasgou) May 2000

--*/
//#include "cpx.h"

//#define UNICODE

#include <xtl.h>
#include <stdio.h>
#include "device.h"
#include "ccl.h"

BYTE gDontRead	= 93;	//the index of a controlpad to not read
//extern "C" ULONG DebugPrint(PCHAR Format, ...);	//prints stuff to the debugger computer

/*************************************************************************************
Method:     CL::RegisterControl
Purpose:	add a button combination and related function to call to the control list
Params:		but --- holds the combo of buttons that should call this function
			func --- the function to call when the button combo is pressed
			context --- a variable to pass func when the button combo is pressed
Return:     0 if it worked, non-zero if there was a problem
*************************************************************************************/
DWORD CL::RegisterControl (BUTTONS but, ControlFunc func, DWORD context)
{
//	DebugPrint("Entering RegisterControl, now walking controls list...\n");
	for(CF * w = &head; w->next; w=w->next) //go to the end of the list
	{}
//	DebugPrint("Done walking the list...\n");

	w->next = new CF; //crate a new element in the list
	if(!w->next)      //if it couldn't be created... that's bad.
		return 1;

	w=w->next;        //move to the new element
	w->but = but;       //set the data appropriately
	w->func = func;
	w->context = context;
	w->next = 0;
	w->repeat = 0;
	return 0;
}

/*************************************************************************************
Method:     CL::CL
Purpose:	initialize an instance of a CL class
Params:     none
Return:     none
*************************************************************************************/
CL::CL()  //initialization
{
	head.next = 0; 
	num = 0;
}

/*************************************************************************************
Method:     CL::~CL
Purpose:	deinitialize an instance of a CL class--deallocate the list of commands
Params:     none
Return:     none
*************************************************************************************/
CL::~CL() //deinitialization
{
	CF * w, *w2;
	for(w = head.next; w; w = w2)  //remove all elements from the list
	{
		w2 = w->next;
		delete w;
	}
	head.next = 0;
	num = 0;
}

/*************************************************************************************
Function:   GetButtons
Purpose:	get the button states of the control pad at a specific slot
Params:     slot --- the slot to read
Return:     a Buttons union that uses a lot of flags to check if any button is pressed
*************************************************************************************/
BUTTONS GetButtons(DWORD slot) 
{
	WORD d;
	BUTTONS r = {0};
	gpPGAMEPAD pgp;

	if(!gpDeviceExists(slot)) {
		r.all = 0;
		return r;
	} else {
		pgp = ::gpGetState(slot);
	}
	
	r.Ab0 = pgp->bAnalogButtons[0] >= 1;
	r.Ab1 = pgp->bAnalogButtons[1] >= 1;
	r.Ab2 = pgp->bAnalogButtons[2] >= 1;
	r.Ab3 = pgp->bAnalogButtons[3] >= 1;
	r.Ab4 = pgp->bAnalogButtons[4] >= 1;
	r.Ab5 = pgp->bAnalogButtons[5] >= 1;
	r.Ab6 = pgp->bAnalogButtons[6] >= 1;
	r.Ab7 = pgp->bAnalogButtons[7] >= 1;

	r.Db = pgp->wButtons;

//	d = gInputFormat[slot].GameReport.wDPad;

	//bugbug hammerhead doesn't report this properly... 
	//remove this when real duke comes!
	//also, hammerhead dpad doesn't go to the middle... 
	//it thinks it's a steering wheel.
/*
	d *= 10;	

	if(d >= 36000) {
		r.DpDn = r.DpUp = r.DpLt = r.DpRt = 0;
	} else {
		r.DpDn = (d > 9000 + 2250 && d < 27000 - 2250);
		r.DpLt = (d > 18000 + 2250 && d < 36000 - 2250);
		r.DpRt = (d > 2250 && d < 18000 - 2250);
		r.DpUp = (d > 27000 + 2250 || d < 9000 - 2250);
	}
*/
	r.LtUp = (pgp->sThumbLY > 0);
	r.LtDn = (pgp->sThumbLY < 0);
	r.LtLt = (pgp->sThumbLX < 0);
	r.LtRt = (pgp->sThumbLX > 0);

	r.RtUp = (pgp->sThumbRY > 0);
	r.RtDn = (pgp->sThumbRY < 0);
	r.RtLt = (pgp->sThumbRX < 0);
	r.RtRt = (pgp->sThumbRX > 0);

//	DebugPrint("Slot: %d, r: %016I64X\n", slot, r.all);

	return r;

}

/*************************************************************************************
Method:     CL::CheckControls
Purpose:	see if any control pattern is being pressed, and call the appropriate 
			function if it is
Params:     none
Return:     the number of functions called
*************************************************************************************/
DWORD CL::CheckControls()
{
	int count = 0;
	int count2;
	for(CF * w = head.next; w; w = w->next)
	{
		count2 = count;
		for(int i = 0; i < gpMaxSlots(); i++)
		{
			if(i == gDontRead) {
				continue;
			}

			if (cclCheckButtons(i, w->but.all)) {
				count++;
				if(w->func) {
					w->func(w->context, w->repeat, (BYTE)i);
					w->repeat = TRUE;
				}
			}
		}
		if (count2 == count) {
			w->repeat = FALSE;
		}
	}

	num = count;

	return count;
}

/*************************************************************************************
Function:   cclCheckButtons
Purpose:	see if the specified pattern is being pressed on the specified control pad
Params:     slot --- the slot to check for button presses
			b --- the button pattern to check for
Return:     TRUE if it is being pressed, FALSE otherwise
*************************************************************************************/
BOOL cclCheckButtons(int slot, UINT64 all)
{
	if(slot == -1) {
		for(int i = 0; i < gpMaxSlots(); i++) {
			if(cclCheckButtons(i, all)) {
				return TRUE;
			}
		}
		return FALSE;
	}

	if(all & bANY) {
		if((GetButtons(slot).all & all) != 0) {
			return TRUE;
		}
	} else {
		if((GetButtons(slot).all & all) == all) {
			return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\device.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    device.cpp

Abstract:

    all functions necessary to get input about control pads and MUs for CPX

Author:

    Jason Gould (a-jasgou) May 2000

--*/

#include <xtl.h>
//#include <stdio.h>
#include <time.h>			//for keeping track of how old device states are
//#include "xinput.h"			//Mitch's input (control pad, etc) routines

#include "tsc.h"

#include "device.h"
#define MAX_SLOTS (XGetPortCount())

#define BADSLOT (-1)

extern "C" ULONG DebugPrint(PCHAR Format, ...);	//prints stuff to the debugger computer


//*******************GLOBAL DUKE DATA*************************************************
HANDLE					gDeviceHandle	[MAX_SLOTS];		//array of deivce handles
static XINPUT_STATE				gInputFormat	[MAX_SLOTS];		//holds the 26 bytes of button states, etc.
static int						gRealSlot		[MAX_SLOTS];
static gpLOGFUNC				gLogFunc					= NULL;
//*******************time stuff*******************************************************
       UINT64					gLastUpdate		[MAX_SLOTS];			//last update of each slot
       UINT64					gTimeStart;								//beginning of time for this program

static BOOL						gDoMapping = 0;


INT64 gpTSecondAge(int slot) { return AGE(slot) / 100000; }


///*************************************************************************************
//Function:	gpPoll
//Purpose:	Poll all devices
//Params:	none
//*************************************************************************************/
void gpPoll()
{

	for(int i=0;i<MAX_SLOTS; i++) {
		if(gDeviceHandle[i]) {
			XInputPoll(gDeviceHandle[i]);	//poll all devices...
		}
	}

}



/*************************************************************************************
Function:	gpGetDeviceMessages
Purpose:	deal with messaging system to figure out what devices are inserted/removed
Params:		none
Return:		none
*************************************************************************************/
void gpGetDeviceMessages()
{
	DWORD insert;
	DWORD remove;
	XINPUT_POLLING_PARAMETERS pp = {FALSE, TRUE, 0, 1, 1, 0};

	int i, j;
	int temp;

	if(XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &insert, &remove)) {
		for (i = 0; i < MAX_SLOTS; i++) {
			if(remove & (1 << i)) { 
				if(gDoMapping) {
					for(j = 0; j < MAX_SLOTS; j++) {
						if(gRealSlot[j] == i) {
							DebugPrint("Device removed from 'slot' %d, which is really %d \n", j, i);
							XInputClose(gDeviceHandle[j]);
							gDeviceHandle[j] = 0;
							gRealSlot[j] = BADSLOT;
							gLastUpdate[j] = TscTicksToUSeconds(TscCurrentTime(gTimeStart));
							break;
						}
						if(j >= MAX_SLOTS - 1) { 
							DebugPrint("Device removed from real slot %d, but not found!\n", i);
						}
					}
				} else {
					DebugPrint("Device removed from slot %d.\n", i);
					gLastUpdate[i] = TscTicksToUSeconds(TscCurrentTime(gTimeStart));
					if(gDeviceHandle[i]) XInputClose(gDeviceHandle[i]);
					gDeviceHandle[i] = 0;
					gRealSlot[i] = BADSLOT;
				}
			}
			if(insert & (1 << i)) {
				if(gDoMapping) {
					for(j = 0; j < MAX_SLOTS; j++) {
						if(gRealSlot[j] == BADSLOT) {
							gLastUpdate[j] = TscTicksToUSeconds(TscCurrentTime(gTimeStart));
							DebugPrint("Device inserted to %d, mapped to %d\n", i, j);
							gDeviceHandle[j] = XInputOpen(XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, &pp);
							if (gDeviceHandle[j] == NULL) {
								DebugPrint("XInputOpenGameController returned %d!!!", GetLastError());
							} else {
								gRealSlot[j] = i;
							}
							break;
						}
						if(j == MAX_SLOTS) {
							DebugPrint("Device inserted to slot %d, no avalible positions??", i);
							for(j = 0; j < MAX_SLOTS; j++) {
								DebugPrint(" %d", gRealSlot[j]);
							}
							break;
						}
					}
				} else {
					gLastUpdate[i] = TscTicksToUSeconds(TscCurrentTime(gTimeStart));
					DebugPrint("Device inserted in slot %d\n", i);
					gDeviceHandle[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, &pp);
					if (NULL == gDeviceHandle[i]) {
						DebugPrint("XInputOpen returned %d!!!", GetLastError());
					} else {
						gRealSlot[i] = i;
					}
				}
			}
		}
	}
}

/*************************************************************************************
Function:	gpUpdateDeviceStateInfo
Purpose:	update all info for all plugged-in devices
Params:		none
*************************************************************************************/

void gpUpdateDeviceStateInfo()
{
	DWORD r;
	int i;
	const unsigned char * pc;
	int c;

	gpGetDeviceMessages();

	for(BYTE slot = 0; slot < MAX_SLOTS; slot++)	//go through all slots...
	{
		if(gDeviceHandle[slot] != NULL)	//get info if the device is plugged in
		{
			DWORD packet = gInputFormat[slot].dwPacketNumber;
			r = XInputGetState(gDeviceHandle[slot], &gInputFormat[slot]);
			if(ERROR_SUCCESS != r) {
				DebugPrint("InputGetDeviceState returned %d for slot %d.\n", r, slot);
				return;
			}

			if(packet != gInputFormat[slot].dwPacketNumber) {
				if(gLogFunc) {
					gLastUpdate[slot] = TscTicksToUSeconds(TscCurrentTime(gTimeStart));
					gLogFunc(gLastUpdate[slot], slot, (gpGAMEPAD*)&gInputFormat[slot].Gamepad, gInputFormat[slot].dwPacketNumber);
				}

			}
		}
	}
}

/*************************************************************************************
Function:	gpInputSetState
Purpose:	set the input state (Rumble, etc...)
*************************************************************************************/
DWORD gpInputSetState(int slot, IN OUT PXINPUT_FEEDBACK Feedback)
{
	return XInputSetState(gDeviceHandle[slot], Feedback);
}

/*************************************************************************************
Function:	gpInit
Purpose:	initialize the device stuff in this file
Params:		none
*************************************************************************************/
DWORD gpInit(BOOL DoMapping)
{
	int i;

	gpDeinit();

	gDoMapping = DoMapping;

	TscInit(0);
	gTimeStart = TscBegin();

	return 0;
}

/*************************************************************************************
Function:	gpDeinit
Purpose:	deinitialize stuff
Params:		none
*************************************************************************************/
VOID gpDeinit()
{
	int i;

	for(i = 0; i < MAX_SLOTS; i++) {
		if(gDeviceHandle[i]) {
			DebugPrint("Closing controller %d\n", i);
			XInputClose(gDeviceHandle[i]);
			gDeviceHandle[i] = 0;
		}
		gRealSlot[i] = BADSLOT;
	}


}

/*************************************************************************************
Function:	gpDeviceExists
Purpose:	return TRUE if a device in the given slot is plugged in
Params:		slot ---
return:		TRUE or FALSE.
*************************************************************************************/
_declspec(dllexport) BOOL __inline gpDeviceExists(int slot)
{
	return (gDeviceHandle[slot] ? TRUE : FALSE);
}


/*************************************************************************************
Function:	gpSetLogFunction
Purpose:	set the log function to a user-defined routine
Params:		func --- the function to call, or NULL if nothing to call
*************************************************************************************/
BOOL gpSetLogFunction(gpLOGFUNC func) 
{
	gLogFunc = func;
	return TRUE;
}

_declspec(dllexport) gpPGAMEPAD __inline gpGetState(int slot)
{
	return (gpGAMEPAD*)&gInputFormat[slot].Gamepad;
}

_declspec(dllexport) int __inline gpMaxSlots() { return MAX_SLOTS; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\draw.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    draw.cpp

Abstract:

    simplified functions that call Matt's dxconio functions... Used by CPX

Author:

    Jason Gould (a-jasgou) May 2000

--*/

#include "xtl.h"
#include "draw.h"
#include "Xfont.h"
//#include "bitfont.h"

extern "C" void DebugPrint(char*,...);

//#ifdef DEBUG
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) DebugPrint(#code "File %s Line %d, Failed: %d\n", __LINE__, __FILE__, _ret__); } while (0);
//#else
//#define CHECK(code) code;
//#endif

typedef struct MYVERTEX {
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
} MYVERTEX, *PMYVERTEX;

static IDirect3DDevice8* gDevice = 0;
static IDirect3DSurface8* gBackBuffer = 0;
static IDirect3DVertexBuffer8* gVertexBuffer = 0;

static int gScreenWidth = 640; 
static int gScreenHeight = 480;
static float gWidth = 8;
static float gHeight = 15;
static DWORD gColor = 0xff00ff00;
static DWORD gBkColor = 0xff000000;
static XFONT* gFont = 0;

/*************************************************************************************
Function:   drInit
Purpose:	initialize drawing stuff
Return:     none
*************************************************************************************/
void drInit(int width, int height)
{
	gScreenWidth = width;
	gScreenHeight = height;

	HWND hwnd = 0;
	gBackBuffer = NULL;

	if (gDevice == NULL)
	{
		// Create D3D 8.

		IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
		if (pD3D == NULL)
			return;

		// Set the screen mode.

		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory(&d3dpp, sizeof(d3dpp));

		d3dpp.BackBufferWidth           = width;
		d3dpp.BackBufferHeight          = height;
		d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount           = 1;
		d3dpp.Windowed                  = false;    // Must be false for Xbox
		d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
		d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
		d3dpp.FullScreen_RefreshRateInHz= 60;	//or 72?
		d3dpp.hDeviceWindow             = hwnd;   // Ignored on Xbox

		// Create the gDevice.

		if (pD3D->CreateDevice
		(
			D3DADAPTER_DEFAULT,
			D3DDEVTYPE_HAL,
			hwnd,                                 // Ignored on Xbox
			D3DCREATE_HARDWARE_VERTEXPROCESSING,
			&d3dpp,
			&gDevice
		) != S_OK)
		{
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.

		pD3D->Release();
	}

	gDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &gBackBuffer);

    gDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    gDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    gDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    gDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	gDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

	gDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);

	gDevice->CreateVertexBuffer(sizeof(MYVERTEX)*4, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE,
		D3DPOOL_DEFAULT, &gVertexBuffer);

	gDevice->SetStreamSource(0, gVertexBuffer, sizeof(MYVERTEX));

	
	
	DebugPrint("opening cour: %x\n", XFONT_OpenBitmapFont(L"t:\\media\\cour.xft", 4096, &gFont));

	// try D:
	if(gFont == 0)
	{
		DebugPrint("opening cour: %x\n", XFONT_OpenBitmapFont(L"d:\\media\\cour.xft", 4096, &gFont));
	}

	if(gFont == 0) {
		DebugPrint("Opening arial: %x\n", XFONT_OpenBitmapFont(L"t:\\media\\arialb16.xft", 4096, &gFont));
	}
	
	// again, try D:
	if(gFont == 0) {
		DebugPrint("Opening arial: %x\n", XFONT_OpenBitmapFont(L"d:\\media\\arialb16.xft", 4096, &gFont));
	}


	if(gFont == 0) {
		DebugPrint("gFont == 0! Font not loaded!\n");
	}


	if(gFont) XFONT_SetTextColor(gFont, 0xff00ff00);
	if(gFont) XFONT_SetBkColor(gFont, 0x00000000);
}

/*************************************************************************************
Function:   drDeinit
Purpose:	deinitialize the drawing stuff
Return:     none
*************************************************************************************/
void drDeinit()
{
	gBackBuffer->Release();
	gDevice->Release();

}

void drClearRect(float x1, float y1, float x2, float y2, DWORD color) 
{
	D3DRECT rect;

	if (gDevice != NULL)
	{
		if(x1 < x2) {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		} else {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if(y1 < y2) {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		} else {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		gDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
	}

}

/*************************************************************************************
Function:   drCls
Purpose:	clears the screen
Return:     none
*************************************************************************************/
void drCls()
{
	D3DRECT rect;
	rect.x1 = rect.y1 = 0;
	rect.x2 = rect.y2 = 2000;

	gDevice->Clear(1, &rect, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0, 1.0f, 0);
}



/*************************************************************************************
Function:   drBox
Purpose:	draw a rectangle
Params:     x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
            col --- the RGBA color to draw the box with
Return:     none
*************************************************************************************/
void drLine(float x1, float y1, float x2, float y2, DWORD color)
{
/**/

	drClearRect(x1, y1, x2, y2, color);

/*/

  
	MYVERTEX * pb;
	
	CHECK(gDevice->SetRenderState(D3DRS_LASTPIXEL, FALSE));

	CHECK(gDevice->BeginScene());
	CHECK(gVertexBuffer->Lock(0,128,(BYTE**)&pb,0));
	
	if(IsBadWritePtr(pb, 128))
	{
		DebugPrint("Lock returned %p, which is BAD!\n", pb);
		return;
	}

	pb[0].v.x = x1  ; pb[0].v.y = y1  ; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = x1  ; pb[1].v.y = y1  ; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = x2  ; pb[2].v.y = y2  ; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;

	CHECK(gVertexBuffer->Unlock());

//	m.Ambient.r = m.Diffuse.r = m.Emissive.r = m.Specular.r = (float)((color      ) & 255) / 255;
//	m.Ambient.g = m.Diffuse.g = m.Emissive.g = m.Specular.g = (float)((color >>  8) & 255) / 255;
//	m.Ambient.b = m.Diffuse.b = m.Emissive.b = m.Specular.b = (float)((color >> 16) & 255) / 255;
//	m.Ambient.a = m.Diffuse.a = m.Emissive.a = m.Specular.a = (float)((color >> 24)      ) / 255;
//	
//	gDevice->SetMaterial(&m);



	CHECK(gDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1));
	CHECK(gDevice->EndScene());

	CHECK(gDevice->SetRenderState(D3DRS_LASTPIXEL, TRUE));

/**/

}


/*************************************************************************************
Function:   drQuad
Purpose:	draw a quadrilateral
Params:     x* --- x coordinate for point * 
			y* --- y coordinate for point *
			c* --- color at point *
Return:     none
*************************************************************************************/
void drQuad(float x1, float y1, DWORD c1,
			float x2, float y2, DWORD c2,
			float x3, float y3, DWORD c3,
			float x4, float y4, DWORD c4)
{
	MYVERTEX * pb;
	float maxx, minx;
	float maxy, miny;

	CHECK(gDevice->BeginScene());
	CHECK(gVertexBuffer->Lock(0,128,(BYTE**)&pb,0));
	
	if(IsBadWritePtr(pb, 128))
	{
		DebugPrint("Lock returned %p, which is BAD!\n", pb);
		return;
	}


	pb[0].v.x = x1; pb[0].v.y = y1; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = c1;
	pb[1].v.x = x2; pb[1].v.y = y2; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = c2;
	pb[2].v.x = x3; pb[2].v.y = y3; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = c3;
	pb[3].v.x = x4; pb[3].v.y = y4; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = c4;

	gVertexBuffer->Unlock();

	gDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	gDevice->EndScene();
}

/*************************************************************************************
Function:   drBox
Purpose:	draw a rectangle
Params:     x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
            col --- the RGBA color to draw the box with
Return:     none
*************************************************************************************/
void drBox(float x1, float y1, float x2, float y2, DWORD color)
{
	MYVERTEX * pb;
	float maxx, minx;
	float maxy, miny;

	CHECK(gDevice->BeginScene());
	CHECK(gVertexBuffer->Lock(0,128,(BYTE**)&pb,0));
	
	if(IsBadWritePtr(pb, 128))
	{
		DebugPrint("Lock returned %p, which is BAD!\n", pb);
		return;
	}

	if(x1 < x2) {
		minx = x1;
		maxx = x2;
	} else {
		minx = x2;
		maxx = x1;
	}

	if(x1 < x2) {
		miny = y1;
		maxy = y2;
	} else {
		miny = y2;
		maxy = y1;
	}

//	maxx++;
//	maxy++; 

	if(x1 == x2) {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	gVertexBuffer->Unlock();

	gDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	gDevice->EndScene();
}




/*************************************************************************************
Function:   drSetSize
Purpose:	set default font size and color for drPrintf
Params:     width, height --- the size of each letter of the font, in pixels
            col --- the RGBA color to draw text with
Return:     none
*************************************************************************************/
void drSetSize(float width, float height, DWORD col, DWORD bkcol)
{
	gWidth = width; gHeight = height; 
	gColor = col; 
	gBkColor = bkcol;

	if(gFont) XFONT_SetTextColor(gFont, gColor);
	if(gFont) XFONT_SetBkColor(gFont, gBkColor);


}

/*************************************************************************************
Function:   drGetSize
Purpose:	get the width, height, and color of the current default font
Params:     pwidth, pheight, pcolor --- pointers to memory to receive the data
            col --- the RGBA color to draw the box with
Return:     none
*************************************************************************************/
void drGetSize(
    OPTIONAL OUT float*pwidth, 
	OPTIONAL OUT float*pheight, 
	OPTIONAL OUT DWORD*pcolor,
	OPTIONAL OUT DWORD*pbkcolor
	)
{
	if(pwidth)*pwidth=gWidth;
	if(pheight)*pheight=gHeight;
	if(pcolor)*pcolor=gColor;
	if(pcolor)*pbkcolor=gBkColor;
}

/*************************************************************************************
Function:   drGetStrSize
Purpose:	get the width, in pixels, of a string
Params:     str --- pointer to the unicode string to measure
			len --- the number of chars in that string, or -1, if null-terminated
Return:     length in pixels of the string
*************************************************************************************/
int drGetStrSize(
	IN LPCWSTR str, 
	IN int len
	) 
{
	unsigned outlen;
	XFONT_GetTextExtent(gFont, str, len, &outlen);
	return outlen;
}

/*************************************************************************************
Function:   drPrintf
Purpose:	prints formatted text, using the default font size and color
Params:     x1, y1 --- coordinates of the upper-left point to start the text
            format --- the WIDE_CHAR formatted string of text
			... --- optional params for the formatted text
Return:     the number of chars printed
*************************************************************************************/
int drPrintf(float x1, float y1, TCHAR* format, ...)
{
	int i;
	HRESULT h;
	va_list v;
	TCHAR wstr[256];

	va_start(v, format);
	i = wvsprintf(wstr, format, v);

	if(gFont) h = XFONT_TextOut(gFont, gBackBuffer, wstr, i, (long)x1, (long)y1);
	if(gFont) if(h != 0) DebugPrint("XFONT_TextOut: %x\n", h);

	va_end(v);
	return i;
}

/*************************************************************************************
Function:   drShowScreen
Purpose:	draw the screen buffer to the monitor
Params:     none
Return:     0, or error code
*************************************************************************************/
void drShowScreen()
{
						#ifdef _UseDxConio_
							xDisplayConsole();
                        #endif

	if (gDevice != NULL) {
		gDevice->Present(NULL, NULL, NULL, NULL);
	}

}

/*************************************************************************************
Function:   drBitBlt
Purpose:	draw the inputed bit array to the screen
Params:     fx - the upper left x coordinate on screen
            fy - the upper left y coordinate on screen
			ulWidth - the width of the bitmap
			ulHeight - the height of the bitmap
			pData - a pointer to the array of pixel values
Return:     none
*************************************************************************************/

void drBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const BYTE* pData )
{
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				drLine( fx + x, fy + y, fx + x, fy + y, (DWORD) pData[y * ulWidth + x] );
			}
		}
	}

}

DWORD drScaledFloatToRgba(float r, float g, float b, float a)
{
	return ((BYTE)(r * 255) + (((BYTE)(g * 255)) << 8) + (((BYTE)(b * 255)) << 16) + (((BYTE)(a * 255)) << 24));
}

DWORD drUnscaledFloatToRgba(float r, float g, float b, float a) 
{
	return ((BYTE)r + ((BYTE)g << 8) + ((BYTE)b << 16) + ((BYTE)a << 24));
}

DWORD drHslToRgb(float h, float s, float l, float al)
{
	float r, g, b, a = al;

	if (h > 360)	//bug, h could be > 720... I don't really care. % doesn't seem to work here.
		h += 360;
	if (h < 0)
		h += 360;

	if((h >= 0) && (h < 60)) {
		r = l / 100;
		b = r - (r * s / 100);
		g = b + (r - b)*(h - 0)/60;
	} 
	else if((h >= 60) && (h < 120)) {
		g = l / 100;
		b = g - (g * s / 100);
		r = b + (g - b) * (120 - h) / 60;
	} 
	else if((h >=120) && (h <180)) {
		g = l / 100;
		r = g - (g * s / 100);
		b = r + (g - r)*(h-120)/60;
	} 
	else if((h >=180) && (h < 240)) {
		b = l / 100;
		r = b - (b * s / 100);
		g = r + (b - r) * (240 - h) / 60;
	} 
	else if((h >= 240) && (h < 300)) {
		b = l / 100;
		g = b - (b * s / 100);
		r = g + (b - g)*(h-240)/60;
	} 
	else if((h >= 300) && (h < 360)) {
		r = l / 100;
		g = r - (r * s / 100);
		b = g + (r - g) * (360 - h) / 60;
	}
	return ::drScaledFloatToRgba(r,g,b,a);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\mu.cpp ===
#include "xtl.h"
#include "xbox.h"
#include "tsc.h"
//#include "device.h"
#include "mmu.h"


extern "C" void DebugPrint(char *, ...);
extern UINT64					gLastUpdate		[];			//last update of each slot
extern UINT64					gTimeStart;					//beginning of time for this program

CHAR gMuDrive[32];


BOOL muInit()
{
	int i;
	DWORD insert;
	int port, slot;
	DWORD temp;

	DebugPrint("Getting MU devices...\n");
	insert = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);

	for(i = 0; i < 32; i++) {
		port = i & 15;
		slot = i < 16 ? XDEVICE_TOP_SLOT : XDEVICE_BOTTOM_SLOT;
		if(insert & (1 << i)) {
			gLastUpdate[port] = TscTicksToUSeconds(TscCurrentTime(gTimeStart));
			DebugPrint("MU inserted in slot %x --", i);
			temp = XMountMU(port, slot, &gMuDrive[i]);
			DebugPrint("XMountMU: %d -- ", temp);
			DebugPrint("Drive: %c\n", gMuDrive[i]);
		} else {
			gMuDrive[i] = '\0';
		}
	}

	return TRUE;
}

BOOL muDeinit()
{
	int i;
	for(i = 0; i < 32; i++) {
		if(gMuDrive[i] != '\0') {
			XUnmountMU(i & 15, i < 16 ? XDEVICE_TOP_SLOT : XDEVICE_BOTTOM_SLOT);
		}
	}
	return TRUE;
}

void muGetDeviceMessages()
{
	DWORD insert;
	DWORD remove;

	int port, slot;

	int i, j;
	int temp;

//	DebugPrint("Getting MU device changes\n");
	if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &insert, &remove)) {
		for (i = 0; i < 32; i++) {
			port = i & 15;
			slot = i < 16 ? XDEVICE_TOP_SLOT : XDEVICE_BOTTOM_SLOT;
			if(remove & (1 << i)) { 
				DebugPrint("MU removed from slot %x.\n", i);
				gLastUpdate[port] = TscTicksToUSeconds(TscCurrentTime(gTimeStart));
				if(gMuDrive[i] != '\0') XUnmountMU(port, slot);
				gMuDrive[i] = '\0';
			}

			if(insert & (1 << i)) {
				gLastUpdate[port] = TscTicksToUSeconds(TscCurrentTime(gTimeStart));
				DebugPrint("MU inserted in slot %x --", i);
				temp = XMountMU(port, slot, &gMuDrive[i]);
				if(temp != 0) gMuDrive[i] = '\0';
				DebugPrint("XMountMU: %d -- ", temp);
				DebugPrint("Drive: %c\n", gMuDrive[i]);
			}
		}
	}
}

CHAR muGetDriveFromPortSlot(int port, int slot)
{
	return gMuDrive[port+ (slot?16:0)];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\num.cpp ===
#include <xtl.h>
#include <stdio.h>
#include "draw.h"
#include "num.h"
#include <math.h>

#define PI (3.1415926535897932384626)
#define NUMREPEATSCALE (2)

static double gRipple;


typedef struct NUM {
	bool arf[7];
} NUM;

NUM gNumbers[]={{1,1,1,0,1,1,1},	//0
				{0,0,1,0,0,1,0},	//1
				{1,0,1,1,1,0,1},	//2
				{1,0,1,1,0,1,1},	//3
				{0,1,1,1,0,1,0},	//4
				{1,1,0,1,0,1,1},	//5
				{1,1,0,1,1,1,1},	//6
				{1,0,1,0,0,1,0},	//7
				{1,1,1,1,1,1,1},	//8
				{1,1,1,1,0,1,0}};	//9

void numDrawNum(float x, float y, float sizex, float sizey, int num, DWORD col)
{
	if(gNumbers[num].arf[0]) {
		drLine(x+1,		y,			x+sizex-1,	y,				col);
		drLine(x+2,		y+1,		x+sizex-2,	y+1,			col);
	}
	if(gNumbers[num].arf[1]) {
		drLine(x,		y+2,		x,			y+sizey/2-1,	col);
		drLine(x+1,		y+3,		x+1,		y+sizey/2-2,	col);
	}
	if(gNumbers[num].arf[2]) {
		drLine(x+sizex,	y+2,		x+sizex,	y+sizey/2-1,	col);
		drLine(x+sizex-1,y+3,		x+sizex-1,	y+sizey/2-2,	col);
	}
	if(gNumbers[num].arf[3]) {
		drLine(x+2,		y+sizey/2,	x+sizex-2,	y+sizey/2,		col);
		drLine(x+3,		y+1+sizey/2,x+sizex-3,	y+1+sizey/2,	col);
	}
	if(gNumbers[num].arf[4]) {
		drLine(x,		y+1+sizey/2,x,			y+sizey-2,		col);
		drLine(x+1,		y+2+sizey/2,x+1,		y+sizey-3,		col);
	}
	if(gNumbers[num].arf[5]) {
		drLine(x+sizex,	y+1+sizey/2,x+sizex,	y+sizey-2,		col);
		drLine(x+sizex-1,y+2+sizey/2,x+sizex-1,	y+sizey-3,		col);
	}
	if(gNumbers[num].arf[6]) {
		drLine(x+2,		y+sizey-1,	x+sizex-2,	y+sizey-1,		col);
		drLine(x+1,		y+sizey,	x+sizex-1,	y+sizey,		col);
	}
}

void numRipple()
{
	gRipple += .01 * NUMREPEATSCALE;
	if(gRipple > 2*PI*NUMREPEATSCALE) gRipple -= 2*PI*NUMREPEATSCALE;
}

void numDrawNumbers(int num, float x, float y, float sizex, float sizey, DWORD col, DWORD flags)
{
	char buf[32];
	float startx, dx, starty, dy;
	float spacer = 3;
	int i;
	float tempx, tempy;
	float yoffset;

	sprintf(buf, "%d", num);

	switch(flags & 3)
	{
	case numALIGN_LEFT:
		startx = x;
		dx = sizex + spacer;
		starty = y;
		dy = 0;
		break;
	case numALIGN_RIGHT:
		dx = sizex + spacer;
		startx = x + spacer - (dx * strlen(buf));
		starty = y;
		dy = 0;
		break;
	case numALIGN_CENTER:
		dx = sizex + spacer;
		startx = x + (spacer - (dx * strlen(buf))) / 2;
		starty = y;
		dy = 0;
		break;
	case numDRAW_VERCIAL:
		startx = x;
		dx = 0;
		starty = y;
		dy = sizey + spacer;
		break;
	}

	yoffset = 0;
	for(i = 0, tempx = startx, tempy = starty; buf[i]; i++, tempx += dx, tempy += dy) {
		if(flags & numRIPPLE) {
			yoffset = sizey * .5f * (float)cos((gRipple + i) / NUMREPEATSCALE);
		}
		numDrawNum(tempx, tempy + yoffset, sizex, sizey, buf[i] - '0', col);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\xpong.cpp ===
#include <xtl.h>
#include "device.h"
#include "ccl.h"
#include "draw.h"
#include "modes.h"
#include "xpong.h"
#include "xsound.h"
#include "num.h"
#include "tsc.h"
//#include "ui.h"

//#define _DontUseSound_

#ifdef _DontUseSound_
#define XPlaySound(a) (true)
#endif

extern "C" ULONG DebugPrint(PCHAR Format, ...);

#define PaddleSpeed (.175f)
#define BallSpeed (.12f)
#define Width 640
#define Height 480

typedef struct PADDLE {
	float x;
	float y;
	float height;
	float width;
	DWORD color;
} PADDLE;

typedef struct BALL{
	float x;
	float y;
	float height;
	float width;
	DWORD color;
	float dx;
	float dy;
} BALL;


static BUTTONS AnyKey;
static CL pongcommands;	//command list that includes all commands used in xpong mode

static score[2] = {0,0};
//the paddles:
static PADDLE p[2] =   {{5, Height / 2 - 50, 100, 3, 0xffffffff},	
						{Width - 5, Height / 2, 100, 3, 0xffffffff}};

static float pdy[2];	//amount of paddle movement

static BALL ball = {Width / 2, Height / 8, 5, 5, 0xffffff00, -BallSpeed, BallSpeed};

static int gSoundError = 0;

float fabs(float a) { return a < 0 ? -a : a; }
float sign(float a) { return (a == 0) ? (float)0 : (a < 0) ? (float)-1 : (float)1; }

enum PONG_SOUND { PONG_BALL_PADDLE_HIT=0, PONG_BALL_WALL_HIT, PONG_PLAYER1_WIN, PONG_PLAYER2_WIN };

IXsound * gixs = NULL;

bool InitSound()
{
	CHAR* files[] = {"t:\\media\\ding.wav","t:\\media\\chord.wav","t:\\media\\tada.wav","t:\\media\\chimes.wav"};
	return IXsound::InitSound(files, &gixs);
}

bool KillSound( void )
{
	if(gixs)
		delete(gixs);
	return true;
}

bool XPlaySound( PONG_SOUND pong_sound )
{
	if(gixs)
		return gixs->XPlaySound((UINT)pong_sound);
	else
		return false;
}

/*************************************************************************************
Method:     MoveUp
Purpose:	this is called when the left thumb stick moves up
Params:		context --- if 1, then right thumbstick represents the other control pad
			repeat --- also irrelevant for this game
			slot --- the player who is moving
Return:     none
*************************************************************************************/
VOID MoveUp(DWORD context, BOOL repeat, BYTE slot)
{
	if(slot > 1) return;
	gpGAMEPAD*pgp;

	pgp = gpGetState(slot);

	if(!gpDeviceExists(0) || !gpDeviceExists(1)) { 
		slot = (BYTE)context;		
	}
	pdy[slot] = -(float)(context ? pgp->sThumbRY : pgp->sThumbLY) / (float)32768;

	p[slot].y = max( p[slot].y + PaddleSpeed * pdy[slot], 0);
}

/*************************************************************************************
Method:     MoveDown
Purpose:	this is called when left thumb stick moves down
Params:		context --- irrelevant
			repeat --- also irrelevant for this game
			slot --- the player who is moving
Return:     none
*************************************************************************************/
VOID MoveDown(DWORD context, BOOL repeat, BYTE slot)
{
	if(slot > 1) return;
	gpGAMEPAD*pgp;

	pgp = gpGetState(slot);

	if(!gpDeviceExists(0) || !gpDeviceExists(1)) {
		slot = (BYTE)context;
	}
	pdy[slot] = -(float)(context ? pgp->sThumbRY : pgp->sThumbLY) / (float)32768;

	p[slot].y = min( p[slot].y + PaddleSpeed * pdy[slot], Height - p[slot].height);
}

/*************************************************************************************
Method:     DrawStuff
Purpose:	draws the paddles, the ball, the score, etc
Params:		none
Return:		none
*************************************************************************************/
VOID DrawStuff(int status)
{
	int i;


	//draw the score
//	drPrintf(Width / 2 - 30, 60, L"Score  %d : %d", score[0], score[1]);
	numDrawNumbers(score[0], 310, 10, 8, 16, 0xff00ff00, numALIGN_RIGHT | (status==1?numRIPPLE:0));
	numDrawNumbers(score[1], 330, 10, 8, 16, 0xff00ff00, numALIGN_LEFT  | (status==2?numRIPPLE:0));

	//draw the paddles
	for(i = 0; i <= 1; i++)	{
		drBox(p[i].x, p[i].y, p[i].x + p[i].width, p[i].y + p[i].height, p[i].color);
	}

	//draw the ball
	drBox(ball.x, ball.y, ball.x + ball.width, ball.y + ball.height, ball.color);
}

/*************************************************************************************
Method:     AnyKeyPressed
Purpose:	return TRUE if any button is pressed on the control pad, false otherwise
*************************************************************************************/
BOOL AnyKeyPressed()
{
	int i;
	for(i = 0; i < gpMaxSlots(); i++)
	{
		if(cclCheckButtons(i, bANYBUTTON)) {
			return TRUE;
		}
	}
	return FALSE;
}

/*************************************************************************************
Method:     win
Purpose:	wave the scores up and down when someone wins
Params:		p: the player that won (0 for player1, 1 for player2)
Return:		none
*************************************************************************************/
void win(int p)
{
	INT64 timer;

	score[p]++;
	if(!XPlaySound((p==0) ? PONG_PLAYER1_WIN : PONG_PLAYER2_WIN)) {
		gSoundError++;
		if(gSoundError <= 8)
			DebugPrint("XPlaySound(PONG_PLAYER%d_WIN) failed!\n", p==1?1:2);
		if(gSoundError == 8)
			DebugPrint("XPlaySound -- halting further error messages\n");
	}

	timer = TscBegin();

	while((TscTicksToFMSeconds(TscCurrentTime(timer)) < 2500) && !AnyKeyPressed()) 
	{
		drCls();
		drPrintf(100, 80, L"Player %d wins!", p + 1);
		gpUpdateDeviceStateInfo();				//update the button state info...
		gpPoll();
		numRipple();
		DrawStuff(p+1);
		drShowScreen();
	}
	
	XPong(STATUS_LEAVE, 1);
	XPong(STATUS_ENTER, 1);
}

/*************************************************************************************
Function:   XPong
Purpose:	update the state of xpong on the screen (move paddles, ball, etc)
Params:		context --- initilize (stage 1 or 2), play, or quit (Stage 1 or 2)
			param --- unused
Return:     none
*************************************************************************************/
VOID XPong(DWORD context, /* unused */ INT param)
{
	
	switch(context)
	{
	case STATUS_NORMAL:
		pdy[0] = pdy[1] = 0;
		pongcommands.CheckControls();

		if(ball.y <= 0) {
			ball.dy = fabs(ball.dy);		//make ball bounce off the top of the screen
			if (!XPlaySound(PONG_BALL_WALL_HIT)) {
				gSoundError++;
				if(gSoundError <= 8)
					DebugPrint("XPlaySound(PONG_BALL_WALL_HIT) failed!\n");
				if(gSoundError == 8)
					DebugPrint("XPlaySound -- halting further error messages\n");
			} 
		}
		if(ball.y >= Height - ball.height) {
			ball.dy = -fabs(ball.dy);	//bounce off teh bottom
			if (!XPlaySound(PONG_BALL_WALL_HIT)) {
				gSoundError++;
				if(gSoundError <= 8)
					DebugPrint("XPlaySound(PONG_BALL_WALL_HIT) failed!\n");
				if(gSoundError == 8)
					DebugPrint("XPlaySound -- halting further error messages\n");
			}
		}

		if(ball.x < 0)						//if ball is off the left edge
		{
			win(1);
		}

		if(ball.x >= Width - ball.width - 1)	//iff the ball is off the right edge
		{
			win(0);
		}

		//move the ball
		ball.x += ball.dx;	
		ball.y += ball.dy;

		//bounce off player 1's paddle
		if(ball.x <= p[0].x + p[0].width && ball.x + ball.width >= p[0].x
			&& ball.y <= p[0].y + p[0].height && ball.y + ball.height >= p[0].y)
		{
			ball.dx = fabs(ball.dx);			//change x direction
			ball.dx += BallSpeed / 20;		//speed up the ball a little
			if(ball.dx > p[0].width) ball.dx = p[0].width;	//but not too fast...
			
			//add some "spin"
			ball.dy += BallSpeed * pdy[0] / 4;
			if (!XPlaySound(PONG_BALL_PADDLE_HIT)) {
				gSoundError++;
				if(gSoundError <= 8)
					DebugPrint("XPlaySound(PONG_BALL_PADDLE_HIT) failed!\n");
				if(gSoundError == 8)
					DebugPrint("XPlaySound -- halting further error messages\n");
			}
		}

		//bounce off player 2's paddle
		if(ball.x <= p[1].x + p[1].width && ball.x + ball.width >= p[1].x
			&& ball.y <= p[1].y + p[1].height && ball.y + ball.height >= p[1].y) 
		{
			ball.dx = -fabs(ball.dx);			             //change x direction
			ball.dx -= BallSpeed / 20;		                 //speed up the ball
			if(-ball.dx > p[1].width) ball.dx = -p[1].width; //but not too fast (you have to be able to hit it!

			//add spin
			ball.dy += BallSpeed * pdy[1] / 4;
			if (!XPlaySound(PONG_BALL_PADDLE_HIT)) {
				gSoundError++;
				if(gSoundError <= 8)
					DebugPrint("XPlaySound(PONG_BALL_PADDLE_HIT) failed!\n");
				if(gSoundError == 8)
					DebugPrint("XPlaySound -- halting further error messages\n");
			}
		}

		DrawStuff(0);	//display everything (don't copy the buffer to the screen yet though)
		break;

	case STATUS_BOOT:
		//initialization stuff...
		{
			BUTTONS ball;
			ball.all = bLTS_UP_PRESSED;
			pongcommands.RegisterControl(ball, MoveUp, 0);		//left thumb stick up = move up
			ball.all = bRTS_UP_PRESSED;
			pongcommands.RegisterControl(ball, MoveUp, 1);		//right thumb stick up = move up
			ball.all = bLTS_DN_PRESSED;
			pongcommands.RegisterControl(ball, MoveDown, 0);	//...
			ball.all = bRTS_DN_PRESSED;
			pongcommands.RegisterControl(ball, MoveDown, 1);
		}

		if(!InitSound()) {
			DebugPrint("InitSound failed!\n");
		}

		TscInit(0);

		break;

	case STATUS_ENTER:
		//initialize player locations, ball locations, etc
		p[0].y = p[1].y = Height / 2 - 50;
		p[0].x = 0;
		p[1].x = Width - 8;
		ball.x = Width * .75; ball.y = Height * .9; ball.dx = -BallSpeed; ball.dy = BallSpeed;
		break;

	case STATUS_LEAVE:
		break;

	case STATUS_QUIT:
		if(!KillSound()) {
			DebugPrint("KillSound failed!\n");
		}
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\xsound.cpp ===
#define INITGUID
#include <xtl.h>
#include <waveldr.h>
#include "xsound.h"

typedef struct {
	int num;
	LPDIRECTSOUNDBUFFER* buffers;
} SOUNDBUFFER;

class CXsound : public IXsound {
public:
	SOUNDBUFFER sb;
};

DEFINE_GUID(GUID_NULL, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0, 0x0);

//LPDIRECTSOUNDBUFFER g_apSoundBuffers[] = { NULL, NULL, NULL, NULL };




HRESULT
CreateBufferFromFile
(
    LPDIRECTSOUND           pDirectSound,
    LPCSTR                  pszFile,
    DWORD                   dwFlags,
    LPDIRECTSOUNDBUFFER *   ppBuffer
)
{
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    CWaveFile               WaveFile;
    WAVEFORMATEX            wfx;
    DWORD                   dwDuration;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    DWORD                   dwLockSize;
    HRESULT                 hr;
    
    hr = WaveFile.Open( pszFile );

    // Get the file format
    if(SUCCEEDED(hr))
    {   
        hr = WaveFile.GetFormat(&wfx, sizeof(wfx), NULL);
    }

    // Get the file data size
    if(SUCCEEDED(hr))
    {   
        hr = WaveFile.GetDuration(&dwDuration);
    }

    // Create the sound buffer
    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));
        
        dsbd.dwSize = sizeof(dsbd);
        dsbd.dwFlags = dwFlags;
        dsbd.dwBufferBytes = dwDuration;
        dsbd.lpwfxFormat = &wfx;

        if(pDirectSound)
        {
            hr = pDirectSound->CreateSoundBuffer(&dsbd, &pBuffer, NULL);
        }
        else
        {

#ifdef    SILVER
            hr = DirectSoundCreateBuffer(NULL, &dsbd, &pBuffer, NULL);
#else  // SILVER
			hr = DirectSoundCreateBuffer( &dsbd, &pBuffer );
#endif // SILVER
        }
    }

    // Read audio data
    if(SUCCEEDED(hr))
    {

        hr = pBuffer->Lock(0, 0, &pvLock, &dwLockSize, NULL, NULL, DSBLOCK_ENTIREBUFFER);
    }

    if(SUCCEEDED(hr))
    {

        hr = WaveFile.ReadSample(0, pvLock, dwLockSize, NULL);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else if(pBuffer)
    {
        pBuffer->Release();
    }

    return hr;
}

bool IXsound::InitSound( CHAR** sounds, IXsound** ixsound) 
{
	HRESULT hr = S_OK;
//	_asm int 3;
	if(!ixsound) return false;
	*ixsound = 0;
	ULONG max, i;

	CXsound* cxsound = new CXsound;
	if(!cxsound) return false;

	for (max = 0; sounds[max]; max++ ) {
	}

	cxsound->sb.num = max;
	cxsound->sb.buffers = new LPDIRECTSOUNDBUFFER [max];

	for(i = 0; i < max; i++) {
		hr = CreateBufferFromFile( NULL, sounds[i], 0, &(cxsound->sb.buffers[i]) );

		if ( FAILED( hr ) )
			return false;
	}

	*ixsound = (IXsound*)cxsound;
	return true;
}

IXsound::~IXsound() 
{
	for ( ULONG i = 0; i < 4; i++ ) {
		if (((CXsound*)this)->sb.buffers[i]) {
			((CXsound*)this)->sb.buffers[i]->Release();
		}
	}
	delete[] ((CXsound*)this)->sb.buffers;
}

bool IXsound::XPlaySound(UINT sound) {
	CXsound * cxsound = (CXsound*)this;

	if ( NULL == cxsound->sb.buffers[sound])
		return false;

	HRESULT hr = cxsound->sb.buffers[sound]->SetCurrentPosition( 0 );

	if ( FAILED( hr ) )
		return false;
	
	hr = cxsound->sb.buffers[sound]->Play(0, 0, 0);

	if ( FAILED( hr ) )
		return false;

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\lib\log.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    log.cpp

Abstract:

    logging functions for CPX

Author:

    Jason Gould (a-jasgou) May 2000

--*/

#include <stdio.h>
#include <xtl.h>
#include <stdarg.h>
#include <time.h>
#include "log.h"

DWORD gPosition = 0;

extern "C" ULONG DebugPrint(PCHAR Format, ...);	//prints stuff to the debugger computer

//*********Global Log variables******************************************************
#ifdef _UseCreateFile_
	static HANDLE f;			//or the handle, if we use CreateFile
#else
	static FILE * f;			//the file pointer used in logging
#endif

static CHAR gFileName[256] = "t:\\cpxlog.log";

/*************************************************************************************
Function:   logInit
Purpose:	Begin Logging, using specified or default file
Params:     file --- pointer to the string that holds the name of the file to log to
			If file is NULL, the file C:\winnt\xboxtest\cpxlog.log" is used instead.
Return:     zero if it failed, non-zero if it worked
*************************************************************************************/
UINT logInit(
	OPTIONAL IN CHAR * file)
{
	DebugPrint("File = 0x%08x\n", file);
	if(file == NULL){
		sprintf(gFileName, "t:\\cpxlog.log");
	} else {
		sprintf(gFileName, "%s", file);
	}

	DebugPrint("LogInit... opening %s.\n", gFileName);

	
	#ifdef _UseCreateFile_
		BOOL TryAgain = TRUE;
tryagain:
		f = CreateFile(gFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL); 

		if(f==INVALID_HANDLE_VALUE)
		{
			int err = GetLastError();
            DebugPrint("CreateFile couldn't open '%s'! GetLastError: %d\n", gFileName, err);
			if(err == 1392) {// weird / corrupted file that happens a lot...
				if(!DeleteFile(gFileName)) {
					DebugPrint("DeleteFile(\"%s\") failed, GetLastError: %d\n", gFileName, GetLastError());
				}
				if(TryAgain) {
					DebugPrint("Trying again...");
					TryAgain = FALSE;
					goto tryagain;
				}
			}

			return 0;
		} else {
			DebugPrint("Createfile opened '%s' correctly!\n", gFileName);
			if(!~SetFilePointer(f, 0, 0, FILE_END))	{
				DebugPrint("SetFilePointer failed! Error %d\n", GetLastError());
			}
		}
	#else
		//	f = fopen(file, "a+");
		f = fopen(gFileName, "a+");
		if(f == NULL)
		{
			DebugPrint("fopen Couldn't open '%s'!  GetLastError: %d\n", gFileName, GetLastError());
			return 0;
		} else {
			DebugPrint("fopen opened '%s' correctly!\n", gFileName);
		}
	#endif
	CHAR timbuf[64];
	_strtime(timbuf);
	DebugPrint("Control Panel X\n");
	DebugPrint("\n--- Beginning log at %s", timbuf);
	_strdate(timbuf);
	DebugPrint(" on %s ---\n\n", timbuf);
	//DebugPrint("]Test...\n");
	return (UINT)f;
}


/*************************************************************************************
Function:   logDeinit
Purpose:	End logging, close the log file, etc.
Params:     none
Return:     none
*************************************************************************************/
VOID logDeinit()
{
	CHAR timbuf[64];
	_strtime(timbuf);
	DebugPrint("\n --- Closing log at %s", timbuf);
	_strdate(timbuf);
	DebugPrint(" on %s ---\n\n", timbuf);
	#ifdef _UseCreateFile_
		CloseHandle(f);
	#else
		fclose(f);
	#endif
}


/* we shouldn't need this now...
#ifdef UNICODE
#define _vftprintf(stream, format, argptr) vfwprintf(stream, format, argptr)
#else
#define _vftprintf(stream, format, argptr) vfprintf(stream, format, argptr)
#endif
*/


/*************************************************************************************
Function:   logLog
Purpose:	Log something!
Params:     str --- the WIDE_CHAR formatted string to log
			... --- the optional params for the formatted string
Notes:		If the first char of str is ']', logLog will print the date and time to 
			log file
Return:     none
*************************************************************************************/
unsigned long __stdcall w(void* buf)
{
	#ifdef _UseCreateFile_
		WriteFile(f, ((CHAR*)buf)+4, *(int*)buf * 2, (DWORD*)buf, 0);
	#else
		fwprintf(f, ((CHAR*)buf)+4);
	#endif

	delete[] buf;
	return 0;
}

UINT logLog(const CHAR * str, ...)
{
	CHAR* buf = new CHAR[1024];
	DWORD length;

	va_list v;
	va_start(v, str);

	if(!f) {
		logInit(NULL);
	}

	*(int*)buf = vsprintf(buf+4, str, v);

	CreateThread(0,0,w,buf,0,0);

	va_end (v);
	return 0;
}

/*************************************************************************************
Function:   logLogAndDump
Purpose:	Log something, and dump it to the debugger
Params:     str --- the WIDE_CHAR formatted string to log
			... --- the optional params for the formatted string
Notes:		If the first char of str is ']', logLog will print the date and time to 
			log file (and not the ']',
Return:     none
*************************************************************************************/
UINT logLogAndDump(const CHAR * str, ...)
{
	CHAR buf[1024];
	DWORD length;

	va_list v;
	va_start(v, str);

	if(!f) {
		logInit(NULL);
	}

	if(str[0] == ']') {		//secret code... display data & time also
		CHAR timbuf[64];
		_strdate(timbuf);
		logLog("%ls ", timbuf);
		_strtime(timbuf);
		logLog("%ls ", timbuf);
		str++;
	} 

	length = vsprintf(buf, str, v);
		DebugPrint("%s", buf);

	#ifdef _UseCreateFile_
		WriteFile(f, buf, length * 2, &length, 0);
	#else
		fprintf(f, buf);
	#endif

	va_end (v);
	return 0;
}


/*************************************************************************************
Function:   logDumpToDebug
Purpose:	dump the log file to the debugger, clear the log file
Params:     none 
Return:     none
*************************************************************************************/
void logDumpToDebug()
{
	CHAR buf[256];
	logDeinit();

	#ifdef _UseCreateFile_
		DWORD length;
		f = CreateFile(gFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL); 
		DebugPrint("\n\n\n");
		do {
			ReadFile(f, buf, sizeof(buf) - 2, &length, 0);
			buf[length / sizeof(buf[0])] = '\0';
			DebugPrint("%s", buf);
		} while (length);
		DebugPrint("\n\n\n");
		CloseHandle(f);
		f=NULL;
//	logInit(NULL);	
	#else //we're trying fopen instead...
		f = fopen(gFileName, "r");
		DebugPrint("\n\n\n");
		
		while(!feof(f)) {
			fgets(buf, 255, f);
			DebugPrint("%s", buf);
		}
	
		DebugPrint("\n\n\n");
		fclose(f);
		f=NULL;
//	logInit(NULL);	
	#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\muprod\muprod.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dukeprod.cpp

Abstract:

    initializes all global variables, contains main loop, init, and stuff for duke production test

Author:

    Jason Gould (jgould) Aug 2000

--*/

#include "xtl.h"
#include <stdio.h>
#include "muprod.h"
//#include "ccl.h"
#include "draw.h"
#include "Tsc.h"

#define MAX_MUS 32

BOXSTATUS gMuStatus[MAX_MUS];

/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void init()
{
	int i;

	DWORD dwRet;
	DWORD insert;

    DebugPrint("Welcome to MU Production Test: Built on %s at %s\n", __DATE__,__TIME__);

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

	drInit();

	TscInit(0);

	DebugPrint("Getting MU devices...\n");
	insert = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);

	for(i = 0; i < MAX_MUS; i++) {
		if(insert & (1 << i)) {
			gMuStatus[i] = testme;
		} else {
			gMuStatus[i] = notyet;
		}
	}

	DebugPrint("Done with initialization!\n");
}

void CheckMus()
{
	DWORD insert, remove;
	int i;
	if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &insert, &remove)) {
		for (i = 0; i < MAX_MUS; i++) {
			if(remove & (1 << i)) { 
				gMuStatus[i] = notyet;
			}

			if(insert & (1 << i)) {
				gMuStatus[i] = testme;
			}
		}
	}
}

/*************************************************************************************
Function:	deinit
Purpose:	de-initialize all cpx stuff (NONE, since we never should quit!)
Params:		none
Out:		un-registers the callbacks for controlpads and MUs, tells all cpx modes to quit
Notes:		We shouldn't ever go here, since xbox only has one process, & this is it...
*************************************************************************************/
void deinit()
{
	DebugPrint("Quitting???? ...");

	drDeinit();

	DebugPrint("Deinit is finished.\n");

	_asm int 3;
}


/*************************************************************************************
Function:	wWinMain (...)
Purpose:	the entry-point of cpx. Calls init, does the main loop, then de-inits
Params:		irrelevant
Notes:		until d3d is ported, it can't display the console...
*************************************************************************************/
//int __cdecl main(){return 0;}
//DWORD WINAPI TestMain()


BOXSTATUS test(int port, int slot, int &BB1, int &BB2, int &BB3)
{
	__int64 tim;
	CHAR drive;
	BOXSTATUS overall = passed;
	int temp;

    if(failed == LowLevelTest(port, slot, BB1, BB2, BB3))
    {
        overall = failed;
		goto nothing;
    }

	if(failed == FormatTest(port, slot)) {
		overall = failed;
		goto nothing;
	}

	if(failed == VerifyTest(port, slot)) {
		overall = failed;
		goto nothing;
	}

	temp = XMountMU(port, slot, &drive);
	DebugPrint("XMountMU: %d -- ", temp);
	DebugPrint("Drive: %c\n", drive);
	if(temp != 0) {
		DebugPrint("XMountMU failed: 0x%x\n", GetLastError());
		overall = failed;
		goto nothing;
	}

	Sleep(1000);

	if(failed == CountSectorWriteTest(drive)) {
		DebugPrint("CountSectorWriteTest(%c:) failed.\n", drive);
		overall = failed;
		goto unmount;
	}

	Sleep(1000);

	if(failed == WriteReadTest(drive)) {
		DebugPrint("WriteReadTest(%c:) failed.\n", drive);
		overall = failed;
		goto unmount;
	}


	overall = passed;

unmount:
	temp = XUnmountMU(port, slot);
	DebugPrint("XUnmountMU: %d\n", temp);
	if(temp != 0) {
		overall = failed;
	}


	if(failed == FormatTest(port, slot)) {
		overall = failed;
		goto nothing;
	}

	if(failed == VerifyTest(port, slot)) {
		overall = failed;
		goto nothing;
	}




nothing:
	return overall;
}

void __cdecl main()
{
//	_asm int 3;

	int i,t,p,f,BB1 = 0,BB2 = 0, BB3 = 0;
	init();
	int port = 0, slot = 0;

	Sleep(16);

	drCls();
	drPrintf(0,0,L"Xbox MU Test Version 1.09 - MU ASIC!");
	drShowScreen();

	while(1) //loop until we're supposed to quit...
	{
		CheckMus();
		for(i = 0; i < MAX_MUS; i++) {
			port = i &  15;
			slot = i < 16 ? 0 : 1;

			if(gMuStatus[i] == testme) {
						DebugPrint("Testing MU at port %d, slot %d\n", port, slot);

						drCls();
						drPrintf(0,0,L"Xbox MU Test Version 1.09 - MU ASIC!");
						drPrintf(0,20,L"Running test...");
						drShowScreen();
						gMuStatus[i] = test(port, slot, BB1, BB2, BB3);
						drCls();
						if(gMuStatus[i] == passed) {
							DebugPrint("Test passed.\n");
							drQuad(250, 350, 0xff00ff00, 550,  50, 0xff00ff00, 600, 100, 0xff00ff00, 300, 400, 0xff00ff00);
							drQuad(250, 450, 0xff00ff00, 300, 400, 0xff00ff00, 150, 250, 0xff00ff00, 100, 300, 0xff00ff00);
						} else {
							DebugPrint("Test failed.\n");
							drQuad(200, 400, 0xffff0000, 550,  50, 0xffff0000, 600, 100, 0xffff0000, 250, 450, 0xffff0000);
							drQuad(600, 400, 0xffff0000, 250,  50, 0xffff0000, 200, 100, 0xffff0000, 550, 450, 0xffff0000);
						}
						drPrintf(0,20,L"First bad block count   %d", BB1);
						drPrintf(0,40,L"Second bad block count  %d", BB2);
						drPrintf(0,60,L"Third bad block count   %d", BB3);
						drShowScreen();
			}
		}
	}

	//we should theoretically never get here on xbox......
	deinit();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\muprod\mp.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <stdio.h>
#include <xtl.h>
extern "C" {
#include <ntos.h>
#include <xapip.h>  //private XAPI methods for low-level tests
}
#include "muprod.h"


// So that we do not need to include mu.h.
// That was causing some problems.  Obviously we need to keep these current.

#define MU_VSC_GET_BAD_BLOCK_TABLE   0
#define MU_VSC_MEMORY_TEST           1
#define MU_IOCTL_GET_BAD_BLOCK_TABLE\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_GET_BAD_BLOCK_TABLE, METHOD_NEITHER, FILE_ANY_ACCESS)
#define MU_IOCTL_MEMORY_TEST\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_MEMORY_TEST, METHOD_NEITHER, FILE_ANY_ACCESS)


BOXSTATUS LowLevelTest(int port, int slot, int &BB1, int &BB2, int &BB3)
{
    CHAR device[32]; // (mu port numbers are hex values, 1 based)
    NTSTATUS status;
    HANDLE hVolume;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK statusBlock;
    OCHAR         deviceNameBuffer[64];
    OBJECT_STRING deviceName;
    USHORT  BadBlockTable[16];
    USHORT  BadBlockCount;
    int i;

    //
    //  Assume the test failed, until it passes.
    //
    BOXSTATUS boxStatus = failed;

    //
    // Initialize the device name buffer
    //

    deviceName.Buffer = deviceNameBuffer;
    deviceName.Length = 0;
    deviceName.MaximumLength = 63;

    //
    //  Tell the MU driver to expose a device object
    //
    status = MU_CreateDeviceObject(port, slot, &deviceName);
    if(NT_ERROR(status))
    {
        DebugPrint("Couldn't create device object\n");
        goto close_nothing;
    }
    
    //
    //  Open the device object in raw mode.
    //
    InitializeObjectAttributes(
        &oa,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);
    status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_ALL,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't open device object\n");
        goto close_mu_do;
    }


    //
    //  MU_IOCTL_GET_BAD_BLOCK_TABLE
    //
    DebugPrint("Getting bad block table\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_GET_BAD_BLOCK_TABLE,
                                   NULL,
                                   0,
                                   &BadBlockTable,
                                   sizeof(BadBlockTable)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    
    //
    //  Count the bad blocks if it exceeds ten fail
    //
    BadBlockCount = 0;
    for(i=0; i<16; i++)
    {
        DebugPrint("BadBlockTable[%d] = %d\n", i, (ULONG)BadBlockTable[i]);
        if(BadBlockTable[i]!=0xFFFF)
        {
            BadBlockCount++;
        }
    }
    if(BadBlockCount > 10)
    {
        DebugPrint("%d bad blocks found - test fails.\n", (ULONG)BadBlockCount);
        goto close_everything;
    }
    DebugPrint("%d bad blocks found - within specification.\n", (ULONG)BadBlockCount);
	BB1 = (ULONG)BadBlockCount;
	
	
    //
    //  MU_IOCTL_MEMORY_TEST
    //
    DebugPrint("Performing Memory Test - can take 30 seconds or more\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_MEMORY_TEST,
                                   NULL,
                                   0,
                                   &BadBlockCount,
                                   sizeof(BadBlockCount)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    //
    //  Check bad blocks
    //
    if(BadBlockCount > 10)
    {
        DebugPrint("Memory test found %d bad blocks - test fails.\n", (ULONG)BadBlockCount);
        goto close_everything;
    }
    DebugPrint("Memory Test found %d bad blocks - within specification.\n", (ULONG)BadBlockCount);
	BB2 = (ULONG)BadBlockCount;


    //
    //  MU_IOCTL_GET_BAD_BLOCK_TABLE
    //
    DebugPrint("Getting bad block table (second time)\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_GET_BAD_BLOCK_TABLE,
                                   NULL,
                                   0,
                                   &BadBlockTable,
                                   sizeof(BadBlockTable)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    //
    //  Count the bad blocks if it exceeds ten fail
    //
    BadBlockCount = 0;
    for(i=0; i<16; i++)
    {
        DebugPrint("BadBlockTable[%d] = %d\n", i, (ULONG)BadBlockTable[i]);
        if(BadBlockTable[i]!=0xFFFF)
        {
            BadBlockCount++;
        }
    }
    if(BadBlockCount > 10)
    {
        DebugPrint("%d bad blocks found - test fails.\n", (ULONG)BadBlockCount);
        goto close_everything;
    }
    DebugPrint("%d bad blocks found - within specification.\n", (ULONG)BadBlockCount);
	BB3 = (ULONG)BadBlockCount;

    //
    //  If we are here, the test passed.
    //
    boxStatus = passed;

close_everything:
    NtClose(hVolume);
close_mu_do:
    MU_CloseDeviceObject(port, slot);
close_nothing:

	return boxStatus;
}

BOXSTATUS FormatTest(int port, int slot)
{
    CHAR device[32]; // (mu port numbers are hex values, 1 based)
    CHAR deviceNameBuffer[64];
    STRING deviceName;

	//
    //  Assume the test failed, until it passes.
    //
    BOXSTATUS boxStatus = failed;
    
    //
    // Initialize the device name buffer
    //
    deviceName.Buffer = deviceNameBuffer;
    deviceName.Length = 0;
    deviceName.MaximumLength = 63;

    DebugPrint("Formatting Device\n");
    NTSTATUS status = MU_CreateDeviceObject(port, slot, &deviceName);
    if(NT_ERROR(status))
    {
        DebugPrint("Couldn't create device object\n");
        goto do_nothing;
    }

    if(XapiFormatFATVolume(&deviceName)) {
		DebugPrint("Format succeeded\n");
        boxStatus = passed;
	} else {
		DebugPrint("Format failed (ec: %lu)\n", GetLastError());
	}

	MU_CloseDeviceObject(port, slot);

do_nothing:
   
    return boxStatus;
}

BOXSTATUS VerifyTest(int port, int slot)
{
	return passed;
}

char* FindLastChar(char* buf, char match) {
	char*c;
	for(c = NULL; ; buf++) {
		if(*buf == match) c = buf;
		if(!*buf) return c;
	}
}

void CopyBadFile(CHAR* badmufile)
{
	if(!CopyFile(badmufile, "T:\\media\\muprod\\BadMuFile.txt", FALSE)) {
		DebugPrint("couldn't copy bad file %s back to t:\\media\\muprod\\badmufile.txt! Error %d\n", badmufile, GetLastError());
	} else {
		DebugPrint("Copied bad mu file %s to t:\\media\\murpod\\badmufile.txt\n");
	}
}

#ifdef GETMUWRITECOUNTS
LONG MU_GetWriteCount();
ULONG MU_GetWriteSize(LONG count);
ULONG MU_GetWriteBlock(LONG count);
#endif

void LogMuWrites(int start, int end, bool startplus1 = true)
{
#ifdef GETMUWRITECOUNTS
	int i;
	DebugPrint("\nTotal Writes: %d\n", end - start - startplus1 + 1);
	for(i = start+startplus1; i <= end; i++) {
		DebugPrint("Write: %d bytes, to block 0x%08x\n", MU_GetWriteSize(i), MU_GetWriteBlock(i));
	}
	DebugPrint("\n");
#endif
}

#define logmu(_title_, code) sc = MU_GetWriteCount(); DebugPrint _title_; code; Sleep(5000); LogMuWrites(sc, MU_GetWriteCount());
#define checkhandle(h) if(INVALID_HANDLE_VALUE == h) { DebugPrint("CreateFile failed, line %d, error %d\n", __LINE__, GetLastError()); goto nothing; }
#define check(r) if(0 == r) { DebugPrint("something failed, line %d, error %d\n", __LINE__, GetLastError()); goto closehandle; }

BOXSTATUS CountSectorWriteTest(CHAR drive)
{

	#ifdef _DO_MU_BLOCK_WRITE_COUNT_
		CHAR GameDir[80] = {drive, ":\\SaveGame"};
		CHAR GameDir2[80] = {drive, ":\\SaveGam2"};
		CHAR File1[80];
		CHAR File2[80];
		CHAR File3[80];
		CHAR File1a[80];
		int i;
		int sc;
		HANDLE h;
		int temp;
		ULONG temp2;
		char * tempbuf;
		
		DebugPrint("CountSectorWriteTest\n\n\n");
		sprintf(File1, "%s\\File1", GameDir);
		sprintf(File2, "%s\\File2", GameDir);
		sprintf(File3, "%s\\File3", GameDir);
		sprintf(File1a, "%s\\File1", GameDir2);

	//CreateDirectory \SaveGame
		logmu(("CreateDirectory(%S, 0): ", GameDir), 
			temp = CreateDirectory(GameDir, 0);
		);
		check(temp);
		
	//Create File \SaveGame\File1
		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//Write 5 bytes to File1
		logmu(("WriteFile 5 to file1"), 
			temp = WriteFile(h, "Narf", 5, &temp2, 0);
		);
		check(temp);
		
	//Close File1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		tempbuf = new char[17000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 16000 bytes!\n"); goto nothing;}

	//Create File \SaveGame\File2
		logmu(("CreateFile(%s, ...)", File2), 
			h = CreateFile(File2, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//Write 16000 bytes to File2
		logmu(("WriteFile 17000 to file2"), 
			temp = WriteFile(h, tempbuf, 17000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//Close File2
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		
	//Create File \SaveGame\File1

		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//append 100 bytes to file1
		tempbuf = new char[100];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 100 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 100 to file1"), 
			temp = WriteFile(h, tempbuf, 100, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file 1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		
	//Create File \SaveGame\File1

		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//append 24000 bytes to file1
		tempbuf = new char[24000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 24000 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 24000 to file1"), 
			temp = WriteFile(h, tempbuf, 24000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);

		
	//delete file2
		logmu(("Deletefile(file2)"),
			temp = DeleteFile(File2);
		);
		check(temp);

	//create file3
		logmu(("CreateFile(%S, ...)", File3), 
			h = CreateFile(File3, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//write 24000 bytes to file3
		tempbuf = new char[7100000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 7100000 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 7100000 to file3"), 
			temp = WriteFile(h, tempbuf, 7100000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file 3
		logmu(("CloseHandle(h)"), 
			temp = CloseHandle(h);
		);
		check(temp);

	//CreateDirectory \SaveGam2
		logmu(("CreateDirectory(%S, 0): ", GameDir2),
			temp = CreateDirectory(GameDir2, 0);
		);
		check(temp);

	//CopyFile(savegame\file1 -> savegam2\file1)
		logmu(("CopyFile(savegame\\file1 -> savegam2\\file1"), 
			temp = CopyFile(File1, File1a, TRUE);
		);
		check(temp);

		logmu(("Delete File3"),
			temp = DeleteFile(File3);
		);
		check(temp);
		logmu(("Delete File1"),
			temp = DeleteFile(File1);
		);
		check(temp);
		logmu(("Delete File1a"),
			temp = DeleteFile(File1a);
		);
		check(temp);
		logmu(("Remove directory1"),
			RemoveDirectory(GameDir);
		);
		check(temp);
		logmu(("Remove directory2"),
			RemoveDirectory(GameDir2);
		);
		check(temp);

		goto nothing;
	closehandle:
		logmu(("CloseHandle(h)"), 
			if(h != INVALID_HANDLE_VALUE) CloseHandle(h);
		);

	nothing:

	#endif //defined(_DO_MU_BLOCK_WRITE_COUNT_)
	return passed;
}

BOXSTATUS WriteReadTest(CHAR drive)
{
	CHAR   buf[1024];
	CHAR  buf2[1024];
	FILE* f;
	DWORD s1;
	DWORD s2;
	DWORD temp;
	int pass;

	char* b1;
	char* b2;

	HANDLE h1, h2;

	sprintf(buf, "%c:\\*.*", drive);
	DeleteFile(buf);

	f = fopen("t:\\media\\muprod\\muprod.ini", "r");
	if(f == NULL) {
		DebugPrint("couldn't open t:\\muprod.ini, == c:\\tdata\\{00000~1\\muprod.ini\n");
		return failed;
	}

	pass = 0;
	while(1 == fscanf(f, "%s", buf)) {
		pass++;

		DebugPrint("Filename I am copying FROM is: %s\n", buf);

		sprintf(buf2, "%c:\\%s", drive, FindLastChar(buf, '\\') + 1);
		DebugPrint("Filename I am copying TO is: %s\n", buf2);

		h1 = CreateFile(buf, GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if(h1)
		{
			s1 = GetFileSize(h1, NULL);
			DebugPrint("Before copy, source file (%s) is %d bytes\n", buf, s1);
			CloseHandle(h1);
		}

		if(!CopyFile(buf, buf2, FALSE)) {
			DebugPrint("CopyFile(%s, %s, FALSE) failed: %d (pass %d)\n", buf, buf2, GetLastError(), pass);
//			return failed;
		}
		
		h1 = CreateFile(buf, GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if(h1 == NULL) {
			DebugPrint("Couldn't open %s!!! error %d (pass %d)", buf, GetLastError(), pass);
			return failed;
		}

		h2 = CreateFile(buf2,GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if(h2 == NULL) {
			DebugPrint("Couldn't open %s!!! error %d (pass %d)", buf2, GetLastError(), pass);
			CloseHandle(h1);
			return failed;
		}

		s1 = GetFileSize(h1, NULL);
		DebugPrint("File I am copying FROM is %d bytes\n", s1);
		s2 = GetFileSize(h2, NULL);
		DebugPrint("File I am copying TO is %d bytes\n", s2);
		if(s1!= s2) {
			DebugPrint("GetFileSize(%s): %d, GetFileSize(%s): %d. BAD! (pass %d)\n", buf, s1, buf2, s2, pass);
			CopyBadFile(buf2);
			CloseHandle(h1);
			CloseHandle(h2);
			return failed;
		}
/*
		b1 = new char[s1];
		if(b1 == NULL) {
			DebugPrint("new failed! (pass %d)\n", pass);
			CloseHandle(h1);
			CloseHandle(h2);
			return failed;
		}
		b2 = new char[s1];
		if(b2 == NULL) {
			DebugPrint("new failed! (pass %d)\n", pass);
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			return failed;
		}

		if(FALSE == ReadFile(h1, b1, s1, &temp, 0)) {
			DebugPrint("ReadFile(h1, .., %d, .., 0) failed! Error %d (pass %d)\n", s1, GetLastError(), pass);
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			delete[] b2;
			return failed;
		}
		if(FALSE == ReadFile(h2, b2, s1, &temp, 0)) {
			DebugPrint("ReadFile(h2, .., %d, .., 0) failed! Error %d (pass %d)\n", s1, GetLastError(), pass);
			CopyBadFile(buf2);
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			delete[] b2;
			return failed;
		}
		if(memcmp(b1, b2, s1)) {
			DebugPrint("%s is NOT the same on the mu! (pass %d)\n", buf, pass);
			CopyBadFile(buf2);
			HANDLE h3 = CreateFile("t:\\media\\muprod\\BadMuFile2.txt", GENERIC_READ | GENERIC_WRITE, 0,0,0,CREATE_ALWAYS,0);
			if(!h3) {
				DebugPrint("Couldn't open t:\\media\\muprod\\badmufile2.txt!!! Error %d\n", GetLastError());
			} else {
				if(FALSE == WriteFile(h3, b2, s1, &temp, 0)) {
					DebugPrint("Couldn't write to t:\\media\\muprod\\badmufile2.txt!!! Error %d\n", GetLastError());
				}
				CloseHandle(h3);
			}
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			delete[] b2;
			return failed;
		}
*/		CloseHandle(h1);
		CloseHandle(h2);
//		delete[] b1;
//		delete[] b2;
		DebugPrint("WriteRead test pass %d, file %s -> %s successful!\n", pass, buf, buf2);
	}
	return passed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\muprod2\muprod23\muprod.h ===
#ifndef __muprod_h_
#define __muprod_h_

#define MAX_SLOTS XGetPortCount()
//typedef enum {none, tested} padstatus;
typedef enum {notyet, testme, pending, failed, passed} BOXSTATUS;
typedef BOXSTATUS (*BOXFUNC)(int port, int slot);
extern BOXSTATUS gPadStatus[MAX_SLOTS];


typedef enum {lowleveltest,formattest, verifytest, writereadtest, countsectorwritetest, xmountmu,unknowreason} failedreason;
//#include "mp.h"
//Global critical section 

//extern CRITICAL_SECTION criter;
extern HANDLE    hIOMutex; 
 

extern BOXFUNC b[];
//extern deGAMEPAD * gData;

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

#ifdef DOLOWLEVELTESTS
	BOXSTATUS LowLevelTest(int port, int slot, int &BB1, int &BB2, int &BB3);
#endif DOLOWLEVELTESTS
    BOXSTATUS FormatTest(int port, int slot);
	BOXSTATUS VerifyTest(int port, int slot);
	BOXSTATUS WriteReadTest(CHAR drive);
	BOXSTATUS CountSectorWriteTest(CHAR drive);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\muprod2\muprod23\mp.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <stdio.h>
#include <xtl.h>
extern "C" {
#include <ntos.h>
#include <xapip.h>  //private XAPI methods for low-level tests
}
#include "muprod.h"


//CRITICAL_SECTION criter;

// So that we do not need to include mu.h.
// That was causing some problems.  Obviously we need to keep these current.

#define MU_VSC_GET_BAD_BLOCK_TABLE   0
#define MU_VSC_MEMORY_TEST           1
#define MU_IOCTL_GET_BAD_BLOCK_TABLE\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_GET_BAD_BLOCK_TABLE, METHOD_NEITHER, FILE_ANY_ACCESS)
#define MU_IOCTL_MEMORY_TEST\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_MEMORY_TEST, METHOD_NEITHER, FILE_ANY_ACCESS)

#ifdef DOLOWLEVELTESTS
BOXSTATUS LowLevelTest(int port, int slot, int &BB1, int &BB2, int &BB3)
{
    CHAR device[32]; // (mu port numbers are hex values, 1 based)
    NTSTATUS status;
    HANDLE hVolume;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK statusBlock;
    OCHAR         deviceNameBuffer[64];
    OBJECT_STRING deviceName;
    USHORT  BadBlockTable[16];
    USHORT  BadBlockCount;
    int i;

    //
    //  Assume the test failed, until it passes.
    //
    BOXSTATUS boxStatus = failed;

    //
    // Initialize the device name buffer
    //

    deviceName.Buffer = deviceNameBuffer;
    deviceName.Length = 0;
    deviceName.MaximumLength = 63;

    //
    //  Tell the MU driver to expose a device object
    //
    status = MU_CreateDeviceObject(port, slot, &deviceName);
    if(NT_ERROR(status))
    {
        DebugPrint("Couldn't create device object\n");
        goto close_nothing;
    }
    
    //
    //  Open the device object in raw mode.
    //
    InitializeObjectAttributes(
        &oa,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);
    status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_ALL,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't open device object\n");
        goto close_mu_do;
    }


    //
    //  MU_IOCTL_GET_BAD_BLOCK_TABLE
    //
    DebugPrint("Getting bad block table\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_GET_BAD_BLOCK_TABLE,
                                   NULL,
                                   0,
                                   &BadBlockTable,
                                   sizeof(BadBlockTable)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    
    //
    //  Count the bad blocks if it exceeds ten fail
    //
    BadBlockCount = 0;
    for(i=0; i<16; i++)
    {
        DebugPrint("BadBlockTable[%d] = %d\n", i, (ULONG)BadBlockTable[i]);
        if(BadBlockTable[i]!=0xFFFF)
        {
            BadBlockCount++;
        }
    }
    if(BadBlockCount > 10)
    {
        DebugPrint("%d bad blocks found - test fails.\n", (ULONG)BadBlockCount);
		BB1 = (ULONG)BadBlockCount;
        goto close_everything;
    }
    DebugPrint("%d bad blocks found - within specification.\n", (ULONG)BadBlockCount);
	BB1 = (ULONG)BadBlockCount;
	
	
    //
    //  MU_IOCTL_MEMORY_TEST
    //
    DebugPrint("Performing Memory Test - can take 30 seconds or more\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_MEMORY_TEST,
                                   NULL,
                                   0,
                                   &BadBlockCount,
                                   sizeof(BadBlockCount)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    //
    //  Check bad blocks
    //
    if(BadBlockCount > 10)
    {
        DebugPrint("Memory test found %d bad blocks - test fails.\n", (ULONG)BadBlockCount);
        BB2 = (ULONG)BadBlockCount;
        goto close_everything;
    }
    DebugPrint("Memory Test found %d bad blocks - within specification.\n", (ULONG)BadBlockCount);
	BB2 = (ULONG)BadBlockCount;


    //
    //  MU_IOCTL_GET_BAD_BLOCK_TABLE
    //
    DebugPrint("Getting bad block table (second time)\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_GET_BAD_BLOCK_TABLE,
                                   NULL,
                                   0,
                                   &BadBlockTable,
                                   sizeof(BadBlockTable)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    //
    //  Count the bad blocks if it exceeds ten fail
    //
    BadBlockCount = 0;
    for(i=0; i<16; i++)
    {
        DebugPrint("BadBlockTable[%d] = %d\n", i, (ULONG)BadBlockTable[i]);
        if(BadBlockTable[i]!=0xFFFF)
        {
            BadBlockCount++;
        }
    }
    if(BadBlockCount > 10)
    {
        DebugPrint("%d bad blocks found - test fails.\n", (ULONG)BadBlockCount);
		BB3 = (ULONG)BadBlockCount;
        goto close_everything;
    }
    DebugPrint("%d bad blocks found - within specification.\n", (ULONG)BadBlockCount);
	BB3 = (ULONG)BadBlockCount;

    //
    //  If we are here, the test passed.
    //
    boxStatus = passed;

close_everything:
    NtClose(hVolume);
close_mu_do:
    MU_CloseDeviceObject(port, slot);
close_nothing:

	return boxStatus;
}
#endif

BOXSTATUS FormatTest(int port, int slot)
{
    CHAR device[32]; // (mu port numbers are hex values, 1 based)
    CHAR deviceNameBuffer[64];
    STRING deviceName;

	//
    //  Assume the test failed, until it passes.
    //
    BOXSTATUS boxStatus = failed;
    
    //
    // Initialize the device name buffer
    //
    deviceName.Buffer = deviceNameBuffer;
    deviceName.Length = 0;
    deviceName.MaximumLength = 63;

    DebugPrint("Formatting Device\n");
    NTSTATUS status = MU_CreateDeviceObject(port, slot, &deviceName);
    if(NT_ERROR(status))
    {
        DebugPrint("Couldn't create device object\n");
        goto do_nothing;
    }

    if(XapiFormatFATVolume(&deviceName)) {
		DebugPrint("Format succeeded\n");
        boxStatus = passed;
	} else {
		DebugPrint("Format failed (ec: %lu)\n", GetLastError());
	}

	MU_CloseDeviceObject(port, slot);

do_nothing:
   
    return boxStatus;
}

BOXSTATUS VerifyTest(int port, int slot)
{
	return passed;
}

char* FindLastChar(char* buf, char match) {
	char*c;
	for(c = NULL; ; buf++) {
		if(*buf == match) c = buf;
		if(!*buf) return c;
	}
}

void CopyBadFile(CHAR* badmufile)
{
	if(!CopyFile(badmufile, "T:\\media\\muprod\\BadMuFile.txt", FALSE)) {
		DebugPrint("couldn't copy bad file %s back to t:\\media\\muprod\\badmufile.txt! Error %d\n", badmufile, GetLastError());
	} else {
		DebugPrint("Copied bad mu file %s to t:\\media\\murpod\\badmufile.txt\n");
	}
}

#ifdef GETMUWRITECOUNTS
LONG MU_GetWriteCount();
ULONG MU_GetWriteSize(LONG count);
ULONG MU_GetWriteBlock(LONG count);
#endif

void LogMuWrites(int start, int end, bool startplus1 = true)
{
#ifdef GETMUWRITECOUNTS
	int i;
	DebugPrint("\nTotal Writes: %d\n", end - start - startplus1 + 1);
	for(i = start+startplus1; i <= end; i++) {
		DebugPrint("Write: %d bytes, to block 0x%08x\n", MU_GetWriteSize(i), MU_GetWriteBlock(i));
	}
	DebugPrint("\n");
#endif
}

#define logmu(_title_, code) sc = MU_GetWriteCount(); DebugPrint _title_; code; Sleep(5000); LogMuWrites(sc, MU_GetWriteCount());
#define checkhandle(h) if(INVALID_HANDLE_VALUE == h) { DebugPrint("CreateFile failed, line %d, error %d\n", __LINE__, GetLastError()); goto nothing; }
#define check(r) if(0 == r) { DebugPrint("something failed, line %d, error %d\n", __LINE__, GetLastError()); goto closehandle; }

BOXSTATUS CountSectorWriteTest(CHAR drive)
{

	#ifdef _DO_MU_BLOCK_WRITE_COUNT_
		CHAR GameDir[80] = {drive, ":\\SaveGame"};
		CHAR GameDir2[80] = {drive, ":\\SaveGam2"};
		CHAR File1[80];
		CHAR File2[80];
		CHAR File3[80];
		CHAR File1a[80];
		int i;
		int sc;
		HANDLE h;
		int temp;
		ULONG temp2;
		char * tempbuf;
		
		DebugPrint("CountSectorWriteTest\n\n\n");
		sprintf(File1, "%s\\File1", GameDir);
		sprintf(File2, "%s\\File2", GameDir);
		sprintf(File3, "%s\\File3", GameDir);
		sprintf(File1a, "%s\\File1", GameDir2);

	//CreateDirectory \SaveGame
		logmu(("CreateDirectory(%S, 0): ", GameDir), 
			temp = CreateDirectory(GameDir, 0);
		);
		check(temp);
		
	//Create File \SaveGame\File1
		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//Write 5 bytes to File1
		logmu(("WriteFile 5 to file1"), 
			temp = WriteFile(h, "Narf", 5, &temp2, 0);
		);
		check(temp);
		
	//Close File1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		tempbuf = new char[17000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 16000 bytes!\n"); goto nothing;}

	//Create File \SaveGame\File2
		logmu(("CreateFile(%s, ...)", File2), 
			h = CreateFile(File2, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//Write 16000 bytes to File2
		logmu(("WriteFile 17000 to file2"), 
			temp = WriteFile(h, tempbuf, 17000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//Close File2
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		
	//Create File \SaveGame\File1

		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//append 100 bytes to file1
		tempbuf = new char[100];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 100 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 100 to file1"), 
			temp = WriteFile(h, tempbuf, 100, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file 1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		
	//Create File \SaveGame\File1

		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//append 24000 bytes to file1
		tempbuf = new char[24000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 24000 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 24000 to file1"), 
			temp = WriteFile(h, tempbuf, 24000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);

		
	//delete file2
		logmu(("Deletefile(file2)"),
			temp = DeleteFile(File2);
		);
		check(temp);

	//create file3
		logmu(("CreateFile(%S, ...)", File3), 
			h = CreateFile(File3, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//write 24000 bytes to file3
		tempbuf = new char[7100000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 7100000 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 7100000 to file3"), 
			temp = WriteFile(h, tempbuf, 7100000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file 3
		logmu(("CloseHandle(h)"), 
			temp = CloseHandle(h);
		);
		check(temp);

	//CreateDirectory \SaveGam2
		logmu(("CreateDirectory(%S, 0): ", GameDir2),
			temp = CreateDirectory(GameDir2, 0);
		);
		check(temp);

	//CopyFile(savegame\file1 -> savegam2\file1)
		logmu(("CopyFile(savegame\\file1 -> savegam2\\file1"), 
			temp = CopyFile(File1, File1a, TRUE);
		);
		check(temp);

		logmu(("Delete File3"),
			temp = DeleteFile(File3);
		);
		check(temp);
		logmu(("Delete File1"),
			temp = DeleteFile(File1);
		);
		check(temp);
		logmu(("Delete File1a"),
			temp = DeleteFile(File1a);
		);
		check(temp);
		logmu(("Remove directory1"),
			RemoveDirectory(GameDir);
		);
		check(temp);
		logmu(("Remove directory2"),
			RemoveDirectory(GameDir2);
		);
		check(temp);

		goto nothing;
	closehandle:
		logmu(("CloseHandle(h)"), 
			if(h != INVALID_HANDLE_VALUE) CloseHandle(h);
		);

	nothing:

	#endif //defined(_DO_MU_BLOCK_WRITE_COUNT_)
	return passed;
}

BOXSTATUS WriteReadTest(CHAR drive)
{
	CHAR   buf[1024];
	CHAR  buf2[1024];
	FILE* f;
	DWORD s1;
	DWORD s2;
	DWORD temp;
	int pass;

	//InitializeCriticalSection(&criter);


    //EnterCriticalSection(&criter);
    

	char* b1;
	char* b2;

	HANDLE h1, h2;


	sprintf(buf, "%c:\\*.*", drive);
	DeleteFile(buf);

	f = fopen("D:\\media\\muprod\\muprod.ini", "r");
	if(f == NULL) {
		DebugPrint("couldn't open D:\\muprod.ini, == c:\\tdata\\MEDIA\\muprod.ini\n");
		// try T: drive
		f = fopen("T:\\media\\muprod\\muprod.ini", "r");
		if(f == NULL)
		{
			DebugPrint("couldn't open T:\\muprod.ini, == c:\\tdata\\MEDIA\\muprod.ini\n");
			return failed;
		}
	}

	pass = 0;
	while(1 == fscanf(f, "%s", buf)) {
		pass++;

		DebugPrint("Filename I am copying FROM is: %s\n", buf);

		sprintf(buf2, "%c:\\%s", drive, FindLastChar(buf, '\\') + 1);
		DebugPrint("Filename I am copying TO is: %s\n", buf2);

		h1 = CreateFile(buf, GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if((int)h1!=-1)
		{
			s1 = GetFileSize(h1, NULL);
			DebugPrint("Before copy, source file (%s) is %d bytes\n", buf, s1);
			CloseHandle(h1);
		}
		else {
			DebugPrint("Cannot createfile correctly, wrong with files\n");
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			return failed;
		}

		if(!CopyFile(buf, buf2, FALSE)) {
			DebugPrint("CopyFile(%s, %s, FALSE) failed: %d (pass %d)\n", buf, buf2, GetLastError(), pass);
		//	return failed;
		}
		
		h1 = CreateFile(buf, GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if(h1 == NULL) {
			DebugPrint("Couldn't open %s!!! error %d (pass %d)", buf, GetLastError(), pass);
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			return failed;
		}

		h2 = CreateFile(buf2,GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if(h2 == NULL) {
			DebugPrint("Couldn't open %s!!! error %d (pass %d)", buf2, GetLastError(), pass);
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			CloseHandle(h1);
			return failed;
		}

		s1 = GetFileSize(h1, NULL);
		DebugPrint("File I am copying FROM is %d bytes\n", s1);
		s2 = GetFileSize(h2, NULL);
		DebugPrint("File I am copying TO is %d bytes\n", s2);
		if((s1!= s2)||(s1==-1)||(s2==-1)) {
			DebugPrint("GetFileSize(%s): %d, GetFileSize(%s): %d. BAD! (pass %d)\n", buf, s1, buf2, s2, pass);
			CopyBadFile(buf2);
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			CloseHandle(h1);
			CloseHandle(h2);
			return failed;
		}
/*
		b1 = new char[s1];
		if(b1 == NULL) {
			DebugPrint("new failed! (pass %d)\n", pass);
			CloseHandle(h1);
			CloseHandle(h2);
			return failed;
		}
		b2 = new char[s1];
		if(b2 == NULL) {
			DebugPrint("new failed! (pass %d)\n", pass);
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			return failed;
		}

		if(FALSE == ReadFile(h1, b1, s1, &temp, 0)) {
			DebugPrint("ReadFile(h1, .., %d, .., 0) failed! Error %d (pass %d)\n", s1, GetLastError(), pass);
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			delete[] b2;
			return failed;
		}
		if(FALSE == ReadFile(h2, b2, s1, &temp, 0)) {
			DebugPrint("ReadFile(h2, .., %d, .., 0) failed! Error %d (pass %d)\n", s1, GetLastError(), pass);
			CopyBadFile(buf2);
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			delete[] b2;
			return failed;
		}
		if(memcmp(b1, b2, s1)) {
			DebugPrint("%s is NOT the same on the mu! (pass %d)\n", buf, pass);
			CopyBadFile(buf2);
			HANDLE h3 = CreateFile("t:\\media\\muprod\\BadMuFile2.txt", GENERIC_READ | GENERIC_WRITE, 0,0,0,CREATE_ALWAYS,0);
			if(!h3) {
				DebugPrint("Couldn't open t:\\media\\muprod\\badmufile2.txt!!! Error %d\n", GetLastError());
			} else {
				if(FALSE == WriteFile(h3, b2, s1, &temp, 0)) {
					DebugPrint("Couldn't write to t:\\media\\muprod\\badmufile2.txt!!! Error %d\n", GetLastError());
				}
				CloseHandle(h3);
			}
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			delete[] b2;
			return failed;
		}
*/		
		
		CloseHandle(h1);
		CloseHandle(h2);
//		delete[] b1;
//		delete[] b2;
		DebugPrint("WriteRead test pass %d, file %s -> %s successful!\n", pass, buf, buf2);
	}

    if( fclose(f) )   DebugPrint("The file was not closed\n");
	
	//LeaveCriticalSection(&criter);
	
    //DeleteCriticalSection(&criter);

	return passed;
	
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\murw\muprod.h ===
#ifndef __muprod_h_
#define __muprod_h_

//Global variables

//int readfailed=0,writefailed=0,comparefailed=0;




#define MAX_SLOTS XGetPortCount()
//typedef enum {none, tested} padstatus;
typedef enum {notyet, testme, pending, failed, passed} BOXSTATUS;
typedef BOXSTATUS (*BOXFUNC)(int port, int slot);
extern BOXSTATUS gPadStatus[MAX_SLOTS];

//#include "mp.h"

extern BOXFUNC b[];
//extern deGAMEPAD * gData;

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

	BOXSTATUS LowLevelTest(int port, int slot, int &BB1, int &BB2, int &BB3);
    BOXSTATUS FormatTest(int port, int slot);
	BOXSTATUS VerifyTest(int port, int slot);
	BOXSTATUS WriteReadTest(CHAR drive,int &readfailed, int &writefailed, int &comparefailed);
	BOXSTATUS CountSectorWriteTest(CHAR drive);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\muprod\muprod.h ===
#ifndef __muprod_h_
#define __muprod_h_

#define MAX_SLOTS XGetPortCount()
//typedef enum {none, tested} padstatus;
typedef enum {notyet, testme, pending, failed, passed} BOXSTATUS;
typedef BOXSTATUS (*BOXFUNC)(int port, int slot);
extern BOXSTATUS gPadStatus[MAX_SLOTS];

//#include "mp.h"

extern BOXFUNC b[];
//extern deGAMEPAD * gData;

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

	BOXSTATUS LowLevelTest(int port, int slot, int &BB1, int &BB2, int &BB3);
    BOXSTATUS FormatTest(int port, int slot);
	BOXSTATUS VerifyTest(int port, int slot);
	BOXSTATUS WriteReadTest(CHAR drive);
	BOXSTATUS CountSectorWriteTest(CHAR drive);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\murw\murw.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    murw.cpp

Abstract:

     Using muprod.cpp as the base, modified and changed to test MU functions: read, write, 
	  and compere two files to be identical. 

Author:

    Bingdong Li (a-bingli) March 2001

--*/

#include "xtl.h"
//#include <afxpriv.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include "muprod.h"
//#include "ccl.h"
#include "draw.h"
#include "Tsc.h"
#include "tchar.h"

#define MAX_MUS 32

//Global variable 

int removeflag =0;

BOXSTATUS gMuStatus[MAX_MUS];

/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void init()
{
	int i;

	DWORD dwRet;
	DWORD insert;
    
	 
    DebugPrint("Welcome to MU Production Test: Built on %s at %s\n", __DATE__,__TIME__);
	 
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

	drInit();

	TscInit(0);

	DebugPrint("Getting MU devices...\n");
	insert = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);

	for(i = 0; i < MAX_MUS; i++) {
		if(insert & (1 << i)) {
			gMuStatus[i] = testme;
		} else {
			gMuStatus[i] = notyet;
		}
	}

	DebugPrint("Done with initialization!\n");
}

/************************************************************************
*Function: CheckMus() is used to check whether MU is inserted or removed*
*Para: void                                                             *
*Return:void                                                            *
*************************************************************************/
void CheckMus()
{
	DWORD insert, remove;
	int i;
	if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &insert, &remove)) {
		for (i = 0; i < MAX_MUS; i++) {
			if(remove & (1 << i)) { 
				gMuStatus[i] = notyet;
				removeflag=1;
			}

			if(insert & (1 << i)) {
				gMuStatus[i] = testme;
				removeflag=0;
			}
		}
	}
}


/*************************************************************************************
Function:	deinit
Purpose:	de-initialize all cpx stuff (NONE, since we never should quit!)
Params:		none
Out:		un-registers the callbacks for controlpads and MUs, tells all cpx modes to quit
Notes:		We shouldn't ever go here, since xbox only has one process, & this is it...
*************************************************************************************/
void deinit()
{
	DebugPrint("Quitting???? ...");

	drDeinit();

	DebugPrint("Deinit is finished.\n");

	_asm int 3;
}


/*************************************************************************************
Function:	test() is used as stub to call WriteReadTest
Purpose:	the entry-point of WriteReadTest.
Params:		port, slot, bad block, failed flags
Notes:		until d3d is ported, it can't display the console...
*************************************************************************************/
 
BOXSTATUS test(int port, int slot, int &BB1, int &BB2, int &BB3, int &readfailed, int &writefailed, int &comparefailed)
{
	__int64 tim;
	CHAR drive;
	BOXSTATUS overall = passed;
	int temp;

	//Mount MU
	temp = XMountMU(port, slot, &drive);
    if(temp != 0) {
		DebugPrint("XMountMU failed: 0x%x\n", GetLastError());
        readfailed = -1;
		overall = failed;
		goto nothing;
	}

   //Write and Read file to and from the MU
	if(failed == WriteReadTest(drive,readfailed,writefailed,comparefailed)) {
		DebugPrint("WriteReadTest(%c:) failed.\n", drive);
		overall = failed;
		//goto unmount;
	}


//unmount:
	if(temp!=0) goto nothing;

	temp = XUnmountMU(port, slot);
	//DebugPrint("XUnmountMU: %d\n", temp);
	if(temp != 0) {
		overall = failed;
	}

  nothing:
	return overall;
}



/*******************************************************************************
*Main Function
********************************************************************************/


void __cdecl main()
{
//	_asm int 3;

	int i,t,p,f,BB1 = 0,BB2 = 0, BB3 = 0;
	long double counter=0,oldc=0;;

	int readfailed =0,writefailed =0,comparefailed =0;

	init();
	int port = 0, slot = 0;
//char *currtime,*begitime;
//	TCHAR *currenttime;
//	TCHAR *begintime1;
//	TCHAR begintime[256];
//	TCHAR testing[256]= L"testing";

	//CHAR   *begintime1;
	//LPWSTR begintime = new WCHAR;
//	WCHAR begintime[256];


	struct tm *ptr;
	time_t lt;

	Sleep(16);

	while(1) //loop until we're supposed to quit...
	{
		//Print out the title
		drCls();
	    drPrintf(30,30,L"Xbox MU Read_Write_Compare Test!");
	    drShowScreen();

		//initilize as 0, there is on error now
        readfailed=writefailed=0;
		comparefailed=0;
		counter=0;

		CheckMus();
		for(i = 0; i < MAX_MUS; i++) {
			port = i &  15;
			slot = i < 16 ? 0 : 1;
			
			if(gMuStatus[i] == testme) {
				 
				lt=time('\0');
				ptr=localtime(&lt);
//				begintime1 = "0"; //_wasctime(ptr);
				/*** This is the bug, I tried to fix it, when drPrint, a small sqare is followed, it should not be
				 **/
                //wcscpy(begintime,begintime1);

				//DebugPrint("early begintime1=%s\n", begintime1);
//				swprintf(begintime,L"%s", begintime1);
				//DebugPrint("after swprintf begintime= %s\n",begintime);

				while(1) {
									    
					    //DebugPrint("Testing MU at port %d, slot %d\n", port, slot);
					
						drCls();
				        drPrintf(20,0,L"Xbox MU Read_Write_Compare             Testing ......");
//				        drPrintf(20,40,L"Begin Time: %s   ",begintime);
						
						CheckMus();
                        if(removeflag) break;

						gMuStatus[i] = test(port, slot, BB1, BB2, BB3,readfailed, writefailed,comparefailed);
						counter++;
                        
						drPrintf(50,100,L"Read failed: %d ",readfailed);
						drPrintf(50,120,L"Write failed: %d ",writefailed);
                        drPrintf(50,140,L"Compare failed: %d ",comparefailed);
						
						if(readfailed !=-1) oldc= abs((int)counter);

						if(readfailed == -1) { 

							drPrintf(300,380,L"XMountMU failed, Error: 0x%x", GetLastError());
							drLine(280,360,280,420,0x00ff0000);
							drLine(600,360,600,420,0x00ff0000);
							drLine(280,360,600,360,0x00ff0000);
							drLine(280,420,600,420,0x00ff0000);
							
							drPrintf(50, 180,L"Test #: %d", oldc);

						}

						if(readfailed != -1) drPrintf(50, 180,L"Test #: %d", abs((int)counter));

                        lt=time('\0');
			    	    ptr=localtime(&lt);					 

//						currenttime = "0"; //_wasctime(ptr);

//                        drPrintf(20, 60, L"Current Time: %s  ", currenttime);

						drShowScreen();
						
						CheckMus();

						if(removeflag) break;


				}

                        
			}
			 
		}
	}

	//we should theoretically never get here on xbox......
	deinit();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\muprod2\muprod23\muprod23.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    muprod23.cpp

Abstract:

     This version was built based on former version muprod.cpp.

     Initializes all global variables, defines user data types, contains main function to test the four MUs independently 
	 at the same time using multithreads. When the first bad block failed, we do not test the others in order to save time.


Author:

    Bing Li(a-bingli) Feb. 2001

--*/

 
 

#include <windows.h>
#include <stdlib.h>
#include <process.h>

#include "xtl.h"
#include <stdio.h>
#include "muprod.h"
#include "draw.h"
#include "Tsc.h"


#define MAX_MUS 32

BOXSTATUS gMuStatus[MAX_MUS];

//CRITICAL_SECTION criter;
HANDLE    hIOMutex; 

typedef struct parameterList *Paralist;


static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };


// this structure contains everything needed for the thread
struct parameterList { 
    int i;                        //index of thread
    int BB1;                      //bad block count 1
    int BB2;                       //bad block count 2 
    int BB3;                       //bad block count 3
    int port;                      // port number
    int slot;                      //slot number
	int inserted;                  //inserted flag
	int removed;                   //removed flag
	int showflag;                   // show to screen flag
	int printposition;              // where should be printed on the screen
	failedreason fail;              // the reason test is failed
};


//Global variables
Paralist testparalist[MAX_MUS];

HANDLE hDuke[4] = { NULL, NULL, NULL, NULL };

//Function declaration
void ShowAllInformation(Paralist list[]);
void ReleaseMemory(Paralist list[]); // may not useful
void  OperateMotors(WORD wMotorCode, BOOL fOn);
void MaintainMotor();
bool InputCheckRumbleOff(void);
bool InputCheckRumbleOn(void);
void InputDukeInsertions(DWORD add, DWORD remove);


 
/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void init()
{
	int i;

	DWORD dwRet;
	DWORD insert;

    DebugPrint("Welcome to MU Production Test: Built on %s at %s\n", __DATE__,__TIME__);

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

	drInit();

	TscInit(0);

	DebugPrint("Getting MU devices...\n");
	insert = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    
    

	for(i = 0; i < MAX_MUS; i++) {
		if(insert & (1 << i)) {
			gMuStatus[i] = testme;
		} else {
			gMuStatus[i] = notyet;
		}
	
        
    }


	// start Motor Maintaince thread
	_beginthread((void (__cdecl*)(void *))MaintainMotor, NULL, NULL);
	DebugPrint("Done with initialization!\n");
}

void CheckMus()
{
	DWORD insert, remove;
	int i,j=0;
	//want to know whenever the devices have been changed
	if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &insert, &remove)) {
		for (i = 0; i < MAX_MUS; i++) {
			if(remove & (1 << i)) { 
				gMuStatus[i] = notyet;
				testparalist[i]->removed=1;
				testparalist[i]->showflag=1;
			}

			if(insert & (1 << i)) {
				gMuStatus[i] = testme;
				testparalist[i]->inserted=1;
				testparalist[i]->removed=0;
				testparalist[i]->showflag=1;
            }   

		}
	}
   
}

/*************************************************************************************
Function:	deinit
Purpose:	de-initialize all cpx stuff (NONE, since we never should quit!)
Params:		none
Out:		un-registers the callbacks for controlpads and MUs, tells all cpx modes to quit
Notes:		We shouldn't ever go here, since xbox only has one process, & this is it...
*************************************************************************************/
void deinit()
{
	DebugPrint("Quitting???? ...");

	drDeinit();

	DebugPrint("Deinit is finished.\n");

}


/*************************************************************************************
Function:	test()
Purpose:	call all other low level test functions
Params:		the structure of this thread
Notes:		until d3d is ported, it can't display the console...
*************************************************************************************/


void test( void *testparalist )
{
	__int64 tim;
	CHAR drive;
	BOXSTATUS overall = passed;

	//HANDLE    hIOMutex= CreateMutex (NULL, FALSE, NULL);

	int temp;
    int port, slot, BB1, BB2, BB3;
    BB1=((struct parameterList *)testparalist)->BB1;
    BB2=((struct parameterList *)testparalist)->BB2;
    BB3=((struct parameterList *)testparalist)->BB3;
    port=((struct parameterList *)testparalist)->port;
    slot=((struct parameterList *)testparalist)->slot;

	// start motor on appropriate Duke and Side

#ifdef DOLOWLEVELTESTS
    if(failed == LowLevelTest(port, slot, BB1, BB2, BB3))
    {
        overall = failed;
		((struct parameterList *)testparalist)->fail=lowleveltest;

		DebugPrint("Lowleveltest failed \n");
		goto nothing;
    }
#endif

	if(failed == FormatTest(port, slot)) {
		overall = failed;
		((struct parameterList *)testparalist)->fail=formattest;
		DebugPrint("Formattest failed \n");
		goto nothing;
	}

	if(failed == VerifyTest(port, slot)) {
		overall = failed;
		((struct parameterList *)testparalist)->fail=verifytest;
		DebugPrint("Verifytest failed \n");
		goto nothing;
	}

	temp = XMountMU(port, slot, &drive);
	DebugPrint("XMountMU: %d -- ", temp);
	DebugPrint("Drive: %c\n", drive);
	if(temp != 0) {
		DebugPrint("XMountMU failed: 0x%x\n", GetLastError());
		((struct parameterList *)testparalist)->fail=xmountmu;
		overall = failed;
		goto nothing;
	}

	Sleep(1000); //asynchronous

	
	if(failed == CountSectorWriteTest(drive)) {
		DebugPrint("CountSectorWriteTest(%c:) failed.\n", drive);
		((struct parameterList *)testparalist)->fail=countsectorwritetest;
		overall = failed;
		goto unmount;
	}

	Sleep(1000); //asynchronous


	// create a mutex handle to pretect the shared FILE * f in WriteReadTest(drive) function

   WaitForSingleObject( hIOMutex, INFINITE );
	if(failed == WriteReadTest(drive)) {
		DebugPrint("WriteReadTest(%c:) failed.\n", drive);
		((struct parameterList *)testparalist)->fail=writereadtest;
		overall = failed;
		ReleaseMutex( hIOMutex); // ensure mutex is released on failure
		goto unmount;
	}
   ReleaseMutex( hIOMutex);

	overall = passed;

unmount:
	temp = XUnmountMU(port, slot);
	DebugPrint("XUnmountMU: %d\n", temp);
	if(temp != 0) {
		overall = failed;
	}


	if(failed == FormatTest(port, slot)) {
		overall = failed;
		DebugPrint("Formattest failed \n");
		((struct parameterList *)testparalist)->fail=formattest;
		goto nothing;
	}

	if(failed == VerifyTest(port, slot)) {
		overall = failed;
		((struct parameterList *)testparalist)->fail=verifytest;
		DebugPrint("Verifytest failed \n");
		goto nothing;
	}




nothing:

    ((struct parameterList *)testparalist)->BB1=BB1;
    ((struct parameterList *)testparalist)->BB2=BB2;
    ((struct parameterList *)testparalist)->BB3=BB3;
    ((struct parameterList *)testparalist)->port=port;
    ((struct parameterList *)testparalist)->slot=slot;
	((struct parameterList *)testparalist)->showflag=1;
    
     gMuStatus[((struct parameterList *)testparalist)->i] =overall;

}


/*******************************************************************
*Function: Init_Int_Array() is used intiliaze integer arries to 0  *
*Parameters: a pointer to array, an interger of the size           *
*Return: void                                                      *
********************************************************************/
void Init_Int_Array( int array[], int size)
{
 int i=0;
 for(i=0;i<size;i++) array[i]=0;
}


/********************************************************************
*Function: main()
*********************************************************************/
void __cdecl main()
{

    int i=0,t=0,p=0,f=0,oldthread[MAX_MUS];
	init();
    Init_Int_Array(oldthread, MAX_MUS);

    //create a mutex;
	hIOMutex= CreateMutex (NULL, FALSE, NULL);


	int port=0, slot=0;
	float x1=0,y1=0;
   // static int count=0;
	Sleep(16);
    int screenflag=0,  muflag=0, showflag=0;
    float printflag=0.0;
    

	drCls();
	drPrintf(40,40,L"Xbox MU Test Version 2.00 - MU ASIC!");
	drShowScreen();
    
//allocate space and initiliaze all
	for(i=0;i<MAX_MUS;i++) {
		testparalist[i] = new (struct parameterList);
		testparalist[i]->port = -1;
        testparalist[i]->slot = -1;
        testparalist[i]->BB1=-1;
        testparalist[i]->BB2=-1;
        testparalist[i]->BB3=-1;
        testparalist[i]->i=-1;
		testparalist[i]->inserted=0;
		testparalist[i]->removed=0;
		testparalist[i]->showflag=0;
		testparalist[i]->printposition=0;
        testparalist[i]->fail=unknowreason;

	}

	while(1) //loop until we're supposed to quit...
	{
        
        screenflag=0;
        printflag=20.0;
        muflag=0;
        showflag=0;

        CheckMus();
	
        for(i = 0; i < MAX_MUS; i++) {
						
            //this device is ready to be tested
            if(gMuStatus[i] == testme) {
				DebugPrint("Testing MU at port %d, slot %d\n", port, slot);
                       
                port = i &  15;
                slot = i < 16 ? 0 : 1;

				if(port==0) testparalist[i]->printposition=0;
				else if(port==1) testparalist[i]->printposition=1;
				else if(port==2) testparalist[i]->printposition=2;
				else if(port==3) testparalist[i]->printposition=3;

               
				
				testparalist[i]->port = port;
                testparalist[i]->slot = slot;
                testparalist[i]->BB1=-1;
                testparalist[i]->BB2=-1;
                testparalist[i]->BB3=-1;
                testparalist[i]->i=i;
				testparalist[i]->fail=unknowreason;

                gMuStatus[i]= pending;
                

                _beginthread((void (__cdecl*)(void *))test, NULL, testparalist[i]);
                 

 
            }
			
			// anyone is changed to be showed on the screen, we will cal ShowAllInformation()
			if(testparalist[i]->showflag==1) showflag=1;
        }
        
        
        if(showflag==1) ShowAllInformation(testparalist);
        
        
	
} //end of while loop


    //release all space used
	ReleaseMemory(testparalist);

	//we should theoretically never get here on xbox......
	deinit();
}



/******************************************************************************************************
*Functions: ShowAllInformation(Paralist list[]) is used to show all information to the screen whenever*
*           the screen need to be updated.                                                            *
*Parameter: array of structure of Paralist.                                                           *
*******************************************************************************************************/

void ShowAllInformation(Paralist list[])
{
  
    int i=0,oldport=-1,screenflag=0,printflag=-1; // it should not be

    float x1=0,x2=0,x3=0,x4=0,y1=0,y2=0,y3=0,y4=0;
    float m1=0,m2=0,m3=0,m4=0,n1=0,n2=0,n3=0,n4=0;
    drCls();

	drPrintf(130,440,L"MU Test Version 2.00");
	drPrintf(325,440,L"Running test ......  ");
	drLine(0,235,640,235,0x000000ff);  //line for range
	drLine(310,0,310,480,0x000000ff);  //line for range

	 
	  
       
   
	
    for(i=0; i< MAX_MUS; i++) {

		//this MU has been removed, so show remove result from the screen

		if(testparalist[i]->removed==1) {

          testparalist[i]->showflag = 0;
		  screenflag=1;

          switch (testparalist[i]->printposition) {
            case 0: x1=40; y1=40; y2=60; y3=60; y4=100; break;  
            case 1: x1=320; y1=40;y2=60; y3=60; y4=100; break;  
            case 2: x1=40; y1=240; y2=260; y3=280; y4=300; break;  
            case 3: x1=320; y1=240;y2=260; y3=280; y4=300; break;  
            
            default: DebugPrint(" printflag is wrong \n");
          }
		drPrintf(x1,y1,L"Port#=%d,Slot#=%d removed", list[i]->port, list[i]->slot);
        drPrintf(x1,y2,L"                              ");
		drPrintf(x1,y3,L"                              ");
		drPrintf(x1,y4,L"                              ");
			
		if(gMuStatus[i] == failed) {
		  switch(testparalist[i]->printposition) {
		    case 0: x1=130; y1=100; x2=230; y2=200; x3=210; y3=220; x4=110; y4=120;
                    n1=210; m1=100; n2=230; m2=120; n3=130; m3=220; n4=110; m4=220;
                    break;
            case 1: x1=450; y1=100; x2=550; y2=200; x3=530; y3=220; x4=430; y4=120; 
                    n1=530; m1=100; n2=550; m2=120; n3=450; m3=220; n4=430; m4=200;
                    break;     
            case 2: x1=130; y1=320; x2=230; y2=420; x3=210; y3=440; x4=110; y4=340; 
                    n1=210; m1=320; n2=230; m2=340;n3=130;m3=440;n4=110;m4=420;
                    break; 
            case 3: x1=450; y1=320; x2=550; y2=420; x3=530; y3=440; x4=430; y4=340; 
                    n1=530; m1=320; n2=550; m2=340;n3=450;m3=440;n4=430;m4=420;
                    break;                             
            default: DebugPrint(" printflag is wrong \n");
		  }
				
		 drQuad(x1, y1, 0xff000000, x2,  y2, 0xff000000, x3, y3, 0xff000000, x4, y4, 0xff000000);
	     drQuad(n1, m1, 0xff000000, n2,  m2, 0xff000000, n3, m3, 0xff000000, n4, m4, 0xff000000);
		} else if(gMuStatus[i] == passed){
		   switch(testparalist[i]->printposition) {
		     case 0: x1=150; y1=180; x2=230; y2=100; x3=250; y3=120; x4=170; y4=200; 
                     n1=130; m1=160; n2=170; m2=200; n3=150; m3=220; n4=110; m4=180; 
					 break;
             case 1: x1=450; y1=180; x2=530; y2=100;  x3=550; y3=120; x4=470; y4=200; 
                     n1=430; m1=160; n2=470; m2=200; n3=450; m3=220; n4=410; m4=180; 
                     break; //draw second
             case 2: x1=150; y1=400; x2=230; y2=320; x3=250; y3=340; x4=170; y4=420; 
                     n1=130; m1=380; n2=170; m2=420;n3=150;m3=440;n4=110;m4=400; 
                     break; //draw third
             case 3:x1=450; y1=400; x2=530; y2=320; x3=550; y3=340; x4=470; y4=420; 
                    n1=430; m1=380; n2=470; m2=420; n3=450; m3=440; n4=410; m4=400;  
                    break; //draw fourth
             default: DebugPrint(" printflag is wrong \n");
			}
			
		   drQuad(x1, y1, 0xff000000, x2,  y2, 0xff000000, x3, y3, 0xff000000, x4, y4, 0xff000000);
           drQuad(n1, m1, 0xff000000, n2,  m2, 0xff000000, n3, m3, 0xff000000, n4, m4, 0xff000000);
		}

		continue;
		} 
		
		// MUs are testing now
		if(gMuStatus[i] == pending) {
		
			//drPrintf(0,0,L"Xbox MU Test Version 2.00 - MU ASIC! Running test...");
		    //drPrintf(0,20,L"Running test...");

			switch (testparalist[i]->printposition) {
			       case 0: x1=40; y1=40; break;  
                   case 1: x1=320; y1=40; break;  
                   case 2: x1=40; y1=240; break;  
                   case 3: x1=320; y1=240; break; 
				   default: DebugPrint(" printflag is wrong \n");
			}
				
			drPrintf(x1,y1,L"Port#=%d, Slot#=%d testing", testparalist[i]->port, testparalist[i]->slot);
		    screenflag=1;
			testparalist[i]->showflag = 0;
		
		}

//keep all old stuff in the screen
      if(((gMuStatus[i]==failed)||(gMuStatus[i] == passed))&&(testparalist[i]->removed!=1)) {         
          printflag++;

          testparalist[i]->showflag = 0;

          switch (testparalist[i]->printposition) {
            case 0: x1=40; y1=40; y2=55; y3=70; y4=85; break;  
            case 1: x1=320; y1=40;y2=55; y3=70; y4=85; break;  
            case 2: x1=40; y1=240; y2=260; y3=280; y4=300; break;  
            case 3: x1=320; y1=240;y2=260; y3=280; y4=300; break;  
            
            default: DebugPrint(" printflag is wrong \n");
          }
          
          drPrintf(x1,y1,L"Port#=%d, Slot#=%d", list[i]->port, list[i]->slot);
          if(list[i]->BB1!=-1) drPrintf(x1,y2,L"First bad block count   %d", list[i]->BB1);
		  if(list[i]->BB2!=-1) drPrintf(x1,y3,L"Second bad block count  %d", list[i]->BB2);
		  if((list[i]->BB3!=-1) && (gMuStatus[i] == passed)) drPrintf(x1,y4,L"Third bad block count   %d", list[i]->BB3);
		  else {
			  
			  switch(testparalist[i]->fail) {
			    case lowleveltest:                drPrintf(x1,y4,L"LowLeveTest Failed"); break;
				case formattest:                  drPrintf(x1,y4,L"FormatTest Failed"); break;
				case verifytest:                  drPrintf(x1,y4,L"VerifyTest Failed"); break;
				case writereadtest:               drPrintf(x1,y4,L"WriteReadTest Failed"); break;
				case countsectorwritetest:        drPrintf(x1,y4,L"CountSectorWriteTest Failed"); break;
				case xmountmu:                    drPrintf(x1,y4,L"XMountMU Failed"); break;
				case unknowreason:                drPrintf(x1,y4,L"Failed Unknow Reason"); break;
				default:                          drPrintf(x1,y4,L"Code is Wrong, Should not Show");
			  }
		  }
      }
      

	  // test is faild or passed
      if((gMuStatus[i] == failed)&&(testparalist[i]->removed!=1)) {
          
          switch(testparalist[i]->printposition) { 
            case 0: x1=130; y1=100; x2=230; y2=200; x3=210; y3=220; x4=110; y4=120;
                    n1=210; m1=100; n2=230; m2=120; n3=130; m3=220; n4=110; m4=200;
                    break;
            case 1: x1=450; y1=100; x2=550; y2=200; x3=530; y3=220; x4=430; y4=120; 
                    n1=530; m1=100; n2=550; m2=120; n3=450; m3=220; n4=430; m4=200;
                    break;     
            case 2: x1=130; y1=320; x2=230; y2=420; x3=210; y3=440; x4=110; y4=340; 
                    n1=210; m1=320; n2=230; m2=340;n3=130;m3=440;n4=110;m4=420;
                    break; 
            case 3: x1=450; y1=320; x2=550; y2=420; x3=530; y3=440; x4=430; y4=340; 
                    n1=530; m1=320; n2=550; m2=340;n3=450;m3=440;n4=430;m4=420;
                    break;                             
            default: DebugPrint(" printflag is wrong \n");
          }
                    
          drQuad(x1, y1, 0xffff0000, x2,  y2, 0xffff0000, x3, y3, 0xffff0000, x4, y4, 0xffff0000);
	      drQuad(n1, m1, 0xffff0000, n2,  m2, 0xffff0000, n3, m3, 0xffff0000, n4, m4, 0xffff0000);

      } else if((gMuStatus[i] == passed)&&(testparalist[i]->removed!=1)) {
          switch(testparalist[i]->printposition) {
             case 0: x1=150; y1=180; x2=230; y2=100; x3=250; y3=120; x4=170; y4=200; 
                     n1=130; m1=160; n2=170; m2=200; n3=150; m3=220; n4=110; m4=180;
					 break;
             case 1: x1=450; y1=180; x2=530; y2=100; x3=550; y3=120; x4=470; y4=200; 
                     n1=430; m1=160; n2=470; m2=200; n3=450; m3=220; n4=410; m4=180; 
                     break; //draw second
             case 2: x1=150; y1=400; x2=230; y2=320; x3=250; y3=340; x4=170; y4=420; 
                     n1=130; m1=380; n2=170; m2=420;n3=150;m3=440;n4=110;m4=400; 
                     break; //draw third
             case 3:x1=450; y1=400; x2=530; y2=320; x3=550; y3=340; x4=470; y4=420; 
                    n1=430; m1=380; n2=470; m2=420; n3=450; m3=440; n4=410; m4=400;  
                   break; //draw fourth
             default: DebugPrint(" printflag is wrong \n");                        
           }
          drQuad(x1, y1, 0xff00ff00, x2,  y2, 0xff00ff00, x3, y3, 0xff00ff00, x4, y4, 0xff00ff00);
          drQuad(n1, m1, 0xff00ff00, n2,  m2, 0xff00ff00, n3, m3, 0xff00ff00, n4, m4, 0xff00ff00);
      }

      if(printflag ==3 ) {
          //drCls();
           
          drShowScreen();
		  screenflag=0;
          
          printflag =-1;
      }
    } //end of for loop

//in case printflag =0,1,2,
     if(printflag!=-1) {
         drShowScreen();
         
         printflag =-1;
     }
	 else if(screenflag==1) drShowScreen();
}



void ReleaseMemory(Paralist list[])
{
    int i=0;
    
    for(i=0;i<MAX_MUS; i++) delete list[i];

}



void OperateMotors(WORD wMotorCode, BOOL fOn)
/*++
  Routine Description:
    Turns on the motors specified in the wMotorCode.
    
    Only the lower byte of wMotorCode is used.
    Here is the interpretation:

        Bit Position:        76543210  
        =============================
        Left(L) or Right(R): LRLRLRLR  
        Controller Number:   33221100

    Any number of bits may be set.

--*/
{
    XINPUT_FEEDBACK feedback;
    DWORD           dwPort;
    DWORD           dwError;
    HANDLE          hGamepad;
    BOOL            fSuccess;
	XINPUT_POLLING_PARAMETERS pp = {FALSE, TRUE, 0, 1, 1, 0};

    //
    //  Fill out the feedback header
    //
    memset(&feedback,0, sizeof(feedback));
    feedback.Header.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(!feedback.Header.hEvent)
    {
        DebugPrint("WARN: Could not create feedback wait event.");
        return;
    }
    
    //
    //  Loop over ports
    //
    for(dwPort = 0; dwPort < 4; dwPort++)
    {
        if(wMotorCode&3)
        {
            DebugPrint(
                "Turning on gamepad %d motors(%s%s%s)\n",
                dwPort,
                (wMotorCode&2) ? "LEFT" : "",
                (3 == (wMotorCode&3)) ? " and " : "",
                (wMotorCode&1) ? "RIGHT" : ""
                );
            fSuccess = FALSE;
			hGamepad = hDuke[dwPort];
            if(hGamepad)
            {
                if(fOn)
                {
                    feedback.Rumble.wLeftMotorSpeed = (wMotorCode&2) ? 0xFFF0 : 0;
                    feedback.Rumble.wRightMotorSpeed = (wMotorCode&1) ? 0xFFF0 : 0;
                } else
                {
                    feedback.Rumble.wLeftMotorSpeed = 0;
                    feedback.Rumble.wRightMotorSpeed = 0;
                }

                ResetEvent(feedback.Header.hEvent);
                dwError = XInputSetState(hGamepad, &feedback);
                if(ERROR_IO_PENDING == dwError)
                {
                    // Wait for 1 second max
                    WaitForSingleObject(feedback.Header.hEvent, 1000);
                }
			}
       }
        //
        //  Get ready for next iteration.
        //
        wMotorCode >>= 2;
    }
}

// thread to maintain motor state for the life of the process

void MaintainMotor()
{
	bool fNoisy = TRUE;
	bool fMotorState[MAX_MUS];
	bool iCurrentStatus[MAX_MUS];
	UINT StateMask[MAX_MUS];
	int port,slot;
	WORD MotorMask;
	DWORD addDevice,removeDevice;

	// init arrays;
	memset(&fMotorState,0,sizeof(bool) * MAX_MUS);
	memset(&iCurrentStatus, 0 ,sizeof(bool)* MAX_MUS);
	memset(&StateMask, 0 ,sizeof(int) * MAX_MUS);

	while(1)
	{
		
	    XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
		// allow users to defeat rumble feature
		if(fNoisy == TRUE)
		{
			// check for noises off
			if(InputCheckRumbleOff())
			{
				fNoisy = FALSE;
			}
		} else
		{
			if(InputCheckRumbleOn())
			{
				fNoisy = TRUE;
			}
		}
			
		// maintain motor states
		for(int i = 0;i< MAX_MUS; i++)
		{
			if(!testparalist[i]) continue; // continue for no duke plugged in
			// setup motor state mask
			port = testparalist[i]->port;
			slot = testparalist[i]->slot;
			MotorMask = 1 << ((port * 2) +1);  // setup for left motor

			if(testparalist[i]->removed == 1 || fNoisy == FALSE)
			{
				// turn off motor
				OperateMotors(MotorMask | (MotorMask>>1), FALSE); // turn off both left and right motors
				continue;
			}
			switch (gMuStatus[i])
			{

				case pending:
				{
					
					if(fNoisy)
					{
						// active test, intermittant rumble
						// switch motor state
						StateMask[i] ^= 1;
						OperateMotors(MotorMask,  StateMask[i]);
					
						iCurrentStatus[i] = TRUE;
					}
					break;
				}

				case failed:
				{
					if(fNoisy)
					{
						// Kill Lefthand Motor
						OperateMotors(MotorMask,0); // set left motor off
						// turn on right motor full
						OperateMotors(MotorMask >> 1,1); // turn on right motor
						StateMask[i] = 0;
					}
					break;
				}
				case passed:
				{
					
					if(fNoisy)
					{
						//
						// turn on left motor full
						OperateMotors(MotorMask,1);
						StateMask[i] = 0;
					}
					break;
				}
				 
				case notyet:
				{
					if(iCurrentStatus[i] == TRUE)
					{
						// turn off motor
						OperateMotors(MotorMask | (MotorMask>>1), FALSE); // turn off both left and right motors
						iCurrentStatus[i] = FALSE;
						StateMask[i] = 0;
						break;
					}
				}
				default:
					break;

			} // switch
		} // for
		
		Sleep(500);
	}  // while forever
}

bool InputCheckRumbleOff(void)
{
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
    {
        if(hDuke[port])
        {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 128 &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 128 &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > 128)
            {
                DebugPrint("\r\n\r\nFound Rumble off Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
            }
		}
    }

    return false;
}

bool InputCheckRumbleOn(void)
{
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
    {
        if(hDuke[port])
        {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 128 &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 128 &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > 128)
            {
                DebugPrint("\r\n\r\nFound Rumble on gamepad %u - rebooting\r\n", port+1);
                return true;
            }
		}
    }

    return false;
}

void InputDukeInsertions(DWORD add, DWORD remove)
{
    for(unsigned port=0; port<XGetPortCount(); port++)
    {
        if(remove & USBPortMasks[port])
        {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
        }
        if(add & USBPortMasks[port])
        {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            DebugPrint("Adding Duke in Port %u\n", port+1);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\murw\murw2.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    muprod23.cpp

Abstract:

     This version was built based on former version muprod.cpp.

     Initializes all global variables, defines user data types, contains main function to test the MUs independently
	 using multithread test. When the first bad block failed, we do not test the others in order to save time.


Author:

    Bing Dong Li(a-bingli) Feb. 2001

--*/

 
 

#include <windows.h>
#include <stdlib.h>
//#include <string.h>
//#include <conio.h>
#include <process.h>

#include "xtl.h"
#include <stdio.h>
#include "muprod.h"
//#include "ccl.h"
#include "draw.h"
#include "Tsc.h"

//using namespace std;

#define MAX_MUS 32

BOXSTATUS gMuStatus[MAX_MUS];

typedef struct parameterList *Paralist;



struct parameterList { 
    int i;
    int BB1;
    int BB2;
    int BB3;
    int port;
    int slot;
	int inserted;
	int removed;
	int showflag;
	int printposition;
};


//Global variables
Paralist testparalist[MAX_MUS];


//Function declaration
void ShowAllInformation(Paralist list[]);
void ReleaseMemory(Paralist list[]);
 
/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void init()
{
	int i;

	DWORD dwRet;
	DWORD insert;

    DebugPrint("Welcome to MU Production Test: Built on %s at %s\n", __DATE__,__TIME__);

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

	drInit();

	TscInit(0);

	DebugPrint("Getting MU devices...\n");
	insert = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    
    

	for(i = 0; i < MAX_MUS; i++) {
		if(insert & (1 << i)) {
			gMuStatus[i] = testme;
		} else {
			gMuStatus[i] = notyet;
		}
	
        
    }

	DebugPrint("Done with initialization!\n");
}

void CheckMus()
{
	DWORD insert, remove;
	int i,j=0;
	if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &insert, &remove)) {
		for (i = 0; i < MAX_MUS; i++) {
			if(remove & (1 << i)) { 
				gMuStatus[i] = notyet;
				testparalist[i]->removed=1;
				testparalist[i]->showflag=1;
			}

			if(insert & (1 << i)) {
				gMuStatus[i] = testme;
				testparalist[i]->inserted=1;
				testparalist[i]->removed=0;
				testparalist[i]->showflag=1;
            }
      
      

		}
	}
   //drCls();
      //drPrintf(0,30,L"remove=%d",(int*)remove);
      //drPrintf(0,50,L"insert=%d",(int*)insert);
      //drPrintf(0,70,L"gMuStatus[i]=%d, i=%d", (int)gMuStatus[i],i);
  // drPrintf(0,90,L"testme#=%d", j);
   //drShowScreen();
   //Sleep(2000);
}

/*************************************************************************************
Function:	deinit
Purpose:	de-initialize all cpx stuff (NONE, since we never should quit!)
Params:		none
Out:		un-registers the callbacks for controlpads and MUs, tells all cpx modes to quit
Notes:		We shouldn't ever go here, since xbox only has one process, & this is it...
*************************************************************************************/
void deinit()
{
	DebugPrint("Quitting???? ...");

	drDeinit();

	DebugPrint("Deinit is finished.\n");

	_asm int 3;
}


/*************************************************************************************
Function:	wWinMain (...)
Purpose:	the entry-point of cpx. Calls init, does the main loop, then de-inits
Params:		irrelevant
Notes:		until d3d is ported, it can't display the console...
*************************************************************************************/
//int __cdecl main(){return 0;}
//DWORD WINAPI TestMain()


void test( void *testparalist /*int port, int slot, int &BB1, int &BB2, int &BB3*/ )
{
	__int64 tim;
	CHAR drive;
	BOXSTATUS overall = passed;
	int temp;
    int port, slot, BB1, BB2, BB3;
    BB1=((struct parameterList *)testparalist)->BB1;
    BB2=((struct parameterList *)testparalist)->BB2;
    BB3=((struct parameterList *)testparalist)->BB3;
    port=((struct parameterList *)testparalist)->port;
    slot=((struct parameterList *)testparalist)->slot;

/*
    if(failed == LowLevelTest(port, slot, BB1, BB2, BB3))
    {
        overall = failed;
		goto nothing;
    }

	if(failed == FormatTest(port, slot)) {
		overall = failed;
		goto nothing;
	}

	if(failed == VerifyTest(port, slot)) {
		overall = failed;
		goto nothing;
	}

	temp = XMountMU(port, slot, &drive);
	DebugPrint("XMountMU: %d -- ", temp);
	DebugPrint("Drive: %c\n", drive);
	if(temp != 0) {
		DebugPrint("XMountMU failed: 0x%x\n", GetLastError());
		overall = failed;
		goto nothing;
	}

	Sleep(1000);

	if(failed == CountSectorWriteTest(drive)) {
		DebugPrint("CountSectorWriteTest(%c:) failed.\n", drive);
		overall = failed;
		goto unmount;
	}

	Sleep(1000);

*/
	// create a semphore to pretect the shared FILE * f in WriteReadTest(drive) function

   HANDLE    hIOMutex= CreateMutex (NULL, FALSE, NULL);

   WaitForSingleObject( hIOMutex, INFINITE );
	if(failed == WriteReadTest(drive)) {
		DebugPrint("WriteReadTest(%c:) failed.\n", drive);
		overall = failed;
		goto unmount;
	}
    ReleaseMutex( hIOMutex);

	overall = passed;

unmount:
	temp = XUnmountMU(port, slot);
	DebugPrint("XUnmountMU: %d\n", temp);
	if(temp != 0) {
		overall = failed;
	}


	if(failed == FormatTest(port, slot)) {
		overall = failed;
		goto nothing;
	}

	if(failed == VerifyTest(port, slot)) {
		overall = failed;
		goto nothing;
	}




nothing:

    ((struct parameterList *)testparalist)->BB1=BB1;
    ((struct parameterList *)testparalist)->BB2=BB2;
    ((struct parameterList *)testparalist)->BB3=BB3;
    ((struct parameterList *)testparalist)->port=port;
    ((struct parameterList *)testparalist)->slot=slot;
	((struct parameterList *)testparalist)->showflag=1;
    
     gMuStatus[((struct parameterList *)testparalist)->i] =overall;

    //return overall;
}



void __cdecl main()
{
//	_asm int 3;

    int i=0,t=0,p=0,f=0; //BB1[MAX_MUS],BB2[MAX_MUS], BB3[MAX_MUS];
	init();
     
	int port=0, slot=0;
	float x1=0,y1=0;

	char *currtime,*begitime;
	TCHAR *currenttime;
	TCHAR *begintime1;
	TCHAR begintime[256];
	TCHAR testing[256]= L"testing";

	struct tm *ptr;
	time_t lt;
   // static int count=0;
	Sleep(16);
    int screenflag=0,  muflag=0, showflag=0;
    float printflag=0.0;
    

	drCls();
	drPrintf(0,0,L"Xbox MU Test Version 2.00 - MU ASIC!");
	drShowScreen();
    //Sleep(200);
//allocate space and initiliaze all
	for(i=0;i<MAX_MUS;i++) {
		testparalist[i] = new (struct parameterList);
		testparalist[i]->port = -1;
        testparalist[i]->slot = -1;
        testparalist[i]->BB1=-1;
        testparalist[i]->BB2=-1;
        testparalist[i]->BB3=-1;
        testparalist[i]->i=-1;
		testparalist[i]->inserted=0;
		testparalist[i]->removed=0;
		testparalist[i]->showflag=0;
		testparalist[i]->printposition=0;
	}

	while(1) //loop until we're supposed to quit...
	{
        
        screenflag=0;
        printflag=20.0;
        muflag=0;
        showflag=0;

        CheckMus();
	
        for(i = 0; i < MAX_MUS; i++) {
						
            //if((i==1)||(i==2)||(i==3)||(i==4)) gMuStatus[i]=testme;
            if(gMuStatus[i] == testme) {
              //  DebugPrint("Testing MU at port %d, slot %d\n", port, slot);

				drCls();
				drPrintf(0,0,L"Xbox MU Read_Write_Compare Testing ......");

				lt=time('\0');
				ptr=localtime(&lt);
				//begitime=asctime(ptr);
				begintime1 = _wasctime(ptr);
                wcscpy(begintime,begintime1);

				//wsprintf(begintime, L"%S", begitime);

				drPrintf(0,200,L"Begin Time: %S", begintime);
				drShowScreen();
                       
                port = i &  15;
                slot = i < 16 ? 0 : 1;

				if((port==0)&&(slot==0)) testparalist[i]->printposition=0;
				else if((port==0)&&(slot==1)) testparalist[i]->printposition=1;
				else if((port==1)&&(slot==0)) testparalist[i]->printposition=2;
				else if((port==1)&&(slot==1)) testparalist[i]->printposition=3;

                testparalist[i]->port = port;
                testparalist[i]->slot = slot;
                testparalist[i]->BB1=-1;
                testparalist[i]->BB2=-1;
                testparalist[i]->BB3=-1;
                testparalist[i]->i=i;
				 
                gMuStatus[i]= pending;
                

                _beginthread((void (__cdecl*)(void *))test, NULL, testparalist[i]);
                 

 
            }
			
			
			if(testparalist[i]->showflag==1) showflag=1;
        }
        
        
        if(showflag==1) ShowAllInformation(testparalist);
        
        //Init_Int_Array(oldthread, MAX_MUS);
		//Init_Int_Array((int*)gMuStatus, MAX_MUS);
        
	
} //end of while loop

	ReleaseMemory(testparalist);

	//we should theoretically never get here on xbox......
	deinit();
}



void ShowAllInformation(Paralist list[])
{
  
    int i=0,oldport=-1,screenflag=0,printflag=-1; // it should not be

    float x1=0,x2=0,x3=0,x4=0,y1=0,y2=0,y3=0,y4=0;
    float m1=0,m2=0,m3=0,m4=0,n1=0,n2=0,n3=0,n4=0;
    drCls();

	drPrintf(130,460,L"MU Test Version 2.00");
	drPrintf(325,460,L"Running test ......  ");
	drLine(0,235,640,235,0x000000ff);
	drLine(310,0,310,480,0x000000ff); 

	 
	  
       
   
	//this MU has been removed, so remove result from the screen
    for(i=0; i< MAX_MUS; i++) {

		if(testparalist[i]->removed==1) {

          testparalist[i]->showflag = 0;
		  screenflag=1;

          switch (testparalist[i]->printposition) {
            case 0: x1=0; y1=20; y2=40; y3=60; y4=80; break;  
            case 1: x1=320; y1=20;y2=40; y3=60; y4=80; break;  
            case 2: x1=0; y1=240; y2=260; y3=280; y4=300; break;  
            case 3: x1=320; y1=240;y2=260; y3=280; y4=300; break;  
            
            default: DebugPrint(" printflag is wrong \n");
          }
		drPrintf(x1,y1,L"Port#=%d,Slot#=%d removed", list[i]->port, list[i]->slot);
        drPrintf(x1,y2,L"                              ");
		drPrintf(x1,y3,L"                              ");
		drPrintf(x1,y4,L"                              ");
			
		if(gMuStatus[i] == failed) {
		  switch(testparalist[i]->printposition) {
		    case 0: x1=130; y1=100; x2=230; y2=200; x3=210; y3=220; x4=110; y4=120;
                    n1=210; m1=100; n2=230; m2=120; n3=130; m3=220; n4=110; m4=220;
                    break;
            case 1: x1=450; y1=100; x2=550; y2=200; x3=530; y3=220; x4=430; y4=120; 
                    n1=530; m1=100; n2=550; m2=120; n3=450; m3=220; n4=430; m4=200;
                    break;     
            case 2: x1=130; y1=320; x2=230; y2=420; x3=210; y3=440; x4=110; y4=340; 
                    n1=210; m1=320; n2=230; m2=340;n3=130;m3=440;n4=110;m4=420;
                    break; 
            case 3: x1=450; y1=320; x2=550; y2=420; x3=530; y3=440; x4=430; y4=340; 
                    n1=530; m1=320; n2=550; m2=340;n3=450;m3=440;n4=430;m4=420;
                    break;                             
            default: DebugPrint(" printflag is wrong \n");
		  }
				
		 drQuad(x1, y1, 0xff000000, x2,  y2, 0xff000000, x3, y3, 0xff000000, x4, y4, 0xff000000);
	     drQuad(n1, m1, 0xff000000, n2,  m2, 0xff000000, n3, m3, 0xff000000, n4, m4, 0xff000000);
		} else if(gMuStatus[i] == passed){
		   switch(testparalist[i]->printposition) {
		     case 0: x1=150; y1=180; x2=230; y2=100; x3=250; y3=120; x4=170; y4=200; 
                     n1=130; m1=160; n2=170; m2=200; n3=150; m3=220; n4=110; m4=180; break;
             case 1: x1=450; y1=180; x2=530; y2=100;  x3=550; y3=120; x4=470; y4=200; 
                     n1=430; m1=160; n2=470; m2=200; n3=450; m3=220; n4=410; m4=180; 
                     break; //draw second
             case 2: x1=150; y1=400; x2=230; y2=320; x3=250; y3=340; x4=170; y4=420; 
                     n1=130; m1=380; n2=170; m2=420;n3=150;m3=440;n4=110;m4=400; 
                     break; //draw third
             case 3:x1=450; y1=400; x2=530; y2=320; x3=550; y3=340; x4=470; y4=420; 
                    n1=430; m1=380; n2=470; m2=420; n3=450; m3=440; n4=410; m4=400;  
                    break; //draw fourth
             default: DebugPrint(" printflag is wrong \n");
			}
			
		   drQuad(x1, y1, 0xff000000, x2,  y2, 0xff000000, x3, y3, 0xff000000, x4, y4, 0xff000000);
           drQuad(n1, m1, 0xff000000, n2,  m2, 0xff000000, n3, m3, 0xff000000, n4, m4, 0xff000000);
		}

		continue;
		} 
		
		
		if(gMuStatus[i] == pending) {
		
			//drPrintf(0,0,L"Xbox MU Test Version 2.00 - MU ASIC! Running test...");
		    //drPrintf(0,20,L"Running test...");

			switch (testparalist[i]->printposition) {
			       case 0: x1=0; y1=20; break;  
                   case 1: x1=320; y1=20; break;  
                   case 2: x1=0; y1=240; break;  
                   case 3: x1=320; y1=240; break; 
				   default: DebugPrint(" printflag is wrong \n");
			}
				
			drPrintf(x1,y1,L"Port#=%d, Slot#=%d testing", testparalist[i]->port, testparalist[i]->slot);
		    screenflag=1;
			testparalist[i]->showflag = 0;
		
		}

//keep in the screen
      if(((gMuStatus[i]==failed)||(gMuStatus[i] == passed))&&(testparalist[i]->removed!=1)) {         
          printflag++;

          testparalist[i]->showflag = 0;

          switch (testparalist[i]->printposition) {
            case 0: x1=0; y1=20; y2=40; y3=60; y4=80; break;  
            case 1: x1=320; y1=20;y2=40; y3=60; y4=80; break;  
            case 2: x1=0; y1=240; y2=260; y3=280; y4=300; break;  
            case 3: x1=320; y1=240;y2=260; y3=280; y4=300; break;  
            
            default: DebugPrint(" printflag is wrong \n");
          }
          
          drPrintf(x1,y1,L"Port#=%d, Slot#=%d", list[i]->port, list[i]->slot);
          if(list[i]->BB1!=-1) drPrintf(x1,y2,L"First bad block count   %d", list[i]->BB1);
		  if(list[i]->BB2!=-1) drPrintf(x1,y3,L"Second bad block count  %d", list[i]->BB2);
		  if(list[i]->BB3!=-1) drPrintf(x1,y4,L"Third bad block count   %d", list[i]->BB3);

      }
      
      if((gMuStatus[i] == failed)&&(testparalist[i]->removed!=1)) {
          
          switch(testparalist[i]->printposition) { 
            case 0: x1=130; y1=100; x2=230; y2=200; x3=210; y3=220; x4=110; y4=120;
                    n1=210; m1=100; n2=230; m2=120; n3=130; m3=220; n4=110; m4=200;
                    break;
            case 1: x1=450; y1=100; x2=550; y2=200; x3=530; y3=220; x4=430; y4=120; 
                    n1=530; m1=100; n2=550; m2=120; n3=450; m3=220; n4=430; m4=200;
                    break;     
            case 2: x1=130; y1=320; x2=230; y2=420; x3=210; y3=440; x4=110; y4=340; 
                    n1=210; m1=320; n2=230; m2=340;n3=130;m3=440;n4=110;m4=420;
                    break; 
            case 3: x1=450; y1=320; x2=550; y2=420; x3=530; y3=440; x4=430; y4=340; 
                    n1=530; m1=320; n2=550; m2=340;n3=450;m3=440;n4=430;m4=420;
                    break;                             
            default: DebugPrint(" printflag is wrong \n");
          }
                    
          drQuad(x1, y1, 0xffff0000, x2,  y2, 0xffff0000, x3, y3, 0xffff0000, x4, y4, 0xffff0000);
	      drQuad(n1, m1, 0xffff0000, n2,  m2, 0xffff0000, n3, m3, 0xffff0000, n4, m4, 0xffff0000);
      } else if((gMuStatus[i] == passed)&&(testparalist[i]->removed!=1)) {
          switch(testparalist[i]->printposition) {
             case 0: x1=150; y1=180; x2=230; y2=100; x3=250; y3=120; x4=170; y4=200; 
                     n1=130; m1=160; n2=170; m2=200; n3=150; m3=220; n4=110; m4=180; break;
             case 1: x1=450; y1=180; x2=530; y2=100; x3=550; y3=120; x4=470; y4=200; 
                     n1=430; m1=160; n2=470; m2=200; n3=450; m3=220; n4=410; m4=180; 
                     break; //draw second
             case 2: x1=150; y1=400; x2=230; y2=320; x3=250; y3=340; x4=170; y4=420; 
                     n1=130; m1=380; n2=170; m2=420;n3=150;m3=440;n4=110;m4=400; 
                     break; //draw third
             case 3:x1=450; y1=400; x2=530; y2=320; x3=550; y3=340; x4=470; y4=420; 
                    n1=430; m1=380; n2=470; m2=420; n3=450; m3=440; n4=410; m4=400;  
                   break; //draw fourth
             default: DebugPrint(" printflag is wrong \n");                        
           }
          drQuad(x1, y1, 0xff00ff00, x2,  y2, 0xff00ff00, x3, y3, 0xff00ff00, x4, y4, 0xff00ff00);
          drQuad(n1, m1, 0xff00ff00, n2,  m2, 0xff00ff00, n3, m3, 0xff00ff00, n4, m4, 0xff00ff00);
      }

      if(printflag ==3 ) {
          //drCls();
           
          drShowScreen();
		  screenflag=0;
          //Sleep(1000);
          printflag =-1;
      }
    } //end of for loop
//in case printflag =0,1,2,3

       
     

     if(printflag!=-1) {
         drShowScreen();
         //Sleep(1000);
         printflag =-1;
     }
	 else if(screenflag==1) drShowScreen();
}



void ReleaseMemory(Paralist list[])
{
    int i=0;
    
    for(i=0;i<MAX_MUS; i++) delete list[i];

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\murw\mp.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <stdio.h>
#include <xtl.h>
extern "C" {
#include <ntos.h>
#include <xapip.h>  //private XAPI methods for low-level tests
}
#include "muprod.h"


// So that we do not need to include mu.h.
// That was causing some problems.  Obviously we need to keep these current.

#define MU_VSC_GET_BAD_BLOCK_TABLE   0
#define MU_VSC_MEMORY_TEST           1
#define MU_IOCTL_GET_BAD_BLOCK_TABLE\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_GET_BAD_BLOCK_TABLE, METHOD_NEITHER, FILE_ANY_ACCESS)
#define MU_IOCTL_MEMORY_TEST\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_MEMORY_TEST, METHOD_NEITHER, FILE_ANY_ACCESS)


BOXSTATUS LowLevelTest(int port, int slot, int &BB1, int &BB2, int &BB3)
{
    CHAR device[32]; // (mu port numbers are hex values, 1 based)
    NTSTATUS status;
    HANDLE hVolume;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK statusBlock;
    OCHAR         deviceNameBuffer[64];
    OBJECT_STRING deviceName;
    USHORT  BadBlockTable[16];
    USHORT  BadBlockCount;
    int i;

    //
    //  Assume the test failed, until it passes.
    //
    BOXSTATUS boxStatus = failed;

    //
    // Initialize the device name buffer
    //

    deviceName.Buffer = deviceNameBuffer;
    deviceName.Length = 0;
    deviceName.MaximumLength = 63;

    //
    //  Tell the MU driver to expose a device object
    //
    status = MU_CreateDeviceObject(port, slot, &deviceName);
    if(NT_ERROR(status))
    {
        DebugPrint("Couldn't create device object\n");
        goto close_nothing;
    }
    
    //
    //  Open the device object in raw mode.
    //
    InitializeObjectAttributes(
        &oa,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);
    status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_ALL,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't open device object\n");
        goto close_mu_do;
    }


    //
    //  MU_IOCTL_GET_BAD_BLOCK_TABLE
    //
    DebugPrint("Getting bad block table\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_GET_BAD_BLOCK_TABLE,
                                   NULL,
                                   0,
                                   &BadBlockTable,
                                   sizeof(BadBlockTable)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    
    //
    //  Count the bad blocks if it exceeds ten fail
    //
    BadBlockCount = 0;
    for(i=0; i<16; i++)
    {
        DebugPrint("BadBlockTable[%d] = %d\n", i, (ULONG)BadBlockTable[i]);
        if(BadBlockTable[i]!=0xFFFF)
        {
            BadBlockCount++;
        }
    }
    if(BadBlockCount > 10)
    {
        DebugPrint("%d bad blocks found - test fails.\n", (ULONG)BadBlockCount);
        goto close_everything;
    }
    DebugPrint("%d bad blocks found - within specification.\n", (ULONG)BadBlockCount);
	BB1 = (ULONG)BadBlockCount;
	
	
    //
    //  MU_IOCTL_MEMORY_TEST
    //
    DebugPrint("Performing Memory Test - can take 30 seconds or more\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_MEMORY_TEST,
                                   NULL,
                                   0,
                                   &BadBlockCount,
                                   sizeof(BadBlockCount)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    //
    //  Check bad blocks
    //
    if(BadBlockCount > 10)
    {
        DebugPrint("Memory test found %d bad blocks - test fails.\n", (ULONG)BadBlockCount);
        goto close_everything;
    }
    DebugPrint("Memory Test found %d bad blocks - within specification.\n", (ULONG)BadBlockCount);
	BB2 = (ULONG)BadBlockCount;


    //
    //  MU_IOCTL_GET_BAD_BLOCK_TABLE
    //
    DebugPrint("Getting bad block table (second time)\n");
    status = NtDeviceIoControlFile(hVolume,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   MU_IOCTL_GET_BAD_BLOCK_TABLE,
                                   NULL,
                                   0,
                                   &BadBlockTable,
                                   sizeof(BadBlockTable)
                                   );
    if (NT_ERROR(status))
    {
        DebugPrint("Couldn't get the bad block table\n");
        goto close_everything;
    }
    //
    //  Count the bad blocks if it exceeds ten fail
    //
    BadBlockCount = 0;
    for(i=0; i<16; i++)
    {
        DebugPrint("BadBlockTable[%d] = %d\n", i, (ULONG)BadBlockTable[i]);
        if(BadBlockTable[i]!=0xFFFF)
        {
            BadBlockCount++;
        }
    }
    if(BadBlockCount > 10)
    {
        DebugPrint("%d bad blocks found - test fails.\n", (ULONG)BadBlockCount);
        goto close_everything;
    }
    DebugPrint("%d bad blocks found - within specification.\n", (ULONG)BadBlockCount);
	BB3 = (ULONG)BadBlockCount;

    //
    //  If we are here, the test passed.
    //
    boxStatus = passed;

close_everything:
    NtClose(hVolume);
close_mu_do:
    MU_CloseDeviceObject(port, slot);
close_nothing:

	return boxStatus;
}

BOXSTATUS FormatTest(int port, int slot)
{
    CHAR device[32]; // (mu port numbers are hex values, 1 based)
    CHAR deviceNameBuffer[64];
    STRING deviceName;

	//
    //  Assume the test failed, until it passes.
    //
    BOXSTATUS boxStatus = failed;
    
    //
    // Initialize the device name buffer
    //
    deviceName.Buffer = deviceNameBuffer;
    deviceName.Length = 0;
    deviceName.MaximumLength = 63;

    DebugPrint("Formatting Device\n");
    NTSTATUS status = MU_CreateDeviceObject(port, slot, &deviceName);
    if(NT_ERROR(status))
    {
        DebugPrint("Couldn't create device object\n");
        goto do_nothing;
    }

    if(XapiFormatFATVolume(&deviceName)) {
		DebugPrint("Format succeeded\n");
        boxStatus = passed;
	} else {
		DebugPrint("Format failed (ec: %lu)\n", GetLastError());
	}

	MU_CloseDeviceObject(port, slot);

do_nothing:
   
    return boxStatus;
}

BOXSTATUS VerifyTest(int port, int slot)
{
	return passed;
}

char* FindLastChar(char* buf, char match) {
	char*c;
	for(c = NULL; ; buf++) {
		if(*buf == match) c = buf;
		if(!*buf) return c;
	}
}

void CopyBadFile(CHAR* badmufile)
{
	if(!CopyFile(badmufile, "T:\\media\\muprod\\BadMuFile.txt", FALSE)) {
		DebugPrint("couldn't copy bad file %s back to t:\\media\\muprod\\badmufile.txt! Error %d\n", badmufile, GetLastError());
	} else {
		DebugPrint("Copied bad mu file %s to t:\\media\\murpod\\badmufile.txt\n");
	}
}

#ifdef GETMUWRITECOUNTS
LONG MU_GetWriteCount();
ULONG MU_GetWriteSize(LONG count);
ULONG MU_GetWriteBlock(LONG count);
#endif

void LogMuWrites(int start, int end, bool startplus1 = true)
{
#ifdef GETMUWRITECOUNTS
	int i;
	DebugPrint("\nTotal Writes: %d\n", end - start - startplus1 + 1);
	for(i = start+startplus1; i <= end; i++) {
		DebugPrint("Write: %d bytes, to block 0x%08x\n", MU_GetWriteSize(i), MU_GetWriteBlock(i));
	}
	DebugPrint("\n");
#endif
}

#define logmu(_title_, code) sc = MU_GetWriteCount(); DebugPrint _title_; code; Sleep(5000); LogMuWrites(sc, MU_GetWriteCount());
#define checkhandle(h) if(INVALID_HANDLE_VALUE == h) { DebugPrint("CreateFile failed, line %d, error %d\n", __LINE__, GetLastError()); goto nothing; }
#define check(r) if(0 == r) { DebugPrint("something failed, line %d, error %d\n", __LINE__, GetLastError()); goto closehandle; }

BOXSTATUS CountSectorWriteTest(CHAR drive)
{

	#ifdef _DO_MU_BLOCK_WRITE_COUNT_
		CHAR GameDir[80] = {drive, ":\\SaveGame"};
		CHAR GameDir2[80] = {drive, ":\\SaveGam2"};
		CHAR File1[80];
		CHAR File2[80];
		CHAR File3[80];
		CHAR File1a[80];
		int i;
		int sc;
		HANDLE h;
		int temp;
		ULONG temp2;
		char * tempbuf;
		
		DebugPrint("CountSectorWriteTest\n\n\n");
		sprintf(File1, "%s\\File1", GameDir);
		sprintf(File2, "%s\\File2", GameDir);
		sprintf(File3, "%s\\File3", GameDir);
		sprintf(File1a, "%s\\File1", GameDir2);

	//CreateDirectory \SaveGame
		logmu(("CreateDirectory(%S, 0): ", GameDir), 
			temp = CreateDirectory(GameDir, 0);
		);
		check(temp);
		
	//Create File \SaveGame\File1
		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//Write 5 bytes to File1
		logmu(("WriteFile 5 to file1"), 
			temp = WriteFile(h, "Narf", 5, &temp2, 0);
		);
		check(temp);
		
	//Close File1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		tempbuf = new char[17000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 16000 bytes!\n"); goto nothing;}

	//Create File \SaveGame\File2
		logmu(("CreateFile(%s, ...)", File2), 
			h = CreateFile(File2, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//Write 16000 bytes to File2
		logmu(("WriteFile 17000 to file2"), 
			temp = WriteFile(h, tempbuf, 17000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//Close File2
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		
	//Create File \SaveGame\File1

		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//append 100 bytes to file1
		tempbuf = new char[100];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 100 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 100 to file1"), 
			temp = WriteFile(h, tempbuf, 100, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file 1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);


		
	//Create File \SaveGame\File1

		logmu(("CreateFile(%S, ...)", File1), 
			h = CreateFile(File1, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//append 24000 bytes to file1
		tempbuf = new char[24000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 24000 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 24000 to file1"), 
			temp = WriteFile(h, tempbuf, 24000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file1
		logmu(("CloseHandle(h)"), 
			CloseHandle(h);
		);

		
	//delete file2
		logmu(("Deletefile(file2)"),
			temp = DeleteFile(File2);
		);
		check(temp);

	//create file3
		logmu(("CreateFile(%S, ...)", File3), 
			h = CreateFile(File3, GENERIC_READ|GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
		);
		checkhandle(h);

	//write 24000 bytes to file3
		tempbuf = new char[7100000];
		if(tempbuf == 0) { DebugPrint("couldn't allocate 7100000 bytes!\n"); goto nothing; }

		SetFilePointer(h, 0, 0, FILE_END);
		
		logmu(("WriteFile 7100000 to file3"), 
			temp = WriteFile(h, tempbuf, 7100000, &temp2, 0);
		);
		delete[] tempbuf;
		check(temp);
		
	//close file 3
		logmu(("CloseHandle(h)"), 
			temp = CloseHandle(h);
		);
		check(temp);

	//CreateDirectory \SaveGam2
		logmu(("CreateDirectory(%S, 0): ", GameDir2),
			temp = CreateDirectory(GameDir2, 0);
		);
		check(temp);

	//CopyFile(savegame\file1 -> savegam2\file1)
		logmu(("CopyFile(savegame\\file1 -> savegam2\\file1"), 
			temp = CopyFile(File1, File1a, TRUE);
		);
		check(temp);

		logmu(("Delete File3"),
			temp = DeleteFile(File3);
		);
		check(temp);
		logmu(("Delete File1"),
			temp = DeleteFile(File1);
		);
		check(temp);
		logmu(("Delete File1a"),
			temp = DeleteFile(File1a);
		);
		check(temp);
		logmu(("Remove directory1"),
			RemoveDirectory(GameDir);
		);
		check(temp);
		logmu(("Remove directory2"),
			RemoveDirectory(GameDir2);
		);
		check(temp);

		goto nothing;
	closehandle:
		logmu(("CloseHandle(h)"), 
			if(h != INVALID_HANDLE_VALUE) CloseHandle(h);
		);

	nothing:

	#endif //defined(_DO_MU_BLOCK_WRITE_COUNT_)
	return passed;
}

 

/*char* FindLastChar(char* buf, char match) {
	char*c;
	for(c = NULL; ; buf++) {
		if(*buf == match) c = buf;
		if(!*buf) return c;
	}
}
*/

BOXSTATUS WriteReadTest(CHAR drive,int &readfailed, int &writefailed, int &comparefailed)
{
	CHAR   buf[1024];
	CHAR  buf2[1024];
	FILE* f;
	DWORD s1;
	DWORD s2;
	DWORD temp;
	int pass;

	char* b1;
	char* b2;

	HANDLE h1, h2;

	sprintf(buf, "%c:\\*.*", drive);
	DeleteFile(buf);

	f = fopen("t:\\media\\muprod\\muprod.ini", "r");
	if(f == NULL) {
		DebugPrint("couldn't open t:\\muprod.ini, == c:\\tdata\\{00000~1\\muprod.ini\n");
		return failed;
	}

	pass = 0;
	while(1 == fscanf(f, "%s", buf)) {
		pass++;

		DebugPrint("Filename I am copying FROM is: %s\n", buf);

		sprintf(buf2, "%c:\\%s", drive, FindLastChar(buf, '\\') + 1);
		DebugPrint("Filename I am copying TO is: %s\n", buf2);

		h1 = CreateFile(buf, GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if(h1)
		{
			s1 = GetFileSize(h1, NULL);
			DebugPrint("Before copy, source file (%s) is %d bytes\n", buf, s1);
			CloseHandle(h1);
		}

		if(!CopyFile(buf, buf2, FALSE)) {
			DebugPrint("CopyFile(%s, %s, FALSE) failed: %d (pass %d)\n", buf, buf2, GetLastError(), pass);
			writefailed++;
//			return failed;
		}
		
		h1 = CreateFile(buf, GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if(h1 == NULL) {
			DebugPrint("Couldn't open %s!!! error %d (pass %d)", buf, GetLastError(), pass);
			//return failed;
		}

		h2 = CreateFile(buf2,GENERIC_READ,0,0,OPEN_EXISTING,0,0);
		if(h2 == NULL) {
			DebugPrint("Couldn't open %s!!! error %d (pass %d)", buf2, GetLastError(), pass);
			CloseHandle(h1);
			readfailed++;
			//return failed;
		}

		s1 = GetFileSize(h1, NULL);
		DebugPrint("File I am copying FROM is %d bytes\n", s1);
		s2 = GetFileSize(h2, NULL);
		DebugPrint("File I am copying TO is %d bytes\n", s2);
		if(s1!= s2) {
			DebugPrint("GetFileSize(%s): %d, GetFileSize(%s): %d. BAD! (pass %d)\n", buf, s1, buf2, s2, pass);
			//CopyBadFile(buf2);
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			CloseHandle(h1);
			CloseHandle(h2);
			comparefailed++;
			return failed;
		}

		b1 = new char[s1];
		if(b1 == NULL) {
			DebugPrint("new failed! (pass %d)\n", pass);
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			if(h1) CloseHandle(h1);
			if(h2) CloseHandle(h2);
			return failed;
		}
		b2 = new char[s1];
		if(b2 == NULL) {
			DebugPrint("new failed! (pass %d)\n", pass);
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			if(h1) CloseHandle(h1);
			if(h2) CloseHandle(h2);
			delete[] b1;
			return failed;
		}

		if(FALSE == ReadFile(h1, b1, s1, &temp, 0)) {
			DebugPrint("ReadFile(h1, .., %d, .., 0) failed! Error %d (pass %d)\n", s1, GetLastError(), pass);
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			if(h1) CloseHandle(h1);
			if(h2) CloseHandle(h2);
			delete[] b1;
			delete[] b2;
			return failed;
		}
		if(FALSE == ReadFile(h2, b2, s1, &temp, 0)) {
			DebugPrint("ReadFile(h2, .., %d, .., 0) failed! Error %d (pass %d)\n", s1, GetLastError(), pass);

		
			readfailed++;
			//	CopyBadFile(buf2);
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			if(h1) CloseHandle(h1);
			if(h2) CloseHandle(h2);
			delete[] b1;
			delete[] b2;
			return failed;
		}
		if(memcmp(b1, b2, s1)) {
			DebugPrint("%s is NOT the same on the mu! (pass %d)\n", buf, pass);
			/*CopyBadFile(buf2);
			HANDLE h3 = CreateFile("t:\\media\\muprod\\BadMuFile2.txt", GENERIC_READ | GENERIC_WRITE, 0,0,0,CREATE_ALWAYS,0);
			if(!h3) {
				DebugPrint("Couldn't open t:\\media\\muprod\\badmufile2.txt!!! Error %d\n", GetLastError());
			} else {
				if(FALSE == WriteFile(h3, b2, s1, &temp, 0)) {
					DebugPrint("Couldn't write to t:\\media\\muprod\\badmufile2.txt!!! Error %d\n", GetLastError());
				}
				CloseHandle(h3);
			}
			*/
			comparefailed++;
			if( fclose(f) )   DebugPrint("The file was not closed\n");
			CloseHandle(h1);
			CloseHandle(h2);
			delete[] b1;
			delete[] b2;

			return failed;
		}


		if( fclose(f) )   DebugPrint("The file was not closed\n");

		CloseHandle(h1);
		CloseHandle(h2);
//		delete[] b1;
//		delete[] b2;
		DebugPrint("WriteRead test pass %d, file %s -> %s successful!\n", pass, buf, buf2);
	}
	return passed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\MUTest\TextScreen.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    TextScreen.cpp

Abstract:

     Class implementation of general text screen and text line support
Author:

    Dennis Krueger <a-denkru> November 2001

--*/

#include "TextScreen.h"


// support methods for TextScreenLine and TextScreenArray 
CTextScreenLine::CTextScreenLine()
{
	m_sx = 0;
	m_sy = 0;
	m_dwColor = 0;
	m_strText = NULL;
	m_dwFlags = 0;
}



CTextScreenLine::CTextScreenLine(float sx, float sy, DWORD Color, WCHAR * pTextStr, DWORD dwFlags)
{
	m_sx = sx;
	m_sy = sy;
	m_dwColor = Color;
	m_strText = pTextStr;
	m_dwFlags = dwFlags;
};


CTextScreenArray::CTextScreenArray()
{
	m_LineCount = 0;
}


CTextScreenArray::~CTextScreenArray()
{
	CTextScreenLine * pThisLine;
	// delete all lines in the array
	for(int i = 0; i < m_LineCount; i++)
	{
		pThisLine = m_TextLines[i];
		if(pThisLine)
		{
			delete pThisLine;
		}
	}
}



int CTextScreenArray::Add(CTextScreenLine * pThisLine)
{
	if(m_LineCount >= MAX_LINES) return -1;
	m_TextLines[m_LineCount] = pThisLine;
	m_LineCount++;
	return m_LineCount-1;  // return index
}

int CTextScreenArray::Replace(CTextScreenLine * pThisLine, int Index)
{
	if(Index >= MAX_LINES) return -1;
	m_TextLines[Index] = pThisLine;
	return Index;  // return index
}

int CTextScreenArray::GetLineCount()
{
	return m_LineCount;
}

CTextScreenLine *
CTextScreenArray::GetLine(int Index)
{
	if(Index >= m_LineCount) return NULL; // out of range
	return m_TextLines[Index];
}

void
CTextScreenArray::ClearScreen()
{
	CTextScreenLine * pThisLine;
	for(int i = 0; i < m_LineCount; i++)
	{
		if(pThisLine = m_TextLines[i])
		{
			delete pThisLine;
		}
	}
	m_LineCount = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\MUTest\mp.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <stdio.h>
#include <xtl.h>
extern "C" {
#include <ntos.h>
#include <xapip.h>  //private XAPI methods for low-level tests
}
#include "mutest.h"




BOOL FormatMU(int port, int slot)
{
    CHAR device[32]; // (mu port numbers are hex values, 1 based)
    CHAR deviceNameBuffer[64];
    STRING deviceName;

	// set failure status
    BOOL fStatus = TRUE;
    
    //
    // Initialize the device name buffer
    //
    deviceName.Buffer = deviceNameBuffer;
    deviceName.Length = 0;
    deviceName.MaximumLength = 63;

    DebugPrint("Formatting Device\n");
    NTSTATUS status = MU_CreateDeviceObject(port, slot, &deviceName);
    if(NT_ERROR(status))
    {
        DebugPrint("Couldn't create device object\n");
        goto do_nothing;
    }

    if(XapiFormatFATVolume(&deviceName)) {
		DebugPrint("Format succeeded\n");
        fStatus = FALSE;
	} else {
		DebugPrint("Format failed (ec: %lu)\n", GetLastError());
	}

	MU_CloseDeviceObject(port, slot);

do_nothing:
   
    return fStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\MUTest\TextScreen.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    TextScreen.h

Abstract:

     Header for Text Screen and text line classes
Author:

    Dennis Krueger <a-denkru> November 2001

--*/
#ifndef __TextScreen_h_
#define __TextScreen_h_

#include "xtl.h"


#define MAX_LINES 100

#define WHITECOLOR	0xffffffff
#define	REDCOLOR	0xffDC143C
#define TITLECOLOR	0xffffd700
#define LTGREENCOLOR	0xff80ff80
#define DARKGREENCOLOR	0Xff228B22
#define YELLOWCOLOR		0xffFFFF00
#define CORALCOLOR		0xfff08080


class CTextScreenLine
{
public:
	
	 FLOAT m_sx;
	 FLOAT m_sy;
	 DWORD m_dwColor;
	 WCHAR* m_strText;
	 DWORD m_dwFlags;


	 CTextScreenLine();
	 CTextScreenLine(float sx, float sy, DWORD Color, WCHAR * TextStr, DWORD dwFlags=0);

	 ~CTextScreenLine() {;}  // do nothing destructor
};


class CTextScreenArray
{
public:
	CTextScreenArray();
	~CTextScreenArray();
	int		Add(CTextScreenLine *);
	int		Replace(CTextScreenLine *,int Index);
	CTextScreenLine * GetLine(int Index);	
	int		GetLineCount();
	void	ClearScreen();
		

private:
	
	CTextScreenLine * m_TextLines[MAX_LINES]; // rather than make this array dynamic
								      // I'm just making it a static "reasonable" size
	int		m_LineCount;

};


#endif // _TextScreen_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\MUTest\mutest.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    MUTest.h

Abstract:

     header definitions for MUTest.cpp 

Author:

    Dennis Krueger <a-denkru> November 2001

--*/
#ifndef __mutest_h_
#define __mutest_h_

//Global variables

#include "TextScreen.h"


class CXBoxUtility
{
public:
    
	CXBoxUtility() {;};
	~CXBoxUtility() {;};
    void				Init();
    void				Render();
    void				FrameMove();
	void				CheckMus();
	void				Run();
	void				UpdateScreen();


	CTextScreenArray	m_ThisScreen;
	BOOL				m_fMUStatus[20];
	BOOL				m_fRemove;


};




#define MAX_SLOTS XGetPortCount()


typedef enum {notyet, testme, pending, failed, passed} BOXSTATUS;
typedef BOXSTATUS (*BOXFUNC)(int port, int slot);
extern BOXSTATUS gPadStatus[MAX_SLOTS];



extern BOXFUNC b[];
//extern deGAMEPAD * gData;

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

	BOXSTATUS LowLevelTest(int port, int slot, int &BB1, int &BB2, int &BB3);
    BOOL FormatMU(int port, int slot);
	BOXSTATUS VerifyTest(int port, int slot);
	BOXSTATUS WriteReadTest(CHAR drive,int &readfailed, int &writefailed, int &comparefailed);
	BOXSTATUS CountSectorWriteTest(CHAR drive);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\MUTGen\MUTGen.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    MUTGen.cpp

Abstract:

    

Author:

    Dennis Krueger (a-denkru)

Environment:

    XBox

Comments:

  Note that a single read buffer is being shared by all the read/write threads.  This is in order to
    minimize memory commitment.  If r/w comparison is needed, seperate buffers will be needed

  Formatted MUs must be used.  XMount failure is not reported to the user.

  Only first 3 MUs can be used for testing due to memory requirements and screen formatting.

  L trigger + R trigger + black is used to abort processing

Revision History:
    07-21-2001  Created


*/

#include <xtl.h>
#include <stdio.h>
#include <process.h>
#include "MUTGen.h"
#include "draw.h"
#include "Tsc.h"


int ScreenInfo[4][2][2] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  // ports,slots,read/write counters

bool fExitFlags[4][2] = {FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE};
bool fRunning[4][2] = {0,0,0,0,0,0,0,0};

HANDLE hDuke[4] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[4][2] = {{ NULL, NULL},{ NULL, NULL}, { NULL, NULL},{ NULL, NULL }};



void _cdecl main(void)
{
 
	DWORD addDevice,removeDevice,dwResult,size;
	UINT port;
	Initialize();
    DebugPrint("\r\n\r\nTest App Started (Built on " __DATE__ " at " __TIME__ ")\r\n");
	bool fResult;

	drCls();

	drPrintf(200,40,L"Xbox MU Traffic Generator 1.00");

	drShowScreen();
 
    char *wbuffer = new char[MEGABYTE*3];
    if(!wbuffer)
    {
        DebugPrint("Unable to allocate memory\r\n");
		drCls();
		drPrintf(150,150,L"ERROR:  MEMORY ALLOCATION FAILURE!! - Quitting");
		drShowScreen();
		Sleep(10000);
        return;
    }

	drCls();

	drPrintf(200,40,L"Xbox MU Exercise Version 1.00");

	drPrintf(100,100,L"Initializing...");

	drShowScreen();

    memset(wbuffer, 0, MEGABYTE*2);
    unsigned count = 1;
    for(size=0; size<MEGABYTE*2; size+=64)
    {
        (*(unsigned*)&wbuffer[size]) = count++;
    }
    wbuffer[MEGABYTE*2-1] = 0x0F;
    wbuffer[MEGABYTE*2-2] = 0x0F;
    wbuffer[MEGABYTE*2-3] = 0x0F;
    wbuffer[MEGABYTE*2-4] = 0x00;
    wbuffer[MEGABYTE*2-5] = 0x01;
    wbuffer[MEGABYTE*2-6] = 0x01;
    wbuffer[MEGABYTE*2-7] = 0x01;
    wbuffer[MEGABYTE*2-8] = 0x00;
    wbuffer[MEGABYTE*2-9] = 0x0F;
    wbuffer[MEGABYTE*2-10] = 0x0F;
    wbuffer[MEGABYTE*2-11] = 0x0F;

    while(!InputCheckExitCombo())
    {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
		for(port=0; port<4; port++)
		{
			bool fRun = FALSE;
			if(hDuke[port])
			{
				// check for MU
				char drive = 0x00;
				UINT SlotNumber = 0;
				// check first MU
				if(hSlot[port][SlotNumber] && !fRunning[port][SlotNumber])
				{
					fRun = TRUE;
					
				} else if(hSlot[port][++SlotNumber] && !fRunning[port][SlotNumber]) // check 2nd MU
				{
					fRun = TRUE;
					
				}
				if(fRun == TRUE)
				{
					// got an idle MU
					// start dodiskio thread
					PTHREAD_PARAMS pParams = (PTHREAD_PARAMS) malloc(sizeof(THREAD_PARAMS));
					if(!pParams)
					{
						DebugPrint("Error:  Thread Params Malloc failed\n");
						break;
					}
					pParams->drive = (char) hSlot[port][SlotNumber];
					pParams->port  = port;
					pParams->slot  = SlotNumber;
					pParams->pSourceBuffer = wbuffer;
					fRunning[port][SlotNumber] = true;
					_beginthread((void (__cdecl*)(void *))DoDiskIO, NULL, pParams);
				}

			}
		} // for

		UpdateScreen();

	} // while

    XLaunchNewImage(NULL, NULL);
}

void UpdateScreen()
{
	float LineInc;
	drCls(); // clear screen
	drPrintf(200,40,L"Xbox MU Traffic Generator 1.00");
	drPrintf(180,60,L"L Trigger + R Trigger + black to Quit");
	// check each port
	for(int port = 0;port<XGetPortCount(); port++)
	{
		LineInc = 100 + (float) (100 * port);
		if(fRunning[port][0] || fRunning[port][1])
		{
			drPrintf(60,LineInc,L"GamePad %d",port);
			if(fRunning[port][0])
			{
				LineInc+=20;
				drPrintf(100,LineInc,L"MU 0");
				LineInc+=20;
				drPrintf(120,LineInc,L"Write Passes = %d",ScreenInfo[port][0][0]);
				drPrintf(300,LineInc,L"Read Passes  = %d",ScreenInfo[port][0][1]);
			}
			if(fRunning[port][1])
			{
				LineInc+=20;
				drPrintf(100,LineInc/*+(60*(float)port)*/,L"MU 1");
				LineInc+=20;
				drPrintf(120,LineInc/*+(60*(float)port)*/,L"Write Passes = %d",ScreenInfo[port][1][0]);
				drPrintf(300,LineInc/*+(60*(float)port)*/,L"Read Passes  = %d",ScreenInfo[port][1][1]);
			}
		}
	}
	drShowScreen();
}


void Initialize(void)
{
    DWORD error;

    //
    // Misc
    //
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    error = XGetLaunchInfo(&dataType, &launchInfo);

    //
    // USB
    //
    XInitDevices(0, NULL);

	// initialize graphics support

	drInit();

	TscInit(0);

}

bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 128 &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 128 &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > 128)
                {
                DebugPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    return false;
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            DebugPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }

void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
{
    for(unsigned i=0; i<XGetPortCount()*2; i++)
    {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[port][slot]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[port][slot]), XMUSlotFromDriveLetter((char)hSlot[port][slot]));
            hSlot[port][slot] = (HANDLE) NULL;
            }
        if(add & USBSlotMasks[i])
        {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
            {
                hSlot[port][slot] = (HANDLE)drive;
                DebugPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[port][slot]), XMUSlotFromDriveLetter((char)hSlot[port][slot])+1);
            }
        }
     }
}

void DoDiskIO(PTHREAD_PARAMS pParams)
    {
    // DISK "IN/OUT" Test for hardware guys
    bool exit = false;
	char cInputDrive = pParams->drive;
	int port = pParams->port;
	int slot = pParams->slot;
    DWORD wSize, rSize,size;
    char *wbuffer = pParams->pSourceBuffer;
 
    char filename[64];
    char drive;

	size = MEGABYTE*2;
    if(!cInputDrive)
    {
        drive = 'F';
    }
    else
    {
        drive = cInputDrive;
    }
    sprintf(filename, "%c:\\IOtest.txt", drive);

    HANDLE hFile = CreateFile(filename, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        DebugPrint("Unable to open file: %s (ec: %ld)\r\n", filename, GetLastError());
        return ;
    }

    DebugPrint("Writing initial file: %s...\r\n", filename);

    if(! (WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size))
    {
        DebugPrint("Unable to write the file (bytes: %u) (ec: %ld)\r\n", wSize, GetLastError());
        CloseHandle(hFile);
        return ;
    }
    int iPasscounter = 0;

    DebugPrint("Running DISKIO \r\n");

    while(!exit)
    {
 		SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) != TRUE)
		{
            DebugPrint("Error: WriteFile[%d] (ec: %ld)\r\n", wSize, GetLastError());
			break;
		}
		// update counter for screen display
		ScreenInfo[port][slot][0]++;
		
		SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

		if(ReadFile(hFile, wbuffer, size, &rSize, NULL) != TRUE)
		{
            DebugPrint("Error: ReadFile[%d] (ec: %ld)\r\n", rSize, GetLastError());
			break;
		}
		ScreenInfo[port][slot][1]++;

 

        // check for user interaction
        exit = fExitFlags[port][slot];
	}

    CloseHandle(hFile);
	fRunning[port][slot] = FALSE; // signal end of running state
	ScreenInfo[port][slot][0] = 0; // clear w counter
	ScreenInfo[port][slot][1] = 0; // clear r counter
	_endthread();
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\MUTGen\MUTGen.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    MUTGen.h

Abstract:

    This module is used to generate usb traffic for load analysis
Author:

    Dennis Krueger (a-denkru)

Environment:

    XBox

Revision History:
    7-21-2000  Created

Notes:

*/

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

void Initialize(void);
#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

#define DO_WRITE 1
#define DO_READ  2

void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);

typedef struct {
	char			drive;
	unsigned int	port;
	unsigned int	slot;
	char *			pSourceBuffer;
} THREAD_PARAMS, *PTHREAD_PARAMS;

void DoDiskIO(PTHREAD_PARAMS pParams );
void UpdateScreen();

static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\MUTest\MUTest.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    MUTest.cpp

Abstract:

     A rewrite of MUProd and MURW to more fully test single MU's at a time. 

Author:

    Dennis Krueger <a-denkru> November 2001

--*/



#include "xtl.h"
#include "xboxp.h"
#include <stdio.h>
#include <time.h>
#include <string.h>
#include "mutest.h"
#include "draw.h"
#include "Tsc.h"
#include "tchar.h"
#include "TextScreen.h"



#define MAX_MUS 32



/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void CXBoxUtility::Init()
{
	int i;

	DWORD dwRet;
	DWORD insert;
    
	 
    DebugPrint("Welcome to MU Production Test: Built on %s at %s\n", __DATE__,__TIME__);
	 
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

	drInit();

	TscInit(0);

	for(i = 0; i < MAX_MUS; i++)
	{
		// set all MUs to false
		m_fMUStatus[i] = FALSE;
	}

	DebugPrint("Done with initialization!\n");
}

/************************************************************************
*Function: CheckMus() is used to check whether MU is inserted or removed*
*Para: void                                                             *
*Return:void                                                            *
*************************************************************************/
void CXBoxUtility::CheckMus()
{
	DWORD insert, remove;
	int i;
	if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &insert, &remove)) {
		for (i = 0; i < MAX_MUS; i++) 
		{
			if(remove & (1 << i)) 
			{ 
				m_fMUStatus[i] = FALSE;
			}

			if(insert & (1 << i)) 
			{
				m_fMUStatus[i] = TRUE;
			}
		}
	}
}



#define TestPattern "abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ"

/*******************************************************************************
*Main Function
********************************************************************************/


void __cdecl main()
{

	CXBoxUtility TheApp;
	TheApp.Init();
	TheApp.Run();
}


void CXBoxUtility::Run()
{

	DWORD		dwResult;
	int			iFormatIndex;
	WCHAR		wcTempBuffer[400];
	BOOL		fResult;
	int			port = 0, slot = 0, temp;
	char		cDrive;


	Sleep(16);

	while(1) //loop until we're supposed to quit...
	{
		//Print out the title
		CTextScreenLine * pTitleLine = new CTextScreenLine(150,60,TITLECOLOR,L"MU Read/Write/Compare all free space",0);
		m_ThisScreen.Add(pTitleLine);
		CTextScreenLine * pInsertLine = new CTextScreenLine(150,120,REDCOLOR,L"Insert Memory Unit");
		m_ThisScreen.Add(pInsertLine);
		UpdateScreen();

		while(1)
		{
			CheckMus();
			for(int portctr = 0; portctr < MAX_MUS; portctr++) 
			{
				port = portctr &  15;
				slot = portctr < 16 ? 0 : 1;
				
				if(m_fMUStatus[portctr] == TRUE) 
				{
					m_ThisScreen.ClearScreen();
					CTextScreenLine * pTitleLine = new CTextScreenLine(150,60,TITLECOLOR,L"MU Read/Write/Compare all free space",0);
					m_ThisScreen.Add(pTitleLine);
					CTextScreenLine * pCautionLine = new CTextScreenLine(120,30,CORALCOLOR,L"CAUTION: Do not unplug MU during test!",0);
					m_ThisScreen.Add(pCautionLine);
					UpdateScreen();
					// first check if mountable
					int temp = XMountMURoot(port, slot, &cDrive);
					char cRootName[10];
					sprintf(cRootName,"%c:\\",cDrive);
					if(ERROR_UNRECOGNIZED_VOLUME == temp)
					{
						// drive not formated, notify and format
						CTextScreenLine * pFormatLine = new CTextScreenLine(170,90,REDCOLOR,L"MU Unformatted, formatting...",0);
						iFormatIndex = m_ThisScreen.Add(pFormatLine);
						UpdateScreen();
						fResult = FormatMU(port,slot);
						if(TRUE == fResult)
						{
							CTextScreenLine * pFormatLine1 = new CTextScreenLine(170,90,REDCOLOR,L"MU needed format and format failed!",0);
							m_ThisScreen.Replace(pFormatLine1,iFormatIndex);
							UpdateScreen();
							break;
						} else
						{
							CTextScreenLine * pFormatLine1 = new CTextScreenLine(170,90,LTGREENCOLOR,L"MU successfully formatted",0);
							m_ThisScreen.Replace(pFormatLine1,iFormatIndex);
							temp = XMountMURoot(port, slot, &cDrive);
							if(temp != ERROR_SUCCESS)
							{
								CTextScreenLine * pFormatLine2 = new CTextScreenLine(170,90,REDCOLOR,L"Unable to Mount MU - Fail",0);
								m_ThisScreen.Add(pFormatLine2);
								break;
							}
							sprintf(cRootName,"%c:\\",cDrive);

							
						}
					} else
					{
						CTextScreenLine * pFormatLine = new CTextScreenLine(200,90,WHITECOLOR,L"MU Format OK",0);
						iFormatIndex = m_ThisScreen.Add(pFormatLine);

					}
					UpdateScreen();
					Sleep(1000);
					ULARGE_INTEGER FreeBytesAvail,TotalBytes,TotalFree;
					fResult = GetDiskFreeSpaceEx(
								cRootName,
								&FreeBytesAvail,
								&TotalBytes,
								&TotalFree
								);
					WCHAR wcRootBuffer[30];

					swprintf(wcTempBuffer,L"Total Bytes = %d",
										TotalBytes
										);

					WCHAR * pwcTemp;
					pwcTemp = (WCHAR *) malloc((wcslen(wcTempBuffer)*2)+2);
					memcpy(pwcTemp,wcTempBuffer,(wcslen(wcTempBuffer)*2)+2);
					CTextScreenLine * pInfoLine1 = new CTextScreenLine(160,140,WHITECOLOR,pwcTemp,0);
					m_ThisScreen.Add(pInfoLine1);

					swprintf(wcTempBuffer,L"Available Bytes = %d",
										FreeBytesAvail
										);
					pwcTemp = (WCHAR *) malloc((wcslen(wcTempBuffer)*2)+2);
					memcpy(pwcTemp,wcTempBuffer,(wcslen(wcTempBuffer)*2)+2);
					CTextScreenLine * pInfoLine2 = new CTextScreenLine(160,160,WHITECOLOR,pwcTemp,0);
					m_ThisScreen.Add(pInfoLine2);

					swprintf(wcTempBuffer,L"Total Free = %d",
										TotalFree
										);

					pwcTemp = (WCHAR *) malloc((wcslen(wcTempBuffer)*2)+2);
					memcpy(pwcTemp,wcTempBuffer,(wcslen(wcTempBuffer)*2)+2);
					CTextScreenLine * pInfoLine3 = new CTextScreenLine(160,180,WHITECOLOR,pwcTemp,0);
					m_ThisScreen.Add(pInfoLine3);
					UpdateScreen();

					// now generate file for test
					// make buffer for write
					long BuffSize;
					BuffSize = FreeBytesAvail.LowPart - 500;
					if(BuffSize < 100)
					{
						CTextScreenLine * pErrorLine = new CTextScreenLine(160,200,REDCOLOR,L"Not enough freespace on MU for test",0);
						m_ThisScreen.Add(pErrorLine);
						UpdateScreen();
						goto UnMount;
					}

					char * pWriteBuffer = (char * ) malloc(BuffSize);
					if(!pWriteBuffer)
					{
						// not enough memory error out
						CTextScreenLine * pErrorLine = new CTextScreenLine(160,200,REDCOLOR,L"Out of Memory",0);
						m_ThisScreen.Add(pErrorLine);
						UpdateScreen();
						goto UnMount;
					}

					swprintf(wcTempBuffer,L"Writing file of %d bytes...",BuffSize);
					pwcTemp = (WCHAR *) malloc((wcslen(wcTempBuffer)*2)+2);
					memcpy(pwcTemp,wcTempBuffer,(wcslen(wcTempBuffer)*2)+2);
					CTextScreenLine * pWriteLine = new CTextScreenLine(160,200,WHITECOLOR,pwcTemp,0);
					int iWriteIndex = m_ThisScreen.Add(pWriteLine);
					UpdateScreen();

					// now fill test buffer with test pattern
					int iPatternSize = sizeof(TestPattern);
					long NumPatterns = BuffSize / iPatternSize;
					char * pcTemp, * pTempDest;
					pTempDest = pWriteBuffer;
					for(long i = 0; i < NumPatterns; i ++)
					{
						memcpy(pTempDest,TestPattern,sizeof(TestPattern));
						pTempDest += iPatternSize;
					}
					char cFileName[30];
					sprintf(cFileName,"%sTestFile",cRootName);
					// buffer ready for write, do it
					HANDLE hFile = CreateFile(
						cFileName,
						GENERIC_READ | GENERIC_WRITE,
						0,
						NULL,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_NORMAL,
						NULL
						);

					if(INVALID_HANDLE_VALUE == hFile)
					{
						CTextScreenLine * pErrorLine = new CTextScreenLine(160,200,REDCOLOR,L"Unable to create file on MU",0);
						m_ThisScreen.Replace(pErrorLine,iWriteIndex);
						UpdateScreen();
						goto UnMount;
					}
					DWORD dwBytesWritten;
					fResult = WriteFile(
						hFile,
						pWriteBuffer,
						BuffSize,
						&dwBytesWritten,
						NULL
						);
					if(FALSE == fResult)
					{
						// write failed
						dwResult = GetLastError();
						CTextScreenLine * pErrorLine = new CTextScreenLine(160,200,REDCOLOR,L"WriteFile failed",0);
						m_ThisScreen.Replace(pErrorLine,iWriteIndex);
						UpdateScreen();
						goto UnMount;
					}

					CTextScreenLine * pWrite1Line = new CTextScreenLine(160,200,LTGREENCOLOR,L"Write Succeeded",0);
					m_ThisScreen.Replace(pWrite1Line, iWriteIndex);
					UpdateScreen();
					
					char * pReadBuffer = (char *) malloc(BuffSize);
					if(!pReadBuffer)
					{
						// not enough memory error out
						CTextScreenLine * pErrorLine = new CTextScreenLine(160,200,REDCOLOR,L"Out of Memory - Unable to create read buffer",0);
						m_ThisScreen.Add(pErrorLine);
						UpdateScreen();
						goto UnMount;
					}
					CTextScreenLine * pReadLine = new CTextScreenLine(160,220,WHITECOLOR,L"Reading...",0);
					int iReadIndex = m_ThisScreen.Add(pReadLine);
					UpdateScreen();
					// set file pointer to beginning of file
					SetFilePointer(hFile,0,0,FILE_BEGIN);
					DWORD dwBytesRead;
					fResult = ReadFile(hFile,
						pReadBuffer,
						BuffSize,
						&dwBytesRead,
						NULL);
					if(FALSE == fResult)
					{
						dwResult = GetLastError();
						CTextScreenLine * pErrorLine = new CTextScreenLine(160,220,REDCOLOR,L"Read of File from MU failed",0);
						m_ThisScreen.Replace(pErrorLine,iReadIndex);
						UpdateScreen();
						goto UnMount;
						// fail
					}
					CTextScreenLine * pReadLine1 = new CTextScreenLine(160,220,LTGREENCOLOR,L"Read Succeeded",0);
					m_ThisScreen.Replace(pReadLine1,iReadIndex);
					UpdateScreen();

					// delete the file on the MU
					CloseHandle(hFile);
					fResult = DeleteFile(cFileName);
					if(FALSE == fResult)
					{
						// delete failed
						CTextScreenLine * pErrorLine = new CTextScreenLine(160,240,REDCOLOR,L"Delete of test file from MU failed",0);
						m_ThisScreen.Add(pErrorLine);
						UpdateScreen();
						goto UnMount;
					}

					// compare buffers
					for(long i = 0; i < BuffSize; i++)
					{
						if(pReadBuffer[i] != pWriteBuffer[i])
						{
							swprintf(wcTempBuffer,L"Compare Failed at byte %d",i);
							pwcTemp = (WCHAR *) malloc((wcslen(wcTempBuffer)*2)+2);
							memcpy(pwcTemp,wcTempBuffer,(wcslen(wcTempBuffer)*2)+2);
							CTextScreenLine * pCompareLine = new CTextScreenLine(160,240,REDCOLOR,pwcTemp,0);
							m_ThisScreen.Add(pCompareLine);
							UpdateScreen();
							goto UnMount;
						}
					}
					free(pReadBuffer);
					free(pWriteBuffer);
					CTextScreenLine * pCmpLine = new CTextScreenLine(160,240,LTGREENCOLOR,L"Compare Succeeded",0);
					m_ThisScreen.Add(pCmpLine);
					UpdateScreen();

	UnMount:
					Sleep(1000);
					XUnmountMU(port,slot);
//					m_fMUStatus[portctr] = FALSE; //done with this MU
					CTextScreenLine * pLastLine = new CTextScreenLine(160,280,YELLOWCOLOR,L"Test Complete",0);
					m_ThisScreen.Add(pLastLine);
					UpdateScreen();

					// wait here for MU removal
					while(1)
					{
						CheckMus();
						if(FALSE == m_fMUStatus[portctr])
							break;
						Sleep(500);
					}
					m_ThisScreen.ClearScreen();
					UpdateScreen();
					break;
                        
				}
				 
			} // for
			break;
		} // while
	} // while

	//we should theoretically never get here on xbox......
}

void CXBoxUtility::UpdateScreen()
{
	CTextScreenLine * pThisLine;
	// draw text on the screen
	int ScreenLines = m_ThisScreen.GetLineCount();
	drCls();
	for(int i = 0; i<ScreenLines;i++)
	{
		// get current line
		pThisLine = m_ThisScreen.GetLine(i);
		if(pThisLine)
		{
			drSetSize(50, 100, pThisLine->m_dwColor, 0xff000000); //set the color
			drPrintf(pThisLine->m_sx,
					pThisLine->m_sy,
					pThisLine->m_strText);
		}
	}
	drShowScreen();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\thumbposition\dp.h ===
#ifndef __dp_h_
#define __dp_h_


#include "dukeprod.h"

BOXSTATUS  LeftTriggerTest(BOXSTATUS newstatus);
BOXSTATUS RightTriggerTest(BOXSTATUS newstatus);
BOXSTATUS LeftThumbStick1Test(BOXSTATUS newstatus);
BOXSTATUS RightThumbStick1Test(BOXSTATUS newstatus);
BOXSTATUS DPadTest(BOXSTATUS newstatus);
BOXSTATUS StartSelectTest(BOXSTATUS newstatus);
BOXSTATUS ButtonTest(BOXSTATUS newstatus);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\TestLaunch\TestLaunch.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    TestLaunch.cpp

Abstract:
	General purpose simple launch program.  Enumerates all .xbe files, presents them in a list
	and allows the users to select and launch them
    

Author:

    Dennis Krueger (a-denkru)

Environment:

    XBox

Comments:



*/

#include "TestLaunch.h"

CXBoxUtility::CXBoxUtility()
		:CXBApplication()
{

	m_iTestCount = 0;
	m_SelLine = 0;

}


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
// _asm Int 3
    CXBoxUtility xbUtility;
    if( FAILED( xbUtility.Create() ) )
        return;
    xbUtility.Run();
}


HRESULT CXBoxUtility::Initialize()
{

//	_asm Int 3
	HANDLE hSearchHandle;
	WIN32_FIND_DATA FoundData;

    if( FAILED( m_Font16.Create( g_pd3dDevice, "Font16.xpr" ) ) )
        return E_FAIL;

	// build array of .xbe files on cd
	hSearchHandle = FindFirstFile("D:\\*.xbe",&FoundData);
	if(hSearchHandle == INVALID_HANDLE_VALUE)
	{
		// display error message
		return FALSE;
	}
    // Display each file and ask for the next.
	do
    {
        if(!(strcmp(FoundData.cFileName,"TestLaunch.xbe")) ||
			!(strcmp(FoundData.cFileName,"Default.xbe")))
				continue;
		int size = strlen(FoundData.cFileName);
		
		m_pwszTestNames[m_iTestCount] = new WCHAR[(size *2)+2];
		wsprintf(m_pwszTestNames[m_iTestCount],L"%S",FoundData.cFileName);
		m_iTestCount++;				

    } while( FindNextFile( hSearchHandle, &FoundData ) );

	DebugPrint("Finished File with %d Files\n m_pwszTestNames[0] = %x : %s\n",m_iTestCount,m_pwszTestNames[0],m_pwszTestNames[0]);
    // Close the find handle.
    FindClose( hSearchHandle );

	// got all the tests
	return TRUE;

}	

HRESULT CXBoxUtility::FrameMove()
{
	DWORD dwResult;
	
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
	{
		if(m_SelLine != 0)
			m_SelLine--;
	}
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN)
	{
		if(m_SelLine != m_iTestCount -1)
			m_SelLine++;
	}

	if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
	{
		// launch selected test
		char cLaunchBuffer[100];
		sprintf(cLaunchBuffer,"D:\\%S",m_pwszTestNames[m_SelLine]);
		dwResult = XLaunchNewImage(cLaunchBuffer,	NULL);

	}

	return S_OK;
}

#define SelColor 0xffFFFFE0  // Antique White
#define StdColor 0xff32CD32  // YELLOW
#define TitleColor 0xffffd700
#define BaseLine 120


HRESULT CXBoxUtility::Render()
{

    RenderGradientBackground(0xff00000f, 0xff000fff );
	// draw text on the screen
	m_Font16.Begin();

	m_Font16.DrawText(200,50,TitleColor,L"Test Launch Menu",0);
	for(int i = 0; i < m_iTestCount; i++)
	{
		m_Font16.DrawText(
			(float) 200,
			(float) BaseLine + (i * 35),
			i == m_SelLine ? SelColor : StdColor,
			m_pwszTestNames[i],
			0
			);
	}
	m_Font16.End();

	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\TestLaunch\TestLaunch.h ===
#include <XBApp.h>
#include <XBInput.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBSound.h>

extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}


class CXBoxUtility : public CXBApplication
{
public:
    
    HRESULT				Initialize();
    HRESULT				Render();
    HRESULT				FrameMove();
	CXBoxUtility();
	~CXBoxUtility() {;};

	CXBFont				m_Font16;
	WCHAR *				m_pwszTestNames[20];  // should never be more than 4-6

	int					m_iTestCount;
	int					m_iCurrSelection;
	int					m_SelLine;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\TestLaunch\xbelist.cpp ===
/*****************************************************
*** xbelist.cpp
***
*** CPP file for our XBE List class.
*** This class will hold a linked list of XBE's that
*** will be populated from a directory.
***
*** by James N. Helm
*** December 2nd , 2000
***
*****************************************************/

#include "stdafx.h"
#include "xbelist.h"

extern CHardDrive   g_XboxHardDrive;    // Used to configure the Xbox Hard Drive

// Constructor
CXBEList::CXBEList()
: m_bInitialized( FALSE )
{
    m_XBEItems.SetDeleteDataItem( TRUE );
}

// Destructor
CXBEList::~CXBEList()
{
}


// Will parse an XBE file and return the Title Name and Publisher Name
// If the XBE is valid, bValidXBE will be TRUE, otherwise FALSE
HRESULT CXBEList::GetInfoFromXBE( struct _XBEINFO* currentXBE, BOOL& bValidXBE, char* pszDrive )
{
    if( ( NULL == currentXBE ) || ( NULL == pszDrive ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Invalid arg passed in!!" );

        return E_INVALIDARG;
    }

    bValidXBE = FALSE;                      // Set the initial return BOOLean to 'FALSE' -- only set it to TRUE if we end up with a valid XBE
    PVOID pVarImageHeader = NULL;           // Pointer to our variable image header.
    DWORD dwCertLocationOffset = 0;         // Offset in the file where the CERT information lives
    int numRead = 0;                        // Number of 'pages' read using fread
    HRESULT hr = S_OK;                      // Return Code
    FILE* pXBEFile = NULL;                  // Used to open the XBE file
    char pszfileNameBuffer[MAX_PATH + 1];   // Used to hold the file name
    XBEIMAGE_HEADER InitialXBEHeader;       // Will hold the initial header of our XBE file

    // Clear our buffers our buffers
    ZeroMemory( pszfileNameBuffer, MAX_PATH + 1 );

    _snprintf( pszfileNameBuffer, MAX_PATH, "%s%s\\%s%s", pszDrive, currentXBE->directory, currentXBE->filename, FILE_EXECUTABLE_EXENSION_A );

    pXBEFile = fopen( pszfileNameBuffer, "rbR" );
    if( NULL == pXBEFile )
    {
        // Couldn't open the XBE file, return "FALSE" as to the XBE validity
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Failed to open the file!! - '%s'", pszfileNameBuffer );

        hr = S_OK;
        goto cleanup;
    }

    numRead = fread( &InitialXBEHeader, sizeof( XBEIMAGE_HEADER ), 1, pXBEFile );
    if( 1 != numRead )
    {
        // Header wasn't big enough to be a valid XBE file, return "FALSE" as to the XBE validity
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Header wasn't big enough - expected 1, got - '%d'", numRead );

        // Clean up and return
        hr = S_OK;
        goto cleanup;
    }

    if( InitialXBEHeader.Signature != XBEIMAGE_SIGNATURE )
    {
        // Signature didn't match, return "false" as to the XBE validity
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Invalid XBE signature" );

        // Clean up and return
        hr = S_OK;
        goto cleanup;
    }

    // Calculate the offset in the file where the CERT size is located
    dwCertLocationOffset = (ULONG)InitialXBEHeader.Certificate - (ULONG)InitialXBEHeader.BaseAddress;

    // Seek to that location in the file and read in the XBOX CERT
    if( 0 != fseek( pXBEFile, dwCertLocationOffset, SEEK_SET ) )
    {
        // Return FALSE
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Could not fseek to proper file location!! Tried - '%d'", dwCertLocationOffset );

        goto cleanup;
    }

    // Read in the information in to our XCERT
    XBEIMAGE_CERTIFICATE XBECert;
    numRead = fread( &XBECert, sizeof( XBEIMAGE_CERTIFICATE ), 1, pXBEFile );
    if( 1 != numRead )
    {
        // Return FALSE
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::GetInfoFromXBE():Could not read the CERT from the file!! - expected 1, got - '%d'", numRead );

        goto cleanup;
    }

    // Now that we have the cert, let's copy the Title Information and Publisher information in to our structure
    char titleName[XBEIMAGE_TITLE_NAME_LENGTH + 1];

    _snwprintf( currentXBE->titleName, XBEIMAGE_TITLE_NAME_LENGTH, L"%s", XBECert.TitleName );

    bValidXBE = TRUE;

cleanup:

    if( NULL != pXBEFile )
    {
        fclose( pXBEFile );
    }

    return hr;
}


// Initialize our list
//
// dirname - the name of the directory to parse
// fileExt - the extension of the file to use
HRESULT CXBEList::Init( char* dirname, char* fileExt )
{
    HRESULT hr = S_OK;

    if( m_bInitialized )
    {
        // Ensure our list is empty
        hr = m_XBEItems.EmptyList();
    }

    if( SUCCEEDED( hr ) )
    {
        m_bInitialized = FALSE;
        hr = LoadXBEs( dirname, fileExt );

        // Check for the Dashboard on the Y partition
        if( g_XboxHardDrive.FileExists( FILE_DATA_DASHBOARD_LOCATION_A ) )
        {
            HRESULT hrFileStatus = ProcessFile( FILE_DATA_DASHBOARD_FILENAME_A, FILE_DATA_DASHBOARD_DRIVE_A, FILE_DATA_DASHBOARD_DIRECTORY_A, fileExt );
            if( FAILED( hrFileStatus ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CXBEList::Init():Failed to process the file!! File - '%hs', Dir - '%hs', Error - '0x%.8X (%d)'", FILE_DATA_DASHBOARD_FILENAME_A, FILE_DATA_DASHBOARD_DIRECTORY_A, hrFileStatus, hrFileStatus );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            m_bInitialized = TRUE;
        }
        else // Clean up our list if we are in a bad way
        {
            m_XBEItems.EmptyList();
        }
    }

    return hr;
}


// Load the XBEs in to our Linked List
HRESULT CXBEList::LoadXBEs( char* dirname, char* fileExt )
{
    // Ensure we were passed valid parameters
    if( ( NULL == dirname ) || ( NULL == fileExt ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::LoadXBEs():Invalid arguments passed in!!" );

        return E_INVALIDARG;
    }

    char searchPath[MAX_PATH];
    char nextPath[MAX_PATH];
    _snprintf( searchPath, MAX_PATH, "%s\\*.*", dirname );

    WIN32_FIND_DATA wfd;
    HANDLE hFind;

    // Find the first file in the directory
    hFind = FindFirstFile( searchPath, &wfd );

    // If FindFirstFile failed with an error, return E_FAIL
    if( INVALID_HANDLE_VALUE == hFind )
    {
        return E_FAIL;
    }

    // Parse the directories looking for the correct file types
    do
    {
        // Skip over files that we are not interested in
		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM )
		{
			continue;
		}

		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )
		{
			continue;
		}

		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY )
		{
			continue;
		}

		if ( '.' == wfd.cFileName[0] )
		{
			continue;
		}

        // If we found a directory, recursively call this function
        if( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            _snprintf( nextPath, MAX_PATH, "%s\\%s", dirname, wfd.cFileName );
            LoadXBEs( nextPath, fileExt );
        }
        else // Found a file, check for XBE
        {
            HRESULT hrFileStatus = ProcessFile( wfd.cFileName, FILE_EXECUTABLE_DRIVE_A, dirname, fileExt );
            if( FAILED( hrFileStatus ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CXBEList::LoadXBEs():Failed to process the file!! File - '%hs', Dir - '%hs', Error - '0x%.8X (%d)'", wfd.cFileName, dirname, hrFileStatus, hrFileStatus );
            }
        }
    } while( FindNextFile( hFind, &wfd ) );

// cleanup:
    if( !FindClose( hFind ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::LoadXBEs():FindClose failed!! - (%d)", GetLastError() );
    }

    return S_OK;
}


// Process the file and add it to our XBE list if it's valid
HRESULT CXBEList::ProcessFile( char* pszFileName, char* pszDrive, char* pszDirectory, char* pszExtension )
{
    if( ( NULL == pszFileName ) || ( NULL == pszDirectory ) || ( NULL == pszExtension ) || ( NULL == pszDrive ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBEList::ProcessFile():Invalid parameter passed in!!" );

        return E_INVALIDARG;
    }

    // Match the extension using the upcased version of the file name

    // Convert the filename to uppercase
    _strupr( pszFileName );

    if( NULL != strstr( pszFileName, pszExtension ) )
    {
        struct _XBEINFO* pXBEInfo = new struct _XBEINFO;
        if( NULL == pXBEInfo )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CXBEList::ProcessFile():Failed to allocate memory!!" );

            return E_OUTOFMEMORY;
        }

        ZeroMemory( pXBEInfo, sizeof( struct _XBEINFO ) );

        _snprintf( pXBEInfo->directory, MAX_PATH, pszDirectory + 2 );


        unsigned int uiStrLen = strlen( pszFileName ) - strlen( pszExtension );
        strncpy( pXBEInfo->filename, pszFileName, uiStrLen );
        pXBEInfo->filename[uiStrLen] = '\0';

        XDBGTRC( APP_TITLE_NAME_A, "CXBEList::ProcessFile():Dir - '%hs', File - '%hs'", pXBEInfo->directory, pXBEInfo->filename );

        // Determine if it's a valid XBE, get the title and publisher info
        BOOL bValidXBE;
        if( FAILED( GetInfoFromXBE( pXBEInfo, bValidXBE, pszDrive ) ) )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CXBEList::ProcessFile(): Get Info Failed!!" );

            delete pXBEInfo;
            pXBEInfo = NULL;
        }
        else if( !bValidXBE )
        {
            XDBGTRC( APP_TITLE_NAME_A, "CXBEList::ProcessFile():Invalid XBE!!" );

            delete pXBEInfo;
            pXBEInfo = NULL;
        }
        else
        {
            m_XBEItems.AddNode( pXBEInfo );
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\TestLaunch\xbelist.h ===
/*****************************************************
*** xbelist.h
***
*** Header file for our XBE List class.
*** This class will hold a linked list of XBE's that
*** will be populated from a directory.
***
*** by James N. Helm
*** December 2nd , 2000
***
*****************************************************/

#ifndef _XBELIST_H_
#define _XBELIST_H_

#include <xbeimage.h>

#define XBE_INITIAL_HEADER_SIZE     4096

class CXBEList
{
public:
    // Constructors and Destructors
    CXBEList();
    ~CXBEList();

    // Methods
    HRESULT Init( char* dirname, char* fileExt );                                               // Initialize the list from a directory, loading files of a certain type
    unsigned int GetNumItems() { return m_XBEItems.GetNumItems(); };                            // Get the number of items currently in our list
    char* GetXBEName( unsigned int index ) { return m_XBEItems[index]->filename; };             // Get the name of an XBE by index
    char* GetXBEDir( unsigned int index ) { return m_XBEItems[index]->directory; };             // Get the directory of an XBE by index
    WCHAR* GetXBETitle( unsigned int index ) { return m_XBEItems[index]->titleName; };          // The title name of the XBE as in the XBE CERT Information

private:
    struct _XBEINFO
    {
        char directory[MAX_PATH + 1];
        char filename[MAX_PATH + 1];
        WCHAR titleName[XBEIMAGE_TITLE_NAME_LENGTH + 1];
    };

    // Private Properties
    CLinkedList< struct _XBEINFO* > m_XBEItems;             // XBE Item list
    BOOL m_bInitialized;                                    // Determines if we've already populated

    // Private Methods
    HRESULT LoadXBEs( char* dirname,                        // Load the XBEs in to our Linked List
                      char* fileExt );
    HRESULT GetInfoFromXBE( struct _XBEINFO* currentXBE,    // Will parse an XBE file and return the Title Name and Publisher Name
                            BOOL& bValidXBE,
                            char* pszDrive );
    HRESULT ProcessFile( char* pszFileName,                 // Process a file and add it to our list if it is valid
                         char* pszDrive,
                         char* pszDirectory,
                         char* pszExtension );
};

#endif // _XBELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\thumbposition\dp.cpp ===
//#define __HAMMERHEAD__
//define __TWOPASS__

#include "xtl.h"
#include "Draw.h"
//#include "Device.h"
#include "dukeprod.h"
#include "dp.h"

#define countof(_x_) (sizeof(_x_) / sizeof(_x_[0]))

#define nc 8192
typedef struct {
	float x1;
	float y1;
	float x2;
	float y2;
	BOXSTATUS stat;
} BOXSTRUCT;

typedef struct {
	signed short minx;
	signed short miny;
	signed short maxx;
	signed short maxy;
	BOOL button;
	int index;
} TPTESTSTRUCT;


#pragma warning(disable : 4035)
__int64 __inline rdtsc() {_asm {rdtsc}}
int __inline rdtsci(){_asm{rdtsc}}
BYTE  __inline rolb( BYTE narf, int r){_asm{mov  al, narf}_asm{mov ecx,r}_asm{rol  al,cl}}
WORD  __inline rolw( WORD narf, int r){_asm{mov  ax, narf}_asm{mov ecx,r}_asm{rol  ax,cl}}
DWORD __inline rold(DWORD narf, int r){_asm{mov eax, narf}_asm{mov ecx,r}_asm{rol eax,cl}}
BYTE  __inline rorb( BYTE narf, int r){_asm{mov  al, narf}_asm{mov ecx,r}_asm{ror  al,cl}}
WORD  __inline rorw( WORD narf, int r){_asm{mov  ax, narf}_asm{mov ecx,r}_asm{ror  ax,cl}}
DWORD __inline rord(DWORD narf, int r){_asm{mov eax, narf}_asm{mov ecx,r}_asm{ror eax,cl}}
#pragma warning(default : 4035)

void drawbox(BOXSTRUCT* b)
{
	DWORD col; 

	switch(b->stat)
	{
	case notyet:
		col = 0xff0000ff;
		break;
	case testme:
		col = (rdtsci()&0x8000000) ? 0xffffffff : 0xff707070;	//blink grey, .4 second intravals
		break;
	case pending:
		col = 0xffffff00;
		break;
	case failed:
		col = 0xffff0000;
		break;
	case passed:
		col = 0xff00ff00;
		break;
	}

	drBox(b->x1, b->y1, b->x2, b->y2, col);
	
}

#define DRAWALL() { for(int __i_ = 0; __i_ < numtocheck; __i_++) drawbox(&bs[__i_]); }


/*
//template: to create a new test:
	copy this, 
	name it appropriately, 
	add a reference to dukeprod.cpp
	change the locations in the bs[] array
	add test code where the // is.


BOXSTATUS TEMPLATE(BOXSTATUS newstatus)
{
	static BOXSTRUCT bs[] = {
		{10,10,11,20,notyet},
		{12,10,15,20,notyet},
		{16,10,19,20,notyet},
		{20,10,23,20,notyet},
		{24,10,25,20,notyet}
	};
	static const int numtocheck = countof(bs);

	int i;
	BOOL doh = FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		//add test-checking code here

		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}
*/

BOXSTATUS LeftTriggerTest(BOXSTATUS newstatus)
{
	static BYTE roller = 0;
	static BOXSTRUCT bs[] = {
		{20,70,23,90,notyet},
		{24,70,31,90,notyet},
		{32,70,39,90,notyet},
		{40,70,47,90,notyet},
		{48,70,51,90,notyet},
		{24,62,28,66,notyet}
	};

	static const int numtocheck = countof(bs);

	BYTE data = gData->bAnalogButtons[GPL];
	int i;
	BOOL doh = FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		roller = 0;
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data == 0)	
			bs[0].stat = passed;
		bs[1].stat = passed;
		bs[2].stat = passed;
		bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		if(bs[4].stat == passed) {
			if(data == 0 || bs[5].stat == passed) {		//retract!
				bs[5].stat = passed;
			} else {
				bs[5].stat = pending;
			}
		}
#else 
		if(data == 0)	
			bs[0].stat = passed;
		if(data > 0x00 && data <= 0x55)		
			bs[1].stat = passed;
		if(data > 0x55 && data <= 0xAA)		
			bs[2].stat = passed;
		if(data > 0xAA && data <  0xff)
			bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		roller |= (rolb(data, 1) ^ data);
		if(roller == 0xff) {
			if(bs[4].stat == passed) {
				if(data == 0 || bs[5].stat == passed) {	//retract!
					bs[5].stat = passed;
				} else {
					bs[5].stat = pending;
				}
			}
		}
#endif

		DRAWALL();
		drPrintf(0,0,L"Left Trigger: %02hx", data);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS RightTriggerTest(BOXSTATUS newstatus)
{
	static BYTE roller = 0;
	static BOXSTRUCT bs[] = {
		{520,70,523,90,notyet},
		{524,70,531,90,notyet},
		{532,70,539,90,notyet},
		{540,70,547,90,notyet},
		{548,70,551,90,notyet},
		{524,62,528,66,notyet}
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	BYTE data = gData->bAnalogButtons[GPR];
	int i;
	BOOL doh = FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		roller = 0;
		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data == 0)	
			bs[0].stat = passed;
		bs[1].stat = passed;
		bs[2].stat = passed;
		bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		if(bs[4].stat == passed) {
			if(data == 0 || bs[5].stat == passed) {		//retract!
				bs[5].stat = passed;
			} else {
				bs[5].stat = pending;
			}
		}
#else 
		if(data == 0)	
			bs[0].stat = passed;
		if(data > 0x00 && data <= 0x55)		
			bs[1].stat = passed;
		if(data > 0x55 && data <= 0xAA)		
			bs[2].stat = passed;
		if(data > 0xAA && data <  0xff)
			bs[3].stat = passed;
		if(data == 0xff)
			bs[4].stat = passed;
		roller |= (rolb(data, 1) ^ data);
		if(roller == 0xff) {
			if(bs[4].stat == passed) {
				if(data == 0 || bs[5].stat == passed) {	//retract!
					bs[5].stat = passed;
				} else {								
					bs[5].stat = pending;
				}
			}
		}
#endif
		DRAWALL();
		drPrintf(0,0,L"Right Trigger: %02hx", data);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}



BOXSTATUS LeftThumbStick1Test(BOXSTATUS newstatus)
{
	static TPTESTSTRUCT tp[] = {				//in-order checkoff
		{   -nc,   -nc,    nc,    nc,0, 9},
		{-16000,-16000, 16000, 16000,0, 4},

		{-16000, 16001, 16000, 32767,0, 1},
		{-32768, 16001,-16001, 32767,0, 0},
		{-32768,-16000,-16001, 16000,0, 3},
		{-32768,-32768,-16001,-16001,0, 6},
		{-16000,-32768, 16000,-16001,0, 7},
		{ 16001,-32768, 32767,-16001,0, 8},
		{ 16001,-16000, 32767, 16000,0, 5},
		{ 16001, 16001, 32767, 32767,0, 2},

#ifdef __TWOPASS__
		{-16000, 16001, 16000, 32767,1, 1},
		{-32768, 16001,-16001, 32767,1, 0},
		{-32768,-16000,-16001, 16000,1, 3},
		{-32768,-32768,-16001,-16001,1, 6},
		{-16000,-32768, 16000,-16001,1, 7},
		{ 16001,-32768, 32767,-16001,1, 8},
		{ 16001,-16000, 32767, 16000,1, 5},
		{ 16001, 16001, 32767, 32767,1, 2},

		{-16000,-16000, 16000, 16000,1, 4},
#endif
		//{     0,     0,     0,     0,1, 9},
		{   -nc,   -nc,    nc,    nc, 1, 9},
		{   -nc,   -nc,    nc,    nc, 0, 9}
		//{     0,     0,     0,     0,0, 9}
	};

	/*
//#pragma warning (disable : 4309; disable : 4305)//either this, or (short)... ugh.
	static TPTESTSTRUCT tp2[] = {					//any-order checkoff
		{(short)0x8000,(short)0x8000,(short)0x8000,(short)0x7fff,0,10},
		{(short)0x8001,(short)0x8000,(short)0xa000,(short)0x7fff,0,11},
		{(short)0xa001,(short)0x8000,(short)0xc000,(short)0x7fff,0,12},
		{(short)0xc001,(short)0x8000,(short)0xe000,(short)0x7fff,0,13},
		{(short)0xe001,(short)0x8000,(short)0xffff,(short)0x7fff,0,14},
		{(short)0x0000,(short)0x8000,(short)0x0000,(short)0x7fff,0,15},
		{(short)0x0001,(short)0x8000,(short)0x2000,(short)0x7fff,0,16},
		{(short)0x2001,(short)0x8000,(short)0x4000,(short)0x7fff,0,17},
		{(short)0x4001,(short)0x8000,(short)0x6000,(short)0x7fff,0,18},
		{(short)0x6001,(short)0x8000,(short)0x7ffe,(short)0x7fff,0,19},
		{(short)0x7fff,(short)0x8000,(short)0x7fff,(short)0x7fff,0,20},

		{(short)0x8000,(short)0x8000,(short)0x7fff,(short)0x8000,0,21},
		{(short)0x8000,(short)0x8001,(short)0x7fff,(short)0xa000,0,22},
		{(short)0x8000,(short)0xa001,(short)0x7fff,(short)0xc000,0,23},
		{(short)0x8000,(short)0xc001,(short)0x7fff,(short)0xe000,0,24},
		{(short)0x8000,(short)0xe001,(short)0x7fff,(short)0xffff,0,25},
		{(short)0x8000,(short)0x0000,(short)0x7fff,(short)0x0000,0,26},
		{(short)0x8000,(short)0x0001,(short)0x7fff,(short)0x2000,0,27},
		{(short)0x8000,(short)0x2001,(short)0x7fff,(short)0x4000,0,28},
		{(short)0x8000,(short)0x4001,(short)0x7fff,(short)0x6000,0,29},
		{(short)0x8000,(short)0x6001,(short)0x7fff,(short)0x7ffe,0,30},
		{(short)0x8000,(short)0x700f,(short)0x7fff,(short)0x7fff,0,31}
	};
//#pragma warning(default : 4309; default : 4305)
*/

	static BOXSTRUCT bs[] = {
		{40,160,59,179,notyet},				//0
		{60,160,79,179,notyet},				//1
		{80,160,99,179,notyet},
		{40,180,59,199,notyet},				//3	
		{60,180,79,199,notyet},				//4
		{80,180,99,199,notyet},
		{40,200,59,219,notyet},				//6
		{60,200,79,219,notyet},
		{80,200,99,219,notyet},	

		{67,187,73,193,notyet},	//centered	//9
/*
		{42,150,46,154,notyet},	//   0x80	//10
		{47,150,51,154,notyet},	//to 0xa0
		{52,150,56,154,notyet},	//to 0xc0
		{57,150,61,154,notyet},	//to 0xe0
		{62,150,66,154,notyet},	//to 0xff
		{67,150,71,154,notyet},	//   0x00
		{72,150,76,154,notyet},	//to 0x20
		{77,150,81,154,notyet},	//to 0x40
		{82,150,86,154,notyet},	//to 0x60
		{87,150,91,154,notyet},	//to 0x7e
		{92,150,96,154,notyet},	//   0x7f	//20

		{105,212,109,216,notyet},	//   0x7f	//31
		{105,207,109,211,notyet},	//to 0x7e
		{105,202,109,206,notyet},	//to 0x60
		{105,197,109,201,notyet},	//to 0x40
		{105,192,109,196,notyet},	//to 0x20
		{105,187,109,191,notyet},	//   0x00
		{105,182,109,186,notyet},	//to 0xff
		{105,177,109,181,notyet},	//to 0xe0
		{105,172,109,176,notyet},	//to 0xc0
		{105,167,109,171,notyet},	//to 0xa0
		{105,162,109,166,notyet},	//   0x80	//21
*/
		{110,177,126,193,notyet}    //button	//32
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	BOOL doh = FALSE;
	static int c = 0;

	signed short x = gData->sThumbLX;
	signed short y = gData->sThumbLY;
	BOOL bp = (gData->wButtons & XINPUT_GAMEPAD_LEFT_THUMB) ? TRUE : FALSE;
    DebugPrint("x=%d",x);
	 
	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		if(c >= sizeof(tp) / sizeof(tp[0])) {
			bs[sizeof(bs)/sizeof(bs[0])-1].stat = passed;
		} else {
			if(x > tp[c].maxx || x < tp[c].minx || 
				y > tp[c].maxy || y < tp[c].miny ||
				bp != tp[c].button || ((tp[c].maxx | tp[c].minx | tp[c].maxy | tp[c].miny) && (!(x | y))) )
			{
				bs[tp[c].index].stat = testme;
				if(c!=(numtocheck-2)) bs[sizeof(bs)/sizeof(bs[0])-1].stat = tp[c].button ? testme : pending;
				else bs[sizeof(bs)/sizeof(bs[0])-1].stat=pending;
			} else {
				for(i = c + 1; i < sizeof(tp) / sizeof(tp[0]); i++)
				{
					if(tp[i].index == tp[c].index) {
						bs[tp[c].index].stat = pending;
						goto notdone;
					}
				}
				bs[tp[c].index].stat = passed;
notdone:

//				bs[tp[c].index].stat = tp[c].button ? passed : pending;
				c++;
			}
		}

/*
		for(i = 0; i < sizeof(tp2) / sizeof(tp2[0]); i++)
		{
			if(x > tp2[i].maxx || x < tp2[i].minx ||
				y > tp2[i].maxy || y < tp2[i].miny)
			{
				if(bs[tp2[i].index].stat != passed) bs[tp2[i].index].stat = testme;
			} else {
				bs[tp2[i].index].stat = passed;
			}
		}
*/

		::drPrintf(0,0,L"Left Thumb-Stick: X: %6hd   Y: %6hd  B: %s", 
			x, y, bp ? L"TRUE" : L"FALSE");
		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS DPadTest(BOXSTATUS newstatus)
{
	static struct {
		BYTE d[4];
	} bd[] = {
		{1,0,0,0},
		{1,0,1,0},
		{0,0,1,0},
		{0,1,1,0},
		{0,1,0,0},
		{0,1,0,1},
		{0,0,0,1},
		{1,0,0,1},
		{0,0,0,0}
	};
	static BOXSTRUCT bs[] = {
		{115,335,205,425,notyet},	//all?
		{150,340,170,360,notyet},	//up
		{120,340,140,360,notyet},	//upleft
		{120,370,140,390,notyet},	//left
		{120,400,140,420,notyet},	//downleft
		{150,400,170,420,notyet},	//down
		{180,400,200,420,notyet},	//downright
		{180,370,200,390,notyet},	//right
		{180,340,200,360,notyet},	//upright
		{150,370,170,390,notyet} 	//centered
	};
	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	static int c = 0;
	BOOL doh = FALSE;
	BYTE data[] = {
		gData->wButtons & XINPUT_GAMEPAD_DPAD_UP    ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_DOWN  ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_LEFT  ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ? 1 : 0
	};


	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 1;
		return notyet;
	case testme:
		for(i = 1; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(doh) {
			goto doh;
		}

		if(bs[0].stat == failed) {
			return failed;
		}

		return passed;
doh:
		if((data[0] && data[1]) || (data[2] && data[3])) {
			bs[0].stat = failed;
		}

		for (i = 0; i < 4; i++)	{
			if(data[i] != bd[c-1].d[i]) {
				bs[c].stat = testme;
				goto doh2;
			}
		}
		bs[c].stat = passed;
		c++;

doh2:

		DRAWALL();
		drPrintf(0,0,L"Up: %d  Down: %d  Left: %d  Right: %d",data[0],data[1],data[2],data[3]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}


BOXSTATUS StartSelectTest(BOXSTATUS newstatus)
{
	static BOXSTRUCT bs[] = {
		{240,400,250,410,notyet},
		{280,400,290,410,notyet}
	};
	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);
	static int c = 0;
	int i;
	BOOL doh = TRUE;
	BYTE data[] = {
		gData->wButtons & XINPUT_GAMEPAD_BACK     ? 1 : 0,
		gData->wButtons & XINPUT_GAMEPAD_START    ? 1 : 0,
	};

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		switch (c) {
		case 0:
			if(data[0] == 0 || data[1] == 1) {
				bs[0].stat = testme;
			} else {
				bs[0].stat = pending;
				c++;
			}
			break;
		case 1:
			if(data[0] == 0) {
				bs[0].stat = passed;
				bs[1].stat = testme;
				c++;
			}
			break;
		case 2:
			if(data[0] == 1 || data[1] == 0) {
				bs[1].stat = testme;
			} else {
				bs[1].stat = pending;
				c++;
			}
			break;
		case 3:
			if(data[1] == 0) {
				bs[1].stat = passed;
				return passed;
			}
			break;
		}

		DRAWALL();
		drPrintf(0,0,L"Start: %d   Back: %d", data[0], data[1]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}


BOXSTATUS RightThumbStick1Test(BOXSTATUS newstatus)
{
	static TPTESTSTRUCT tp[] = {				//in-order checkoff
		{     -nc,     -nc,     nc,     nc,0, 9},
		{-16000, -16000,  16000,  16000,0, 4},

		{-16000, 16001, 16000, 32767,0, 1},
		{-32768, 16001,-16001, 32767,0, 0},
		{-32768,-16000,-16001, 16000,0, 3},
		{-32768,-32768,-16001,-16001,0, 6},
		{-16000,-32768, 16000,-16001,0, 7},
		{ 16001,-32768, 32767,-16001,0, 8},
		{ 16001,-16000, 32767, 16000,0, 5},
		{ 16001, 16001, 32767, 32767,0, 2},

#ifdef __TWOPASS__
		{-16000, 16001, 16000, 32767,1, 1},
		{-32768, 16001,-16001, 32767,1, 0},
		{-32768,-16000,-16001, 16000,1, 3},
		{-32768,-32768,-16001,-16001,1, 6},
		{-16000,-32768, 16000,-16001,1, 7},
		{ 16001,-32768, 32767,-16001,1, 8},
		{ 16001,-16000, 32767, 16000,1, 5},
		{ 16001, 16001, 32767, 32767,1, 2},

		{ -16000, -16000,  16000,  16000,1, 4},
#endif
		{   -nc,   -nc,    nc,    nc,1, 9},
		{   -nc,   -nc,    nc,    nc,0, 9}
		
		//{     0,     0,     0,     0,1, 9},
		//{     0,     0,     0,     0,0, 9}
	};

	/*
//#pragma warning (disable : 4309; disable : 4305)//either this, or (short)... ugh.
	static TPTESTSTRUCT tp2[] = {					//any-order checkoff
		{(short)0x8000,(short)0x8000,(short)0x8000,(short)0x7fff,0,10},
		{(short)0x8001,(short)0x8000,(short)0xa000,(short)0x7fff,0,11},
		{(short)0xa001,(short)0x8000,(short)0xc000,(short)0x7fff,0,12},
		{(short)0xc001,(short)0x8000,(short)0xe000,(short)0x7fff,0,13},
		{(short)0xe001,(short)0x8000,(short)0xffff,(short)0x7fff,0,14},
		{(short)0x0000,(short)0x8000,(short)0x0000,(short)0x7fff,0,15},
		{(short)0x0001,(short)0x8000,(short)0x2000,(short)0x7fff,0,16},
		{(short)0x2001,(short)0x8000,(short)0x4000,(short)0x7fff,0,17},
		{(short)0x4001,(short)0x8000,(short)0x6000,(short)0x7fff,0,18},
		{(short)0x6001,(short)0x8000,(short)0x7ffe,(short)0x7fff,0,19},
		{(short)0x7fff,(short)0x8000,(short)0x7fff,(short)0x7fff,0,20},

		{(short)0x8000,(short)0x8000,(short)0x7fff,(short)0x8000,0,21},
		{(short)0x8000,(short)0x8001,(short)0x7fff,(short)0xa000,0,22},
		{(short)0x8000,(short)0xa001,(short)0x7fff,(short)0xc000,0,23},
		{(short)0x8000,(short)0xc001,(short)0x7fff,(short)0xe000,0,24},
		{(short)0x8000,(short)0xe001,(short)0x7fff,(short)0xffff,0,25},
		{(short)0x8000,(short)0x0000,(short)0x7fff,(short)0x0000,0,26},
		{(short)0x8000,(short)0x0001,(short)0x7fff,(short)0x2000,0,27},
		{(short)0x8000,(short)0x2001,(short)0x7fff,(short)0x4000,0,28},
		{(short)0x8000,(short)0x4001,(short)0x7fff,(short)0x6000,0,29},
		{(short)0x8000,(short)0x6001,(short)0x7fff,(short)0x7ffe,0,30},
		{(short)0x8000,(short)0x700f,(short)0x7fff,(short)0x7fff,0,31}
	};
//#pragma warning(default : 4309; default : 4305)
*/

	static BOXSTRUCT bs[] = {
		{340,360,359,379,notyet},				//0
		{360,360,379,379,notyet},				//1
		{380,360,399,379,notyet},
		{340,380,359,399,notyet},				//3	
		{360,380,379,399,notyet},				//4
		{380,380,399,399,notyet},
		{340,400,359,419,notyet},				//6
		{360,400,379,419,notyet},
		{380,400,399,419,notyet},	
		{367,387,373,393,notyet},	//centered	//9
/*
		{342,350,346,354,notyet},	//   0x80	//10
		{347,350,351,354,notyet},	//to 0xa0
		{352,350,356,354,notyet},	//to 0xc0
		{357,350,361,354,notyet},	//to 0xe0
		{362,350,366,354,notyet},	//to 0xff
		{367,350,371,354,notyet},	//   0x00
		{372,350,376,354,notyet},	//to 0x20
		{377,350,381,354,notyet},	//to 0x40
		{382,350,386,354,notyet},	//to 0x60
		{387,350,391,354,notyet},	//to 0x7e
		{392,350,396,354,notyet},	//   0x7f	//20

		{405,412,409,416,notyet},	//   0x7f	//31
		{405,407,409,411,notyet},	//to 0x7e
		{405,402,409,406,notyet},	//to 0x60
		{405,397,409,401,notyet},	//to 0x40
		{405,392,409,396,notyet},	//to 0x20
		{405,387,409,391,notyet},	//   0x00
		{405,382,409,386,notyet},	//to 0xff
		{405,377,409,381,notyet},	//to 0xe0
		{405,372,409,376,notyet},	//to 0xc0
		{405,367,409,371,notyet},	//to 0xa0
		{405,362,409,366,notyet},	//   0x80	//21
		*/

		{410,377,426,393,notyet}    //button	//32
	};

	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	int i;
	BOOL doh = FALSE;
	static int c = 0;

	signed short x = gData->sThumbRX;
	signed short y = gData->sThumbRY;
	BOOL bp = (gData->wButtons & XINPUT_GAMEPAD_RIGHT_THUMB) ? TRUE : FALSE;

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}
		DRAWALL();
		c = 0;
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
//				bs[i].stat = testme;
				doh = TRUE;
			}
		}
		if(!doh) return passed;

		if(c >= sizeof(tp) / sizeof(tp[0])) {
			bs[sizeof(bs)/sizeof(bs[0])-1].stat = passed;
		} else {
			if(x > tp[c].maxx || x < tp[c].minx || 
				y > tp[c].maxy || y < tp[c].miny ||
				bp != tp[c].button || ((tp[c].maxx | tp[c].minx | tp[c].maxy | tp[c].miny) && (!(x | y))) )
			{
				bs[tp[c].index].stat = testme;
				if(c!=(numtocheck-2)) bs[sizeof(bs)/sizeof(bs[0])-1].stat = tp[c].button ? testme : pending;
				else bs[sizeof(bs)/sizeof(bs[0])-1].stat=pending;
			} else {
				for(i = c + 1; i < sizeof(tp) / sizeof(tp[0]); i++)
				{
					if(tp[i].index == tp[c].index) {
						bs[tp[c].index].stat = pending;
						goto notdone;
					}
				}
				bs[tp[c].index].stat = passed;
notdone:

//				bs[tp[c].index].stat = tp[c].button ? passed : pending;
				c++;
			}
		}

/*
		for(i = 0; i < sizeof(tp2) / sizeof(tp2[0]); i++)
		{
			if(x > tp2[i].maxx || x < tp2[i].minx ||
				y > tp2[i].maxy || y < tp2[i].miny)
			{
				if(bs[tp2[i].index].stat != passed) bs[tp2[i].index].stat = testme;
			} else {
				bs[tp2[i].index].stat = passed;
			}
		}
*/

		::drPrintf(0,0,L"Right Thumb-Stick: X: %6hd   Y: %6hd  B: %s", 
			x, y, bp ? L"TRUE" : L"FALSE");
		DRAWALL();
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}

BOXSTATUS ButtonTest(BOXSTATUS newstatus)
{
	static BOXSTRUCT bs[] = {
		{410,210,420,212,notyet},
		{410,212,420,216,notyet},
		{410,216,420,220,notyet},
		{410,220,420,224,notyet},
		{410,224,420,228,notyet},
		{424,210,428,228,notyet},

		{450,210,460,212,notyet},
		{450,212,460,216,notyet},
		{450,216,460,220,notyet},
		{450,220,460,224,notyet},
		{450,224,460,228,notyet},
		{464,210,468,228,notyet},

		{490,210,500,212,notyet},
		{490,212,500,216,notyet},
		{490,216,500,220,notyet},
		{490,220,500,224,notyet},
		{490,224,500,228,notyet},
		{504,210,508,228,notyet},

		{410,260,420,262,notyet},
		{410,262,420,266,notyet},
		{410,266,420,270,notyet},
		{410,270,420,274,notyet},
		{410,274,420,278,notyet},
		{424,260,428,278,notyet},

		{450,260,460,262,notyet},
		{450,262,460,266,notyet},
		{450,266,460,270,notyet},
		{450,270,460,274,notyet},
		{450,274,460,278,notyet},
		{464,260,468,278,notyet},

		{490,260,500,262,notyet},
		{490,262,500,266,notyet},
		{490,266,500,270,notyet},
		{490,270,500,274,notyet},
		{490,274,500,278,notyet},
		{504,260,508,278,notyet}
	};
	static const int numtocheck = sizeof(bs) / sizeof(bs[0]);

	static int c = 0;
//	if(c >= 6) c = 0;

	int i;
	BOOL doh = FALSE;
	BOOL doh2 = FALSE;

	static BYTE otherdif[6] = {0,0,0,0,0,0};
	static BYTE roller = 0;

	BYTE data[] = {
		gData->bAnalogButtons[GPX],
		gData->bAnalogButtons[GPY],
		gData->bAnalogButtons[GPW],
		gData->bAnalogButtons[GPA],
		gData->bAnalogButtons[GPB],
		gData->bAnalogButtons[GPK]
	};

	switch(newstatus)
	{
	case notyet:
		for(i = 0; i < numtocheck; i++) {
			bs[i].stat = notyet;
		}

		roller = 0;
		for(i = 1; i < 6; i++) {
			otherdif[i] = 0x00;
		}
		otherdif[0] = 0xff;
		c = 0;

		DRAWALL();
		return notyet;
	case testme:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) {
				doh = TRUE;
			}
		}
		if(c < 6) {
			for(i = 0; i < 6; i++) {
				if(bs[c * 6 + i].stat != passed) {
					bs[c * 6 + i].stat = testme;
				}
			}
		}
		if(!doh) return passed;

#ifdef __HAMMERHEAD__
		if(data[c] == 0) 
			bs[c * 6 + 4].stat = passed;
		bs[c * 6 + 3].stat = passed;
		bs[c * 6 + 2].stat = passed;
		bs[c * 6 + 1].stat = passed;
		if (data[c] == 0xff) 
			bs[c * 6 + 0].stat = passed;
#else
		if(data[c] == 0) 
			bs[c * 6 + 4].stat = passed;
		else if (data[c] < 0x55) 
			bs[c * 6 + 3].stat = passed;
		else if (data[c] < 0xaa) 
			bs[c * 6 + 2].stat = passed;
		else if (data[c] < 0xff) 
			bs[c * 6 + 1].stat = passed;
		if (data[c] == 0xff) 
			bs[c * 6 + 0].stat = passed;
#endif
		

		doh2 = FALSE;
		for(i = 0; i < 6; i++) {
			otherdif[i] |= data[c] ^ data[i];
			if(otherdif[i] != 0xff) {
				doh2 = TRUE;
			}
		}

		roller |= rolb(data[c], 1) ^ data[c];
		if(!doh2 
			#ifndef __HAMMERHEAD__
				&& roller == 0xff
			#endif
			) {		
			bs[c * 6 + 5].stat = pending;
		}

		for(i = 0; i < 6; i++) {
			if(bs[i * 6 + 5].stat == pending) {
				if(bs[i * 6 + 4].stat == passed && data[i] == 0)
					bs[i * 6 + 5].stat = passed;
				else
					bs[i * 6 + 5].stat = pending;
			}
		}

		for(i = 0; i < 5; i++) {
			if(bs[c * 6 + i].stat != passed) goto doh2;
		}
		if(bs[c * 6 + 5].stat != passed && bs[c * 6 + 5].stat != pending) {
			goto doh2;
		}

		c++;
		for(i = 0; i < 6; i++) {
			otherdif[i] = 0;		
		}
		roller = 0;
		otherdif[c] = 0xff;
doh2:
		DRAWALL();
		drPrintf(0,0,L"X:%02x  Y:%02x  K:%02x  W:%02x  A:%02x  B:%02x  c:%d  ro:%02x  od: %02x %02x %02x %02x %02x %02x",
			data[2], data[3], data[4], data[5], data[0], data[1], c, roller, 
			otherdif[0], otherdif[1], otherdif[2], otherdif[3], otherdif[4], otherdif[5]);
		return testme;
	case failed:
		for(i = 0; i < numtocheck; i++) {
			if(bs[i].stat != passed) bs[i].stat = failed;
		}
		DRAWALL();
		return failed;
	case passed:
		DRAWALL();
		return passed;
	default:
		_asm int 3;
		return failed;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\thumbposition\thumb.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    thumb.cpp

Abstract:

    initializes global variables, contains main loop, init, and  test for the thumb positioning

Author:

    Bing Li (a-bingli) April 2001

Notes: This program can be modified to paint the screen using the thumb stick.
       Because OS has problems temporarily now, there are problems with pluging in and out. 
--*/

#include "xtl.h"
#include <stdio.h>
#include "dukeprod.h"
#include "ccl.h"
#include "device.h"
#include "draw.h"
#include "mmu.h"
#include "Tsc.h"

#define countof(_x_) (sizeof(_x_) / sizeof(_x_[0]))

BOXSTATUS gPadStatus[MAX_SLOTS];

/*************************************************************************************
Function:	init
Purpose:	performs all initialization routines for CPX
Params:		none
Out:		sets up the console window, control-pads, memory units, and cpx modes
Notes:		until direct3d is ported, the console window stuff is irrelevant...
*************************************************************************************/
void init()
{
	int i;

	DWORD dwRet;

    DebugPrint("Welcome to Duke Production Test: Built on %s at %s\n", __DATE__,__TIME__);

    //Initialize core peripheral port support
    XInitDevices(0,NULL);
    

	gpInit(0);
	drInit();
	//muInit();

	for(i = 0; i < MAX_SLOTS; i++) {
		gPadStatus[i] = notyet;
	}
	
	TscInit(0);

	DebugPrint("Done with initialization!\n");
}


void binginit()
{

	gpInit(0);
	drInit();
	//muInit();

	for(int i = 0; i < MAX_SLOTS; i++) {
		gPadStatus[i] = notyet;
	}
	
	TscInit(0);

	DebugPrint("Done with Bing initialization!\n");

}

/*************************************************************************************
Function:	deinit
Purpose:	de-initialize all cpx stuff (NONE, since we never should quit!)
Params:		none
Out:		un-registers the callbacks for controlpads and MUs, tells all cpx modes to quit
Notes:		We shouldn't ever go here, since xbox only has one process, & this is it...
*************************************************************************************/
void deinit()
{
	DebugPrint("Quitting???? ...");

//	gModeFunctions[gMode](STATUS_LEAVE, 0);
//	for(int i = 0; i < MAX_MODES; i++) {
//		gModeFunctions[i](STATUS_QUIT, 0);
//	}

	gpDeinit();
	drDeinit();
	//muDeinit();

	DebugPrint("Deinit is finished.\n");
	
}


/*************************************************************************************
Function:	test() is used to move thumb sticker around.
Params:		the slot number which device has been inserted
Notes:		until d3d is ported, it can't display the console...
*************************************************************************************/
 

gpGAMEPAD * gData;

int ratio = 32768 / 240; //map from -32678 - 32678 to 0 - 480
float length = 20.0;    //length of the cross
float area = 480.0 * 480.0;      //area of the total sqare

BOXSTATUS test(int slot)
{
	int i=0, j=0, flag=0;
	float enlarge=0, smallarea=0.0;
	__int64 tim;
	BOXSTATUS overall = passed;
	 
	float xl=0.0, yl=0.0, xr=0.0,yr=0.0;
	float width=140.0, high=15.0;

	
    float x1l=0.0, y1l=0.0, x1r=0.0,y1r=0.0;
	float x2l=0.0, y2l=0.0, x2r=0.0,y2r=0.0;
	float x3l=0.0, y3l=0.0, x3r=0.0,y3r=0.0;
	float x4l=0.0, y4l=0.0, x4r=0.0,y4r=0.0;


	BYTE datar=0, datal=0;

	gData = ::gpGetState(slot);

	drCls();
	
	 //loop until you plug out the device
		while(1) {
	 
		   gpUpdateDeviceStateInfo();				//update the button state info...

		   if(!::gpDeviceExists(slot))	{
				return failed; 
			}
			
		   gpPoll();
		   gData = ::gpGetState(slot);
             
           //we can go back to start another test to chose A or B to test Pad or ThumbStick
		   if(gData->bAnalogButtons[GPX]) return pending;

           xl =  (float)( gData->sThumbLX / ratio + 240);
           yl =  (float)((-1) * gData->sThumbLY / ratio + 240);
           xr =  (float)( gData->sThumbRX / ratio + 240);
           yr =  (float)((-1) * gData->sThumbRY / ratio + 240);

			 

          datal = gData->bAnalogButtons[GPL];
		  datar = gData->bAnalogButtons[GPR];

		  
		  //DebugPrint("Left Trigger: %d \n", datal);
          //DebugPrint("Right Trigger: %d \n", datar);

          

		  if((datal==0)&&(datar==0)) {  //draw normal cross
			  drCls();
			  length=20.0;
		  } else if(datar>0) {
			  drCls();   //clear the screen
			  flag=0;    //turn on to normal
		  }
		  else if(datal>0) {            // draw dots and keep it on the screen always
			  length=0.0;
			  //draw a black box to erase the old value, so we can update the new x, y
			  drQuad(490,20-high,0xff000000,490+width,20-high,0xff000000,490+width,20+high,0xff000000,490,20+high,0xff000000);
			  drQuad(490,40-high,0xff000000,490+width,40-high,0xff000000,490+width,40+high,0xff000000,490,40+high,0xff000000);
			  drQuad(490,120-high,0xff000000,490+width,120-high,0xff000000,490+width,120+high,0xff000000,490,120+high,0xff000000);
			  drQuad(490,140-high,0xff000000,490+width,140-high,0xff000000,490+width,140+high,0xff000000,490,140+high,0xff000000);
		  }

//draw a square to show the range 0-480
          drLine(0.0, 0.0, 480.0, 0.0, 0x000000ff);
          drLine(0.0, 479.0, 479.0, 479.0, 0x000000ff);
          drLine(0.0, 0.0, 0.0, 480.0, 0x000000ff);
          drLine(480.0,0.0, 480.0,480.0, 0x000000ff);


//draw a small square to show the center if start is pushed
		  if((gData->wButtons) & 16) {
			  flag=1;
			  enlarge++;             //push start will enlarge the center
		  } else if((gData->wButtons) & 32 ) {
			  enlarge--;              //puch back will make the center small
		  }

          if(flag) {

			  if(enlarge > 235) enlarge = 235;   //this is limited in the range
			  else if(enlarge<0) enlarge =0;

			  //set the range of the center
			  x1l=(float)(235.0 - enlarge);  y1l=(float)(235.0 - enlarge); x1r=(float)(245.0 + enlarge); y1r=(float)(235.0 - enlarge);
	          x2l=(float)(235.0 - enlarge);  y2l=(float)(245.0 + enlarge); x2r=(float)(245.0 + enlarge); y2r=(float)(245.0 + enlarge);
	          
			  // get covered part
			  smallarea = x1r - x2l ;

			  //print out how much percent length is covered
			  double c= 100.0 * ( smallarea / 480.0 ) ;
			  double s= ( 32768.0 * (x1r - 240.0) ) / 240.0;

			  drPrintf(490, 220, L"Percent Covered:");
			  drPrintf(490, 240, L"%4.2f",c);
			  drPrintf(490, 260, L"Size is %5.0f",s);

			  if( ((xl<x1r) && (xl>x1l)) && ((yl>y1l) && (yl<y2l)) ) drPrintf(490, 60, L"ZERO");

			  if( ((xr<x1r) && (xr>x1l)) && ((yr>y1l) && (yr<y2l)) ) {
				  drSetSize(8.0, 15.0, 0x0000ffff, 0xff000000); //set the color
			      drPrintf(490, 160, L"ZERO");
                  drSetSize(8.0, 15.0, 0xff00ff00, 0xff000000); //default color
			  }
              //draw the small square
			  drLine(x1l, y1l, x1r,y1r, 0xff0000ff);
              drLine(x2l, y2l, x2r,y2r, 0xff0000ff);
              drLine(x1l,y1l,x2l,y2l, 0xff0000ff);
              drLine(x1r,y1r,x2r,y2r, 0xff0000ff);
		  }


//draw a big red dot to show the center
          drQuad(235.0, 235.0, 0xffff0000, 245.0,  235.0, 0xffff0000, 245.0, 245.0, 0xffff0000, 235.0, 245.0, 0xffff0000);

//print out the value of x and y

         //left thumb
		 drPrintf(490,0,L"LeftThumb:");
         drPrintf(490,20,L"X=%d", gData->sThumbLX);
         drPrintf(490,40,L"Y=%d", gData->sThumbLY);

        // right thumb, print the same blue color as the line, reset the default color and then reset back again
         drSetSize(8.0, 15.0, 0x0000ffff, 0xff000000);
         drPrintf(490,100,L"RightThumb:");
         drPrintf(490,120,L"X=%d", gData->sThumbRX);
         drPrintf(490,140,L"Y=%d", gData->sThumbRY);
         drSetSize(8.0, 15.0, 0xff00ff00, 0xff000000); //default color

//draw a green cross for left thumb and a blue cross for right thumb
		 //left thumb
          drLine(xl-length, yl, xl+length, yl, 0x0000ff00);
          drLine(xl, yl-length, xl, yl+length, 0x0000ff00);
		 
		  //right thumb
          drLine(xr-length, yr, xr+length, yr, 0x0000ffff);
          drLine(xr, yr-length, xr, yr+length, 0x0000ffff);

  
        drShowScreen();



		}
	return overall;
}

/*************************************************************************
*Function: PadTest(int slot) is used to test the Game_Pad                *
*Para: int exiting duke slot                                             *
*Return: test status                                                     *
**************************************************************************/

int COUNT = 20;
float xmove = 32.0, ymove = 24.0;

BOXSTATUS PadTest(int slot)
{

	float xl=0,yl=0, xr=0,yr=0,xdl=0,ydl=0,xdr=0,ydr=0;
	float minxy=0,maxx=640.0, maxy = 480.0;
	float xleft=0,yleft=0,xright=0,yright=0;
	 
	int count=0;
	BOXSTATUS overall = passed; //default as passed

    gData = ::gpGetState(slot);
    
	drCls();
	
	//draw a center first 
	for(count=0; count<20;count++) {
	 
		drLine(xleft, minxy, xleft, maxy, 0x000000ff);		
		drLine(minxy, yright, maxx, yright, 0x000000ff);
        
		xleft+=xmove;
		yright+=ymove;
	}

    drLine(xleft-2, minxy, xleft-2, maxy, 0x000000ff);		
    drLine(minxy, yright-2, maxx, yright-2, 0x000000ff);

	xl=(float)(320.0-xmove); yl=(float)(240.0-ymove);xr=320.0;yr=(float)(240.0-ymove);
    xdr=320.0;ydr=240.0;xdl=(float)(320.0-xmove);ydl=240.0;

    drQuad(xl, yl, 0xff00ff00, xr, yr,0xff00ff00, 
		           xdr, ydr, 0xff00ff00, xdl, ydl, 0xff00ff00);
    drShowScreen();
   
	// loop until we want to quit. we have a bug now, we have to start the application after remove the device
	while(1) {
		
		  gpUpdateDeviceStateInfo();				//update the button state info...

		   if(!::gpDeviceExists(slot))	{
				return failed; 
			}
			
		   gpPoll();
		   gData = ::gpGetState(slot);

		   //we can start another test to chose A or B to test Pad or ThumbStick
		   if(gData->bAnalogButtons[GPX]) return pending;

		   //no action taken, waiting to new action
           if(!gData->wButtons) continue;

		    
		   //move 
		   if(gData->wButtons == XINPUT_GAMEPAD_DPAD_UP) {    
               yl-=ymove;
			   yr-=ymove;
			   ydl-=ymove;
			   ydr-=ymove;

		   } else if(gData->wButtons == XINPUT_GAMEPAD_DPAD_DOWN)  {   
               yl+=ymove;
			   yr+=ymove;
			   ydl+=ymove;
			   ydr+=ymove;
		   } else if(gData->wButtons == XINPUT_GAMEPAD_DPAD_LEFT) {
			    
               xl-=xmove;
			   xr-=xmove;
			   xdl-=xmove;
			   xdr-=xmove;

		   } else if(gData->wButtons == XINPUT_GAMEPAD_DPAD_RIGHT) {
			    
			   xl+=xmove;
			   xr+=xmove;
			   xdl+=xmove;
			   xdr+=xmove;
		   } else if(gData->wButtons == (XINPUT_GAMEPAD_DPAD_UP + XINPUT_GAMEPAD_DPAD_LEFT)) {
			    
               yl-=ymove;
			   yr-=ymove;
			   ydl-=ymove;
			   ydr-=ymove;
               xl-=xmove;
			   xr-=xmove;
			   xdl-=xmove;
			   xdr-=xmove;
		   }  else if( gData->wButtons == ( XINPUT_GAMEPAD_DPAD_UP + XINPUT_GAMEPAD_DPAD_RIGHT)) {
			   DebugPrint("UpRight \n");
			   yl-=ymove;
			   yr-=ymove;
			   ydl-=ymove;
			   ydr-=ymove;
               xl+=xmove;
			   xr+=xmove;
			   xdl+=xmove;
			   xdr+=xmove;
		   }  else if( gData->wButtons ==( XINPUT_GAMEPAD_DPAD_DOWN + XINPUT_GAMEPAD_DPAD_LEFT) ) { 
			   DebugPrint("Down Left \n");
               yl+=ymove;
			   yr+=ymove;
			   ydl+=ymove;
			   ydr+=ymove;
               xl-=xmove;
			   xr-=xmove;
			   xdl-=xmove;
			   xdr-=xmove;
		   } else if(gData->wButtons == (XINPUT_GAMEPAD_DPAD_DOWN + XINPUT_GAMEPAD_DPAD_RIGHT)) {
               yl+=ymove;
			   yr+=ymove;
			   ydl+=ymove;
			   ydr+=ymove;
			   xl+=xmove;
			   xr+=xmove;
			   xdl+=xmove;
			   xdr+=xmove;

		   }  
		   
		   // set limitation 
		   if(xl<0) { 
			   xl=0;
			   xr=xmove;
			   xdl=0;
			   xdr=xmove;
		   }

		   if(xr>640) {
			   xr=xdr=639;
			   xl=xdl=640-xmove;
		   }

		   if(yl<0) {
			   yl=yr=0;
			   ydl=ydr=ymove;
		   }

		   if(ydl>480) {
			   yl=yr=480-ymove;
			   ydl=ydr=479;
		   }	   
			   
		    //draw a now position         
		  drCls();
		   
	      drQuad(xl, yl, 0xff00ff00, xr, yr,0xff00ff00,xdr, ydr, 0xff00ff00, xdl, ydl, 0xff00ff00);

		  xleft=0;yleft=0;xright=0;yright=0;
		  for(count=0; count<20;count++) {
			      drLine(xleft, minxy, xleft, maxy, 0x000000ff);		
		          drLine(minxy, yright, maxx, yright, 0x000000ff);
			      xleft+=xmove;
			      yright+=ymove;
		   }
          drLine(xleft-2, minxy, xleft-2, maxy, 0x000000ff);		
          drLine(minxy, yright-2, maxx, yright-2, 0x000000ff);
		  drShowScreen();

	}

	//never be here
	return overall;


}
	 


/**************************************************
*Main Function
***************************************************/
int __cdecl main()
{
//	_asm int 3;

	int i;

	init();

Start:
	gpPoll();
	 
	drCls();
	drPrintf(10, 20, L"Press A To Test Pad");
	drPrintf(10, 40, L"Press B To Test Thumb");
	drShowScreen();

     
	while(1) //loop until we're supposed to quit...
	{
		gpUpdateDeviceStateInfo();				//update the button state info...
		//muGetDeviceMessages();
          
		
		for(i = 0; i < MAX_SLOTS; i++) {
			if(!gpDeviceExists(i)) {
				::gPadStatus[i] = notyet;
				 
			} else if (gPadStatus[i] == notyet) {
                
				gpPoll();
		        gData = ::gpGetState(i);

				if(gData->bAnalogButtons[GPA]) { 
					gPadStatus[i]=PadTest(i);
					if(gPadStatus[i] == pending ) {
					    gPadStatus[i]=notyet;
						goto Start;
					}

				} else if(gData->bAnalogButtons[GPB])	{
					if((gPadStatus[i] = test(i))== pending) {
					    gPadStatus[i]=notyet;
						goto Start;
					}
				}
            	else continue;

				drCls();

				// this will be always failed now, we just use this as a sign to show whether the device is inserted.
				if(gPadStatus[i] == passed) {
					//passed
					drQuad(250, 350, 0xff00ff00, 550,  50, 0xff00ff00, 600, 100, 0xff00ff00, 300, 400, 0xff00ff00);
					drQuad(250, 450, 0xff00ff00, 300, 400, 0xff00ff00, 150, 250, 0xff00ff00, 100, 300, 0xff00ff00);
				} else {
					//failed
					drQuad(200, 400, 0xffff0000, 550,  50, 0xffff0000, 600, 100, 0xffff0000, 250, 450, 0xffff0000);
					drQuad(600, 400, 0xffff0000, 250,  50, 0xffff0000, 200, 100, 0xffff0000, 550, 450, 0xffff0000);
				}
				drShowScreen();
			}
		}
	}
 

	//we should theoretically never get here on xbox......

	deinit();


	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\thumbposition\dukeprod.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cpx.h

Abstract:

    function declarations, type definitions, includes, etc, for Control Panel X

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __cpx_h_
#define __cpx_h_

//#include <windef.h>
//#include "ccl.h"
//#include "modes.h"

#ifndef UNICODE
#define UNICODE
#endif

#ifdef __cplusplus
extern "C" {
#endif
int DebugPrint(char* format, ...);
#ifdef __cplusplus
}
#endif

#define MAX_SLOTS XGetPortCount()
//typedef enum {none, tested} padstatus;
typedef enum {notyet, testme, pending, failed, passed} BOXSTATUS;
typedef BOXSTATUS (*BOXFUNC)(BOXSTATUS newstatus);
extern BOXSTATUS gPadStatus[MAX_SLOTS];

#include "dp.h"
#include "device.h"

extern BOXFUNC gBoxFuncs[];
extern gpGAMEPAD * gData;


#endif //!defined (__cpx_h_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\cpx\xpong\xpongmain.cpp ===
#include <xtl.h>


#include "device.h"
#include "draw.h"
#include "modes.h"
#include "xpong.h"

extern "C" ULONG DebugPrint(PCHAR Format, ...);

//extern "C" int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow)
int __cdecl main()
{
    //Initialize core peripheral port support
    XInitDevices(0,NULL);
    
    gpInit(1);		//initialize device stuff, do control-pad remapping
	drInit();		//initialize drawing routines
		
	XPong(STATUS_BOOT, 0);	//initialize pong	
	XPong(STATUS_ENTER, 1);	//initialize pong, step 2, and 

    while(1) { //for(int i = 0; i < 30; i++) {
		gpUpdateDeviceStateInfo();				//update the button state info...
		gpPoll();								//query for the next button states
		drCls();								//clear the screen
		XPong(STATUS_NORMAL, 0);				//update pong state
		drShowScreen();							//and draw the screen
	}

	XPong(STATUS_LEAVE, 1);	//deinitialize pong
	XPong(STATUS_QUIT, 0);	//quit pong

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\cworkerthread.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    CWorkerThread.h

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

--*/

#ifndef _CWORKERTHRAD_H_
#define _CWORKERTHRAD_H_

#include "deviceSrv.h"
#include <process.h>    /* _beginthread, _endthread */

namespace DeviceServer {

static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

/*++

Class Description:

    Worker thread class

Methods:



Data:



NOTE: 
    
    Remember to nest any member read/write with Lock and Unlock 

    In the implementation of the ThreadFunct function, the user must check 
        the bExit flag and exit gracefully if set.

--*/
class CWorkerThread
    {
    private:
        CRITICAL_SECTION criter;
        DWORD dwThreadHandle;
        DWORD dwThreadID;
        DWORD dwThreadExitCode;

    protected:
        BOOL bExit;

        DWORD dwLocalThreadID;

        // exit notification params
        HWND notifyWindow;
        UINT notifyMsg;
        LPARAM notifylParam;

    // constructors / destructors
    public:
        CWorkerThread();
        CWorkerThread(DWORD localID);
        ~CWorkerThread();

    // public access and information
    public:
        void Lock(void) { EnterCriticalSection(&criter); }
        void Unlock(void) { LeaveCriticalSection(&criter); }

        #ifdef _WIN32_WINNT
        BOOL Lock(DWORD dwTimeOut);
        #endif

        DWORD GetThreadHandle(void) { Lock(); DWORD h = dwThreadHandle; Unlock(); return h; }
        DWORD GetThreadID(void) { Lock(); DWORD id = dwThreadID; Unlock(); return id; }
        DWORD GetLocalThreadID(void) { Lock(); DWORD id = dwLocalThreadID; Unlock(); return id; }
        void  SetLocalThreadID(DWORD id) { Lock(); dwLocalThreadID = id; Unlock(); }
        DWORD GetThreadExitCode(void) { Lock(); DWORD e = dwThreadExitCode; Unlock(); return e; }
        BOOL  GetExitFlag(void) { Lock(); BOOL e = bExit; Unlock(); return e; }
        void  SetExitFlag(BOOL b) { Lock(); bExit = b; Unlock(); }

        void Run(void);
        BOOL SoftBreak(DWORD dwTimeOut);
        BOOL HardBreak(void);

        BOOL WaitForExit(DWORD dwTimeOut);

        // thread manipulation
        DWORD SuspendThread(void);
        DWORD ResumeThread(void);

        // notifications
        void SetExitNotify(HWND notifyDestination, UINT message, LPARAM lParam);

    // internal functions
    private:
        void SetThreadHandle(DWORD h) { Lock(); dwThreadHandle = h; Unlock(); }
        void SetThreadID(DWORD id) { Lock(); dwThreadID = id; Unlock(); }
        void SetThreadExitCode(DWORD c) { Lock(); dwThreadExitCode = c; Unlock(); }

        friend DWORD WINAPI LocalThreadFunct(LPVOID lpParameter);

    // overrideable functions
    public:
        /*
        NOTE: in the implementation of this function, the user must check 
               the bExit flag and exit gracefully if set:
        while(1)
            {
            if(GetExitFlag()) break;
            }
        */
        virtual DWORD ThreadFunct(void) { return 0; }
    };

} // namespace DeviceServer
#endif // _CWORKERTHRAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\deviceSrv.h ===
/*

deviceSrv.h

*/

#ifndef _DEVICESRV_H_
#define _DEVICESRV_H_

#define CLEARFLAG(var, flag)                (var &= ~(flag))
#define SETFLAG(var, flag)                  (var |=  (flag))
#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)

#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>

int SockPrint(SOCKET sock, char* format, ...);
void DebugPrint(char* format, ...);
bool stristr(char *string, char *substr, size_t len=0);


#endif // _DEVICESRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\cworkerthread.cpp ===
/*

Copyright (C) 1999 Microsoft Corporation

Module Name:

    CWorkerThread.cpp

Abstract:

    

Author:

    Josh Poley (jpoley) 1-1-1999

Revision History:

*/


#include "CWorkerThread.h"

namespace DeviceServer {

/*****************************************************************************

Routine Description:

    LocalThreadFunct

Arguments:

    LPVOID lpParameter  - a valid CWorkerThread class

Return Value:

    0 on error, ~0 on execption, or the thread's exit value

Notes:


*****************************************************************************/
static DWORD WINAPI LocalThreadFunct(LPVOID lpParameter)
    {
    DWORD returnCode = 0;
    HWND window = NULL;
    UINT msg = 0;
    LPARAM lparam = 0;
    CWorkerThread *localPointer = (CWorkerThread*)lpParameter;

    if(!localPointer)
        {
        // a valid CWorkerThread class must be supplied via the lpParameter!
        //_ASSERT(localPointer);
        return 0;
        }

    // turn off the exit flag and set notification values
    localPointer->Lock();
    localPointer->bExit = FALSE;
    window = localPointer->notifyWindow;
    msg = localPointer->notifyMsg;
    lparam = localPointer->notifylParam;
    localPointer->Unlock();

    // set the thread id
    localPointer->SetThreadID(GetCurrentThreadId());

    // run the main thread function (this is the custom function)
#ifdef _DEBUG
    returnCode = localPointer->ThreadFunct();
#else
    //try
        {
        returnCode = localPointer->ThreadFunct();
        }
    //catch(...)
    //    {
    //    returnCode = ~0;
    //    }
#endif

    // invalidate the thread handle & id
    localPointer->SetThreadID(~0);
    localPointer->SetThreadHandle(~0);

    // store the return code from the main thread function
    localPointer->Lock();
    localPointer->dwThreadExitCode = returnCode;
    localPointer->Unlock();

    // send notification if necessary
    if(window)
        {
        //PostMessage(window, msg, (WPARAM)returnCode, lparam);
        }

    // exit thread
    return returnCode;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::Run
    start up a worker thread

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
void CWorkerThread::Run(void)
    {
    DWORD handle = _beginthread((void (__cdecl *)(void *))LocalThreadFunct, 0, this);
    SetThreadHandle(handle);
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    none

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread()
    {
    InitializeCriticalSection(&criter);
    SetThreadHandle(~0);
    SetThreadID(~0);

    Lock();

    notifyWindow = NULL;
    notifyMsg = 0;
    notifylParam = 0;

    dwLocalThreadID = 0;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::CWorkerThread
    worker thread data constructor

Arguments:

    DWORD localID

Return Value:

    none

Notes:

*****************************************************************************/
CWorkerThread::CWorkerThread(DWORD localID)
    {
    InitializeCriticalSection(&criter);
    SetThreadHandle(~0);
    SetThreadID(~0);

    Lock();

    notifyWindow = NULL;
    notifyMsg = 0;
    notifylParam = 0;
    
    dwLocalThreadID = localID;

    bExit = FALSE;
    dwThreadExitCode = 0;

    Unlock();
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::~CWorkerThread
    worker thread data destructor

Arguments:

    none

Return Value:

    none

Notes:

    If the thread does not exit, this function will be caught in an infinate 
        loop.

*****************************************************************************/
CWorkerThread::~CWorkerThread()
    {
    if(GetThreadHandle() != ~0)
        {
        DWORD timeout = 1000; // start with 1 sec

        // if your code infinite loops here, you have a blocking problem
        while(!SoftBreak(timeout))
            {
            timeout *= 2;
            if(timeout == 64000) OutputDebugStringA("CWorkerThread::~CWorkerThread(): Possible deadlock\n");
            }
        }

    DeleteCriticalSection(&criter);
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::SoftBreak

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timedout before the thread exited

Notes:

*****************************************************************************/
BOOL CWorkerThread::SoftBreak(DWORD dwTimeOut)
    {
    Lock();
    bExit = TRUE;
    Unlock();

    return WaitForExit(dwTimeOut);
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::HardBreak

Arguments:

    none

Return Value:

    TRUE - operation succedded, FALSE - the operation failed.

Notes:

    This function does not perform any locking or unlocking.

    WARNING: Do not use this function execpt in DIRE situations. This WILL 
        cause leaks, and perhaps blocking or crashes if critical sections 
        are not released!

*****************************************************************************/
BOOL CWorkerThread::HardBreak(void)
    {
    DWORD dwHandle = dwThreadHandle;
    bExit = TRUE;
    dwThreadHandle = ~0;
    dwThreadExitCode = ~0;
    dwThreadID = ~0;

    if(dwHandle != ~0)
        {
        OutputDebugStringA("CWorkerThead::HardBreak() called!\n");
        //
        // schanbai 11/20/2000
        // comment out as there is no TerminateThread under Xbox
        //
#if 0
        return TerminateThread((void*)dwHandle, ~0);
#else
        return FALSE;
#endif
        }

    return FALSE;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::WaitForExit

Arguments:

    DWORD dwTimeOut - timeout value in ms

Return Value:

    TRUE - the thread exited, FALSE - timeout was reached

Notes:

*****************************************************************************/
BOOL CWorkerThread::WaitForExit(DWORD dwTimeOut)
    {
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(GetThreadHandle() != ~0)
        {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
            {
            return FALSE;
            }
        }

    return TRUE;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::Lock

Arguments:

    DWORD dwTimeOut - timeout value in ms
   
Return Value:

    TRUE - critical section entered, FALSE - timeout

Notes:

*****************************************************************************/
#ifdef _WIN32_WINNT // TryEnterCriticalSection only available on NT
#include "winbase.h"
BOOL CWorkerThread::Lock(DWORD dwTimeOut)
    {
    DWORD dwStartTime = GetTickCount();
    DWORD dwCurTime;

    while(!TryEnterCriticalSection(&criter))
        {
        Sleep(20);
        dwCurTime = GetTickCount();
        if(dwCurTime - dwStartTime >= dwTimeOut)
            {
            return FALSE;
            }
        }

    return TRUE;
    }
#endif


/*****************************************************************************

Routine Description:

    CWorkerThread::SetExitNotify

Arguments:

    HWND   notifyDestination  - handle to the destination window
    UINT   message            - the message to send
    LPARAM lParam             - custom parameter to send

Return Value:

    none

Notes:

    WPARAM of the message is always the return code for the thread

*****************************************************************************/
void CWorkerThread::SetExitNotify(HWND notifyDestination, UINT message, LPARAM lParam)
    {
    Lock();
    notifyWindow = notifyDestination;
    notifyMsg = message;
    notifylParam = lParam;
    Unlock();
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::SuspendThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API SuspendThread

*****************************************************************************/
DWORD CWorkerThread::SuspendThread(void)
    {
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != ~0)
        {
        return ::SuspendThread((void*)dwHandle);
        }

    return 0xFFFFFFFF;
    }


/*****************************************************************************

Routine Description:

    CWorkerThread::ResumeThread

Arguments:

    none

Return Value:

    DWORD - the thread's suspend count, 0xFFFFFFFF on error.

Notes:

    This function just calls the WIN API ResumeThread

*****************************************************************************/
DWORD CWorkerThread::ResumeThread(void)
    {
    DWORD dwHandle = GetThreadHandle();

    if(dwHandle != ~0)
        {
        return ::ResumeThread((void*)dwHandle);
        }

    return 0xFFFFFFFF;
    }
} // namespace DeviceServer
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\csockserver.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CSockServer.h

Abstract:

    This class will allow the creation of the Winsock Server object that
    can send and receive data within it's own thread.

Author:

    Jim Helm (jimhelm)
    Josh Poley (jpoley)

Environment:

    XBox


*/
#ifndef _CSOCKSERVER_H_
#define _CSOCKSERVER_H_

#include "deviceSrv.h"
#include <winsockx.h>
#include <xnetref.h>
#include "CWorkerThread.h"

namespace DeviceServer {

class CSockServer : public CWorkerThread
    {
    private:
        SOCKET m_socket;                                        // Socket used to "listen" for connections
        SOCKET m_remotesocket;                                  // Socket returned by "accepted" connections
        sockaddr_in m_sockaddr;                                 // Our Sock Address structure
        USHORT m_port;                                          // Port of our current server
        unsigned m_uTimeoutSec;                                 // idle timeout length

        int GetSocket(int af=AF_INET,
                    int socktype=SOCK_STREAM,
                    int protocol=IPPROTO_TCP);                  // Get our socket

    public:
        int m_socktype;

    public:
        CSockServer();                                          // Constructor
        ~CSockServer();                                         // Destructor

    public:
        virtual DWORD ThreadFunct(void);                        // Thread function to handle accepting connections

    public:
        int BindSocket();                                       // Bind or Name our socket
        int OpenServerSocket(int socktype);                     // Create the socket for our server
        int CloseSocket(SOCKET s);                              // Close our socket
        BOOL IsDataAvailable(SOCKET s);

        USHORT GetPort(void) { Lock(); USHORT usTemp = m_port; Unlock(); return (usTemp); }
        void SetPort(USHORT usNewPort) { Lock(); m_port = usNewPort; Unlock(); }
        unsigned GetTimeout(void) { Lock(); unsigned usTemp = m_uTimeoutSec; Unlock(); return (usTemp); }
        void SetTimeout(unsigned timeout) { Lock(); m_uTimeoutSec = timeout; Unlock(); }
    };

} // namespace DeviceServer 

#endif // _CSOCKSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\csockserver.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CSockServer.cpp

Abstract:

    This class will allow the creation of the Winsock Server object that
    can send and receive data within it's own thread.

Author:

    Jim Helm (jimhelm)
    Josh Poley (jpoley)

Environment:

    XBox

*/
#include "CSockServer.h"

void HandleRequest(SOCKET sock);

namespace DeviceServer {

CSockServer::CSockServer()
    {
    m_port = 20;
    m_socket = NULL;
    m_remotesocket = NULL;
    m_socktype = SOCK_STREAM;
    m_uTimeoutSec = 60;

    XNetAddRef();

    WSADATA wsaData;
    unsigned short version = MAKEWORD(2, 2);
    WSAStartup(version, &wsaData);
    }

CSockServer::~CSockServer()
    {
    CloseSocket(m_socket);
    WSACleanup();
    XNetRelease();
    }

int CSockServer::BindSocket()
    {
    int nReturnVal=0;						// Return Value for BindSocket()

    m_sockaddr.sin_family = AF_INET;
    m_sockaddr.sin_port = htons(GetPort());
    m_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    nReturnVal = bind(m_socket, (LPSOCKADDR)&m_sockaddr, sizeof(SOCKADDR));
    if(SOCKET_ERROR == nReturnVal)
        {
        //nReturnVal = WSAGetLastError();
        DebugPrint("BindSocket: WS Last Error : %d\n", WSAGetLastError());
        }

    return (nReturnVal);
    }


// Close our Socket
int CSockServer::CloseSocket(SOCKET s)
    {
    Lock();

    // Shutdown the socket (will fail if not connected)
    shutdown(s, SD_BOTH);

    // Close the socket
    closesocket(s);
    Unlock();

    return 0;
    }


// Get our Socket
int CSockServer::GetSocket(int af, int socktype, int protocol)
    {
    int nReturnVal=0;		// Return value for GetSocket()

    m_socket = socket(af, socktype, protocol);
    if(INVALID_SOCKET == m_socket)
        {
        //nReturnVal=WSAGetLastError();
        DebugPrint("GetSocket Last WS Error: %s\n", WSAGetLastError());
        }

    return nReturnVal;
    }


// Create our server socket
int CSockServer::OpenServerSocket(int socktype)
    {
    int nReturnVal;
    
    if(socktype == SOCK_DGRAM) nReturnVal = GetSocket(AF_INET, socktype, 0);
    else nReturnVal = GetSocket(AF_INET, socktype, IPPROTO_TCP);

    return nReturnVal;
    }

BOOL CSockServer::IsDataAvailable(SOCKET s)
    {
    TIMEVAL timeout = { m_uTimeoutSec, 0 };
    FD_SET bucket;
    bucket.fd_count = 1;
    bucket.fd_array[0] = s;

    int err = select(0, &bucket, NULL, NULL, &timeout);
    if(err == 0 || err == SOCKET_ERROR)
        {
        return FALSE;
        }

    return TRUE;
    }

// Thread code for our Winsock Server
DWORD CSockServer::ThreadFunct(void)
    {
	DWORD nReturnVal=0;				// Return Value of ThreadFunct()
    DWORD count = 0;

	while(!GetExitFlag())
        {
        if(m_socktype == SOCK_STREAM)
            {
            if(SOCKET_ERROR == listen(m_socket, 1))
                {
                DebugPrint("DEVICESRV: listen failed: ec=%lu\n", WSAGetLastError());
                break;
                }
            else
                {
                //DebugPrint("DEVICESRV: Waiting for a connection on port %u... (%u)\n", GetPort(), ++count);
                m_remotesocket = accept(m_socket, NULL, NULL);
                if(INVALID_SOCKET == m_remotesocket)
                    {
                    DebugPrint("DEVICESRV: connection failed: ec=%lu\n", WSAGetLastError());
                    continue;
                    }
                else
                    {
                    // turn off the time wait delay after closing the socket
                    linger noTimeWait = { true, 0 };
                    setsockopt(m_remotesocket, SOL_SOCKET, SO_LINGER, (char*)&noTimeWait, sizeof(noTimeWait));

                    Lock();
                    HandleRequest(m_remotesocket);
                    Unlock();

                    Sleep(25);
                    CloseSocket(m_remotesocket);
                    }
                }
            }
        }

    return nReturnVal;
    }

} // namespace DeviceServer
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\iString.cpp ===
#include "iString.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h> 
#include <malloc.h>
#include <xtl.h>

iString::iString()
    {
    str = end = NULL;
    bufferSize = 0;
    aggressive = false;
    }

iString::iString(unsigned initialSize)
    {
    str = end = NULL;
    bufferSize = 0;
    aggressive = false;
    Grow(initialSize);
    }

iString::~iString()
    {
    if(allocated) free(str);
    }

void* iString::Grow(unsigned count /*=0*/)
    {
    if(bufferSize == 0)
        {
        bufferSize = count?count:16;
        str = (char*)malloc(bufferSize);
        if(!str) return NULL;
        *str = '\0';
        end = str + 1;
        allocated = true;
        return str;
        }

    // adjust buffer size
    if(aggressive || count != 0) bufferSize += count?count:16;
    else bufferSize = bufferSize << 1;

    // allocate, copy, and free
    char *temp;
    unsigned size = length();
    if(allocated)
        {
        // Note: this is MUCH faster than the standard: new, memcpy, delete
        temp = (char*)realloc(str, bufferSize);
        }
    else
        {
        temp = (char*)malloc(bufferSize);
        if(!temp) return NULL;
        memcpy(temp, str, size+1); // +1 for the NULL char
        allocated = true;
        }

    str = temp;
    end = str + size;
    return str;
    }

void iString::Attach(char *src)
    {
    if(allocated) free(str);
    allocated = false;
    str = src;
    bufferSize = ::strlen(str) + 1;
    end = str + bufferSize - 1;
    }

unsigned iString::Hash(void)
    {
    char *ptr = str;
    unsigned hash = 0;

    while(*ptr)
        {
        hash += (hash << 5) + *ptr++;
        }

    return hash;
    }

char* iString::sprintf(char *format, ...)
    {
    va_list args;
    va_start(args, format);

    int count;

    if(!str) Grow(); // cause _vsnprintf sucks

    while((count = _vsnprintf(str, bufferSize, format, args)) == -1)
        Grow();

    end = str + count;
    va_end(args);

    // deal with bug in _vsnprintf where terminating NULL char is omitted if string just fits
    if(*end != '\0')
        {
        Grow();
        *end = '\0';
        }

    return str;
    }

char* iString::scatf(char *format, ...)
    {
    va_list args;
    va_start(args, format);

    int count;

    if(!str) Grow(); // cause _vsnprintf sucks

    while((count = _vsnprintf(end, bufferSize-length(), format, args)) == -1)
        Grow();

    end += count;
    va_end(args);

    // deal with bug in _vsnprintf where terminating NULL char is omitted if string just fits
    if(*end != '\0')
        {
        Grow();
        *end = '\0';
        }

    return str;
    }

char* iString::strcpy(const char *src)
    {
    unsigned len = ::strlen(src);

    if(len+1 > bufferSize)
        {
        // no need to copy memory around when we will just write over it
        end = str;
        Grow(len+1);
        }

    memcpy(str, src, len+1);
    end = str + len;

    return str;
    }

char* iString::strcat(const char *src)
    {
    unsigned len = ::strlen(src);

    if(length()+len+1 > bufferSize) Grow(length()+len+1 - bufferSize);

    memcpy(end, src, len+1);
    end += len;

    return str;
    }

char* iString::strncpy(const char *src, unsigned len)
    {
    if(len+1 > bufferSize)
        {
        // no need to copy memory around when we will just write over it
        end = str;
        Grow(len+1);
        }

    memcpy(str, src, len+1);
    end = str + len;

    return str;
    }

char* iString::strncat(const char *src, unsigned len)
    {
    if(length()+len+1 > bufferSize) Grow(length()+len+1 - bufferSize);

    memcpy(end, src, len+1);
    end += len;

    return str;
    }

char* iString::strrchr(int ch)
    {
    if(!end) return NULL;

    char *string = end;

    while(--string != str && *string != (char)ch)
        {
        }

    if(*string == (char)ch)
        return (char *)string;

    return NULL;
    }

void iString::DebugPrint(void)
    {
    OutputDebugStringA(str);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\deviceSrv.cpp ===
#include "deviceSrv.h"
#include "CSockServer.h"
#include "USBManager.h"
#include "iString.h"

void ErrorPage(SOCKET sock, unsigned code);
void GETConnected(SOCKET sock, char *url);

USBManager *usbmanager;
DeviceServer::CSockServer *server;

char *helpText = "The following 'pages' are recognized:<BR>&nbsp;connect.txt<BR><P>";
char *htmlHeader = "<STYLE>BODY { color:000000; background-color:FFFFFF; font:normal 12pt Arial; }</STYLE>";

void __cdecl main(void)
    {
    XInitDevices(0, NULL);

    server = new DeviceServer::CSockServer;
    usbmanager = new USBManager;

    if(!server)
        {
        DebugPrint("ERROR: Out of memory!\n");
        return;
        }

    server->SetPort(80);
    server->SetTimeout(1000);
    server->m_socktype = SOCK_STREAM;
    server->OpenServerSocket(server->m_socktype);
    server->BindSocket();
    server->Run();

    DebugPrint("Main Loop is Running\n");
    usbmanager->CheckForHotplugs();
    while(1)
        {
        // check for new devices
        server->Lock();
        usbmanager->CheckForHotplugs();
        server->Unlock();


        SleepEx(80, true);
        }

    delete server;

    DebugPrint("END\n");
    while(1) {}
    }


void HandleRequest(SOCKET sock)
    {
    char request[1024];
    char method[16];
    char url[512];

    if(server->IsDataAvailable(sock))
        recv(sock, request, 1024, 0);
    else
        return;

    sscanf(request, "%s %s", method, url);

    if(stricmp(method, "GET") != 0)
        {
        ErrorPage(sock, 405); // invalid "Method"
        return;
        }

    if(stristr(url, "connect.") == true)
        {
        GETConnected(sock, url);
        }
    else
        {
        ErrorPage(sock, 404);
        }
    }

void ErrorPage(SOCKET sock, unsigned code)
    {
    iString response;
    iString fullResponse;
    response.sprintf("<HTML><HEAD>\r\n");
    response.scatf("%s\r\n", htmlHeader);
    response.scatf("<TITLE>Device Server Error</TITLE></HEAD><BODY>\r\n");
    response.scatf("<B>%u</B><P>\r\n", code);
    response.scatf("%s\r\n", helpText);
    response.scatf("</BODY></HTML>\r\n");

    fullResponse.sprintf("HTTP/1.1 %u\r\n", code);
    fullResponse.scatf("Content-Length: %u\r\n", response.length());
    fullResponse.scatf("Content-Type: text/html\r\n");
    fullResponse.scatf("Connection: close\r\n");
    fullResponse.scatf("\r\n");
    fullResponse.scatf("%s", response.str);
    send(sock, fullResponse.str, fullResponse.length(), 0);
    }

void GETConnected(SOCKET sock, char *url)
    {
    iString response;
    iString fullResponse;
    XINPUT_CAPABILITIES info;

    const char *xidSubTypes[] = {
        "",
        "GAMEPAD",
        "JOYSTICK",
        "WHEEL",
        "DANCE PAD",
        "FISHING ROD",
        "LIGHT GUN"
        };

    response.sprintf("\r\n");

    response.scatf("Port, Slot, Device, Notes;\r\n");
    for(unsigned i=0; i<XGetPortCount(); i++)
        {
        for(unsigned j=0; j<SLOT_MAX; j++)
            {
            if(usbmanager->devices[i][j] != NULL)
                {
                response.scatf("%u, %u", i, j);
                if(XDEVICE_TYPE_GAMEPAD == usbmanager->devices[i][j]->type)
                    {
                    XInputGetCapabilities(((DeviceDuke*)(usbmanager->devices[i][j]))->duke, &info);
                    response.scatf(", XID");
                    response.scatf(", %s;\r\n", xidSubTypes[info.SubType]);
                    }
                else if(XDEVICE_TYPE_MEMORY_UNIT == usbmanager->devices[i][j]->type)
                    {
                    response.scatf(", MU");
                    response.scatf(", %c;\r\n", (char)((DeviceMU*)(usbmanager->devices[i][j]))->drive);
                    }
                else if(XDEVICE_TYPE_VOICE_MICROPHONE == usbmanager->devices[i][j]->type)
                    {
                    response.scatf(", HAWK");
                    response.scatf(", \"\";\r\n");
                    }
#ifdef DEBUG_KEYBOARD
                else if(XDEVICE_TYPE_DEBUG_KEYBOARD == usbmanager->devices[i][j]->type)
                    {
                    response.scatf(", KEYBOARD");
                    response.scatf(", \"\";\r\n");
                    }
#endif // DEBUG_KEYBOARD
                else
                    {
                    response.scatf(", UNKNOWN");
                    response.scatf(", \"\";\r\n");
                    }
                }
            }
        }

    //DebugPrint("Content-Length: %u\r\n", response.length());

    fullResponse.sprintf("HTTP/1.1 200 OK\r\n");
    fullResponse.scatf("Content-Length: %u\r\n", response.length());
    fullResponse.scatf("Content-Type: text/plain\r\n");
    fullResponse.scatf("Connection: close\r\n");
    fullResponse.scatf("\r\n");
    fullResponse.scatf("%s", response.str);
    send(sock, fullResponse.str, fullResponse.length(), 0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\iString.h ===
#ifndef _ISTRING_H_
#define _ISTRING_H_

class iString
    {
    public:
        char *str;
        char *end;
        unsigned bufferSize;
        bool aggressive;
        bool allocated;

    public:
        iString();
        iString(unsigned initialSize);
        ~iString();

    public:
        void* Grow(unsigned count = 0);
        unsigned length(void) { return end-str; }
        operator char*() { return str; }
        void Attach(char *src);
        unsigned Hash(void);

    public:
        size_t strlen(void) { return end-str; }
        char* sprintf(char *format, ...);
        char* scatf(char *format, ...);
        char* strcpy(const char *src);
        char* strcat(const char *src);
        char* strncpy(const char *src, unsigned len);
        char* strncat(const char *src, unsigned len);
        char* strrchr(int ch);

    public:
        void DebugPrint(void);
    };

#endif // _ISTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_

#include "deviceSrv.h"
#include <xbox.h>


enum {
    SLOT_CONTROLLER,
    SLOT_TOP,
    SLOT_BOTTOM,
    SLOT_MAX
    };


class USBDevice
    {
    public:
        PXPP_DEVICE_TYPE type; // XDEVICE type

    public:
        USBDevice() { type = NULL; }
        ~USBDevice() { type = NULL; }

    public:
        virtual void Insert(unsigned port, unsigned slot) = 0;
        virtual void Remove(void) = 0;
    };


class DeviceDuke : public USBDevice
    {
    public:
        HANDLE duke;
        XINPUT_POLLING_PARAMETERS *pollingParameters;

    public:
        DeviceDuke() { type = XDEVICE_TYPE_GAMEPAD; pollingParameters = NULL; duke = NULL; }
        DeviceDuke(unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p) { type = XDEVICE_TYPE_GAMEPAD; pollingParameters = p; duke = NULL; Insert(port, slot); }
        ~DeviceDuke() { if(duke) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert duke\n");*/ duke = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters); if(!duke) throw; }
        void Remove(void) { /*DebugPrint("USBDevice: Remove duke\n");*/ XInputClose(duke); duke = NULL; }
    };


#ifdef DEBUG_KEYBOARD
class DeviceKeyboard : public USBDevice
    {
    public:
        HANDLE keyboard;
        XINPUT_POLLING_PARAMETERS *pollingParameters;

    public:
        DeviceKeyboard() { type = XDEVICE_TYPE_DEBUG_KEYBOARD; pollingParameters = NULL; keyboard = NULL; }
        DeviceKeyboard(unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p) { type = XDEVICE_TYPE_DEBUG_KEYBOARD; pollingParameters = p; keyboard = NULL; Insert(port, slot); }
        ~DeviceKeyboard() { if(keyboard) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { keyboard = XInputOpen(XDEVICE_TYPE_DEBUG_KEYBOARD, port, XDEVICE_NO_SLOT, pollingParameters); if(!keyboard) throw; }
        void Remove(void) { XInputClose(keyboard); keyboard = NULL; }
    };
#endif // DEBUG_KEYBOARD


class DeviceMU : public USBDevice
    {
    public:
        char drive;

    public:
        DeviceMU() { type = XDEVICE_TYPE_MEMORY_UNIT; drive = 0; }
        DeviceMU(unsigned port, unsigned slot) { type = XDEVICE_TYPE_MEMORY_UNIT; drive = 0; Insert(port, slot); }
        ~DeviceMU() { if(drive) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert MU\n");*/ if(XMountMU(port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, &drive) != ERROR_SUCCESS) throw; }
        void Remove(void) { /*DebugPrint("USBDevice: Remove MU\n");*/ XUnmountMU(XMUPortFromDriveLetter(drive), XMUSlotFromDriveLetter(drive)); drive = 0; }
    };


class DeviceHawk : public USBDevice
    {
    public:
        XMediaObject *microphone;
        XMediaObject *headphone;

    public:
        DeviceHawk() { type = XDEVICE_TYPE_VOICE_MICROPHONE; microphone = headphone = NULL; }
        DeviceHawk(unsigned port, unsigned slot) { type = XDEVICE_TYPE_VOICE_MICROPHONE; microphone = headphone = NULL; Insert(port, slot); }
        ~DeviceHawk() { if(microphone || headphone) Remove(); }

    public:
        void Insert(unsigned port, unsigned slot) { /*DebugPrint("USBDevice: Insert HAWK: mic\n"); 
            XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, port, 2, NULL, &microphone);
            /*DebugPrint("USBDevice: Insert HAWK: headphone\n"); 
            XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, port, 2, NULL, &headphone); */
            /*DebugPrint("USBDevice: Insert HAWK: done\n"); */
            }
        void Remove(void) { 
            /*DebugPrint("USBDevice: Remove HAWK\n");*/
            if(microphone) { /*DebugPrint("microphone->Release()...");*/ microphone->Release(); DebugPrint("...microphone->Release()\n"); } 
            if(headphone)  { /*DebugPrint("headphone->Release()...");*/  headphone->Release();  DebugPrint("...headphone->Release()\n"); } 
            microphone = headphone = NULL; 
            /*DebugPrint("USBDevice: Remove HAWK\n");*/ }
    };


class USBManager
    {
    public:
        bool hotplugs;
        USBDevice *devices[XGetPortCount()][SLOT_MAX];
        DWORD packetNum[XGetPortCount()][SLOT_MAX];
        XINPUT_POLLING_PARAMETERS pollingParameters;

    public:
        USBManager();
        ~USBManager();

    public:
        void DumpControllerState(SOCKET sock, unsigned port, unsigned slot);
        void ProcessInput(void);
        void ProcessInput(SOCKET sock);
        void CheckForHotplugs(void);

    };


#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\utils.cpp ===
#include "deviceSrv.h"


/*

Routine Description:

    Formatted print function that sends the output through a connected SOCKET.

Arguments:

    SOCKET sock - connected socket
    char* format - printf style format specifier
    ... - arguments specified by the format specifier

Return Value:

    int - number of bytes sent out

Notes:

*/
int SockPrint(SOCKET sock, char* format, ...)
    {
    if(sock == INVALID_SOCKET) return 0;

    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    int len = vsprintf(szBuffer, format, args);
    send(sock, szBuffer, len, 0);

    va_end(args);

    return len;
    }

void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }


bool stristr(char *string, char *substr, size_t len/*=0*/)
    {
    if(!string || ! substr) return false;
    if(!*string) return false;
    if(!len) len = strlen(substr);
    if(_strnicmp(string, substr, len) == 0) return true;

    return stristr(string+1, substr, len);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\acquire.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Acquire.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    05-30-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include <initguid.h>
#include <dinput.h>
#include <input.h>


BOOL CALLBACK Acquire_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);

struct EnumCallbackState
    {
    DWORD threadID;
    DWORD numFound;
    DWORD mode;
    IDirectInput8* pDI;
    HANDLE hLog;
    };


/*

Routine Description:

    

Arguments:

    

Return Value:

    

*/
DWORD Acquire_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HRESULT Acquire();

    HRESULT Unacquire();
    */
    xSetFunctionName(hLog, "Acquire");

    HRESULT result;
    IDirectInput8 *pDI = NULL;
    IDirectInputDevice8 *pDID = NULL;
    unsigned i;
    DIDEVCAPS diDevCaps;
    DIPROPDWORD dipdw;
    diDevCaps.dwSize = sizeof(DIDEVCAPS);
    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj = 0;
    dipdw.diph.dwHow = DIPH_DEVICE;
    dipdw.dwData = false;

    __asm int 3;

    result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL);
    if(result != DI_OK)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to create the DirectInput interface (ec: %lX)", result);
        xEndVariation(hLog);
        return -1;
        }


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Checking plugged in devices")
        {
        EnumCallbackState state = { ThreadID, 0, 1, pDI, hLog };
        result = pDI->EnumDevices(0, Acquire_Test_Callback, (void*)&state, DIEDFL_ENUMANDNOTIFYINSERT);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        xLog(hLog, XLL_INFO, "Found %u devices", state.numFound);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, Acquire_Test_Callback, NULL, DIEDFL_HALTNOTIFYINSERT); });
    xSetFunctionName(hLog, "Acquire");


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////


/*
    TESTCASE("Reciently removed")
        {
        // TODO plug in device x
        // TODO unplug device x
        GUID guid = { x, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = state->pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
*/

    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    xSetFunctionName(hLog, "Acquire");
    TESTCASE("Mini Stress")
        {
        GUID guid = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);
        if(result != DI_OK || !pDID)
            {
            char buffer[1024];
            sprintf(buffer, "CreateDevice failed (ec: %lX)", result);
            BLOCKED(0, buffer);
            }
        DebugPrint("DITEST(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned maxLoop = 10000;
        for(i=0; i<maxLoop; i++)
            {
            if(i%(maxLoop/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxLoop);
            pDID->SetProperty(DIPROP_AUTOPOLL, &dipdw.diph);
            pDID->Acquire();
            pDID->Unacquire();
            }
        } ENDTESTCASE_CLEAN({ if(pDID) { pDID->Release(); pDID=NULL; } DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    pDI->Release();
    return 0;
    }



BOOL CALLBACK Acquire_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    //__asm int 3;

    if(!pvRef)
        {
        DebugPrint("DITEST(-): Found Device: but state is NULL\n");
        return DIENUM_CONTINUE;
        }

    EnumCallbackState *state = (EnumCallbackState*)pvRef;
    HANDLE hLog = state->hLog;
    ++state->numFound;

    HRESULT result;
    char buffer[1024];
    sprintf(buffer, "Device #%d", state->numFound);

    IDirectInputDevice8 *pDID = NULL;
    DIDEVCAPS diDevCaps;
    DIPROPDWORD dipdw;
    diDevCaps.dwSize = sizeof(DIDEVCAPS);
    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj = 0;
    dipdw.diph.dwHow = DIPH_DEVICE;
    dipdw.dwData = false;

    xSetFunctionName(hLog, "Acquire");
    TESTCASE(buffer)
        {
        result = state->pDI->CreateDevice(lpddi->guidInstance, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK || !pDID)
            {
            sprintf(buffer, "CreateDevice failed (ec: %lX)", result);
            BLOCKED(0, buffer);
            }

        pDID->SetProperty(DIPROP_AUTOPOLL, &dipdw.diph);
        result = pDID->Acquire();

        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;

    xSetFunctionName(hLog, "Unacquire");
    TESTCASE(buffer)
        {
        if(!pDID)
            {
            sprintf(buffer, "CreateDevice failed (ec: %lX)", result);
            BLOCKED(0, buffer);
            }

        result = pDID->Unacquire();

        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });

    return DIENUM_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\commontest.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         L"Z"
#define TITLE_DRIVE         L"T"
#define USER_DRIVE          L"U"
#define BASE_DRIVE          CACHE_DRIVE

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    xStartVariation(hLog, variant);
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    xStartVariation(hLog, aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

#define ALLCHARS L"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f" \
    L"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

// common numbers
static DWORD dwBogus = 0xF000BAAA;
static ULARGE_INTEGER ulBogus = { 0xF000BAAA, 0xF000BAAA };

// common HANDLE parameters
static HANDLE hNull = NULL;
static HANDLE hBogus = (void*)0xF000BAAA;

// common string parameters
static LPCTSTR lpNull = NULL;
static LPCTSTR lpEmpty = L"";
static LPCTSTR lpSpace = L" ";
static LPCTSTR lpBogus = (const unsigned short*)0xF000BAAA;
static LPCTSTR lpCurrentDir = L".";
static LPCTSTR lpParentDir = L"..";
static LPCTSTR lpUnderMaxPathDir = BASE_DRIVE L":\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory";
static LPCTSTR lpOverMaxPathDir = BASE_DRIVE L":\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory";

// security attributes
static SECURITY_DESCRIPTOR sdEmpty = { 0, 0, 0, 0, 0, 0, 0 };
static SECURITY_DESCRIPTOR sdBogus = { 0x69, 0x69, 0xF000, (void*)0xF000BAAA, (void*)0xF000BAAA, (PACL)0xF000BAAA, (PACL)0xF000BAAA};
static SECURITY_ATTRIBUTES saEmpty = { 0, 0, 0 };
static SECURITY_ATTRIBUTES saBogus = { 0xF000BAAA, (PISECURITY_DESCRIPTOR)0xF000BAAA, 0xF000BAAA};
static SECURITY_ATTRIBUTES saEmptyWithSize = { sizeof(SECURITY_ATTRIBUTES), 0, 0 };
static SECURITY_ATTRIBUTES saWithEmptySD = { sizeof(SECURITY_ATTRIBUTES), &sdEmpty, 0 };
static SECURITY_ATTRIBUTES saWithBogusSD = { sizeof(SECURITY_ATTRIBUTES), &sdBogus, 0 };

// device names
static WCHAR *deviceNames[] = {
    BASE_DRIVE L":\\prn",
    BASE_DRIVE L":\\aux",
    BASE_DRIVE L":\\con",
    BASE_DRIVE L":\\lpt1",
    L"\\\\?\\prn",
    L"\\\\?\\aux",
    L"\\\\?\\con",
    L"\\\\?\\lpt1",
    L"\\\\lpt1",
    L"CONOUT$",
    L"CONIN$",
    };

// invalid file names
static WCHAR *invalidFileNames[] = {
    BASE_DRIVE L":\\abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd",
    BASE_DRIVE L":\\)#+l+RI+Td<\x12>",
    BASE_DRIVE L":\\~`!@#$%^&*()-=_+[]{}\\|';:\",./?><",
    BASE_DRIVE L":\\*",
    BASE_DRIVE L":\\?",
    BASE_DRIVE L":\\" ALLCHARS,
    BASE_DRIVE L":\\abc?",
    BASE_DRIVE L":\\abc>def",
    BASE_DRIVE L":\\abc<def",
    BASE_DRIVE L":\\abc|def",
    BASE_DRIVE L":\\abc:def",
    BASE_DRIVE L":\\abc\"def",
    BASE_DRIVE L":\\>",
    BASE_DRIVE L":\\<",
    BASE_DRIVE L":\\:",
    BASE_DRIVE L":\\|",
    BASE_DRIVE L":\\\"",
    BASE_DRIVE L":\\..\\abcdef",
    BASE_DRIVE L":\\.\\..\\abcdef",
    BASE_DRIVE L":\\..\\..\\..\\..\\..\\..\\..\\..\\..\\abcdef",
    BASE_DRIVE L":\\abc" BASE_DRIVE L":\\def",
    BASE_DRIVE L":\\new\nline",
    BASE_DRIVE L":\\newline\n",
    BASE_DRIVE L":\\Carriage\rreturn",
    BASE_DRIVE L":\\Carriagereturn\r",
    BASE_DRIVE L":\\\ttab",
    BASE_DRIVE L":\\tab\t",
    BASE_DRIVE L":\\\abell",
    BASE_DRIVE L":\\bell\a",
    BASE_DRIVE BASE_DRIVE L":\\abc",
    BASE_DRIVE L"::\\abc",
    BASE_DRIVE L"abc",
    BASE_DRIVE L".",
    BASE_DRIVE L"..",
    BASE_DRIVE L" ",
    L"\\\\?\\" BASE_DRIVE L":\\)#+l+RI+Td<\x12>",
    L"\\\\?\\" BASE_DRIVE L":\\~`!@#$%^&*()-=_+[]{}\\|';:\",./?><",
    L"\\\\?\\" BASE_DRIVE L":\\*",
    L"\\\\?\\" BASE_DRIVE L":\\?",
    L"\\\\?\\" BASE_DRIVE L":\\" ALLCHARS,
    L"\\\\?\\" BASE_DRIVE L":\\..\\abcdef",
    L"\\\\?\\" BASE_DRIVE L":\\.\\..\\abcdef",
    L"\\\\?\\" BASE_DRIVE L":\\new\nline",
    L"\\\\?\\" BASE_DRIVE L":\\Carriage\rreturn",
    L"\\\\?\\" BASE_DRIVE L":\\\ttab",
    L"\\\\?\\" BASE_DRIVE BASE_DRIVE L":\\abc",
    L"\\\\?\\" BASE_DRIVE L"::\\abc",
    L"\\\\?\\" BASE_DRIVE L":\\\\abc",
    L"\\\\?\\" BASE_DRIVE L"abc",
    L"\\\\?\\abc",
    L"\\\\?\\ ",
    L"\\\\?\\/",
    L"\\\\?\\\\",
    L"\\\\?\\.",
    L"\\\\?\\..",
    L" ",
    L"/",
    L"\\",
    L".",
    L".."
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\deviceSrv\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "deviceSrv.h"
#include "usbmanager.h"

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
    };


USBManager::USBManager()
    {
    hotplugs = true;
    DWORD insertions, insertions2;
    unsigned i, j;
    unsigned port, slot;

    pollingParameters.fAutoPoll = 1;
    pollingParameters.fInterruptOut = 0;
    pollingParameters.ReservedMBZ1 = 0;
    pollingParameters.bInputInterval = 8;  
    pollingParameters.bOutputInterval = 8;
    pollingParameters.ReservedMBZ2 = 0;

    // initialize
    for(i=0; i<XGetPortCount(); i++)
        {
        for(j=0; j<SLOT_MAX; j++)
            {
            devices[i][j] = NULL;
            packetNum[i][j] = 1234;
            }
        }

    // look for game pads
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    //DebugPrint("USBMGR: XID: - %X\n", insertions);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XID %d\n", i);
            devices[port][0] = new DeviceDuke(port, 0, &pollingParameters); 
            }
        }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    //DebugPrint("USBMGR: XMU: - %X\n", insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XMU %d (ec: %lu)\n", port, err);
            devices[port][slot] = new DeviceMU(port, slot);
            }
        }

    
    // check for hawks
    insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if(insertions == insertions2)
        {
        //DebugPrint("USBMGR: OK!\n");
        }
    else
        {
        //DebugPrint("USBMGR: CRAP!\n");
        }
    //DebugPrint("USBMGR: XHAWK: %X %X\n", removals, insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[port][slot] = new DeviceHawk(port, slot);
            }
        }
    }


USBManager::~USBManager()
    {
    unsigned i, j;

    for(i=0; i<XGetPortCount(); i++)
        {
        for(j=0; j<SLOT_MAX; j++)
            {
            if(devices[i][j] != NULL)
                {
                if(XDEVICE_TYPE_GAMEPAD == devices[i][j]->type) delete (DeviceDuke*)devices[i][j];
                else if(XDEVICE_TYPE_MEMORY_UNIT == devices[i][j]->type) delete (DeviceMU*)devices[i][j];
                else if(XDEVICE_TYPE_VOICE_MICROPHONE == devices[i][j]->type) delete (DeviceHawk*)devices[i][j];
                devices[i][j] = NULL;
                }
            }
        }
    }


void USBManager::CheckForHotplugs(void)
    {
    DWORD addDuke, removeDuke;
    DWORD addKey, removeKey;
    DWORD addMU, removeMU;
    DWORD addHawk, removeHawk, addHawk2, removeHawk2;
    unsigned slot, port;
    unsigned i;

    if(!hotplugs) return;

    // check for mu removals
    XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addMU, &removeMU);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(removeMU & XMUMasks[i])
            {
            delete (DeviceMU*)devices[port][slot];
            devices[port][slot] = NULL;
            }
        }

#ifdef DEBUG_KEYBOARD
    // check for keyboard removals
    XGetDeviceChanges(XDEVICE_TYPE_DEBUG_KEYBOARD, &addKey, &removeKey);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(removeKey & XIDMasks[i])
            {
            delete (DeviceKeyboard*)devices[port][0];
            devices[port][0] = NULL;
            }
        }
#endif // DEBUG_KEYBOARD

    // check for xhawk removals
    XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &addHawk, &removeHawk);
    XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &addHawk2, &removeHawk2);
    if(removeHawk == removeHawk && addHawk == addHawk2)
        {
        //DebugPrint("USBMGR: OK!\n");
        }
    else
        {
        //DebugPrint("USBMGR: CRAP!\n");
        }
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(removeHawk & XMUMasks[i])
            {
            delete (DeviceHawk*)devices[port][slot];
            devices[port][slot] = NULL;
            }
        }


    // check for game controllers (insert & removal)
    XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(removeDuke & XIDMasks[i])
            {
            delete (DeviceDuke*)devices[port][0];
            devices[port][0] = NULL;
            }
        if(addDuke & XIDMasks[i])
            {
            try
                {
                devices[port][0] = new DeviceDuke(port, 0, &pollingParameters); 
                }
            catch(...)
                {
                delete devices[port][0];
                devices[port][0] = NULL;
                }
            }
        }

#ifdef DEBUG_KEYBOARD
    // check for keyboard insertions
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(addKey & XIDMasks[i])
            {
            try
                {
                devices[port][0] = new DeviceKeyboard(port, 0, &pollingParameters); 
                }
            catch(...)
                {
                delete devices[port][0];
                devices[port][0] = NULL;
                }
            }
        }
#endif // DEBUG_KEYBOARD

    // check for mu insertions
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(addMU & XMUMasks[i])
            {
            try
                {
                devices[port][slot] = new DeviceMU(port, slot); 
                }
            catch(...)
                {
                delete devices[port][slot];
                devices[port][slot] = NULL;
                }
            }
        }

    // check for xhawk insertions
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(addHawk & XMUMasks[i])
            {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            try
                {
                // TODO 
                devices[port][slot] = new DeviceHawk(port, slot); 
                }
            catch(...)
                {
                delete devices[port][0];
                devices[port][0] = NULL;
                }
            }
        }
    }


void USBManager::ProcessInput(void)
    {
    CheckForHotplugs();
    for(unsigned i=0; i<XGetPortCount(); i++)
        {
        DumpControllerState(INVALID_SOCKET, i, 0);
        }
    }


void USBManager::ProcessInput(SOCKET sock)
    {
    CheckForHotplugs();
    for(unsigned i=0; i<XGetPortCount(); i++)
        {
        DumpControllerState(sock, i, 0);
        }
    }


void USBManager::DumpControllerState(SOCKET sock, unsigned port, unsigned slot)
    {
    if(devices[port][slot] == NULL) return;

    XINPUT_STATE state;
    memset(&state, 0, sizeof(XINPUT_STATE));

    XInputGetState(((DeviceDuke*)devices[port][slot])->duke, &state);

    //DebugPrint("Duke: 0x%X, packet id: %u\r\n", ((DeviceDuke*)devices[port][slot])->duke, state.dwPacketNumber);

    if(packetNum[port][slot] != state.dwPacketNumber)
        {
        packetNum[port][slot] = state.dwPacketNumber;

        if(sock != INVALID_SOCKET)
            {
            SockPrint(sock, "Input [%u][%u] #%lu:\r\n"
                "   dButtons = %d%d%d%d %d%d%d%d %d%d%d%d%d%d%d%d\r\n"
                "   aButtons = (%02X %02X %02X %02X %02X %02X %02X %02X)\r\n"
                "   Thumb1   = (%d, %d)\r\n"
                "   Thumb2   = (%d, %d)\r\n"
                , port, slot,
                state.dwPacketNumber,
                !!(state.Gamepad.wButtons&(1<<0)),
                !!(state.Gamepad.wButtons&(1<<1)),
                !!(state.Gamepad.wButtons&(1<<2)),
                !!(state.Gamepad.wButtons&(1<<3)),
                !!(state.Gamepad.wButtons&(1<<4)),
                !!(state.Gamepad.wButtons&(1<<5)),
                !!(state.Gamepad.wButtons&(1<<6)),
                !!(state.Gamepad.wButtons&(1<<7)),
                !!(state.Gamepad.wButtons&(1<<8)),
                !!(state.Gamepad.wButtons&(1<<9)),
                !!(state.Gamepad.wButtons&(1<<10)),
                !!(state.Gamepad.wButtons&(1<<11)),
                !!(state.Gamepad.wButtons&(1<<12)),
                !!(state.Gamepad.wButtons&(1<<13)),
                !!(state.Gamepad.wButtons&(1<<14)),
                !!(state.Gamepad.wButtons&(1<<15)),
                state.Gamepad.bAnalogButtons[0],
                state.Gamepad.bAnalogButtons[1],
                state.Gamepad.bAnalogButtons[2],
                state.Gamepad.bAnalogButtons[3],
                state.Gamepad.bAnalogButtons[4],
                state.Gamepad.bAnalogButtons[5],
                state.Gamepad.bAnalogButtons[6],
                state.Gamepad.bAnalogButtons[7],
                state.Gamepad.sThumbLX,
                state.Gamepad.sThumbLY,
                state.Gamepad.sThumbRX,
                state.Gamepad.sThumbRY
                );
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\createdevice.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CreateDevice.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    05-30-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include <initguid.h>
#include <dinput.h>
#include <input.h>


BOOL CALLBACK CreateDevice_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);

struct EnumCallbackState
    {
    DWORD threadID;
    DWORD numFound;
    DWORD mode;
    IDirectInput8* pDI;
    HANDLE hLog;
    };


/*

Routine Description:

    

Arguments:

    

Return Value:

    

*/
DWORD CreateDevice_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HRESULT CreateDevice(
      REFGUID rguid,
      LPDIRECTINPUTDEVICE *lplpDirectInputDevice,
      LPUNKNOWN pUnkOuter
    );

    HRESULT CreateDeviceEx(
      REFGUID rguid,
      REFIID riid,
      LPVOID *pvOut,
      LPUNKNOWN pUnkOuter
    );
    */
    xSetFunctionName(hLog, "CreateDevice");

    HRESULT result;
    IDirectInput8 *pDI = NULL;
    IDirectInputDevice8 *pDID = NULL;
    unsigned i;

    //__asm int 3;

    result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL);
    if(result != DI_OK)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to create the DirectInput interface (ec: %lX)", result);
        xEndVariation(hLog);
        return -1;
        }


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Checking plugged in devices")
        {
        EnumCallbackState state = { ThreadID, 0, 1, pDI, hLog };
        result = pDI->EnumDevices(0, CreateDevice_Test_Callback, (void*)&state, DIEDFL_ENUMANDNOTIFYINSERT);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        xLog(hLog, XLL_INFO, "Found %u devices", state.numFound);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, CreateDevice_Test_Callback, NULL, DIEDFL_HALTNOTIFYINSERT); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    xSetFunctionName(hLog, "CreateDevice");
    TESTCASE("{ 0xFFFF 0 0 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0xFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
        result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID != NULL)
            {
            TESTFAIL(hLog, "Device != NULL (ec: %lX)", result);
            }

        if(pDID) pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
    TESTCASE("{ 0 0 0 0 0 0 0 0 0 0 1 }")
        {
        GUID guid = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
        result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID != NULL)
            {
            TESTFAIL(hLog, "Device != NULL (ec: %lX)", result);
            }

        if(pDID) pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
    TESTCASE("{ 0 1 0 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID != NULL)
            {
            TESTFAIL(hLog, "Device != NULL (ec: %lX)", result);
            }

        if(pDID) pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
    TESTCASE("{ 0 0 1 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID != NULL)
            {
            TESTFAIL(hLog, "Device != NULL (ec: %lX)", result);
            }

        if(pDID) pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
    TESTCASE("{ 0 0 0 1 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID != NULL)
            {
            TESTFAIL(hLog, "Device != NULL (ec: %lX)", result);
            }

        if(pDID) pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
    TESTCASE("{ 0x20 0 0 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID != NULL)
            {
            TESTFAIL(hLog, "Device != NULL (ec: %lX)", result);
            }

        if(pDID) pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
    TESTCASE("{ 0x21 0 0 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0x21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID != NULL)
            {
            TESTFAIL(hLog, "Device != NULL (ec: %lX)", result);
            }

        if(pDID) pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });


/*
    TESTCASE("Reciently removed")
        {
        // TODO plug in device x
        // TODO unplug device x
        GUID guid = { x, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = state->pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID != NULL)
            {
            TESTFAIL(hLog, "Device != NULL (ec: %lX)", result);
            }

        if(pDID) pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
*/

    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        GUID guid = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        //DebugPrint("DITEST(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned maxLoop = 100000;
        for(i=0; i<maxLoop; i++)
            {
            //if(i%(maxLoop/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxLoop);
            result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);
            if(pDID) pDID->Release();
            pDID = NULL;
            }
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    pDI->Release();
    return 0;
    }



BOOL CALLBACK CreateDevice_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    if(!pvRef)
        {
        DebugPrint("DITEST(-): Found Device: but state is NULL\n");
        return DIENUM_CONTINUE;
        }

    EnumCallbackState *state = (EnumCallbackState*)pvRef;
    HANDLE hLog = state->hLog;
    ++state->numFound;

    HRESULT result;
    char buffer[1024];
    sprintf(buffer, "Device #%d", state->numFound);

    IDirectInputDevice8 *pDID = NULL;

    xSetFunctionName(hLog, "CreateDevice");
    TESTCASE(buffer)
        {
        result = state->pDI->CreateDevice(lpddi->guidInstance, (IDirectInputDevice8**)&pDID, NULL);

        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID == NULL)
            {
            TESTFAIL(hLog, "Device == NULL (ec: %lX)", result);
            break;
            }

        pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
/*
    xSetFunctionName(hLog, "CreateDeviceEx");
    TESTCASE(buffer)
        {
        result = state->pDI->CreateDeviceEx(lpddi->guidInstance, IID_IDirectInputDevice8, (void**)&pDID, NULL);

        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        if(pDID == NULL)
            {
            TESTFAIL(hLog, "Device == NULL (ec: %lX)", result);
            break;
            }

        pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });
*/


    return DIENUM_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\dinputtest.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    usbtest.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <initguid.h>
#include <dinput.h>
#include <input.h>
#include <xlog.h>
#include "ditestAPI.h"
#include "commontest.h"

#include "dinputtest.h"

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

ULONG ThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE HeapHandle;


BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    //
    // IMPORTANT:
    //
    // There are tons of threads in the harness process. If you don't have
    // anything to do for thread creation/destroy notification, you should
    // call DisableThreadLibraryCalls to reduce the size of the working set
    //
    // TODO: There is no DisableThreadLibraryCalls export from XAPI now,
    //         remove the comment below when it is ready.
    //

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        //DisableThreadLibraryCalls(hInstance);
        HeapHandle = HeapCreate(0, 0, 0);

        if(!HeapHandle)
            {
            OutputDebugString(L"USBTEST: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(HeapHandle)
            {
            HeapDestroy(HeapHandle);
            }
        }

    return TRUE;
    }


/*

Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    DWORD threadNumber - sequential number of the thread
    DWORD loops - # of times to run test
    WCHAR* testname - specific name of a test to run

Return Value:

    DWORD

*/
DWORD RunAll(HANDLE hLog, DWORD threadNumber, DWORD loops, WCHAR *testname)
    {
    Sleep(threadNumber*200); // stagger the thread's execution a bit

    struct APIFUNCT
        {
        APITEST_FUNC f;
        WCHAR *name;
        };
    #define BUILTAPISTRUCT(n) { n , L#n }

    // Define all the API tests
    APIFUNCT testlist[] =
        {
        BUILTAPISTRUCT(DeviceDump_Test),
        /*
        BUILTAPISTRUCT(Acquire_Test),
        */
        /*
        BUILTAPISTRUCT(CreateDevice_Test),
        BUILTAPISTRUCT(DirectInputCreate_Test),
        BUILTAPISTRUCT(EnumDevices_Test),
        BUILTAPISTRUCT(GetCapabilities_Test),
        BUILTAPISTRUCT(GetDeviceStatus_Test),
        */
        };

    bool runAll = wcscmp(testname, L"(all)") == 0 ? true : false;

    // Run the suite of tests
    for(DWORD i=0; i<loops; i++)
        {
        // run each test
        for(unsigned j=0; j<ARRAYSIZE(testlist); j++)
            {
            if(runAll || wcsstr(testlist[j].name, testname) != NULL)
                {
                xLog(hLog, XLL_INFO, "%ws() ******************************************", testlist[j].name);
                LogResourceStatus(hLog, true);
                DebugPrint("DITEST(%d): Entering %ws()\n", threadNumber, testlist[j].name);
                testlist[j].f(hLog, threadNumber);
                }
            }
        }

    return 0;
    }




/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI StartTest(HANDLE hLog)
    {
    ULONG ID = 0;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &ThreadID);

    // test settings
    const int buffLen = 1024;
    WCHAR testname[buffLen];
    DWORD loops;

    // Pull out internal INI file settings
    GetProfileString(L"dinputtest", L"testname", L"(all)", testname, buffLen);
    loops = GetProfileInt(L"dinputtest", L"loops", 1);

    xSetComponent(hLog, "DirectX", "DirectInput");
    DebugPrint("DITEST(%d): Entering StartTest()\n", ID);
    DebugPrint("DITEST(%d): Internal INI Settings:\n", ID);
    DebugPrint("  loops=%lu\n", loops);
    DebugPrint("  testname=%ws\n", testname);

    switch(ThreadID)
        {
        case 0:
        case 1:
        default:
            RunAll(hLog, ID, loops, testname);
            break;
        }

    DebugPrint("DITEST(%d): Leaving StartTest()\n", ID);
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI EndTest(void)
    {
    ThreadID = 0;
    }



BOOL CALLBACK EnumDevicesCallback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    /*
    static BOOL fCreate = TRUE;
    CDIDevice *pDevice;

    if(pvRef == ENUM_DEVICE_REMOVE_REF)
        {
        pDevice = g_pDITest->FindDevice(lpddi->guidInstance);
        g_pDITest->RemoveDevice(pDevice, FALSE);
        delete pDevice;
        }

    if(pvRef == ENUM_DEVICE_INSERT_REF)
        {
        pDevice = new CDIDevice(lpddi->guidInstance);
        if(pDevice)
            {
            pDevice->CreateDID8(g_pDITest->GetDI8(), fCreate);
            fCreate = !fCreate;
            g_pDITest->AddDevice(pDevice);
            }
        }
*/
    return TRUE;
    }


/*
void DeviceChanges(PCINPUT_DEVICE_INFORMATION DeviceInformation, BOOL fAdd, BOOL, CXidDeviceCollection *pDeviceCollection)
    {
    if(fAdd)
        {
        pDeviceCollection->Add(DeviceInformation);
        }
    else
        {
        pDeviceCollection->Remove(DeviceInformation);
        }
    }


CXidDeviceCollection::CXidDeviceCollection() : m_pDevices(NULL), m_iDeviceCount(0)
    {
    }

CXidDeviceCollection::~CXidDeviceCollection()
    {
    //
    //  Remove all the devices
    //
    CXidDevice *pDevice;
    while(m_pDevices)
        {
        pDevice = m_pDevices;
        m_pDevices = pDevice->m_pNextDevice;
        //
        //  neglect the backward links, we are going to
        //  delete everything anyway.
        //
        pDevice->Close();
        m_iDeviceCount--;
        delete pDevice;
        }

    if(0!=m_iDeviceCount)
        {
        DebugPrint("USBTEST: Somewhere m_iDeviceCount got hosed, it is now %d, should be 0\n", m_iDeviceCount);
        }
    }

void CXidDeviceCollection::Add(PCINPUT_DEVICE_INFORMATION pDeviceInfo)
    {
    CXidDevice *pNewDevice = new CXidDevice(pDeviceInfo);

    //
    //  Open the device
    //
    pNewDevice->Open();

    //
    //  Add the device to the head of the list
    //
    pNewDevice->m_pPrevDevice = NULL;
    pNewDevice->m_pNextDevice = m_pDevices;
    if(m_pDevices) m_pDevices->m_pPrevDevice = pNewDevice;
    m_pDevices = pNewDevice;
    m_iDeviceCount++;
    }

void CXidDeviceCollection::Remove(PCINPUT_DEVICE_INFORMATION pDeviceInfo)
    {
    //
    //  Walk the list loop for the device
    //
    CXidDevice *pDevice = m_pDevices;
    while(pDevice)
        {
        if(pDevice->IsDevice(pDeviceInfo))
            {
            if(pDevice->m_pPrevDevice)
                {
                pDevice->m_pPrevDevice->m_pNextDevice = pDevice->m_pNextDevice;
                }
            else
                {
                m_pDevices = pDevice->m_pNextDevice;
                }
            if(pDevice->m_pNextDevice)
                {
                pDevice->m_pNextDevice->m_pPrevDevice = pDevice->m_pPrevDevice;
                }
            pDevice->Close();
            delete pDevice;
            m_iDeviceCount--;
            return;
            }
        pDevice = pDevice->m_pNextDevice;
        }
    DebugPrint("USBTEST: Attempt to remove a device not found:\n");
    DumpDeviceInfo(pDeviceInfo);
    }

void CXidDeviceCollection::PollDevices()
    {
    CXidDevice *pDevice = m_pDevices;
    while(pDevice)
        {
        pDevice->PollDevice();
        pDevice = pDevice->m_pNextDevice;
        }
    }

CXidDevice::CXidDevice(PCINPUT_DEVICE_INFORMATION pDeviceInfo) :
    m_dwDeviceHandle(0), m_pNextDevice(NULL), m_pPrevDevice(NULL),
    m_dwPacketNumber(0), m_dwIdlePollCount(0)
    {
    m_DeviceInfo = *pDeviceInfo;
    m_InputBuffer.bReportId = 0;
    m_InputBuffer.bSize = sizeof(INPUT_FORMAT_GAME);
    m_InputBufferLast.bReportId = 0;
    m_InputBufferLast.bSize = sizeof(INPUT_FORMAT_GAME);
    DebugPrint("USBTEST: DeviceAdded:\n");
    DumpDeviceInfo(&m_DeviceInfo);
    }

CXidDevice::~CXidDevice()
    {
    if(m_dwDeviceHandle)
        {
        Close();
        }
    DebugPrint("USBTEST: DeviceRemoved:\n");
    DumpDeviceInfo(&m_DeviceInfo);
    }

void CXidDevice::Open()
    {
    DWORD errorCode = InputOpenDevice(m_DeviceInfo.bDeviceID, false, &m_dwDeviceHandle);
    if(ERROR_SUCCESS != errorCode)
        {
        DebugPrint("USBTEST: InputOpenDevice failed with errorCode 0x%0.8x\n", errorCode);
        if(m_dwDeviceHandle != 0)
            {
            DebugPrint("USBTEST: InputOpenDevice failed and did not zero out the device handle!!!");
            }
        }
    }

void CXidDevice::Close()
    {
    if(m_dwDeviceHandle)
        {
        InputCloseDevice(m_dwDeviceHandle);
        m_dwDeviceHandle = 0;
        }
    }

void CXidDevice::PollDevice()
    {
    DWORD               dwError;
    DWORD               dwPreviousPacketNumber = m_dwPacketNumber;
    dwError = InputGetDeviceState(m_dwDeviceHandle, (PINPUT_FORMAT)&m_InputBuffer, &m_dwPacketNumber);
    if(ERROR_SUCCESS == dwError)
        {
        //
        //  check to see if the device state changed
        //
        if(dwPreviousPacketNumber != m_dwPacketNumber)
            {
            if(ThresholdCheck())
                {
                m_dwIdlePollCount = 0;
                DebugPrint("USBTEST: Device %d changed state:\n", (DWORD)m_DeviceInfo.bDeviceID);
                DumpDeviceState(&m_InputBuffer);
                }
            else
                {
                m_dwIdlePollCount = 0;
                DebugPrint(".");
                }
            }
        else
            {
            //
            //  Display an idle message about every 5 seconds, assuming
            //  this function gets called 60 times a seconds.
            //
            if(0==++m_dwIdlePollCount%600)
                {
                DebugPrint("USBTEST: Device %d has been idle about %d seconds.\n", (DWORD)m_DeviceInfo.bDeviceID, m_dwIdlePollCount/60);
                }
            }
        }
    else
        {
        DebugPrint("USBTEST: Poll of device %d failed.\n", (DWORD)m_DeviceInfo.bDeviceID);
        }
    }

BOOL CXidDevice::ThresholdCheck()
/*++
    ThresholdCheck is necessary because the POC has a lot of jitter.
    Since we don't have graphics yet, the test program outputs to the
    debug monitor, and we need to keep the spew down.
--/
{
    int i;
    BOOL Threshold = FALSE;
    for(i=0; i<8; i++)
    {
        //
        //  check analog buttons (look for a change of 32 or greater)
        //
        if((m_InputBufferLast.rgbAnalogButtons[i]^m_InputBuffer.rgbAnalogButtons[i])&0xE0)
        {
            m_InputBufferLast.rgbAnalogButtons[i] = m_InputBuffer.rgbAnalogButtons[i];
            Threshold = TRUE;
        }
        //
        //  check digitial buttons
        //
        if(m_InputBufferLast.wButtons != m_InputBuffer.wButtons)
        {
            m_InputBufferLast.wButtons = m_InputBuffer.wButtons;
            Threshold = TRUE;
        }
        //
        //  Check DPAD
        //
        if(m_InputBufferLast.wDPad != m_InputBuffer.wDPad)
        {
            m_InputBufferLast.wDPad = m_InputBuffer.wDPad;
            Threshold = TRUE;
        }
        //
        //  check axes (Look for a change of 32 or creater
        //
        if((m_InputBufferLast.wThumb1X^m_InputBuffer.wThumb1X)&0xFFE0)
        {
            m_InputBufferLast.wThumb1X=m_InputBuffer.wThumb1X;
            Threshold = TRUE;
        }
        if((m_InputBufferLast.wThumb1Y^m_InputBuffer.wThumb1Y)&0xFFE0)
        {
            m_InputBufferLast.wThumb1Y=m_InputBuffer.wThumb1Y;
            Threshold = TRUE;
        }
        if((m_InputBufferLast.wThumb2X^m_InputBuffer.wThumb2X)&0xFFE0)
        {
            m_InputBufferLast.wThumb2X=m_InputBuffer.wThumb2X;
            Threshold = TRUE;
        }
        if((m_InputBufferLast.wThumb2Y^m_InputBuffer.wThumb2Y)&0xFFE0)
        {
            m_InputBufferLast.wThumb2Y=m_InputBuffer.wThumb2Y;
            Threshold = TRUE;
        }
        /*
        if((m_InputBufferLast.wTiltX^m_InputBuffer.wTiltX)&0xFFE0)
        {
            m_InputBufferLast.wTiltX=m_InputBuffer.wTiltX;
            Threshold = TRUE;
        }
        if((m_InputBufferLast.wTiltY^m_InputBuffer.wTiltY)&0xFFE0)
        {
            m_InputBufferLast.wTiltY=m_InputBuffer.wTiltY;
            Threshold = TRUE;
        }*


    }
    return Threshold;
}

BOOL CXidDevice::IsDevice(PCINPUT_DEVICE_INFORMATION pDeviceInfo)
    {
    if(m_DeviceInfo.bDeviceID == pDeviceInfo->bDeviceID)
        {
        return TRUE;
        }
    return FALSE;
    }


LPCSTR GetDeviceTypeString(BYTE bType)
    {
    switch(bType)
        {
        case INPUT_DEVTYPE_GAMECONTROLLER:
            return "INPUT_DEVTYPE_GAMECONTROLLER";
        case INPUT_DEVTYPE_KEYBOARD:
            return "INPUT_DEVTYPE_KEYBOARD";
        case INPUT_DEVTYPE_MOUSE:
            return "INPUT_DEVTYPE_MOUSE";
        }
    return "UNKNOWN";
    }

LPCSTR GetDeviceSubTypeString(BYTE bType, BYTE bSubType)
    {
    switch(bType)
        {
        case INPUT_DEVTYPE_GAMECONTROLLER:
            switch(bSubType)
                {
                case INPUT_DEVSUBTYPE_GAMEPAD:
                    return "INPUT_DEVSUBTYPE_GAMEPAD";
                case INPUT_DEVSUBTYPE_JOYSTICK:
                    return "INPUT_DEVSUBTYPE_JOYSTICK";
                case INPUT_DEVSUBTYPE_WHEEL:
                    return "INPUT_DEVSUBTYPE_WHEEL";
                case INPUT_DEVSUBTYPE_FISHINGROD:
                    return "INPUT_DEVSUBTYPE_FISHINGROD";
                case INPUT_DEVSUBTYPE_DANCEPAD:
                    return "INPUT_DEVSUBTYPE_DANCEPAD";
                case INPUT_DEVSUBTYPE_LIGHTGUN:
                    return "INPUT_DEVSUBTYPE_LIGHTGUN";
                default:
                    return "UNKNOWN";
                }

        case INPUT_DEVTYPE_KEYBOARD:
            switch(bSubType)
                {
                case INPUT_DEVSUBTYPE_KEYBOARD:
                    return "INPUT_DEVSUBTYPE_KEYBOARD";
                default:
                    return "UNKNOWN";
                }

        case INPUT_DEVTYPE_MOUSE:
            switch(bSubType)
                {
                case INPUT_DEVSUBTYPE_MOUSE:
                    return "INPUT_DEVSUBTYPE_MOUSE";
                case INPUT_DEVSUBTYPE_TRACKBALL:
                    return "INPUT_DEVSUBTYPE_TRACKBALL";
                case INPUT_DEVSUBTYPE_TOUCHPAD:
                    return "INPUT_DEVSUBTYPE_TOUCHPAD";
                case INPUT_DEVSUBTYPE_THUMBSTICK:
                    return "INPUT_DEVSUBTYPE_THUMBSTICK";
                default:
                    return "UNKNOWN";
                }

        }
    return "UNKNOWN";
    }

void DumpDeviceInfo(PCINPUT_DEVICE_INFORMATION pDeviceInfo)
    {
    DebugPrint("USBTEST: Device Information:\n");
    DebugPrint("   dwSize:         %d\n", pDeviceInfo->dwSize);
    DebugPrint("   bDeviceID:      %d\n", (DWORD)pDeviceInfo->bDeviceID);
    DebugPrint("   bDeviceType:    %s\n", GetDeviceTypeString(pDeviceInfo->bDeviceType));
    DebugPrint("   bDeviceSubType: %s\n", GetDeviceSubTypeString(pDeviceInfo->bDeviceType, pDeviceInfo->bDeviceSubtype));
    DebugPrint("   bPlayerSlot:    %d\n", (DWORD)pDeviceInfo->bPlayerSlot);
    }

void DumpDeviceState(PINPUT_FORMAT_GAME pGamePacket)
    {
    DebugPrint("USBTEST: Device State:\n");
    DebugPrint("   bSize:                       %d\n", pGamePacket->bSize);
    DebugPrint("   bReportId:                   %d\n", pGamePacket->bReportId);
    DebugPrint("   Analog Buttons:              ");
    for(int i=0; i<8; i++)
        {
        DebugPrint("%d ",(DWORD)pGamePacket->rgbAnalogButtons[i]);
        }
    DebugPrint("\n   Digital Button (bitfield):   0x%0.4x\n",(DWORD)pGamePacket->wButtons);
    DebugPrint("   DPAD(like POV):              0x%0.4x\n",(DWORD)pGamePacket->wDPad);
    DebugPrint("   Left Thumb Stick:            (%d,%d)\n",(DWORD)pGamePacket->wThumb1X, (DWORD)pGamePacket->wThumb1Y);
    DebugPrint("   Right Thumb Stick:           (%d,%d)\n",(DWORD)pGamePacket->wThumb2X, (DWORD)pGamePacket->wThumb2Y);
    DebugPrint("   Tilt Axes:                   (%d,%d)\n\n",(DWORD)pGamePacket->wTiltX, (DWORD)pGamePacket->wTiltY);
    }
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\dinputtest.h ===
BOOL CALLBACK EnumDevicesCallback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);
/*
class CXidDevice
{
	friend class CXidDeviceCollection;
	public:
		CXidDevice(PCINPUT_DEVICE_INFORMATION pDeviceInfo);
		~CXidDevice();
		void	Open();
		void	Close();
		BOOL	IsDevice(PCINPUT_DEVICE_INFORMATION pDeviceInfo);
		void	PollDevice();
		BOOL	ThresholdCheck();
	private:
		INPUT_DEVICE_INFORMATION	m_DeviceInfo;
		DWORD						m_dwDeviceHandle;
		CXidDevice					*m_pPrevDevice;
		CXidDevice					*m_pNextDevice;
		INPUT_FORMAT_GAME			m_InputBuffer;
		INPUT_FORMAT_GAME			m_InputBufferLast;
		DWORD						m_dwPacketNumber;
		DWORD						m_dwIdlePollCount;
};


class CXidDeviceCollection
{
	public:
		CXidDeviceCollection();
		~CXidDeviceCollection();
		void	Add(PCINPUT_DEVICE_INFORMATION pDeviceInfo);
		void	Remove(PCINPUT_DEVICE_INFORMATION pDeviceInfo);
		void	PollDevices();
		//void	PrintDeviceCount();
		//void	PrintDeviceList();
	private:
		int			m_iDeviceCount;
		CXidDevice	*m_pDevices;
};

void DeviceChanges(
	PCINPUT_DEVICE_INFORMATION DeviceInformation,
	BOOL fAdd,
	BOOL fEnum,
	CXidDeviceCollection *pDeviceCollection
	);

void DumpDeviceInfo(PCINPUT_DEVICE_INFORMATION pDeviceInfo);

void DumpDeviceState(PINPUT_FORMAT_GAME pGamePacket);
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\devicedump.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DeviceDump.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    05-30-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include <initguid.h>
#include <dinput.h>
#include <input.h>

#define MAX_DEVICES 64

BOOL CALLBACK DeviceInsert_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);
BOOL CALLBACK DeviceRemove_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);

class USBDevice
    {
    public:
        DWORD id;
        IDirectInput8 *pDI;
        IDirectInputDevice8 *pDID;
        LPCDIDEVICEINSTANCE devInstance;
    public:
        USBDevice();
    };

USBDevice::USBDevice()
    {
    id = 0;
    pDI = NULL;
    pDID = NULL;
    devInstance = NULL;
    }

struct EnumCallbackState
    {
    DWORD threadID;
    DWORD numFound;
    IDirectInput8 *pDI;
    USBDevice *devices;
    };


BOOL HasInput(DIXBOXCONTROLLERSTATE *data1, DIXBOXCONTROLLERSTATE *data2)
    {
    if(memcmp(data1, data2, sizeof(DIXBOXCONTROLLERSTATE)) == 0) return FALSE;

    return TRUE;
    }


void DumpControllerState(DWORD threadID, unsigned ID, DIXBOXCONTROLLERSTATE *controllerState)
    {
    DebugPrint("DITEST(%d): Input from %08X-0000-0000-0000-000000000000:\n"
        "   Reserved  = 0x%0.4X\n"
        "   dButtons  = 0x%0.4X\n"
        "   aButtons  = (%02X %02X %02X %02X %02X %02X %02X %02X)\n"
        "   DPAD      = 0x%0.4X\n"
        "   Thumb1    = (0x%0.4X, 0x%0.4X)\n"
        "   Thumb2    = (0x%0.4X, 0x%0.4X)\n"
        "   Tilt      = (0x%0.4X, 0x%0.4X)\n"
        ,
        threadID,
        ID,
        controllerState->Reserved,
        controllerState->bmButtons,
        controllerState->rgbAnalogButtons[0],
        controllerState->rgbAnalogButtons[1],
        controllerState->rgbAnalogButtons[2],
        controllerState->rgbAnalogButtons[3],
        controllerState->rgbAnalogButtons[4],
        controllerState->rgbAnalogButtons[5],
        controllerState->rgbAnalogButtons[6],
        controllerState->rgbAnalogButtons[7],
        controllerState->wDPAD,
        controllerState->wThumb1X,
        controllerState->wThumb1Y,
        controllerState->wThumb2X,
        controllerState->wThumb2Y,
        controllerState->wTiltX,
        controllerState->wTiltY
        );
    }

/*

Routine Description:

    

Arguments:

    

Return Value:

    

*/
DWORD DeviceDump_Test(HANDLE hLog, DWORD ThreadID)
    {
    HRESULT result;
    IDirectInput8 *pDI = NULL;

    USBDevice devices[MAX_DEVICES];
    EnumCallbackState state = { 0, 0, 0, devices };
	DIXBOXCONTROLLERSTATE controllerState[MAX_DEVICES][2];
    unsigned cs = 1;
    unsigned i;
    unsigned exitState = 0;
    DWORD time = GetTickCount();

    //__asm int 3;

    DebugPrint("DEVDUMP(%d): Creating DirectInput\n", ThreadID);
    result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL);
    if(result != DI_OK)
        {
        DebugPrint("DEVDUMP(%d): Creating DirectInput Failed (ec: %08X)\n", ThreadID, result);
        return -1;
        }
    state.pDI = pDI;

    // Enumerate Devices
    DebugPrint("DEVDUMP(%d): Enumerating devices\n\n\n", ThreadID);
    result = pDI->EnumDevices(0, DeviceInsert_Callback, (void*)&state, DIEDFL_ENUMANDNOTIFYINSERT);
    result = pDI->EnumDevices(0, DeviceRemove_Callback, (void*)&state, DIEDFL_NOTIFYREMOVE);

    DebugPrint("DITEST(%d): Device Watch...\n", ThreadID);
    DebugPrint("*************************************\n");
    DebugPrint("* Press A B A A on Device 0 to exit *\n");
    DebugPrint("*************************************\n");

    // Loop
    while(exitState < 8)
        {
        Sleep(8);
        InputPumpCallbacks();
        cs = !cs;

        for(i=0; i<MAX_DEVICES; i++)
            {
            if(devices[i].pDID)
                {
                devices[i].pDID->GetDeviceState(sizeof(DIXBOXCONTROLLERSTATE), &controllerState[i][cs]);

                // check to see if the exit combo (abaa) has been pressed
                if(i == 0 && HasInput(&controllerState[i][cs], &controllerState[i][!cs]))
                    {
                    if(exitState == 0 && controllerState[i][cs].rgbAnalogButtons[0] > 0) ++exitState;
                    else if(exitState == 1 && controllerState[i][cs].rgbAnalogButtons[0] < 10) ++exitState;
                    else if(exitState == 2 && controllerState[i][cs].rgbAnalogButtons[1] > 0) ++exitState;
                    else if(exitState == 3 && controllerState[i][cs].rgbAnalogButtons[1] < 10) ++exitState;
                    else if(exitState == 4 && controllerState[i][cs].rgbAnalogButtons[0] > 0) ++exitState;
                    else if(exitState == 5 && controllerState[i][cs].rgbAnalogButtons[0] < 10) ++exitState;
                    else if(exitState == 6 && controllerState[i][cs].rgbAnalogButtons[0] > 0) ++exitState;
                    else if(exitState == 7 && controllerState[i][cs].rgbAnalogButtons[0] < 10) ++exitState;
                    else exitState = 0;
                    }

                // Dump out the device state if it has changed
                if(HasInput(&controllerState[i][cs], &controllerState[i][!cs]))
                    {
                    DumpControllerState(ThreadID, i, &controllerState[i][cs]);
                    }
                }
            }
        }

    // End Enumeration
    DebugPrint("\n\nDEVDUMP(%d): Halting Enumeration\n", ThreadID);
    result = pDI->EnumDevices(0, DeviceInsert_Callback, (void*)&state, DIEDFL_HALTNOTIFYINSERT);
    result = pDI->EnumDevices(0, DeviceRemove_Callback, (void*)&state, DIEDFL_HALTNOTIFYREMOVE);

    // Clean up opened devices
    DebugPrint("DEVDUMP(%d): Cleaning up opened devices\n", ThreadID);
    for(i=0; i<MAX_DEVICES; i++)
        {
        if(devices[i].pDID)
            {
            devices[i].pDID->Unacquire();
            devices[i].pDID->Release();
            }
        }

    // Close DirectInput
    pDI->Release();

    return 0;
    }



BOOL CALLBACK DeviceInsert_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    if(!pvRef)
        {
        DebugPrint("DITEST(-): Found Device: but state is NULL\n");
        return DIENUM_CONTINUE;
        }

    DIDEVCAPS diDevCaps;
    DIPROPDWORD dipdw;
    diDevCaps.dwSize = sizeof(DIDEVCAPS);
    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj = 0;
    dipdw.diph.dwHow = DIPH_DEVICE;
    dipdw.dwData = true;

    EnumCallbackState *state = (EnumCallbackState*)pvRef;

    if(lpddi->guidInstance.Data1 >= MAX_DEVICES)
        {
        DebugPrint("DITEST(%d): Found Device but not saving it because id is too high\n", state->threadID);
        return DIENUM_CONTINUE;
        }
    ++state->numFound;

    state->pDI->CreateDevice(lpddi->guidInstance, (IDirectInputDevice8**)&(state->devices[lpddi->guidInstance.Data1].pDID), NULL);
    if(!state->devices[lpddi->guidInstance.Data1].pDID)
        {
        DebugPrint("DITEST(-): Found Device: but unable to Create it\n");
        return DIENUM_CONTINUE;
        }
    state->devices[lpddi->guidInstance.Data1].pDI = state->pDI;
    state->devices[lpddi->guidInstance.Data1].pDID->SetProperty(DIPROP_AUTOPOLL, &dipdw.diph);
    state->devices[lpddi->guidInstance.Data1].pDID->Acquire();
    state->devices[lpddi->guidInstance.Data1].devInstance = lpddi;

    DebugPrint("DITEST(%d): Found Device:\n"
        "   Device Type:   %X\n"
        "   Instance GUID: %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"
        "   Product GUID:  %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"
        ,
        state->threadID, lpddi->dwDevType, 
        lpddi->guidInstance.Data1, lpddi->guidInstance.Data2, lpddi->guidInstance.Data3, lpddi->guidInstance.Data4[0], lpddi->guidInstance.Data4[1], lpddi->guidInstance.Data4[2], lpddi->guidInstance.Data4[3], lpddi->guidInstance.Data4[4], lpddi->guidInstance.Data4[5], lpddi->guidInstance.Data4[6], lpddi->guidInstance.Data4[7],
        lpddi->guidProduct.Data1, lpddi->guidProduct.Data2, lpddi->guidProduct.Data3, lpddi->guidProduct.Data4[0], lpddi->guidProduct.Data4[1], lpddi->guidProduct.Data4[2], lpddi->guidProduct.Data4[3], lpddi->guidProduct.Data4[4], lpddi->guidProduct.Data4[5], lpddi->guidProduct.Data4[6], lpddi->guidProduct.Data4[7]
        );

    return DIENUM_CONTINUE;
    }

BOOL CALLBACK DeviceRemove_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    if(!pvRef)
        {
        DebugPrint("DITEST(-): Removing Device: but state is NULL\n");
        return DIENUM_CONTINUE;
        }

    EnumCallbackState *state = (EnumCallbackState*)pvRef;

    if(lpddi->guidInstance.Data1 >= MAX_DEVICES)
        {
        DebugPrint("DITEST(%d): Found Device but not saving it because id is too high\n", state->threadID);
        return DIENUM_CONTINUE;
        }
    --state->numFound;

    if(state->devices[lpddi->guidInstance.Data1].pDID == NULL)
        {
        DebugPrint("DITEST(-): Removing Device: but pDID is NULL\n");
        return DIENUM_CONTINUE;
        }

    state->devices[lpddi->guidInstance.Data1].pDID->Unacquire();
    state->devices[lpddi->guidInstance.Data1].pDID->Release();
    state->devices[lpddi->guidInstance.Data1].pDI = NULL;
    state->devices[lpddi->guidInstance.Data1].pDID = NULL;
    state->devices[lpddi->guidInstance.Data1].devInstance = NULL;

    DebugPrint("DITEST(%d): Removing Device:\n"
        "   Device Type:   %X\n"
        "   Instance GUID: %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"
        "   Product GUID:  %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"
        ,
        state->threadID, lpddi->dwDevType, 
        lpddi->guidInstance.Data1, lpddi->guidInstance.Data2, lpddi->guidInstance.Data3, lpddi->guidInstance.Data4[0], lpddi->guidInstance.Data4[1], lpddi->guidInstance.Data4[2], lpddi->guidInstance.Data4[3], lpddi->guidInstance.Data4[4], lpddi->guidInstance.Data4[5], lpddi->guidInstance.Data4[6], lpddi->guidInstance.Data4[7],
        lpddi->guidProduct.Data1, lpddi->guidProduct.Data2, lpddi->guidProduct.Data3, lpddi->guidProduct.Data4[0], lpddi->guidProduct.Data4[1], lpddi->guidProduct.Data4[2], lpddi->guidProduct.Data4[3], lpddi->guidProduct.Data4[4], lpddi->guidProduct.Data4[5], lpddi->guidProduct.Data4[6], lpddi->guidProduct.Data4[7]
        );

    return DIENUM_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\utils.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

extern bool FileExists(const char *filename);
extern bool FileExists(const WCHAR *filename);
extern DWORD FillFile(HANDLE hFile, DWORD size);
extern DWORD CreateFilledFile(const char *filename, DWORD size=16384);
extern DWORD CreateFilledFile(const WCHAR *filename, DWORD size=16384);
extern HANDLE FileOpen(const char *filename);
extern HANDLE FileOpen(const WCHAR *filename);
extern HANDLE FileOpenRW(const char *filename);
extern HANDLE FileOpenRW(const WCHAR *filename);
extern BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec);
extern DWORD FillHDPartition(const WCHAR *drive, WCHAR *lpFile);
extern void LogResourceStatus(HANDLE hLog, bool debugger);

class iLARGE_INTEGER
    {
    public: 
        __int64 value;

    public:
        iLARGE_INTEGER() { value = 0; }
        iLARGE_INTEGER(int i) { value = i; }
        iLARGE_INTEGER(DWORD i) { value = i; }
        iLARGE_INTEGER(__int64 i) { value = i; }
        iLARGE_INTEGER(const LARGE_INTEGER &i) { value = i.QuadPart; }

        operator int() {  return (int)value; }
        operator DWORD() {  return (DWORD)value; }
        operator __int64() {  return value; }
        operator LARGE_INTEGER() {  LARGE_INTEGER a; a.QuadPart=value; return a; }
    };

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\getdevicestatus.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GetDeviceStatus.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    05-30-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include <initguid.h>
#include <dinput.h>
#include <input.h>


BOOL CALLBACK GetDeviceStatus_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);

struct EnumCallbackState
    {
    DWORD threadID;
    DWORD numFound;
    DWORD mode;
    IDirectInput8* pDI;
    HANDLE hLog;
    };


/*

Routine Description:

    

Arguments:

    

Return Value:

    

*/
DWORD GetDeviceStatus_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HRESULT GetDeviceStatus(
      REFGUID rguidInstance  
    );
    */
    xSetFunctionName(hLog, "GetDeviceStatus");

    HRESULT result;
    IDirectInput8 *pDI = NULL;
    unsigned i;

    //__asm int 3;

    result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL);
    if(result != DI_OK)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to create the DirectInput interface (ec: %lX)", result);
        xEndVariation(hLog);
        return -1;
        }


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Checking plugged in devices")
        {
        EnumCallbackState state = { ThreadID, 0, 1, pDI, hLog };
        result = pDI->EnumDevices(0, GetDeviceStatus_Test_Callback, (void*)&state, DIEDFL_ENUMANDNOTIFYINSERT);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        xLog(hLog, XLL_INFO, "Found %u devices", state.numFound);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, GetDeviceStatus_Test_Callback, NULL, DIEDFL_HALTNOTIFYINSERT); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("{ 0xFFFF 0 0 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0xFFFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->GetDeviceStatus(guid);
        if(result == DIERR_INVALIDPARAM)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("{ 0 0 0 0 0 0 0 0 0 0 1 }")
        {
        GUID guid = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
        result = pDI->GetDeviceStatus(guid);
        if(result == DIERR_INVALIDPARAM)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("{ 0 1 0 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->GetDeviceStatus(guid);
        if(result == DIERR_INVALIDPARAM)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("{ 0 0 1 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->GetDeviceStatus(guid);
        if(result == DIERR_INVALIDPARAM)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("{ 0 0 0 1 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->GetDeviceStatus(guid);
        if(result == DIERR_INVALIDPARAM)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("{ 0x20 0 0 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0x20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->GetDeviceStatus(guid);
        if(result == DIERR_INVALIDPARAM)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("{ 0x21 0 0 0 0 0 0 0 0 0 0 }")
        {
        GUID guid = { 0x21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->GetDeviceStatus(guid);
        if(result == DIERR_INVALIDPARAM)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;

/*
    TESTCASE("Reciently removed")
        {
        // TODO plug in device x
        // TODO unplug device x
        GUID guid = { x, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        result = pDI->GetDeviceStatus(guid);
        if(result == DIERR_INVALIDPARAM)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
*/

    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        GUID guid = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        //DebugPrint("DITEST(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned maxLoop = 100000;
        for(i=0; i<maxLoop; i++)
            {
            //if(i%(maxLoop/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxLoop);
            result = pDI->GetDeviceStatus(guid);
            }
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    pDI->Release();
    return 0;
    }



BOOL CALLBACK GetDeviceStatus_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    if(!pvRef)
        {
        DebugPrint("DITEST(-): Found Device: but state is NULL\n");
        return DIENUM_CONTINUE;
        }

    EnumCallbackState *state = (EnumCallbackState*)pvRef;
    HANDLE hLog = state->hLog;
    ++state->numFound;

    HRESULT result;
    char buffer[1024];
    sprintf(buffer, "Device #%d", state->numFound);

    TESTCASE(buffer)
        {
        result = state->pDI->GetDeviceStatus(lpddi->guidInstance);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;

    if(state->mode > 0)
        {
        DebugPrint("DITEST(%d): Found Device:\n"
            "   Device Type:   %X\n"
            "   Instance GUID: %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"
            "   Product GUID:  %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"
            ,
            state->threadID, lpddi->dwDevType, 
            lpddi->guidInstance.Data1, lpddi->guidInstance.Data2, lpddi->guidInstance.Data3, lpddi->guidInstance.Data4[0], lpddi->guidInstance.Data4[1], lpddi->guidInstance.Data4[2], lpddi->guidInstance.Data4[3], lpddi->guidInstance.Data4[4], lpddi->guidInstance.Data4[5], lpddi->guidInstance.Data4[6], lpddi->guidInstance.Data4[7],
            lpddi->guidProduct.Data1, lpddi->guidProduct.Data2, lpddi->guidProduct.Data3, lpddi->guidProduct.Data4[0], lpddi->guidProduct.Data4[1], lpddi->guidProduct.Data4[2], lpddi->guidProduct.Data4[3], lpddi->guidProduct.Data4[4], lpddi->guidProduct.Data4[5], lpddi->guidProduct.Data4[6], lpddi->guidProduct.Data4[7]
            );
        }



    return DIENUM_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\ditestapi.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ditestAPI.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    05-30-2000  Created

*/

typedef DWORD (*APITEST_FUNC)(HANDLE hLog, DWORD ThreadID);

/*
    DirectInput API Tests
*/
extern DWORD Acquire_Test(HANDLE hLog, DWORD ThreadID);
extern DWORD CreateDevice_Test(HANDLE hLog, DWORD ThreadID);
extern DWORD DirectInputCreate_Test(HANDLE hLog, DWORD ThreadID);
extern DWORD EnumDevices_Test(HANDLE hLog, DWORD ThreadID);
extern DWORD GetCapabilities_Test(HANDLE hLog, DWORD ThreadID);
extern DWORD GetDeviceStatus_Test(HANDLE hLog, DWORD ThreadID);
extern DWORD DeviceDump_Test(HANDLE hLog, DWORD ThreadID);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\enumdevices.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    EnumDevices.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    05-30-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include <initguid.h>
#include <dinput.h>
#include <input.h>


BOOL CALLBACK EnumDevices_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);
BOOL CALLBACK EnumDevices_Test_CallbackBlank(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);

#define MODE_DIENUM_STOP 33
struct EnumCallbackState
    {
    DWORD threadID;
    DWORD numFound;
    DWORD mode;
    };


/*

Routine Description:

    

Arguments:

    

Return Value:

    

*/
DWORD EnumDevices_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HRESULT EnumDevices(
      DWORD dwDevType,
      LPDIENUMCALLBACK lpCallback,
      LPVOID pvRef,
      DWORD dwFlags
    );
    */
    xSetFunctionName(hLog, "EnumDevices");

    HRESULT result;
    IDirectInput8 *pDI = NULL;
    unsigned i;

    //__asm int 3;

    result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL);
    if(result != DI_OK)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to create the DirectInput interface (ec: %lX)", result);
        xEndVariation(hLog);
        return -1;
        }


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NULL")
        {
        BUGGED(345, "This causes the folowing tests to fail!");
        result = pDI->EnumDevices(0, NULL, NULL, DIEDFL_ENUMANDNOTIFYINSERT);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, NULL, NULL, DIEDFL_HALTNOTIFYINSERT); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Flags==DIEDFL_ENUMANDNOTIFYINSERT")
        {
        EnumCallbackState state = { ThreadID, 0, 1 };
        result = pDI->EnumDevices(0, EnumDevices_Test_Callback, (void*)&state, DIEDFL_ENUMANDNOTIFYINSERT);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        DebugPrint("DITEST(%d): Insert a new device...\n", ThreadID);
        for(unsigned j=0; j<1200; j++)
            {
            Sleep(16);
            InputPumpCallbacks();
            }

        xLog(hLog, XLL_INFO, "Found %u devices", state.numFound);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, EnumDevices_Test_Callback, NULL, DIEDFL_HALTNOTIFYINSERT); });
    TESTCASE("DIENUM_STOP")
        {
        EnumCallbackState state = { ThreadID, 0, MODE_DIENUM_STOP };
        result = pDI->EnumDevices(0, EnumDevices_Test_Callback, (void*)&state, DIEDFL_ENUMANDNOTIFYINSERT);
        if(state.numFound == 0 && result == DI_OK)
            TESTPASS(hLog, "Found %u devices (ec: %lX)", state.numFound, result);
        else
            TESTFAIL(hLog, "Found %u devices (ec: %lX)", state.numFound, result);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, EnumDevices_Test_Callback, NULL, DIEDFL_HALTNOTIFYINSERT); });
    // TODO device filter


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Flags == ~0")
        {
        EnumCallbackState state = { ThreadID, 0, 1 };
        result = pDI->EnumDevices(0, EnumDevices_Test_Callback, (void*)&state, ~0);
        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, EnumDevices_Test_Callback, NULL, DIEDFL_HALTNOTIFYINSERT); });
    TESTCASE("Filter == ~0")
        {
        EnumCallbackState state = { ThreadID, 0, 1 };
        result = pDI->EnumDevices(~0, EnumDevices_Test_Callback, (void*)&state, ~0);
        if(state.numFound == 0 && result == DI_OK)
            TESTPASS(hLog, "Found %u devices (ec: %lX)", state.numFound, result);
        else
            TESTFAIL(hLog, "Found %u devices (ec: %lX)", state.numFound, result);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, EnumDevices_Test_Callback, NULL, DIEDFL_HALTNOTIFYINSERT); });


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        EnumCallbackState state = { ThreadID, 0, 0 };
        //DebugPrint("DITEST(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned maxLoop = 1000;
        for(i=0; i<maxLoop; i++)
            {
            //if(i%(maxLoop/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxLoop);
            result = pDI->EnumDevices(0, EnumDevices_Test_CallbackBlank, (void*)&state, DIEDFL_ENUMANDNOTIFYINSERT);
            pDI->EnumDevices(0, EnumDevices_Test_CallbackBlank, NULL, DIEDFL_HALTNOTIFYINSERT);
            result = pDI->EnumDevices(0, EnumDevices_Test_CallbackBlank, (void*)&state, DIEDFL_NOTIFYREMOVE);
            pDI->EnumDevices(0, EnumDevices_Test_CallbackBlank, NULL, DIEDFL_HALTNOTIFYREMOVE);
            }
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    pDI->Release();
    return 0;
    }



BOOL CALLBACK EnumDevices_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    if(!pvRef)
        {
        DebugPrint("DITEST(-): Found Device: but state is NULL\n");
        return DIENUM_CONTINUE;
        }

    EnumCallbackState *state = (EnumCallbackState*)pvRef;
    if(state->mode == MODE_DIENUM_STOP)
        {
        return DIENUM_STOP;
        }

    ++state->numFound;

    if(state->mode > 0)
        {
        DebugPrint("DITEST(%d): Found Device:\n"
            "   Device Type:   %X\n"
            "   Instance GUID: %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"
            "   Product GUID:  %08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"
            ,
            state->threadID, lpddi->dwDevType, 
            lpddi->guidInstance.Data1, lpddi->guidInstance.Data2, lpddi->guidInstance.Data3, lpddi->guidInstance.Data4[0], lpddi->guidInstance.Data4[1], lpddi->guidInstance.Data4[2], lpddi->guidInstance.Data4[3], lpddi->guidInstance.Data4[4], lpddi->guidInstance.Data4[5], lpddi->guidInstance.Data4[6], lpddi->guidInstance.Data4[7],
            lpddi->guidProduct.Data1, lpddi->guidProduct.Data2, lpddi->guidProduct.Data3, lpddi->guidProduct.Data4[0], lpddi->guidProduct.Data4[1], lpddi->guidProduct.Data4[2], lpddi->guidProduct.Data4[3], lpddi->guidProduct.Data4[4], lpddi->guidProduct.Data4[5], lpddi->guidProduct.Data4[6], lpddi->guidProduct.Data4[7]
            );
        }

    return DIENUM_CONTINUE;
    }

BOOL CALLBACK EnumDevices_Test_CallbackBlank(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    return DIENUM_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\directinputcreate.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DirectInput8Create.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    05-30-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include <initguid.h>
#include <dinput.h>
#include <input.h>

/*

Routine Description:

    

Arguments:

    

Return Value:

    

*/
DWORD DirectInputCreate_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HRESULT WINAPI DirectInput8Create(
      HINSTANCE hinst,
      DWORD dwVersion,
      REFIID riidltf,
      LPVOID * ppvOut,
      LPUNKNOWN punkOuter
    );
    */
    xSetFunctionName(hLog, "DirectInput8Create");

    HRESULT result;
    IDirectInput8 *pDI = NULL;
    unsigned i;

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("ver=0, pID=NULL")
        {
        result = DirectInput8Create(NULL, 0, IID_IDirectInput8, NULL, NULL);
        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE_CLEAN({ if(pDI) pDI->Release(); pDI=NULL; });
    TESTCASE("ver=current, pID=NULL")
        {
        result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, NULL, NULL);
        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE_CLEAN({ if(pDI) pDI->Release(); pDI=NULL; });


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Normal Creation")
        {
        result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE_CLEAN({ if(pDI) pDI->Release(); pDI=NULL; });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("DI version 1")
        {
        result = DirectInput8Create(NULL, 0x0100, IID_IDirectInput8, (void**)&pDI, NULL);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE_CLEAN({ if(pDI) pDI->Release(); pDI=NULL; });
    TESTCASE("DI version 8.1")
        {
        result = DirectInput8Create(NULL, 0x0801, IID_IDirectInput8, (void**)&pDI, NULL);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE_CLEAN({ if(pDI) pDI->Release(); pDI=NULL; });
    TESTCASE("DI version 10")
        {
        result = DirectInput8Create(NULL, 0x0A00, IID_IDirectInput8, (void**)&pDI, NULL);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE_CLEAN({ if(pDI) pDI->Release(); pDI=NULL; });


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        //DebugPrint("DITEST(%d): This test takes a long time to run...\n", ThreadID);
        unsigned maxLoop = 100000;
        for(i=0; i<maxLoop; i++)
            {
            //if(i%(maxLoop/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxLoop);
            result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL);
            if(pDI) pDI->Release();
            pDI = NULL;
            }
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\getcapabilities.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GetCapabilities.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    05-30-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include <initguid.h>
#include <dinput.h>
#include <input.h>


BOOL CALLBACK GetCapabilities_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef);

struct EnumCallbackState
    {
    DWORD threadID;
    DWORD numFound;
    DWORD mode;
    IDirectInput8* pDI;
    HANDLE hLog;
    };


/*

Routine Description:

    

Arguments:

    

Return Value:

    

*/
DWORD GetCapabilities_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HRESULT GetCapabilities(
      LPDIDEVCAPS lpDIDevCaps
    );
    */
    xSetFunctionName(hLog, "GetCapabilities");

    HRESULT result;
    IDirectInput8 *pDI = NULL;
    IDirectInputDevice8 *pDID = NULL;
    unsigned i;
    DIDEVCAPS diDevCaps;
    DIPROPDWORD dipdw;
    diDevCaps.dwSize = sizeof(DIDEVCAPS);
    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj = 0;
    dipdw.diph.dwHow = DIPH_DEVICE;
    dipdw.dwData = false;

    //__asm int 3;

    result = DirectInput8Create(NULL, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&pDI, NULL);
    if(result != DI_OK)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to create the DirectInput interface (ec: %lX)", result);
        xEndVariation(hLog);
        return -1;
        }

    GUID guid = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    result = pDI->CreateDevice(guid, (IDirectInputDevice8**)&pDID, NULL);
    if(result != DI_OK || !pDID)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "CreateDevice failed (ec: %lX)", result);
        xEndVariation(hLog);
        return -1;
        }
    pDID->SetProperty(DIPROP_AUTOPOLL, &dipdw.diph);
    pDID->Acquire();

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("NULL")
        {
        diDevCaps.dwSize = sizeof(DIDEVCAPS);
        result = pDID->GetCapabilities(NULL);
        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Checking plugged in devices")
        {
        EnumCallbackState state = { ThreadID, 0, 1, pDI, hLog };
        result = pDI->EnumDevices(0, GetCapabilities_Test_Callback, (void*)&state, DIEDFL_ENUMANDNOTIFYINSERT);
        if(result == DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);

        xLog(hLog, XLL_INFO, "Found %u devices", state.numFound);
        } ENDTESTCASE_CLEAN({ pDI->EnumDevices(0, GetCapabilities_Test_Callback, NULL, DIEDFL_HALTNOTIFYINSERT); });


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("dwSize == 0")
        {
        diDevCaps.dwSize = 0;
        result = pDID->GetCapabilities(NULL);
        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("dwSize == 1")
        {
        diDevCaps.dwSize = 0;
        result = pDID->GetCapabilities(NULL);
        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("dwSize == 0xFFFF")
        {
        diDevCaps.dwSize = 0xFFFF;
        result = pDID->GetCapabilities(NULL);
        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("dwSize == ~0")
        {
        diDevCaps.dwSize = ~0;
        result = pDID->GetCapabilities(NULL);
        if(result != DI_OK)
            TESTPASS(hLog, "(ec: %lX)", result);
        else
            TESTFAIL(hLog, "(ec: %lX)", result);
        } ENDTESTCASE;
    TESTCASE("Recently removed")
        {
        // TODO plug in device x
        // TODO unplug device x
        BLOCKED(0, "Need USB Simulator");
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        //DebugPrint("DITEST(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned maxLoop = 100000;
        for(i=0; i<maxLoop; i++)
            {
            //if(i%(maxLoop/10) == 0) DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxLoop);
            diDevCaps.dwSize = sizeof(DIDEVCAPS);
            result = pDID->GetCapabilities(&diDevCaps);
            }
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    pDID->Unacquire();
    pDID->Release();
    pDI->Release();
    return 0;
    }



BOOL CALLBACK GetCapabilities_Test_Callback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
    {
    if(!pvRef)
        {
        DebugPrint("DITEST(-): Found Device: but state is NULL\n");
        return DIENUM_CONTINUE;
        }

    EnumCallbackState *state = (EnumCallbackState*)pvRef;
    HANDLE hLog = state->hLog;
    ++state->numFound;

    HRESULT result;
    char buffer[1024];
    sprintf(buffer, "Device #%d", state->numFound);

    IDirectInputDevice8 *pDID = NULL;
    DIDEVCAPS diDevCaps;
    DIPROPDWORD dipdw;
    diDevCaps.dwSize = sizeof(DIDEVCAPS);
    dipdw.diph.dwSize = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj = 0;
    dipdw.diph.dwHow = DIPH_DEVICE;
    dipdw.dwData = false;

    TESTCASE(buffer)
        {
        result = state->pDI->CreateDevice(lpddi->guidInstance, (IDirectInputDevice8**)&pDID, NULL);

        if(result != DI_OK || !pDID)
            {
            sprintf(buffer, "CreateDevice failed (ec: %lX)", result);
            BLOCKED(0, buffer);
            }

        pDID->SetProperty(DIPROP_AUTOPOLL, &dipdw.diph);
        pDID->Acquire();
        result = pDID->GetCapabilities(&diDevCaps);

        if(result == DI_OK)
            {
            TESTPASS(hLog, "(ec: %lX)", result);
            /*
            DebugPrint("--------------------------------------------\n", diDevCaps.dwAxes);
            DebugPrint("diDevCaps.dwAxes                = 0x%0.8x\n", diDevCaps.dwAxes);
            DebugPrint("diDevCaps.dwButtons             = 0x%0.8x\n", diDevCaps.dwButtons);
            DebugPrint("diDevCaps.dwDevType             = 0x%0.8x\n", diDevCaps.dwDevType);
            DebugPrint("diDevCaps.dwFFDriverVersion     = 0x%0.8x\n", diDevCaps.dwFFDriverVersion);
            DebugPrint("diDevCaps.dwFFMinTimeResolution = 0x%0.8x\n", diDevCaps.dwFFMinTimeResolution);
            DebugPrint("diDevCaps.dwFFSamplePeriod      = 0x%0.8x\n", diDevCaps.dwFFSamplePeriod);
            DebugPrint("diDevCaps.dwFirmwareRevision    = 0x%0.8x\n", diDevCaps.dwFirmwareRevision);
            DebugPrint("diDevCaps.dwFlags               = 0x%0.8x\n", diDevCaps.dwFlags);
            DebugPrint("diDevCaps.dwHardwareRevision    = 0x%0.8x\n", diDevCaps.dwHardwareRevision);
            DebugPrint("diDevCaps.dwPOVs                = 0x%0.8x\n", diDevCaps.dwPOVs);
            */
            }
        else
            {
            TESTFAIL(hLog, "(ec: %lX)", result);
            }

        pDID->Unacquire();
        pDID->Release();
        pDID = NULL;
        } ENDTESTCASE_CLEAN({ if(pDID) pDID->Release(); pDID=NULL; });

    return DIENUM_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\utils.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif


/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    char *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
bool FileExists(const char *filename)
    {
    WIN32_FIND_DATAA FindFileData;
    HANDLE hFind;
    bool retval = false;

    hFind = FindFirstFileA(filename, &FindFileData);

    if(hFind != INVALID_HANDLE_VALUE)
        {
        retval = true;
        }
    FindClose(hFind);

    return retval;
    }


/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    unsigned short *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
bool FileExists(const WCHAR *filename)
    {
    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind;
    bool retval = false;

    hFind = FindFirstFileW(filename, &FindFileData);

    if(hFind != INVALID_HANDLE_VALUE)
        {
        retval = true;
        }
    FindClose(hFind);

    return retval;
    }


/*

Routine Description:

    Creates a new file and fills it with x bytes of garbage

Arguments:

    char *filename - the name of the file to create
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD CreateFilledFile(const char *filename, DWORD size /*=16384*/)
    {
    HANDLE file = CreateFileA(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    size = FillFile(file, size);

    CloseHandle(file);

    return size;
    return size;
    }


/*

Routine Description:

    Creates a new file and fills it with x bytes of garbage

Arguments:

    unsigned short *filename - the name of the file to create
    DWORD size - how big the file should be (defaults to 16k)

Return Value:

    DWORD actual size of file

*/
DWORD CreateFilledFile(const WCHAR *filename, DWORD size /*=16384*/)
    {
    HANDLE file = CreateFileW(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    size = FillFile(file, size);

    CloseHandle(file);

    return size;
    }


/*

Routine Description:

    Fills an opened file with x bytes of garbage

Arguments:

    HANDLE hFile - handle to opened file
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD FillFile(HANDLE hFile, DWORD size)
    {
    WCHAR *error = NULL;
    char w = 'X';
    DWORD wsize = sizeof(w);
    DWORD errCode = 0;

    do
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            error = L"unable to create/open file";
            errCode = GetLastError();
            break;
            }

        if(size == 0) break;

        if(SetFilePointer(hFile, size-1, NULL, FILE_BEGIN) != size-1)
            {
            error = L"unable to size file";
            errCode = GetLastError();
            break;
            }

        if(WriteFile(hFile, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = L"unable to write last byte";
            errCode = GetLastError();
            break;
            }
        } while(0);

    FlushFileBuffers(hFile);

    if(error)
        {
        DebugPrint("DITEST: FillFile(%ld) - %ws (ec: %d)\n", size, error, errCode);
        size = 0;
        }

    return size;
    }

/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpen(const char *filename)
    {
    return CreateFileA(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }


/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    unsigned short *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpen(const WCHAR *filename)
    {
    return CreateFileW(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }


/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpenRW(const char *filename)
    {
    return CreateFileA(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }


/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    unsigned short *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpenRW(const WCHAR *filename)
    {
    return CreateFileW(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }


/*

Routine Description:

    Generates a FILETIME structure from the date components by calling 
    SystemTimeToFileTime

Arguments:

    LPFILETIME fileTime - pointer to the FILETIME struct to populate with the date
    WORD year
    WORD month
    WORD day
    WORD hour
    WORD min
    WORD sec
    WORD msec

Return Value:

    BOOL - returns the result from SystemTimeToFileTime

*/
BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec)
    {
    SYSTEMTIME sysTime;

    sysTime.wYear = year;
    sysTime.wMonth = month;
    sysTime.wDay = day;
    sysTime.wHour = hour;
    sysTime.wMinute = min;
    sysTime.wSecond = sec;
    sysTime.wMilliseconds = msec;

    return SystemTimeToFileTime(&sysTime, fileTime);
    }

/*

Routine Description:


Arguments:

    drive - Drive to fill up, it should be in the form 
        C:\
        D:\
        etc.
    lpFile - This function will populate buffer with the name of the file created

Return Value:

    DWORD return code from GetLastError in the event of a problem

*/
DWORD FillHDPartition(const WCHAR *drive, WCHAR *lpFile)
    {
    if(!drive || !lpFile) return ERROR_INVALID_PARAMETER;

    DWORD error = 0;
    char w = 'X';
    DWORD wsize = sizeof(w);
    LARGE_INTEGER distance;
    LARGE_INTEGER size;
    ULARGE_INTEGER available;
    ULARGE_INTEGER total;
    ULARGE_INTEGER free;

    DebugPrint("DITEST: Filling HD Partition: %ws...\n", drive);

    wsprintf(lpFile, L"%wsFullHD_%lX.txt", drive, GetCurrentThreadId());

    HANDLE file = CreateFile(lpFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
    if(file == INVALID_HANDLE_VALUE)
        {
        return GetLastError();
        }

    // Get the disk space free
    GetDiskFreeSpaceEx(drive, &available, &total, &free);
    distance.QuadPart = (__int64)available.QuadPart - 256;
    size.QuadPart = 0;

    // Do a test write
    if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
        {
        error = GetLastError();
        CloseHandle(file);
        return error;
        }

    // write as big as a file as possible
    do
        {
        distance.QuadPart -= 256;
        if(SetFilePointerEx(file, distance, &size, FILE_BEGIN) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("SetFilePointerEx (ec: %lu)\n", error);
            }
        else if(size.QuadPart != distance.QuadPart)
            {
            error = 99;
            //DebugPrint("SetFilePointerEx size != dist\n");
            }
        else if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("WriteFile (ec: %lu)\n", error);
            }
        else
            {
            error = 0;
            }

        } while(error);

    // clean up
    if(FlushFileBuffers(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("FlushFileBuffers (ec: %lu)\n", error);
        }
    if(CloseHandle(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("CloseHandle (ec: %lu)\n", error);
        }

    DebugPrint("DITEST: Filled  HD Partition. %ws(%I64d)\n", lpFile, size.QuadPart);

    return error;
    }

/*

Routine Description:

    Writes system resource usage information to the specified log file 
    and/or to the debugger.

    Be sure to include extern "C" { "ntos.h" } to use MmQueryStatistics

    MM_STATISTICS:
        ULONG TotalPhysicalPages;
        ULONG AvailablePages;
        ULONG VirtualMemoryBytesCommitted;
        ULONG VirtualMemoryBytesReserved;
        ULONG CachePagesCommitted;
        ULONG PoolPagesCommitted;
        ULONG StackPagesCommitted;
        ULONG ImagePagesCommitted;

Arguments:

    HANDLE hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    bool debugger - true sends memory data to the debugger

Return Value:

    None

*/
void LogResourceStatus(HANDLE hLog, bool debugger)
    {
    const DWORD pageSize = 4096;
    MM_STATISTICS mmStats;
    PS_STATISTICS psStats;

    // initialize the stat info
    memset(&mmStats, 0, sizeof(MM_STATISTICS));
    mmStats.Length = sizeof(MM_STATISTICS);
    memset(&psStats, 0, sizeof(PS_STATISTICS));
    psStats.Length = sizeof(PS_STATISTICS);

    // gather all the data
    MmQueryStatistics(&mmStats);
    PsQueryStatistics(&psStats);

    // display/write the data
    if(hLog)
        {
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        xLog(hLog, XLL_INFO, "   Total:     %lu", mmStats.TotalPhysicalPages*pageSize);
        xLog(hLog, XLL_INFO, "   Available: %lu", mmStats.AvailablePages*pageSize);
        xLog(hLog, XLL_INFO, "   Cache:     %lu", mmStats.CachePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Pool:      %lu", mmStats.PoolPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Stack:     %lu", mmStats.StackPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Image:     %lu", mmStats.ImagePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Handles:   %lu", psStats.HandleCount);
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        }
    if(debugger)
        {
        DebugPrint("MEM: Available=%lu, Cache=%lu, Pool=%lu, Stack=%lu, Image=%lu, Handles=%lu\n", mmStats.AvailablePages*pageSize, mmStats.CachePagesCommitted*pageSize, mmStats.PoolPagesCommitted*pageSize, mmStats.StackPagesCommitted*pageSize, mmStats.ImagePagesCommitted*pageSize, psStats.HandleCount);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dinput\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_
#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif

// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>


#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
{
ULONG DebugPrint(PCHAR Format, ...);
}


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dvdprod\main.cpp ===
/* ++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    initializes all global variables, contains main loop, init. The module is using remote controller to control duke's motor.
	there is a file called buttoncontrol.ini to specify all codes. it can be changed to satisfy different requirement. This 
	application supports two dukes right now, it can be modified to support more than two dukes easily.

Author:

     Bing Li (a-bingli) 2001 May
     Mitchell Dernis (mitchd) 2001 July - Rewrite

-- */

#include <xtl.h>
#include <xboxp.h>
#include <time.h>
#include <stdio.h>
#include <draw.h>


//
//  The kernel exports this, it is just not in a public header
//
extern "C" 
{
    ULONG DebugPrint(PCHAR Format,...);
}

//---------------------------------------------------
// Filenames
//---------------------------------------------------
const char INI_FILENAME[]                = "t:\\buttoncontrol.ini";
const char DVD_REFERENCE_CODE_FILENAME[] = "d:\\dvdsource.lib";
const char DVD_DOWNLOAD_CODE_FILENAME[]  = "t:\\dvdcode.lib";

//--------------------------------------------------------------
//  Colors
//--------------------------------------------------------------
#define COLOR_BLACK   0xFF000000
#define COLOR_RED     0xFFFF0000
#define COLOR_GREEN   0xFF00FF00
#define COLOR_BLUE    0xFF0000FF
#define COLOR_ORANGE  0xFFFFFF00
#define COLOR_MAGENTA 0xFFFF00FF
#define COLOR_CYAN    0xFF00FFFF
#define COLOR_WHITE   0xFFFFFFFF

//--------------------------------------------------------------
//  Messages
//--------------------------------------------------------------
const char WAIT_FOR_DEVICE_INSERT[] = "Insert DVD IR Remote Receiver";

//--------------------------------------------------------------
// Remote Code Table - this table drives the remote code testing
//--------------------------------------------------------------
#define BUTTON_PRESS_TIMEOUT 10000 //Timeout for pressing a button (in ms)
#define MAX_BUTTON_TEST_ENTRIES 40
struct BUTTON_TEST_TABLE
{
    LPSTR  Name;       // Name of the button on the remote controller
    WORD   ButtonCode; // Remote Code of the button
	WORD   MotorCode;  // Motor(s) that operate the remote button
};
BUTTON_TEST_TABLE g_ButtonTestTable[MAX_BUTTON_TEST_ENTRIES+1] = {0};

//----------------------------------------------------------------
// Image Buffers
//----------------------------------------------------------------
#define MAX_IMAGE_SIZE 2000000

DWORD g_dwReferenceImageLength;                  // Size of Reference Image
BYTE  g_rgbReferenceImageBuffer[MAX_IMAGE_SIZE]; // Buffer for the Reference ROM image
BYTE  g_rgbDownloadImageBuffer[MAX_IMAGE_SIZE];  // Buffer for the Downloaded ROM image

//----------------------------------------------------------------
// Forward Declarations - Implemented in order of declaration
//----------------------------------------------------------------
void  ReadButtonTestTable(LPCSTR pszIniFilename);
LPSTR SkipWhitespace(LPSTR pszString);
void  LoadDvdReferenceImage(LPCSTR pszFilename);
DWORD WaitForDvdReceiverInsertion();
BOOL  DownLoadAndVerifyCode(DWORD dwPort);
void  WriteImageToFile(LPCSTR pszFilename, PVOID pvBuffer, DWORD dwBytes);
BOOL  RunButtonTest(DWORD dwPort);
void  OperateMotors(WORD wMotorCode, BOOL fOn);
void  DisplayMessage(DWORD dwColor, LPCSTR pszMessage,...);
void  DisplayFailure(LPCSTR pszMessage,...);
void  DisplaySuccess();
void  CriticalError(LPSTR pszErrorString,...);


//------------------------------------------------------------------------------
// Main Loop
//------------------------------------------------------------------------------
void __cdecl main()
/*++
 Routine Description:
    This operates the main loop of the test.  The following steps are
    performed.

    1) Wait for DVD Remote to be inserted.
    2) Download Code and Compare to Existing Image.
    3) Walk through button test.  (operating motors)
  
    Each of the routines are responsible for display
    status as they go.

--*/
{
    //
    //  Initialize core peripheral port support
    //

    XInitDevices(0,NULL);

    //
    //  Initialize the Drawing Library
    //

    drInit();

    //
    //  Load the remote code table.
    //

    ReadButtonTestTable(INI_FILENAME);

    //
    //  Load the test DVD code image.
    //
    LoadDvdReferenceImage(DVD_REFERENCE_CODE_FILENAME);

    //
    //  Show the insert device screen.
    //

    DisplayMessage(COLOR_CYAN, WAIT_FOR_DEVICE_INSERT);

    //
    //  Loop Forever.
    //

    while(TRUE)
    {
        DWORD dwPort;

        //
        //  Wait for a device insertion
        //  

        dwPort = WaitForDvdReceiverInsertion();

        //
        //  Download the code and verify it.
        //

        if(DownLoadAndVerifyCode(dwPort))
        {
            //
            //  If verification Passed, run the button test.
            //

            if(RunButtonTest(dwPort))
            {
                //
                //  If RunButtonTest also passed
                //  display success.
                //

                DisplaySuccess();
            }
        }
    }
}

void ReadButtonTestTable(LPCSTR pszIniFilename)
/*++
 Routine Description:
  Reads the .ini file to fill the remote code table.

 File Format:
  Each line consists of a button name, a remote code, and a motor code.
  All Items must be on the same line, and are comma separated
  
  button name: a quoted string.
  remote code: numerical value of string. 0xHHHH, or may be decimal DDDDD
  motor  code: bit field for motors to operate, either hexadecimal or
               decimal.
--*/
{
    char lineBuffer[256];
    char *pStartPhrase, *pEndPhrase;
    int  iLineNumber, iNameLen;
    int  iButtonEntry = 0;

    FILE *hIniFile = fopen(pszIniFilename, "rt");
    if(!hIniFile)
    {
      CriticalError("Could not open \'%s\'", pszIniFilename);
    }
    
    DebugPrint("Processing \'%s\':\n", pszIniFilename);

    //
    //  Process One line at a time
    //

    iLineNumber = 0;
    while(fgets(lineBuffer, sizeof(lineBuffer), hIniFile))
    {
        LPSTR pszButtonName;
        DWORD dwButtonCode;
        DWORD dwMotorCode;

        //
        // Increment Line Number
        //
        iLineNumber++;

        //
        // Skip comment lines
        //

        if(0==strncmp("//", lineBuffer, 2)) continue;

        //
        // Skip blank lines
        //
        pStartPhrase = SkipWhitespace(lineBuffer);
        if(!pStartPhrase)
        {
            continue;
        }
        
        //
        // Isolate Button Name in line
        //
        if(*pStartPhrase++ != '\"')
        {
            DebugPrint("ERROR (line %d): Name of button must be quoted. Skipping line.\n", iLineNumber);
            continue;
        }
        pEndPhrase = strchr(pStartPhrase, '\"');
        if(!pEndPhrase)
        {
            DebugPrint("ERROR (line %d): Cannot find closing quote for button name. Skipping line.\n", iLineNumber);
            continue;
        }
        pszButtonName = pStartPhrase;
        *pEndPhrase++ = '\0';

        //
        //  Now, get the button code.
        //
        pStartPhrase = SkipWhitespace(pEndPhrase);
        if(!pStartPhrase || *pStartPhrase++!=',')
        {
            DebugPrint("ERROR (line %d): Expecting comma after name of button. Skipping line.\n", iLineNumber);
            continue;   
        }
        pStartPhrase = SkipWhitespace(pStartPhrase);
        dwButtonCode = strtoul(pStartPhrase, &pEndPhrase, 0);
        if(pStartPhrase==pEndPhrase)
        {
            DebugPrint("ERROR (line %d): Expecting button code after name of button. Skipping line.\n", iLineNumber);
            continue;   
        }
        if(dwButtonCode > 0xFFFF)
        {
            DebugPrint("ERROR (line %d): Button code must be less than or equal 0xFFFF. Skipping line.\n", iLineNumber);
            continue;   
        }

        //
        //  Finally, get the motor code.
        //

        pStartPhrase = SkipWhitespace(pEndPhrase);
        if(!pStartPhrase || *pStartPhrase++!=',')
        {
            DebugPrint("ERROR (line %d): Expecting comma after button code. Skipping line.\n", iLineNumber);
            continue;   
        }
        pStartPhrase = SkipWhitespace(pStartPhrase);
        dwMotorCode = strtoul(pStartPhrase, &pEndPhrase, 0);
        if(pStartPhrase==pEndPhrase)
        {
            DebugPrint("ERROR (line %d): Expecting motor code after button code. Skipping line.\n", iLineNumber);
            continue;   
        }
        if(dwMotorCode > 0xFFFF)
        {
            DebugPrint("ERROR (line %d): Motor code must be less than or equal 0xFFFF. Skipping line.\n", iLineNumber);
            continue;
        }
        
        //
        //  Scan to end of line, and make sure that it is only white
        //

        pStartPhrase = SkipWhitespace(pEndPhrase);
        if(pStartPhrase)
        {
            DebugPrint("WARNING (line %d): Unexpected characters \'%s\' at end of line. Process line anyway\n", iLineNumber, pStartPhrase);
            continue;   
        }

        //
        //  Are there entries left in the table?
        //

        if(iButtonEntry >= MAX_BUTTON_TEST_ENTRIES)
        {
            DebugPrint("WARNING (line %d): Too many commands in ini file. Increase MAX_BUTTON_TEST_ENTRIES and recompile.\n", iLineNumber, pStartPhrase);
            continue;   
        }

        //
        //  Copy the entry
        //

        iNameLen = strlen(pszButtonName)+1;
        g_ButtonTestTable[iButtonEntry].Name = new char[iNameLen];
        if(NULL==g_ButtonTestTable[iButtonEntry].Name)
        {
            CriticalError("Couldn't Allocate Memory For Button Test Entry");
        }
        strcpy(g_ButtonTestTable[iButtonEntry].Name, pszButtonName);
        g_ButtonTestTable[iButtonEntry].ButtonCode =  (WORD)dwButtonCode;
        g_ButtonTestTable[iButtonEntry].MotorCode = (WORD)dwMotorCode;

        //
        //  Spew, what we did.
        //
        DebugPrint("%d: \'%s\',wButtonCode = 0x%0.4x,wMotorCode = 0x%0.4x\n",
                    iButtonEntry,
                    g_ButtonTestTable[iButtonEntry].Name,
                    g_ButtonTestTable[iButtonEntry].ButtonCode,
                    g_ButtonTestTable[iButtonEntry].MotorCode
                    );

        //
        //  Ready for next entry
        //
        iButtonEntry++;
    }
    fclose(hIniFile);
}

LPSTR SkipWhitespace(LPSTR pszString)
/*++
  Routine Description:
   Skips over whitespace in a string.
--*/
{
    while(pszString && *pszString)
    {
        if(
            (*pszString == '\t') ||
            (*pszString == ' ')  ||
            (*pszString == '\n') ||
            (*pszString == '\r')
        )
        {
            pszString++;
        } else
        {
            return pszString;
        }
    }
    return NULL;
}

void LoadDvdReferenceImage(LPCSTR pszFilename)
/*++
  Routine Description:
    Read in the DVD Reference Image.
--*/
{
    HANDLE hFile;
    DWORD  dwBogus;
    char   szFormatBuffer[1024];
    
    //
    //  Open the file
    //

    hFile = CreateFile(pszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if(FAILED(hFile))
    {
        CriticalError("Couldn't open DVD code reference file, \'%s\'", pszFilename);
    }

    //
    //  Get the image size
    //

    g_dwReferenceImageLength = GetFileSize(hFile, &dwBogus);
    if(MAX_IMAGE_SIZE < g_dwReferenceImageLength)
    {
        CriticalError("Image buffer is not big enough for reference image.");
    }

    //
    //  Read the reference image
    //

    if(!ReadFile(hFile, g_rgbReferenceImageBuffer, g_dwReferenceImageLength, &dwBogus, NULL))
    {
        CriticalError("Could not read DVD code reference file, \'%s\'", pszFilename);
    }
    
    if(dwBogus != g_dwReferenceImageLength)
    {
        CriticalError("Could not read entire DVD code reference file, \'%s\'", pszFilename);
    }

    //
    // Close the file
    //

    CloseHandle(hFile);

    return;
}

DWORD WaitForDvdReceiverInsertion()
/*++
  Routine Description:
    Waits for a DVD dongle.  Notice that if multiple devices are inserted between calls
    to XGetDeviceChanges we only test one of them.  This spins tight, but since we
    don't have other threads, we have nothing else to do.  There is no incentive sleep.
--*/
{
  static DWORD dwCurrentDongle = 0;
  DWORD dwInsertions, dwRemovals;
  DWORD dwRetVal;
    
  while(TRUE)
  {
    if(XGetDeviceChanges(XDEVICE_TYPE_DVD_CODE_SERVER, &dwInsertions, &dwRemovals))
    {
      //
      //  Handle Removals First
      //
      if(dwCurrentDongle&dwRemovals)
      {
          //DisplayMessage(COLOR_CYAN, WAIT_FOR_DEVICE_INSERT);
          dwCurrentDongle = 0;
      }
    
      //
      //  Look for newly inserted device.
      //
      if(dwInsertions)
      {
        for(dwRetVal = 0, dwCurrentDongle = 1; dwRetVal < 4; dwRetVal++, dwCurrentDongle <<= 1)
        {
           if(dwInsertions&dwCurrentDongle)
           {
             return dwRetVal;
           }
        }
      }
    }
  }            
}

BOOL DownLoadAndVerifyCode(DWORD dwPort)
/*++
  Routine Description:
    Reads the code from the DVD IR receiver
    and checks it against the reference image.
  Return Value:
    TRUE  - On Success
    FALSE - On Failure
--*/
{
    DWORD dwError;
    DWORD dwDeviceInstance;
    XDCS_DVD_CODE_INFORMATION xdcsCodeInformation;
    DWORD dwBytesRead;
    
    //
    //  Get the image size and version
    //
    dwError = XDCSGetInformation(dwPort, &dwDeviceInstance, &xdcsCodeInformation);
    
    //
    //  If error, then display and return FALSE
    //

    if(ERROR_SUCCESS != dwError)
    {
        DisplayFailure("Getting Device Information");
        return FALSE;
    }

    //
    //  Check image size against our buffer
    //
    
    if(xdcsCodeInformation.dwCodeLength > MAX_IMAGE_SIZE)
    {
        DisplayFailure("ROM Image Too Large (%d bytes)", xdcsCodeInformation.dwCodeLength);
        return FALSE;
    }

    //
    //  Download code,
    //

    dwError = XDCSDownloadCode(dwDeviceInstance, g_rgbDownloadImageBuffer, 0, xdcsCodeInformation.dwCodeLength, &dwBytesRead);

    //
    //  Check for errors
    //

    if(ERROR_SUCCESS != dwError)
    {
        DisplayFailure("Downloading ROM");
        return FALSE;
    }

    //
    //  Were all the bytes read?
    //

    if(dwBytesRead != xdcsCodeInformation.dwCodeLength)
    {
        DisplayFailure("Couldn't Download all bytes");
        return FALSE;
    }

    //
    //  Write out the image to file (before comparing it to the
    //  reference image.)
    //
    WriteImageToFile(DVD_DOWNLOAD_CODE_FILENAME, g_rgbDownloadImageBuffer, dwBytesRead);

    //
    //  Now compare with reference image.
    //
    
    if(g_dwReferenceImageLength != dwBytesRead)
    {
        DisplayFailure("ROM Length (%d bytes) incorrect", dwBytesRead);
        return FALSE;
    }

    //
    //  Do memory comparison
    //
    if(memcmp(g_rgbDownloadImageBuffer, g_rgbReferenceImageBuffer, dwBytesRead))
    {
        DisplayFailure("ROM not identical to reference code.");
        return FALSE;
    }

    return TRUE;
}

void  WriteImageToFile(LPCSTR pszFilename, PVOID pvBuffer, DWORD dwBytes)
/*++
  Routine Description:
    Writes pvBuffer out to pszFilename, blasting over an existing file.
--*/
{
    DWORD dwBytesWritten;
    HANDLE hFile = CreateFile(
                        pszFilename,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
    if(INVALID_HANDLE_VALUE == hFile)
    {
        DebugPrint("WARN: Could not create file \'%s\' to dump image to.\n", pszFilename);
        return;
    }

    if(!WriteFile(hFile, pvBuffer, dwBytes, &dwBytesWritten, NULL))
    {
        DebugPrint("WARN: Write dumping image failed.\n");
    }

    if(dwBytesWritten != dwBytes)
    {
        DebugPrint("WARN: Write only wrote some of the bytes.\n");
    }

    CloseHandle(hFile);
}



BOOL RunButtonTest(DWORD dwPort)
/*++
  Routine Description:
    1) Open IR Remote Device
    
    2) Goes through buttons in the INI file and
       a) Turns on motor(s) to activate.
       b) Display message to press button
       c) Waits for button press
       d) Fails if timeout on button press.
       e) Turn off motor(s).

    3) Close IR Remote Device
--*/
{
    int                   iButtonIndex = 0;
    XINPUT_STATE_INTERNAL InputState;
    DWORD                 dwError;
    HANDLE                hRemote;
    int                   iEndTick;
    BOOL                  fTimeout;
    

    //
    //  Give it a second the input portion, it should not
    //  take longer than that.
    //
    //  This is not really a hack.  It is perfectly legitimate
    //  to give it 200 ms and no more to find the input portion
    //  after finding the code server.  I would NEVER suggest
    //  this for a game.  However, we are testing that the device
    //  behaves reasonably.
    //

    Sleep(200);

    //
    //  Open the remote device
    //
    hRemote = XInputOpen(XDEVICE_TYPE_IR_REMOTE, dwPort, XDEVICE_NO_SLOT, NULL);
    if(!hRemote)
    {
        DisplayFailure("Opening IR Remote Input.");
        return FALSE;
    }
    
    //
    //  Loop over all button tests
    //

    while(g_ButtonTestTable[iButtonIndex].Name)
    {
        //
        //  Turn on the motors
        //

        OperateMotors(g_ButtonTestTable[iButtonIndex].MotorCode, TRUE);

        //
        //  Tell operator to press button.
        //

        DisplayMessage(COLOR_GREEN, "Press \'%s\' Button", g_ButtonTestTable[iButtonIndex].Name);

        //
        //  Wait for button press or timeout
        //  (use signed compare for timeout to handle wrap)
        //
        iEndTick = ((int)GetTickCount()) + BUTTON_PRESS_TIMEOUT;
        fTimeout = TRUE; //assume timeout
        while( (iEndTick - ((int)GetTickCount())) > 0)
        {
            dwError = XInputGetState(hRemote, (PXINPUT_STATE)&InputState);
            if(ERROR_SUCCESS != dwError)
            {
                DisplayFailure("\'%s\' Button", g_ButtonTestTable[iButtonIndex].Name);
                XInputClose(hRemote);
				OperateMotors(g_ButtonTestTable[iButtonIndex].MotorCode, FALSE);
                return FALSE;
            }
            
            if(InputState.IrRemote.wKeyCode == g_ButtonTestTable[iButtonIndex].ButtonCode)
            {
                // Not a timeout
                fTimeout = FALSE;
                break;
            }
        }

        //
        //  Turn off the motors
        //
        
        OperateMotors(g_ButtonTestTable[iButtonIndex].MotorCode, FALSE);

        //
        //  If we timed out, then display error, return FALSE.
        //

        if(fTimeout)
        {
            XInputClose(hRemote);
            DisplayFailure("Timeout Waiting for \'%s\' button", g_ButtonTestTable[iButtonIndex].Name);
            return FALSE;
        }

        //
        //  Increment iButtonIndex for next loop
        //

        iButtonIndex++;
    }

    //
    //  Close the handle
    //

    XInputClose(hRemote);
    
    //
    //  We finished the button test 
    //

    return TRUE;
}

void OperateMotors(WORD wMotorCode, BOOL fOn)
/*++
  Routine Description:
    Turns on the motors specified in the wMotorCode.
    
    Only the lower byte of wMotorCode is used.
    Here is the interpretation:

        Bit Position:        76543210  
        =============================
        Left(L) or Right(R): LRLRLRLR  
        Controller Number:   33221100

    Any number of bits may be set.

--*/
{
    XINPUT_FEEDBACK feedback;
    DWORD           dwPort;
    DWORD           dwError;
    HANDLE          hGamepad;
    BOOL            fSuccess;

    //
    //  Fill out the feedback header
    //
    memset(&feedback,0, sizeof(feedback));
    feedback.Header.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(!feedback.Header.hEvent)
    {
        DebugPrint("WARN: Could not create feedback wait event.");
        return;
    }
    
    //
    //  Loop over ports
    //
    for(dwPort = 0; dwPort < 4; dwPort++)
    {
        if(wMotorCode&3)
        {
            DebugPrint(
                "Turning on gamepad %d motors(%s%s%s)\n",
                dwPort,
                (wMotorCode&2) ? "LEFT" : "",
                (3 == (wMotorCode&3)) ? " and " : "",
                (wMotorCode&1) ? "RIGHT" : ""
                );
            fSuccess = FALSE;
            hGamepad = XInputOpen(XDEVICE_TYPE_GAMEPAD, dwPort, XDEVICE_NO_SLOT, NULL);
            if(hGamepad)
            {
                if(fOn)
                {
                    feedback.Rumble.wLeftMotorSpeed = (wMotorCode&2) ? 0xFFF0 : 0;
                    feedback.Rumble.wRightMotorSpeed = (wMotorCode&1) ? 0xFFF0 : 0;
                } else
                {
                    feedback.Rumble.wLeftMotorSpeed = 0;
                    feedback.Rumble.wRightMotorSpeed = 0;
                }

                ResetEvent(feedback.Header.hEvent);
                dwError = XInputSetState(hGamepad, &feedback);
                if(ERROR_IO_PENDING == dwError)
                {
                    // Wait for 1 second max
                    WaitForSingleObject(feedback.Header.hEvent, 1000);
                }
                XInputClose(hGamepad);
                if(ERROR_SUCCESS == feedback.Header.dwStatus)
                {
                    fSuccess = TRUE;
                }
            }
            if(!fSuccess)
            {
                DebugPrint("WARN: Command to motors failed.");
            }
        }
        //
        //  Get ready for next iteration.
        //
        wMotorCode >>= 2;
    }
}

void  DisplayMessage(DWORD dwColor, LPCSTR pszMessage,...)
/*++
  Routine Description:
    Displays a message while tests are running to indicate testing
    progress, and whether user action is required.
  Arguments:
   pszMessage - format string for message to display.
  
   See printf - for use of variable arguments.
--*/
{
    char    szBuffer[512];
    WCHAR   wszBuffer[512];
    
    //Format string
    va_list args;
    va_start(args, pszMessage);
    vsprintf(szBuffer, pszMessage, args);
    va_end(args);

    //Convert to WCHAR
    wsprintfW(wszBuffer, L"%hs", szBuffer);

    //Set Font
    drSetSize(40.0, 42.0, dwColor, COLOR_BLACK);

    //Clear Screen
    drCls();

    //Print Header
    drPrintf(40,50,L"Xbox DVD Dongle Test Version 1.00");

    //Print Message
    drPrintf(40,150,wszBuffer);
    
    // Show the display
    drShowScreen();

    //Send to Debug Monitor
    DebugPrint("%s\n", szBuffer);
}   

void  DisplayFailure(LPCSTR pszMessage,...)
/*++
  Routine Description:
    Similar to DisplayMessage, but is accompanied by a BIG RED X.
    This indicates that some test failed.
  Arguments:
   pszMessage - format string for message to display.
  
   See printf - for use of variable arguments.
--*/
{
    char    szBuffer[512];
    WCHAR   wszBuffer[512];
    
    //Format string
    va_list args;
    va_start(args, pszMessage);
    vsprintf(szBuffer, pszMessage, args);
    va_end(args);

    //Convert to WCHAR
    wsprintfW(wszBuffer, L"FAILED: %hs", szBuffer);
    
    //Set Font
    drSetSize(40.0, 42.0, COLOR_RED, COLOR_BLACK);

    //Clear Screen
    drCls();

    //Print Message
    drPrintf(40,50, wszBuffer);

    //Draw RED X
    drQuad(200, 425, COLOR_RED, 550,  75, COLOR_RED, 600, 125, COLOR_RED, 250, 475, COLOR_RED);
	drQuad(600, 425, COLOR_RED, 250,  75, COLOR_RED, 200, 125, COLOR_RED, 550, 475, COLOR_RED);

    // Show the display
    drShowScreen();

    //Send to Debug Monitor
    DebugPrint("FAILED: %s\n", szBuffer);
}


void DisplaySuccess()
/*++
  Routine Description:
    Draws a big green check
--*/
{
    drSetSize(40.0, 42.0, COLOR_GREEN, COLOR_BLACK);

    //Clear Screen
    drCls();

    //Print Message
    drPrintf(40, 50,L"Test Passed");

    //Draw GREEN Check
    drQuad(250, 350, COLOR_GREEN, 550,  50, COLOR_GREEN, 600, 100, COLOR_GREEN, 300, 400, COLOR_GREEN);
	drQuad(250, 450, COLOR_GREEN, 300, 400, COLOR_GREEN, 150, 250, COLOR_GREEN, 100, 300, COLOR_GREEN);

    // Show the display
    drShowScreen();

    //Send to Debug Monitor
    DebugPrint("Test Passed\n");
}

void  CriticalError(LPSTR pszErrorString,...)
/*++
  Routine Description:
    Called when the test system hits an unexpected error that prevents testing.
--*/
{
    char    szBuffer[512];
    WCHAR   wszBuffer[512];
    
    //Format string
    va_list args;
    va_start(args, pszErrorString);
    vsprintf(szBuffer, pszErrorString, args);
    va_end(args);

    //Convert to WCHAR
    wsprintfW(wszBuffer, L"CRITICAL ERROR: %hs", szBuffer);

    //Set Font
    drSetSize(40.0, 42.0, COLOR_RED, COLOR_BLACK);

    //Clear Screen
    drCls();

    //Print Header
    drPrintf(40,50,L"Xbox DVD Dongle Test Version 1.00");

    //Print Message
    drPrintf(40,150,wszBuffer);
    drPrintf(40,200,L"Reboot System and Correct Problem");
    
    // Show the display
    drShowScreen();

    //Send to Debug Monitor
    DebugPrint("Critical Error: %s\n", szBuffer);
    DebugPrint("Reboot System and Correct Problem\n");

    //Spin forever
    while(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dvdtest\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dvdtest\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, 0) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dvdtest\irrem.h ===
#include <xtl.h>
#include <stdio.h>
//#include <dsound.h>
#include "draw.h"
#include "device.h"

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

/*
#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\devices.h ===
class CKeyboard
{
  public:
    CKeyboard(DWORD dwPortNumber, int iLeftEdge, int iTopEdge);
    ~CKeyboard();
    void    Open(XINPUT_POLLING_PARAMETERS *pPollingParameters);
    void    Close();
    void    PollDevice();
    void    UpdateState();
    void    Draw(CDraw& draw);
  private:
    DWORD           m_dwPortNumber;
    BOOL            m_fOpened;
    HANDLE          m_hDevice;
    XINPUT_STATE    m_kbdState;
    DWORD           m_dwPacketNumber;
    int             m_iLeftEdge;
    int             m_iTopEdge;
    int             m_iLabelColorOpened;
    int             m_iLabelColorClosed;
    int             m_iStateColor;
    //volatile XINPUT_KEYBOARD_LEDS m_LEDs;
    BOOL            m_fScrollLock;
    BOOL            m_fNumLock;
    BOOL            m_fCapsLock;
};

class CKeyboards
{
    public:
        CKeyboards(XINPUT_POLLING_PARAMETERS *pPollingParameters);
        ~CKeyboards();
        void CheckForHotplugs();
        //void UpdateState();
        //void PollDevices();
        void Draw(CDraw& draw);
    private:
        CKeyboard                  *m_pKeyboards[4];
        XINPUT_POLLING_PARAMETERS  *m_pPollingParameters;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\devices.cpp ===
#include <xtl.h>
#include "draw.h"
#include "devices.h"
#include <xkbd.h>


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

CKeyboard::CKeyboard(DWORD dwPortNumber, int iLeftEdge, int iTopEdge) : 
    m_dwPortNumber(dwPortNumber),
    m_fOpened(FALSE),
    m_dwPacketNumber(0),
    m_hDevice(0),
    m_iLabelColorOpened(LABEL_WHITE),
    m_iLabelColorClosed(DISCONNECTED_BLUE),
    m_iStateColor(CONNECTED_YELLOW),
    m_fScrollLock(FALSE),
    m_fNumLock(FALSE),
    m_fCapsLock(FALSE),
    m_iLeftEdge(iLeftEdge),
    m_iTopEdge(iTopEdge)
{

    /*
    m_Feedback.Header.dwStatus = ERROR_SUCCESS;
    m_Feedback.KeyboardLEDs.LedStates = 0;
    */
}

CKeyboard::~CKeyboard()
{
    Close();
}
void CKeyboard::Open(XINPUT_POLLING_PARAMETERS *pPollingParameters)
{
    DWORD dwError;
    if(!m_fOpened)
    {
        //m_Feedback.Header.dwStatus = ERROR_SUCCESS;
        m_hDevice =  XInputOpen(XDEVICE_TYPE_DEBUG_KEYBOARD, m_dwPortNumber, XDEVICE_NO_SLOT, pPollingParameters);
        if(m_hDevice)
        {
            m_fOpened = TRUE;
        } else
        {   
            DebugPrint("Opened port %d Failed: %d\n", m_dwPortNumber, GetLastError());
        }
    }
}
void CKeyboard::Close()
{
    DWORD dwError;
    if(m_fOpened)
    {
        //while(ERROR_IO_PENDING == m_Feedback.Header.dwStatus);
        XInputClose(m_hDevice);
        m_fOpened = FALSE;
        m_hDevice = NULL;
    }
}

#if 0
void CKeyboard::PollDevice()
{
    if(!m_fOpened) return;
    XInputPoll(m_hDevice);
}

void CKeyboard::UpdateState()
{
    if(!m_fOpened) return;
    DWORD dwError = XInputGetState(m_hDevice, &m_kbdState);
    /*
    if(ERROR_IO_PENDING != m_Feedback.Header.dwStatus)
    {
        if(
            ((m_kbdState.Modifiers.bAnalogButtons[6] << 8) != m_Feedback.Rumble.wLeftMotorSpeed) ||
            ((m_kbdState.Gamepad.bAnalogButtons[7] << 8) != m_Feedback.Rumble.wRightMotorSpeed)
        ){
            m_Feedback.Rumble.wLeftMotorSpeed = m_gpState.Gamepad.bAnalogButtons[6] << 8;
            m_Feedback.Rumble.wRightMotorSpeed = m_gpState.Gamepad.bAnalogButtons[7] << 8;
            XInputSetState(m_hDevice, (PXINPUT_FEEDBACK)&m_Feedback);
        }
    }
    */
    if(ERROR_SUCCESS != dwError)
    {
        if(dwError == ERROR_DEVICE_NOT_CONNECTED)
        {
            //
            //  Don't worry about closing the handle, since we
            //  poll for device removals and we will close
            //  the handle very soon anyway.
            //
            return;
        }
        DebugPrint("XInputGetDeviceState return error: %d\n", dwError);
        DebugPrint("This error is not expected in normal operation\n");
        DebugBreak();
    }
}
#endif

#define COLOR_LEFT_GREEN 0xff00ff00
#define COLOR_RIGHT_RED 0xffff0000
void CKeyboard::Draw(CDraw& draw)
{
    int iLabelColor = m_fOpened ? m_iLabelColorOpened : m_iLabelColorClosed;
    WCHAR FormatBuffer[80];
    draw.FillRect(m_iLeftEdge, m_iTopEdge, 600, 30, BACKDROP_BLUE); 
    wsprintf(FormatBuffer, L"P%d:", m_dwPortNumber);
    draw.DrawText(FormatBuffer, m_iLeftEdge, m_iTopEdge, iLabelColor);
/*    
    if(m_fOpened)
    {
        
        //
        //  Left and Right Control
        //
        iLabelColor = 0;
        if(HID_USAGE_MASK_KEYBOARD_LCTRL&m_kbdState.Keyboard.Modifiers)
        {
            iLabelColor |= COLOR_LEFT_GREEN;
        }
        if(HID_USAGE_MASK_KEYBOARD_RCTRL&m_kbdState.Keyboard.Modifiers)
        {
            iLabelColor |= COLOR_RIGHT_RED;
        }
        if(iLabelColor)
        {
            draw.DrawText(L"CTRL", m_iLeftEdge+50, m_iTopEdge, iLabelColor);
        }
        
        //
        //  Left and Right SHIFT
        //
        iLabelColor = 0;
        if(HID_USAGE_MASK_KEYBOARD_LSHFT&m_kbdState.Keyboard.Modifiers)
        {
            iLabelColor |= COLOR_LEFT_GREEN;
        }
        if(HID_USAGE_MASK_KEYBOARD_RSHFT&m_kbdState.Keyboard.Modifiers)
        {
            iLabelColor |= COLOR_RIGHT_RED;
        }
        if(iLabelColor)
        {
            draw.DrawText(L"SHIFT", m_iLeftEdge+100, m_iTopEdge, iLabelColor);
        }

        //
        //  Left and Right ALT
        //
        iLabelColor = 0;
        if(HID_USAGE_MASK_KEYBOARD_LALT&m_kbdState.Keyboard.Modifiers)
        {
            iLabelColor |= COLOR_LEFT_GREEN;
        }
        if(HID_USAGE_MASK_KEYBOARD_RALT&m_kbdState.Keyboard.Modifiers)
        {
            iLabelColor |= COLOR_RIGHT_RED;
        }
        if(iLabelColor)
        {
            draw.DrawText(L"ALT", m_iLeftEdge+150, m_iTopEdge, iLabelColor);
        }

        //
        //  Left and Right GUI
        //
        iLabelColor = 0;
        if(HID_USAGE_MASK_KEYBOARD_LGUI&m_kbdState.Keyboard.Modifiers)
        {
            iLabelColor |= COLOR_LEFT_GREEN;
        }
        if(HID_USAGE_MASK_KEYBOARD_RGUI&m_kbdState.Keyboard.Modifiers)
        {
            iLabelColor |= COLOR_RIGHT_RED;
        }
        if(iLabelColor)
        {
            draw.DrawText(L"GUI", m_iLeftEdge+200, m_iTopEdge, iLabelColor);
        }

        //
        //  Show other six keys
        //
        for(int i=0; i<6; i++)
        {
            wsprintf(FormatBuffer, L"0x%0.2x", (ULONG)m_kbdState.Keyboard.Keys[i]);
            draw.DrawText(
                FormatBuffer,
                m_iLeftEdge+250+i*35,
                m_iTopEdge,
                m_iStateColor
                );
        }
    }
*/
}

CKeyboards::CKeyboards(XINPUT_POLLING_PARAMETERS *pPollingParameters) :
    m_pPollingParameters(pPollingParameters)
{

     //
    //  Initialize High-Level Keyboard Function
    //
    XINPUT_DEBUG_KEYQUEUE_PARAMETERS QueueParameters;
    QueueParameters.dwFlags = XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN | XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT;
    QueueParameters.dwQueueSize = 40;
    QueueParameters.dwRepeatDelay = 350;
    QueueParameters.dwRepeatInterval = 70;
    XInputDebugInitKeyboardQueue(&QueueParameters);
    //
    //  Create and initialize the keyboard instance objects
    //
    int i;
    for(i=0; i < 4; i++)
    {
        m_pKeyboards[i] = new CKeyboard(i, 10, 40+(i*30));
        if(!m_pKeyboards[i]) DebugPrint("Failed to allocate a keyboard!");
    }
    //
    //  Find and open keyboard instances
    //
    DWORD dwDevices;
    dwDevices = XGetDevices(XDEVICE_TYPE_DEBUG_KEYBOARD);
    for(i=0; i < 4; i++)
    {
        if(dwDevices&(1 << i)) m_pKeyboards[i]->Open(m_pPollingParameters);
    }
}

CKeyboards::~CKeyboards()
{
    int i;
    for(i=0; i < 4; i++)
    {
        delete m_pKeyboards[i];
    }
}
void CKeyboards::CheckForHotplugs()
{
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges(XDEVICE_TYPE_DEBUG_KEYBOARD, &dwInsertions, &dwRemovals);
    int i;
    for(i=0; i < 4; i++)
    {
        if(dwRemovals&(1 << i)) m_pKeyboards[i]->Close();
        if(dwInsertions&(1 << i)) m_pKeyboards[i]->Open(m_pPollingParameters);
    }
}
/*
void CKeyboards::PollDevices()
{
    for(int i=0; i < 4; i++) m_pKeyboards[i]->PollDevice();
}
void CKeyboards::UpdateState()
{
   for(int i=0; i < 4; i++) m_pKeyboards[i]->UpdateState();
}
*/
void CKeyboards::Draw(CDraw& draw)
{
    for(int i=0; i < 4; i++) m_pKeyboards[i]->Draw(draw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\dvdtest\dvdtest.cpp ===
/* ++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dvdtest.cpp

Abstract:

    initializes all global variables, contains main loop, init. The module is to test DVD IR Receiver and Remote Contorler
	there is a file called button.ini to specify all codes. it can be changed to satisfy different requirement. This 
	application supports one Receiver and One controler right now, it can be modified to support more than two dukes easily.

Author:

     Bing Li (a-bingli) 2001 May

-- */


#include "irrem.h"
//#include <stdio.h>
#include <xboxp.h>
#include <time.h>
//#include <math.h>
//#include <string>



#define NO_XDCS_INSTANCE    ((DWORD)(-1))
#define IR_CODE_BUFFER_SIZE 2                  //used to store IR_CODE, it can be enlarged to store more 
#define MAXCOUNT 5                              //useless now


#define XDCS_STATUS_NO_DONGLE           0
#define XDCS_STATUS_DOWNLOADING         1
#define XDCS_STATUS_DOWNLOAD_SUCCEEDED  2
#define XDCS_STATUS_DOWNLOAD_FAILED     3
#define XDCS_STATUS_FILE_WRITE_FAILED   4


struct REMOTE_CODE_TABLE
{
    LPWSTR Name;   //name of the remote controler button
    WORD Code;     //IR code of the remote controler
};

//table size 28, 27 buttons in total, different remote controler may have different number. 
//This works for all less than 27 butttons, otherwise, this need to be enlarged.
#define RemoteCodeSize 28
DWORD  MAXTIME=120;
//2 minutes

//Global Variable
DWORD TestStatus;

HANDLE target;  //file handle to handle the target file which is downloaded from the ROM
HANDLE source;  //file handle to handle the source file which had been stored at "t:\\dvdsource.lib" already

int Dongle=0, Rom=0, File=1, screen=0, timer=0; // all these variable are used to control, these may not need to be bad gloable

//CDraw draw;
WCHAR FormatBuffer[256];
DWORD dwDownloadStatus = XDCS_STATUS_NO_DONGLE;

LPWSTR StatusText[] = 
    {
        L"No Dongle",
        L"Downloading",
        L"Success",
        L"Failure",
        L"Writing to File Failed",

    };


REMOTE_CODE_TABLE RemoteCodeTable[RemoteCodeSize];
/* = {
    {L"POWER",    0xAD5},
    {L"REVERSE",  0xAE2},
    {L"PLAY",     0xAEA},
    {L"FORWARD",  0xAE3},
    {L"SKIP -",   0xADD},
    {L"STOP",     0xAE0},
    {L"PAUSE",    0xAE6},
    {L"SKIP +",   0xADF},
    {L"GUIDE",    0xAE5},
    {L"INFO",     0xAC3},
    {L"MENU",     0xAF7},
    {L"REPLAY",   0xAD8},
    {L"UP",       0xAA6},
    {L"LEFT",     0xAA9},
    {L"OK",       0xA0B},
    {L"RIGHT",    0xAA8},
    {L"DOWN",     0xAA7},
    {L"DIGIT 0",  0xACF},
    {L"DIGIT 1",  0xACE},
    {L"DIGIT 2",  0xACD},
    {L"DIGIT 3",  0xACC},
    {L"DIGIT 4",  0xACB},
    {L"DIGIT 5",  0xACA},
    {L"DIGIT 6",  0xAC9},
    {L"DIGIT 7",  0xAC8},
    {L"DIGIT 8",  0xAC7},
    {L"DIGIT 9",  0xAC6},
    {NULL, 0}
};

  this has been replaced by the file "t:\\button.ini" 
  
*/

/************************************************************************
*Function: InitRemotCodeTable() is used to initilize the RemotCodeTable *
*Para: void                                                             *
*************************************************************************/
void InitRemotCodeTable()
{
   int i=0;

   for(i=0; i<RemoteCodeSize;i++) {

       //RemoteCodeTable[i]= new REMOTE_CODE_TABLE;
	   RemoteCodeTable[i].Name = new WCHAR;
	   RemoteCodeTable[i].Code = 0;
   }

}

/***************************************************************************
*Function: hextpde() is ued to transfer hex string to decimal integer      *
*Para: string of CHAR which is 0x format                                   *
*Return: decimal integer of the hex string or -1 if error happened         *
****************************************************************************/
int hextode(CHAR hex[])
{

  int retn=0,i=0, k=0;
  int len=strlen(hex), pw=(int)pow(16,len-3);

  //hex begin 0x, so we count from the 0,1,2, from the third one
  for(i=2;i<len; ++i) {
	  if((hex[i]>= '0') && (hex[i] <= '9'))   k=  hex[i] - '0';
      else {
		  
		  switch(hex[i]) {
		  case 'A' : k=10; break;
          case 'a' : k=10; break;
		  case 'B' : k=11; break;
		  case 'b' : k=11; break;
		  case 'C' : k=12; break;
          case 'c' : k=12; break;
		  case 'D' : k=13; break;
          case 'd' : k=13; break;
		  case 'E' : k=14; break;
		  case 'e' : k=14; break;
		  case 'F' : k=15; break;
          case 'f' : k=15; break;
		  default: DebugPrint("Button.ini has invalid hex charactor %c \n", hex[i]); return -1;
		  }

	  }

	  retn += k*pw;
	  pw /=16;
  }
  
  return retn;

}


/*********************************************************************
*Function: Readrct() is used to read file to RemotCodeTable          *
*Para:     the array of file, and the size of the array              *
*Return:   void                                                      *
**********************************************************************/
  
void Readrct(char file[], int fsize)
{

  int size=RemoteCodeSize,i=0;
  CHAR *tempf = new CHAR [fsize];
  CHAR  *temp;
  
  strcpy(tempf,file);

  //ignore the first line of the comments
  if((temp=strtok(tempf, "\r\n")) == NULL) {
		  
		  DebugPrint("Out of button.ini range, size is not correct \n");
		  return;
	  }
   

  //this is the second line, to read time limit as decimal in seconds unit
  temp=strtok(NULL, " \r\n");

  int t=atoi(temp);
  if(t!=0)  MAXTIME=t; //if there is no timer, the default value 120 will be used

  for(i=0; i<size; i++) {

	  if((temp=strtok(NULL, " \r\n")) == NULL) {
		  
		  DebugPrint("Out of button.ini range, size is not correct \n");
		  return;
	  }  

	  swprintf(RemoteCodeTable[i].Name,L"%S", temp);

	  DebugPrint("RemoteCodeTable[%d].Name=%s \n",i, temp);

	  if( (temp=strtok(NULL, " \r\n")) == NULL ) {
		  
		  DebugPrint("Out of button.ini range, size is not correct \n");
		  return;
	  }  

	  RemoteCodeTable[i].Code = (WORD)hextode(temp);
	  DebugPrint("RemoteCodeTable[%d].Code=%s\n",i, temp);
  }
}


    
/***********************************************************
*Function:ReadButton() is used to read the button.ini file *
*Para: the file name                                       *
*Return: void                                              *
************************************************************/

void ReadButton(char buttonfilename[])
{
  //char buttonfilename[]="C:\\public\button.ini";

  HANDLE buttonfile;

  buttonfile = CreateFile(buttonfilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); 
  if(buttonfile==INVALID_HANDLE_VALUE) {
	  DebugPrint("CreateFile failed, Error %d \n", GetLastError());
	  return;
  }

  DWORD fsize=0;
	
  CHAR *sm;
   
  DWORD temp;

	
	if(-1==(fsize=GetFileSize(buttonfile,NULL))) {
		 DebugPrint("GetFileSize(buttonfile,NULL) failed, Error: %d\n", GetLastError());
		return;
	}

	sm = new char[fsize];
	if(sm == NULL) {
		DebugPrint("new failed line %d FILE :%s!\n", __LINE__, __FILE__);
		delete[] sm;
		return;
	}
	
	if(FALSE == ReadFile(buttonfile, sm, fsize, &temp, 0)) {
		DebugPrint("ReadFile(buttonfile, .., %d, .., 0) failed! Error %d \n", fsize, GetLastError());
		delete[] sm;
		return;
	}

   Readrct(sm, fsize);


}








void WorkScreen(int button)
{
	float wX=40, wY=50;
	screen=1;
	drCls();
	
	drPrintf(wX,wY,L"Xbox Tongle Test Version 1.00        Runing ...");

	drPrintf(wX,70.0,L"Time Limit Is %d Seconds",MAXTIME);

    wY+=60; 
	if((button>=0)&&(button<28)) drPrintf(wX,wY,L"Press Button %s",RemoteCodeTable[button].Name);
	else drPrintf(wX, wY, L"Unknow Button");
    drShowScreen();
}




void ShowFinalResult()
{
    

    float x1=0,x2=0,x3=0,x4=0,y1=0,y2=0,y3=0,y4=0;
    float m1=0,m2=0,m3=0,m4=0,n1=0,n2=0,n3=0,n4=0;

    drCls();
 
    if((TestStatus==1)&&(File==1)) {
		DebugPrint("Test passed.\n");

        drPrintf(40, 40,L"Test Passed");

		drQuad(250, 350, 0xff00ff00, 550,  50, 0xff00ff00, 600, 100, 0xff00ff00, 300, 400, 0xff00ff00);
		drQuad(250, 450, 0xff00ff00, 300, 400, 0xff00ff00, 150, 250, 0xff00ff00, 100, 300, 0xff00ff00);
	/*
		x1=450; y1=400; x2=530; y2=320; x3=550; y3=340; x4=470; y4=420; 
        n1=430; m1=380; n2=470; m2=420; n3=450; m3=440; n4=410; m4=400;  
		
		drQuad(x1, y1, 0xff000000, x2,  y2, 0xff000000, x3, y3, 0xff000000, x4, y4, 0xff000000);
        drQuad(n1, m1, 0xff000000, n2,  m2, 0xff000000, n3, m3, 0xff000000, n4, m4, 0xff000000);
	*/

	} else {

		DebugPrint("Test failed.\n");
		if(1!=File) drPrintf(40.0, 40.0, L"File Compare Failed");
		else if(timer) drPrintf(40.0, 40.0, L"Time Off");
		else if(TestStatus == -1) drPrintf(40, 40, L"Download Failed");
		else drPrintf(40, 40, L"Button Test Failed");

		drQuad(200, 400, 0xffff0000, 550,  50, 0xffff0000, 600, 100, 0xffff0000, 250, 450, 0xffff0000);
		drQuad(600, 400, 0xffff0000, 250,  50, 0xffff0000, 200, 100, 0xffff0000, 550, 450, 0xffff0000);

    /*
		x1=450; y1=400; x2=530; y2=320; x3=550; y3=340; x4=470; y4=420; 
        n1=430; m1=380; n2=470; m2=420; n3=450; m3=440; n4=410; m4=400;  
                     
		drQuad(x1, y1, 0xff000000, x2,  y2, 0xff000000, x3, y3, 0xff000000, x4, y4, 0xff000000);
        drQuad(n1, m1, 0xff000000, n2,  m2, 0xff000000, n3, m3, 0xff000000, n4, m4, 0xff000000);

     */
	}
     
	drShowScreen();
	 

//       draw.DrawText(FormatBuffer, 50, 80, ProgressColor[dwDownloadStatus]);


}


/***********************************************************************************************
*Function: DiffFile() is used to compare two files: target file which is downloaded and the    *
*          source file which is stored at "t:\dvdsource.lib"                                   *
*Para: void                                                                                    *
*Return:1 different file, 0 same file                                                          *
************************************************************************************************/



int DiffFile(/*HANDLE &target, HANDLE &source*/)
{
	  
	
	int diff=0; //initiliaze as false, it will changed as true whenever bad thing happened
	
	DWORD tfsize=0, sfsize=0;
	
	char *tm, *sm;
	DWORD temp;


	
	if(-1==(sfsize=GetFileSize(source,NULL))) {
		 DebugPrint("GetFileSize(source,NULL) failed, Error: %d\n", GetLastError());
		return 1;
	}
	
	if(-1==(tfsize=GetFileSize(target,NULL))) {
		DebugPrint("GetFileSize(target,NULL) failed, Error: %d\n", GetLastError());
		return 1;
	}

    //if file size are different, the file is different
	if(tfsize!=sfsize) {
		DebugPrint("Size are different\nSource file size is %d but ", sfsize);
        DebugPrint("Target file size is %d\n", tfsize);
		return 1;
	}
	else DebugPrint("The same file, size is %d \n", sfsize);
	
	tm = new char[tfsize];
	if(tm == NULL) {
		DebugPrint("new failed line %d FILE :%s!\n", __LINE__, __FILE__);
		delete [] tm;
		return 1;
	}
	
	sm = new char[sfsize];
	if(sm == NULL) {
		DebugPrint("new failed line %d FILE :%s!\n", __LINE__, __FILE__);
		delete[] sm;
		return 1;
	}
	
	if(FALSE == ReadFile(target, tm, tfsize, &temp, 0)) {
		DebugPrint("ReadFile(h1, .., %d, .., 0) failed! Error %d \n", tfsize, GetLastError());
		 
		delete[] sm;
		delete[] tm;
		return 1;
	}
	
	if(FALSE == ReadFile(source, sm, sfsize, &temp, 0)) {
		DebugPrint("ReadFile(h2, .., %d, .., 0) failed! Error %d \n", sfsize, GetLastError());
		delete[] sm;
		delete[] tm;
		return 1;
	}
	
	//compare the two file byte by byte
	if(memcmp(tm, sm, sfsize)) {
		DebugPrint("NOT the same file\n");
		return 1;
	}
	
    DebugPrint("The same file, Success File Compare\n");
	return diff;

}


/*****************************************************************
*Function: ShowScreen() is used to show there is now IR Receiver *
******************************************************************/

void ShowScreen()
{

    drCls();
	 
	drPrintf(10,20,L"Xbox Tongle Test Version 1.00 ");

	drPrintf(10,50,L"No IR Remote Receiver");

	drShowScreen();


}

/************************************************************************
*Function:GetCodeName() is used to return the button's name             *
*************************************************************************/

LPCWSTR GetCodeName(WORD wCode)
{
    REMOTE_CODE_TABLE *pRemoteEntry = RemoteCodeTable;
    while(pRemoteEntry->Code)
    {
        if(pRemoteEntry->Code == wCode)
        {
            return pRemoteEntry->Name;
        }
        pRemoteEntry++;
    }
    if(wCode)
    {
        return L"UNKNOWN";
    } else
    {
        return NULL;
    }
}


//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------
void __cdecl main()
{
    XDCS_DVD_CODE_INFORMATION XdcsInfo;
    DWORD dwXdcsInstance=NO_XDCS_INSTANCE;
//    DWORD dwDownloadStatus = XDCS_STATUS_NO_DONGLE;
    DWORD dwConnectedDevices = 0;
    DWORD dwPortInUse = 0;
    XDCS_ASYNC_DOWNLOAD_REQUEST downloadRequest;
    DWORD dwPercentComplete = 0;
    DWORD dwDownloadStartTick, dwCurrentTick;
	DWORD mystarttime=0,mycurrenttime=0;

    double fDownloadTime = 0;
    PVOID pvBuffer;
    DWORD dwInserstions, dwRemovals;
    CHAR  szFileName[]="t:\\dvdcode.lib";
	CHAR sourceFileName[]="t:\\dvdsource.lib";
	CHAR button[]="t:\\button.ini";

	

	if((source = CreateFile(sourceFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))==INVALID_HANDLE_VALUE)
	{ DebugPrint("Can not Create Source File \n");
	  File =0;
	  goto Final;
	}
    
    //HANDLE hFile;
	LPCWSTR pwszCodeName=0, oldCodeName=0;
 

    HANDLE hRemote = NULL;
    DWORD  dwRemotePort=0;
    XINPUT_STATE_INTERNAL IrCodeBuffer[IR_CODE_BUFFER_SIZE] = {0};
    DWORD dwIrCodeBufferPos=0;
    DWORD dwPacketNumber=0;

	 
	DWORD dwDisplayYPos;

	float myX=10, myY=20,y=0;
	int remotecode=0, press =0, count=0,pressOk=0, dc=0;
    int xinput=0;
//    CDraw draw;
//    WCHAR FormatBuffer[256];

	TestStatus =1; //initiliaze as success, any bad thing happend, it will fail

     
    //Initialize core peripheral port support
    XInitDevices(0,NULL);
	
	drInit();

	InitRemotCodeTable();

	ReadButton(button);
	

//	drShowScreen();
//	myY+=20;
	//drShowScreen();


//    draw.FillRect(0,0,640,480,PITCH_BLACK);
        
    //Loop Forever Printing out the Library information
	Rom=0;
	Dongle=1;
	Rom=1; File=-1;

	struct tm *ptr;
	time_t lt;
 
	ShowScreen();

    while(1) {

		
		   
//		DebugPrint("version 1\n");

           if( (mycurrenttime - mystarttime) > MAXTIME) { 
			   DebugPrint("Time off \n");
			   timer=1;
			   TestStatus = 0;
			   goto Final;
		   }


		   if(remotecode==0) {
			   lt=time('\0');
			   ptr=localtime(&lt);
                
			   mystarttime = (ptr->tm_hour) * 360 + (ptr->tm_min)*60 + ptr->tm_sec;
			   mycurrenttime=mystarttime;

		//	   starttick=GetTickCount();
		   }

		   oldCodeName = RemoteCodeTable[remotecode].Name;

		   

        if(XDCS_STATUS_DOWNLOADING == dwDownloadStatus)
        {
            //Update download time
            dwCurrentTick = GetTickCount();
            fDownloadTime = ((LONG)dwCurrentTick - (LONG)dwDownloadStartTick)/1000.0;
            //Update percent complete
            dwPercentComplete = (downloadRequest.ulBytesRead * 100) / downloadRequest.ulLength; 
            // Check status
            if(ERROR_SUCCESS == downloadRequest.ulStatus)
            {
                target = CreateFile(szFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); 
                if(INVALID_HANDLE_VALUE != target)
                {
                    DWORD dwBytesWritten;
                    if(WriteFile(target, downloadRequest.pvBuffer, downloadRequest.ulBytesRead, &dwBytesWritten, NULL))
                    {
                        dwDownloadStatus = XDCS_STATUS_DOWNLOAD_SUCCEEDED;
				
                    } else
                    {
                        dwDownloadStatus = XDCS_STATUS_FILE_WRITE_FAILED;
						DebugPrint("WriteFile() failed %d", GetLastError());
                    }
 //                   CloseHandle(target);
                } else
                {
                    dwDownloadStatus = XDCS_STATUS_FILE_WRITE_FAILED;
					DebugPrint("CreateFile() failed %d\n", GetLastError());
                }
                free(downloadRequest.pvBuffer);
            } else if(ERROR_IO_PENDING != downloadRequest.ulStatus)
            {
                dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                free(downloadRequest.pvBuffer);
            }
        }

        //
        //  Look for the insertion or removal of devices
        //
        if(XGetDeviceChanges(XDEVICE_TYPE_DVD_CODE_SERVER, &dwInserstions, &dwRemovals))
        {

			if (((remotecode > 0)&& (remotecode < (RemoteCodeSize -1))) || (dwDownloadStatus == XDCS_STATUS_DOWNLOADING)
				||(dwDownloadStatus == XDCS_STATUS_DOWNLOAD_SUCCEEDED))
			{
			
				TestStatus =0;
				goto Final;
			}

			Rom = 0;
            if((1<<dwPortInUse)&dwRemovals)
            {   
                dwDownloadStatus = XDCS_STATUS_NO_DONGLE;
            }
            dwConnectedDevices &= dwRemovals;       //Handle removals
            dwConnectedDevices |= dwInserstions;    //Then additions

            //If there currently is no dongle, start using the first device.
            if(XDCS_STATUS_NO_DONGLE == dwDownloadStatus)
            {
                if(dwInserstions)
                {
                    DWORD dwError;
                    dwPortInUse = 0;
                    while(!(dwConnectedDevices&(1<<dwPortInUse))) dwPortInUse++;
                    dwError = XDCSGetInformation(dwPortInUse, &dwXdcsInstance, &XdcsInfo);
                    if(dwError)
                    {
                        dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                    } else
                    {
                        dwDownloadStatus = XDCS_STATUS_DOWNLOADING;
                        downloadRequest.dwDeviceInstance = dwXdcsInstance;
                        downloadRequest.pvBuffer = malloc(XdcsInfo.dwCodeLength);
                        downloadRequest.ulOffset = 0;
                        downloadRequest.ulLength = XdcsInfo.dwCodeLength;
                        downloadRequest.ulBytesRead = 0;
                        downloadRequest.hCompleteEvent = NULL;
                        dwDownloadStartTick = GetTickCount();
                        if(!downloadRequest.pvBuffer)
                        {
                            dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
							DebugPrint("Memory Allocation Failed \n");

                        } else if(ERROR_IO_PENDING!=XDCSDownloadCodeAsync(&downloadRequest))
                        {
                            dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                        }
                    }
                }
            }
        }    
		
	
        if(Rom==1) continue;
         


// Compare the downloaded file in t:\dvdcode.lib with t:\dvdsource.lib byte by byte using DiffFile(), 
// DiffFile return 1 if two files are different, 0 otherwise.

		if((dwDownloadStatus == XDCS_STATUS_DOWNLOAD_SUCCEEDED)&&(File==-1)) {
			

		 
//			target = CreateFile(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    		SetFilePointer(target,NULL,NULL,FILE_BEGIN);
            SetFilePointer(source,NULL,NULL,FILE_BEGIN);

	    	if(!DiffFile()) {
			//			drPrintf(10,myY,L"File Compare is SUCCESSFUL");
		    	DebugPrint("File Compare is Successful\n");
				File=1;
				TestStatus=1;
				if(!CloseHandle(target)) DebugPrint("CloseHandle(target) faile: %d\n", GetLastError());
 
			} else {
			    TestStatus =0; 
			    File=0;
			    DebugPrint("Compare File Failed\n");
                if(!CloseHandle(target)) DebugPrint("CloseHandle(target) faile: %d\n", GetLastError());
			    goto Final;

			}   

		} else if((dwDownloadStatus==XDCS_STATUS_DOWNLOAD_FAILED) ||(dwDownloadStatus==XDCS_STATUS_FILE_WRITE_FAILED)) {
			TestStatus=-1;
			DebugPrint("DownLoad Filed \n");
            if(!CloseHandle(target)) DebugPrint("CloseHandle(target) faile: %d\n", GetLastError());
			goto Final;
		}


        /**
        *** Poll the XID Remote part.
        *** Just because we don't have lot's of creative ways to
        *** abuse the XInput API, we will be clever here, and use the API in a valid,
        *** but less than optimal ways.  It had better work too!
        **/
        if(!hRemote) {
            DWORD dwDevices= (XGetDevices(XDEVICE_TYPE_IR_REMOTE)&0x0F); 
            if(dwDevices)
            {
                //Find the first bit set and open it.
                dwRemotePort = 0;
                while(!(dwDevices&(1<<dwRemotePort))) dwRemotePort++;
                hRemote = XInputOpen(XDEVICE_TYPE_IR_REMOTE, dwRemotePort, XDEVICE_NO_SLOT, NULL);
                dwPacketNumber = 0;
            }
        }

         //compare file first, otherwise do not need to test others
		if(File == -1) {
			
			drCls();
			drPrintf(10, 40, L" %s", StatusText[dwDownloadStatus]);
			drShowScreen();			
			continue;

		}

        if(hRemote)
        {
  
			WorkScreen(remotecode);


            if(ERROR_SUCCESS == XInputGetState(hRemote, (PXINPUT_STATE)(IrCodeBuffer+dwIrCodeBufferPos)))
            {
                //Don't move for duplicates
                if(dwPacketNumber != IrCodeBuffer[dwIrCodeBufferPos].dwPacketNumber)
                {
                    dwPacketNumber = IrCodeBuffer[dwIrCodeBufferPos].dwPacketNumber;
                    dwIrCodeBufferPos = (dwIrCodeBufferPos+1)%IR_CODE_BUFFER_SIZE;
                }
                
                
                if(dwPacketNumber)
                {
                    DWORD dwCodeBufferDisplayPos = (dwIrCodeBufferPos+1)%IR_CODE_BUFFER_SIZE;
                    DWORD dwDisplayYPos = 265 + (IR_CODE_BUFFER_SIZE*15);
                    LPCWSTR pwszCodeName;
                   for(int i=1; i < IR_CODE_BUFFER_SIZE; i++)
                   {
                        pwszCodeName = GetCodeName(IrCodeBuffer[dwCodeBufferDisplayPos].IrRemote.wKeyCode);
                        if(pwszCodeName)
                        {
                            

							if(oldCodeName==pwszCodeName) remotecode++;
                        }
                        dwDisplayYPos -= 15;
                        dwCodeBufferDisplayPos = (dwCodeBufferDisplayPos+1)%IR_CODE_BUFFER_SIZE;
				   }
                }
            } else
            {   
                XInputClose(hRemote);
                hRemote = NULL;
                memset(IrCodeBuffer, 0, sizeof(IrCodeBuffer));
				//screen=0;
                 
            }
        } else
        {
             
			screen=0;
        }

        //Preset
        if(screen==0) ShowScreen();


		lt=time('\0');
		ptr=localtime(&lt);

		mycurrenttime = (ptr->tm_hour) * 360 + (ptr->tm_min)*60 + ptr->tm_sec;         
	 

		if((mycurrenttime - mystarttime) > MAXTIME) {
			TestStatus = 0;
			timer=1;
		}

//		DebugPrint("currenttime=%d \n starttime=%d\n", mycurrenttime,mystarttime);
		
		if( (remotecode == RemoteCodeSize-1) || ( (mycurrenttime-mystarttime) > MAXTIME ) ) {
Final:	ShowFinalResult();
		//initiliaze all variable
		    dwDownloadStatus = XDCS_STATUS_NO_DONGLE;
			Rom =1;
			timer=0;
			remotecode =0;
			File=-1;
			mycurrenttime =0;
			mystarttime=0;
		}
    }
	

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

VOID CDraw::FillRectNow(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    FillRect(x,y,width,height,color);
    Present();
    FillRect(x,y,width,height,color);
}
//------------------------------------------------------------------------------
// CDraw::DrawText

VOID CDraw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

VOID CDraw::DrawTextNow(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
    Present();
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
}
//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\hawktest\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <xtl.h>

#include <stdio.h>
#include <assert.h>
#include <D3D8.h>
#include <D3DX8Math.h>
#include "bitfont.h"

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename,
		                      GENERIC_READ,
							  FILE_SHARE_READ,
							  NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_NORMAL,
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_NOSYSLOCK) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;

    (void)pSurface->GetDesc(&desc);

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 || desc.Format == D3DFMT_X8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8: case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;


    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\edit.h ===
class CEditBox
{
    public:
        CEditBox(int iLeft, int iTop, int iWidth, int iHeight, CDraw &Draw);
        void ProcessInput(CDraw &Draw);
        void Draw(CDraw &Draw);
    protected:
        void NextLine();
        void PreviousLine();
    private:
        int m_iLeft;
        int m_iTop;
        int m_iWidth;
        int m_iHeight;
        int m_iLines;
        int m_iColumns;
        int m_iLineSpacing;
        int m_iCurrentLine;
        int m_iCurrentPos;
        WCHAR **m_LineBuffer;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

#define BACKDROP_BLUE        0x000080
#define LABEL_WHITE          0xffffff
#define DISCONNECTED_BLUE    0x000020
#define CONNECTED_YELLOW     0xffff00


class CDraw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

     VOID FillRectNow(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);


    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);
    
    VOID DrawTextNow(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\edit.cpp ===
#include <xtl.h>
#include <xkbd.h>
#include "draw.h"
#include "edit.h"

#define FIXED_FONT_WIDTH  7
#define FIXED_FONT_HEIGHT 10

CEditBox::CEditBox(int iLeft, int iTop, int iWidth, int iHeight, CDraw &Draw) :
        m_iLeft(iLeft),
        m_iTop(iTop),
        m_iWidth(iWidth),
        m_iHeight(iHeight),
        m_iLines(0),
        m_iColumns(0),
        m_iLineSpacing(0),
        m_iCurrentLine(0),
        m_iCurrentPos(0),
        m_LineBuffer(0)
{
    int iCharWidth, iCharHeight;
    int i;
    //
    // Figure out Line Count and Spacing
    //
#ifdef propfont
    Draw.GetTextExtent((PDWORD)&iCharWidth, (PDWORD)&iCharHeight, L"A");
    iCharWidth += 2;  //Leave Space Between Lines
    if(0==iCharHeight) iCharHeight = FIXED_FONT_HEIGHT;
    if(0==iCharWidth) iCharWidth = FIXED_FONT_WIDTH;
#else
    iCharHeight = FIXED_FONT_HEIGHT;
    iCharWidth = FIXED_FONT_WIDTH;
#endif

    m_iLineSpacing = iCharHeight;
    m_iLines = (m_iHeight)/m_iLineSpacing;
    
    //
    //  Figure out maximum columns
    //
#ifdef propfont
    Draw.GetTextExtent((PDWORD)&iCharWidth, (PDWORD)&iCharHeight, L" ");
    if(0==iCharHeight) iCharHeight = FIXED_FONT_HEIGHT;
    if(0==iCharWidth) iCharWidth = FIXED_FONT_WIDTH;
#else
    iCharHeight = FIXED_FONT_HEIGHT;
    iCharWidth = FIXED_FONT_WIDTH;
#endif
    m_iColumns = (m_iWidth)/iCharWidth + 1;  //allocate an extra character on the end to terminate.
    
    //
    //  Allocate the line buffers
    //
    m_LineBuffer = new PWCHAR[m_iLines];
    for(i = 0; i < m_iLines; i++)
    {
        m_LineBuffer[i] = new WCHAR[m_iColumns];
        memset(m_LineBuffer[i],0, sizeof(WCHAR)*m_iColumns);
    }
}

void CEditBox::ProcessInput(CDraw &Draw)
{
    XINPUT_DEBUG_KEYSTROKE Keystroke;
    int iLineWidth, iBogus;
    int i;
    while(ERROR_SUCCESS==XInputDebugGetKeystroke(/*NULL,*/ &Keystroke))
    {
        //
        //  If the key has an ascii value place it in the buffer
        //
        if(Keystroke.Ascii)
        {
           switch(Keystroke.Ascii)
           {    
                case '\n':
                    NextLine();
                    break;
                case '\b':
                    if(0==m_iCurrentPos)
                    {
                        PreviousLine();
                    } else
                    {
                        m_LineBuffer[m_iCurrentLine][--m_iCurrentPos] = 0;
                    }
                    break;
                case '\t':
                    for(i=0; i<4; i++)
                    {
                        m_LineBuffer[m_iCurrentLine][m_iCurrentPos++] = 32;
                    }
                    break;
                default:
                    if(Keystroke.Ascii >= 32)
                    {
                        // Check for line buffer overrun
                        if(m_iCurrentPos == (m_iColumns+1))
                        {
                            NextLine();
                        }
                        // Add the character
                        m_LineBuffer[m_iCurrentLine][m_iCurrentPos++] = Keystroke.Ascii;
                        // Check for line render overrun
                        #ifdef propfont
                        Draw.GetTextExtent((PDWORD)&iLineWidth, (PDWORD)&iBogus, m_LineBuffer[m_iCurrentLine]);
                        if(iLineWidth >= m_iWidth)
                        {
                            // Move the character down to the next line
                            m_LineBuffer[m_iCurrentLine][--m_iCurrentPos] = 0;
                            NextLine();
                            m_LineBuffer[m_iCurrentLine][m_iCurrentPos++] = Keystroke.Ascii;
                        }
                        #endif
                    }
                    break;
           }
        }
    }
}

void CEditBox::Draw(CDraw &Draw)
{
    int i;
    // Clear the box out to total blackness
    Draw.FillRect(m_iLeft, m_iTop, m_iWidth, m_iHeight, 0);
    // Draw Each Line.
    for(i=0;i<m_iLines;i++)
    {
        Draw.DrawText(m_LineBuffer[i], m_iLeft, (m_iTop+m_iLineSpacing*i), 0xff7f7f7f);
    }
    // Draw Cursor
    if(GetTickCount()%1024 < 512)
    {
        //
        //  Find the horizontal cursor position
        //
        int iHorizCursorPos, iBogus;
        #ifdef propfont
        WCHAR TempChar;
        TempChar = m_LineBuffer[m_iCurrentLine][m_iCurrentPos];
        m_LineBuffer[m_iCurrentLine][m_iCurrentPos] = 0;
        Draw.GetTextExtent((PDWORD)&iHorizCursorPos,(PDWORD)&iBogus, m_LineBuffer[m_iCurrentLine]);
        m_LineBuffer[m_iCurrentLine][m_iCurrentPos] = TempChar;
        //
        //  Draw the cursor
        //
        Draw.FillRect(m_iLeft+iHorizCursorPos, (m_iTop+m_iLineSpacing*m_iCurrentLine), 2, m_iLineSpacing, 0xffffffff);
        #endif
    }
}

void CEditBox::NextLine()
{
    int i;
    //
    //  If we are on the bottom line then we scroll up
    //
    WCHAR *pTempLine;
    int iNextLine = m_iCurrentLine+1;
    if(iNextLine == m_iLines)
    {
        pTempLine = m_LineBuffer[0];
        for(i = 0; i < m_iCurrentLine; i++)
        {
            m_LineBuffer[i] = m_LineBuffer[i+1];
        }
        memset(pTempLine, 0, sizeof(WCHAR)*m_iColumns); 
        m_LineBuffer[m_iCurrentLine] = pTempLine;
        m_iCurrentPos = 0;
    } else
    //
    //  Otherwise, just move the current position
    //
    {
        m_iCurrentLine = iNextLine;
        m_iCurrentPos = 0;
    }
}

void CEditBox::PreviousLine()
{
    //
    //  If we are on not on top line go up a line.
    //
    if(0!=m_iCurrentLine)
    {
        m_iCurrentLine--;
        // Find the end of the line
        m_iCurrentPos = 0;
        while(m_LineBuffer[m_iCurrentLine][m_iCurrentPos]) m_iCurrentPos++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\loopback\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\edttst\main.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    edttst.cpp	

Abstract:
    
    Test App to exercise high-level keyboard support.
    
    
Environment:

    Designed for XBOX.

Notes:

    
    
Revision History:

    12-26-00 created by Mitchell Dernis (mitchd)

--*/

#include <xtl.h>
#include "draw.h"
#include "edit.h"
#include "devices.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

//
//  Useful Macro
//

//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------

void __cdecl main()
{
    int iFrameCount=0;
    int iState = 0;
    HRESULT hr;
    DebugPrint("Edit Test.\nBuilt on %s at %s\n", __DATE__, __TIME__);
    
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    CDraw draw;
    /*
    hr = draw.CreateFont("Font16.xpr");
    if(FAILED(hr))
    {
        DebugPrint("Edit Test.\nCouldn't find font.\n", __DATE__, __TIME__);
    }*/

    CEditBox editBox(0,250,640,230, draw);
    draw.FillRect(0, 0, 640, 480, BACKDROP_BLUE); 
    draw.DrawText(L"Edit Test Application", 300,  1, LABEL_WHITE);
    draw.Present();
    draw.DrawText(L"Edit Test Application", 300,  1, LABEL_WHITE);
    
    CKeyboards *pKeyboards = NULL;
    pKeyboards = new CKeyboards(NULL);
    while(1)
    {
        pKeyboards->CheckForHotplugs();
        //pKeyboards->UpdateState();
        editBox.ProcessInput(draw);
        pKeyboards->Draw(draw);
        editBox.Draw(draw);
        draw.Present();
        Sleep(16);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\hawktest\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_

// pack the structure as we're reading it from the disk
#pragma pack(1)

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)


//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\hawktest\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    draw.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>

#include "d3d8.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.

        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;

        // Set the screen mode.

        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));

        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;

        // Create the device.

        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }

        // Now we no longer need the D3D interface so let's free it.

        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

extern "C" VOID DrawMessage(int x, int y, LPCWSTR pcszText, int iProgPercent, int xProg, int yProg)
{
    Draw draw;

    draw.FillRect(0, 0, 640, 480, 0x000080);            // Draw border in dark blue
    draw.FillRect(20, 20, 600, 440, 0);                 // Fill interior with black
    draw.DrawText(pcszText, x, y, 0xbbbbff);

    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        draw.FillRect(xProg, yProg, 210, 40, 0x000080);

        //
        // Draw progress bar
        //

        draw.FillRect(xProg + 5, yProg + 5, 2 * min(iProgPercent, 100), 30, 0xbbbbff);
    }
    draw.Present();                                     // Show the buffer
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\hawktest\hawkpch.h ===
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\hawktest\hawktest.c ===
#include "hawkpch.h"



VOID DrawMessage(int x, int y, LPCWSTR pcszText, int iProgPercent, int xProg, int yProg);
ULONG DebugPrint(PCHAR Format,...);



VOID
WaitForAnyButton()
{
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    int i;

    while (!fButtonPressed)
    {
        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
        {
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;
        }

        for (i = 0; i < XGetPortCount(); i++)
        {
            if ((1 << i) & dwPads)
            {
                HANDLE hPad = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);

                if (NULL != hPad)
                {
                    XINPUT_STATE State;

                    Sleep(10);

                    if (ERROR_SUCCESS == XInputGetState(hPad, &State))
                    {
                        if ((0 != State.Gamepad.wButtons) ||
                            (0 != State.Gamepad.bAnalogButtons[0]) ||
                            (0 != State.Gamepad.bAnalogButtons[1]) ||
                            (0 != State.Gamepad.bAnalogButtons[2]) ||
                            (0 != State.Gamepad.bAnalogButtons[3]) ||
                            (0 != State.Gamepad.bAnalogButtons[4]) ||
                            (0 != State.Gamepad.bAnalogButtons[5]) ||
                            (0 != State.Gamepad.bAnalogButtons[6]) ||
                            (0 != State.Gamepad.bAnalogButtons[7]))
                        {
                            fButtonPressed = TRUE;
                        }
                    }

                    XInputClose(hPad);
                }
            }

            if (fButtonPressed)
            {
                break;
            }
        }
    }
}

#define NOHAWK 0xFF

void
pHandleInitialHawks (
    IN OUT XMediaObject ** MicrophoneXmo,
    IN OUT XMediaObject ** SpeakerXmo,
    OUT int * MicrophonePort
    )
{

    DWORD dwConnectedMicrophones, dwConnectedHeadphones;
    int i;
    HRESULT result;

    //Sleep (3000);
    //
    //  Get the initial connected state of the devices
    //
    dwConnectedMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    dwConnectedHeadphones = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if( dwConnectedMicrophones != dwConnectedHeadphones)
    {
        DebugPrint("dwConnectedMicrophones != dwConnectedHeadphone\n");
        _asm int 3;
    }

    //
    // Create XMOs for any already connect units.
    //
    DebugPrint ("Mikes/Heads 0x%08x 0x%08x\n", dwConnectedMicrophones, dwConnectedHeadphones);
    for (i=0;i<4;i++) {

        if(dwConnectedMicrophones&(1<<i) && *MicrophonePort == NOHAWK) {

            DebugPrint ("Opening hawk in port %u.\n", i);
            result = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, i , 2, NULL, MicrophoneXmo);
            if (!SUCCEEDED(result)) {
                DebugPrint ("Failed to create Mike XMO. %s(%d): 0x%0.8x\n", __FILE__, __LINE__, result);
            }
            else {
                XDBGTRC ("HAWKTEST", "HawkTest: Created XMO for Microphone device in port %u", i);
                *MicrophonePort = i;
            }

            result = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, i , 2, NULL, SpeakerXmo);
            if (!SUCCEEDED(result)) {
                DebugPrint ("Failed to create Speakerx XMO. %s(%d): 0x%0.8x\n", __FILE__, __LINE__, result);
            }
            else {
                XDBGTRC ("HAWKTEST", "HawkTest: Created XMO for Speaker device in port %u", i);
            }

        }
    }
}

void
pHandleHotplugs (
    IN OUT XMediaObject ** MicrophoneXmo,
    IN OUT XMediaObject ** SpeakerXmo,
    OUT int * MicrophonePort
    )
{
    DWORD dwMicrophoneInsertions, dwHeadphoneInsertions, dwMicrophoneRemovals, dwHeadphoneRemovals;
    int i;
    HRESULT result;

    if(XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwMicrophoneInsertions, &dwMicrophoneRemovals))
    {
        if(!XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwHeadphoneInsertions, &dwHeadphoneRemovals))
        {
            DebugPrint("GetDeviceChanges does not match\n");
            _asm int 3;
        }
        if(
            (dwMicrophoneInsertions != dwHeadphoneInsertions) ||
            (dwMicrophoneRemovals != dwHeadphoneRemovals)
        ){
            DebugPrint("GetDeviceChanges does not match, different\n");
            _asm int 3;
        }

        //
        //  Loop over all the ports
        //

        DebugPrint ("Hotplug event occurred.\n");
        for(i=0; i<4; i++)
        {
            //
            //  Handle Removal, if there is one.
            //

            if(dwMicrophoneRemovals&(1<<i) && i == *MicrophonePort)
            {
                DebugPrint ("Closing hawk in port %u", *MicrophonePort);
                XMediaObject_Release ((*MicrophoneXmo));
                XMediaObject_Release ((*SpeakerXmo));
                *MicrophonePort = NOHAWK;

            }

            //
            //  Handle Insertion. Ignore if we already have an opened hawk
            //

            if(dwMicrophoneInsertions&(1<<i) && *MicrophonePort == NOHAWK)
            {
                DebugPrint ("Opening hawk in port %u.\n", i);
                result = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, i , 2, NULL, MicrophoneXmo);
                if (!SUCCEEDED(result)) {
                    DebugPrint ("Failed to create Mike XMO. %s(%d): 0x%0.8x\n", __FILE__, __LINE__, result);
                }
                else {
                    XDBGTRC ("HAWKTEST", "HawkTest: Created XMO for Microphone device in port %u", i);
                    *MicrophonePort = i;
                }

                result = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, i , 2, NULL, SpeakerXmo);
                if (!SUCCEEDED(result)) {
                    DebugPrint ("Failed to create Mike XMO. %s(%d): 0x%0.8x\n", __FILE__, __LINE__, result);
                }
                else {
                    XDBGTRC ("HAWKTEST", "HawkTest: Created XMO for Speaker device in port %u", i);
                }

            }
        }
    }
}

void
pRunTest (void) {

    XMediaObject * speakerXmo;
    XMediaObject * microphoneXmo;
    int microphonePort = NOHAWK;



    DrawMessage(100, 100, TEXT("Press any gamepad button"), -1, 0 , 0);
    WaitForAnyButton();


    //
    // Get initial hawk connectivity.
    //
    pHandleInitialHawks (&microphoneXmo, &speakerXmo, &microphonePort);



    //
    // Loop forever.
    //
    XDBGTRC ("HAWKTEST", "HawkTest: Entering Test Loop\n");
    while (1) {

        //
        // Check for hotplug events.
        //
        pHandleHotplugs (&microphoneXmo, &speakerXmo, &microphonePort);


        if (microphonePort != NOHAWK) {

            DrawMessage (150, 150, TEXT("We've got a hawk!"), -1, 0, 0);
        }
    }
}



int
WINAPI
wWinMain(
    HINSTANCE hInst,
    HINSTANCE hPrev,
    LPWSTR lpCmdLine,
    int nCmdShow)
{


    XDBGTRC("HAWKTEST", "HawkTest: Built on %s at %s", __DATE__,__TIME__);
    XDBGTRC("HAWKTEST", "HawkTest: Polling for device insertions/removals..");

    pRunTest ();


    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\loopback\devices.cpp ===
#define DSOUND_INCLUDE_XHAWK

#include "loopback.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

/*
**
**  Implementation of CHawkUnit that does loop back test
**  on a single unit.
**
*/

CHawkUnit::CHawkUnit():
        m_dwPortNumber(0),
        m_iPosX(0),
        m_iPosY(0),
        m_pHeadphone(NULL),
        m_pMicrophone(NULL),
        m_dwBuffersSent(0),
        m_dwBuffersReceived(0),
        m_dwLoopbackErrors(0),
        m_fConnected(FALSE),
        m_fStarted(FALSE),
        m_dwPatternPosition(0),
        m_NextMicrophoneBufferIndex(0),
        m_NextHeadphoneBufferIndex(0)
{
}

void CHawkUnit::Init(DWORD dwPortNumber, INT iPosX, INT iPosY, HANDLE hEvent)
{
    m_dwPortNumber = dwPortNumber;
    m_iPosX = iPosX;
    m_iPosY = iPosY;
    
    //
    // Initialize the media buffers
    //

    for(int i=0; i <3; i++)
    {
        
        HeadphoneBuffers[i].xMediaPacket.dwMaxSize  = XHAWK_TEST_BUFFER_SIZE;
        HeadphoneBuffers[i].xMediaPacket.pvBuffer = new BYTE[XHAWK_TEST_BUFFER_SIZE];
        HeadphoneBuffers[i].xMediaPacket.pdwCompletedSize = &HeadphoneBuffers[i].dwCompletedSize;
        HeadphoneBuffers[i].xMediaPacket.pdwStatus = &HeadphoneBuffers[i].dwStatus;
        HeadphoneBuffers[i].xMediaPacket.hCompletionEvent = hEvent;
        

        MicrophoneBuffers[i].xMediaPacket.dwMaxSize  = XHAWK_TEST_BUFFER_SIZE;
        MicrophoneBuffers[i].xMediaPacket.pvBuffer = new BYTE[XHAWK_TEST_BUFFER_SIZE];
        MicrophoneBuffers[i].xMediaPacket.pdwCompletedSize = &MicrophoneBuffers[i].dwCompletedSize;
        MicrophoneBuffers[i].xMediaPacket.pdwStatus = &MicrophoneBuffers[i].dwStatus;
        MicrophoneBuffers[i].xMediaPacket.hCompletionEvent = hEvent;

        if(NULL == HeadphoneBuffers[i].xMediaPacket.pvBuffer)
        {
            DebugPrint("Buffer allocation Failed (Headphone Buffer #%d)\n", i);
        }
        if(NULL == MicrophoneBuffers[i].xMediaPacket.pvBuffer)
        {
            DebugPrint("Buffer allocation Failed (Microphone Buffer #%d)\n", i);
        }
    }
}

CHawkUnit::~CHawkUnit()
{
    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
    }
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
    }
    
    for(int i=0; i <3; i++)
    {
        delete MicrophoneBuffers[i].xMediaPacket.pvBuffer;
        delete HeadphoneBuffers[i].xMediaPacket.pvBuffer;
    }
}

void CHawkUnit::Inserted()
{
    Log(L"Hawk Inserted");
    int i;
    //
    //  Create a microphone and a headphone.
    //
    VERIFY_SUCCESS(XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, m_dwPortNumber , XHAWK_TEST_BUFFER_COUNT, NULL, &m_pMicrophone));
    VERIFY_SUCCESS(XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, m_dwPortNumber , XHAWK_TEST_BUFFER_COUNT, NULL, &m_pHeadphone));
    m_fConnected = TRUE;

    m_NextMicrophoneBufferIndex = 0;
    m_NextHeadphoneBufferIndex = 0;
    m_dwBuffersSent = 0;
    m_dwBuffersReceived = 0;
    m_dwLoopbackErrors = 0;
    
    //
    //  Initialize the status of all the buffer
    //
    for(i=0; i < XHAWK_TEST_BUFFER_COUNT; i++)
    {
        HeadphoneBuffers[i].dwStatus = XMEDIAPACKET_STATUS_PENDING;
        MicrophoneBuffers[i].dwStatus = XMEDIAPACKET_STATUS_PENDING;
    }

    //
    //  Start up the streaming
    //
    for(i=0; i < XHAWK_TEST_BUFFER_COUNT; i++)
    {
        //
        //  Fill the headphone buffer with a test pattern
        //
        for(int bufferOffset=0 ; bufferOffset < XHAWK_TEST_BUFFER_SIZE/sizeof(DWORD); bufferOffset++)
        {
            ((PDWORD)HeadphoneBuffers[i].xMediaPacket.pvBuffer)[bufferOffset] = m_dwPatternPosition++;
        }
        
        //
        //  Wipe the microphone buffer clean
        //
        memset(MicrophoneBuffers[i].xMediaPacket.pvBuffer, 0, XHAWK_TEST_BUFFER_SIZE);
                
        //
        //  Attach media buffer for headphone XMO's
        //
        VERIFY_SUCCESS(m_pHeadphone->Process(&HeadphoneBuffers[i].xMediaPacket, NULL));
                
        //
        //  For the first buffer, introduce a 10 ms delay, to give the loop back device
        //  a few cycles to process the first data.
        //
        if(i==0) Sleep(25);

        //
        //  Attach media buffer for microphone
        //
        VERIFY_SUCCESS(m_pMicrophone->Process(NULL, &MicrophoneBuffers[i].xMediaPacket));
    }
}


void CHawkUnit::Removed()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
    }
    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
    }
    m_fConnected = FALSE;
}

void CHawkUnit::Process()
/*++
    
    This routine is called because this XMO's event
    was signaled.  Since we pass the same event with
    every buffer, we do not know whether th microphone or
    headphone completed.

--*/
{
    
    //
    //  Handle a headphone completions
    //
    while(XMEDIAPACKET_STATUS_PENDING != HeadphoneBuffers[m_NextHeadphoneBufferIndex].dwStatus)
    {
        if(XMEDIAPACKET_STATUS_SUCCESS == HeadphoneBuffers[m_NextHeadphoneBufferIndex].dwStatus)
        {
            m_dwBuffersSent++;
        }
        HeadphoneBuffers[m_NextHeadphoneBufferIndex].dwStatus = XMEDIAPACKET_STATUS_PENDING;
        m_NextHeadphoneBufferIndex = (m_NextHeadphoneBufferIndex+1)%XHAWK_TEST_BUFFER_COUNT;
    }

    //
    //  Handle a microphone completions
    //
    while(XMEDIAPACKET_STATUS_PENDING != MicrophoneBuffers[m_NextMicrophoneBufferIndex].dwStatus)
    {
        int i = m_NextMicrophoneBufferIndex; //save some typing

        //
        //  only do the rest on success
        //
        if(XMEDIAPACKET_STATUS_SUCCESS == MicrophoneBuffers[i].dwStatus)
        {
            //
            //  Record that the data was receieved
            //
            m_dwBuffersReceived++;
            if(m_dwBuffersReceived > m_dwBuffersSent)
            {
                DebugPrint("ERROR: m_dwBuffersReceived > m_dwBuffersSent\n");
                _asm int 3;
            }

            //
            //  Check for loopback errors
            //
            if(0!=memcmp(
                    MicrophoneBuffers[i].xMediaPacket.pvBuffer,
                    HeadphoneBuffers[i].xMediaPacket.pvBuffer,
                    XHAWK_TEST_BUFFER_SIZE)
            ) {
                m_dwLoopbackErrors++;
            }
        } else
        {
            DebugPrint("ERROR: Buffer transmission failure\n");
            m_dwLoopbackErrors++;
        }

        //
        //  Reset the status to pending so we don't accidentaly
        //  process twice.
        //

        MicrophoneBuffers[i].dwStatus = XMEDIAPACKET_STATUS_PENDING;

        //
        //  If the device is still connected, resubmit the buffers.
        //

        if(m_fConnected)
        {
            //
            //  Fill the headphone buffer with a test pattern
            //
            for(int bufferOffset=0 ; bufferOffset < XHAWK_TEST_BUFFER_SIZE/sizeof(DWORD); bufferOffset++)
            {
                ((PDWORD)HeadphoneBuffers[i].xMediaPacket.pvBuffer)[bufferOffset] = m_dwPatternPosition++;
            }
    
            //
            //  Wipe the microphone buffer clean
            //
            memset(MicrophoneBuffers[i].xMediaPacket.pvBuffer, 0, XHAWK_TEST_BUFFER_SIZE);
            
            //
            //  Attach media buffer for headphone XMO's
            //
            VERIFY_SUCCESS(m_pHeadphone->Process(&HeadphoneBuffers[i].xMediaPacket, NULL));
            
            //
            //  Attach media buffer for microphone
            //
            VERIFY_SUCCESS(m_pMicrophone->Process(NULL, &MicrophoneBuffers[i].xMediaPacket));
        }

        //
        //  Process the next microphone buffer, if it is ready.
        //

        m_NextMicrophoneBufferIndex = (m_NextMicrophoneBufferIndex+1)%XHAWK_TEST_BUFFER_COUNT;
    }
}    

void CHawkUnit::Draw(CDraw& draw)
{
    WCHAR wcBuffer[80];
    DWORD dwColor;
    
    if(m_fConnected)
    {
        //dwColor = CONNECTED_YELLOW;
        dwColor = 0xFFFFFF;
    }else
    {
        //dwColor = DISCONNECTED_BLUE;
        dwColor = 0xFFFFFF;
    }

    for(int i=0; i<2; i++)
    {
        draw.FillRect(m_iPosX, m_iPosY, 150, 150, BACKDROP_BLUE);
        wsprintf(wcBuffer, L"Port %d: %ws", m_dwPortNumber, (m_fConnected ? L"Connected" : L"Disconnected") );
        draw.DrawText(wcBuffer, m_iPosX, m_iPosY, dwColor);
        wsprintf(wcBuffer, L"Buffer Sent = %d", m_dwBuffersSent);
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+15, dwColor);
        wsprintf(wcBuffer, L"Buffer Received = %d", m_dwBuffersReceived);
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+30, dwColor);
        wsprintf(wcBuffer, L"Loopback Errors = %d", m_dwLoopbackErrors);
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+45, dwColor);
        draw.Present();
    } 
}

void CHawkUnit::Log(WCHAR *pwstrText)
{
    DebugPrint("%ws\n", pwstrText);
}

/*
**
**  Implementation of CHawkUnits that tracks multiple hawk units.
**
*/

CHawkUnits::CHawkUnits()
{   
    for(int i=0; i<4; i++)
    {
        m_pProcessEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_pHawkUnits[i].Init(
                          i,
                          (0==i%2) ? 5 : 325,
                          (i<2) ? 15 : 245,
                          m_pProcessEvents[i]
                          );
    }        
}
CHawkUnits::~CHawkUnits(){}

void CHawkUnits::Run(CDraw& draw)
{
    int i;
    draw.FillRectNow(0,0, 480,640, BACKDROP_BLUE);
    DebugPrint("XInput Test Application.\nBuilt on %s at %s\n", __DATE__, __TIME__);
    draw.FillRectNow(0, 0, 640, 480, BACKDROP_BLUE); 
    draw.DrawTextNow(L"xHawk Audio Loopback Test", 300,  0, LABEL_WHITE);
    draw.Present();
    
    DWORD dwConnectedMicrophones;
    DWORD dwConnectedHeadphones;
    

    //
    //  Get the initial connected state of the devices
    //

    dwConnectedMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    dwConnectedHeadphones = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if( dwConnectedMicrophones != dwConnectedHeadphones)
    {
        DebugPrint("dwConnectedMicrophones != dwConnectedHeadphone\n");
        _asm int 3;
    }
    for(i=0; i < 4; i++)
    {
        if(dwConnectedMicrophones&(1<<i))
        {
            m_pHawkUnits[i].Inserted();
        }
        m_pHawkUnits[i].Draw(draw);
    }

    //
    //  Now loop forever
    //
    while(1)
    {
        
        //
        //  Wait until something happens, or 16 ms, whichever is first
        //
        
        DWORD dwReason = WaitForMultipleObjects(4, this->m_pProcessEvents, FALSE, 16);

        //
        //  If the wait expired due to one of the events, then call
        //  the appropriate hawk unit.
        //

        if(
            (dwReason >= WAIT_OBJECT_0) &&
            (dwReason <= WAIT_OBJECT_0+3)
          )
        {
            int i = dwReason-WAIT_OBJECT_0;
            m_pHawkUnits[i].Process();
            m_pHawkUnits[i].Draw(draw);
        }

        //
        //  Always check for hot-plugs
        //
        DWORD dwMicrophoneInsertions, dwHeadphoneInsertions, dwMicrophoneRemovals, dwHeadphoneRemovals;
        if(XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwMicrophoneInsertions, &dwMicrophoneRemovals))
        {
            if(!XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwHeadphoneInsertions, &dwHeadphoneRemovals))
            {
                DebugPrint("GetDeviceChanges does not match\n");
                _asm int 3;
            }
            if(
                (dwMicrophoneInsertions != dwHeadphoneInsertions) ||
                (dwMicrophoneRemovals != dwHeadphoneRemovals)
            ){
                DebugPrint("GetDeviceChanges does not match, different\n");
                _asm int 3;
            }

            //
            //  Loop over all the ports
            //

            for(i=0; i<4; i++)
            {
                //
                //  Handle Removal, if there is one.
                //

                if(dwMicrophoneRemovals&(1<<i))
                {
                    m_pHawkUnits[i].Removed();
                    m_pHawkUnits[i].Draw(draw);
                }

                //
                //  Handle Insertion, if there is one.
                //

                if(dwMicrophoneInsertions&(1<<i))
                {
                    m_pHawkUnits[i].Inserted();
                    m_pHawkUnits[i].Draw(draw);
                }
            } //end of loop over ports
        }  //end of check for getting device changes
    } //end of infinite loop
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\loopback\devices.h ===
//
//  The buffer size should not be divisible by 8 USB frames.
//  Depending on the hardware, it is either 32 bytes or 48
//  bytes.  So it is either (29*3) ms or (29*2) ms of data.
//
#define XHAWK_TEST_BUFFER_SIZE (16*2*3*29)
#define XHAWK_TEST_BUFFER_COUNT 3

struct HAWKMEDIABUFFER
{
    XMEDIAPACKET xMediaPacket;
    DWORD        dwCompletedSize;
    DWORD        dwStatus;
};

class CHawkUnit
{
  public:

    CHawkUnit();
    ~CHawkUnit();
    void Init(DWORD dwPort, INT iPosX, INT iPosY, HANDLE hEvent);
    void Inserted();
    void Removed();
    void Process();
    void Draw(CDraw& draw);
    void Log(WCHAR *pwstrText);
  
  private:

    XMediaObject *m_pMicrophone;
    XMediaObject *m_pHeadphone;
    DWORD m_dwPortNumber;
    INT m_iPosX;
    INT m_iPosY;
    BOOL m_fConnected;
    BOOL m_fStarted;
    
    //
    //  Buffers for test.
    //

    HAWKMEDIABUFFER HeadphoneBuffers[XHAWK_TEST_BUFFER_COUNT];
    HAWKMEDIABUFFER MicrophoneBuffers[XHAWK_TEST_BUFFER_COUNT];

    //
    //  Progress Stats.
    //

    DWORD  m_dwPatternPosition;
    DWORD  m_dwBuffersSent;
    DWORD  m_dwBuffersReceived;
    DWORD  m_dwLoopbackErrors;

    //
    //  Keeps track of the next buffer that is 
    //  expected to complete.
    //

    ULONG m_NextMicrophoneBufferIndex;
    ULONG m_NextHeadphoneBufferIndex;

};

class CHawkUnits
{
    public:
        CHawkUnits();
        ~CHawkUnits();
        void Run(CDraw& draw);
    private:
        CHawkUnit m_pHawkUnits[4];
        HANDLE m_pProcessEvents[4];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\playback\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\loopback\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

#define BACKDROP_BLUE 0x000080
#define PITCH_BLACK 0x0
#define LABEL_WHITE 0xffffff
#define DISCONNECTED_BLUE 0x000040
#define CONNECTED_YELLOW 0xffff00

class CDraw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID FillRectNow(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID DrawTextNow(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\loopback\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, 0) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\loopback\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include <d3d8.h>
#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_R5G6B5;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

VOID CDraw::FillRectNow(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    FillRect(x,y,width,height,color);
    Present();
    FillRect(x,y,width,height,color);
}

//------------------------------------------------------------------------------
// CDraw::DrawText

VOID CDraw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

VOID CDraw::DrawTextNow(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    DrawText(string, x, y, foregroundColor, backgroundColor, flags);
    Present();
    DrawText(string, x, y, foregroundColor, backgroundColor, flags);
}

//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\playback\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

VOID CDraw::FillRectNow(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    FillRect(x,y,width,height,color);
    Present();
    FillRect(x,y,width,height,color);
}
//------------------------------------------------------------------------------
// CDraw::DrawText

VOID CDraw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

VOID CDraw::DrawTextNow(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
    Present();
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
}
//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\playback\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

#define BACKDROP_BLUE        0x000080
#define LABEL_WHITE          0xffffff
#define DISCONNECTED_BLUE    0x000020
#define CONNECTED_YELLOW     0xffff00


class CDraw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

     VOID FillRectNow(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);


    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);
    
    VOID DrawTextNow(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\loopback\loopback.h ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
}
#include <dsoundp.h>
#include "draw.h"
#include "devices.h"

#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\playback\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, 0) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\loopback\main.cpp ===
#include "loopback.h"

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

//------------------------------------------------------------------------------
//  Forward Declations
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------

void __cdecl main()
{
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    CHawkUnits hawkUnits;
    CDraw draw;
    hawkUnits.Run(draw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\inc\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\playback\devices.h ===
/*++
    The CHawkUnit class manages a single hawk unit.
    It records from the microphone, and then plays
    back the data with a 2 second delay through the headphone
    speaker.

    Both the headphone and microphone XMO's need to have
    a max attach buffer of at least two so that the always
    have an additional buffer queued.  The simplest scheme
    would have 4 XMEDIAPACKET contexts so that both the headphone
    and the microphone have two buffers queued at all times.
    This is a little wasteful.  Staggering can get away
    with only three buffers.

    So we could have three XMEDIAPACKET contexts to keep both XMO's
    from starving.  Say we have context permanently mapped to a
    fixed size buffer.  We would then attach the first buffer
    completed by the microphone to the headphone, 1 1/2
    buffer times after the microphone completes.  The playback
    latency would then be 1 1/2 buffer times.  So for a 2 
    second latency each buffer is 1 1/3 seconds for a total
    4 seconds of buffers.  This seems somewhat wasteful, the total
    buffer needed in theory should be very close to two seconds.

    A better way is to allocate a single large buffer, and have
    the XMEDIAPACKET contexts map a smaller region of it.  The stagger
    delay is then some multiple of the smaller region time.  If we
    want to use only three contexts, we need to delay an additional half
    of the small region time.  This is a pain to do cleanly assuming
    that your app is doing something besides streaming this one device
    (infact this app can play this trick with four hawks at a time.)
    However, since the context of a buffer (at least the part this
    class keeps track of) is only two DWORD, it makes very little sense
    to skimp, and we just go with four contexts.

    How big should the small region be?  The hawk XMO's run most
    efficiently if the small regions are a multiple of 8 USB frames
    (though this is not a requirement).  This will result in the fewest
    number of interrupts per bytes transferred.  Everytime one of these
    small buffers complete an event is signalled.  Presumably, we want
    to minimize this as well, so it is a good idea to make them as large
    as possible.  However, if the latency is N*the number of small regions,
    the full buffer must be (N+2)*smaller region.  So if you break the large
    region into 12 regions, you are using about 20% more buffer than the
    theoretical minimum.  22 regions wastes only 10%, etc.

    So our choice is to have 2080 ms of buffers, with each small region
    being only 40 ms, giving us a total of 52 regions.  The buffer is
    only 4% larger than it needs to be for a two second delay.

--*/

#define XHAWK_PLAYBACK_BYTES_PER_MS (((ULONG)(TEST_HAWK_SAMPLING_RATE/1000.0))*2)
#define XHAWK_PLAYBACK_BUFFER_REGION_TIME 80
#define XHAWK_PLAYBACK_BUFFER_REGION_SIZE (XHAWK_PLAYBACK_BYTES_PER_MS*XHAWK_PLAYBACK_BUFFER_REGION_TIME)
#define XHAWK_PLAYBACK_PREBUFFER_REGIONS 20
#define XHAWK_PLAYBACK_TOTAL_REGIONS (XHAWK_PLAYBACK_PREBUFFER_REGIONS+2)
#define XHAWK_PLAYBACK_BUFFER_SIZE (XHAWK_PLAYBACK_BUFFER_REGION_SIZE*XHAWK_PLAYBACK_TOTAL_REGIONS)

struct PLAYBACK_MEDIABUFFER_CONTEXT
{
    DWORD        dwCompletedSize;
    DWORD        dwStatus;
};

struct PLAYBACK_REGION
{
    BYTE Data[XHAWK_PLAYBACK_BUFFER_REGION_SIZE];
};

class CHawkUnit
{
  public:

      CHawkUnit() :
        m_pMicrophone(NULL),
        m_pHeadphone(NULL),
        m_dwPortNumber(0),
        m_iPosX(0),
        m_iPosY(0),
        m_hEvent(NULL),
        m_dwMicrophoneRegionIndex(0),
        m_dwHeadphoneRegionIndex(0),
        m_dwMicrophoneContextIndex(0),
        m_dwHeadphoneContextIndex(0),
        m_fConnected(FALSE),
        m_fPreBuffering(FALSE),
        m_dwPreBufferRegions(0),
        m_dwBuffersReceived(0),
        m_dwBytesReceived(0),
        m_dwBuffersSent(0),
        m_dwBytesSent(0),
        m_dwErrorCount(0)
        {}

    ~CHawkUnit();
    void Init(DWORD dwPort, INT iPosX, INT iPosY, HANDLE hEvent);
    void Inserted();
    void Removed();
    void Process();
    void AttachMicrophoneContext(DWORD dwIndex);
    void AttachHeadphoneContext(DWORD dwIndex);
    void Draw(CDraw& draw);
    void Log(WCHAR *pwstrText);
  
  private:

    //
    // XMO objects created on
    // call to Inserted.
    //
    
    XMediaObject *m_pMicrophone;
    XMediaObject *m_pHeadphone;

    //
    // Stuff given to us at init
    //
    DWORD m_dwPortNumber;
    INT m_iPosX;
    INT m_iPosY;
    HANDLE m_hEvent;
        
    //
    //  The buffer is just an array of regions,
    //  which are simply fixed sized arrays
    //  of bytes.
    //

    PLAYBACK_REGION m_Buffer[XHAWK_PLAYBACK_TOTAL_REGIONS];

    //
    //  m_dwMicrophoneRegionIndex (m_dwHeadphoneRegionIndex)
    //  is the next next region that needs to be attached to
    //  the microphone (headphone) XMO.
    //

    DWORD m_dwMicrophoneRegionIndex;
    DWORD m_dwHeadphoneRegionIndex;

    //
    //  These contexts are used to track the status
    //  of an attached media buffer.
    //
    PLAYBACK_MEDIABUFFER_CONTEXT m_MicrophoneContexts[2];
    PLAYBACK_MEDIABUFFER_CONTEXT m_HeadphoneContexts[2];
    
    //
    //  m_dwMicrophoneContextIndex (m_dwHeadphoneContexIndex)
    //  is the next next region that the microphone (headphone) XMO,
    //  is expected to complete.
    //
    DWORD m_dwMicrophoneContextIndex;
    DWORD m_dwHeadphoneContextIndex;

    //
    //  Status.
    //
    BOOL   m_fConnected;
    BOOL   m_fPreBuffering;
    DWORD  m_dwPreBufferRegions;
    DWORD  m_dwBuffersReceived;
    DWORD  m_dwBytesReceived;
    DWORD  m_dwBuffersSent;
    DWORD  m_dwBytesSent;
    DWORD  m_dwErrorCount;
    
};

class CHawkUnits
{
    public:
        CHawkUnits();
        ~CHawkUnits();
        void Run(CDraw& draw);
    private:
        CHawkUnit m_pHawkUnits[4];
        HANDLE m_pProcessEvents[4];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\inc\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include <xbfont.h>

#define PITCH_BLACK          0xff000000
#define INVALID_GRAY         0xff101010
#define LABEL_WHITE          0xffffffff
#define CONNECTED_YELLOW     0xffffff00
#define ACCEPTED_GREEN       0xff009f00
#define REJECTED_RED         0xff9f0000
#define BRIGHT_BLUE          0xff2020ff


class CDraw
{

private:

    static IDirect3DDevice8* m_pDevice;
    IDirect3DSurface8* m_pBackBuffer;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);
   
    CXBFont *CreateFont(const CHAR* strFontResourceFileName);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\inc\usbtst.h ===
#include <xtl.h>
#include <xboxp.h>
#include "draw.h"

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}


#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}

VOID test_MapEDrive();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\playback\playback.h ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
}
#include <dsoundp.h>
#include "draw.h"
#include "devices.h"

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}


#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\playback\devices.cpp ===
#define DSOUND_INCLUDE_XHAWK

#include "playback.h"

#if TEST_HAWK_SAMPLING_RATE == 8000
#pragma message ("Playback built for 8 ksamples/second")
#endif

#if TEST_HAWK_SAMPLING_RATE == 11025
#pragma message ("Playback built for 11.025 ksamples/second")
#endif

#if TEST_HAWK_SAMPLING_RATE == 16000
#pragma message ("Playback built for 16 ksamples/second")
#endif

#if TEST_HAWK_SAMPLING_RATE == 22050
#pragma message ("Playback built for 22.05 ksamples/second")
#endif

#if TEST_HAWK_SAMPLING_RATE == 24000
#pragma message ("Playback built for 24 ksamples/second")
#endif

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}


/*
**
**  Implementation of CHawkUnit that does play back test
**  on a single unit.
**
*/

void CHawkUnit::Init(DWORD dwPortNumber, INT iPosX, INT iPosY, HANDLE hEvent)
{
    m_dwPortNumber = dwPortNumber;
    m_iPosX = iPosX;
    m_iPosY = iPosY;
    m_hEvent = hEvent;
}

CHawkUnit::~CHawkUnit()
{
    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
    }
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
    }
}

void CHawkUnit::Inserted()
{
    Log(L"Hawk Inserted");
    DWORD i;
    HRESULT hr;

    WAVEFORMATEX wfxFormat;
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = TEST_HAWK_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2*TEST_HAWK_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    //
    //  Create a microphone and a headphone.
    //
    hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, m_dwPortNumber , 2, &wfxFormat, &m_pMicrophone);
    if(SUCCEEDED(hr))
    {
       hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, m_dwPortNumber , 2, &wfxFormat, &m_pHeadphone);
       if(SUCCEEDED(hr))
       {
            m_dwMicrophoneRegionIndex = 0;
            m_dwHeadphoneRegionIndex = 0;
            m_dwMicrophoneContextIndex = 0;
            m_dwHeadphoneContextIndex = 0;
            m_fConnected = TRUE;
            m_fPreBuffering = TRUE;
            m_dwPreBufferRegions = 0;
            m_dwBuffersReceived = 0;
            m_dwBytesReceived = 0;
            m_dwBytesSent = 0;
            m_dwErrorCount = 0;
    
            //
            //  Initialize the status of all the contexts
            //

            for(i=0; i < 2; i++)
            {
                m_MicrophoneContexts[i].dwStatus = XMEDIAPACKET_STATUS_PENDING;
                m_HeadphoneContexts[i].dwStatus = XMEDIAPACKET_STATUS_PENDING;
            }

            //
            //  Attach two microphone contexts off the bat.
            //

            for(i=0; i < 2; i++)
            {
                AttachMicrophoneContext(i);
            }
       } else
       {
            m_pMicrophone->Release();
            m_pMicrophone = NULL;
       }
    }
}


void CHawkUnit::Removed()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
    }
    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
    }
    m_fConnected = FALSE;
}

void CHawkUnit::Process()
/*++
    
    This routine is called because this XMO's event
    was signaled.  Since we pass the same event with
    every buffer, we do not know whether the microphone or
    headphone completed.

--*/
{
   
    //
    //  Check for a completed microphone context first
    //

    if(XMEDIAPACKET_STATUS_PENDING != m_MicrophoneContexts[m_dwMicrophoneContextIndex].dwStatus)
    {
        if(SUCCEEDED(m_MicrophoneContexts[m_dwMicrophoneContextIndex].dwStatus))
        {
            m_dwBuffersReceived++;
        } else
        {
            m_dwErrorCount++;
        }

        m_dwBytesReceived += m_MicrophoneContexts[m_dwMicrophoneContextIndex].dwCompletedSize;
        
        m_MicrophoneContexts[m_dwMicrophoneContextIndex].dwStatus = XMEDIAPACKET_STATUS_PENDING;

        //
        //  If we are still connected, reattach the context
        //

        if(m_fConnected)
        {
            //
            //  Increment m_dwMicrophoneContextIndex
            //

            DWORD index = m_dwMicrophoneContextIndex;
            m_dwMicrophoneContextIndex = (m_dwMicrophoneContextIndex+1)%2;
            
            //
            //  Reattach the microphone context that just completed.
            //

            AttachMicrophoneContext(index);
            
            //
            //  If we prebuffer is complete, switch off the prebuffer flag
            //  and attach two headphone contexts.
            //

            if(m_fPreBuffering)
            {
                if(XHAWK_PLAYBACK_PREBUFFER_REGIONS==++m_dwPreBufferRegions)
                {
                    m_fPreBuffering = FALSE;
                    for(DWORD i=0;i<2;i++)
                    {
                        AttachHeadphoneContext(i);
                    }
                }
            } //m_fPreBuffering
        } //m_fConnected
    }   //if microphone context no longer pending

    //
    //  Check for a completed headphone context first
    //

    if(XMEDIAPACKET_STATUS_PENDING != m_HeadphoneContexts[m_dwHeadphoneContextIndex].dwStatus)
    {
        if(SUCCEEDED(m_HeadphoneContexts[m_dwHeadphoneContextIndex].dwStatus))
        {
            m_dwBuffersSent++;
        } else
        {
            m_dwErrorCount++;
        }
        
        m_dwBytesSent += m_HeadphoneContexts[m_dwHeadphoneContextIndex].dwCompletedSize;

        m_HeadphoneContexts[m_dwHeadphoneContextIndex].dwStatus = XMEDIAPACKET_STATUS_PENDING;

        //
        //  If we are still connected, reattach the context
        //
        if(m_fConnected)
        {
            //
            //  Increment m_dwHeadphoneContextIndex
            //

            DWORD index = m_dwHeadphoneContextIndex;
            m_dwHeadphoneContextIndex = (m_dwHeadphoneContextIndex+1)%2;
            
            //
            //  Reattach the microphone context that just completed.
            //

            AttachHeadphoneContext(index);
        }
    }
}    


void CHawkUnit::AttachMicrophoneContext(DWORD dwIndex)
{
    XMEDIAPACKET MediaPacket;

     //
    //  Seup the size and pointer into our buffer
    //

    MediaPacket.dwMaxSize = XHAWK_PLAYBACK_BUFFER_REGION_SIZE;
    MediaPacket.pvBuffer = (PVOID)m_Buffer[m_dwMicrophoneRegionIndex].Data;

    //
    //  Adjust the region index for the next call
    //

    m_dwMicrophoneRegionIndex = (m_dwMicrophoneRegionIndex+1)%XHAWK_PLAYBACK_TOTAL_REGIONS;

    //
    //  Setup the pointers to our status and completed size pointers
    //

    MediaPacket.pdwCompletedSize = &m_MicrophoneContexts[dwIndex].dwCompletedSize;
    MediaPacket.pdwStatus = &m_MicrophoneContexts[dwIndex].dwStatus;

    //
    //  Initialize the event and timestamp
    //

    MediaPacket.hCompletionEvent = m_hEvent;

    //
    //  Submit the buffer
    //
    
    VERIFY_SUCCESS(m_pMicrophone->Process(NULL, &MediaPacket));
}

void CHawkUnit::AttachHeadphoneContext(DWORD dwIndex)
{
    XMEDIAPACKET MediaPacket;
    
    //
    //  Seup the size and pointer into our buffer
    //

    MediaPacket.dwMaxSize = XHAWK_PLAYBACK_BUFFER_REGION_SIZE;
    MediaPacket.pvBuffer = (PVOID)m_Buffer[m_dwHeadphoneRegionIndex].Data;

    //
    //  Adjust the region index for the next call
    //

    m_dwHeadphoneRegionIndex = (m_dwHeadphoneRegionIndex+1)%XHAWK_PLAYBACK_TOTAL_REGIONS;

    
    //
    //  Setup the pointers to our status and completed size pointers
    //

    MediaPacket.pdwCompletedSize = &m_HeadphoneContexts[dwIndex].dwCompletedSize;
    MediaPacket.pdwStatus = &m_HeadphoneContexts[dwIndex].dwStatus;

    //
    //  Initialize the event and timestamp
    //

    MediaPacket.hCompletionEvent = m_hEvent;

    //
    //  Submit the buffer
    //
    
    VERIFY_SUCCESS(m_pHeadphone->Process(&MediaPacket, NULL));
}
    
void CHawkUnit::Draw(CDraw& draw)
{
    WCHAR wcBuffer[80];
    DWORD dwColor;
    
    if(m_fConnected)
    {
        dwColor = CONNECTED_YELLOW;
    }else
    {
        dwColor = DISCONNECTED_BLUE;
    }

    for(int i=0; i<2; i++)
    {
        draw.FillRect(m_iPosX, m_iPosY, 250, 150, BACKDROP_BLUE);
        
        wsprintf(wcBuffer, L"Port %d: %ws", m_dwPortNumber, (m_fConnected ? L"Connected" : L"Disconnected") );
        draw.DrawText(wcBuffer, m_iPosX, m_iPosY, dwColor);
        
        if(m_fPreBuffering)
        {
            wsprintf(wcBuffer, L"pre-buffering data: %d ms remaining", (XHAWK_PLAYBACK_PREBUFFER_REGIONS - m_dwPreBufferRegions)*XHAWK_PLAYBACK_BUFFER_REGION_TIME);
        } else
        {
            wsprintf(wcBuffer, L"playing with %d ms delay", XHAWK_PLAYBACK_PREBUFFER_REGIONS*XHAWK_PLAYBACK_BUFFER_REGION_TIME);
        }
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+15, dwColor);

        wsprintf(wcBuffer, L"Buffers Received = %d", m_dwBuffersReceived);
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+30, dwColor);

        wsprintf(wcBuffer, L"Bytes Received = %d", m_dwBytesReceived);
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+45, dwColor);

        wsprintf(wcBuffer, L"Buffers Sent = %d", m_dwBuffersSent);
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+60, dwColor);

        wsprintf(wcBuffer, L"Bytes Sent = %d", m_dwBytesSent);
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+75, dwColor);

        wsprintf(wcBuffer, L"Errors = %d", m_dwErrorCount);
        draw.DrawText(wcBuffer, m_iPosX+10, m_iPosY+90, dwColor);
        
        draw.Present();
    } 
}

void CHawkUnit::Log(WCHAR *pwstrText)
{
    DebugPrint("%ws\n", pwstrText);
}

/*
**
**  Implementation of CHawkUnits that tracks multiple hawk units.
**
*/

CHawkUnits::CHawkUnits()
{   
    for(int i=0; i<4; i++)
    {
        m_pProcessEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_pHawkUnits[i].Init(
                          i,
                          (0==i%2) ? 5 : 325,
                          (i<2) ? 45 : 245,
                          m_pProcessEvents[i]
                          );
    }        
}
CHawkUnits::~CHawkUnits(){}

void CHawkUnits::Run(CDraw& draw)
{
    int i;
    WCHAR FormatBuffer[255];

    draw.FillRectNow(0,0,640,480, BACKDROP_BLUE);
    DebugPrint("XHawk Test Application.\nBuilt on %s at %s\n", __DATE__, __TIME__);
    wsprintf(FormatBuffer,L"Hawk Audio Play-back Test.");
    draw.DrawTextNow(FormatBuffer, 0,  0, LABEL_WHITE);
    wsprintf(FormatBuffer,L"Rate = %0.3f ksamples/second.", TEST_HAWK_SAMPLING_RATE/1000.0);
    draw.DrawTextNow(FormatBuffer, 2,  14, LABEL_WHITE);
    wsprintf(FormatBuffer,L"Built on %hs at %hs", __DATE__, __TIME__);
    draw.DrawTextNow(FormatBuffer, 2,  28, LABEL_WHITE);
    draw.Present();
    
    DWORD dwConnectedMicrophones;
    DWORD dwConnectedHeadphones;
    

    //
    //  Get the initial connected state of the devices
    //

    dwConnectedMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    dwConnectedHeadphones = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if( dwConnectedMicrophones != dwConnectedHeadphones)
    {
        DebugPrint("dwConnectedMicrophones != dwConnectedHeadphone\n");
        _asm int 3;
    }
    for(i=0; i < 4; i++)
    {
        if(dwConnectedMicrophones&(1<<i))
        {
            m_pHawkUnits[i].Inserted();
        }
        m_pHawkUnits[i].Draw(draw);
    }

    //
    //  Now loop forever
    //
    while(1)
    {
        
        //
        //  Wait until something happens, or 16 ms, whichever is first
        //
        
        DWORD dwReason = WaitForMultipleObjects(4, this->m_pProcessEvents, FALSE, 16);

        //
        //  If the wait expired due to one of the events, then call
        //  the appropriate hawk unit.
        //

        if(
            (dwReason >= WAIT_OBJECT_0) &&
            (dwReason <= WAIT_OBJECT_0+3)
          )
        {
            int i = dwReason-WAIT_OBJECT_0;
            m_pHawkUnits[i].Process();
            m_pHawkUnits[i].Draw(draw);
        }

        //
        //  Always check for hot-plugs
        //
        DWORD dwMicrophoneInsertions, dwHeadphoneInsertions, dwMicrophoneRemovals, dwHeadphoneRemovals;
        if(XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwMicrophoneInsertions, &dwMicrophoneRemovals))
        {
            if(!XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwHeadphoneInsertions, &dwHeadphoneRemovals))
            {
                DebugPrint("GetDeviceChanges does not match\n");
                _asm int 3;
            }
            if(
                (dwMicrophoneInsertions != dwHeadphoneInsertions) ||
                (dwMicrophoneRemovals != dwHeadphoneRemovals)
            ){
                DebugPrint("GetDeviceChanges does not match, different\n");
                _asm int 3;
            }

            //
            //  Loop over all the ports
            //

            for(i=0; i<4; i++)
            {
                //
                //  Handle Removal, if there is one.
                //

                if(dwMicrophoneRemovals&(1<<i))
                {
                    m_pHawkUnits[i].Removed();
                    m_pHawkUnits[i].Draw(draw);
                }

                //
                //  Handle Insertion, if there is one.
                //

                if(dwMicrophoneInsertions&(1<<i))
                {
                    m_pHawkUnits[i].Inserted();
                    m_pHawkUnits[i].Draw(draw);
                }
            } //end of loop over ports
        }  //end of check for getting device changes
    } //end of infinite loop
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\kbdtest\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\hawk\playback\main.cpp ===
#include "playback.h"

//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------

void __cdecl main()
{
    //Initialize core peripheral port support
    XDEVICE_PREALLOC_TYPE deviceTypes[] = 
    {
        {XDEVICE_TYPE_VOICE_MICROPHONE,4},
        {XDEVICE_TYPE_VOICE_HEADPHONE,4}
    };
    XInitDevices(sizeof(deviceTypes)/sizeof(XDEVICE_PREALLOC_TYPE),deviceTypes);

    CHawkUnits *pHawkUnits;
    CDraw draw;
    pHawkUnits = new CHawkUnits;
    pHawkUnits->Run(draw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\kbdtest\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

VOID CDraw::FillRectNow(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    FillRect(x,y,width,height,color);
    Present();
    FillRect(x,y,width,height,color);
}
//------------------------------------------------------------------------------
// CDraw::DrawText

VOID CDraw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

VOID CDraw::DrawTextNow(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
    Present();
    DrawText(string,x,y,foregroundColor,backgroundColor,flags);
}
//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\kbdtest\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

#define BACKDROP_BLUE        0x000080
#define LABEL_WHITE          0xffffff
#define DISCONNECTED_BLUE    0x000020
#define CONNECTED_YELLOW     0xffff00


class CDraw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

     VOID FillRectNow(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);


    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);
    
    VOID DrawTextNow(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\kbdtest\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_NOSYSLOCK) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\inc\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\kbdtest\devices.h ===
class CKeyboard
{
  public:
    CKeyboard(DWORD dwPortNumber);
    ~CKeyboard();
    void    Open(XINPUT_POLLING_PARAMETERS *pPollingParameters);
    void    Close();
    void    PollDevice();
    void    UpdateState();
    void    Draw(CDraw& draw);
  private:
    DWORD           m_dwPortNumber;
    BOOL            m_fOpened;
    HANDLE          m_hDevice;
    XINPUT_STATE    m_kbdState;
    DWORD           m_dwPacketNumber;
    int             m_iLeftEdge;
    int             m_iTopEdge;
    int             m_iLabelColorOpened;
    int             m_iLabelColorClosed;
    int             m_iStateColor;
    volatile XINPUT_KEYBOARD_LEDS m_LEDs;
    BOOL            m_fScrollLock;
    BOOL            m_fNumLock;
    BOOL            m_fCapsLock;
};

class CKeyboards
{
    public:
        CKeyboards(XINPUT_POLLING_PARAMETERS *pPollingParameters);
        ~CKeyboards();
        void CheckForHotplugs();
        void UpdateState();
        void Draw(CDraw& draw);
        void PollDevices();
    private:
        CKeyboard                  *m_pKeyboards[4];
        XINPUT_POLLING_PARAMETERS  *m_pPollingParameters;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\irrem\main.cpp ===
#include "usbtst.h"

#define NO_XDCS_INSTANCE    ((DWORD)(-1))
#define IR_CODE_BUFFER_SIZE 8


#define FAILURE_RED          0xff9f0000
#define PENDING_YELLOW       0xffffff00
#define UNKNOWN_ORANGE       0xffff7f00
#define SUCCESS_GREEN        0xff009f00
#define WAITING_WHITE        0xffffffff

struct REMOTE_CODE_TABLE
{
    LPCWSTR Name;
    WORD Code;
};

REMOTE_CODE_TABLE RemoteCodeTable[] = {
    {L"POWER",    0xAD5},
    {L"REVERSE",  0xAE2},
    {L"PLAY",     0xAEA},
    {L"FORWARD",  0xAE3},
    {L"SKIP -",   0xADD},
    {L"STOP",     0xAE0},
    {L"PAUSE",    0xAE6},
    {L"SKIP +",   0xADF},
    {L"GUIDE",    0xAE5},
    {L"INFO",     0xAC3},
    {L"MENU",     0xAF7},
    {L"REPLAY",   0xAD8},
    {L"UP",       0xAA6},
    {L"LEFT",     0xAA9},
    {L"OK",       0xA0B},
    {L"RIGHT",    0xAA8},
    {L"DOWN",     0xAA7},
    {L"DIGIT 0",  0xACF},
    {L"DIGIT 1",  0xACE},
    {L"DIGIT 2",  0xACD},
    {L"DIGIT 3",  0xACC},
    {L"DIGIT 4",  0xACB},
    {L"DIGIT 5",  0xACA},
    {L"DIGIT 6",  0xAC9},
    {L"DIGIT 7",  0xAC8},
    {L"DIGIT 8",  0xAC7},
    {L"DIGIT 9",  0xAC6},
    {NULL, 0}
};

LPCWSTR GetCodeName(WORD wCode)
{
    if(0xF000 == (0xF000&wCode))
    {
        return L"ERROR";
    }
    REMOTE_CODE_TABLE *pRemoteEntry = RemoteCodeTable;
    while(pRemoteEntry->Code)
    {
        if(pRemoteEntry->Code == wCode)
        {
            return pRemoteEntry->Name;
        }
        pRemoteEntry++;
    }
    if(wCode)
    {
        return L"UNKNOWN";
    } else
    {
        return NULL;
    }
}

#define XDCS_STATUS_NO_DONGLE                   0
#define XDCS_STATUS_DOWNLOADING                 1
#define XDCS_STATUS_DOWNLOAD_VERIFYING          2
#define XDCS_STATUS_DOWNLOAD_UNKNOWN_VERSION    3
#define XDCS_STATUS_DOWNLOAD_CODE_ERRORS        4
#define XDCS_STATUS_DOWNLOAD_SUCCEEDED          5
#define XDCS_STATUS_DOWNLOAD_FAILED             6
#define XDCS_STATUS_FILE_WRITE_FAILED           7

DWORD VerifyAndGetRegion(XDCS_DVD_CODE_INFORMATION *pXdcsInfo, PVOID pvBytes, DWORD dwSize, DWORD *pdwRegion, BOOL *pfDebug);

const CHAR  *szRomImageDirTemplate    = "e:\\tests\\DVDROMIMAGES\\%x.%0.2x";     //version directory
const CHAR  *szRomImageNameTemplate   = "%s\\dvdkey%d.bin";               //release images
const CHAR  *szRomImageNameTemplateD  = "%s\\dvdkey%dd.bin";              //debug images


//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------
void __cdecl main()
{
    XDCS_DVD_CODE_INFORMATION XdcsInfo;
    DWORD dwXdcsInstance=NO_XDCS_INSTANCE;
    DWORD dwDownloadStatus = XDCS_STATUS_NO_DONGLE;
    DWORD dwRegion = 0;
    BOOL  fDebugRom = FALSE;
    DWORD dwConnectedDevices = 0;
    DWORD dwPortInUse = 0;
    XDCS_ASYNC_DOWNLOAD_REQUEST downloadRequest;
    DWORD dwPercentComplete = 0;
    DWORD dwDownloadStartTick, dwCurrentTick;
    double fDownloadTime = 0;
    PVOID pvBuffer;
    DWORD dwInserstions, dwRemovals;
    CHAR  szFileName[]="t:\\dvdcode.lib";
    HANDLE hRemote = NULL;
    DWORD  dwRemotePort=0;
    XINPUT_STATE_INTERNAL IrCodeBuffer[IR_CODE_BUFFER_SIZE] = {0};
    DWORD dwIrCodeBufferPos=0;
    DWORD dwPacketNumber=0;

    test_MapEDrive();

    CDraw draw;
    CXBFont *pFont = draw.CreateFont("e:\\tests\\media\\font16.xpr");
   

    WCHAR FormatBuffer[256];

    LPWSTR StatusText[] = 
    {
        L"INSERT DONGLE",
        L"PLEASE WAIT: Downloading . . .",
        L"PLEASE WAIT: Verifying Code . . .",
        L"INCONCLUSIVE: Cannot verify this ROM Version.",
        L"FAILURE: Code Contains Errors",
        L"SUCCESS: Region %d%s",
        L"FAILURE: Could Not Download Code",
        L"INCONCLUSIVE: Internal test error, could not save image",

    };

    int StatusColor[] = 
    {
        WAITING_WHITE,
        PENDING_YELLOW,
        PENDING_YELLOW,
        UNKNOWN_ORANGE,
        FAILURE_RED,
        SUCCESS_GREEN,
        FAILURE_RED,
        UNKNOWN_ORANGE
    };

    int ProgressColor[] = 
    {
        INVALID_GRAY,
        PENDING_YELLOW,
        PENDING_YELLOW,
        UNKNOWN_ORANGE,
        FAILURE_RED,
        SUCCESS_GREEN,
        FAILURE_RED,
        UNKNOWN_ORANGE
    };
    
    int InfoColor[] = 
    {
        INVALID_GRAY,
        PENDING_YELLOW,
        PENDING_YELLOW,
        UNKNOWN_ORANGE,
        FAILURE_RED,
        SUCCESS_GREEN,
        FAILURE_RED,
        UNKNOWN_ORANGE
    };

    
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    //Loop Forever Printing out the Library information
    while(1)
    {
        /**
        *** Poll the XDCS Portion
        ***
        ***
        **/
        
        //
        //  Update download progress
        //
        if(XDCS_STATUS_DOWNLOADING == dwDownloadStatus)
        {
            //Update download time
            dwCurrentTick = GetTickCount();
            fDownloadTime = ((LONG)dwCurrentTick - (LONG)dwDownloadStartTick)/1000.0;
            //Update percent complete
            dwPercentComplete = (downloadRequest.ulBytesRead * 100) / downloadRequest.ulLength; 
            // Check status
            if(ERROR_SUCCESS == downloadRequest.ulStatus)
            {
                HANDLE hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); 
                if(INVALID_HANDLE_VALUE != hFile)
                {
                    DWORD dwBytesWritten;
                    if(WriteFile(hFile, downloadRequest.pvBuffer, downloadRequest.ulBytesRead, &dwBytesWritten, NULL))
                    {
                        dwDownloadStatus = VerifyAndGetRegion(
                                                &XdcsInfo,
                                                downloadRequest.pvBuffer,
                                                downloadRequest.ulBytesRead,
                                                &dwRegion,
                                                &fDebugRom
                                                );
                    } else
                    {
                        dwDownloadStatus = XDCS_STATUS_FILE_WRITE_FAILED;
                    }
                    CloseHandle(hFile);
                } else
                {
                    dwDownloadStatus = XDCS_STATUS_FILE_WRITE_FAILED;
                }
                free(downloadRequest.pvBuffer);
            } else if(ERROR_IO_PENDING != downloadRequest.ulStatus)
            {
                dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                free(downloadRequest.pvBuffer);
            }
        }

        //
        //  Look for the insertion or removal of devices
        //
        if(XGetDeviceChanges(XDEVICE_TYPE_DVD_CODE_SERVER, &dwInserstions, &dwRemovals))
        {
            if((1<<dwPortInUse)&dwRemovals)
            {   
                dwDownloadStatus = XDCS_STATUS_NO_DONGLE;
            }
            dwConnectedDevices &= dwRemovals;       //Handle removals
            dwConnectedDevices |= dwInserstions;    //Then additions

            //If there currently is no dongle, start using the first device.
            if(XDCS_STATUS_NO_DONGLE == dwDownloadStatus)
            {
                if(dwInserstions)
                {
                    DWORD dwError;
                    dwPortInUse = 0;
                    while(!(dwConnectedDevices&(1<<dwPortInUse))) dwPortInUse++;
                    dwError = XDCSGetInformation(dwPortInUse, &dwXdcsInstance, &XdcsInfo);
                    if(dwError)
                    {
                        dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                    } else
                    {
                        dwDownloadStatus = XDCS_STATUS_DOWNLOADING;
                        downloadRequest.dwDeviceInstance = dwXdcsInstance;
                        downloadRequest.pvBuffer = malloc(XdcsInfo.dwCodeLength);
                        downloadRequest.ulOffset = 0;
                        downloadRequest.ulLength = XdcsInfo.dwCodeLength;
                        downloadRequest.ulBytesRead = 0;
                        downloadRequest.hCompleteEvent = NULL;
                        dwDownloadStartTick = GetTickCount();
                        if(!downloadRequest.pvBuffer)
                        {
                            dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                        } else if(ERROR_IO_PENDING!=XDCSDownloadCodeAsync(&downloadRequest))
                        {
                            dwDownloadStatus = XDCS_STATUS_DOWNLOAD_FAILED;
                        }
                    }
                }
            }
        }        
        
        draw.FillRect(0,0,640,480, PITCH_BLACK);
        //Draw the status.
        if(XDCS_STATUS_DOWNLOAD_SUCCEEDED == dwDownloadStatus)
        {
            swprintf(FormatBuffer, StatusText[dwDownloadStatus], dwRegion, fDebugRom ? L", DEBUG" : L"");
            pFont->DrawText(70, 70, StatusColor[dwDownloadStatus],FormatBuffer);
        } else
        {
            pFont->DrawText(70, 70, StatusColor[dwDownloadStatus],StatusText[dwDownloadStatus]);
        }
        //Draw the progress
        swprintf(FormatBuffer, L"%d percent complete.", dwPercentComplete);
        pFont->DrawText(70, 95, ProgressColor[dwDownloadStatus], FormatBuffer);
        swprintf(FormatBuffer, L"%0.2lf seconds", fDownloadTime);
        pFont->DrawText(70, 120, ProgressColor[dwDownloadStatus], FormatBuffer);
        //Draw Info
        swprintf(FormatBuffer, L"Version %x.%0.2x", (ULONG)((XdcsInfo.bcdVersion&0xff00)>>8), (ULONG)(XdcsInfo.bcdVersion&0x00ff));
        pFont->DrawText(70, 145, InfoColor[dwDownloadStatus], FormatBuffer);
        swprintf(FormatBuffer, L"Code Length =  %d bytes", XdcsInfo.dwCodeLength);
        pFont->DrawText(70, 170, InfoColor[dwDownloadStatus], FormatBuffer);
        swprintf(FormatBuffer, L"FileName =  \'%S\'", szFileName);
        pFont->DrawText(70, 195, InfoColor[dwDownloadStatus], FormatBuffer);


        /**
        *** Poll the XID Remote part.
        *** Just because we don't have lot's of creative ways to
        *** abuse the XInput API, we will be clever here, and use the API in a valid,
        *** but less than optimal ways.  It had better work too!
        **/
        if(!hRemote) {
            DWORD dwDevices= (XGetDevices(XDEVICE_TYPE_IR_REMOTE)&0x0F); 
            if(dwDevices)
            {
                //Find the first bit set and open it.
                dwRemotePort = 0;
                while(!(dwDevices&(1<<dwRemotePort))) dwRemotePort++;
                hRemote = XInputOpen(XDEVICE_TYPE_IR_REMOTE, dwRemotePort, XDEVICE_NO_SLOT, NULL);
                dwPacketNumber = 0;
            }
        }
        if(hRemote)
        {
            if(ERROR_SUCCESS == XInputGetState(hRemote, (PXINPUT_STATE)(IrCodeBuffer+dwIrCodeBufferPos)))
            {
                //Don't move for duplicates
                if(dwPacketNumber != IrCodeBuffer[dwIrCodeBufferPos].dwPacketNumber)
                {
                    dwPacketNumber = IrCodeBuffer[dwIrCodeBufferPos].dwPacketNumber;
                    dwIrCodeBufferPos = (dwIrCodeBufferPos+1)%IR_CODE_BUFFER_SIZE;
                }
                
                swprintf(FormatBuffer, L"Port = %d", dwRemotePort);
                pFont->DrawText(70, 230, BRIGHT_BLUE, FormatBuffer);
                pFont->DrawText(70, 250, BRIGHT_BLUE, L"Command");
                pFont->DrawText(280, 250, BRIGHT_BLUE, L"Relative Time");
                if(dwPacketNumber)
                {
                    DWORD dwCodeBufferDisplayPos = (dwIrCodeBufferPos+1)%IR_CODE_BUFFER_SIZE;
                    DWORD dwDisplayYPos = 250 + (IR_CODE_BUFFER_SIZE*18);
                    LPCWSTR pwszCodeName;
                    for(int i=1; i < IR_CODE_BUFFER_SIZE; i++)
                    {
                        pwszCodeName = GetCodeName(IrCodeBuffer[dwCodeBufferDisplayPos].IrRemote.wKeyCode);
                        if(pwszCodeName)
                        {
                            swprintf(FormatBuffer, L"%s(0x%0.4x)", pwszCodeName, (DWORD)IrCodeBuffer[dwCodeBufferDisplayPos].IrRemote.wKeyCode);
                            pFont->DrawText(70, (float)dwDisplayYPos, BRIGHT_BLUE, FormatBuffer);
                            swprintf(FormatBuffer, L"%d ms", (DWORD)IrCodeBuffer[dwCodeBufferDisplayPos].IrRemote.wTimeDelta);
                            pFont->DrawText(280, (float)dwDisplayYPos, BRIGHT_BLUE, FormatBuffer);
                        }
                        dwDisplayYPos -= 18;
                        dwCodeBufferDisplayPos = (dwCodeBufferDisplayPos+1)%IR_CODE_BUFFER_SIZE;
                    }
                }
            } else
            {   
                XInputClose(hRemote);
                hRemote = NULL;
                memset(IrCodeBuffer, 0, sizeof(IrCodeBuffer));
                pFont->DrawText(70, 230, BRIGHT_BLUE, L"No IR Remote Receiver");
            }
        } else
        {
            pFont->DrawText(70, 230, BRIGHT_BLUE, L"No IR Remote Receiver");
        }
        //Preset
        draw.Present();
    }
}

BYTE rgbRomImageBuffer[500000]; //Buffer for the ROM image
DWORD VerifyAndGetRegion(XDCS_DVD_CODE_INFORMATION *pXdcsInfo, PVOID pvBytes, DWORD dwSize, DWORD *pdwRegion, BOOL *pfDebug)
/*++
  Routine Description:
--*/
{
    HANDLE hRomImage;
    DWORD  dwRomImageSize, dwBogus;
    DWORD  dwRegion;
    BOOL   fDebug;
    char   szRomImageDirectory[1024];
    char   szRomImagePath[1024];
    const char *pszNameTemplate = szRomImageNameTemplate;

    //
    //  Verify that the correct version of the ROM is available for the test
    //
    wsprintfA(
        szRomImageDirectory,
        szRomImageDirTemplate,
        (ULONG)((pXdcsInfo->bcdVersion&0xff00)>>8),
        (ULONG)(pXdcsInfo->bcdVersion&0x00ff)
        );
    if((DWORD)-1 == GetFileAttributes(szRomImageDirectory))
    {
        return XDCS_STATUS_DOWNLOAD_UNKNOWN_VERSION;
    }
    
    // Loop over all the possible images

    for(fDebug = 0; fDebug <= 1; fDebug++)
    {
        for(dwRegion = 1; dwRegion < 6; dwRegion++)
        {
            wsprintfA(szRomImagePath, pszNameTemplate, szRomImageDirectory, dwRegion);
            hRomImage= CreateFile(szRomImagePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
            if(INVALID_HANDLE_VALUE!=hRomImage)
            {
               dwRomImageSize = GetFileSize(hRomImage, &dwBogus);
               if(dwRomImageSize==dwSize)
               {
                    if(ReadFile(hRomImage, rgbRomImageBuffer, dwRomImageSize, &dwBogus, NULL))
                    {
                        if(0==memcmp(rgbRomImageBuffer, pvBytes, dwRomImageSize))
                        {
                            CloseHandle(hRomImage);
                            *pdwRegion = dwRegion;
                            *pfDebug = fDebug;
                            return XDCS_STATUS_DOWNLOAD_SUCCEEDED;
                        }
                    }
               }
               CloseHandle(hRomImage);
            }
        }
        pszNameTemplate = szRomImageNameTemplateD;
    }
    return XDCS_STATUS_DOWNLOAD_CODE_ERRORS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\inc\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\kbdtest\devices.cpp ===
#include <xtl.h>
#include "draw.h"
#include "devices.h"
//#include "hidkbd.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

int PressureColor(UCHAR Pressure)
/*++
    Wild ass guess on how to make it go from blue to red on more pressure.
--*/
{
    UCHAR blue = Pressure << 2;
    if(blue > Pressure) blue -= Pressure;
    else blue = 0;
    UCHAR green = Pressure << 1;;
    if(green  > Pressure) green -= Pressure;
    else green = 0;
    UCHAR red = Pressure;
    int Color = 0;
    Color = D3DCOLOR_XRGB(red, green, blue);
    return Color;
}

CKeyboard::CKeyboard(DWORD dwPortNumber) : 
    m_dwPortNumber(dwPortNumber),
    m_fOpened(FALSE),
    m_dwPacketNumber(0),
    m_hDevice(0),
    m_iLabelColorOpened(LABEL_WHITE),
    m_iLabelColorClosed(DISCONNECTED_BLUE),
    m_iStateColor(CONNECTED_YELLOW),
    m_fScrollLock(FALSE),
    m_fNumLock(FALSE),
    m_fCapsLock(FALSE)
{
    switch(dwPortNumber)
    {
        case 0:
            m_iLeftEdge = 10;
            m_iTopEdge  = 10;
            break;
        case 1:
            m_iLeftEdge = 325;
            m_iTopEdge  = 10;
            break;
        case 2:
            m_iLeftEdge = 10;
            m_iTopEdge  = 255;
            break;
        case 3:
            m_iLeftEdge = 325;
            m_iTopEdge  = 255;
            break;
    }
    /*
    m_Feedback.Header.dwStatus = ERROR_SUCCESS;
    m_Feedback.KeyboardLEDs.LedStates = 0;
    */
}

CKeyboard::~CKeyboard()
{
    Close();
}
void CKeyboard::Open(XINPUT_POLLING_PARAMETERS *pPollingParameters)
{
    DWORD dwError;
    if(!m_fOpened)
    {
        //m_Feedback.Header.dwStatus = ERROR_SUCCESS;
        m_hDevice =  XInputOpen(XDEVICE_TYPE_KEYBOARD, m_dwPortNumber, XDEVICE_NO_SLOT, pPollingParameters);
        if(m_hDevice)
        {
            m_fOpened = TRUE;
        } else
        {   
            DebugPrint("Opened port %d Failed: %d\n", m_dwPortNumber, GetLastError());
        }
    }
}
void CKeyboard::Close()
{
    DWORD dwError;
    if(m_fOpened)
    {
        //while(ERROR_IO_PENDING == m_Feedback.Header.dwStatus);
        XInputClose(m_hDevice);
        m_fOpened = FALSE;
        m_hDevice = NULL;
    }
}

void CKeyboard::PollDevice()
{
    if(!m_fOpened) return;
    XInputPoll(m_hDevice);
}

void CKeyboard::UpdateState()
{
    if(!m_fOpened) return;
    DWORD dwError = XInputGetState(m_hDevice, &m_kbdState);
    /*
    if(ERROR_IO_PENDING != m_Feedback.Header.dwStatus)
    {
        if(
            ((m_kbdState.Modifiers.bAnalogButtons[6] << 8) != m_Feedback.Rumble.wLeftMotorSpeed) ||
            ((m_kbdState.Gamepad.bAnalogButtons[7] << 8) != m_Feedback.Rumble.wRightMotorSpeed)
        ){
            m_Feedback.Rumble.wLeftMotorSpeed = m_gpState.Gamepad.bAnalogButtons[6] << 8;
            m_Feedback.Rumble.wRightMotorSpeed = m_gpState.Gamepad.bAnalogButtons[7] << 8;
            XInputSetState(m_hDevice, (PXINPUT_FEEDBACK)&m_Feedback);
        }
    }
    */
    if(ERROR_SUCCESS != dwError)
    {
        if(dwError == ERROR_DEVICE_NOT_CONNECTED)
        {
            //
            //  Don't worry about closing the handle, since we
            //  poll for device removals and we will close
            //  the handle very soon anyway.
            //
            return;
        }
        DebugPrint("XInputGetDeviceState return error: %d\n", dwError);
        DebugPrint("This error is not expected in normal operation\n");
        DebugBreak();
    }
}

void CKeyboard::Draw(CDraw& draw)
{
    int iLabelColor = m_fOpened ? m_iLabelColorOpened : m_iLabelColorClosed;
    WCHAR FormatBuffer[80];
    draw.FillRect(m_iLeftEdge, m_iTopEdge, 300, 200, BACKDROP_BLUE); 
    wsprintf(FormatBuffer, L"Port Number %d", m_dwPortNumber);
    draw.DrawText(FormatBuffer, m_iLeftEdge, m_iTopEdge, iLabelColor);
    draw.DrawText(L"Modifiers:", m_iLeftEdge+10, m_iTopEdge+10, iLabelColor);
    draw.DrawText(L"Buttons:",  m_iLeftEdge+10, m_iTopEdge+30, iLabelColor); 
    
    
    if(m_fOpened)
    {
        //
        //  Format modifiers.
        //
        wsprintf(FormatBuffer, L"0x%0.2x", (ULONG)m_kbdState.Keyboard.Modifiers);
        draw.DrawText(
            FormatBuffer,
            m_iLeftEdge+100,
            m_iTopEdge+10,
            m_iStateColor
            );
        //
        //  Show other six keys
        //
        for(int i=0; i<6; i++)
        {
            wsprintf(FormatBuffer, L"0x%0.2x", (ULONG)m_kbdState.Keyboard.Keys[i]);
            draw.DrawText(
                FormatBuffer,
                m_iLeftEdge+100+i*35,
                m_iTopEdge+30,
                m_iStateColor
                );
        }
    }
}

CKeyboards::CKeyboards(XINPUT_POLLING_PARAMETERS *pPollingParameters) :
    m_pPollingParameters(pPollingParameters)
{
    int i;
    for(i=0; i < 4; i++)
    {
        m_pKeyboards[i] = new CKeyboard(i);
        if(!m_pKeyboards[i]) DebugPrint("Failed to allocate a game controller!");
    }
    DWORD dwDevices;
    dwDevices = XGetDevices(XDEVICE_TYPE_KEYBOARD);
    for(i=0; i < 4; i++)
    {
        if(dwDevices&(1 << i)) m_pKeyboards[i]->Open(m_pPollingParameters);
    }
}

CKeyboards::~CKeyboards()
{
    int i;
    for(i=0; i < 4; i++)
    {
        delete m_pKeyboards[i];
    }
}
void CKeyboards::CheckForHotplugs()
{
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges(XDEVICE_TYPE_KEYBOARD, &dwInsertions, &dwRemovals);
    int i;
    for(i=0; i < 4; i++)
    {
        if(dwRemovals&(1 << i)) m_pKeyboards[i]->Close();
        if(dwInsertions&(1 << i)) m_pKeyboards[i]->Open(m_pPollingParameters);
    }
}
void CKeyboards::UpdateState()
{
   for(int i=0; i < 4; i++) m_pKeyboards[i]->UpdateState();
}
void CKeyboards::Draw(CDraw& draw)
{
    for(int i=0; i < 4; i++) m_pKeyboards[i]->Draw(draw);
}

void CKeyboards::PollDevices()
{
    for(int i=0; i < 4; i++) m_pKeyboards[i]->PollDevice();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\lib\xbresource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Under UMA emulation, we copy the data from AGP memory to video memory.
    // This will not be necessary with final hardware
    D3D_CopyContiguousMemoryToVideo( m_pVidMemData );

    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\kbdtest\main.cpp ===
#include <xtl.h>
#include "draw.h"
#include "devices.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}
XINPUT_POLLING_PARAMETERS g_PollingParameters = {0};
//
//  Useful Macro
//
#define DECLARE_DO_TWICE int doTwice;
#define DO_TWICE doTwice=2; while(doTwice--)

void DrawTestCaseMessage(CDraw& draw, LPWSTR pMessage);

//------------------------------------------------------------------------------
//  Forward Declations
//------------------------------------------------------------------------------
void DrawTestCaseMessage(CDraw& draw, LPWSTR pMessage);

//------------------------------------------------------------------------------
// TestMain
//------------------------------------------------------------------------------

INT WINAPI wWinMain(HINSTANCE, HINSTANCE, LPWSTR, INT)
{
    DECLARE_DO_TWICE;
    int iFrameCount=0;
    int iState = 0;
    BOOL fUseUpdateAndRedraw = TRUE;
    BOOL fCallPollDevice;
    DebugPrint("XInput Test Application.\nBuilt on %s at %s\n", __DATE__, __TIME__);
    CDraw draw;
    
    DO_TWICE
    {
        draw.FillRect(0, 0, 640, 480, BACKDROP_BLUE); 
        draw.DrawText(L"XInput Test Application", 300,  0, LABEL_WHITE);
        draw.Present();
    }
    CKeyboards *pKeyboards = NULL;
    do
    {
        fCallPollDevice = FALSE; //most of the case use autopoll
        iState = (iState+1)%5;
        //
        //  Decide how to open the game controllers this time
        //
        switch(iState)
        {
            case 0:
                DrawTestCaseMessage(draw, L"Default Polling Parameters");
                pKeyboards = new CKeyboards(NULL);
                break;
            case 1:
                DrawTestCaseMessage(draw, L"AutoPoll, Control-OUT, Input Interval 16 ms, Calling PollDevice");
                g_PollingParameters.fAutoPoll = TRUE;
                g_PollingParameters.fInterruptOut = FALSE;
                g_PollingParameters.bInputInterval = 16;
                g_PollingParameters.ReservedMBZ1 = 0;
                g_PollingParameters.ReservedMBZ2 = 0;
                pKeyboards = new CKeyboards(&g_PollingParameters);
                fCallPollDevice = TRUE; //make sure PollDevices does no harm.
                break;
            case 2:
                DrawTestCaseMessage(draw, L"AutoPoll, Control-OUT, Input Interval 4 ms");
                g_PollingParameters.fAutoPoll = TRUE;
                g_PollingParameters.fInterruptOut = FALSE;
                g_PollingParameters.bInputInterval = 4;
                g_PollingParameters.ReservedMBZ1 = 0;
                g_PollingParameters.ReservedMBZ2 = 0;
                pKeyboards = new CKeyboards(&g_PollingParameters);
                break;
            case 3:
                DrawTestCaseMessage(draw, L"ManualPoll, Control-OUT, Input Interval 2 ms");
                g_PollingParameters.fAutoPoll = FALSE;
                g_PollingParameters.fInterruptOut = FALSE;
                g_PollingParameters.bInputInterval = 2;
                g_PollingParameters.ReservedMBZ1 = 0;
                g_PollingParameters.ReservedMBZ2 = 0;
                pKeyboards = new CKeyboards(&g_PollingParameters);
                fCallPollDevice = TRUE; //make sure PollDevices does no harm.
                break;
            case 4:
                DrawTestCaseMessage(draw, L"ManualPoll, Control-OUT, Input Interval 2 ms, NOT POLLING");
                g_PollingParameters.fAutoPoll = FALSE;
                g_PollingParameters.fInterruptOut = FALSE;
                g_PollingParameters.bInputInterval = 2;
                g_PollingParameters.ReservedMBZ1 = 0;
                g_PollingParameters.ReservedMBZ2 = 0;
                pKeyboards = new CKeyboards(&g_PollingParameters);
                break;
        }
        //Poll for three hundred frames
        iFrameCount = 0;        
        while(300 > iFrameCount++)
        {
           pKeyboards->CheckForHotplugs();
           pKeyboards->UpdateState();
           DO_TWICE{
               pKeyboards->Draw(draw);
               draw.Present();
           }
           //
           //   Sleep for a video frame
           //
           if(fCallPollDevice)
           {
             Sleep(8);
             pKeyboards->PollDevices();
             Sleep(8);
           } else
           {
             Sleep(16);
           }
        }
        delete pKeyboards;
    }while(1);
    return 1;
}

void DrawTestCaseMessage(CDraw& draw, LPWSTR pMessage)
{
    DECLARE_DO_TWICE;
    DebugPrint("%ws\n", pMessage);
    DO_TWICE
    {
        draw.FillRect(0, 465, 640, 14, BACKDROP_BLUE); 
        draw.DrawText(L"TEST CASE:", 0, 465, LABEL_WHITE);
        draw.DrawText(pMessage, 60, 465, CONNECTED_YELLOW);
        draw.Present();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\lib\private.cpp ===
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>

//-----------------------------------------------------------------------------
// Name: test_MapEDrive()
// Desc: If the title was booted off the default
//       partition (aka Y:), map D to Y.
//
// This is a little something for test apps.  Sometimes we want to install
// them as y:\default.xbe for ease of use on the production floor.  Ideally,
//
//-----------------------------------------------------------------------------
VOID test_MapEDrive()
{

    OBJECT_STRING strDosDevice, strPath;
    strDosDevice.Buffer = "\\??\\E:";
    strDosDevice.Length = (USHORT)strlen(strDosDevice.Buffer);
    strDosDevice.MaximumLength = strDosDevice.Length + 1;

    /*
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE handle;
    NTSTATUS status;
    InitializeObjectAttributes(&objectAttributes,
                               &strDosDevice,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    status = NtOpenSymbolicLinkObject(&handle, &objectAttributes);
    if (!NT_SUCCESS(status))
    */
    {
        strPath.Buffer = "\\Device\\Harddisk0\\partition1\\devkit";
        strPath.Length = (USHORT)strlen(strPath.Buffer);
        strPath.MaximumLength = strPath.Length + 1;
        IoCreateSymbolicLink(&strDosDevice, &strPath);
    } 
    /*
    else{
        NtClose(handle);
    }*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\lib\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

CXBFont *CDraw::CreateFont(const CHAR* strFontResourceFileName)
{
    CXBFont *pNewFont = NULL;
    if(m_pDevice)
    {
        pNewFont = new CXBFont();
        if(pNewFont)
        {
            HRESULT hr;
            hr= pNewFont->Create(m_pDevice, strFontResourceFileName);
            if(FAILED(hr))
            {
                delete pNewFont;
                pNewFont = NULL;
            }
        }
    }
    return pNewFont;
}

//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\keyboardTest\keyboardTest.cpp ===
//
// "winerror.h"
//

#define DEBUG_KEYBOARD

#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>

void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }



void main( void )
    {
    XINPUT_POLLING_PARAMETERS xpp = { TRUE, TRUE, 0, 32, 32, 0 };
    XINPUT_DEBUG_KEYQUEUE_PARAMETERS xdkp = {
        XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN     |
            XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT  |
            XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY,
            50,
            500,
            70 };
        XDEVICE_PREALLOC_TYPE xdpt[] = {
            {XDEVICE_TYPE_GAMEPAD, 4},
            {XDEVICE_TYPE_MEMORY_UNIT, 2},
            {XDEVICE_TYPE_DEBUG_KEYBOARD, 1} };
            XINPUT_DEBUG_KEYSTROKE ks;
            DWORD dwIns, dwRem, dwPort = 0;
            CHAR szOut[2] = "X";
            HANDLE hKeyboard;
            
            
    // Initialize the peripherals.
    XInitDevices( sizeof(xdpt) / sizeof(XDEVICE_PREALLOC_TYPE), xdpt );
    
    // Create the keyboard queue.
    if( ERROR_SUCCESS == XInputDebugInitKeyboardQueue( &xdkp ) )
        {
        // Wait for the device to show up.
        DebugPrint("Waiting for Keyboard...\n");
        dwIns = XGetDevices( XDEVICE_TYPE_DEBUG_KEYBOARD );
        while( !dwIns )
            {
            XGetDeviceChanges( XDEVICE_TYPE_DEBUG_KEYBOARD, &dwIns, &dwRem );
            }
        
        // Convert the bitmask into a port number.
        while( !(dwIns & (1 << dwPort)) )
            {
            dwPort++;
            }
        
        // Open the keyboard device.
        DebugPrint("Opening Keyboard...\n");
        if( hKeyboard = XInputOpen(
            XDEVICE_TYPE_DEBUG_KEYBOARD,
            dwPort,
            XDEVICE_NO_SLOT,
            &xpp ) )
            {
            // Loop waiting for keyboard input.
            DebugPrint("You can press keys now");
            while( TRUE )
                {       
                if( ERROR_SUCCESS == XInputDebugGetKeystroke( &ks ) )
                    {
                    *szOut = ks.Ascii;
                    OutputDebugString( szOut );
                    }
                }       
            }   
        }    
    
    // Don't return from main.
    XLaunchNewImage(NULL, NULL);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\lib\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,     D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\linkinit\commontest.h ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#define CACHE_DRIVE         "Z"
#define TITLE_DRIVE         "T"
#define USER_DRIVE          "U"
#define BASE_DRIVE          CACHE_DRIVE

extern void DebugPrint(char* format, ...);

#pragma warning(push)
#pragma warning(disable : 4200) // disable warning on zero sized array
struct UsbInitInfo
    {
    unsigned variation;
    char data[0];
    };
#pragma warning(pop)


static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

extern char *logVariationStr;

#define XLL_EXCEPTION             0x00000001L  // Enables logging of exception events
#define XLL_BREAK                 0x00000002L  // Enables logging to break into the debugger
#define XLL_FAIL                  0x00000003L  // Enables logging of failure events
#define XLL_WARN                  0x00000004L  // Enables logging of warning events
#define XLL_BLOCK                 0x00000005L  // Enables logging of blocking events
#define XLL_PASS                  0x00000006L  // Enables logging of pass events
#define XLL_INFO                  0x00000007L  // Enables logging of informational events

#define XLO_DEFAULT               0x00000000L  // Opens log file in append mode
#define XLO_REFRESH               0x00000008L  // Creates a new log file.  If the log file already exists, overwrites the file and clears the existing attributes.

static void xEndVariation(HANDLE hLog)
    {
    }

static HANDLE xCreateLog(char *filename, DWORD createFlag)
    {
    if(createFlag == XLO_REFRESH)
        return fopen(filename, "w+");
    else
        return fopen(filename, "a+");
    }
static void xCloseLog(HANDLE hLog)
    {
    fclose((FILE*)hLog);
    }

static void xLog(HANDLE hLog, DWORD level, char *fmt, ...)
    {
    char *levels[] =
        {
        "UNKNOWN",
        "EXCEPTION",
        "BREAK",
        "FAIL",
        "WARN",
        "BLOCK",
        "PASS",
        "INFO"
        };

    va_list args;
    va_start(args, fmt);
    char szBuffer[1024];
    vsprintf(szBuffer, fmt, args);
    fprintf((FILE*)hLog, "0000,00:00:00,%s,USB,Init/Link Config,XInitDevices,%s,%s\n", levels[level], logVariationStr, szBuffer);
    va_end(args);
    }
static void xLogVA(HANDLE hLog, DWORD level, char *fmt, va_list args)
    {
    char *levels[] =
        {
        "UNKNOWN",
        "EXCEPTION",
        "BREAK",
        "FAIL",
        "WARN",
        "BLOCK",
        "PASS",
        "INFO"
        };

    char szBuffer[1024];
    vsprintf(szBuffer, fmt, args);
    fprintf((FILE*)hLog, "0000,00:00:00,%s,USB,Init/Link Config,XInitDevices,%s,%s\n", levels[level], logVariationStr, szBuffer);
    va_end(args);
    }

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLogVA(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLogVA(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    logVariationStr = variant;
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    StartTest(hLog, (char*)aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\linkinit\dukemu\usbinit.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>

extern void DebugPrint(char* format, ...);

#include "../commontest.h"

char *logVariationStr;

struct VariationDescription
    {
    char *description;
    unsigned size;
    XDEVICE_PREALLOC_TYPE deviceTypes[4];
    };


VariationDescription variations[] =
    {
    { "0 XDEVICE_TYPE_GAMEPADs; 0 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 0}, {XDEVICE_TYPE_MEMORY_UNIT, 0}, {0, 0}, {0, 0} } },
    { "1 XDEVICE_TYPE_GAMEPADs; 1 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 1}, {XDEVICE_TYPE_MEMORY_UNIT, 1}, {0, 0}, {0, 0} } },
    { "1 and 1 XDEVICE_TYPE_GAMEPADs; 1 and 1 XDEVICE_TYPE_MEMORY_UNITs",
        4, { {XDEVICE_TYPE_GAMEPAD, 1}, {XDEVICE_TYPE_GAMEPAD, 1}, {XDEVICE_TYPE_MEMORY_UNIT, 1}, {XDEVICE_TYPE_MEMORY_UNIT, 1} } },
    { "2 XDEVICE_TYPE_GAMEPADs; 2 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 2}, {XDEVICE_TYPE_MEMORY_UNIT, 2}, {0, 0}, {0, 0} } },
    { "3 XDEVICE_TYPE_GAMEPADs; 3 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 3}, {XDEVICE_TYPE_MEMORY_UNIT, 3}, {0, 0}, {0, 0} } },
    { "3 and 3 XDEVICE_TYPE_GAMEPADs; 3 and 3 XDEVICE_TYPE_MEMORY_UNITs",
        4, { {XDEVICE_TYPE_GAMEPAD, 3}, {XDEVICE_TYPE_GAMEPAD, 3}, {XDEVICE_TYPE_MEMORY_UNIT, 3}, {XDEVICE_TYPE_MEMORY_UNIT, 3} } },
    { "4 XDEVICE_TYPE_GAMEPADs; 4 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 4}, {XDEVICE_TYPE_MEMORY_UNIT, 4}, {0, 0}, {0, 0} } },
    { "5 XDEVICE_TYPE_GAMEPADs; 5 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 5}, {XDEVICE_TYPE_MEMORY_UNIT, 5}, {0, 0}, {0, 0} } },
    { "1024 XDEVICE_TYPE_GAMEPADs; 1024 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 1*KILOBYTE}, {XDEVICE_TYPE_MEMORY_UNIT, 1*KILOBYTE}, {0, 0}, {0, 0} } },
    { "1meg XDEVICE_TYPE_GAMEPADs; 1meg XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 1*MEGABYTE}, {XDEVICE_TYPE_MEMORY_UNIT, 1*MEGABYTE}, {0, 0}, {0, 0} } },
    { "128meg XDEVICE_TYPE_GAMEPADs; 128meg XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 128*MEGABYTE}, {XDEVICE_TYPE_MEMORY_UNIT, 128*MEGABYTE}, {0, 0}, {0, 0} } },
    { "4 XDEVICE_TYPE_GAMEPADs; 8 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 4}, {XDEVICE_TYPE_MEMORY_UNIT, 8}, {0, 0}, {0, 0} } },
    { "1 XDEVICE_TYPE_GAMEPADs; 8 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 1}, {XDEVICE_TYPE_MEMORY_UNIT, 8}, {0, 0}, {0, 0} } },
    { "4 XDEVICE_TYPE_GAMEPADs; 2 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 4}, {XDEVICE_TYPE_MEMORY_UNIT, 2}, {0, 0}, {0, 0} } },
    { "4 XDEVICE_TYPE_GAMEPADs; 2 XDEVICE_TYPE_MEMORY_UNITs",
        2, { {XDEVICE_TYPE_GAMEPAD, 4}, {XDEVICE_TYPE_MEMORY_UNIT, 2}, {0, 0}, {0, 0} } },
    };


void main(void)
    {
    HANDLE hLog;
    DWORD error;
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    UsbInitInfo *info = (UsbInitInfo*)&launchInfo;

    error = XGetLaunchInfo(&dataType, &launchInfo);

    if(dataType == LDT_FROM_DASHBOARD || dataType == LDT_FROM_DEBUGGER_CMDLINE || dataType == 0xCDCDCDCD)
        {
        info->variation = 0;
        hLog = xCreateLog("t:\\initusb.log", XLO_REFRESH);
        }
    else
        {
        hLog = xCreateLog("t:\\initusb.log", XLO_DEFAULT);
        }


    TESTCASE(variations[info->variation].description)
        {
        XInitDevices(variations[info->variation].size, variations[info->variation].deviceTypes);
        TESTPASS(hLog, "XInitDevices");
        Sleep(4000);
        DWORD devices;
        for(unsigned i=0; i<variations[info->variation].size; i++)
            {
            devices = XGetDevices(variations[info->variation].deviceTypes[i].DeviceType);
            if(devices != 0)
                TESTPASS(hLog, "  XGetDevices dev=0x%08X ret=0x%08X", variations[info->variation].deviceTypes[i].DeviceType, devices);
            else
                TESTFAIL(hLog, "  XGetDevices dev=0x%08X ret=0x%08X", variations[info->variation].deviceTypes[i].DeviceType, devices);
            }
        } ENDTESTCASE;

    ++info->variation;

    xCloseLog(hLog);

    if(info->variation == ARRAYSIZE(variations)) XLaunchNewImage(NULL, NULL);
    else XLaunchNewImage("D:\\dukemu.xbe", &launchInfo);
    }


void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\linkinit\duke\usbinit.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>

extern void DebugPrint(char* format, ...);

#include "../commontest.h"

char *logVariationStr;

struct VariationDescription
    {
    char *description;
    unsigned size;
    XDEVICE_PREALLOC_TYPE deviceTypes[2];
    };

VariationDescription variations[] =
    {
    { "0 XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 0}, {0, 0} } },
    { "1 XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 1}, {0, 0} } },
    { "1 and 1 XDEVICE_TYPE_GAMEPADs",
        2, { {XDEVICE_TYPE_GAMEPAD, 1}, {XDEVICE_TYPE_GAMEPAD, 1} } },
    { "2 XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 2}, {0, 0} } },
    { "3 XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 3}, {0, 0} } },
    { "3 and 3 XDEVICE_TYPE_GAMEPADs",
        2, { {XDEVICE_TYPE_GAMEPAD, 3}, {XDEVICE_TYPE_GAMEPAD, 3} } },
    { "4 XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 4}, {0, 0} } },
    { "5 XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 5}, {0, 0} } },
    { "1024 XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 1*KILOBYTE}, {0, 0} } },
    { "1meg XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 1*MEGABYTE}, {0, 0} } },
    { "128meg XDEVICE_TYPE_GAMEPADs",
        1, { {XDEVICE_TYPE_GAMEPAD, 128*MEGABYTE}, {0, 0} } },
    };


void main(void)
    {
    HANDLE hLog;
    DWORD error;
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    UsbInitInfo *info = (UsbInitInfo*)&launchInfo;

    error = XGetLaunchInfo(&dataType, &launchInfo);

    if(dataType == LDT_FROM_DASHBOARD || dataType == LDT_FROM_DEBUGGER_CMDLINE || dataType == 0xCDCDCDCD)
        {
        info->variation = 0;
        hLog = xCreateLog("t:\\initusb.log", XLO_REFRESH);
        }
    else
        {
        hLog = xCreateLog("t:\\initusb.log", XLO_DEFAULT);
        }

    if(hLog == NULL)
        {
        DebugPrint("LOG FILE IS NULL!!!!\n");
        }

    TESTCASE(variations[info->variation].description)
        {
        XInitDevices(variations[info->variation].size, variations[info->variation].deviceTypes);
        TESTPASS(hLog, "XInitDevices");
        Sleep(4000);
        DWORD devices;
        for(unsigned i=0; i<variations[info->variation].size; i++)
            {
            devices = XGetDevices(variations[info->variation].deviceTypes[i].DeviceType);
            if(devices != 0)
                TESTPASS(hLog, "  XGetDevices dev=0x%08X ret=0x%08X", variations[info->variation].deviceTypes[i].DeviceType, devices);
            else
                TESTFAIL(hLog, "  XGetDevices dev=0x%08X ret=0x%08X", variations[info->variation].deviceTypes[i].DeviceType, devices);
            }
        } ENDTESTCASE;

    ++info->variation;

    xCloseLog(hLog);

    if(info->variation == ARRAYSIZE(variations)) XLaunchNewImage(NULL, NULL);
    else XLaunchNewImage("D:\\duke.xbe", &launchInfo);
    }

void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }

/*
char *configuration[] = 
    {
    "DUKE 0",
    "DUKE 1",
    "DUKE 2",
    "DUKE 3",
    "DUKE 4",
    "DUKE 5",
    "DUKE 6",
    "DUKE 7",
    "DUKE 8",
    "DUKE 9",
    "MU 0",
    "MU 1",
    "MU 2",
    "MU 3",
    "MU 4",
    "MU 5",
    "MU 6",
    "MU 7",
    "MU 8",
    "MU 9",
    "HAWK 0",
    "HAWK 1",
    "HAWK 2",
    "HAWK 3",
    "HAWK 4",
    "HAWK 5",
    "HAWK 6",
    "HAWK 7",
    "HAWK 8",
    "HAWK 9",
    "DVD 0",
    "DVD 1",
    "DVD 2",
    "DVD 3",
    "DVD 4",
    "DVD 5",
    "DVD 6",
    "DVD 7",
    "DVD 8",
    "DVD 9",
    "KEYBOARD 0",
    "KEYBOARD 1",
    "KEYBOARD 2",
    "KEYBOARD 3",
    "KEYBOARD 4",
    "KEYBOARD 5",
    "KEYBOARD 6",
    "KEYBOARD 7",
    "KEYBOARD 8",
    "KEYBOARD 9",
    "DUKE 1, MU 0",
    "DUKE 1, MU 1",
    "DUKE 1, MU 2",
    "DUKE 1, MU 8",
    "DUKE 1, HAWK 0",
    "DUKE 1, HAWK 1",
    "DUKE 1, HAWK 2",
    "DUKE 1, HAWK 8",
    "DUKE 1, KEYBOARD 0",
    "DUKE 1, KEYBOARD 1",
    "DUKE 1, KEYBOARD 2",
    "DUKE 1, KEYBOARD 8",
    "DUKE 1, DVD 0",
    "DUKE 1, DVD 1",
    "DUKE 1, DVD 2",
    "DUKE 1, DVD 8",
    "DUKE 1, MU 0, HAWK 0",
    "DUKE 1, MU 1, HAWK 1",
    "DUKE 1, MU 2, HAWK 2",
    "DUKE 1, MU 8, HAWK 8",
    "DUKE 1, MU 0, HAWK 0, KEYBOARD 1",
    "DUKE 1, MU 1, HAWK 1, DVD 1",
    "DUKE 1, MU 2, KEYBOARD 1",
    "DUKE 2, MU 4, HAWK 4",
    "DUKE 2, MU 6, HAWK 6",
    "DUKE 2, MU 8, HAWK 8",
    "DUKE 2, MU 0, HAWK 0, KEYBOARD 1",
    "DUKE 2, MU 1, HAWK 1, DVD 1",
    "DUKE 2, MU 2, KEYBOARD 1",
    "DUKE 3, MU 4, HAWK 4",
    "DUKE 3, MU 6, HAWK 6",
    "DUKE 3, MU 8, HAWK 8",
    "DUKE 3, MU 0, HAWK 0, KEYBOARD 1",
    "DUKE 3, MU 1, HAWK 1, DVD 1",
    "DUKE 3, MU 2, KEYBOARD 1",
    "DUKE 4, MU 4, HAWK 4",
    "DUKE 4, MU 6, HAWK 6",
    "DUKE 4, MU 8, HAWK 8",
    "DUKE 4, MU 0, HAWK 0, KEYBOARD 1",
    "DUKE 4, MU 1, HAWK 1, DVD 1",
    "DUKE 4, MU 2, KEYBOARD 1",
    "DUKE 4, MU 8, HAWK 8, DVD 4, KEYBOARD 4",
    };
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\linkinit\keyboard\usbinit.cpp ===
#define DEBUG_KEYBOARD

#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>

extern void DebugPrint(char* format, ...);

#include "../commontest.h"

char *logVariationStr;

struct VariationDescription
    {
    char *description;
    unsigned size;
    XDEVICE_PREALLOC_TYPE deviceTypes[2];
    };

VariationDescription variations[] =
    {
    { "0 XDEVICE_TYPE_DEBUG_KEYBOARD",
        1, { {XDEVICE_TYPE_DEBUG_KEYBOARD, 0}, {0, 0} } },
    { "1 XDEVICE_TYPE_DEBUG_KEYBOARD",
        1, { {XDEVICE_TYPE_DEBUG_KEYBOARD, 1}, {0, 0} } },
    { "2 XDEVICE_TYPE_DEBUG_KEYBOARDs",
        2, { {XDEVICE_TYPE_DEBUG_KEYBOARD, 1}, {XDEVICE_TYPE_DEBUG_KEYBOARD, 1} } },
    };


void main(void)
    {
    HANDLE hLog;
    DWORD error;
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    UsbInitInfo *info = (UsbInitInfo*)&launchInfo;

    error = XGetLaunchInfo(&dataType, &launchInfo);

    if(dataType == LDT_FROM_DASHBOARD || dataType == LDT_FROM_DEBUGGER_CMDLINE || dataType == 0xCDCDCDCD)
        {
        info->variation = 0;
        hLog = xCreateLog("t:\\initusb.log", XLO_REFRESH);
        }
    else
        {
        hLog = xCreateLog("t:\\initusb.log", XLO_DEFAULT);
        }

    if(hLog == NULL)
        {
        DebugPrint("LOG FILE IS NULL!!!!\n");
        }

    TESTCASE(variations[info->variation].description)
        {
        XInitDevices(variations[info->variation].size, variations[info->variation].deviceTypes);
        TESTPASS(hLog, "XInitDevices");
        Sleep(4000);
        DWORD devices;
        for(unsigned i=0; i<variations[info->variation].size; i++)
            {
            devices = XGetDevices(variations[info->variation].deviceTypes[i].DeviceType);
            if(devices != 0)
                TESTPASS(hLog, "  XGetDevices dev=0x%08X ret=0x%08X", variations[info->variation].deviceTypes[i].DeviceType, devices);
            else
                TESTFAIL(hLog, "  XGetDevices dev=0x%08X ret=0x%08X", variations[info->variation].deviceTypes[i].DeviceType, devices);
            }
        } ENDTESTCASE;

    ++info->variation;

    xCloseLog(hLog);

    if(info->variation == ARRAYSIZE(variations)) XLaunchNewImage(NULL, NULL);
    else XLaunchNewImage("D:\\duke.xbe", &launchInfo);
    }

void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\lib\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\linkinit\hawk\usbinit.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>

extern void DebugPrint(char* format, ...);

#include "../commontest.h"

char *logVariationStr;

struct VariationDescription
    {
    char *description;
    unsigned size;
    XDEVICE_PREALLOC_TYPE deviceTypes[4];
    };


VariationDescription variations[] =
    {
    { "0 XDEVICE_TYPE_VOICE_MICROPHONEs; 0 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 0}, {XDEVICE_TYPE_VOICE_HEADPHONE, 0}, {0, 0}, {0, 0} } },

    { "1 XDEVICE_TYPE_VOICE_MICROPHONEs; 1 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 1}, {XDEVICE_TYPE_VOICE_HEADPHONE, 1}, {0, 0}, {0, 0} } },

    { "1 and 1 XDEVICE_TYPE_VOICE_MICROPHONEs; 1 and 1 XDEVICE_TYPE_VOICE_HEADPHONEs",
        4, { {XDEVICE_TYPE_VOICE_MICROPHONE, 1}, {XDEVICE_TYPE_VOICE_MICROPHONE, 1}, {XDEVICE_TYPE_VOICE_HEADPHONE, 1}, {XDEVICE_TYPE_VOICE_HEADPHONE, 1} } },

    { "2 XDEVICE_TYPE_VOICE_MICROPHONEs; 2 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 2}, {XDEVICE_TYPE_VOICE_HEADPHONE, 2}, {0, 0}, {0, 0} } },

    { "3 XDEVICE_TYPE_VOICE_MICROPHONEs; 3 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 3}, {XDEVICE_TYPE_VOICE_HEADPHONE, 3}, {0, 0}, {0, 0} } },

    { "3 and 3 XDEVICE_TYPE_VOICE_MICROPHONEs; 3 and 3 XDEVICE_TYPE_VOICE_HEADPHONEs",
        4, { {XDEVICE_TYPE_VOICE_MICROPHONE, 3}, {XDEVICE_TYPE_VOICE_MICROPHONE, 3}, {XDEVICE_TYPE_VOICE_HEADPHONE, 3}, {XDEVICE_TYPE_VOICE_HEADPHONE, 3} } },

    { "4 XDEVICE_TYPE_VOICE_MICROPHONEs; 4 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 4}, {XDEVICE_TYPE_VOICE_HEADPHONE, 4}, {0, 0}, {0, 0} } },

    { "1 XDEVICE_TYPE_VOICE_MICROPHONEs; 4 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 1}, {XDEVICE_TYPE_VOICE_HEADPHONE, 4}, {0, 0}, {0, 0} } },

    { "4 XDEVICE_TYPE_VOICE_MICROPHONEs; 1 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 4}, {XDEVICE_TYPE_VOICE_HEADPHONE, 1}, {0, 0}, {0, 0} } },

    { "4 XDEVICE_TYPE_VOICE_MICROPHONEs; 2 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 4}, {XDEVICE_TYPE_VOICE_HEADPHONE, 2}, {0, 0}, {0, 0} } },

    { "2 XDEVICE_TYPE_VOICE_MICROPHONEs; 4 XDEVICE_TYPE_VOICE_HEADPHONEs",
        2, { {XDEVICE_TYPE_VOICE_MICROPHONE, 2}, {XDEVICE_TYPE_VOICE_HEADPHONE, 4}, {0, 0}, {0, 0} } },
    };


void main(void)
    {
    HANDLE hLog;
    DWORD error;
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    UsbInitInfo *info = (UsbInitInfo*)&launchInfo;

    error = XGetLaunchInfo(&dataType, &launchInfo);

    if(dataType == LDT_FROM_DASHBOARD || dataType == LDT_FROM_DEBUGGER_CMDLINE || dataType == 0xCDCDCDCD)
        {
        info->variation = 0;
        hLog = xCreateLog("t:\\initusb.log", XLO_REFRESH);
        }
    else
        {
        hLog = xCreateLog("t:\\initusb.log", XLO_DEFAULT);
        }


    TESTCASE(variations[info->variation].description)
        {
        XInitDevices(variations[info->variation].size, variations[info->variation].deviceTypes);
        TESTPASS(hLog, "XInitDevices");
        Sleep(4000);
        DWORD devices;
        for(unsigned i=0; i<variations[info->variation].size; i++)
            {
            devices = XGetDevices(variations[info->variation].deviceTypes[i].DeviceType);
            if(devices != 0)
                TESTPASS(hLog, "  XGetDevices dev=0x%08X ret=0x%08X", variations[info->variation].deviceTypes[i].DeviceType, devices);
            else
                TESTFAIL(hLog, "  XGetDevices dev=0x%08X ret=0x%08X", variations[info->variation].deviceTypes[i].DeviceType, devices);
            }
        } ENDTESTCASE;

    ++info->variation;

    xCloseLog(hLog);

    if(info->variation == ARRAYSIZE(variations)) XLaunchNewImage(NULL, NULL);
    else XLaunchNewImage("D:\\hawk.xbe", &launchInfo);
    }


void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\commontest.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         "Z"
#define TITLE_DRIVE         "T"
#define USER_DRIVE          "U"
//#define BASE_DRIVE          "F"
namespace MUTests
    {
    extern WCHAR BASE_DRIVE[5];
    }

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, char *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )
#define CLEARFLAG(var, flag)                (var &= ~(flag))
#define SETFLAG(var, flag)                  (var |=  (flag))

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    xStartVariation(hLog, variant);
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    xStartVariation(hLog, aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

#define ALLCHARS "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f" \
    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

// common numbers
static DWORD dwBogus = 0xF000BAAA;
static ULARGE_INTEGER ulBogus = { 0xF000BAAA, 0xF000BAAA };

// common HANDLE parameters
static HANDLE hNull = NULL;
static HANDLE hBogus = (void*)0xF000BAAA;

// common string parameters
static char* lpNull = NULL;
static char* lpEmpty = "";
static char* lpSpace = " ";
//static char* lpBogus = (const char*)0xF000BAAA;
static char* lpCurrentDir = ".";
static char* lpParentDir = "..";
//static LPCTSTR lpUnderMaxPathDir = BASE_DRIVE ":\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory";
//static LPCTSTR lpOverMaxPathDir = BASE_DRIVE ":\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory\\direct.ory";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\copyfile.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CopyFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the CopyFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    DWORD - 

*/
DWORD MUTests::CopyFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL CopyFile(
      LPCTSTR lpExistingFileName, // name of an existing file
      LPCTSTR lpNewFileName,      // name of new file
      BOOL bFailIfExists          // operation if file exists
    );
    */
    xSetFunctionName(hLog, "CopyFile");

    char lpSmallFile[80]; sprintf(lpSmallFile, "%ws:\\FCP01_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%ws:\\FCP02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%ws:\\FCP03_%d.bla", BASE_DRIVE, ThreadID);
    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FCP04_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\FCP05_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws:\\FCP06_%d.txt", BASE_DRIVE, ThreadID);
    char lpFileTemp1[80];
    unsigned i;

    // initialize system state
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);
    DeleteFile(lpFakeFile);
    DeleteFile(lpBigFile);
    DeleteFile(lpSmallFile);
    CreateFilledFile(lpSmallFile, KILOBYTE*16);
    CreateFilledFile(lpBigFile, MEGABYTE*3);

    DWORD time = GetTickCount();




    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(exists, nonexists, true)")
        {
        if(CopyFile(lpSmallFile, lpFile1, TRUE) == TRUE && FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, nonexists, false)")
        {
        if(CopyFile(lpSmallFile, lpFile2, FALSE) == TRUE && FileExists(lpFile2))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, exists, false)")
        {
        if(CopyFile(lpSmallFile, lpFile1, FALSE) == TRUE && FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(exists, exists, true)")
        {
        if(CopyFile(lpSmallFile, lpFile1, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(nonexists, nonexists, false)")
        {
        if(CopyFile(lpFakeFile, lpFile3, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(exists, nonexist\\nonexists, false)")
        {
        sprintf(lpFileTemp1, "%ws:\\CopyFile_nonexistdir\\CopyFile_file4_%d.txt", BASE_DRIVE, ThreadID);
        if(CopyFile(lpFakeFile, lpFileTemp1, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // copy abc to abc
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(file1, file1, true)")
        {
        if(CopyFile(lpBigFile, lpBigFile, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(file1, file1, false)")
        {
        if(CopyFile(lpBigFile, lpBigFile, FALSE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("MUTESTS(%d): This test takes a long time to run...\n", ThreadID);
        for(i=0; i<10; i++)
            {
            DebugPrint("   (%d) %02d%%\n", ThreadID, i*10);
            CopyFile(lpSmallFile, lpFile1, FALSE);
            }
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    xSetFunctionName(hLog, "DeleteFile");
    TESTCASE("Removing CopyFile_file1.txt")
        {
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing CopyFile_file2.txt")
        {
        if(DeleteFile(lpFile2) == TRUE && !FileExists(lpFile2))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing CopyFile_file3.txt")
        {
        if(DeleteFile(lpFile3) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing non existant file")
        {
        if(DeleteFile(lpFakeFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing large file")
        {
        if(DeleteFile(lpBigFile) != FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Removing small file")
        {
        if(DeleteFile(lpSmallFile) != FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;



    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\copyfileex.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CopyFileEx.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

static BOOL cancel = FALSE;
static DWORD CALLBACK CopyFileProgressRoutine(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);
static DWORD CALLBACK CancelHalfway(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);
static DWORD CALLBACK CancelOnFirst(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);


struct CopyState
    {
    HANDLE hLog;
    __int64 totalBytesTransferred;
    int state;
    };

// states
#define TEST_CANCELRESUME   1
#define TEST_CANCELFLAG     2


/*

Routine Description:

    Tests the CopyFileEx API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::CopyFileEx_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL CopyFileEx(
      LPCTSTR lpExistingFileName,           // name of existing file
      LPCTSTR lpNewFileName,                // name of new file
      LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
      LPVOID lpData,                        // callback parameter
      LPBOOL pbCancel,                      // cancel status
      DWORD dwCopyFlags                     // copy options
    );
    */
    xSetFunctionName(hLog, "CopyFileEx");

    char lpSmallFile[80]; sprintf(lpSmallFile, "%ws:\\FCPX01_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%ws:\\FCPX02_%d.txt", BASE_DRIVE, ThreadID);
    char lpExtraBigFile[80]; sprintf(lpExtraBigFile, "%ws:\\FCPX03_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%ws:\\FCPX04_%d.bla", BASE_DRIVE, ThreadID);
    char lpFakeFile2[80]; sprintf(lpFakeFile2, "%ws:\\FCPX05_%d.bla", BASE_DRIVE, ThreadID);
    char lpDevice[80]; sprintf(lpDevice, "%ws:\\FCPX06_%d.txt", BASE_DRIVE, ThreadID);
    char lpDir1[80]; sprintf(lpDir1, "%ws:\\FCPX_%d", BASE_DRIVE, ThreadID);
    char lpSubFile[80]; sprintf(lpSubFile, "%ws:\\FCPX_%d\\FCPX07_%d.txt", BASE_DRIVE, ThreadID, ThreadID);
    char lpFile1[80];
    char lpFile2[80];
    unsigned i;

    // initialize system state
    CreateDirectory(lpDir1, NULL);
    CreateFilledFile(lpSmallFile, KILOBYTE*3);
    CreateFilledFile(lpBigFile, MEGABYTE*2);        // tests rely on this being 2meg
    CreateFilledFile(lpSubFile, KILOBYTE*9);


    DWORD time = GetTickCount();




    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("small file")
        {
        sprintf(lpFile1, "%ws:\\FCPX08_%d.txt", BASE_DRIVE, ThreadID);

        if(CopyFileEx(lpSmallFile, lpFile1, CopyFileProgressRoutine, hLog, &cancel, 0) == TRUE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("large file")
        {
        sprintf(lpFile1, "%ws:\\FCPX08_%d.txt", BASE_DRIVE, ThreadID);

        if(CopyFileEx(lpBigFile, lpFile1, CopyFileProgressRoutine, hLog, &cancel, 0) == TRUE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("Exists & FAIL_IF_EXISTS")
        {
        if(CopyFileEx(lpBigFile, lpBigFile, CopyFileProgressRoutine, hLog, &cancel, COPY_FILE_FAIL_IF_EXISTS) == FALSE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    /*
    TESTCASE("large file cancel+resume")
        {
        CopyState state = { hLog, 0, TEST_CANCELRESUME };
        sprintf(lpFile1, "%ws:\\FCPX08_%d.txt", BASE_DRIVE, ThreadID);

        if(CopyFileEx(lpBigFile, lpFile1, CancelHalfway, &state, &cancel, COPY_FILE_RESTARTABLE) == FALSE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(CopyFileEx(lpBigFile, lpFile1, CancelOnFirst, &state, &cancel, COPY_FILE_RESTARTABLE) == FALSE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(state.totalBytesTransferred >= 1*MEGABYTE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Copy didnt restart, copied bytes = %I64d (ec: %ld)", state.totalBytesTransferred, GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
        */
    TESTCASE("cancel flag")
        {
        CopyState state = { hLog, 0, TEST_CANCELFLAG };
        sprintf(lpFile1, "%ws:\\FCPX08_%d.txt", BASE_DRIVE, ThreadID);

        if(CopyFileEx(lpBigFile, lpFile1, CancelHalfway, &state, &cancel, 0) == FALSE)
            TESTPASS(hLog, "CopyFileEx (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CopyFileEx (ec: %ld)", GetLastError());

        if(state.totalBytesTransferred < 1*MEGABYTE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Copy didnt stop, copied bytes = %I64d (ec: %ld)", state.totalBytesTransferred, GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });




    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    DeleteFile(lpSubFile);
    RemoveDirectory(lpDir1);
    DeleteFile(lpBigFile);
    DeleteFile(lpSmallFile);
    DeleteFile(lpExtraBigFile);
    DeleteFile(lpDevice);

    return 0;
    }


/*

Routine Description:

    Callback function used with the CopyFileEx and MoveFileWithProgress functions
    See "CopyProgressRoutine" in MSDN

Arguments:

    LARGE_INTEGER TotalFileSize          - file size
    LARGE_INTEGER TotalBytesTransferred  - bytes transferred
    LARGE_INTEGER StreamSize             - bytes in stream
    LARGE_INTEGER StreamBytesTransferred - bytes transferred for stream
    DWORD dwStreamNumber                 - current stream
    DWORD dwCallbackReason               - callback reason
    HANDLE hSourceFile                   - handle to source file
    HANDLE hDestinationFile              - handle to destination file
    LPVOID lpData                        - user data, HANDLE to XLOG object

Return Value:

    PROGRESS_CONTINUE, PROGRESS_STOP, or PROGRESS_CANCEL

*/
static DWORD CALLBACK CopyFileProgressRoutine(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
    {
    if(!lpData) return PROGRESS_CONTINUE;

    HANDLE hLog = (HANDLE)lpData;

    //xLog(hLog, XLL_INFO, "1: %I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);

    if(TotalBytesTransferred.QuadPart > TotalFileSize.QuadPart)
        {
        xLog(hLog, XLL_FAIL, "Transfered more than filesize: %I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);
        }

    if(TotalBytesTransferred.QuadPart >= TotalFileSize.QuadPart)
        {
        }

    return PROGRESS_CONTINUE;
    }

/*

Routine Description:

    Callback function used with the CopyFileEx and MoveFileWithProgress functions
    See "CopyProgressRoutine" in MSDN

Arguments:

    LARGE_INTEGER TotalFileSize          - file size
    LARGE_INTEGER TotalBytesTransferred  - bytes transferred
    LARGE_INTEGER StreamSize             - bytes in stream
    LARGE_INTEGER StreamBytesTransferred - bytes transferred for stream
    DWORD dwStreamNumber                 - current stream
    DWORD dwCallbackReason               - callback reason
    HANDLE hSourceFile                   - handle to source file
    HANDLE hDestinationFile              - handle to destination file
    LPVOID lpData                        - user data, CopyState

Return Value:

    PROGRESS_CONTINUE, PROGRESS_STOP, or PROGRESS_CANCEL

*/
static DWORD CALLBACK CancelHalfway(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
    {
    if(!lpData) return PROGRESS_CONTINUE;

    CopyState *state = (CopyState*)lpData;
    HANDLE hLog = state->hLog;
    state->totalBytesTransferred = TotalBytesTransferred.QuadPart;

    //xLog(hLog, XLL_INFO, "2: %I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);

    if(TotalBytesTransferred.QuadPart >= 1*MEGABYTE)
        {
        if(state->state == TEST_CANCELRESUME)
            {
            //return PROGRESS_STOP;
            return PROGRESS_CONTINUE;
            }
        else if(state->state == TEST_CANCELFLAG)
            {
            cancel = TRUE;
            return PROGRESS_CONTINUE;
            }
        else
            {
            return PROGRESS_CONTINUE;
            }
        }

    if(TotalBytesTransferred.QuadPart >= TotalFileSize.QuadPart)
        {
        }

    return PROGRESS_CONTINUE;
    }

/*

Routine Description:

    Callback function used with the CopyFileEx and MoveFileWithProgress functions
    See "CopyProgressRoutine" in MSDN

Arguments:

    LARGE_INTEGER TotalFileSize          - file size
    LARGE_INTEGER TotalBytesTransferred  - bytes transferred
    LARGE_INTEGER StreamSize             - bytes in stream
    LARGE_INTEGER StreamBytesTransferred - bytes transferred for stream
    DWORD dwStreamNumber                 - current stream
    DWORD dwCallbackReason               - callback reason
    HANDLE hSourceFile                   - handle to source file
    HANDLE hDestinationFile              - handle to destination file
    LPVOID lpData                        - user data, CopyState

Return Value:

    PROGRESS_CONTINUE, PROGRESS_STOP, or PROGRESS_CANCEL

*/
static DWORD CALLBACK CancelOnFirst(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
    {
    if(!lpData) return PROGRESS_CONTINUE;

    CopyState *state = (CopyState*)lpData;
    HANDLE hLog = state->hLog;
    state->totalBytesTransferred = TotalBytesTransferred.QuadPart;

    if(dwCallbackReason == CALLBACK_CHUNK_FINISHED) return PROGRESS_CANCEL;
    else return PROGRESS_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\createfile.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CreateFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the CreateFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

Notes:

    Cases for the below flags are handled in the ReadFile/WriteFile tests
        FILE_FLAG_RANDOM_ACCESS
        FILE_FLAG_SEQUENTIAL_SCAN
        FILE_FLAG_WRITE_THROUGH
    
*/
DWORD MUTests::CreateFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    HANDLE CreateFile(
      LPCTSTR lpFileName,                         // file name
      DWORD dwDesiredAccess,                      // access mode
      DWORD dwShareMode,                          // share mode
      LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
      DWORD dwCreationDisposition,                // how to create
      DWORD dwFlagsAndAttributes,                 // file attributes
      HANDLE hTemplateFile                        // handle to template file
    );
    */
    xSetFunctionName(hLog, "CreateFile");

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FCF01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\FCF02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws:\\FCF03_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile4[80]; sprintf(lpFile4, "%ws:\\FCF04_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile5[80]; sprintf(lpFile5, "%ws:\\FCF05_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%ws:\\FCF06_%d.txt", BASE_DRIVE, ThreadID);
    char lpTemp[80];
    char lpTemp2[80];

    HANDLE hFile = NULL;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;
    unsigned i;

    // initialize system state
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);
    DeleteFile(lpFile4);
    DeleteFile(lpFile5);
    DeleteFile(lpFakeFile);

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Create new, 8.3")
        {
        sprintf(lpTemp, "%ws:\\%d.zzz", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        DeleteFile(lpTemp);
        } ENDTESTCASE;
    TESTCASE("Create new, 8.3")
        {
        sprintf(lpTemp, "%ws:\\aaaaaa_%d.000", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        DeleteFile(lpTemp);
        } ENDTESTCASE;
    /*
    TESTCASE("Create new \\\\?")
        {
        sprintf(lpTemp, "\\\\?\\%ws:\\CreateFileFullPath_%d.txt", BASE_DRIVE, ThreadID);
        hFile = CreateFile(lpTemp, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpTemp))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        DeleteFile(lpTemp);
        } ENDTESTCASE;
        */
    TESTCASE("Create new file write")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("Create new file write/read")
        {
        hFile = CreateFile(lpFile2, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpFile2))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("Create new file read")
        {
        hFile = CreateFile(lpFile3, GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE && FileExists(lpFile3))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        } ENDTESTCASE;
    TESTCASE("Open existing file write")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        CloseHandle(hFile);
        DeleteFile(lpFile1);
        } ENDTESTCASE;
    TESTCASE("Open existing file write/read")
        {
        hFile = CreateFile(lpFile2, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile2);});
    TESTCASE("Open existing file read")
        {
        hFile = CreateFile(lpFile3, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile3);});
    TESTCASE("ReOpen an opened file with read access")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile1 = CreateFile(lpFile1, STANDARD_RIGHTS_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile1 != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); CloseHandle(hFile1); DeleteFile(lpFile1);});
    TESTCASE("ReOpen an opened file with write access")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile1 = CreateFile(lpFile1, STANDARD_RIGHTS_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile1 != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); CloseHandle(hFile1); DeleteFile(lpFile1);});
    TESTCASE("ReOpen an opened file with read write access")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile1 = CreateFile(lpFile1, STANDARD_RIGHTS_WRITE | STANDARD_RIGHTS_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile1 != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); CloseHandle(hFile1); DeleteFile(lpFile1);});
    TESTCASE("TRUNCATE_EXISTING 16k")
        {
        DWORD filesize;
        sprintf(lpTemp, "%ws:\\FCF07_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpTemp, 16*KILOBYTE+7); // 7 is just randomness

        hFile = CreateFile(lpTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS | TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        if((filesize=GetFileSize(hFile, NULL)) == 0)
            TESTPASS(hLog, "GetFileSize[%lu] (ec: %ld)", filesize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize[%lu] (ec: %ld)", filesize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("TRUNCATE_EXISTING 6meg")
        {
        DWORD filesize;
        sprintf(lpTemp, "%ws:\\FCF08_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpTemp, 6*MEGABYTE+7); // 7 is just randomness

        hFile = CreateFile(lpTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS | TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        if((filesize=GetFileSize(hFile, NULL)) == 0)
            TESTPASS(hLog, "GetFileSize[%lu] (ec: %ld)", filesize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize[%lu] (ec: %ld)", filesize, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    TESTCASE("DELETE_ON_CLOSE existing file")
        {
        sprintf(lpTemp, "%ws:\\FCF09_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpTemp, 3*MEGABYTE+7); // 7 is just randomness

        hFile = CreateFile(lpTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        CloseHandle(hFile);

        if(! FileExists(lpTemp))
            TESTPASS(hLog, "FileExists (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FileExists (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpTemp);});
    TESTCASE("DELETE_ON_CLOSE new file")
        {
        sprintf(lpTemp, "%ws:\\FCF10_%d.txt", BASE_DRIVE, ThreadID);

        hFile = CreateFile(lpTemp, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        FillFile(hFile, 5*MEGABYTE+7); // 7 is just randomness

        CloseHandle(hFile);

        if(! FileExists(lpTemp))
            TESTPASS(hLog, "FileExists (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FileExists (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ DeleteFile(lpTemp);});


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Open nonexisting file write")
        {
        hFile = CreateFile(lpFakeFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("Open nonexisting file write/read")
        {
        hFile = CreateFile(lpFakeFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("Open nonexisting file read")
        {
        hFile = CreateFile(lpFakeFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE;
    TESTCASE("New only on existing file")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        CloseHandle(hFile);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("New only on existing write/read")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        CloseHandle(hFile);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("New only on existing file read")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        CloseHandle(hFile);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile = CreateFile(lpFile1, GENERIC_READ, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ DeleteFile(lpFile1); });
    TESTCASE("Open a directory read only")
        {
        sprintf(lpTemp, "%ws:\\CreateFileDirR_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpTemp, NULL);
        if(!FileExists(lpTemp))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        hFile = CreateFile(lpTemp, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpTemp); });
    TESTCASE("Open a directory write")
        {
        sprintf(lpTemp, "%ws:\\CreateFileDirW_%d", BASE_DRIVE, ThreadID);
        CreateDirectory(lpTemp, NULL);
        if(!FileExists(lpTemp))
            {
            BLOCKED(0, "Unable to create initial directory");
            }
        hFile = CreateFile(lpTemp, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile);
            }
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpTemp); });
    TESTCASE("ReOpen an opened file with exclusive access")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to create initial file");
            }
        hFile1 = CreateFile(lpFile1, GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile1 == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            {
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            CloseHandle(hFile1);
            }
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("TRUNCATE_EXISTING no Rights")
        {
        sprintf(lpTemp, "%ws:\\FCF11_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpTemp, 3*KILOBYTE+7); // 7 is just randomness

        hFile = CreateFile(lpTemp, GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS | TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTemp);});
    /*
    TESTCASE("Template File")
        {
        sprintf(lpTemp, "%ws:\\FCF12_%d.txt", BASE_DRIVE, ThreadID);
        sprintf(lpTemp2, "%ws:\\FCF013_%d.txt", BASE_DRIVE, ThreadID);

        hFile = CreateFile(lpTemp, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        hFile1 = CreateFile(lpTemp2, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, hFile);
        if(hFile1 == INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "CreateFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "CreateFile (ec: %ld)", GetLastError());

        CloseHandle(hFile);
        CloseHandle(hFile1);
        } ENDTESTCASE_CLEAN({ DeleteFile(lpTemp); DeleteFile(lpTemp2); });
*/


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    // clean up
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);
    DeleteFile(lpFile4);
    DeleteFile(lpFile5);
    DeleteFile(lpFakeFile);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\findfile.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    FindFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the FindFirstFile / FindNextFile / FindClose APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::FindFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL FindClose(
      HANDLE hFindFile   // file search handle
    );

    HANDLE FindFirstFile(
      LPCTSTR lpFileName,               // file name
      LPWIN32_FIND_DATA lpFindFileData  // data buffer
    );

    BOOL FindNextFile(
      HANDLE hFindFile,                // search handle 
      LPWIN32_FIND_DATA lpFindFileData // data buffer
    );
    */
    xSetFunctionName(hLog, "FindFile");

    WIN32_FIND_DATA findData;
    HANDLE hFind;
    unsigned i;

    char lpFile1[80];
    char lpFile2[80];


    DWORD time = GetTickCount();

    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("default:\\*")
        {
        sprintf(lpFile1, "%ws:\\*", BASE_DRIVE);
        hFind = FindFirstFile(lpFile1, &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        do
            {
            // TODO verify
            } while(FindNextFile(hFind, &findData) == TRUE);
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("\\x*")
        {
        sprintf(lpFile1, "%ws:\\xFFF_%d.txt", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, FALSE);
        sprintf(lpFile2, "%ws:\\x*", BASE_DRIVE);
        hFind = FindFirstFile(lpFile2, &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        do
            {
            // TODO verify
            } while(FindNextFile(hFind, &findData) == TRUE);
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });
    TESTCASE("\\?*")
        {
        sprintf(lpFile2, "%ws:\\?*", BASE_DRIVE);
        hFind = FindFirstFile(lpFile2, &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        do
            {
            // TODO verify
            } while(FindNextFile(hFind, &findData) == TRUE);
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("one match \\FFF*")
        {
        sprintf(lpFile1, "%ws:\\FFF_%d", BASE_DRIVE, ThreadID);
        sprintf(lpFile2, "%ws:\\FFF_%d*", BASE_DRIVE, ThreadID);
        CreateDirectory(lpFile1, FALSE);
        hFind = FindFirstFile(lpFile2, &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        if(FindNextFile(hFind, &findData) == FALSE)
            TESTPASS(hLog, "FindNextFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindNextFile (ec: %ld)", GetLastError());
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpFile1); });




    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\flushfilebuffers.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    FlushFileBuffers.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the FlushFileBuffers API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::FlushFileBuffers_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL FlushFileBuffers(
      HANDLE hFile  // handle to file
    );
    */
    xSetFunctionName(hLog, "FlushFileBuffers");

    char lpFile[80]; sprintf(lpFile, "%ws:\\FFB01_%d.txt", BASE_DRIVE, ThreadID);
    HANDLE hFile;

    char *wbuffer = new char[MEGABYTE*16];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    DWORD wSize, size;


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Write 0 bytes")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        size = sprintf(wbuffer, "");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write 1 byte")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        size = sprintf(wbuffer, "1");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write 2 bytes")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "69");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write short text")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a FlushFileBuffers() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write long text")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a FlushFileBuffers() API Test!\r\n\r\n"
                "The quick brown fox jumps over the lazy dog\r\n"
                "1234567890\t-=`~!@#$%^&*()_+[]}{\\|';:\"/.,<>?\r\n\r\n"
                "This is a story about Ranet Jeno, the wicked witch from a swamp called DC.\r\n\r\n"
                "(All persons, places, and events are fictitious and bear no resemblance to any living or deceased (past, present, or future) persons, places or events.)\r\n\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write really long text (0.5meg)")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(int i=0; i<8192; i++)
            {
            size += sprintf(wbuffer+size, "Hello World.\r\n\r\nThis is a FlushFileBuffers() API Test!\r\n\r\n");
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write short binary (256b)")
        {
        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<256; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });
    TESTCASE("Write a lot of binary (6meg)")
        {
        BUGGED(958, "Asserts in mu driver");

        hFile = CreateFile(lpFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(size=0; size<6*MEGABYTE; size++)
            {
            wbuffer[size] = (char)size;
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(FlushFileBuffers(hFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile); });



    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    delete[] wbuffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\deletefile.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DeleteFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the DeleteFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::DeleteFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL DeleteFile(
      LPCTSTR lpFileName   // file name
    );
    */
    xSetFunctionName(hLog, "DeleteFile");

    char lpFile1[80];
    unsigned i;

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Existing file \\DeleteFile.txt")
        {
        sprintf(lpFile1, "%ws:\\FDF01_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Existing large file \\DeleteFile_bigfile.txt")
        {
        sprintf(lpFile1, "%ws:\\FDF02_%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1, MEGABYTE*5);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Existing file \\a")
        {
        sprintf(lpFile1, "%ws:\\%d.txt", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1, KILOBYTE);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Existing file 8.3")
        {
        sprintf(lpFile1, "%ws:\\aaaaaa_%d.zzz", BASE_DRIVE, ThreadID);
        CreateFilledFile(lpFile1, 1);
        if(!FileExists(lpFile1))
            {
            BLOCKED(0, "Unable to create initial file");
            }
        if(DeleteFile(lpFile1) == TRUE && !FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;



    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\createdirectory.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CreateDirectory.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the CreateDirectory API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    
*/
DWORD MUTests::CreateDirectory_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL CreateDirectory(
      LPCTSTR lpPathName,                         // directory name
      LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    );
    */
    xSetFunctionName(hLog, "CreateDirectory");

    unsigned i=0;
    char *buffer = new char[65536];
    if(!buffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }


    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FCD01_%d", BASE_DRIVE, ThreadID);
    char lpFile1Sub1[80]; sprintf(lpFile1Sub1, "%ws:\\FCD01_%d\\FCD03_%d", BASE_DRIVE, ThreadID, ThreadID);
    char lpFile1Sub2[80]; sprintf(lpFile1Sub2, "%ws:\\FCD01_%d\\FCD04_%d", BASE_DRIVE, ThreadID, ThreadID);
    //char lpFile2[80]; sprintf(lpFile2, "%ws:\\ CreateDirectory2_%d",  BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws:\\md_%d", BASE_DRIVE, ThreadID);
    char lpTemp[80];

    // initialize system state
    RemoveDirectory(lpFile1Sub1);
    RemoveDirectory(lpFile1Sub1);
    RemoveDirectory(lpFile1);
    //RemoveDirectory(lpFile2);
    RemoveDirectory(lpFile3);


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Creating CreateDirectory")
        {
        if(CreateDirectory(lpFile1, NULL) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        // this directory is used below
        } ENDTESTCASE;
    TESTCASE("Creating CreateSubDirectory")
        {
        if(CreateDirectory(lpFile1Sub1, NULL) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        // this directory is used below
        } ENDTESTCASE;
    /*
    TESTCASE("Creating \"\\ CreateDirectory2\"")
        {
        if(CreateDirectory(lpFile2, NULL) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        // this directory is used below
        } ENDTESTCASE;
    TESTCASE("Creating \\CreateDirectory\\.\\..\\.\\CreateDirectory4")
        {
        // Note this test depends on a directory created above
        if(CreateDirectory(lpFile1Sub2, NULL) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        RemoveDirectory(lpFile1Sub2);
        } ENDTESTCASE;
*/


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    delete[] buffer;

    RemoveDirectory(lpFile1Sub1);
    RemoveDirectory(lpFile1Sub1);
    RemoveDirectory(lpFile1);
    //RemoveDirectory(lpFile2);
    RemoveDirectory(lpFile3);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\getfileinformationbyhandle.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GetFileInformationByHandle.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the GetFileInformationByHandle API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::GetFileInformationByHandle_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL GetFileInformationByHandle(
      HANDLE hFile,                                  // handle to file 
      LPBY_HANDLE_FILE_INFORMATION lpFileInformation // buffer
    );
    */
    xSetFunctionName(hLog, "GetFileInformationByHandle");

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FGI01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\FGI02_%d.txt", BASE_DRIVE, ThreadID);
    unsigned i;

    CreateFilledFile(lpFile1, KILOBYTE);        // below tests rely on the exact file size
    CreateFilledFile(lpFile2, KILOBYTE*124);    // below tests rely on the exact file size

    HANDLE hFile = NULL;
    BY_HANDLE_FILE_INFORMATION fileInfo;

    DWORD time = GetTickCount();



    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("valid file")
        {
        hFile = FileOpen(lpFile1);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to open file");
            }
        if(GetFileInformationByHandle(hFile, &fileInfo) == TRUE && fileInfo.nFileSizeLow == KILOBYTE)
            TESTPASS(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        else
            TESTFAIL(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        } ENDTESTCASE_CLEAN( { CloseHandle(hFile); } );
    TESTCASE("valid file 2")
        {
        hFile = FileOpen(lpFile2);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            BLOCKED(0, "Unable to open file");
            }
        if(GetFileInformationByHandle(hFile, &fileInfo) == TRUE && fileInfo.nFileSizeLow == KILOBYTE*124)
            TESTPASS(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        else
            TESTFAIL(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        } ENDTESTCASE_CLEAN( { CloseHandle(hFile); } );


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\getsetfileattributes.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GetSetFileAttributes.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the GetFileAttributes / SetFileAttributes APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::GetSetFileAttributes_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD GetFileAttributes(
      LPCTSTR lpFileName   // name of file or directory
    );

    BOOL SetFileAttributes(
      LPCTSTR lpFileName,      // file name
      DWORD dwFileAttributes   // attributes
    );

    #define FILE_ATTRIBUTE_READONLY             0x00000001
    #define FILE_ATTRIBUTE_HIDDEN               0x00000002
    #define FILE_ATTRIBUTE_SYSTEM               0x00000004
    #define FILE_ATTRIBUTE_DIRECTORY            0x00000010
    #define FILE_ATTRIBUTE_ARCHIVE              0x00000020
    #define FILE_ATTRIBUTE_DEVICE               0x00000040
    #define FILE_ATTRIBUTE_NORMAL               0x00000080
    #define FILE_ATTRIBUTE_TEMPORARY            0x00000100
    #define FILE_ATTRIBUTE_SPARSE_FILE          0x00000200
    #define FILE_ATTRIBUTE_REPARSE_POINT        0x00000400
    #define FILE_ATTRIBUTE_COMPRESSED           0x00000800
    #define FILE_ATTRIBUTE_OFFLINE              0x00001000
    #define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000
    #define FILE_ATTRIBUTE_ENCRYPTED            0x00004000
    */
    xSetFunctionName(hLog, "SetFileAttributes / GetFileAttributes");

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FFA01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%ws:\\FFA02_%d.txt", BASE_DRIVE, ThreadID);
    char lpDir1[80]; sprintf(lpDir1, "%ws:\\FFA03_%d", BASE_DRIVE, ThreadID);

    CreateFilledFile(lpFile1, KILOBYTE*16);
    CreateDirectory(lpDir1, FALSE);
    SetFileAttributes(lpFile1, FILE_ATTRIBUTE_NORMAL);
    SetFileAttributes(lpDir1, FILE_ATTRIBUTE_NORMAL);

    DWORD sattrib = 0;
    DWORD gattrib = 0;
    unsigned i;


    DWORD time = GetTickCount();



    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("File Set read only")
        {
        sattrib = FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear read only")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("File Set archive")
        {
        sattrib = FILE_ATTRIBUTE_ARCHIVE;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear archive")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("File Set hidden")
        {
        sattrib = FILE_ATTRIBUTE_HIDDEN;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear hidden")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("File Set system")
        {
        sattrib = FILE_ATTRIBUTE_SYSTEM;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear system")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("File Set arhs")
        {
        sattrib = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("File Clear arhs")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_SYSTEM & ~FILE_ATTRIBUTE_HIDDEN & ~FILE_ATTRIBUTE_ARCHIVE & ~FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;

    TESTCASE("Directory Set read only")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear read only")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory Set archive")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_ARCHIVE;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear archive")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_ARCHIVE;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory Set hidden")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_HIDDEN;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear hidden")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_HIDDEN;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory Set system")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_SYSTEM;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear system")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_SYSTEM;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;
    TESTCASE("Directory Set arhs")
        {
        sattrib = GetFileAttributes(lpDir1) | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        // The next test case depends on this test case
        } ENDTESTCASE;
    TESTCASE("Directory Clear arhs")
        {
        // The previous test case depends on this test case
        sattrib = GetFileAttributes(lpDir1) & ~FILE_ATTRIBUTE_SYSTEM & ~FILE_ATTRIBUTE_HIDDEN & ~FILE_ATTRIBUTE_ARCHIVE & ~FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpDir1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpDir1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("SetFileAttributes(missing file, 0)")
        {
        if(SetFileAttributes(lpFakeFile, 0) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("GetFileAttributes(missing file)")
        {
        if(GetFileAttributes(lpFakeFile) == -1)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;




    xSetFunctionName(hLog, "SetFileAttributes / GetFileAttributes");
    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    DeleteFile(lpFile1);
    RemoveDirectory(lpDir1);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\getfilesize.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GetFileSize.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the GetFileSize / GetFileSizeEx APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::GetFileSize_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DWORD GetFileSize(
      HANDLE hFile,           // handle to file
      LPDWORD lpFileSizeHigh  // high-order word of file size
    );

    BOOL GetFileSizeEx(
      HANDLE hFile,              // handle to file
      PLARGE_INTEGER lpFileSize  // file size
    );
    */
    xSetFunctionName(hLog, "GetFileSize");

    HANDLE file = NULL;
    DWORD size;
    DWORD highSize;
    LARGE_INTEGER bigSize;
    bigSize.QuadPart = 0;

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FGS01_%d.txt", BASE_DRIVE, ThreadID);

    DeleteFile(lpFile1);


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("filesize = 0")
        {
        size = 0;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 1")
        {
        size = 1;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 133")
        {
        size = 133;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 16384")
        {
        size = KILOBYTE*16;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("filesize = 3meg")
        {
        size = 3*MEGABYTE;
        highSize = dwBogus;
        CreateFilledFile(lpFile1, size);
        file = FileOpen(lpFile1);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });



    //////////////////////////////////////////////////////////////////////////
    // More successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("new file with nothing written")
        {
        size = 0;
        highSize = dwBogus;
        file = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("new file with some stuff written")
        {
        size = sizeof(DWORD);
        highSize = dwBogus;
        file = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        WriteFile(file, &highSize, size, &highSize, NULL);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });
    TESTCASE("new file with some stuff written and a flush")
        {
        size = sizeof(DWORD);
        highSize = dwBogus;
        file = CreateFile(lpFile1, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        WriteFile(file, &highSize, sizeof(DWORD), &highSize, NULL);
        FlushFileBuffers(file);
        if((highSize=GetFileSize(file, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(file, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(file); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\getvolumeinformation.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GetVolumeInformation.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the GetVolumeInformation API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::GetVolumeInformation_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL GetVolumeInformation(
      LPCTSTR lpRootPathName,           // [in]  root directory
      LPTSTR lpVolumeNameBuffer,        // [out] volume name buffer
      DWORD nVolumeNameSize,            // [in]  length of name buffer
      LPDWORD lpVolumeSerialNumber,     // [out] volume serial number
      LPDWORD lpMaximumComponentLength, // [out] maximum file name length
      LPDWORD lpFileSystemFlags,        // [out] file system options
      LPTSTR lpFileSystemNameBuffer,    // [out] file system name buffer
      DWORD nFileSystemNameSize         // [in]  length of file system name buffer
    );
    */
    xSetFunctionName(hLog, "GetVolumeInformation");

    DWORD serialNum;
    DWORD maxFilename;
    DWORD flags;


    DWORD vnameSize = 128;
    DWORD fsnameSize = 128;
    char vnameBuffer[128];
    char fsnameBuffer[128];
    char lpFile1[80];


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Valid Root Drive")
        {
        sprintf(lpFile1, "%ws:\\", BASE_DRIVE);
        if(GetVolumeInformation(lpFile1, vnameBuffer, vnameSize, &serialNum, &maxFilename, &flags, fsnameBuffer, fsnameSize) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    /*
    TESTCASE("Valid Root Drive (UNC style)")
        {
        sprintf(lpFile1, "\\\\?\\%ws:\\", BASE_DRIVE);
        if(GetVolumeInformation(lpFile1, vnameBuffer, vnameSize, &serialNum, &maxFilename, &flags, fsnameBuffer, fsnameSize) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
*/

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\movefile.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    MoveFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the MoveFile API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::MoveFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL MoveFile(
      LPCTSTR lpExistingFileName, // file name
      LPCTSTR lpNewFileName       // new file name
    );
    */
    xSetFunctionName(hLog, "MoveFile");

    char lpSmallFile[80]; sprintf(lpSmallFile, "%ws:\\FMF01_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%ws:\\FMF02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%ws:\\FMF03_%d.bla", BASE_DRIVE, ThreadID);
    char lpFakeFile2[80]; sprintf(lpFakeFile2, "%ws:\\FMF04_%d.bla", BASE_DRIVE, ThreadID);
    char lpDevice[80]; sprintf(lpDevice, "%ws:\\FMF05_%d.txt", BASE_DRIVE, ThreadID);
    char lpDir1[80]; sprintf(lpDir1, "%ws:\\FMF06_%d", BASE_DRIVE, ThreadID);
    char lpSubFile[80]; sprintf(lpSubFile, "%ws:\\FMF06_%d\\FMF07_%d.txt", BASE_DRIVE, ThreadID, ThreadID);
    char lpFile1[80];
    char lpFile2[80];
    unsigned i;

    // initialize system state
    CreateDirectory(lpDir1, NULL);
    CreateFilledFile(lpSmallFile, KILOBYTE*3);
    CreateFilledFile(lpBigFile, MEGABYTE*2);
    CreateFilledFile(lpSubFile, KILOBYTE*16);


    DWORD time = GetTickCount();



    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(valid file, nonexist)")
        {
        sprintf(lpFile1, "%ws:\\FMF08_%d.txt", BASE_DRIVE, ThreadID);
        if(MoveFile(lpSmallFile, lpFile1) == TRUE && FileExists(lpFile1))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("(valid file, nonexist)")
        {
        // this case relies on the previous test
        if(MoveFile(lpFile1, lpSmallFile) == TRUE && FileExists(lpSmallFile))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(valid dir, nonexist)")
        {
        sprintf(lpFile1, "%ws:\\MoveFileDir2_%d.txt", BASE_DRIVE, ThreadID);
        sprintf(lpFile2, "%ws\\file_%d.txt", lpFile1, ThreadID);
        if(MoveFile(lpDir1, lpFile1) == TRUE && FileExists(lpFile1) && FileExists(lpFile2))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(valid dir, nonexist)")
        {
        if(MoveFile(lpFile1, lpDir1) == TRUE && FileExists(lpDir1) && FileExists(lpSubFile))
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(file1, file1)")
        {
        if(MoveFile(lpSmallFile, lpSmallFile) == TRUE && FileExists(lpSmallFile) )
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("(valid file, existing)")
        {
        if(MoveFile(lpSmallFile, lpBigFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(valid dir, existing)")
        {
        if(MoveFile(lpDir1, lpBigFile) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(nonexist, nonexist)")
        {
        if(MoveFile(lpFakeFile, lpFakeFile2) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("(\\, nonexist)")
        {
        sprintf(lpFile1, "%ws:\\", BASE_DRIVE);
        sprintf(lpFile2, "%ws:\\backup", BASE_DRIVE);
        if(MoveFile(lpFile1, lpFile2) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;
    

   
    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    DeleteFile(lpSubFile);
    RemoveDirectory(lpDir1);
    DeleteFile(lpBigFile);
    DeleteFile(lpSmallFile);
    DeleteFile(lpDevice);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\getsetfiletime.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GetSetFileTime.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the GetFileTime / SetFileTime APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::GetSetFileTime_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL GetFileTime(
      HANDLE hFile,                 // handle to file
      LPFILETIME lpCreationTime,    // creation time
      LPFILETIME lpLastAccessTime,  // last access time
      LPFILETIME lpLastWriteTime    // last write time
    );

    BOOL SetFileTime(
      HANDLE hFile,                     // handle to file
      CONST FILETIME *lpCreationTime,   // creation time
      CONST FILETIME *lpLastAccessTime, // last-access time
      CONST FILETIME *lpLastWriteTime   // last-write time
    );
    */
    xSetFunctionName(hLog, "GetFileTime / SetFileTime");

    unsigned date;
    HANDLE hFile;
    HANDLE hFile2;

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FFT01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\FFT02_%d.txt", BASE_DRIVE, ThreadID);

    FILETIME fileTime[3];
    FILETIME gfileTime[3];

    // initialize system state
    hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    DWORD time = GetTickCount();



    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    for(date=0; date<20; date++)
        {
        TESTCASE("Valid Dates")
            {
            for(unsigned i=0; i<3; i++)
                {
                // just create some different dates
                if(CreateFileTime(&fileTime[i], (25+i) + 1974, date % (9+i) + 1, date % (26+i) + 1, i==1? 0 :(date % (21+i)), i==1? 0 : (date % (55+i)), 0, 0) == FALSE)
                    xLog(hLog, XLL_WARN, "SystemTimeToFileTime Error: %ld", GetLastError());
                }

            if(SetFileTime(hFile, &fileTime[0], &fileTime[1], &fileTime[2]) == TRUE)
                TESTPASS(hLog, "SetFileTime (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "SetFileTime (ec: %ld)", GetLastError());

            if(GetFileTime(hFile, &gfileTime[0], &gfileTime[1], &gfileTime[2]) == TRUE)
                TESTPASS(hLog, "GetFileTime (ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "GetFileTime (ec: %ld)", GetLastError());

            if(memcmp(fileTime, gfileTime, sizeof(FILETIME)*3) == 0)
                {
                SYSTEMTIME sysTime;
                char buffer[256];
                char *t = buffer;

                t += sprintf(t, "Set");
                FileTimeToSystemTime(&fileTime[0], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&fileTime[1], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&fileTime[2], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);

                t += sprintf(t, " == Get");
                FileTimeToSystemTime(&gfileTime[0], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&gfileTime[1], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&gfileTime[2], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                TESTPASS(hLog, buffer);
                }
            else
                {
                SYSTEMTIME sysTime;
                char buffer[256];
                char *t = buffer;

                t += sprintf(t, "Set");
                FileTimeToSystemTime(&fileTime[0], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&fileTime[1], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&fileTime[2], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);

                t += sprintf(t, " != Get");
                FileTimeToSystemTime(&gfileTime[0], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&gfileTime[1], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                FileTimeToSystemTime(&gfileTime[2], &sysTime);
                t += sprintf(t, "(%d/%d/%d %d:%d:%d.%d)", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond, sysTime.wMilliseconds);
                TESTFAIL(hLog, buffer);
                }
            } ENDTESTCASE;
        }



    //////////////////////////////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    CloseHandle(hFile);
    DeleteFile(lpFile1);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\movefilewithprogress.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    MoveFileWithProgress.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

    
*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

static DWORD CALLBACK MoveFileProgressRoutine(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData);


/*

Routine Description:

    Tests the MoveFileWithProgress API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::MoveFileWithProgress_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL MoveFileWithProgress(
      LPCTSTR lpExistingFileName,            // file name
      LPCTSTR lpNewFileName,                 // new file name
      LPPROGRESS_ROUTINE lpProgressRoutine,  // callback function
      LPVOID lpData,                         // parameter for callback
      DWORD dwFlags                          // move options
    );
    */
    xSetFunctionName(hLog, "MoveFileWithProgress");

    char lpSmallFile[80]; sprintf(lpSmallFile, "%ws:\\FMP01_%d.txt", BASE_DRIVE, ThreadID);
    char lpBigFile[80]; sprintf(lpBigFile, "%ws:\\FMP02_%d.txt", BASE_DRIVE, ThreadID);
    char lpExtraBigFile[80]; sprintf(lpExtraBigFile, "%ws:\\FMP03_%d.txt", BASE_DRIVE, ThreadID);
    char lpFakeFile[80]; sprintf(lpFakeFile, "%ws:\\FMP04_%d.bla", BASE_DRIVE, ThreadID);
    char lpFakeFile2[80]; sprintf(lpFakeFile2, "%ws:\\FMP05_%d.bla", BASE_DRIVE, ThreadID);
    char lpDevice[80]; sprintf(lpDevice, "%ws:\\FMP06_%d.txt", BASE_DRIVE, ThreadID);
    char lpDir1[80]; sprintf(lpDir1, "%ws:\\FMP07_%d", BASE_DRIVE, ThreadID);
    char lpSubFile[80]; sprintf(lpSubFile, "%ws:\\FMP07_%d\\FMP08_%d.txt", BASE_DRIVE, ThreadID, ThreadID);
    char lpFile1[80];
    char lpFile2[80];
    unsigned i;

    // initialize system state
    CreateDirectory(lpDir1, NULL);
    CreateFilledFile(lpSmallFile, KILOBYTE*2);
    CreateFilledFile(lpBigFile, MEGABYTE*2);
    CreateFilledFile(lpExtraBigFile, MEGABYTE*3);
    CreateFilledFile(lpSubFile, KILOBYTE*16);


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Small file replace")
        {
        sprintf(lpFile1, "%ws:\\FMP09_%d.txt", BASE_DRIVE, ThreadID);

        if(MoveFileWithProgress(lpSmallFile, lpFile1, MoveFileProgressRoutine, hLog, MOVEFILE_REPLACE_EXISTING) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("Small file")
        {
        // this case relies on the previous test
        if(MoveFileWithProgress(lpFile1, lpSmallFile, MoveFileProgressRoutine, hLog, 0) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpSmallFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Big file replace")
        {
        sprintf(lpFile1, "%ws:\\FMP09_%d.txt", BASE_DRIVE, ThreadID);

        if(MoveFileWithProgress(lpBigFile, lpFile1, MoveFileProgressRoutine, hLog, MOVEFILE_REPLACE_EXISTING) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("Big file")
        {
        // this case relies on the previous test
        if(MoveFileWithProgress(lpFile1, lpBigFile, MoveFileProgressRoutine, hLog, 0) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpBigFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE;
    TESTCASE("Extra Big file replace")
        {
        sprintf(lpFile1, "%ws:\\FMP09_%d.txt", BASE_DRIVE, ThreadID);

        if(MoveFileWithProgress(lpExtraBigFile, lpFile1, MoveFileProgressRoutine, hLog, MOVEFILE_REPLACE_EXISTING) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpFile1) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        // the next case relies on this one
        } ENDTESTCASE;
    TESTCASE("Extra Big file w/write through")
        {
        // this case relies on the previous test
        if(MoveFileWithProgress(lpFile1, lpExtraBigFile, MoveFileProgressRoutine, hLog, MOVEFILE_WRITE_THROUGH) == TRUE)
            TESTPASS(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "MoveFileWithProgress (ec: %ld)", GetLastError());

        if(FileExists(lpExtraBigFile) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "File doesn't exist (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    DeleteFile(lpSubFile);
    RemoveDirectory(lpDir1);
    DeleteFile(lpBigFile);
    DeleteFile(lpExtraBigFile);
    DeleteFile(lpSmallFile);
    DeleteFile(lpDevice);

    return 0;
    }

/*

Routine Description:

    Callback function used with the CopyFileEx and MoveFileWithProgress functions
    See "CopyProgressRoutine" in MSDN

Arguments:

    LARGE_INTEGER TotalFileSize          - file size
    LARGE_INTEGER TotalBytesTransferred  - bytes transferred
    LARGE_INTEGER StreamSize             - bytes in stream
    LARGE_INTEGER StreamBytesTransferred - bytes transferred for stream
    DWORD dwStreamNumber                 - current stream
    DWORD dwCallbackReason               - callback reason
    HANDLE hSourceFile                   - handle to source file
    HANDLE hDestinationFile              - handle to destination file
    LPVOID lpData                        - user data, HANDLE to XLOG object

Return Value:

    PROGRESS_CONTINUE, PROGRESS_STOP, or PROGRESS_CANCEL

*/
static DWORD CALLBACK MoveFileProgressRoutine(LARGE_INTEGER TotalFileSize, LARGE_INTEGER TotalBytesTransferred, LARGE_INTEGER StreamSize, LARGE_INTEGER StreamBytesTransferred, DWORD dwStreamNumber, DWORD dwCallbackReason, HANDLE hSourceFile, HANDLE hDestinationFile, LPVOID lpData)
    {
    HANDLE hLog = (HANDLE)lpData;

    xLog(hLog, XLL_INFO, "%I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);

    if(TotalBytesTransferred.QuadPart > TotalFileSize.QuadPart)
        {
        xLog(hLog, XLL_FAIL, "Transfered more than filesize: %I64d of %I64d", TotalBytesTransferred.QuadPart, TotalFileSize.QuadPart);
        }

    if(TotalFileSize.QuadPart == TotalBytesTransferred.QuadPart)
        {
        }

    return PROGRESS_CONTINUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\mucmd.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ReadWriteFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the ReadFile / WriteFile APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::MUCommand_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReadFile(
      HANDLE hFile,                // handle to file
      LPVOID lpBuffer,             // data buffer
      DWORD nNumberOfBytesToRead,  // number of bytes to read
      LPDWORD lpNumberOfBytesRead, // number of bytes read
      LPOVERLAPPED lpOverlapped    // overlapped buffer
    );

    BOOL WriteFile(
      HANDLE hFile,                    // handle to file
      LPCVOID lpBuffer,                // data buffer
      DWORD nNumberOfBytesToWrite,     // number of bytes to write
      LPDWORD lpNumberOfBytesWritten,  // number of bytes written
      LPOVERLAPPED lpOverlapped        // overlapped buffer
    );
    */
    xSetFunctionName(hLog, "ReadFile / WriteFile");

    char *wbuffer = new char[MEGABYTE*1];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    char *rbuffer = new char[MEGABYTE*1];
    if(!rbuffer)
        {
        delete[] wbuffer;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\MUCMDFile1_%d.txt", BASE_DRIVE, ThreadID);

    HANDLE hFile = NULL;

    DWORD wSize, rSize, size;

    // initialize state
    DeleteFile(lpFile1);

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("MU Command 1")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        char data[] = "\x55\x53\x42\x43\x88\x1A\x18\xD1\x08\x00\x00\x00\x80\x00\x0A\x25\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
        size = sizeof(data)-1;
        memcpy(wbuffer, data, sizeof(data));
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });

    TESTCASE("MU Command 2")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        char data[] = "\x55\x53\x42\x43\x48\xCF\x19\xD1\x00\x10\x00\x00\x80\x00\x0A\x28\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00";
        size = sizeof(data)-1;
        memcpy(wbuffer, data, sizeof(data));
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });

    TESTCASE("MU Command 3")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        char data[] = "\x55\x53\x42\x53\x88\x1A\x18\xD1\x00\x00\x00\x00\x00";
        size = sizeof(data)-1;
        memcpy(wbuffer, data, sizeof(data));
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });

    TESTCASE("MU Command 4")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        char data[] = "\x00\x00\x3E\xFF\x00\x00\x02\x00";
        size = sizeof(data)-1;
        memcpy(wbuffer, data, sizeof(data));
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });


    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    delete[] wbuffer;
    delete[] rbuffer;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\mutests.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mutests.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/

typedef DWORD (*APITEST_FUNC)(HANDLE hLog, DWORD ThreadID);

//
//  MU Tests
//
namespace MUTests
    {
    extern DWORD CopyFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD CopyFileEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD CreateDirectory_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD CreateFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD DeleteFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD FindFile_Test(HANDLE hLog, DWORD ThreadID);
    //extern DWORD FindFirstFileEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD FlushFileBuffers_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetDiskFreeSpaceEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetDriveType_Test(HANDLE hLog, DWORD ThreadID);
    //extern DWORD GetFileAttributesEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetFileInformationByHandle_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetFileSize_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetLogicalDrives_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetSetFileAttributes_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetSetFileTime_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD GetVolumeInformation_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD MoveFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD MoveFileWithProgress_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD MUCommand_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD ReadWriteFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD ReadWriteFileEx_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD ReadWriteFileGatherScatter_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD RemoveDirectory_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD ReplaceFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD SetEndOfFile_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD SetFilePointer_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD SetFilePointerEx_Test(HANDLE hLog, DWORD ThreadID);

    extern DWORD HardDriveFull_Test(HANDLE hLog, DWORD ThreadID);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\mutests.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mutests.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xtestlib.h>
#include <xlog.h>
#include "mutests.h"
#include "commontest.h"
#include "utils.h"
#include "usbmanager.h"


//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

static ULONG ThreadID = 0;

WCHAR MUTests::BASE_DRIVE[5];

//
// Heap handle from HeapCreate
//
HANDLE MuTestHeapHandle;


BOOL WINAPI MuTestDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        MuTestHeapHandle = HeapCreate(0, 0, 0);

        if(!MuTestHeapHandle)
            {
            OutputDebugString(L"MUTESTS: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(MuTestHeapHandle)
            {
            HeapDestroy(MuTestHeapHandle);
            }
        }

    return TRUE;
    }

static bool wcistrstr(WCHAR *string, WCHAR *substr, size_t len=0)
    {
    if(!string || ! substr) return false;
    if(!*string) return false;
    if(!len) len = wcslen(substr);
    if(_wcsnicmp(string, substr, len) == 0) return true;

    return wcistrstr(string+1, substr, len);
    }

/*

Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    DWORD threadNumber - sequential number of the thread
    DWORD loops - # of times to run test
    WCHAR* testname - specific name of a test to run

Return Value:

    DWORD

*/
namespace MUTests {
static DWORD RunAll(HANDLE hLog, DWORD threadNumber, DWORD loops, WCHAR *testname)
    {
    Sleep(threadNumber*200); // stagger the thread's execution a bit

    struct APIFUNCT
        {
        APITEST_FUNC f;
        WCHAR *name;
        };
    #define BUILTAPISTRUCT(n) { n , L#n }


    // Define all the API tests
    APIFUNCT testlist[] =
        {
        /*
        */
        BUILTAPISTRUCT(MUTests::CopyFile_Test),
        BUILTAPISTRUCT(MUTests::CopyFileEx_Test),
        BUILTAPISTRUCT(MUTests::CreateDirectory_Test),
        BUILTAPISTRUCT(MUTests::CreateFile_Test),
        BUILTAPISTRUCT(MUTests::DeleteFile_Test),
        BUILTAPISTRUCT(MUTests::FindFile_Test),
        BUILTAPISTRUCT(MUTests::FlushFileBuffers_Test),
        BUILTAPISTRUCT(MUTests::GetFileInformationByHandle_Test),
        BUILTAPISTRUCT(MUTests::GetFileSize_Test),
        BUILTAPISTRUCT(MUTests::GetSetFileAttributes_Test),
        BUILTAPISTRUCT(MUTests::GetSetFileTime_Test),
        BUILTAPISTRUCT(MUTests::GetVolumeInformation_Test),
        BUILTAPISTRUCT(MUTests::MoveFile_Test),
        BUILTAPISTRUCT(MUTests::MoveFileWithProgress_Test),
        BUILTAPISTRUCT(MUTests::MUCommand_Test),
        BUILTAPISTRUCT(MUTests::ReadWriteFile_Test),
        BUILTAPISTRUCT(MUTests::ReadWriteFileEx_Test),
        BUILTAPISTRUCT(MUTests::ReadWriteFileGatherScatter_Test),
        BUILTAPISTRUCT(MUTests::RemoveDirectory_Test),
        BUILTAPISTRUCT(MUTests::SetEndOfFile_Test),
        BUILTAPISTRUCT(MUTests::SetFilePointerEx_Test),
        BUILTAPISTRUCT(MUTests::HardDriveFull_Test),
        /*
        */
        };

    bool runAll = _wcsicmp(testname, L"(all)") == 0 ? true : false;
    USBManager *usbmanager = new USBManager;
    if(!usbmanager) return 0;


    // Run the suite of tests
    for(DWORD i=0; i<loops; i++)
        {
        // run each test
        for(unsigned j=0; j<ARRAYSIZE(testlist); j++)
            {
            if(runAll || wcistrstr(testlist[j].name, testname))
                {
                xLog(hLog, XLL_INFO, "%ws() ******************************************", testlist[j].name);
                usbmanager->CheckForHotplugs();
                LogResourceStatus(hLog, false);
                DebugPrint("MUTESTS(%d): Entering %ws()\n", threadNumber, testlist[j].name);
                testlist[j].f(hLog, threadNumber);
                }
            }
        }

    delete usbmanager;
    return 0;
    }
} // namespace MUTests



/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI MuTestStartTest(HANDLE hLog)
    {
    DWORD ID = 0;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &ThreadID);


    // test settings
    const int buffLen = 1024;
    WCHAR testname[buffLen];
    DWORD loops;



    // Pull out internal INI file settings
    GetProfileString(L"mutests", L"testname", L"(all)", testname, buffLen);
    GetProfileString(L"mutests", L"drive", L"F", MUTests::BASE_DRIVE, 5);
    loops = GetProfileInt(L"mutests", L"loops", 1);

    DebugPrint("  drive=%s\n", MUTests::BASE_DRIVE);

    MUTests::BASE_DRIVE[0] = MUTests::BASE_DRIVE[0] + (unsigned short)ID - 1;
    MUTests::BASE_DRIVE[1] += L'\0';

    xSetOwnerAlias(hLog, "jpoley");
    xSetComponent(hLog, "Device Driver", "MU");
    DebugPrint("MUTESTS(%d): **************************************************************\n", ID);
    DebugPrint("MUTESTS(%d): Entering StartTest()\n", ID);
    DebugPrint("MUTESTS(%d): Internal INI Settings:\n", ID);
    DebugPrint("  loops=%lu\n", loops);
    DebugPrint("  testname=%ws\n", testname);
    DebugPrint("  drive=%ws\n", MUTests::BASE_DRIVE);
    DebugPrint("MUTESTS(%d): **************************************************************\n", ID);


    switch(ID)
        {
        case 0:
        case 1:
        default:
            MUTests::RunAll(hLog, ID, loops, testname);
            break;
        }

    DebugPrint("MUTESTS(%d): **************************************************************\n", ID);
    DebugPrint("MUTESTS(%d): Leaving StartTest()\n", ID);
    DebugPrint("MUTESTS(%d): **************************************************************\n", ID);
    xSetOwnerAlias(hLog, NULL);
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI MuTestEndTest(void)
    {
    ThreadID = 0;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( mutests )
#pragma data_seg()

BEGIN_EXPORT_TABLE( mutests )
    EXPORT_TABLE_ENTRY( "StartTest", MuTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MuTestEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", MuTestDllMain )
END_EXPORT_TABLE( mutests )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\harddrivefull.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    HardDriveFull.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests a bunch of APIs while the Hard Drive is full

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::HardDriveFull_Test(HANDLE hLog, DWORD ThreadID)
    {
    char drive[5]; sprintf(drive, "%ws:\\", BASE_DRIVE);
    char lpBaseDirectory[80]; sprintf(lpBaseDirectory, "%wsFHD_%d", drive, ThreadID);
    char lpFile1[80]; sprintf(lpFile1, "%ws\\FHD01_%d.txt", lpBaseDirectory, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws\\FHD02_%d.txt", lpBaseDirectory, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws\\FHD03_%d.txt", lpBaseDirectory, ThreadID);
    char lpTempFile1[80]; sprintf(lpTempFile1, "%ws\\FHD04_%d.txt", lpBaseDirectory, ThreadID);
    char lpTempFile2[80]; sprintf(lpTempFile2, "%ws\\FHD05_%d.txt", lpBaseDirectory, ThreadID);
    char lpTempFile3[80]; sprintf(lpTempFile3, "%ws\\FHD06_%d.txt", lpBaseDirectory, ThreadID);
    char lpFillHDFile[80];
    char lpTemp[80];

    HANDLE hFile;
    char *wbuffer=NULL;
    char *rbuffer=NULL;

    // initialize system state
    CreateDirectory(lpBaseDirectory, NULL);
    CreateFilledFile(lpFile1, KILOBYTE*16);       // GetFileSize test below relies on this file being 16k
    CreateFilledFile(lpFile2, MEGABYTE*2);
    CreateFilledFile(lpFile3, MEGABYTE*2);

    // Fill up the HD
    FillHDPartition(drive, lpFillHDFile);

    DWORD time = GetTickCount();

    xSetFunctionName(hLog, "GetDiskFreeSpaceEx");
    TESTCASE("Full HardDrive")
        {
        ULARGE_INTEGER available;
        ULARGE_INTEGER total;
        ULARGE_INTEGER free;
        available = total = free = ulBogus;

        if(GetDiskFreeSpaceEx(drive, &available, &total, &free) == TRUE && available.QuadPart < total.QuadPart && available.QuadPart != ulBogus.QuadPart)
            TESTPASS(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);
        else
            TESTFAIL(hLog, "(ec: %ld) avail:%I64x total:%I64x", GetLastError(), available.QuadPart, total.QuadPart);

        if(available.QuadPart != 0)
            xLog(hLog, XLL_WARN, "Hard Drive is not full! The next set of tests will FAIL.");
        } ENDTESTCASE;


    xSetFunctionName(hLog, "CopyFile");
    TESTCASE("Full HardDrive")
        {
        if(CopyFile(lpFile1, lpTempFile1, TRUE) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        if(FileExists(lpFile1) && ! FileExists(lpTempFile1))
            TESTPASS(hLog, "Checking file existance (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Checking file existance (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    xSetFunctionName(hLog, "MoveFile");
    TESTCASE("Full HardDrive")
        {
        if(MoveFile(lpFile1, lpTempFile1) == TRUE)
            TESTPASS(hLog, "Move 1 (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Move 1 (ec: %ld)", GetLastError());

        if(!FileExists(lpFile1) && FileExists(lpTempFile1))
            TESTPASS(hLog, "Checking file existance (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Checking file existance (ec: %ld)", GetLastError());

        if(MoveFile(lpTempFile1, lpFile1) == TRUE)
            TESTPASS(hLog, "Move 2 (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Move 2 (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    xSetFunctionName(hLog, "CreateDirectory");
    TESTCASE("Full HardDrive")
        {
        sprintf(lpTemp, "%ws:\\FHD07", BASE_DRIVE);
        if(CreateDirectory(lpTemp, NULL) == FALSE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());

        } ENDTESTCASE_CLEAN({ RemoveDirectory(lpTemp); });


    // create a new file, and try to write to it
    xSetFunctionName(hLog, "CreateFile");
    TESTCASE("Full HardDrive")
        {
        hFile = CreateFile(lpTempFile1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "Open new file (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Open new file (ec: %ld)", GetLastError());

        DWORD size = 15*KILOBYTE;
        xSetFunctionName(hLog, "SetFilePointer");
        if((size=SetFilePointer(hFile, size, NULL, FILE_BEGIN)) == INVALID_SET_FILE_POINTER)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", size, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", size, GetLastError());

        char w = 'X';
        DWORD wsize = sizeof(w);
        xSetFunctionName(hLog, "WriteFile");
        if(WriteFile(hFile, &w, wsize, &wsize, NULL) != TRUE)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wsize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wsize, GetLastError());

        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpTempFile1); });


    // read and write from inside an existing file
    xSetFunctionName(hLog, "CreateFile");
    TESTCASE("Full HardDrive")
        {
        DWORD wSize, rSize, size;
        DWORD seek;

        wbuffer = new char[MEGABYTE*1];
        if(!wbuffer)
            {
            BLOCKED(0, "Unable to allocate memory");
            }
        rbuffer = new char[MEGABYTE*24];
        if(!rbuffer)
            {
            delete[] wbuffer;
            wbuffer = NULL;
            BLOCKED(0, "Unable to allocate memory");
            }

        hFile = CreateFile(lpFile3, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "Open existing file (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "Open existing file (ec: %ld)", GetLastError());

        seek = 11*KILOBYTE;
        xSetFunctionName(hLog, "SetFilePointer");
        if((seek=SetFilePointer(hFile, seek, NULL, FILE_BEGIN)) == 11*KILOBYTE)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        xSetFunctionName(hLog, "WriteFile");
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        seek = 11*KILOBYTE;
        xSetFunctionName(hLog, "SetFilePointer");
        if((seek=SetFilePointer(hFile, seek, NULL, FILE_BEGIN)) == 11*KILOBYTE)
            TESTPASS(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());
        else
            TESTFAIL(hLog, "Seek[%d] (ec: %ld)", seek, GetLastError());

        xSetFunctionName(hLog, "ReadFile");
        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);

        } ENDTESTCASE_CLEAN({ if(wbuffer) delete[] wbuffer; if(rbuffer) delete[] rbuffer; CloseHandle(hFile); });


    xSetFunctionName(hLog, "GetVolumeInformation");
    TESTCASE("Full HardDrive")
        {
        DWORD vnameSize = 128;
        DWORD fsnameSize = 128;
        char vnameBuffer[128];
        char fsnameBuffer[128];
        DWORD serialNum;
        DWORD maxFilename;
        DWORD flags;
        if(GetVolumeInformation(drive, vnameBuffer, vnameSize, &serialNum, &maxFilename, &flags, fsnameBuffer, fsnameSize) == TRUE)
            TESTPASS(hLog, "(ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "(ec: %ld)", GetLastError());
        } ENDTESTCASE;


    xSetFunctionName(hLog, "SetFileAttributes / GetFileAttributes");
    TESTCASE("Full HardDrive")
        {
        DWORD sattrib = 0;
        DWORD gattrib = 0;
        sattrib = FILE_ATTRIBUTE_READONLY;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());

        sattrib = GetFileAttributes(lpFile1) & ~FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_NORMAL;
        if(SetFileAttributes(lpFile1, sattrib) == TRUE && (gattrib=GetFileAttributes(lpFile1)) == sattrib)
            TESTPASS(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        else
            TESTFAIL(hLog, "set(0x%X) get(0x%X) (ec: %ld)", sattrib, gattrib, GetLastError());
        } ENDTESTCASE;


    xSetFunctionName(hLog, "GetFileSize");
    TESTCASE("Full HardDrive")
        {
        DWORD size = KILOBYTE*16;
        DWORD highSize = 0;
        LARGE_INTEGER bigSize;
        bigSize.QuadPart = 0;
        hFile = FileOpen(lpFile1);
        if((highSize=GetFileSize(hFile, &highSize)) == size)
            TESTPASS(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSize=%ld (ec: %ld)", highSize, GetLastError());

        if(GetFileSizeEx(hFile, &bigSize) == TRUE && bigSize.QuadPart == size)
            TESTPASS(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        else
            TESTFAIL(hLog, "GetFileSizeEx=%I64d (ec: %ld)", bigSize.QuadPart, GetLastError());
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); });


    xSetFunctionName(hLog, "GetFileInformationByHandle");
    TESTCASE("Full HardDrive")
        {
        BY_HANDLE_FILE_INFORMATION fileInfo;
        hFile = FileOpen(lpFile1);
        if(GetFileInformationByHandle(hFile, &fileInfo) == TRUE && fileInfo.nFileSizeLow == KILOBYTE*16)
            TESTPASS(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        else
            TESTFAIL(hLog, "(ec: %ld) filesize: %ld", GetLastError(), fileInfo.nFileSizeLow);
        } ENDTESTCASE_CLEAN( { CloseHandle(hFile); } );


    xSetFunctionName(hLog, "FindFile");
    TESTCASE("Full HardDrive")
        {
        sprintf(lpTemp, "%ws:\\*", BASE_DRIVE);
        WIN32_FIND_DATA findData;
        HANDLE hFind = FindFirstFile(lpTemp, &findData);
        if(hFind != INVALID_HANDLE_VALUE)
            TESTPASS(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindFirstFile (ec: %ld)", GetLastError());
        do
            {
            // TODO verify
            } while(FindNextFile(hFind, &findData) == TRUE);
        if(FindClose(hFind) != FALSE)
            TESTPASS(hLog, "FindClose (ec: %ld)", GetLastError());
        else
            TESTFAIL(hLog, "FindClose (ec: %ld)", GetLastError());
        } ENDTESTCASE;


    // TODO
        // Get/SetFileTime

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    xSetFunctionName(hLog, "(hd full tests)");
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;

    // unfill the HD
    DeleteFile(lpFillHDFile);

    // clean up
    DeleteFile(lpFile1);
    DeleteFile(lpFile3);
    DeleteFile(lpFile2);
    DeleteFile(lpTempFile1);
    DeleteFile(lpTempFile3);
    DeleteFile(lpTempFile2);
    RemoveDirectory(lpBaseDirectory);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\readwritefilegatherscatter.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ReadWriteFileGatherScatter.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include <winioctl.h>
#include "commontest.h"
#include "mutests.h"

static void SerializeTest(HANDLE hLog, char *variation, char* filename, DWORD size);
static void FillBuffer(FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD size);
static BOOL CompareBuffer(FILE_SEGMENT_ELEMENT *aSegmentArray, FILE_SEGMENT_ELEMENT *bSegmentArray, DWORD size);

static FILE_SEGMENT_ELEMENT *rpages;
static FILE_SEGMENT_ELEMENT *wpages;

/*

Routine Description:

    Tests the ReadFileScatter / WriteFileGather APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::ReadWriteFileGatherScatter_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReadFileScatter(
      HANDLE hFile,                          // handle to file 
      FILE_SEGMENT_ELEMENT aSegmentArray[ ], // array of buffer pointers
      DWORD nNumberOfBytesToRead,            // number of bytes to read
      LPDWORD lpReserved,                    // reserved; must be NULL
      LPOVERLAPPED lpOverlapped              // OVERLAPPED structure
    );

    BOOL WriteFileGather(
      HANDLE hFile,                          // handle to file
      FILE_SEGMENT_ELEMENT aSegmentArray[ ], // array of buffer pointers
      DWORD nNumberOfBytesToWrite,           // number of bytes to write
      LPDWORD lpReserved,                    // reserved; must be NULL
      LPOVERLAPPED lpOverlapped              // overlapped buffer
    );
    */
    xSetFunctionName(hLog, "ReadFileScatter/WriteFileGather");

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FSG01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\FSG02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws:\\FSG03_%d.txt", BASE_DRIVE, ThreadID);

    HANDLE hFile = NULL;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;

    DWORD size;
    const size_t NUM_PAGES = 4000;
    size_t page;

    // Get the sector size
    char drivestuff[5];
    sprintf(drivestuff, "%s:\\", BASE_DRIVE);
    DWORD bytesPerSector = XGetDiskSectorSize(drivestuff);
    xLog(hLog, XLL_INFO, "BytesPerSector=   %lu", bytesPerSector);


    // Allocate the pages
    rpages = new FILE_SEGMENT_ELEMENT[NUM_PAGES];
    if(!rpages)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        DebugPrint("MUTESTS: Unable to allocate memory, all tests skipped\n");
        return -1;
        }
    wpages = new FILE_SEGMENT_ELEMENT[NUM_PAGES];
    if(!wpages)
        {
        delete[] rpages;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        DebugPrint("MUTESTS: Unable to allocate memory, all tests skipped\n");
        return -1;
        }
    for(page=0; page<NUM_PAGES; page++)
        {
        rpages[page].Buffer = VirtualAlloc(NULL, PAGESIZE, MEM_COMMIT, PAGE_READWRITE);
        wpages[page].Buffer = VirtualAlloc(NULL, PAGESIZE, MEM_COMMIT, PAGE_READWRITE);
        if(!rpages[page].Buffer || !wpages[page].Buffer)
            {
            for(page=0; page<NUM_PAGES; page++)
                {
                VirtualFree(rpages[page].Buffer, 0, MEM_RELEASE);
                VirtualFree(wpages[page].Buffer, 0, MEM_RELEASE);
                }
            delete[] rpages;
            delete[] wpages;
            xStartVariation(hLog, "Initializing State");
            xLog(hLog, XLL_BLOCK, "Unable to VirtualAlloc memory, all tests skipped");
            xEndVariation(hLog);
            DebugPrint("MUTESTS: Unable to allocate memory, all tests skipped\n");
            return -1;
            }
        }


    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////

    // smallest block
    size = 1*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 1 sector size", lpFile1, size);

    // next smallest block
    size = 2*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 2 sector sizes", lpFile1, size);

    // 1 below standard page size (assuming 512 sector size)
    size = 7*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 7 sector sizes", lpFile1, size);

    // page size
    size = PAGESIZE;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write PAGESIZE", lpFile1, size);

    // one above
    size = 9*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 9 sector sizes", lpFile1, size);

    // unnatural number
    size = 11*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 11 sector sizes", lpFile1, size);

    /*
    TESTCASE("Read/Write many sector sizes")
        {
        BUGGED(928, "ASSERTS in OS");
        } ENDTESTCASE;
    */

    // medium file
    size = 1024*bytesPerSector;
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 1024 sector sizes", lpFile1, size);

    // big sized file
    size = 1536*bytesPerSector; 
    FillBuffer(wpages, size);
    SerializeTest(hLog, "Read/Write 1536 sector sizes", lpFile1, size);



    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    // clean up
    for(page=0; page<NUM_PAGES; page++)
        {
        VirtualFree(rpages[page].Buffer, 0, MEM_RELEASE);
        VirtualFree(wpages[page].Buffer, 0, MEM_RELEASE);
        }
    delete[] rpages;
    delete[] wpages;

    return 0;
    }

static void SerializeTest(HANDLE hLog, char *variation, char* filename, DWORD size)
    {
    HANDLE hFile;
    OVERLAPPED overlap = {0, 0, 0, 0, 0};
    DWORD rSize, wSize;
    DWORD numPages = size/PAGESIZE+1;
    DWORD opTime, waitTime;
    DWORD error;

    FILE_SEGMENT_ELEMENT temp = wpages[numPages];
    wpages[numPages].Buffer = NULL;

    TESTCASE(variation)
        {
        //DebugPrint("%s\n", variation);
        hFile = CreateFile(filename, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            char wbuffer[1024];
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        // write the test data
        opTime = GetTickCount();
        if(WriteFileGather(hFile, wpages, size, NULL, &overlap) == FALSE && ((error=GetLastError()) == ERROR_IO_PENDING))
            TESTPASS(hLog, "WriteFileGather (ec: %ld)", error);
        else
            TESTFAIL(hLog, "WriteFileGather (ec: %ld)", error);
        opTime = GetTickCount()-opTime;

        // wait for the IO to complete
        waitTime = GetTickCount();
        if(GetOverlappedResult(hFile, &overlap, &wSize, (error==ERROR_IO_PENDING?TRUE:FALSE)) == TRUE)
            TESTPASS(hLog, "GetOverlappedResult[%ld] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "GetOverlappedResult[%ld] (ec: %ld)", wSize, GetLastError());
        waitTime = GetTickCount()-waitTime;

        if(opTime > 2*waitTime)
            TESTFAIL(hLog, "Operation took longer than 2*wait: %lu, %lu", opTime, waitTime);

        // read the data back
        opTime = GetTickCount();
        if(ReadFileScatter(hFile, rpages, size, NULL, &overlap) == FALSE && ((error=GetLastError()) == ERROR_IO_PENDING))
            TESTPASS(hLog, "ReadFileScatter (ec: %ld)", error);
        else
            TESTFAIL(hLog, "ReadFileScatter (ec: %ld)", error);
        opTime = GetTickCount()-opTime;

        // wait for the IO to complete
        waitTime = GetTickCount();
        if(GetOverlappedResult(hFile, &overlap, &rSize, (error==ERROR_IO_PENDING?TRUE:FALSE)) == TRUE)
            TESTPASS(hLog, "GetOverlappedResult[%ld] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "GetOverlappedResult[%ld] (ec: %ld)", rSize, GetLastError());
        waitTime = GetTickCount()-waitTime;

        if(opTime > 2*waitTime)
            TESTFAIL(hLog, "Operation took longer than 2*wait: %lu, %lu", opTime, waitTime);

        // compare the 2 buffers
        if(!(rSize == size && wSize == size))
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        else if(CompareBuffer(wpages, rpages, size) == FALSE)
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        else
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);

        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(filename); });
    
    wpages[numPages] = temp;
    }


/*

Routine Description:

    Fills an array of buffers with data making sure data between calls is different

Arguments:

    FILE_SEGMENT_ELEMENT *aSegmentArray - array of buffers, each ptr must be 1 PAGESIZE
    DWORD size - total number of bytes to write

Return Value:

    none

*/
static void FillBuffer(FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD size)
    {
    static bool hilo=false; // so we put different data in the buffer each time we use it
    for(DWORD i=0; i<size; i++)
        {

        ((char*)aSegmentArray[i/PAGESIZE].Buffer)[i%PAGESIZE] = (char) (hilo?i:~i);
        }
    hilo = !hilo;
    }

/*

Routine Description:

    Compares two buffer arrays

Arguments:

    FILE_SEGMENT_ELEMENT *aSegmentArray - array of buffers, each ptr must be 1 PAGESIZE
    FILE_SEGMENT_ELEMENT *bSegmentArray - array of buffers, each ptr must be 1 PAGESIZE
    DWORD size - total size of the data

Return Value:

    TRUE if they are ==
    FALSE if they are !=

*/
static BOOL CompareBuffer(FILE_SEGMENT_ELEMENT *aSegmentArray, FILE_SEGMENT_ELEMENT *bSegmentArray, DWORD size)
    {
    DWORD s;
    for(DWORD i=0; i<size; i+=PAGESIZE)
        {
        if(i + PAGESIZE > size) s = size - i;
        else s = PAGESIZE;

        if(memcmp(aSegmentArray[i/PAGESIZE].Buffer, bSegmentArray[i/PAGESIZE].Buffer, s) != 0) return FALSE;
        }

    return TRUE;
    }


/*
    TODO 
        Read() off of DVD (different sector size)
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

/*
#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif
*/



// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>



#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
{
ULONG DebugPrint(PCHAR Format, ...);
}


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\USB\mutests\readwritefile.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ReadWriteFile.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "mutests.h"

/*

Routine Description:

    Tests the ReadFile / WriteFile APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    

*/
DWORD MUTests::ReadWriteFile_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    BOOL ReadFile(
      HANDLE hFile,                // handle to file
      LPVOID lpBuffer,             // data buffer
      DWORD nNumberOfBytesToRead,  // number of bytes to read
      LPDWORD lpNumberOfBytesRead, // number of bytes read
      LPOVERLAPPED lpOverlapped    // overlapped buffer
    );

    BOOL WriteFile(
      HANDLE hFile,                    // handle to file
      LPCVOID lpBuffer,                // data buffer
      DWORD nNumberOfBytesToWrite,     // number of bytes to write
      LPDWORD lpNumberOfBytesWritten,  // number of bytes written
      LPOVERLAPPED lpOverlapped        // overlapped buffer
    );
    */
    xSetFunctionName(hLog, "ReadFile / WriteFile");

    char *wbuffer = new char[MEGABYTE*10];
    if(!wbuffer)
        {
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }
    char *rbuffer = new char[MEGABYTE*10];
    if(!rbuffer)
        {
        delete[] wbuffer;
        xStartVariation(hLog, "Initializing State");
        xLog(hLog, XLL_BLOCK, "Unable to allocate memory, all tests skipped");
        xEndVariation(hLog);
        return -1;
        }

    char lpFile1[80]; sprintf(lpFile1, "%ws:\\FRW01_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile2[80]; sprintf(lpFile2, "%ws:\\FRW02_%d.txt", BASE_DRIVE, ThreadID);
    char lpFile3[80]; sprintf(lpFile3, "%ws:\\FRW03_%d.txt", BASE_DRIVE, ThreadID);

    HANDLE hFile = NULL;
    HANDLE hFile1 = NULL;
    HANDLE hFile2 = NULL;

    DWORD wSize, rSize, size;

    // initialize state
    DeleteFile(lpFile1);
    DeleteFile(lpFile2);
    DeleteFile(lpFile3);

    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Read/Write 0 bytes")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 1 byte")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "1");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 1 space")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, " ");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write 2 bytes")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "69");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write short text")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write long text")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        size = sprintf(wbuffer, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n\r\n"
                "The quick brown fox jumps over the lazy dog\r\n"
                "1234567890\t-=`~!@#$%^&*()_+[]}{\\|';:\"/.,<>?\r\n\r\n"
                "This is a story about Ranet Jeno, the wicked witch from a swamp called DC.\r\n\r\n"
                "(All persons, places, and events are fictitious and bear no resemblance to any living or deceased (past, present, or future) persons, places or events.)\r\n\r\n");
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write really long text (0.5meg)")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for(int i=0; i<8192; i++)
            {
            size += sprintf(wbuffer+size, "Hello World.\r\n\r\nThis is a ReadFile() / WriteFile() API Test!\r\n\r\n");
            }
        if(WriteFile(hFile, wbuffer, size, &wSize, NULL) == TRUE && wSize == size)
            TESTPASS(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());
        else
            TESTFAIL(hLog, "WriteFile[%d] (ec: %ld)", wSize, GetLastError());

        if(SetFilePointer(hFile, 0, NULL, FILE_BEGIN) != 0)
            {
            sprintf(wbuffer, "Unable to reset file pointer (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }

        if(ReadFile(hFile, rbuffer, size, &rSize, NULL) == TRUE && rSize == size)
            TESTPASS(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());
        else
            TESTFAIL(hLog, "ReadFile[%d] (ec: %ld)", rSize, GetLastError());

        if(wSize == rSize && wSize == size && memcmp(rbuffer, wbuffer, size) == 0)
            TESTPASS(hLog, "Write Buffer[%d] == Read Buffer[%d]", wSize, rSize);
        else
            TESTFAIL(hLog, "Write Buffer[%d] != Read Buffer[%d]", wSize, rSize);
        } ENDTESTCASE_CLEAN({ CloseHandle(hFile); DeleteFile(lpFile1); });
    TESTCASE("Read/Write short binary (256b)")
        {
        hFile = CreateFile(lpFile1, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
            {
            sprintf(wbuffer, "Unable to open file (ec: %ld)", GetLastError());
            BLOCKED(0, wbuffer);
            }
        for