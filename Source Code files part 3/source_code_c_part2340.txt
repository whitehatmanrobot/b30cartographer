;
    else
        // Both specified
        return dwMsgAndCertEncodingType;
}

#if 0

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT SlowCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded
    )
{
    DWORD dwEncodingType;
    HCRYPTPROV hProv = 0;
    DWORD dwProvFlags = 0;
    HCRYPTMSG hMsg = NULL;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    PCTL_INFO pInfo = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCTL_CONTEXT pCtl;
    PCTL_CONTEXT_SUFFIX pCtlSuffix;

    // Attempt to get the store's crypt provider. Serialize crypto
    // operations.
    hProv = GetCryptProv(pStore, &dwProvFlags);

    if (0 == (dwMsgAndCertEncodingType = GetCtlEncodingType(
             dwMsgAndCertEncodingType)))
        goto InvalidArg;

    // The message encoding type takes precedence
    dwEncodingType = (dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;

    // BUGBUG what about indefinite length encoded PKCS #7 ???
    cbCtlEncoded = AdjustEncodedLength(
        dwEncodingType, pbCtlEncoded, cbCtlEncoded);

    // First decode as a PKCS#7 SignedData message
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgAndCertEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            hProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto MsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsg,
            pbCtlEncoded,
            cbCtlEncoded,
            TRUE                    // fFinal
            )) goto MsgUpdateError;
    else {
        // Verify that the outer ContentType is SignedData and the inner
        // ContentType is a CertificateTrustList
        DWORD dwMsgType = 0;
        DWORD cbData;
        char szInnerContentType[64];
        assert(sizeof(szInnerContentType) > strlen(szOID_CTL));

        cbData = sizeof(dwMsgType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_TYPE_PARAM,
                0,                  // dwIndex
                &dwMsgType,
                &cbData
                )) goto GetTypeError;
        if (CMSG_SIGNED != dwMsgType)
            goto UnexpectedMsgTypeError;

        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        if (0 != strcmp(szInnerContentType, szOID_CTL))
            goto UnexpectedInnerContentTypeError;

    }

    // Get the inner content.
    if (NULL == (pbContent = (BYTE *) AllocAndGetMsgParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            &cbContent))) goto GetContentError;

    // Decode inner content
    if (NULL == (pInfo = (PCTL_INFO) AllocAndDecodeObject(
                dwEncodingType,
                PKCS_CTL,
                pbContent,
                cbContent))) goto DecodeError;

    // Allocate and initialize the CTL element structure
    if (NULL == (pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) + sizeof(CTL_CONTEXT) +
            sizeof(CTL_CONTEXT_SUFFIX))))
        goto OutOfMemory;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CTL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCtl = (PCTL_CONTEXT) ToCtlContext(pEle);
    pCtl->dwMsgAndCertEncodingType =
        dwMsgAndCertEncodingType;
    pCtl->pbCtlEncoded = pbCtlEncoded;
    pCtl->cbCtlEncoded = cbCtlEncoded;
    pCtl->pCtlInfo = pInfo;
    pCtl->hCertStore = (HCERTSTORE) pStore;
    pCtl->hCryptMsg = hMsg;
    pCtl->pbCtlContent = pbContent;
    pCtl->cbCtlContent = cbContent;

    pCtlSuffix = ToCtlContextSuffix(pEle);
    pCtlSuffix->ppSortedEntry = NULL;
    pCtlSuffix->pSortedCtlFindInfo = NULL;

CommonReturn:
    // For the store's crypt provider, release reference count. Leave
    // crypto operations critical section.
    //
    // BUGBUG,  Also, any subsequent CryptMsg cryptographic operations will
    // be done outside of critical section. This critical section is needed
    // because CAPI 1.0 isn't thread safe. This should be fixed!!!! ?????
    ReleaseCryptProv(pStore, dwProvFlags);
    return pEle;

ErrorReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    PkiFree(pInfo);
    PkiFree(pbContent);
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(MsgOpenToDecodeError)
TRACE_ERROR(MsgUpdateError)
TRACE_ERROR(GetTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedInnerContentTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetContentError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeError)
}

void
StoreMessageBox(
    IN LPSTR pszText
    )
{
    MessageBoxA(
        NULL,           // hwndOwner
        pszText,
        "Check FastCreateCtlElement",
        MB_TOPMOST | MB_OK | MB_ICONQUESTION |
            MB_SERVICE_NOTIFICATION
        );
}
#endif

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT FastCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN DWORD dwFlags
    );

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded
    )
{
#if 1
    return FastCreateCtlElement(
        pStore,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        0                                   // dwFlags
        );
#else
    PCONTEXT_ELEMENT pSlowEle;
    PCONTEXT_ELEMENT pFastEle;

    pFastEle = FastCreateCtlElement(
        pStore,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        0                   // dwFlags
        );

    pSlowEle = NULL;
    if (cbCtlEncoded) {
        BYTE *pbSlowCtlEncoded = NULL;

        pbSlowCtlEncoded = (BYTE *) PkiNonzeroAlloc(cbCtlEncoded);
        if (pbSlowCtlEncoded) {
            memcpy(pbSlowCtlEncoded, pbCtlEncoded, cbCtlEncoded);
            pSlowEle = SlowCreateCtlElement(
                &NullCertStore,
                dwMsgAndCertEncodingType,
                pbSlowCtlEncoded,
                cbCtlEncoded
                );
            if (NULL == pSlowEle)
                PkiFree(pbSlowCtlEncoded);
        }
    }

    if (NULL == pFastEle) {
        if (pSlowEle)
            StoreMessageBox("fast failed, slow succeeded");
    } else if (NULL == pSlowEle) {
        StoreMessageBox("fast succeeded, slow failed");
    } else {
        PCTL_INFO pFastInfo = ToCtlContext(pFastEle)->pCtlInfo;
        PCTL_INFO pSlowInfo = ToCtlContext(pSlowEle)->pCtlInfo;

        // Check that headers match
        if (pFastInfo->dwVersion != pSlowInfo->dwVersion ||
                pFastInfo->SubjectUsage.cUsageIdentifier !=
                    pSlowInfo->SubjectUsage.cUsageIdentifier ||
                0 != CompareFileTime(&pFastInfo->ThisUpdate,
                    &pSlowInfo->ThisUpdate) ||
                0 != CompareFileTime(&pFastInfo->NextUpdate,
                    &pSlowInfo->NextUpdate) ||
                0 != strcmp(pFastInfo->SubjectAlgorithm.pszObjId,
                        pSlowInfo->SubjectAlgorithm.pszObjId) ||
                pFastInfo->SubjectAlgorithm.Parameters.cbData !=
                        pSlowInfo->SubjectAlgorithm.Parameters.cbData)
            StoreMessageBox("fast and slow info doesn't match\n");
        else {
            // Check that the extensions match
            DWORD cFastExt = pFastInfo->cExtension;
            PCERT_EXTENSION pFastExt = pFastInfo->rgExtension;
            DWORD cSlowExt = pSlowInfo->cExtension;
            PCERT_EXTENSION pSlowExt = pSlowInfo->rgExtension;

            if (cFastExt != cSlowExt)
                StoreMessageBox("fast and slow extension count doesn't match");
            else {
                for ( ; cFastExt; cFastExt--, pFastExt++, pSlowExt++) {
                    if (0 != strcmp(pFastExt->pszObjId, pSlowExt->pszObjId) ||
                                pFastExt->fCritical != pSlowExt->fCritical ||
                            pFastExt->Value.cbData != pSlowExt->Value.cbData) {
                        StoreMessageBox(
                            "fast and slow extension doesn't match");
                        goto Done;
                    }
                    if (pFastExt->Value.cbData && 0 != memcmp(
                            pFastExt->Value.pbData, pSlowExt->Value.pbData,
                                pFastExt->Value.cbData)) {
                        StoreMessageBox(
                            "fast and slow extension doesn't match");
                        goto Done;
                    }
                }
            }
        }

        if (pFastInfo->cCTLEntry != pSlowInfo->cCTLEntry)
            StoreMessageBox("fast and slow entry count doesn't match");
        else {
            DWORD cEntry = pFastInfo->cCTLEntry;
            PCTL_ENTRY pFastEntry = pFastInfo->rgCTLEntry;
            PCTL_ENTRY pSlowEntry = pSlowInfo->rgCTLEntry;

            for ( ; cEntry; cEntry--, pFastEntry++, pSlowEntry++) {
                if (pFastEntry->SubjectIdentifier.cbData !=
                        pSlowEntry->SubjectIdentifier.cbData ||
                    0 != memcmp(pFastEntry->SubjectIdentifier.pbData,
                            pSlowEntry->SubjectIdentifier.pbData,
                            pFastEntry->SubjectIdentifier.cbData)) {
                    StoreMessageBox(
                        "fast and slow SubjectIdentifier doesn't match");
                    goto Done;
                }

                if (pFastEntry->cAttribute != pSlowEntry->cAttribute) {
                    StoreMessageBox(
                        "fast and slow Attribute Count doesn't match");
                    goto Done;
                } else if (0 < pFastEntry->cAttribute) {
                    DWORD cAttr = pFastEntry->cAttribute;
                    PCRYPT_ATTRIBUTE pFastAttr = pFastEntry->rgAttribute;
                    PCRYPT_ATTRIBUTE pSlowAttr = pSlowEntry->rgAttribute;

                    for ( ; cAttr; cAttr--, pFastAttr++, pSlowAttr++) {
                        if (0 != strcmp(pFastAttr->pszObjId,
                                    pSlowAttr->pszObjId)) {
                            StoreMessageBox(
                                "fast and slow Attribute OID doesn't match");
                            goto Done;
                        }

                        if (pFastAttr->cValue != pSlowAttr->cValue) {
                            StoreMessageBox(
                                "fast and slow Value Count doesn't match");
                            goto Done;
                        }

                        if (0 < pFastAttr->cValue) {
                            DWORD cValue = pFastAttr->cValue;
                            PCRYPT_ATTR_BLOB pFastValue = pFastAttr->rgValue;
                            PCRYPT_ATTR_BLOB pSlowValue = pSlowAttr->rgValue;

                            for ( ; cValue;
                                        cValue--, pFastValue++, pSlowValue++) {
                                if (pFastValue->cbData !=
                                        pSlowValue->cbData ||
                                    0 != memcmp(pFastValue->pbData,
                                            pSlowValue->pbData,
                                            pFastValue->cbData)) {
                                    StoreMessageBox(
                                        "fast and slow Value doesn't match");
                                    goto Done;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    

Done:
    if (pSlowEle)
        FreeContextElement(pSlowEle);

    return pFastEle;
        
#endif
}

STATIC void FreeCtlElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCTL_CONTEXT pCtl = ToCtlContext(pEle);
    PCTL_CONTEXT_SUFFIX pCtlSuffix = ToCtlContextSuffix(pEle);

    PkiFree(pCtl->pbCtlEncoded);
    PkiFree(pCtl->pCtlInfo);
    PkiFree(pCtlSuffix->ppSortedEntry);
    CryptMsgClose(pCtl->hCryptMsg);

    if (pCtlSuffix->fFastCreate) {
        PSORTED_CTL_FIND_INFO pSortedCtlFindInfo =
            pCtlSuffix->pSortedCtlFindInfo;

        PkiFree(pCtlSuffix->pCTLEntry);
        PkiFree(pCtlSuffix->pExtInfo);

        if (pSortedCtlFindInfo) {
            PkiFree(pSortedCtlFindInfo->pdwHashBucketHead);
            PkiFree(pSortedCtlFindInfo->pHashBucketEntry);
        }
    } else
        PkiFree(pCtl->pbCtlContent);

    PkiFree(pEle);
}

STATIC BOOL CompareCtlHash(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwPropId,
    IN PCRYPT_HASH_BLOB pHash
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;
    CertGetCTLContextProperty(
        pCtl,
        dwPropId,
        rgbHash,
        &cbHash
        );
    if (cbHash == pHash->cbData &&
            memcmp(rgbHash, pHash->pbData, cbHash) == 0)
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareCtlUsage(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCTL_FIND_USAGE_PARA pPara
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;

    if (NULL == pPara ||
             pPara->cbSize < (offsetof(CTL_FIND_USAGE_PARA, SubjectUsage) +
                sizeof(pPara->SubjectUsage)))
        return TRUE;
    if ((CTL_FIND_SAME_USAGE_FLAG & dwFindFlags) &&
            pPara->SubjectUsage.cUsageIdentifier !=
                pInfo->SubjectUsage.cUsageIdentifier)
        return FALSE;
    if (!CompareCtlUsageIdentifiers(&pPara->SubjectUsage,
            1, &pInfo->SubjectUsage, FALSE))
        return FALSE;

    assert(offsetof(CTL_FIND_USAGE_PARA, ListIdentifier) >
        offsetof(CTL_FIND_USAGE_PARA, SubjectUsage));
    if (pPara->cbSize < offsetof(CTL_FIND_USAGE_PARA, ListIdentifier) +
            sizeof(pPara->ListIdentifier))
        return TRUE;
    if (pPara->ListIdentifier.cbData) {
        DWORD cb = pPara->ListIdentifier.cbData;
        if (CTL_FIND_NO_LIST_ID_CBDATA == cb)
            cb = 0;
        if (cb != pInfo->ListIdentifier.cbData)
            return FALSE;
        if (0 != cb && 0 != memcmp(pPara->ListIdentifier.pbData,
                pInfo->ListIdentifier.pbData, cb))
            return FALSE;
    }

    assert(offsetof(CTL_FIND_USAGE_PARA, pSigner) >
        offsetof(CTL_FIND_USAGE_PARA, ListIdentifier));
    if (pPara->cbSize < offsetof(CTL_FIND_USAGE_PARA, pSigner) +
            sizeof(pPara->pSigner))
        return TRUE;
    if (CTL_FIND_NO_SIGNER_PTR == pPara->pSigner) {
        DWORD cbData;
        DWORD dwSignerCount;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                pCtl->hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 != dwSignerCount)
            return FALSE;
    } else if (pPara->pSigner) {
        DWORD dwCertEncodingType;
        PCERT_INFO pCertId1 = pPara->pSigner;
        HCRYPTMSG hMsg = pCtl->hCryptMsg;
        DWORD cbData;
        DWORD dwSignerCount;
        DWORD i;

        dwCertEncodingType = GetCertEncodingType(dwMsgAndCertEncodingType);
        if (dwCertEncodingType != GET_CERT_ENCODING_TYPE(
                pCtl->dwMsgAndCertEncodingType))
            return FALSE;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 == dwSignerCount)
            return FALSE;
        for (i = 0; i < dwSignerCount; i++) {
            BOOL fResult;
            PCERT_INFO pCertId2;
            if (NULL == (pCertId2 = (PCERT_INFO) AllocAndGetMsgParam(
                    hMsg,
                    CMSG_SIGNER_CERT_INFO_PARAM,
                    i,
                    &cbData)))
                continue;
            fResult = CertCompareCertificate(
                dwCertEncodingType,
                pCertId1,
                pCertId2);
            PkiFree(pCertId2);
            if (fResult)
                break;
        }
        if (i == dwSignerCount)
            return FALSE;
    }

    return TRUE;
}

STATIC BOOL CompareCtlSubject(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCTL_FIND_SUBJECT_PARA pPara
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;

    if (NULL == pPara ||
             pPara->cbSize < (offsetof(CTL_FIND_SUBJECT_PARA, pUsagePara) +
                sizeof(pPara->pUsagePara)))
        return TRUE;
    if (pPara->pUsagePara && !CompareCtlUsage(pCtl,
            dwMsgAndCertEncodingType, dwFindFlags, pPara->pUsagePara))
        return FALSE;

    assert(offsetof(CTL_FIND_SUBJECT_PARA, pvSubject) >
        offsetof(CTL_FIND_SUBJECT_PARA, pUsagePara));
    if (pPara->cbSize < offsetof(CTL_FIND_SUBJECT_PARA, pvSubject) +
            sizeof(pPara->pvSubject))
        return TRUE;
    if (pPara->pvSubject && NULL == CertFindSubjectInCTL(
            dwMsgAndCertEncodingType,
            pPara->dwSubjectType,
            pPara->pvSubject,
            pCtl,
            0))                     // dwFlags
        return FALSE;

    return TRUE;
}

STATIC BOOL IsSameCtl(
    IN PCCTL_CONTEXT pCtl,
    IN PCCTL_CONTEXT pNew
    )
{
    PCTL_INFO pInfo = pNew->pCtlInfo;
    HCRYPTMSG hMsg = pNew->hCryptMsg;
    CTL_FIND_USAGE_PARA FindPara;
    DWORD dwFindFlags;

    DWORD cbData;
    DWORD dwSignerCount;
    DWORD i;

    cbData = sizeof(dwSignerCount);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_SIGNER_COUNT_PARAM,
            0,                      // dwIndex
            &dwSignerCount,
            &cbData))
        return FALSE;

    memset(&FindPara, 0, sizeof(FindPara));
    FindPara.cbSize = sizeof(FindPara);
    FindPara.SubjectUsage = pInfo->SubjectUsage;
    FindPara.ListIdentifier = pInfo->ListIdentifier;
    if (0 == FindPara.ListIdentifier.cbData)
        FindPara.ListIdentifier.cbData = CTL_FIND_NO_LIST_ID_CBDATA;
    dwFindFlags = CTL_FIND_SAME_USAGE_FLAG;

    if (0 == dwSignerCount) {
        FindPara.pSigner = CTL_FIND_NO_SIGNER_PTR;
        return CompareCtlUsage(
            pCtl,
            pNew->dwMsgAndCertEncodingType,
            dwFindFlags,
            &FindPara
            );
    } else {
        for (i = 0; i < dwSignerCount; i++) {
            BOOL fResult;
            PCERT_INFO pSigner;

            if (NULL == (pSigner = (PCERT_INFO) AllocAndGetMsgParam(
                    hMsg,
                    CMSG_SIGNER_CERT_INFO_PARAM,
                    i,
                    &cbData)))
                continue;
            FindPara.pSigner = pSigner;
            fResult = CompareCtlUsage(
                    pCtl,
                    pNew->dwMsgAndCertEncodingType,
                    dwFindFlags,
                    &FindPara
                    );
            PkiFree(pSigner);
            if (fResult)
                return TRUE;
        }
    }
    return FALSE;
}

STATIC BOOL CompareCtlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCTL_CONTEXT pCtl = ToCtlContext(pEle);
    DWORD dwFindType = pFindInfo->dwFindType;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived) {
        switch (dwFindType) {
            case CTL_FIND_SHA1_HASH:
            case CTL_FIND_MD5_HASH:
                break;
            default:
                return FALSE;
        }
    }

    switch (dwFindType) {
        case CTL_FIND_ANY:
            return TRUE;
            break;
        case CTL_FIND_SHA1_HASH:
        case CTL_FIND_MD5_HASH:
            {
                DWORD dwPropId;
                if (dwFindType == CTL_FIND_SHA1_HASH)
                    dwPropId = CERT_SHA1_HASH_PROP_ID;
                else
                    dwPropId = CERT_MD5_HASH_PROP_ID;
                return CompareCtlHash(pCtl, dwPropId,
                    (PCRYPT_HASH_BLOB) pvFindPara);
            }
            break;
        case CTL_FIND_USAGE:
            return CompareCtlUsage(pCtl, pFindInfo->dwMsgAndCertEncodingType,
                pFindInfo->dwFindFlags, (PCTL_FIND_USAGE_PARA) pvFindPara);
            break;
        case CTL_FIND_SUBJECT:
            return CompareCtlSubject(pCtl, pFindInfo->dwMsgAndCertEncodingType,
                pFindInfo->dwFindFlags, (PCTL_FIND_SUBJECT_PARA) pvFindPara);
            break;

        case CTL_FIND_EXISTING:
            {
                PCCTL_CONTEXT pNew = (PCCTL_CONTEXT) pFindInfo->pvFindPara;
                return IsSameCtl(pCtl, pNew);
            }
            break;

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCtlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCTL_CONTEXT pNewCtl = ToCtlContext(pNewEle);
    PCCTL_CONTEXT pExistingCtl = ToCtlContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCtl->pCtlInfo->ThisUpdate,
        &pExistingCtl->pCtlInfo->ThisUpdate
        ));
}

#endif // CAPI_INCLUDE_CTL

//+=========================================================================
//  Store Link Functions
//==========================================================================

STATIC PCERT_STORE_LINK CreateStoreLink(
    IN PCERT_STORE pCollection,
    IN PCERT_STORE pSibling,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    )
{
    PCERT_STORE_LINK pLink;
    if (NULL == (pLink = (PCERT_STORE_LINK) PkiZeroAlloc(
            sizeof(CERT_STORE_LINK))))
        return NULL;

    pLink->lRefCnt = 1;
    pLink->dwUpdateFlags = dwUpdateFlags;
    pLink->dwPriority = dwPriority;
    pLink->pCollection = pCollection;
    pLink->pSibling = (PCERT_STORE) CertDuplicateStore((HCERTSTORE) pSibling);

    return pLink;
}

// Not locked upon entry
STATIC void FreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    CertCloseStore((HCERTSTORE) pStoreLink->pSibling, 0);
    PkiFree(pStoreLink);
}


STATIC void RemoveStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    PCERT_STORE pCollection = pStoreLink->pCollection;


    LockStore(pCollection);

    // Remove store link from the store's collection
    if (pStoreLink->pNext)
        pStoreLink->pNext->pPrev = pStoreLink->pPrev;
    if (pStoreLink->pPrev)
        pStoreLink->pPrev->pNext = pStoreLink->pNext;
    else if (pStoreLink == pCollection->pStoreListHead)
        pCollection->pStoreListHead = pStoreLink->pNext;
    // else
    //  Not on any list

    // Unlocks the store or deletes the store if this was the
    // last link in a closed store
    FreeStore(pCollection);
}

STATIC void RemoveAndFreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    RemoveStoreLink(pStoreLink);
    FreeStoreLink(pStoreLink);
}

STATIC void ReleaseStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    if (0 == InterlockedDecrement(&pStoreLink->lRefCnt)) {
        assert(pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG);
        assert(pStoreLink->pSibling);
        RemoveAndFreeStoreLink(pStoreLink);
    }
}


//+=========================================================================
//  Context Element Functions
//==========================================================================

STATIC DWORD GetContextEncodingType(
    IN PCONTEXT_ELEMENT pEle
    )
{
    DWORD dwContextType = pEle->dwContextType;
    DWORD *pdwEncodingType;

    pdwEncodingType = (DWORD *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodingType[dwContextType]);
    return *pdwEncodingType;
}

STATIC void GetContextEncodedInfo(
    IN PCONTEXT_ELEMENT pEle,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    DWORD dwContextType = pEle->dwContextType;
    BYTE **ppbSrcEncoded;
    DWORD *pcbSrcEncoded;

    ppbSrcEncoded = (BYTE **) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodedPointer[dwContextType]);
    *ppbEncoded = *ppbSrcEncoded;

    pcbSrcEncoded = (DWORD *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodedCount[dwContextType]);
    *pcbEncoded = *pcbSrcEncoded;
}



STATIC PCONTEXT_ELEMENT GetCacheElement(
    IN PCONTEXT_ELEMENT pCacheEle
    )
{
    DWORD dwInnerDepth;

    // Skip past any links to get to the cache element
    dwInnerDepth = 0;
    for ( ; pCacheEle != pCacheEle->pEle; pCacheEle = pCacheEle->pEle) {
        dwInnerDepth++;
        assert(dwInnerDepth <= MAX_LINK_DEPTH);
        assert(ELEMENT_TYPE_CACHE != pCacheEle->dwElementType);
        if (dwInnerDepth > MAX_LINK_DEPTH)
            goto ExceededMaxLinkDepth;
    }

    assert(pCacheEle);
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);

CommonReturn:
    return pCacheEle;
ErrorReturn:
    pCacheEle = NULL;
    goto CommonReturn;
SET_ERROR(ExceededMaxLinkDepth, E_UNEXPECTED)
}


STATIC void AddContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PCERT_STORE pStore = pEle->pStore;
    DWORD dwContextType = pEle->dwContextType;

    LockStore(pStore);

    pEle->pNext = pStore->rgpContextListHead[dwContextType];
    pEle->pPrev = NULL;
    if (pStore->rgpContextListHead[dwContextType])
        pStore->rgpContextListHead[dwContextType]->pPrev = pEle;
    pStore->rgpContextListHead[dwContextType] = pEle;

    UnlockStore(pStore);
}


STATIC void RemoveContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PCERT_STORE pStore = pEle->pStore;
    DWORD dwContextType = pEle->dwContextType;

    LockStore(pStore);

    // Remove context from the store's list
    if (pEle->pNext)
        pEle->pNext->pPrev = pEle->pPrev;
    if (pEle->pPrev)
        pEle->pPrev->pNext = pEle->pNext;
    else if (pEle == pStore->rgpContextListHead[dwContextType])
        pStore->rgpContextListHead[dwContextType] = pEle->pNext;
    // else
    //  Not on any list

    // Unlocks the store or deletes the store if this was the
    // last context in a closed store
    FreeStore(pStore);
}

STATIC void FreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PPROP_ELEMENT pPropEle;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo;

    // Free its property elements
    while ((pPropEle = pEle->Cache.pPropHead) != NULL) {
        RemovePropElement(pEle, pPropEle);
        FreePropElement(pPropEle);
    }

    // For NOCOPY of the pbEncoded, call the NOCOPY pfnFree callback
    if (pNoCopyInfo = pEle->pNoCopyInfo) {
        PFN_CRYPT_FREE pfnFree;
        BYTE **ppbEncoded;

        if (pfnFree = pNoCopyInfo->pfnFree) {
            assert(pNoCopyInfo->pvFree);
            pfnFree(pNoCopyInfo->pvFree);
        }

        // Inhibit following rgpfnFreeElement[] from freeing pbEncoded
        ppbEncoded = (BYTE **) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
            rgOffsetofEncodedPointer[pEle->dwContextType]);
        *ppbEncoded = NULL;
        PkiFree(pNoCopyInfo);
    }

    rgpfnFreeElement[pEle->dwContextType](pEle);
}

STATIC void RemoveAndFreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    RemoveContextElement(pEle);
    FreeContextElement(pEle);
}

STATIC void AddRefContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    InterlockedIncrement(&pEle->lRefCnt);
    if (pEle->pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
        InterlockedIncrement(&pEle->pStore->lDeferCloseRefCnt);
}

STATIC void AddRefDeferClose(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle->pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
        InterlockedIncrement(&pEle->pStore->lDeferCloseRefCnt);
}

STATIC void ReleaseContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    DWORD dwErr;
    PCERT_STORE pStore;
    DWORD dwStoreFlags;

    if (pEle == NULL)
        return;

    pStore = pEle->pStore;
    dwStoreFlags = pStore->dwFlags;

    if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
        // Check that the store still doesn't hold a reference
        assert(pEle->dwFlags & ELEMENT_DELETED_FLAG);

        if (dwStoreFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
            InterlockedDecrement(&pStore->lDeferCloseRefCnt);

        dwErr = GetLastError();
        if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
            RemoveAndFreeContextElement(pEle);
        else
            RemoveAndFreeLinkElement(pEle);
        SetLastError(dwErr);
    } else if (dwStoreFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG) {
        LockStore(pStore);
        if (0 == InterlockedDecrement(&pStore->lDeferCloseRefCnt)) {
            if (STORE_STATE_DEFER_CLOSING == pStore->dwState) {
                dwErr = GetLastError();
                CloseStore(pStore, 0);
                SetLastError(dwErr);
                return;
            }
        }
        UnlockStore(pStore);
    }
}

STATIC BOOL DeleteContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;

    if (NULL == pEle) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    switch (pEle->dwElementType) {
        case ELEMENT_TYPE_LINK_CONTEXT:
            // Only delete the link itself
            break;

        case ELEMENT_TYPE_COLLECTION:
            // Delete element pointed to
            assert(pEle != pEle->pEle);
            if (pEle != pEle->pEle) {
                // Since delete releases refCnt, need to do an extra
                // addRef here.
                AddRefContextElement(pEle->pEle);
                if (!DeleteContextElement(pEle->pEle))
                    goto DeleteCacheCollectionError;
            } else
                goto InvalidElement;
            break;

        case ELEMENT_TYPE_CACHE:
        case ELEMENT_TYPE_EXTERNAL:
            {
                PCERT_STORE pProvStore = pEle->pProvStore;
                const DWORD dwStoreProvDeleteIndex =
                    rgdwStoreProvDeleteIndex[pEle->dwContextType];
                PFN_CERT_STORE_PROV_DELETE_CERT pfnStoreProvDeleteCert;

                assert(STORE_TYPE_CACHE == pProvStore->dwStoreType ||
                    STORE_TYPE_EXTERNAL == pProvStore->dwStoreType);

                fResult = TRUE;
                LockStore(pProvStore);
                // Check if we need to call the store provider's writethru
                // function.
                if (dwStoreProvDeleteIndex <
                        pProvStore->StoreProvInfo.cStoreProvFunc &&
                            NULL != (pfnStoreProvDeleteCert =
                                (PFN_CERT_STORE_PROV_DELETE_CERT)
                            pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                                dwStoreProvDeleteIndex])) {

                    // Since we can't hold a lock while calling the provider
                    // function, bump the store's provider reference count
                    // to inhibit the closing of the store and freeing of
                    // the provider functions.
                    //
                    // When the store is closed,
                    // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
                    AddRefStoreProv(pProvStore);
                    UnlockStore(pProvStore);

                    // Check if its OK to delete from the store.
                    fResult = pfnStoreProvDeleteCert(
                            pProvStore->StoreProvInfo.hStoreProv,
                            ToCertContext(pEle->pEle),
                            0                       // dwFlags
                            );
                    LockStore(pProvStore);
                    ReleaseStoreProv(pProvStore);
                }
                UnlockStore(pProvStore);
                if (!fResult)
                    goto StoreProvDeleteError;
            }
            break;
        default:
            goto InvalidElementType;
    }

    LockStore(pEle->pStore);
    if (0 == (pEle->dwFlags & ELEMENT_DELETED_FLAG)) {
        // On the store's list. There should be at least two reference
        // counts on the context, the store's and the caller's.
        assert(pEle->pStore->dwState == STORE_STATE_OPEN ||
            pEle->pStore->dwState == STORE_STATE_OPENING ||
            pEle->pStore->dwState == STORE_STATE_DEFER_CLOSING ||
            pEle->pStore->dwState == STORE_STATE_CLOSING);

        // Remove the store's reference
        if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
            assert(pEle->lRefCnt > 0);
            // Put back the reference to allow the ReleaseContextElement
            // to do the context remove and free
            pEle->lRefCnt = 1;
        }
        pEle->dwFlags |= ELEMENT_DELETED_FLAG;
    }
    UnlockStore(pEle->pStore);

    fResult = TRUE;
CommonReturn:
    // Release the caller's reference on the context
    ReleaseContextElement(pEle);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DeleteCacheCollectionError)
SET_ERROR(InvalidElement, E_INVALIDARG)
TRACE_ERROR(StoreProvDeleteError)
SET_ERROR(InvalidElementType, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Serialize a store element and its properties
//--------------------------------------------------------------------------
STATIC BOOL SerializeStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!SerializeProperty(
            h,
            pfn,
            pEle
            ))
        goto SerializePropertyError;

    GetContextEncodedInfo(pEle, &pbEncoded, &cbEncoded);
    if (!WriteStoreElement(
            h,
            pfn,
            GetContextEncodingType(pEle),
            rgdwFileElementType[pEle->dwContextType],
            pbEncoded,
            cbEncoded
            ))
        goto WriteElementError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(SerializePropertyError);
TRACE_ERROR(WriteElementError);
}

//+-------------------------------------------------------------------------
//  Serialize the context's encoded data and its properties.
//--------------------------------------------------------------------------
STATIC BOOL SerializeContextElement(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pByte = pbElement;
    if (pbElement == NULL)
        MemInfo.cb = 0;
    else
        MemInfo.cb = *pcbElement;
    MemInfo.cbSeek = 0;

    if (fResult = SerializeStoreElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle)) {
        if (MemInfo.cbSeek > MemInfo.cb && pbElement) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
        *pcbElement = MemInfo.cbSeek;
    } else
        *pcbElement = 0;

    return fResult;
}

//+=========================================================================
//  Collection Stack Functions
//==========================================================================

// No locks upon entry
STATIC BOOL PushCollectionStack(
    IN OUT PCOLLECTION_STACK_ENTRY *ppStack,
    IN PCERT_STORE pCollection
    )
{
    PCOLLECTION_STACK_ENTRY pNew;
    PCERT_STORE_LINK pStoreLink;

    if (NULL == (pNew = (PCOLLECTION_STACK_ENTRY) PkiZeroAlloc(
            sizeof(COLLECTION_STACK_ENTRY))))
        return FALSE;

    LockStore(pCollection);

    pStoreLink = pCollection->pStoreListHead;
    // Advance past deleted store links
    while (pStoreLink && (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG))
        pStoreLink = pStoreLink->pNext;

    if (pStoreLink)
        AddRefStoreLink(pStoreLink);
    UnlockStore(pCollection);

    pNew->pCollection = pCollection;
    pNew->pStoreLink = pStoreLink;
    pNew->pPrev = *ppStack;
    *ppStack = pNew;
    return TRUE;
};


// No locks upon entry
STATIC void AdvanceToNextStackStoreLink(
    IN PCOLLECTION_STACK_ENTRY pStack
    )
{
    PCERT_STORE pStackCollectionStore;
    PCERT_STORE_LINK pStoreLink;

    if (NULL == pStack)
        return;
    pStoreLink = pStack->pStoreLink;
    if (NULL == pStoreLink)
        return;

    pStackCollectionStore = pStack->pCollection;
    assert(pStackCollectionStore);
    LockStore(pStackCollectionStore);
    pStoreLink = pStoreLink->pNext;

    // Advance past deleted store links
    while (pStoreLink && (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG))
        pStoreLink = pStoreLink->pNext;

    if (pStoreLink)
        AddRefStoreLink(pStoreLink);
    UnlockStore(pStackCollectionStore);

    ReleaseStoreLink(pStack->pStoreLink);
    pStack->pStoreLink = pStoreLink;
}

// No locks upon entry
STATIC void PopCollectionStack(
    IN OUT PCOLLECTION_STACK_ENTRY *ppStack
    )
{
    PCOLLECTION_STACK_ENTRY pStack = *ppStack;
    if (pStack) {
        PCOLLECTION_STACK_ENTRY pPrevStack;
        if (pStack->pStoreLink)
            ReleaseStoreLink(pStack->pStoreLink);
        pPrevStack = pStack->pPrev;
        *ppStack = pPrevStack;
        PkiFree(pStack);

        if (pPrevStack)
            AdvanceToNextStackStoreLink(pPrevStack);
    }
}

// No locks upon entry
STATIC void ClearCollectionStack(
    IN PCOLLECTION_STACK_ENTRY pStack
    )
{
    while (pStack) {
        PCOLLECTION_STACK_ENTRY pFreeStack;

        if (pStack->pStoreLink)
            ReleaseStoreLink(pStack->pStoreLink);
        pFreeStack = pStack;
        pStack = pStack->pPrev;
        PkiFree(pFreeStack);
    }
}

//+=========================================================================
//  Link Element Functions
//==========================================================================

STATIC PCONTEXT_ELEMENT CreateLinkElement(
    IN DWORD dwContextType
    )
{
    PCONTEXT_ELEMENT pLinkEle;
    const DWORD cbContext = rgcbContext[dwContextType];

    if (NULL == (pLinkEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) + cbContext)))
        return NULL;
    pLinkEle->dwContextType = dwContextType;
    return pLinkEle;
}

static inline void SetStoreHandle(
    IN PCONTEXT_ELEMENT pEle
    )
{
    HCERTSTORE *phStore;
    phStore = (HCERTSTORE *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofStoreHandle[pEle->dwContextType]);
    *phStore = (HCERTSTORE) pEle->pStore;
}

// The store doesn't hold a reference on the external element.
// Therefore, its lRefCnt is 1 and the ELEMENT_DELETED_FLAG is set.
STATIC void InitAndAddExternalElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,          // EXTERNAL
    IN PCONTEXT_ELEMENT pProvEle,   // already AddRef'ed
    IN DWORD dwFlags,
    IN OPTIONAL void *pvProvInfo
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_EXTERNAL == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_EXTERNAL;
    pLinkEle->dwFlags = dwFlags | ELEMENT_DELETED_FLAG;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pProvEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pStore;
    pLinkEle->External.pvProvInfo = pvProvInfo;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pProvEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
    AddRefDeferClose(pLinkEle);
}

// The store doesn't hold a reference on the collection element.
// Therefore, its RefCount is 1 and the ELEMENT_DELETED_FLAG is set.
STATIC void InitAndAddCollectionElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,              // COLLECTION
    IN PCONTEXT_ELEMENT pSiblingEle,    // already AddRef'ed
    IN OPTIONAL PCOLLECTION_STACK_ENTRY pCollectionStack
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_COLLECTION == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_COLLECTION;
    pLinkEle->dwFlags = ELEMENT_DELETED_FLAG;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pSiblingEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pSiblingEle->pProvStore;
    pLinkEle->Collection.pCollectionStack = pCollectionStack;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pSiblingEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
    AddRefDeferClose(pLinkEle);
}

// The store holds a reference on the link context element.
// Therefore, the ELEMENT_DELETED_FLAG is clear.
STATIC void InitAndAddLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,              // CACHE
    IN PCONTEXT_ELEMENT pContextEle     // already AddRef'ed
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_LINK_CONTEXT;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pContextEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pContextEle->pProvStore;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pContextEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
}

// Upon entry no locks
STATIC void RemoveAndFreeLinkElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (ELEMENT_TYPE_EXTERNAL == pEle->dwElementType) {
        PCERT_STORE pProvStore = pEle->pProvStore;
        const DWORD dwStoreProvFreeFindIndex =
            rgdwStoreProvFreeFindIndex[pEle->dwContextType];
        PFN_CERT_STORE_PROV_FREE_FIND_CERT pfnStoreProvFreeFindCert;

        assert(pEle->pStore == pEle->pProvStore);
        assert(STORE_TYPE_EXTERNAL == pProvStore->dwStoreType);

        LockStore(pProvStore);
        // Check if we need to call the store provider's free find cert
        // function.
        if (pEle->dwFlags & ELEMENT_FIND_NEXT_FLAG) {
            pEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;

            if (dwStoreProvFreeFindIndex <
                    pProvStore->StoreProvInfo.cStoreProvFunc &&
                        NULL != (pfnStoreProvFreeFindCert =
                            (PFN_CERT_STORE_PROV_FREE_FIND_CERT)
                        pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                            dwStoreProvFreeFindIndex])) {

                // Since we can't hold a lock while calling the provider
                // function, bump the store's provider reference count
                // to inhibit the closing of the store and freeing of
                // the provider functions.
                //
                // When the store is closed,
                // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
                AddRefStoreProv(pProvStore);
                UnlockStore(pProvStore);

                pfnStoreProvFreeFindCert(
                    pProvStore->StoreProvInfo.hStoreProv,
                    ToCertContext(pEle->pEle),
                    pEle->External.pvProvInfo,
                    0                       // dwFlags
                    );
                LockStore(pProvStore);
                ReleaseStoreProv(pProvStore);
            }
        }
        UnlockStore(pProvStore);
    } else if (ELEMENT_TYPE_COLLECTION == pEle->dwElementType) {
        if (pEle->Collection.pCollectionStack)
            ClearCollectionStack(pEle->Collection.pCollectionStack);
    }

    ReleaseContextElement(pEle->pEle);

    // Remove from store
    RemoveContextElement(pEle);
    FreeLinkElement(pEle);
}

STATIC void FreeLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle
    )
{
    ReleaseContextElement(pLinkEle->pEle);
    FreeLinkElement(pLinkEle);
}

//+=========================================================================
//  Find Element Functions
//==========================================================================

// For Add, called with store already locked and store remains locked. The
// find type for the Add is FIND_EXISTING.
// CacheStore may contain either cache or context link elements
STATIC PCONTEXT_ELEMENT FindElementInCacheStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle,
    IN BOOL fForceEnumArchived = FALSE
    )
{
    PCONTEXT_ELEMENT pEle;

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);
    LockStore(pStore);

    if (pPrevEle) {
        if (pPrevEle->pStore != pStore ||
                pPrevEle->dwContextType != dwContextType) {
            UnlockStore(pStore);
            goto InvalidPreviousContext;
        }
        pEle = pPrevEle->pNext;
    } else if (STORE_STATE_NULL == pStore->dwState)
        // For NULL store, all elements are already deleted
        pEle = NULL;
    else
        pEle = pStore->rgpContextListHead[dwContextType];

    for ( ; pEle; pEle = pEle->pNext) {
        PCONTEXT_ELEMENT pCacheEle;
        BOOL fArchived;

        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType ||
            ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType);

        // Skip past deleted elements
        if (pEle->dwFlags & ELEMENT_DELETED_FLAG)
            continue;

        if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
            pCacheEle = pEle;
        else {
            pCacheEle = GetCacheElement(pEle);
            if (NULL == pCacheEle)
                pCacheEle = pEle;
        }
        fArchived = ((pCacheEle->dwFlags & ELEMENT_ARCHIVED_FLAG) &&
            0 == (pStore->dwFlags & CERT_STORE_ENUM_ARCHIVED_FLAG) &&
            !fForceEnumArchived);

        AddRefContextElement(pEle);
        UnlockStore(pStore);

        if (rgpfnCompareElement[dwContextType](pEle, pFindInfo, fArchived))
            goto CommonReturn;

        if (pPrevEle)
            ReleaseContextElement(pPrevEle);
        pPrevEle = pEle;

        LockStore(pStore);
    }

    UnlockStore(pStore);
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;

ErrorReturn:
    pEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
}

STATIC PCONTEXT_ELEMENT FindElementInExternalStore(
    IN PCERT_STORE pStore,      //  EXTERNAL
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    const DWORD dwStoreProvFindIndex = rgdwStoreProvFindIndex[dwContextType];

    // All the context types have the same find callback signature.
    PFN_CERT_STORE_PROV_FIND_CERT pfnStoreProvFind;

    void *pvProvInfo;
    PCONTEXT_ELEMENT pPrevProvEle = NULL;
    PCCERT_CONTEXT pProvCertContext;

    assert(STORE_TYPE_EXTERNAL == pStore->dwStoreType);

    if (NULL == (pEle = CreateLinkElement(dwContextType)))
        goto CreateLinkElementError;

    if (pPrevEle) {
        BOOL fResult;

        if (pPrevEle->pStore != pStore ||
                pPrevEle->dwContextType != dwContextType)
            goto InvalidPreviousContext;
        assert(ELEMENT_TYPE_EXTERNAL == pPrevEle->dwElementType);

        LockStore(pStore);
        fResult = pPrevEle->dwFlags & ELEMENT_FIND_NEXT_FLAG;
        if (fResult) {
            assert(dwStoreProvFindIndex <
                pStore->StoreProvInfo.cStoreProvFunc &&
                pStore->StoreProvInfo.rgpvStoreProvFunc[dwStoreProvFindIndex]);
            pvProvInfo = pPrevEle->External.pvProvInfo;
            pPrevEle->External.pvProvInfo = NULL;
            pPrevEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;
            pPrevProvEle = pPrevEle->pEle;
            assert(pPrevProvEle);
        }
        UnlockStore(pStore);
        if (!fResult)
            goto InvalidExternalFindNext;
    } else {
        pvProvInfo = NULL;
        pPrevProvEle = NULL;
    }


    // Check if external store supports the context type
    if (dwStoreProvFindIndex >= pStore->StoreProvInfo.cStoreProvFunc ||
        NULL == (pfnStoreProvFind = (PFN_CERT_STORE_PROV_FIND_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[dwStoreProvFindIndex]))
        goto ProvFindNotSupported;

    pProvCertContext = NULL;
    if (!pfnStoreProvFind(
            pStore->StoreProvInfo.hStoreProv,
            pFindInfo,
            ToCertContext(pPrevProvEle),
            0,                      // dwFlags
            &pvProvInfo,
            &pProvCertContext) || NULL == pProvCertContext)
        goto ErrorReturn;

    InitAndAddExternalElement(
        pEle,
        pStore,
        ToContextElement(pProvCertContext),
        ELEMENT_FIND_NEXT_FLAG,
        pvProvInfo
        );

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;

ErrorReturn:
    if (pEle) {
        FreeLinkElement(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
SET_ERROR(InvalidExternalFindNext, E_INVALIDARG)
SET_ERROR(ProvFindNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
TRACE_ERROR(CreateLinkElementError)
}

STATIC PCONTEXT_ELEMENT FindElementInCollectionStore(
    IN PCERT_STORE pCollection,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle,
    IN BOOL fFindForAdd = FALSE
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCOLLECTION_STACK_ENTRY pStack = NULL;

    if (pPrevEle) {
        // Get previous element's collection stack

        if (pPrevEle->pStore != pCollection ||
                pPrevEle->dwContextType != dwContextType)
            goto InvalidPreviousContext;

        LockStore(pCollection);
        pStack = pPrevEle->Collection.pCollectionStack;
        pPrevEle->Collection.pCollectionStack = NULL;
        UnlockStore(pCollection);

        if (NULL == pStack)
            goto InvalidCollectionFindNext;

        // Note, pStack->pCollection is only equal to pCollection
        // for a single level collection.
        assert(pStack->pStoreLink);
        assert(ELEMENT_TYPE_EXTERNAL == pPrevEle->dwElementType ||
            ELEMENT_TYPE_COLLECTION == pPrevEle->dwElementType);
    } else {
        // Initialize collection stack with the collection store's
        // first link
        if (!PushCollectionStack(&pStack, pCollection))
            goto PushStackError;
    }

    while (pStack) {
        PCERT_STORE pStackCollectionStore;
        PCERT_STORE_LINK pStoreLink;
        PCERT_STORE pFindStore;

        pStackCollectionStore = pStack->pCollection;
        pStoreLink = pStack->pStoreLink;    // may be NULL
        if (NULL == pPrevEle) {
            LockStore(pStackCollectionStore);

            // Advance past any deleted store links
            //
            // Also if doing a find before doing an add to a collection,
            // check that the store link allows an ADD
            while (pStoreLink &&
                ((pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG) ||
                    (fFindForAdd && 0 == (pStoreLink->dwUpdateFlags &
                        CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG))))
                pStoreLink = pStoreLink->pNext;
            if (pStoreLink && pStoreLink != pStack->pStoreLink)
                AddRefStoreLink(pStoreLink);

            UnlockStore(pStackCollectionStore);

            if (NULL == pStoreLink) {
                // Reached end of collection's store links
                PopCollectionStack(&pStack);
                continue;
            } else if (pStoreLink != pStack->pStoreLink) {
                ReleaseStoreLink(pStack->pStoreLink);
                pStack->pStoreLink = pStoreLink;
            }
        }

        assert(pStoreLink);
        pFindStore = pStoreLink->pSibling;
        if (STORE_TYPE_COLLECTION == pFindStore->dwStoreType) {
            assert(NULL == pPrevEle);
            // Add inner collection store to stack
            if (!PushCollectionStack(&pStack, pFindStore))
                goto PushStackError;
        } else if (STORE_TYPE_CACHE == pFindStore->dwStoreType ||
                STORE_TYPE_EXTERNAL == pFindStore->dwStoreType) {
            PCONTEXT_ELEMENT pPrevSiblingEle;
            PCONTEXT_ELEMENT pSiblingEle;

            if (pPrevEle) {
                assert(ELEMENT_TYPE_COLLECTION ==
                    pPrevEle->dwElementType);
                pPrevSiblingEle = pPrevEle->pEle;
                // FindElementInCacheStore or FindElementInExternalStore
                // does an implicit Free
                AddRefContextElement(pPrevSiblingEle);
            } else
                pPrevSiblingEle = NULL;

            if (pSiblingEle = FindElementInStore(
                    pFindStore,
                    dwContextType,
                    pFindInfo,
                    pPrevSiblingEle
                    )) {
                if (NULL == (pEle =
                        CreateLinkElement(dwContextType))) {
                    ReleaseContextElement(pSiblingEle);
                    goto CreateLinkElementError;
                }

                InitAndAddCollectionElement(
                    pEle,
                    pCollection,
                    pSiblingEle,
                    pStack
                    );
                goto CommonReturn;
            }

            if (pPrevEle) {
                ReleaseContextElement(pPrevEle);
                pPrevEle = NULL;
            }

            // Advance to the next store link in the collection
            AdvanceToNextStackStoreLink(pStack);
        } else
            goto InvalidStoreType;
    }
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;
ErrorReturn:
    ClearCollectionStack(pStack);
    pEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
SET_ERROR(InvalidCollectionFindNext, E_INVALIDARG)
TRACE_ERROR(PushStackError)
TRACE_ERROR(CreateLinkElementError)
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}

STATIC PCONTEXT_ELEMENT FindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING ||
        pStore->dwState == STORE_STATE_CLOSING ||
        pStore->dwState == STORE_STATE_NULL);

    switch (pStore->dwStoreType) {
        case STORE_TYPE_CACHE:
            return FindElementInCacheStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        case STORE_TYPE_EXTERNAL:
            return FindElementInExternalStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        case STORE_TYPE_COLLECTION:
            return FindElementInCollectionStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        default:
            goto InvalidStoreType;
    }

ErrorReturn:
    return NULL;
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}

STATIC PCONTEXT_ELEMENT CheckAutoResyncAndFindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    if (NULL == pPrevEle && pStore->hAutoResyncEvent) {
        if (WAIT_OBJECT_0 == WaitForSingleObjectEx(
                pStore->hAutoResyncEvent,
                0,                          // dwMilliseconds
                FALSE                       // bAlertable
                ))
        CertControlStore(
            (HCERTSTORE) pStore,
            0,              // dwFlags
            CERT_STORE_CTRL_RESYNC,
            &pStore->hAutoResyncEvent
            );
    }

    return FindElementInStore(
        pStore,
        dwContextType,
        pFindInfo,
        pPrevEle
        );
}

//+=========================================================================
//  Add Element Functions
//==========================================================================

STATIC void SetFindInfoToFindExisting(
    IN PCONTEXT_ELEMENT pEle,
    IN OUT PCERT_STORE_PROV_FIND_INFO pFindInfo
    )
{
    memset(pFindInfo, 0, sizeof(*pFindInfo));
    pFindInfo->cbSize = sizeof(*pFindInfo);
    pFindInfo->dwFindType = rgdwFindTypeToFindExisting[pEle->dwContextType];
    pFindInfo->pvFindPara = ToCertContext(pEle);
}


STATIC BOOL AddLinkContextToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pLinkEle = NULL;
    PCONTEXT_ELEMENT pGetEle = NULL;

    if (STORE_TYPE_CACHE != pStore->dwStoreType)
        goto InvalidStoreType;

    // Note, CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES or
    // CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES
    // isn't allowed for adding links
    if (!(CERT_STORE_ADD_NEW == dwAddDisposition ||
            CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
            CERT_STORE_ADD_NEWER == dwAddDisposition))
        goto InvalidAddDisposition;

    LockStore(pStore);
    if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        // Check if the context is already in the store.
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in the store
        SetFindInfoToFindExisting(pEle, &FindInfo);
        if (pGetEle = FindElementInCacheStore(
                pStore,
                pEle->dwContextType,
                &FindInfo,
                NULL                // pPrevEle
                )) {
            UnlockStore(pStore);
            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_NEWER:
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
                // fall through
            case CERT_STORE_ADD_REPLACE_EXISTING:
                if (DeleteContextElement(pGetEle))
                    // Try again. It shouldn't be in the store.
                    return AddLinkContextToCacheStore(
                        pStore,
                        pEle,
                        dwAddDisposition,
                        ppStoreEle);
                else {
                    // Provider didn't allow the delete
                    pGetEle = NULL;
                    goto DeleteError;
                }
                break;
            case CERT_STORE_ADD_USE_EXISTING:
                if (ppStoreEle)
                    *ppStoreEle = pGetEle;
                else
                    ReleaseContextElement(pGetEle);
                return TRUE;
                break;
            default:
                goto InvalidArg;
                break;
            }
            goto UnexpectedError;
        }
    }

    if (NULL == (pLinkEle = CreateLinkElement(pEle->dwContextType))) {
        UnlockStore(pStore);
        goto CreateLinkElementError;
    }

    AddRefContextElement(pEle);

    InitAndAddLinkContextElement(
        pLinkEle,
        pStore,
        pEle
        );
    if (ppStoreEle) {
        AddRefContextElement(pLinkEle);
        *ppStoreEle = pLinkEle;
    }
    UnlockStore(pStore);
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidStoreType, E_INVALIDARG)
SET_ERROR(InvalidAddDisposition, E_INVALIDARG)
SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
TRACE_ERROR(DeleteError)
TRACE_ERROR(CreateLinkElementError)
}

// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the cache store.
STATIC BOOL AddElementToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pGetEle = NULL;
    PCONTEXT_ELEMENT pCollectionEle;
    PCERT_STORE pCollectionStore = NULL;
    const DWORD dwStoreProvWriteIndex =
        rgdwStoreProvWriteIndex[pEle->dwContextType];
    PFN_CERT_STORE_PROV_WRITE_CERT pfnStoreProvWriteCert;

    BOOL fUpdateKeyId;

    LockStore(pStore);
    assert(STORE_STATE_DELETED != pStore->dwState &&
        STORE_STATE_CLOSED != pStore->dwState);
    if (STORE_STATE_NULL == pStore->dwState) {
        // CertCreate*Context, CertAddSerializedElementToStore
        // or CertAddEncoded*ToStore with hCertStore == NULL.
        pEle->dwFlags |= ELEMENT_DELETED_FLAG;
        dwAddDisposition = CERT_STORE_ADD_ALWAYS;
    }
    assert(CERT_STORE_ADD_NEW == dwAddDisposition ||
        CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
        CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
        CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES ==
            dwAddDisposition ||
        CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
        CERT_STORE_ADD_NEWER == dwAddDisposition ||
        CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES == dwAddDisposition);

    if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        // Check if the context is already in the store.
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in the store
        SetFindInfoToFindExisting(pEle, &FindInfo);
        if (pGetEle = FindElementInCacheStore(
                pStore,
                pEle->dwContextType,
                &FindInfo,
                NULL                // pPrevEle
                )) {
            UnlockStore(pStore);

            if (CERT_STORE_ADD_NEWER == dwAddDisposition ||
                    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES ==
                        dwAddDisposition) {
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
            }
            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING:
            case CERT_STORE_ADD_NEWER:
                if (DeleteContextElement(pGetEle))
                    // Try again. It shouldn't be in the store.
                    return AddElementToCacheStore(
                        pStore,
                        pEle,
                        dwAddDisposition,
                        ppStoreEle);
                else {
                    // Provider didn't allow the delete
                    pGetEle = NULL;
                    goto DeleteError;
                }
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_USE_EXISTING:
                // For USE_EXISTING, copy any new non-existing properties.
                // Otherwise, copy all properties, replacing existing
                // properties.
                if (!CopyProperties(
                        pEle,
                        pGetEle,
                        CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ?
                            COPY_PROPERTY_USE_EXISTING_FLAG : 0
                        ))
                    goto CopyPropertiesError;
                if (ppStoreEle) {
                    if (pStore != pEle->pStore) {
                        assert(STORE_TYPE_COLLECTION ==
                            pEle->pStore->dwStoreType);
                        if (NULL == (*ppStoreEle = CreateLinkElement(
                                pEle->dwContextType)))
                            goto CreateLinkElementError;
                        InitAndAddCollectionElement(
                            *ppStoreEle,
                            pEle->pStore,
                            pGetEle,
                            NULL                // pCollectionStack
                            );
                    } else
                        *ppStoreEle = pGetEle;
                } else
                    ReleaseContextElement(pGetEle);
                FreeContextElement(pEle);
                return TRUE;
                break;
            default:
                goto InvalidArg;
                break;
            }
            goto UnexpectedError;
        }
    }


    // The element doesn't exist in the store.
    // Check if we need to write through to the provider.
    if (pStore->StoreProvInfo.cStoreProvFunc >
            dwStoreProvWriteIndex  &&
        NULL != (pfnStoreProvWriteCert = (PFN_CERT_STORE_PROV_WRITE_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                dwStoreProvWriteIndex])) {
        // Don't ever call the provider holding a lock!!
        // Also, the caller is holding a reference count on the store.
        UnlockStore(pStore);
        if (!pfnStoreProvWriteCert(
                pStore->StoreProvInfo.hStoreProv,
                ToCertContext(pEle),
                (dwAddDisposition << 16) | CERT_STORE_PROV_WRITE_ADD_FLAG))
            goto StoreProvWriteError;
        LockStore(pStore);
        if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
            // Check if the certificate was added while the store was unlocked
            CERT_STORE_PROV_FIND_INFO FindInfo;

            // Check if the context element is already in the store
            SetFindInfoToFindExisting(pEle, &FindInfo);
            if (pGetEle = FindElementInCacheStore(
                    pStore,
                    pEle->dwContextType,
                    &FindInfo,
                    NULL                // pPrevEle
                    )) {
                // Try again
                UnlockStore(pStore);
                ReleaseContextElement(pGetEle);
                return AddElementToCacheStore(pStore, pEle, dwAddDisposition,
                    ppStoreEle);
            }
        }
    }

    pCollectionEle = NULL;
    fUpdateKeyId = (pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG) &&
        STORE_STATE_OPENING != pStore->dwState;
    if (pStore != pEle->pStore) {
        assert(STORE_TYPE_COLLECTION == pEle->pStore->dwStoreType);
        if (ppStoreEle) {
            if (NULL == (pCollectionEle =
                    CreateLinkElement(pEle->dwContextType))) {
                UnlockStore(pStore);
                goto CreateLinkElementError;
            }
            pCollectionStore = pEle->pStore;
        }

        // Update the element's store. This is needed when adding to a store in
        // a collection
        pEle->pProvStore = pStore;
        pEle->pStore = pStore;
        SetStoreHandle(pEle);
    }

    if (FindPropElement(pEle, CERT_ARCHIVED_PROP_ID))
        pEle->dwFlags |= ELEMENT_ARCHIVED_FLAG;

    // Finally, add the element to the store.
    AddContextElement(pEle);
    AddRefContextElement(pEle); // needed for fUpdateKeyId

    if (pCollectionEle) {
        assert(pCollectionStore && ppStoreEle);
        AddRefContextElement(pEle);
        UnlockStore(pStore);
        InitAndAddCollectionElement(
            pCollectionEle,
            pCollectionStore,
            pEle,
            NULL                // pCollectionStack
            );
        *ppStoreEle = pCollectionEle;
    } else {
        if (STORE_STATE_NULL == pStore->dwState) {
            if (ppStoreEle)
                // Since the NULL store doesn't hold a reference, use it.
                *ppStoreEle = pEle;
            else
                ReleaseContextElement(pEle);
        } else if (ppStoreEle) {
            AddRefContextElement(pEle);
            *ppStoreEle = pEle;
        }
        UnlockStore(pStore);
    }
    fResult = TRUE;

    if (fUpdateKeyId)
        SetCryptKeyIdentifierKeyProvInfoProperty(pEle);
    ReleaseContextElement(pEle);

CommonReturn:
    return fResult;

ErrorReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
TRACE_ERROR(DeleteError)
TRACE_ERROR(CopyPropertiesError)
TRACE_ERROR(CreateLinkElementError)
TRACE_ERROR(StoreProvWriteError)
}


// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// The caller is holding a reference count on the store
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the external store.
STATIC BOOL AddElementToExternalStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;

    const DWORD dwStoreProvWriteIndex =
        rgdwStoreProvWriteIndex[pEle->dwContextType];
    PFN_CERT_STORE_PROV_WRITE_CERT pfnStoreProvWriteCert;
    PCONTEXT_ELEMENT pExternalEle = NULL;
    PCONTEXT_ELEMENT pCollectionEle = NULL;
    PCERT_STORE pEleStore;
    BOOL fUpdateKeyId;

    // Check if the store supports the write callback
    if (pStore->StoreProvInfo.cStoreProvFunc <=
            dwStoreProvWriteIndex  ||
        NULL == (pfnStoreProvWriteCert = (PFN_CERT_STORE_PROV_WRITE_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                dwStoreProvWriteIndex]))
        goto ProvWriteNotSupported;

    // Remember the Element's store.
    pEleStore = pEle->pStore;
    fUpdateKeyId = pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG;
    if (ppStoreEle) {
        if (NULL == (pExternalEle = CreateLinkElement(pEle->dwContextType)))
            goto CreateLinkElementError;
        if (pStore != pEleStore) {
            assert(STORE_TYPE_COLLECTION == pEleStore->dwStoreType);
            if (NULL == (pCollectionEle =
                    CreateLinkElement(pEle->dwContextType)))
                goto CreateLinkElementError;
        }
    }

    // Update the Element to use the NULL store.
    pEle->pProvStore = &NullCertStore;
    pEle->pStore = &NullCertStore;
    SetStoreHandle(pEle);

    // Also, the caller is holding a reference count on the store.
    if (!pfnStoreProvWriteCert(
            pStore->StoreProvInfo.hStoreProv,
            ToCertContext(pEle),
            (dwAddDisposition << 16) | CERT_STORE_PROV_WRITE_ADD_FLAG)) {
        // Restore the Element's store
        pEle->pProvStore = pEleStore;
        pEle->pStore = pEleStore;
        SetStoreHandle(pEle);
        goto StoreProvWriteError;
    }

    // Add to the NULL store
    pEle->dwFlags |= ELEMENT_DELETED_FLAG;
    AddContextElement(pEle);
    AddRefContextElement(pEle); // needed for fUpdateKeyId

    if (ppStoreEle) {
        InitAndAddExternalElement(
            pExternalEle,
            pStore,                 // pProvStore
            pEle,
            0,                      // dwFlags
            NULL                    // pvProvInfo
            );
        if (pStore != pEleStore) {
            InitAndAddCollectionElement(
                pCollectionEle,
                pEleStore,
                pExternalEle,
                NULL                // pCollectionStack
                );
            *ppStoreEle = pCollectionEle;
        } else
            *ppStoreEle = pExternalEle;
    } else
        ReleaseContextElement(pEle);

    if (fUpdateKeyId)
        SetCryptKeyIdentifierKeyProvInfoProperty(pEle);
    ReleaseContextElement(pEle);

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pExternalEle)
        FreeLinkElement(pExternalEle);
    if (pCollectionEle)
        FreeLinkElement(pCollectionEle);
    if (ppStoreEle)
        *ppStoreEle = NULL;
    goto CommonReturn;

TRACE_ERROR(CreateLinkElementError)
TRACE_ERROR(StoreProvWriteError)
SET_ERROR(ProvWriteNotSupported, E_NOTIMPL)
}



// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
STATIC BOOL AddElementToCollectionStore(
    IN PCERT_STORE pCollection,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCERT_STORE pOuterCollection;
    PCONTEXT_ELEMENT pGetEle = NULL;
    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pPrevStoreLink = NULL;
    DWORD dwAddErr;

    pOuterCollection = pEle->pStore;

    // Only need to do the find once for the outer most collection
    if (pOuterCollection == pCollection &&
            CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in any of the collection's
        // stores
        SetFindInfoToFindExisting(pEle, &FindInfo);

        // BUGBUG check negative side effects of setting fFindForAdd to
        // FALSE
        if (pGetEle = FindElementInCollectionStore(
                pCollection,
                pEle->dwContextType,
                &FindInfo,
                NULL,               // pPrevEle
                FALSE               // fFindForAdd
                )) {

            if (CERT_STORE_ADD_NEWER == dwAddDisposition ||
                    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES ==
                        dwAddDisposition) {
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
            }

            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING:
            case CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_USE_EXISTING:
            case CERT_STORE_ADD_NEWER:
            case CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES:
                // For success pEle will be used or freed by the called function
                // Add to either the cache or external store

                assert(STORE_TYPE_CACHE == pGetEle->pProvStore->dwStoreType ||
                    STORE_TYPE_EXTERNAL == pGetEle->pProvStore->dwStoreType);
                fResult = AddElementToStore(
                    pGetEle->pProvStore,
                    pEle,
                    dwAddDisposition,
                    ppStoreEle
                    );
                goto CommonReturn;
            default:
                goto InvalidArg;
                break;
            }
            goto UnexpectedError;
        }
    }

    // The element doesn't exist in any of the collection's stores.

    // Iterate and try to add to first where adding is allowed

    LockStore(pCollection);
    dwAddErr = E_ACCESSDENIED;
    pStoreLink = pCollection->pStoreListHead;
    for (; pStoreLink; pStoreLink = pStoreLink->pNext) {
        // Advance past deleted store links and links not enabling adds
        if ((pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG) ||
                0 == (pStoreLink->dwUpdateFlags &
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG))
            continue;

        AddRefStoreLink(pStoreLink);
        UnlockStore(pCollection);
        if (pPrevStoreLink)
            ReleaseStoreLink(pPrevStoreLink);
        pPrevStoreLink = pStoreLink;

        if (AddElementToStore(
                pStoreLink->pSibling,
                pEle,
                dwAddDisposition,
                ppStoreEle
                )) {
            fResult = TRUE;
            goto CommonReturn;
        } else if (E_ACCESSDENIED == dwAddErr) {
            DWORD dwErr = GetLastError();
            if (0 != dwErr)
                dwAddErr = dwErr;
        }

        LockStore(pCollection);
    }
    UnlockStore(pCollection);
    goto NoAddEnabledStore;

CommonReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);
    if (pPrevStoreLink)
        ReleaseStoreLink(pPrevStoreLink);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (ppStoreEle)
        *ppStoreEle = NULL;
    goto CommonReturn;

SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
SET_ERROR_VAR(NoAddEnabledStore, dwAddErr)
}



// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the inner store
STATIC BOOL AddElementToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    // Check for valid disposition values
    if (!(CERT_STORE_ADD_NEW == dwAddDisposition ||
            CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES ==
                dwAddDisposition ||
            CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
            CERT_STORE_ADD_NEWER == dwAddDisposition ||
            CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES == dwAddDisposition)) {
        *ppStoreEle = NULL;
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    switch (pStore->dwStoreType) {
        case STORE_TYPE_CACHE:
            return AddElementToCacheStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        case STORE_TYPE_EXTERNAL:
            return AddElementToExternalStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        case STORE_TYPE_COLLECTION:
            return AddElementToCollectionStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        default:
            goto InvalidStoreType;
    }

ErrorReturn:
    return NULL;
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}

STATIC BOOL AddEncodedContextToStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    BYTE *pbAllocEncoded;

    if (NULL == pStore)
        pStore = &NullCertStore;

    fResult = FALSE;
    if (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)) {
        PCONTEXT_ELEMENT pEle;

        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        if (pEle = rgpfnCreateElement[dwContextType](
                pStore,
                dwCertEncodingType,
                pbAllocEncoded,
                cbEncoded
                )) {
            fResult = AddElementToStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            if (!fResult)
                FreeContextElement(pEle);
        } else
            PkiFree(pbAllocEncoded);
    }

    if (!fResult && ppStoreEle)
        *ppStoreEle = NULL;
    return fResult;
}

STATIC BOOL AddContextToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pSrcEle,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    BYTE *pbAllocEncoded;

    if (NULL == pStore)
        pStore = &NullCertStore;

    fResult = FALSE;
    if (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)) {
        PCONTEXT_ELEMENT pEle;

        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        if (pEle = rgpfnCreateElement[pSrcEle->dwContextType](
                pStore,
                dwCertEncodingType,
                pbAllocEncoded,
                cbEncoded
                )) {
            if (CopyProperties(
                    pSrcEle,
                    pEle,
                    COPY_PROPERTY_INHIBIT_PROV_SET_FLAG
                    ))
                fResult = AddElementToStore(
                    pStore,
                    pEle,
                    dwAddDisposition,
                    ppStoreEle
                    );
            if (!fResult)
                FreeContextElement(pEle);
        } else
            PkiFree(pbAllocEncoded);
    }
    if (!fResult && ppStoreEle)
        *ppStoreEle = NULL;
    return fResult;
}

//+=========================================================================
//  PROP_ELEMENT Functions
//==========================================================================

// pbData has already been allocated
STATIC PPROP_ELEMENT CreatePropElement(
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN BYTE *pbData,
    IN DWORD cbData
    )
{
    PPROP_ELEMENT pEle = NULL;

    // Allocate and initialize the prop element structure
    pEle = (PPROP_ELEMENT) PkiZeroAlloc(sizeof(PROP_ELEMENT));
    if (pEle == NULL) return NULL;
    pEle->dwPropId = dwPropId;
    pEle->dwFlags = dwFlags;
    pEle->pbData = pbData;
    pEle->cbData = cbData;
    pEle->pNext = NULL;
    pEle->pPrev = NULL;

    return pEle;
}

STATIC void FreePropElement(IN PPROP_ELEMENT pEle)
{
    if (pEle->dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
        HCRYPTPROV hProv = ((PCERT_KEY_CONTEXT) pEle->pbData)->hCryptProv;
        if (hProv && (pEle->dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG) == 0) {
            DWORD dwErr = GetLastError();
            CryptReleaseContext(hProv, 0);
            SetLastError(dwErr);
        }
    }
    PkiFree(pEle->pbData);
    PkiFree(pEle);
}

// Upon entry/exit: Store/Element is locked
STATIC PPROP_ELEMENT FindPropElement(
    IN PPROP_ELEMENT pPropEle,
    IN DWORD dwPropId
    )
{
    while (pPropEle) {
        if (pPropEle->dwPropId == dwPropId)
            return pPropEle;
        pPropEle = pPropEle->pNext;
    }

    return NULL;
}
STATIC PPROP_ELEMENT FindPropElement(
    IN PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    return FindPropElement(pCacheEle->Cache.pPropHead, dwPropId);
}

// Upon entry/exit: Store/Element is locked
STATIC void AddPropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    )
{
    // Insert property in the certificate/CRL/CTL's list of properties
    pPropEle->pNext = *ppPropHead;
    pPropEle->pPrev = NULL;
    if (*ppPropHead)
        (*ppPropHead)->pPrev = pPropEle;
    *ppPropHead = pPropEle;
}
STATIC void AddPropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    AddPropElement(&pCacheEle->Cache.pPropHead, pPropEle);
}


// Upon entry/exit: Store/Element is locked
STATIC void RemovePropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    )
{
    if (pPropEle->pNext)
        pPropEle->pNext->pPrev = pPropEle->pPrev;
    if (pPropEle->pPrev)
        pPropEle->pPrev->pNext = pPropEle->pNext;
    else if (pPropEle == *ppPropHead)
        *ppPropHead = pPropEle->pNext;
    // else
    //  Not on any list
}
STATIC void RemovePropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    RemovePropElement(&pCacheEle->Cache.pPropHead, pPropEle);
}


//+=========================================================================
//  Property Functions
//==========================================================================

// Upon entry/exit the store is locked
STATIC void DeleteProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId
    )
{
    PPROP_ELEMENT pPropEle;

    // Delete the property
    pPropEle = FindPropElement(*ppPropHead, dwPropId);
    if (pPropEle) {
        RemovePropElement(ppPropHead, pPropEle);
        FreePropElement(pPropEle);
    }
}
STATIC void DeleteProperty(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    )
{
    DeleteProperty(&pCacheEle->Cache.pPropHead, dwPropId);
}

//+-------------------------------------------------------------------------
//  Set the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL SetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData,
    IN BOOL fInhibitProvSet
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PPROP_ELEMENT pPropEle;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_CONTEXT KeyContext;

    if (dwPropId == 0 || dwPropId > CERT_LAST_USER_PROP_ID) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID ||
            dwPropId == CERT_KEY_SPEC_PROP_ID) {
        // Map to the CERT_KEY_CONTEXT_PROP_ID and update its
        // hCryptProv and/or dwKeySpec field(s).
        DWORD cbData = sizeof(KeyContext);
        if ((fResult = GetProperty(
                pCacheEle,
                CERT_KEY_CONTEXT_PROP_ID,
                &KeyContext,
                &cbData))) {
            if (dwPropId == CERT_KEY_SPEC_PROP_ID) {
                // Inhibit hCryptProv from being closed by the subsequent
                // DeleteProperty. Also, use the existing dwFlags.
                PPROP_ELEMENT pPropEle;
                pPropEle = FindPropElement(pCacheEle,
                    CERT_KEY_CONTEXT_PROP_ID);
                assert(pPropEle);
                if (pPropEle) {
                    dwFlags = pPropEle->dwFlags;
                    pPropEle->dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
                }
            }
        } else {
            memset(&KeyContext, 0, sizeof(KeyContext));
            KeyContext.cbSize = sizeof(KeyContext);
            if (pvData && dwPropId != CERT_KEY_SPEC_PROP_ID) {
                // Try to get the KeySpec from a CERT_KEY_PROV_INFO_PROP_ID.
                // Need to do without any locks.
                UnlockStore(pCacheStore);
                cbData = sizeof(DWORD);
                GetProperty(
                    pEle,
                    CERT_KEY_SPEC_PROP_ID,
                    &KeyContext.dwKeySpec,
                    &cbData);
                LockStore(pCacheStore);

                // Check if CERT_KEY_CONTEXT_PROP_ID was added while store
                // was unlocked.
                if (FindPropElement(pCacheEle, CERT_KEY_CONTEXT_PROP_ID)) {
                    // We now have a CERT_KEY_CONTEXT_PROP_ID property.
                    // Try again
                    UnlockStore(pCacheStore);
                    return SetProperty(
                        pEle,
                        dwPropId,
                        dwFlags,
                        pvData,
                        fInhibitProvSet
                        );
                }
            }
        }
        if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            KeyContext.hCryptProv = (HCRYPTPROV) pvData;
        } else {
            if (pvData)
                KeyContext.dwKeySpec = *((DWORD *) pvData);
            else
                KeyContext.dwKeySpec = 0;
        }
        if (fResult || pvData)
            // CERT_KEY_CONTEXT_PROP_ID exists or we are creating a
            // new CERT_KEY_CONTEXT_PROP_ID
            pvData = &KeyContext;
        dwPropId = CERT_KEY_CONTEXT_PROP_ID;
    } else if (dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
        if (pvData) {
            PCERT_KEY_CONTEXT pKeyContext = (PCERT_KEY_CONTEXT) pvData;
            if (pKeyContext->cbSize != sizeof(CERT_KEY_CONTEXT))
                goto InvalidArg;
        }
    } else if (!fInhibitProvSet) {
        // Check if we need to call the store provider's writethru function.
        // Note, since the above properties aren't persisted they don't
        // need to be checked.

        const DWORD dwStoreProvSetPropertyIndex =
            rgdwStoreProvSetPropertyIndex[pEle->dwContextType];
        PCERT_STORE pProvStore = pEle->pProvStore;
        PFN_CERT_STORE_PROV_SET_CERT_PROPERTY pfnStoreProvSetProperty;

        // Use provider store. May be in a collection.
        UnlockStore(pCacheStore);
        LockStore(pProvStore);

        if (dwStoreProvSetPropertyIndex <
                pProvStore->StoreProvInfo.cStoreProvFunc &&
            NULL != (pfnStoreProvSetProperty =
                (PFN_CERT_STORE_PROV_SET_CERT_PROPERTY)
                    pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                        dwStoreProvSetPropertyIndex])) {
            // Since we can't hold a lock while calling the provider function,
            // bump the store's provider reference count to inhibit the closing
            // of the store and freeing of the provider functions.
            //
            // When the store is closed, pStore->StoreProvInfo.cStoreProvFunc
            // is set to 0.
            AddRefStoreProv(pProvStore);
            UnlockStore(pProvStore);
#if 0
            // Slow down the provider while holding the provider reference
            // count.
            Sleep(1500);
#endif

            // Note: PFN_CERT_STORE_PROV_SET_CRL_PROPERTY has the same signature
            // except, PCCRL_CONTEXT replaces the PCCERT_CONTEXT parameter.
            fResult = pfnStoreProvSetProperty(
                    pProvStore->StoreProvInfo.hStoreProv,
                    ToCertContext(pEle->pEle),
                    dwPropId,
                    dwFlags,
                    pvData);
            LockStore(pProvStore);
            ReleaseStoreProv(pProvStore);
            UnlockStore(pProvStore);
            LockStore(pCacheStore);
            if (!fResult && !IS_CERT_HASH_PROP_ID(dwPropId) &&
                    0 == (dwFlags & CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG))
                goto StoreProvSetCertPropertyError;
            // else
            //  Silently ignore any complaints about setting the
            //  property.
        } else {
            UnlockStore(pProvStore);
            LockStore(pCacheStore);
        }
    }

    if (pvData != NULL) {
        // First, delete the property
        DeleteProperty(pCacheEle, dwPropId);

        if (dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
            cbEncoded = sizeof(CERT_KEY_CONTEXT);
            if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                goto OutOfMemory;
            memcpy(pbEncoded, (BYTE *) pvData, cbEncoded);
        } else if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            if (!AllocAndEncodeKeyProvInfo(
                    (PCRYPT_KEY_PROV_INFO) pvData,
                    &pbEncoded,
                    &cbEncoded
                    )) goto AllocAndEncodeKeyProvInfoError;
        } else {
            PCRYPT_DATA_BLOB pDataBlob = (PCRYPT_DATA_BLOB) pvData;
            cbEncoded = pDataBlob->cbData;
            if (cbEncoded) {
                if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                    goto OutOfMemory;
                memcpy(pbEncoded, pDataBlob->pbData, cbEncoded);
            }
        }

        if (NULL == (pPropEle = CreatePropElement(
                dwPropId,
                dwFlags,
                pbEncoded,
                cbEncoded))) goto CreatePropElementError;
        AddPropElement(pCacheEle, pPropEle);
        if (CERT_ARCHIVED_PROP_ID == dwPropId)
            pCacheEle->dwFlags |= ELEMENT_ARCHIVED_FLAG;

    } else {
        // Delete the property
        DeleteProperty(pCacheEle, dwPropId);
        if (CERT_ARCHIVED_PROP_ID == dwPropId)
            pCacheEle->dwFlags &= ~ELEMENT_ARCHIVED_FLAG;
    }

    fResult = TRUE;
CommonReturn:
    UnlockStore(pCacheStore);

    if (fResult && pvData && !fInhibitProvSet &&
            ((pCacheStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG) ||
                (pEle->pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG)))
        SetCryptKeyIdentifierKeyProvInfoProperty(
            pEle,
            dwPropId,
            pvData
            );
    return fResult;

ErrorReturn:
    PkiFree(pbEncoded);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(StoreProvSetCertPropertyError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AllocAndEncodeKeyProvInfoError)
TRACE_ERROR(CreatePropElementError)
}

STATIC BOOL AllocAndGetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void **ppvData,
    OUT DWORD *pcbData
    )
{
    BOOL fResult;
    void *pvData = NULL;
    DWORD cbData;
    if (!GetProperty(
            pEle,
            dwPropId,
            NULL,               // pvData
            &cbData)) goto GetPropertyError;
    if (cbData) {
        if (NULL == (pvData = PkiNonzeroAlloc(cbData))) goto OutOfMemory;
        if (!GetProperty(
                pEle,
                dwPropId,
                pvData,
                &cbData)) goto GetPropertyError;
    }
    fResult = TRUE;
CommonReturn:
    *ppvData = pvData;
    *pcbData = cbData;
    return fResult;

ErrorReturn:
    PkiFree(pvData);
    pvData = NULL;
    cbData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetPropertyError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Get the property for the specified element
//
//  Note the pEle's cache store may be locked on entry by the above
//  SetProperty for a CERT_KEY_CONTEXT_PROP_ID.
//--------------------------------------------------------------------------
STATIC BOOL GetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PCERT_STORE pProvStore;
    DWORD cbIn;

    if (pvData == NULL)
        cbIn = 0;
    else
        cbIn = *pcbData;
    *pcbData = 0;

    if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID ||
            dwPropId == CERT_KEY_SPEC_PROP_ID) {
        // These two properties are fields within CERT_KEY_CONTEXT_PROP_ID.

        BOOL fResult;
        CERT_KEY_CONTEXT KeyContext;
        DWORD cbData;
        BYTE *pbData;

        cbData = sizeof(KeyContext);
        fResult = GetProperty(
            pEle,
            CERT_KEY_CONTEXT_PROP_ID,
            &KeyContext,
            &cbData
            );
        if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            cbData = sizeof(HCRYPTPROV);
            pbData = (BYTE *) &KeyContext.hCryptProv;
        } else {
            if (!fResult) {
                // Try to get the dwKeySpec from the CERT_KEY_PROV_INFO_PROP_ID
                PCRYPT_KEY_PROV_INFO pInfo;
                if (fResult = AllocAndGetProperty(
                        pEle,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        (void **) &pInfo,
                        &cbData)) {
                    KeyContext.dwKeySpec = pInfo->dwKeySpec;
                    PkiFree(pInfo);
                }
            }
            cbData = sizeof(DWORD);
            pbData = (BYTE *) &KeyContext.dwKeySpec;
        }

        if (fResult) {
            *pcbData = cbData;
            if (cbIn < cbData) {
                if (pvData) {
                    SetLastError((DWORD) ERROR_MORE_DATA);
                    fResult = FALSE;
                }
            } else if (cbData)
                memcpy((BYTE *) pvData, pbData, cbData);
        }
        return fResult;
    } else if (dwPropId == CERT_ACCESS_STATE_PROP_ID) {
        DWORD dwAccessStateFlags;

        pProvStore = pEle->pProvStore;
        if ((pProvStore->dwFlags & CERT_STORE_READONLY_FLAG) ||
                (pProvStore->StoreProvInfo.dwStoreProvFlags &
                     CERT_STORE_PROV_NO_PERSIST_FLAG))
            dwAccessStateFlags = 0;
        else
            dwAccessStateFlags = CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;

        if ((pEle->pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG) ||
            (pProvStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG))
            dwAccessStateFlags |= CERT_ACCESS_STATE_SYSTEM_STORE_FLAG;

        *pcbData = sizeof(DWORD);
        if (cbIn < sizeof(DWORD)) {
            if (pvData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                return FALSE;
            }
        } else
            *((DWORD * ) pvData) = dwAccessStateFlags;
        return TRUE;
    }

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    PPROP_ELEMENT pPropEle = FindPropElement(pCacheEle, dwPropId);
    if (pPropEle) {
        BOOL fResult = TRUE;
        DWORD cbData = pPropEle->cbData;
        if (cbIn < cbData) {
            if (pvData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                fResult = FALSE;
            }
        } else if (cbData) {
            memcpy((BYTE *) pvData, pPropEle->pbData, cbData);
            if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID)
                DecodeKeyProvInfo((BYTE *) pvData);
        }
        UnlockStore(pCacheStore);
        *pcbData = cbData;
        return fResult;
    } else
        UnlockStore(pCacheStore);

    // We're here with property not found and store unlocked.

    // For CERT_*_HASH_PROP_ID: compute its hash and do a SetProperty
    if (IS_CERT_HASH_PROP_ID(dwPropId)) {
        BOOL fResult;
        PCERT_STORE pEleStore;

        BYTE *pbEncoded;
        DWORD cbEncoded;
        BYTE Hash[MAX_HASH_LEN];
        CRYPT_DATA_BLOB HashBlob;

        GetContextEncodedInfo(
            pEle,
            &pbEncoded,
            &cbEncoded
            );
        pEleStore = pEle->pStore;

        HashBlob.pbData = Hash;
        HashBlob.cbData = sizeof(Hash);
        if (CERT_SIGNATURE_HASH_PROP_ID == dwPropId)
            fResult = CryptHashToBeSigned(
                0,                              // hCryptProv
                GetContextEncodingType(pEle),
                pbEncoded,
                cbEncoded,
                Hash,
                &HashBlob.cbData);
        else
            fResult = CryptHashCertificate(
                0,                              // hCryptProv
                dwPropId == CERT_SHA1_HASH_PROP_ID ? CALG_SHA1 : CALG_MD5,
                0,                  //dwFlags
                pbEncoded,
                cbEncoded,
                Hash,
                &HashBlob.cbData);

        if (!fResult) {
            assert(HashBlob.cbData <= MAX_HASH_LEN);
            return FALSE;
        }
        assert(HashBlob.cbData);
        if (HashBlob.cbData == 0)
            return FALSE;
        if (!SetProperty(
                pEle,
                dwPropId,
                0,                      // dwFlags
                &HashBlob
                )) return FALSE;

        *pcbData = cbIn;
        return GetProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData);
    } else if (CERT_KEY_IDENTIFIER_PROP_ID == dwPropId) {
        *pcbData = cbIn;
        return GetKeyIdProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData);
    }

    // We're here with property not found and not a hash or KeyId property

    // Since the cache store may be locked when called from SetProperty for
    // a CERT_KEY_CONTEXT_PROP_ID and since this property isn't persisted,
    // don't look in the external store for this property.
    pProvStore = pEle->pProvStore;
    if (STORE_TYPE_EXTERNAL == pProvStore->dwStoreType &&
            CERT_KEY_CONTEXT_PROP_ID != dwPropId) {
        // Check if provider supports getting a non-cached property
        const DWORD dwStoreProvGetPropertyIndex =
            rgdwStoreProvGetPropertyIndex[pEle->dwContextType];
        PFN_CERT_STORE_PROV_GET_CERT_PROPERTY pfnStoreProvGetProperty;

        LockStore(pProvStore);
        if (dwStoreProvGetPropertyIndex <
                pProvStore->StoreProvInfo.cStoreProvFunc &&
                    NULL != (pfnStoreProvGetProperty =
                        (PFN_CERT_STORE_PROV_GET_CERT_PROPERTY)
                    pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                        dwStoreProvGetPropertyIndex])) {
            BOOL fResult;

            // Since we can't hold a lock while calling the provider
            // function, bump the store's provider reference count
            // to inhibit the closing of the store and freeing of
            // the provider functions.
            //
            // When the store is closed,
            // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
            AddRefStoreProv(pProvStore);
            UnlockStore(pProvStore);

            *pcbData = cbIn;
            fResult = pfnStoreProvGetProperty(
                pProvStore->StoreProvInfo.hStoreProv,
                ToCertContext(pEle->pEle),
                dwPropId,
                0,                  // dwFlags
                pvData,
                pcbData
                );
            LockStore(pProvStore);
            ReleaseStoreProv(pProvStore);
            UnlockStore(pProvStore);
            return fResult;
        }
    }

    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Serialize a Property
//--------------------------------------------------------------------------
STATIC BOOL SerializeProperty(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PPROP_ELEMENT pPropEle;

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    fResult = TRUE;
    for (pPropEle = pCacheEle->Cache.pPropHead; pPropEle;
                                            pPropEle = pPropEle->pNext) {
        if (pPropEle->dwPropId != CERT_KEY_CONTEXT_PROP_ID) {
            if(!WriteStoreElement(
                    h,
                    pfn,
                    GetContextEncodingType(pCacheEle),
                    pPropEle->dwPropId,
                    pPropEle->pbData,
                    pPropEle->cbData
                    )) {
                fResult = FALSE;
                break;
            }
        }
    }
    UnlockStore(pCacheStore);
    return(fResult);
}

//+-------------------------------------------------------------------------
//  Get the first or next PropId for the specified element.
//
//  Only enumerates cached properties. Doesn't try to enumerate any external
//  properties.
//
//  Set dwPropId = 0, to get the first. Returns 0, if no more properties.
//--------------------------------------------------------------------------
STATIC DWORD EnumProperties(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId
    )
{
    PPROP_ELEMENT pPropEle;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return 0;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (0 == dwPropId)
        pPropEle = pCacheEle->Cache.pPropHead;
    else {
        pPropEle = FindPropElement(pCacheEle, dwPropId);
        if (pPropEle)
            pPropEle = pPropEle->pNext;
    }

    if (pPropEle)
        dwPropId = pPropEle->dwPropId;
    else
        dwPropId = 0;
    UnlockStore(pCacheStore);
    return dwPropId;
}

STATIC BOOL CopyProperties(
    IN PCONTEXT_ELEMENT pSrcEle,
    IN PCONTEXT_ELEMENT pDstEle,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    DWORD dwPropId;

    if (dwFlags & COPY_PROPERTY_SYNC_FLAG) {
        // Delete any properties from the Dst element that don't exist
        // in the Src element.

        DWORD dwNextPropId;
        dwNextPropId = EnumProperties(pDstEle, 0);
        while (dwNextPropId) {
            PPROP_ELEMENT pPropEle;
            PCONTEXT_ELEMENT pSrcCacheEle;
            PCERT_STORE pSrcCacheStore;

            dwPropId = dwNextPropId;
            dwNextPropId = EnumProperties(pDstEle, dwNextPropId);

            // Don't delete hCryptProv or KeySpec or hash properties
            if (CERT_KEY_CONTEXT_PROP_ID == dwPropId ||
                    IS_CERT_HASH_PROP_ID(dwPropId))
                continue;
#ifdef CMS_PKCS7
            if (CERT_PUBKEY_ALG_PARA_PROP_ID == dwPropId)
                continue;
#endif  // CMS_PKCS7

            if (NULL == (pSrcCacheEle = GetCacheElement(pSrcEle)))
                continue;
            pSrcCacheStore = pSrcCacheEle->pStore;

            // Don't delete if the src also has the property
            LockStore(pSrcCacheStore);
            pPropEle = FindPropElement(pSrcCacheEle, dwPropId);
            UnlockStore(pSrcCacheStore);
            if (pPropEle)
                continue;

            SetProperty(
                pDstEle,
                dwPropId,
                0,                              // dwFlags
                NULL,                           // NULL deletes
                dwFlags & COPY_PROPERTY_INHIBIT_PROV_SET_FLAG // fInhibitProvSet
                );
        }
    }

    fResult = TRUE;
    dwPropId = 0;
    while (dwPropId = EnumProperties(pSrcEle, dwPropId)) {
        void *pvData;
        DWORD cbData;

        // Don't copy hCryptProv or KeySpec
        if (CERT_KEY_CONTEXT_PROP_ID == dwPropId)
            continue;
        if (dwFlags & COPY_PROPERTY_USE_EXISTING_FLAG) {
            PPROP_ELEMENT pPropEle;
            PCONTEXT_ELEMENT pDstCacheEle;
            PCERT_STORE pDstCacheStore;

            // For existing, don't copy any hash properties
            if (IS_CERT_HASH_PROP_ID(dwPropId))
                continue;

            if (NULL == (pDstCacheEle = GetCacheElement(pDstEle)))
                continue;
            pDstCacheStore = pDstCacheEle->pStore;

            // Don't copy if the destination already has the property
            LockStore(pDstCacheStore);
            pPropEle = FindPropElement(pDstCacheEle, dwPropId);
            UnlockStore(pDstCacheStore);
            if (pPropEle)
                continue;
        }

        if (!AllocAndGetProperty(
                pSrcEle,
                dwPropId,
                &pvData,
                &cbData)) {
            if (CRYPT_E_NOT_FOUND == GetLastError()) {
                // Its been deleted after we did the Enum. Start over
                // from the beginning.
                dwPropId = 0;
                continue;
            } else {
                fResult = FALSE;
                break;
            }
        } else {
            CRYPT_DATA_BLOB DataBlob;
            void *pvSetData;

            if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId)
                pvSetData = pvData;
            else {
                DataBlob.pbData = (BYTE *) pvData;
                DataBlob.cbData = cbData;
                pvSetData = &DataBlob;
            }
            fResult = SetProperty(
                pDstEle,
                dwPropId,
                0,                                              // dwFlags
                pvSetData,
                dwFlags & COPY_PROPERTY_INHIBIT_PROV_SET_FLAG // fInhibitProvSet
                );
            if (pvData)
                PkiFree(pvData);
            if (!fResult)
                break;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Get or set the caller properties for a store or KeyId element.
//
//  Upon entry/exit, properties are locked by caller.
//--------------------------------------------------------------------------
STATIC BOOL GetCallerProperty(
    IN PPROP_ELEMENT pPropHead,
    IN DWORD dwPropId,
    BOOL fAlloc,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PPROP_ELEMENT pPropEle;
    DWORD cbData;
    void *pvDstData = NULL;

    if (NULL == (pPropEle = FindPropElement(pPropHead, dwPropId)))
        goto PropertyNotFound;

    if (dwPropId == CERT_KEY_CONTEXT_PROP_ID ||
            dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID)
        goto InvalidPropId;

    cbData = pPropEle->cbData;
    if (fAlloc) {
        if (cbData) {
            if (NULL == (pvDstData = PkiDefaultCryptAlloc(cbData)))
                goto OutOfMemory;
        }
        *((void **) pvData) = pvDstData;
    } else
        pvDstData = pvData;

    fResult = TRUE;
    if (pvDstData) {
        if (!fAlloc && *pcbData < cbData) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else if (cbData) {
            memcpy((BYTE *) pvDstData, pPropEle->pbData, cbData);
            if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID)
                DecodeKeyProvInfo((BYTE *) pvDstData);
        }
    }

CommonReturn:
    *pcbData = cbData;
    return fResult;

ErrorReturn:
    if (fAlloc) {
        *((void **) pvData) = NULL;
        PkiDefaultCryptFree(pvDstData);
    }
    cbData = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(PropertyNotFound, CRYPT_E_NOT_FOUND)
SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}

BOOL SetCallerProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    BOOL fResult;

    if (pvData != NULL) {
        DWORD cbEncoded;
        BYTE *pbEncoded;
        PPROP_ELEMENT pPropEle;

        // First, delete the property
        DeleteProperty(ppPropHead, dwPropId);

        if (dwPropId == CERT_KEY_CONTEXT_PROP_ID ||
                dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            goto InvalidPropId;
        } else if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            if (!AllocAndEncodeKeyProvInfo(
                    (PCRYPT_KEY_PROV_INFO) pvData,
                    &pbEncoded,
                    &cbEncoded
                    )) goto AllocAndEncodeKeyProvInfoError;
        } else {
            PCRYPT_DATA_BLOB pDataBlob = (PCRYPT_DATA_BLOB) pvData;
            cbEncoded = pDataBlob->cbData;
            if (cbEncoded) {
                if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                    goto OutOfMemory;
                memcpy(pbEncoded, pDataBlob->pbData, cbEncoded);
            }
        }

        if (NULL == (pPropEle = CreatePropElement(
                dwPropId,
                dwFlags,
                pbEncoded,
                cbEncoded))) {
            PkiFree(pbEncoded);
            goto CreatePropElementError;
        }
        AddPropElement(ppPropHead, pPropEle);
    } else
        // Delete the property
        DeleteProperty(ppPropHead, dwPropId);

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(AllocAndEncodeKeyProvInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreatePropElementError)
}

//+-------------------------------------------------------------------------
//  CRYPT_KEY_PROV_INFO: Encode and Decode Functions
//--------------------------------------------------------------------------

#define ENCODE_LEN_ALIGN(Len)  ((Len + 7) & ~7)

STATIC BOOL AllocAndEncodeKeyProvInfo(
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    DWORD cbContainerName;
    DWORD cbProvName;

    PCRYPT_KEY_PROV_INFO pDstInfo;
    DWORD Off;
    DWORD cParam;
    PCRYPT_KEY_PROV_PARAM pParam;

    // Get overall length
    cbEncoded = sizeof(CRYPT_KEY_PROV_INFO) +
        pKeyProvInfo->cProvParam * sizeof(CRYPT_KEY_PROV_PARAM);

    for (cParam = pKeyProvInfo->cProvParam, pParam = pKeyProvInfo->rgProvParam;
                                            cParam > 0; cParam--, pParam++) {
        if (pParam->cbData)
            cbEncoded += ENCODE_LEN_ALIGN(pParam->cbData);
    }

    if (pKeyProvInfo->pwszContainerName) {
        cbContainerName = (wcslen(pKeyProvInfo->pwszContainerName) + 1) *
            sizeof(WCHAR);
        cbEncoded += ENCODE_LEN_ALIGN(cbContainerName);
    } else
        cbContainerName = 0;

    if (pKeyProvInfo->pwszProvName) {
        cbProvName = (wcslen(pKeyProvInfo->pwszProvName) + 1) *
            sizeof(WCHAR);
        cbEncoded += ENCODE_LEN_ALIGN(cbProvName);
    } else
        cbProvName = 0;

    assert(cbEncoded <= MAX_FILE_ELEMENT_DATA_LEN);

    // Allocate
    pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded);
    if (pbEncoded == NULL) {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }

    // Copy and convert pointers to offsets
    memcpy(pbEncoded, (BYTE *) pKeyProvInfo, sizeof(CRYPT_KEY_PROV_INFO));
    Off = sizeof(CRYPT_KEY_PROV_INFO);

    pDstInfo = (PCRYPT_KEY_PROV_INFO) pbEncoded;

    if (pKeyProvInfo->cProvParam) {
        PCRYPT_KEY_PROV_PARAM pDstParam;

        pDstParam = (PCRYPT_KEY_PROV_PARAM) (pbEncoded + Off);
        pDstInfo->rgProvParam = (PCRYPT_KEY_PROV_PARAM)(DWORD_PTR) Off;
        memcpy(pbEncoded + Off,
            (BYTE *) pKeyProvInfo->rgProvParam,
            pKeyProvInfo->cProvParam * sizeof(CRYPT_KEY_PROV_PARAM));

        Off += pKeyProvInfo->cProvParam * sizeof(CRYPT_KEY_PROV_PARAM);

        for (cParam = pKeyProvInfo->cProvParam,
             pParam = pKeyProvInfo->rgProvParam;
                                        cParam > 0;
                                            cParam--, pParam++, pDstParam++) {
            if (pParam->cbData) {
                memcpy(pbEncoded + Off, pParam->pbData,  pParam->cbData);
                pDstParam->pbData = (BYTE *)(DWORD_PTR) Off;
                Off += ENCODE_LEN_ALIGN(pParam->cbData);
            }
        }
    }

    if (cbContainerName) {
        memcpy(pbEncoded + Off, (BYTE *) pKeyProvInfo->pwszContainerName,
            cbContainerName);
        pDstInfo->pwszContainerName = (LPWSTR)(DWORD_PTR) Off;
        Off += ENCODE_LEN_ALIGN(cbContainerName);
    }
    if (cbProvName) {
        memcpy(pbEncoded + Off, (BYTE *) pKeyProvInfo->pwszProvName,
            cbProvName);
        pDstInfo->pwszProvName = (LPWSTR)(DWORD_PTR) Off;
        Off += ENCODE_LEN_ALIGN(cbProvName);
    }


    assert(Off == cbEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return TRUE;
}

// Converts offsets to pointers
STATIC void DecodeKeyProvInfo(
    IN OUT BYTE *pbData
    )
{
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pbData;
    DWORD_PTR Off;
    DWORD cParam;
    PCRYPT_KEY_PROV_PARAM pParam;

    // Convert offsets to pointers
    Off = (DWORD_PTR) pKeyProvInfo->pwszContainerName;
    if (Off)
        pKeyProvInfo->pwszContainerName = (LPWSTR) (pbData + Off);

    Off = (DWORD_PTR) pKeyProvInfo->pwszProvName;
    if (Off)
        pKeyProvInfo->pwszProvName = (LPWSTR) (pbData + Off);

    Off = (DWORD_PTR) pKeyProvInfo->rgProvParam;
    if (Off)
        pKeyProvInfo->rgProvParam = (PCRYPT_KEY_PROV_PARAM) (pbData + Off);

    for (cParam = pKeyProvInfo->cProvParam, pParam = pKeyProvInfo->rgProvParam;
                                            cParam > 0; cParam--, pParam++) {
        Off = (DWORD_PTR) pParam->pbData;
        if (Off)
            pParam->pbData = (BYTE *) (pbData + Off);
    }

}


//+=========================================================================
//  KEYID_ELEMENT Functions
//==========================================================================

// pbKeyIdEncoded has already been allocated
STATIC PKEYID_ELEMENT CreateKeyIdElement(
    IN BYTE *pbKeyIdEncoded,
    IN DWORD cbKeyIdEncoded
    )
{
    PKEYID_ELEMENT pEle = NULL;

    // Allocate and initialize the prop element structure
    pEle = (PKEYID_ELEMENT) PkiZeroAlloc(sizeof(KEYID_ELEMENT));
    if (pEle == NULL) return NULL;
    pEle->KeyIdentifier.pbData = pbKeyIdEncoded;
    pEle->KeyIdentifier.cbData = cbKeyIdEncoded;

    return pEle;
}

STATIC void FreeKeyIdElement(IN PKEYID_ELEMENT pEle)
{
    PPROP_ELEMENT pPropEle;

    if (NULL == pEle)
        return;

    PkiFree(pEle->KeyIdentifier.pbData);

    // Free the Key Identifier's property elements
    while (pPropEle = pEle->pPropHead) {
        RemovePropElement(&pEle->pPropHead, pPropEle);
        FreePropElement(pPropEle);
    }
    PkiFree(pEle);
}

#ifdef CAPI_INCLUDE_PKCS7
//+-------------------------------------------------------------------------
//  Open Message Store Provider
//
//  Get Certs and CRLs from the message. pvPara contains the HCRYPTMSG
//  to read.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenMsgStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    HCRYPTMSG hCryptMsg = (HCRYPTMSG) pvPara;

    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cCert;
    DWORD cCrl;
    DWORD cbData;
    DWORD dwIndex;

    PCONTEXT_ELEMENT pCertEle;
    PCONTEXT_ELEMENT pCrlEle;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;

    // Get count of certificates and CRLs in the message
    cCert = 0;
    cbData = sizeof(cCert);
    fResult = CryptMsgGetParam(
        hCryptMsg,
        CMSG_CERT_COUNT_PARAM,
        0,                      // dwIndex
        &cCert,
        &cbData
        );
    if (!fResult) goto ErrorReturn;

    cCrl = 0;
    cbData = sizeof(cCrl);
    fResult = CryptMsgGetParam(
        hCryptMsg,
        CMSG_CRL_COUNT_PARAM,
        0,                      // dwIndex
        &cCrl,
        &cbData
        );
    if (!fResult) goto ErrorReturn;

    for (dwIndex = 0; dwIndex < cCert; dwIndex++) {
        if (NULL == (pbEncoded = (BYTE *) AllocAndGetMsgParam(
                hCryptMsg,
                CMSG_CERT_PARAM,
                dwIndex,
                &cbData))) goto ErrorReturn;

        pCertEle = CreateCertElement(
            pStore,
            dwEncodingType,
            pbEncoded,
            cbData
            );
        if (pCertEle == NULL)
            goto ErrorReturn;
        else {
            pbEncoded = NULL;
            AddContextElement(pCertEle);
        }
    }

    for (dwIndex = 0; dwIndex < cCrl; dwIndex++) {
        if (NULL == (pbEncoded = (BYTE *) AllocAndGetMsgParam(
                hCryptMsg,
                CMSG_CRL_PARAM,
                dwIndex,
                &cbData))) goto ErrorReturn;

        pCrlEle = CreateCrlElement(
            pStore,
            dwEncodingType,
            pbEncoded,
            cbData
            );
        if (pCrlEle == NULL)
            goto ErrorReturn;
        else {
            pbEncoded = NULL;
            AddContextElement(pCrlEle);
        }
    }

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    PkiFree(pbEncoded);
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Open PKCS #7 Signed Message Store Provider
//
//  Get Certs and CRLs from the message. pvPara points to a CRYPT_DATA_BLOB
//  containing the signed message.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenPKCS7StoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    PCRYPT_DATA_BLOB pMsg = (PCRYPT_DATA_BLOB) pvPara;
    HCRYPTMSG hMsg = NULL;
    DWORD dwMsgType;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;
    if (0 == GET_CMSG_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= PKCS_7_ASN_ENCODING;

    if (Asn1UtilIsPKCS7WithoutContentType(pMsg->pbData, pMsg->cbData))
        dwMsgType = CMSG_SIGNED;
    else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwEncodingType,
            0,                          // dwFlags
            dwMsgType,
            0,                          // hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto MsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsg,
            pMsg->pbData,
            pMsg->cbData,
            TRUE                    // fFinal
            )) goto MsgUpdateError;

    fResult = OpenMsgStoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) hMsg,
            hCertStore,
            pStoreProvInfo
            );
    // Set in above call
    //  pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;


CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(MsgOpenToDecodeError)
TRACE_ERROR(MsgUpdateError)
}

#endif

#ifdef CAPI_INCLUDE_SERIALIZED_STORE
STATIC BOOL LoadSerializedStore(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN DWORD cbReadSize,
    IN PCERT_STORE pStore
    )
{

    FILE_HDR FileHdr;
    DWORD   csStatus;

    if (!pfnRead(
            h,
            &FileHdr,
            sizeof(FileHdr)))
        return FALSE;

    if (FileHdr.dwVersion != CERT_FILE_VERSION_0 ||
        FileHdr.dwMagic != CERT_MAGIC) {
        SetLastError((DWORD) CRYPT_E_FILE_ERROR);
        return(FALSE);
    }

    while (CSContinue == (csStatus = LoadStoreElement(
            h,
            pfnRead,
            cbReadSize,
            pStore,
            CERT_STORE_ADD_ALWAYS,
            CERT_STORE_ALL_CONTEXT_FLAG,
            NULL,                           // pdwContextType
            NULL)))                         // ppvContext
        ;
    if(csStatus == CSError)
        return(FALSE);

    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Add the serialized store to the store.
//
//  Called from logstor.cpp for serialized registry stores
//--------------------------------------------------------------------------
BOOL WINAPI I_CertAddSerializedStore(
        IN HCERTSTORE hCertStore,
        IN BYTE *pbStore,
        IN DWORD cbStore
        )
{
    MEMINFO MemInfo;

    MemInfo.pByte = pbStore;
    MemInfo.cb = cbStore;
    MemInfo.cbSeek = 0;

    return LoadSerializedStore(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbStore,
        (PCERT_STORE) hCertStore
        );
}


//+-------------------------------------------------------------------------
//  Open Serialized Store Provider
//
//  pvPara points to a CRYPT_DATA_BLOB containing an in memory serialized
//  Store.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenSerializedStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvPara;

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;

    assert(pData);
    return I_CertAddSerializedStore(
        hCertStore,
        pData->pbData,
        pData->cbData
        );
}

//+=========================================================================
//  File Store Provider Functions
//==========================================================================

#define OPEN_FILE_FLAGS_MASK        (CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_FILE_STORE_COMMIT_ENABLE_FLAG)


//+-------------------------------------------------------------------------
//  File Store Provider handle information. Only applicable when the store
//  was opened with CERT_FILE_STORE_COMMIT_ENABLE_FLAG set in dwFlags.
//--------------------------------------------------------------------------
typedef struct _FILE_STORE {
    HCERTSTORE          hCertStore;         // not duplicated
    CRITICAL_SECTION    CriticalSection;
    HANDLE              hFile;
    DWORD               dwLoFilePointer;
    LONG                lHiFilePointer;
    DWORD               dwEncodingType;
    DWORD               dwSaveAs;
    BOOL                fTouched;      // set for write, delete or set property
} FILE_STORE, *PFILE_STORE;

//+-------------------------------------------------------------------------
//  Lock and unlock file functions
//--------------------------------------------------------------------------
static inline void LockFileStore(IN PFILE_STORE pFileStore)
{
    EnterCriticalSection(&pFileStore->CriticalSection);
}
static inline void UnlockFileStore(IN PFILE_STORE pFileStore)
{
    LeaveCriticalSection(&pFileStore->CriticalSection);
}

STATIC BOOL CommitFile(
    IN PFILE_STORE pFileStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fTouched;

    assert(pFileStore);
    LockFileStore(pFileStore);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pFileStore->fTouched;

    if (fTouched) {
        HANDLE hFile = pFileStore->hFile;
        DWORD dwLoFilePointer;
        LONG lHiFilePointer = pFileStore->lHiFilePointer;

        // Start the file overwrite at the same location as we started
        // the store read from the file.
        assert(hFile);
        dwLoFilePointer = SetFilePointer(
            hFile,
            (LONG) pFileStore->dwLoFilePointer,
            &lHiFilePointer,
            FILE_BEGIN
            );
        if (0xFFFFFFFF == dwLoFilePointer && NO_ERROR != GetLastError())
            goto SetFilePointerError;

        if (!CertSaveStore(
                pFileStore->hCertStore,
                pFileStore->dwEncodingType,
                pFileStore->dwSaveAs,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0))                     // dwFlags
            goto SaveStoreError;

        if (!SetEndOfFile(hFile))
            goto SetEndOfFileError;
    }
    pFileStore->fTouched = FALSE;
    fResult = TRUE;

CommonReturn:
    UnlockFileStore(pFileStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(SetFilePointerError)
TRACE_ERROR(SaveStoreError)
TRACE_ERROR(SetEndOfFileError)
}

//+-------------------------------------------------------------------------
//  File Store Provider Functions for stores opened with
//  CERT_FILE_STORE_COMMIT_ENABLE_FLAG set in dwFlags.
//
//  Note, since the CRL and CTL callbacks have the same signature as the
//  certificate callbacks and since we don't need to access the context
//  information, we can also use the certificate callbacks for CRLs and
//  CTLs.
//--------------------------------------------------------------------------
STATIC void WINAPI FileStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;

    if (pFileStore) {
        if (pFileStore->fTouched)
            CommitFile(
                pFileStore,
                0               // dwFlags
                );
#ifndef UNDER_CE	// WinCE does not have DuplicateHandle, so the handle is not ours to close
        if (pFileStore->hFile)
            CloseHandle(pFileStore->hFile);
#endif            
        DeleteCriticalSection(&pFileStore->CriticalSection);
        PkiFree(pFileStore);
    }
}

STATIC BOOL WINAPI FileStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}

STATIC BOOL WINAPI FileStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}

STATIC BOOL WINAPI FileStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}


STATIC BOOL WINAPI FileStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        )
{
    BOOL fResult;
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;

    switch (dwCtrlType) {
        case CERT_STORE_CTRL_COMMIT:
            fResult = CommitFile(pFileStore, dwFlags);
            break;
        default:
            goto NotSupported;
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}

static void * const rgpvFileStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    FileStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    NULL,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    NULL,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    NULL,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    FileStoreProvControl
};
#define FILE_STORE_PROV_FUNC_COUNT (sizeof(rgpvFileStoreProvFunc) / \
                                    sizeof(rgpvFileStoreProvFunc[0]))


STATIC BOOL OpenFileForCommit(
    IN HANDLE hFile,
    IN DWORD dwLoFilePointer,
    IN LONG lHiFilePointer,
    IN HCERTSTORE hCertStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveAs,
    IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
    )
{
    BOOL fResult;

    PFILE_STORE pFileStore;

    if (NULL == (pFileStore = (PFILE_STORE) PkiZeroAlloc(sizeof(FILE_STORE))))
        return FALSE;

#ifndef UNDER_CE
// Duplicate the file HANDLE
    if (!DuplicateHandle(
            GetCurrentProcess(),
            hFile,
            GetCurrentProcess(),
            &pFileStore->hFile,
            GENERIC_READ | GENERIC_WRITE,   // dwDesiredAccess
            FALSE,                          // bInheritHandle
            0                               // dwOptions
            ) || NULL == pFileStore->hFile)
        goto DuplicateFileError;
#else
	// CE doesnt support duplicate handle
	pFileStore->hFile = hFile;
	if (hFile == INVALID_HANDLE_VALUE)
		goto DuplicateFileError;
#endif

    pFileStore->hCertStore = hCertStore;
    InitializeCriticalSection(&pFileStore->CriticalSection);

    pFileStore->dwLoFilePointer = dwLoFilePointer;
    pFileStore->lHiFilePointer = lHiFilePointer;
    pFileStore->dwEncodingType = dwEncodingType;
    pFileStore->dwSaveAs = dwSaveAs;

    pStoreProvInfo->cStoreProvFunc = FILE_STORE_PROV_FUNC_COUNT;
    pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvFileStoreProvFunc;
    pStoreProvInfo->hStoreProv = (HCERTSTOREPROV) pFileStore;
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    PkiFree(pFileStore);
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DuplicateFileError)
}


//+-------------------------------------------------------------------------
//  Open File Store Provider
//
//  Get Certs and CRLs from the opened file. pvPara contains the opened
//  HANDLE of the file to read.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFileStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    HANDLE hFile = (HANDLE) pvPara;
    DWORD dwLoFilePointer = 0;
    LONG lHiFilePointer;
    DWORD cbReadSize;

    if (dwFlags & ~OPEN_FILE_FLAGS_MASK)
        goto InvalidArg;
    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG) {
        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto InvalidArg;
        // Get current file location. This is where we will start the
        // commits.
        lHiFilePointer = 0;
        dwLoFilePointer = SetFilePointer(
            hFile,
            0,                  // lDistanceToMove
            &lHiFilePointer,
            FILE_CURRENT
            );
        if (0xFFFFFFFF == dwLoFilePointer && NO_ERROR != GetLastError())
            goto SetFilePointerError;
    }

    cbReadSize = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbReadSize) goto FileError;
    fResult = LoadSerializedStore(
        hFile,
        ReadFromFile,
        cbReadSize,
        (PCERT_STORE) hCertStore
        );

    if (!fResult) {
        if (0 == GetFileSize(hFile, NULL))
            // Empty file
            fResult = TRUE;
    }

    if (fResult && (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG))
        fResult = OpenFileForCommit(
            hFile,
            dwLoFilePointer,
            lHiFilePointer,
            hCertStore,
            dwEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            pStoreProvInfo
            );
    else
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(SetFilePointerError)
TRACE_ERROR(FileError)
}

#endif // CAPI_INCLUDE_SERIALIZED_STORE

#ifdef CAPI_INCLUDE_FILENAME_STORE
//+-------------------------------------------------------------------------
//  Open Filename Store Provider (Unicode version)
//
//  Attempt to open a file containing a Store, a PKCS #7 signed
//  message or a single encoded certificate.
//
//  pvPara contains a LPCWSTR of the Filename.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFilenameStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPWSTR pwszFile = (LPWSTR) pvPara;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CRYPT_DATA_BLOB FileData;
    memset(&FileData, 0, sizeof(FileData));
    DWORD cbBytesRead;
    DWORD dwSaveAs = 0;
    HCERTSTORE hBase64CertStore = NULL;

    assert(pwszFile);
    if (dwFlags & ~OPEN_FILE_FLAGS_MASK)
        goto InvalidArg;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;
    if (0 == GET_CMSG_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= PKCS_7_ASN_ENCODING;

    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG) {
        DWORD dwCreate;

        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto InvalidArg;

        if (dwFlags & CERT_STORE_CREATE_NEW_FLAG)
            dwCreate = CREATE_NEW;
        else if (dwFlags & CERT_STORE_OPEN_EXISTING_FLAG)
            dwCreate = OPEN_EXISTING;
        else
            dwCreate = OPEN_ALWAYS;

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFile,
                  GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ,
                  NULL,                   // lpsa
                  dwCreate,
                  FILE_ATTRIBUTE_NORMAL,
                  NULL                    // hTemplateFile
                  )))
            goto CreateFileError;

        // Default to saving as a serialized store
        dwSaveAs = CERT_STORE_SAVE_AS_STORE;

        if (0 == GetFileSize(hFile, NULL)) {
            // Use file extension to determine dwSaveAs
            LPWSTR pwszExt;
            pwszExt = pwszFile + wcslen(pwszFile);
            while (pwszExt-- > pwszFile) {
                if (L'.' == *pwszExt) {
                    pwszExt++;
                    if (0 == _wcsicmp(pwszExt, L"p7c") ||
                            0 == _wcsicmp(pwszExt, L"spc"))
                        dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
                    break;
                }
            }
            goto CommitReturn;
        }
    } else {
        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFile,
                  GENERIC_READ,
                  FILE_SHARE_READ,
                  NULL,                   // lpsa
                  OPEN_EXISTING,
                  FILE_ATTRIBUTE_NORMAL,
                  NULL                    // hTemplateFile
                  )))
            goto CreateFileError;
    }

    if (OpenFileStoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) hFile,
            hCertStore,
            pStoreProvInfo)) {
        // For commit, we have already called OpenFileForCommit
        fResult = TRUE;
        goto OpenReturn;
    }

    // Read the entire file. Will attempt to process as either a
    // PKCS #7 or as a single cert.
    //
    // Will first try as binary. If that fails will try as base64 encoded.
    if (0 != SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
        goto FileError;
    FileData.cbData = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == FileData.cbData) goto FileError;
    if (0 == FileData.cbData)
        // Empty file
        goto CommitReturn;
    if (NULL == (FileData.pbData = (BYTE *) PkiNonzeroAlloc(FileData.cbData)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            FileData.pbData,
            FileData.cbData,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) goto FileError;

    if (OpenPKCS7StoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) &FileData,
            hCertStore,
            pStoreProvInfo)) {
        dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
        goto CommitReturn;
    }

    // Try to process as a single encoded certificate
    if (CertAddEncodedCertificateToStore(
            hCertStore,
            dwEncodingType,
            FileData.pbData,
            FileData.cbData,
            CERT_STORE_ADD_USE_EXISTING,
            NULL)) {
        if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
            goto CanNotCommitX509CertFileError;
        else
            goto CommitReturn;
    }

    // Try to process as a base64 encoded PKCS7 or single encoded certificate
    if (CryptQueryObject(
            CERT_QUERY_OBJECT_BLOB,
            &FileData,
            CERT_QUERY_CONTENT_FLAG_CERT | CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
            CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED,
            0,                                  // dwFlags
            NULL,                               // pdwMsgAndCertEncodingType
            NULL,                               // pdwContentType
            NULL,                               // pdwFormatType
            &hBase64CertStore,
            NULL,                               // phMsg
            NULL                                // ppvContext
            )) {
        fResult = I_CertSyncStore(hCertStore, hBase64CertStore);
        CertCloseStore(hBase64CertStore, 0);
        if (!fResult)
            goto SyncStoreError;
        if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
            goto CanNotCommitBase64FileError;
        else
            goto CommitReturn;
    }

    goto NoStoreOrPKCS7OrCertFileError;

CommitReturn:
    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
        fResult = OpenFileForCommit(
            hFile,
            0,                          // dwLoFilePointer
            0,                          // lHiFilePointer
            hCertStore,
            dwEncodingType,
            dwSaveAs,
            pStoreProvInfo
            );
    else {
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
        fResult = TRUE;
    }
OpenReturn:
    if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG) {
        CRYPT_DATA_BLOB Property;
        Property.pbData = (BYTE *) pwszFile;
        Property.cbData = (wcslen(pwszFile) + 1) * sizeof(WCHAR);
        CertSetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            0,                                  // dwFlags
            (const void *) &Property
            );
    }

CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (FileData.pbData)
        PkiFree(FileData.pbData);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(FileError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(CanNotCommitX509CertFileError, ERROR_ACCESS_DENIED)
SET_ERROR(CanNotCommitBase64FileError, ERROR_ACCESS_DENIED)
SET_ERROR(NoStoreOrPKCS7OrCertFileError, CRYPT_E_FILE_ERROR)
TRACE_ERROR(SyncStoreError)
}

//+-------------------------------------------------------------------------
//  Open Filename Store Provider (ASCII version)
//
//  Attempt to open a file containing a Store, a PKCS #7 signed
//  message or a single encoded certificate.
//
//  pvPara contains a LPCWSTR of the Filename.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFilenameStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPWSTR pwszFilename;
    assert(pvPara);
    if (NULL == (pwszFilename = MkWStr((LPSTR) pvPara)))
        fResult = FALSE;
    else {
        fResult = OpenFilenameStoreProvW(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) pwszFilename,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszFilename);
    }
    return fResult;
}
#endif // CAPI_INCLUDE_FILENAME_STORE

//+=========================================================================
//  CryptAcquireCertificatePrivateKey Support Functions
//==========================================================================

// Upon entry/exit, the Cache Store is locked.
//
// OUTs are only updated for success.
STATIC BOOL GetCacheKeyContext(
    IN PCONTEXT_ELEMENT pCacheEle,
    OUT HCRYPTPROV *phCryptProv,
    OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult = FALSE;
    PPROP_ELEMENT pPropEle;
    if (pPropEle = FindPropElement(pCacheEle, CERT_KEY_CONTEXT_PROP_ID)) {
        PCERT_KEY_CONTEXT pKeyContext =
            (PCERT_KEY_CONTEXT) pPropEle->pbData;
        assert(pKeyContext);
        assert(pPropEle->cbData >= sizeof(CERT_KEY_CONTEXT));
        if (pKeyContext->hCryptProv) {
            *phCryptProv = pKeyContext->hCryptProv;
            if (pdwKeySpec)
                *pdwKeySpec = pKeyContext->dwKeySpec;
            fResult = TRUE;
        }
    }
    return fResult;
}


STATIC PCRYPT_KEY_PROV_INFO GetKeyIdentifierKeyProvInfo(
    IN PCONTEXT_ELEMENT pCacheEle
    )
{
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    BYTE rgbKeyId[MAX_HASH_LEN];
    DWORD cbKeyId;
    CRYPT_HASH_BLOB KeyIdentifier;

    cbKeyId = sizeof(rgbKeyId);
    if(!GetProperty(
            pCacheEle,
            CERT_KEY_IDENTIFIER_PROP_ID,
            rgbKeyId,
            &cbKeyId
            ))
        return NULL;

    KeyIdentifier.pbData = rgbKeyId;
    KeyIdentifier.cbData = cbKeyId;

    if (CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            ))
        return pKeyProvInfo;

    // Try again, searching LocalMachine
    if (CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG | CRYPT_KEYID_MACHINE_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            ))
        return pKeyProvInfo;
    else
        return NULL;
}

STATIC BOOL AcquireKeyContext(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    IN OUT PCERT_KEY_CONTEXT pKeyContext,
    IN OUT BOOL *pfBadPubKey
    )
{
    BOOL fResult;
    DWORD dwAcquireFlags;
    DWORD dwIdx;

    dwAcquireFlags = pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID;
    pKeyContext->dwKeySpec = pKeyProvInfo->dwKeySpec;

    if (PROV_RSA_FULL == pKeyProvInfo->dwProvType &&
            (NULL == pKeyProvInfo->pwszProvName ||
                L'\0' == *pKeyProvInfo->pwszProvName))
        fResult = CryptAcquireContextU(
            &pKeyContext->hCryptProv,
            pKeyProvInfo->pwszContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            dwAcquireFlags
            );
    else
        fResult = FALSE;
    if (!fResult) {
        if (!CryptAcquireContextU(
                &pKeyContext->hCryptProv,
                pKeyProvInfo->pwszContainerName,
                pKeyProvInfo->pwszProvName,
                pKeyProvInfo->dwProvType,
                dwAcquireFlags
                )) {
            pKeyContext->hCryptProv = 0;
            goto AcquireContextError;
        }
    }

    for (dwIdx = 0; dwIdx < pKeyProvInfo->cProvParam; dwIdx++) {
        PCRYPT_KEY_PROV_PARAM pKeyProvParam = &pKeyProvInfo->rgProvParam[dwIdx];
        if (!CryptSetProvParam(
                pKeyContext->hCryptProv,
                pKeyProvParam->dwParam,
                pKeyProvParam->pbData,
                pKeyProvParam->dwFlags
                ))
            goto SetProvParamError;
    }


    if (dwFlags & CRYPT_ACQUIRE_COMPARE_KEY_FLAG) {
        if (!I_CertCompareCertAndProviderPublicKey(
                pCert,
                pKeyContext->hCryptProv,
                pKeyContext->dwKeySpec
                )) {
            *pfBadPubKey = TRUE;
            goto BadPublicKey;
        }
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    if (pKeyContext->hCryptProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(pKeyContext->hCryptProv, 0);
        SetLastError(dwErr);
        pKeyContext->hCryptProv = 0;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AcquireContextError)
TRACE_ERROR(SetProvParamError)
SET_ERROR(BadPublicKey, NTE_BAD_PUBLIC_KEY)
}

//+-------------------------------------------------------------------------
//  Acquire a HCRYPTPROV handle and dwKeySpec for the specified certificate
//  context. Uses the certificate's CERT_KEY_PROV_INFO_PROP_ID property.
//  The returned HCRYPTPROV handle may optionally be cached using the
//  certificate's CERT_KEY_CONTEXT_PROP_ID property.
//
//  If CRYPT_ACQUIRE_CACHE_FLAG is set, then, if an already acquired and
//  cached HCRYPTPROV exists for the certificate, its returned. Otherwise,
//  a HCRYPTPROV is acquired and then cached via the certificate's
//  CERT_KEY_CONTEXT_PROP_ID.
//
//  The CRYPT_ACQUIRE_USE_PROV_INFO_FLAG can be set to use the dwFlags field of
//  the certificate's CERT_KEY_PROV_INFO_PROP_ID property's CRYPT_KEY_PROV_INFO
//  data structure to determine if the returned HCRYPTPROV should be cached.
//  HCRYPTPROV caching is enabled if the CERT_SET_KEY_CONTEXT_PROP_ID flag was
//  set.
//
//  If CRYPT_ACQUIRE_COMPARE_KEY_FLAG is set, then,
//  the public key in the certificate is compared with the public
//  key returned by the cryptographic provider. If the keys don't match, the
//  acquire fails and LastError is set to NTE_BAD_PUBLIC_KEY. Note, if
//  a cached HCRYPTPROV is returned, the comparison isn't done. We assume the
//  comparison was done on the initial acquire.
//
//  *pfCallerFreeProv is returned set to FALSE for:
//    - Acquire or public key comparison fails.
//    - CRYPT_ACQUIRE_CACHE_FLAG is set.
//    - CRYPT_ACQUIRE_USE_PROV_INFO_FLAG is set AND
//      CERT_SET_KEY_CONTEXT_PROP_ID flag is set in the dwFlags field of the
//      certificate's CERT_KEY_PROV_INFO_PROP_ID property's
//      CRYPT_KEY_PROV_INFO data structure.
//  When *pfCallerFreeProv is FALSE, the caller must not release. The
//  returned HCRYPTPROV will be released on the last free of the certificate
//  context.
//
//  Otherwise, *pfCallerFreeProv is TRUE and the returned HCRYPTPROV must
//  be released by the caller by calling CryptReleaseContext.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptAcquireCertificatePrivateKey(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTPROV *phCryptProv,
    OUT OPTIONAL DWORD *pdwKeySpec,
    OUT OPTIONAL BOOL *pfCallerFreeProv
    )
{
    BOOL fResult;
    BOOL fCallerFreeProv;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    CERT_KEY_CONTEXT KeyContext;
    memset(&KeyContext, 0, sizeof(KeyContext));
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbData;
    BOOL fKeyIdentifier = FALSE;
    BOOL fBadPubKey = FALSE;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCert))))
        goto InvalidCert;
    pCacheStore = pCacheEle->pStore;

    if (dwFlags &
            (CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_USE_PROV_INFO_FLAG)) {
        // Attempt to use existing CERT_KEY_CONTEXT_PROP_ID property

        LockStore(pCacheStore);
        if (GetCacheKeyContext(
                pCacheEle,
                phCryptProv,
                pdwKeySpec
                )) {
            if (pfCallerFreeProv)
                *pfCallerFreeProv = FALSE;
            UnlockStore(pCacheStore);
            return TRUE;
        }
        UnlockStore(pCacheStore);
    }

    if (!AllocAndGetProperty(
            pCacheEle,
            CERT_KEY_PROV_INFO_PROP_ID,
            (void **) &pKeyProvInfo,
            &cbData)) {
        fKeyIdentifier = TRUE;
        if (NULL == (pKeyProvInfo = GetKeyIdentifierKeyProvInfo(pCacheEle)))
            goto NoKeyProperty;
    }

    if (!AcquireKeyContext(
            pCert,
            dwFlags,
            pKeyProvInfo,
            &KeyContext,
            &fBadPubKey
            )) {
        if (fKeyIdentifier)
            goto AcquireKeyContextError;

        PkiFree(pKeyProvInfo);
        fKeyIdentifier = TRUE;
        if (NULL == (pKeyProvInfo = GetKeyIdentifierKeyProvInfo(pCacheEle)))
            goto NoKeyProperty;

        if (!AcquireKeyContext(
                pCert,
                dwFlags,
                pKeyProvInfo,
                &KeyContext,
                &fBadPubKey
                ))
            goto AcquireKeyContextError;
    }


    fResult = TRUE;
    if ((dwFlags & CRYPT_ACQUIRE_CACHE_FLAG)
                        ||
        ((dwFlags & CRYPT_ACQUIRE_USE_PROV_INFO_FLAG) &&
            (pKeyProvInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID))) {
        // Cache the context.

        HCRYPTPROV hCryptProv;
        DWORD dwKeySpec;

        LockStore(pCacheStore);
        // First check that another thread hasn't already cached the context.
        if (GetCacheKeyContext(
                pCacheEle,
                &hCryptProv,
                &dwKeySpec
                )) {
            CryptReleaseContext(KeyContext.hCryptProv, 0);
            KeyContext.hCryptProv = hCryptProv;
            KeyContext.dwKeySpec = dwKeySpec;
        } else {
            KeyContext.cbSize = sizeof(KeyContext);
            fResult = SetProperty(
                pCacheEle,
                CERT_KEY_CONTEXT_PROP_ID,
                0,                              // dwFlags
                (void *) &KeyContext,
                TRUE                            // fInhibitProvSet
                );
        }
        UnlockStore(pCacheStore);
        if (!fResult) goto SetKeyContextPropertyError;
        fCallerFreeProv = FALSE;
    } else
        fCallerFreeProv = TRUE;

CommonReturn:
    if (pKeyProvInfo) {
        if (fKeyIdentifier)
            PkiDefaultCryptFree(pKeyProvInfo);
        else
            PkiFree(pKeyProvInfo);
    }

    *phCryptProv = KeyContext.hCryptProv;
    if (pdwKeySpec)
        *pdwKeySpec = KeyContext.dwKeySpec;
    if (pfCallerFreeProv)
        *pfCallerFreeProv = fCallerFreeProv;
    return fResult;

ErrorReturn:
    if (fBadPubKey)
        SetLastError((DWORD) NTE_BAD_PUBLIC_KEY);
    if (KeyContext.hCryptProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(KeyContext.hCryptProv, 0);
        SetLastError(dwErr);
        KeyContext.hCryptProv = 0;
    }
    fResult = FALSE;
    fCallerFreeProv = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidCert, E_INVALIDARG)
SET_ERROR(NoKeyProperty, CRYPT_E_NO_KEY_PROPERTY)
TRACE_ERROR(AcquireKeyContextError)
TRACE_ERROR(SetKeyContextPropertyError)
}

//+=========================================================================
//  I_CertSyncStore Support Functions
//==========================================================================

// Returns FALSE if unable to do the find. For instance, OutOfMemory error.
STATIC BOOL FindElementInOtherStore(
    IN PCERT_STORE pOtherStore,
    IN DWORD dwContextType,
    IN PCONTEXT_ELEMENT pEle,
    OUT PCONTEXT_ELEMENT *ppOtherEle
    )
{
    PCONTEXT_ELEMENT pOtherEle;
    BYTE rgbHash[SHA1_HASH_LEN];
    DWORD cbHash;

    *ppOtherEle = NULL;

    cbHash = SHA1_HASH_LEN;
    if (!GetProperty(
            pEle,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            ) || SHA1_HASH_LEN != cbHash)
        return FALSE;

    assert(STORE_TYPE_CACHE == pOtherStore->dwStoreType);

    pOtherEle = NULL;
    // Enable fForceEnumArchived
    while (pOtherEle = FindElementInCacheStore(pOtherStore, dwContextType,
            &FindAnyInfo, pOtherEle, TRUE)) {
        BYTE rgbOtherHash[SHA1_HASH_LEN];
        DWORD cbOtherHash;

        cbOtherHash = SHA1_HASH_LEN;
        if (!GetProperty(
                pOtherEle,
                CERT_SHA1_HASH_PROP_ID,
                rgbOtherHash,
                &cbOtherHash
                ) || SHA1_HASH_LEN != cbOtherHash)
            return FALSE;
        if (0 == memcmp(rgbOtherHash, rgbHash, SHA1_HASH_LEN)) {
            *ppOtherEle = pOtherEle;
            return TRUE;
        }
    }

    return TRUE;
}

STATIC void AppendElementToDeleteList(
    IN PCONTEXT_ELEMENT pEle,
    IN OUT DWORD *pcDeleteList,
    IN OUT PCONTEXT_ELEMENT **pppDeleteList
    )
{
    DWORD cDeleteList = *pcDeleteList;
    PCONTEXT_ELEMENT *ppDeleteList = *pppDeleteList;

    if (ppDeleteList = (PCONTEXT_ELEMENT *) PkiRealloc(ppDeleteList,
            (cDeleteList + 1) * sizeof(PCONTEXT_ELEMENT))) {
        AddRefContextElement(pEle);
        ppDeleteList[cDeleteList] = pEle;
        *pcDeleteList = cDeleteList + 1;
        *pppDeleteList = ppDeleteList;
    }
}

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore
    )
{
    PCERT_STORE pOrigStore = (PCERT_STORE) hOriginalStore;
    PCERT_STORE pNewStore = (PCERT_STORE) hNewStore;

    DWORD cDeleteList = 0;
    PCONTEXT_ELEMENT *ppDeleteList = NULL;
    DWORD i;

    assert(STORE_TYPE_CACHE == pOrigStore->dwStoreType &&
        STORE_TYPE_CACHE == pNewStore->dwStoreType);

    if (STORE_TYPE_CACHE != pOrigStore->dwStoreType ||
            STORE_TYPE_CACHE != pNewStore->dwStoreType) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (pOrigStore->dwFlags & CERT_STORE_MANIFOLD_FLAG)
        ArchiveManifoldCertificatesInStore(pNewStore);

    // Loop through the original store's elements. If the context exists
    // in the new store, copy the new store's properties and delete from
    // the new store. Otherwise, put the original store's context on a
    // deferred delete list.
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pOrigEle = NULL;
        // Enable fForceEnumArchived
        while (pOrigEle = FindElementInCacheStore(pOrigStore, i, &FindAnyInfo,
                pOrigEle, TRUE)) {
            PCONTEXT_ELEMENT pNewEle;
            if (FindElementInOtherStore(pNewStore, i, pOrigEle, &pNewEle)) {
                if (pNewEle) {
                    CopyProperties(
                        pNewEle,
                        pOrigEle,
                        COPY_PROPERTY_INHIBIT_PROV_SET_FLAG |
                            COPY_PROPERTY_SYNC_FLAG
                        );
                    DeleteContextElement(pNewEle);
                } else
                    AppendElementToDeleteList(pOrigEle, &cDeleteList,
                        &ppDeleteList);
            }
            //
            // else
            //  Find failed due to OutOfMemory
        }
    }

    LockStore(pOrigStore);

    // Move any remaining contexts in the new store to the original store.
    // Note, append at the end of list and not at the beginning. Another
    // thread might have been enumerating the store. Its better to find
    // 2 copies of a renewed context instead of none.
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pNewEle;

        if (pNewEle = pNewStore->rgpContextListHead[i]) {
            PCONTEXT_ELEMENT pOrigEle;

            if (pOrigEle = pOrigStore->rgpContextListHead[i]) {
                // Append at end of original store
                while (pOrigEle->pNext)
                    pOrigEle = pOrigEle->pNext;
                pOrigEle->pNext = pNewEle;
                pNewEle->pPrev = pOrigEle;
            } else {
                // New entries in original store
                pOrigStore->rgpContextListHead[i] = pNewEle;
                pNewEle->pPrev = NULL;
            }

            for ( ; pNewEle; pNewEle = pNewEle->pNext) {
                // Update the elements obtained from the new store to
                // point to the original store
                pNewEle->pStore = pOrigStore;
                pNewEle->pProvStore = pOrigStore;
                SetStoreHandle(pNewEle);
            }

            // No contexts remain in new store
            pNewStore->rgpContextListHead[i] = NULL;
        }
    }

    UnlockStore(pOrigStore);

    // Delete any contexts in the deferred delete list from the original store
    while (cDeleteList--)
        DeleteContextElement(ppDeleteList[cDeleteList]);
    PkiFree(ppDeleteList);
    return TRUE;
}


#ifdef CAPI_INCLUDE_CTL

//+=========================================================================
//  SortedCTL APIs.
//==========================================================================

static const BYTE rgbSeqTag[] = {ASN1UTIL_TAG_SEQ, 0};
static const BYTE rgbSetTag[] = {ASN1UTIL_TAG_SET, 0};
static const BYTE rgbOIDTag[] = {ASN1UTIL_TAG_OID, 0};
static const BYTE rgbIntegerTag[] = {ASN1UTIL_TAG_INTEGER, 0};
static const BYTE rgbBooleanTag[] = {ASN1UTIL_TAG_BOOLEAN, 0};
static const BYTE rgbOctetStringTag[] = {ASN1UTIL_TAG_OCTETSTRING, 0};
static const BYTE rgbConstructedContext0Tag[] =
    {ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0, 0};
static const BYTE rgbChoiceOfTimeTag[] =
    {ASN1UTIL_TAG_UTC_TIME, ASN1UTIL_TAG_GENERALIZED_TIME, 0};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCtlPara[] = {
    // 0 - CertificateTrustList ::= SEQUENCE {
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - version                 CTLVersion DEFAULT v1,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //   2 - subjectUsage            SubjectUsage,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   3 - listIdentifier          ListIdentifier OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   4 - sequenceNumber          HUGEINTEGER OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //   5 - ctlThisUpdate           ChoiceOfTime,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbChoiceOfTimeTag,
    //   6 - ctlNextUpdate           ChoiceOfTime OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbChoiceOfTimeTag,
    //   7 - subjectAlgorithm        AlgorithmIdentifier,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   8 - trustedSubjects         TrustedSubjects OPTIONAL,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   9 - ctlExtensions           [0] EXPLICIT Extensions OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbConstructedContext0Tag,
};
#define CTL_SEQ_VALUE_INDEX         0
#define CTL_SUBJECT_ALG_VALUE_INDEX 7
#define CTL_SUBJECTS_VALUE_INDEX    8
#define CTL_EXTENSIONS_VALUE_INDEX  9
#define CTL_VALUE_COUNT             \
    (sizeof(rgExtractCtlPara) / sizeof(rgExtractCtlPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractExtPara[] = {
    // 0 - Extension ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - extnId              OBJECT IDENTIFIER,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - critical            BOOLEAN DEFAULT FALSE,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbBooleanTag,
    //   3 - extnValue           OCTETSTRING
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
};
#define EXT_OID_VALUE_INDEX         1
#define EXT_OCTETS_VALUE_INDEX      3
#define EXT_VALUE_COUNT             \
    (sizeof(rgExtractExtPara) / sizeof(rgExtractExtPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractTrustedSubjectPara[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - subjectIdentifier       SubjectIdentifier,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   2 - subjectAttributes	    Attributes OPTIONAL
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSetTag,
};
#define TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX      1
#define TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX      2
#define TRUSTED_SUBJECT_VALUE_COUNT                 \
    (sizeof(rgExtractTrustedSubjectPara) / \
        sizeof(rgExtractTrustedSubjectPara[0]))

// same as above, however, return content blob for subjectAttributes instead
// of its value blob
static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractTrustedSubjectPara2[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - subjectIdentifier       SubjectIdentifier,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   2 - subjectAttributes	    Attributes OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSetTag,
};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractAttributePara[] = {
    // 0 - Attribute ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - type  
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - values     AttributeSetValue
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSetTag,
};
#define ATTRIBUTE_OID_VALUE_INDEX                   1
#define ATTRIBUTE_VALUES_VALUE_INDEX                2
#define ATTRIBUTE_VALUE_COUNT                       \
    (sizeof(rgExtractAttributePara) / sizeof(rgExtractAttributePara[0]))



static const DWORD rgdwPrime[] = {
            // Bits - cHashBucket
        1,  //   0  - 0x00001 (1)
        2,  //   1  - 0x00002 (2)
        3,  //   2  - 0x00004 (4)
        7,  //   3  - 0x00008 (8)
       13,  //   4  - 0x00010 (16)
       31,  //   5  - 0x00020 (32)
       61,  //   6  - 0x00040 (64)
      127,  //   7  - 0x00080 (128)
      251,  //   8  - 0x00100 (256)
      509,  //   9  - 0x00200 (512)
     1021,  //  10  - 0x00400 (1024)
     2039,  //  11  - 0x00800 (2048)
     4093,  //  12  - 0x01000 (4096)
     8191,  //  13  - 0x02000 (8192)
    16381,  //  14  - 0x04000 (16384)
    32749,  //  15  - 0x08000 (32768)
    65521,  //  16  - 0x10000 (65536)
};

#define MIN_HASH_BUCKET_BITS    6
#define MIN_HASH_BUCKET_COUNT   (1 << MIN_HASH_BUCKET_BITS)
#define MAX_HASH_BUCKET_BITS    16
#define MAX_HASH_BUCKET_COUNT   (1 << MAX_HASH_BUCKET_BITS)

#define DEFAULT_BYTES_PER_CTL_ENTRY     100
#define DEFAULT_CTL_ENTRY_COUNT         256

STATIC DWORD GetHashBucketCount(
    IN DWORD cCtlEntry
    )
{
    DWORD cBits;

    if (MAX_HASH_BUCKET_COUNT <= cCtlEntry)
        cBits = MAX_HASH_BUCKET_BITS;
    else {
        DWORD cHashBucket = MIN_HASH_BUCKET_COUNT;

        cBits = MIN_HASH_BUCKET_BITS;
        while (cCtlEntry > cHashBucket) {
            cHashBucket = cHashBucket << 1;
            cBits++;
        }
        assert(cBits <= MAX_HASH_BUCKET_BITS);
    }
    return rgdwPrime[cBits];
}

STATIC DWORD GetHashBucketIndex(
    IN DWORD cHashBucket,
    IN BOOL fHashedIdentifier,
    IN const CRYPT_DATA_BLOB *pIdentifier
    )
{
    DWORD dwIndex;
    const BYTE *pb = pIdentifier->pbData;
    DWORD cb = pIdentifier->cbData;


    if (fHashedIdentifier) {
        if (4 <= cb)
            memcpy(&dwIndex, pb, 4);
        else
            dwIndex = 0;
    } else {
        dwIndex = 0;
        while (cb--) {
            if (dwIndex & 0x80000000)
                dwIndex = (dwIndex << 1) | 1;
            else
                dwIndex = dwIndex << 1;
            dwIndex += *pb++;
        }
    }
    if (0 == cHashBucket)
        return 0;
    else
        return dwIndex % cHashBucket;
}

// #define szOID_CTL                       "1.3.6.1.4.1.311.10.1"
static const BYTE rgbOIDCtl[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x01};
static const CRYPT_DER_BLOB EncodedOIDCtl = {
    sizeof(rgbOIDCtl), (BYTE *) rgbOIDCtl
};

// #define szOID_SORTED_CTL                "1.3.6.1.4.1.311.10.1.1"
static const BYTE rgbOIDSortedCtlExt[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x01, 0x01};
static const CRYPT_DER_BLOB EncodedOIDSortedCtlExt = {
    sizeof(rgbOIDSortedCtlExt), (BYTE *) rgbOIDSortedCtlExt
};


// The encoded OID only includes the content octets. Excludes the tag and
// length octets.
STATIC BOOL CompareEncodedOID(
    IN const CRYPT_DER_BLOB *pEncodedOID1,
    IN const CRYPT_DER_BLOB *pEncodedOID2
    )
{
    if (pEncodedOID1->cbData == pEncodedOID2->cbData &&
            0 == memcmp(pEncodedOID1->pbData, pEncodedOID2->pbData,
                    pEncodedOID1->cbData))
        return TRUE;
    else
        return FALSE;
}


STATIC BOOL ExtractSortedCtlExtValue(
    IN const CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT],
    OUT const BYTE **ppbSortedCtlExtValue,
    OUT DWORD *pcbSortedCtlExtValue,
    OUT const BYTE **ppbRemainExt,
    OUT DWORD *pcbRemainExt
    )
{
    BOOL fResult;
    const BYTE *pbEncodedExtensions;
    DWORD cbEncodedExtensions;
    const BYTE *pbEncodedSortedCtlExt;
    DWORD cbEncodedSortedCtlExt;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[EXT_VALUE_COUNT];
    LONG lSkipped;

    // Following points to the outer Extensions sequence
    pbEncodedExtensions = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData;
    cbEncodedExtensions = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].cbData;
    if (0 == cbEncodedExtensions)
        goto NoExtensions;

    // Step into the Extension sequence and get pointer to the first extension.
    // The returned cbEncodedSortedCtlExt includes all of the
    // extensions in the sequence.
    if (0 >= (lSkipped = Asn1UtilExtractContent(
            pbEncodedExtensions,
            cbEncodedExtensions,
            &cbEncodedSortedCtlExt,
            &pbEncodedSortedCtlExt
            )) || CMSG_INDEFINITE_LENGTH == cbEncodedSortedCtlExt ||
                (DWORD) lSkipped + cbEncodedSortedCtlExt !=
                    cbEncodedExtensions)
        goto InvalidExtensions;

    // Decode the first extension
    cValue = EXT_VALUE_COUNT;
    if (0 >= (lSkipped = Asn1UtilExtractValues(
            pbEncodedSortedCtlExt,
            cbEncodedSortedCtlExt,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractExtPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    // Check that the first extension is the SortedCtl extension
    if (!CompareEncodedOID(
            &rgValueBlob[EXT_OID_VALUE_INDEX],
            &EncodedOIDSortedCtlExt
            ))
        goto NoSortedCtlExtension;

    *ppbSortedCtlExtValue = rgValueBlob[EXT_OCTETS_VALUE_INDEX].pbData;
    *pcbSortedCtlExtValue = rgValueBlob[EXT_OCTETS_VALUE_INDEX].cbData;

    *ppbRemainExt = pbEncodedSortedCtlExt + lSkipped;
    *pcbRemainExt = cbEncodedSortedCtlExt - lSkipped;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    *ppbSortedCtlExtValue = NULL;
    *pcbSortedCtlExtValue = 0;
    *ppbRemainExt = NULL;
    *pcbRemainExt = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoExtensions, ERROR_INVALID_DATA)
SET_ERROR(InvalidExtensions, ERROR_INVALID_DATA)
TRACE_ERROR(ExtractValuesError)
SET_ERROR(NoSortedCtlExtension, ERROR_INVALID_DATA)
}


BOOL
WINAPI
SortedCtlInfoEncodeEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN PCTL_INFO pOrigCtlInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT OPTIONAL void *pvEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    PCTL_INFO pSortedCtlInfo = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    DWORD cCtlEntry;
    PCTL_ENTRY pSortedCtlEntry = NULL;
    DWORD cHashBucket;
    PHASH_BUCKET_ENTRY *ppHashBucketHead = NULL;
    PHASH_BUCKET_ENTRY pHashBucketEntry = NULL;

    DWORD cSortedExtension;
    PCERT_EXTENSION pSortedExtension = NULL;
    BYTE *pbSortedCtlExtValue = NULL;
    DWORD cbSortedCtlExtValue = 0;


    if (0 == (dwFlags & CRYPT_ENCODE_ALLOC_FLAG))
        goto InvalidArg;

    // Make a copy of the CtlInfo. We're going to re-order the CTL entries
    // and insert a szOID_SORTED_CTL extension.
    if (NULL == (pSortedCtlInfo = (PCTL_INFO) PkiNonzeroAlloc(
            sizeof(CTL_INFO))))
        goto OutOfMemory;
    memcpy(pSortedCtlInfo, pOrigCtlInfo, sizeof(CTL_INFO));
    cCtlEntry = pSortedCtlInfo->cCTLEntry;
    if (0 < cCtlEntry) {
        DWORD i;
        DWORD j;
        PCTL_ENTRY pCtlEntry;
        DWORD cOrigExtension;
        PCERT_EXTENSION pOrigExtension;

        BOOL fHashedIdentifier =
            dwFlags & CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG;
        DWORD dwSortedCtlExtFlags = fHashedIdentifier ?
            SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG : 0;
        DWORD dwMaxCollision = 0;

        cHashBucket = GetHashBucketCount(cCtlEntry);
        if (NULL == (ppHashBucketHead = (PHASH_BUCKET_ENTRY *) PkiZeroAlloc(
                sizeof(PHASH_BUCKET_ENTRY) * cHashBucket)))
            goto OutOfMemory;

        if (NULL == (pHashBucketEntry = (PHASH_BUCKET_ENTRY) PkiNonzeroAlloc(
                sizeof(HASH_BUCKET_ENTRY) * cCtlEntry)))
            goto OutOfMemory;

        // Iterate through the CTL entries and add to the appropriate
        // hash bucket.
        pCtlEntry = pSortedCtlInfo->rgCTLEntry;
        for (i = 0; i < cCtlEntry; i++) {
            DWORD HashBucketIndex;

            HashBucketIndex = GetHashBucketIndex(
                cHashBucket,
                fHashedIdentifier,
                &pCtlEntry[i].SubjectIdentifier
                );
            pHashBucketEntry[i].dwEntryIndex = i;
            pHashBucketEntry[i].pNext = ppHashBucketHead[HashBucketIndex];
            ppHashBucketHead[HashBucketIndex] = &pHashBucketEntry[i];
        }

        // Sort the entries according to the HashBucket order
        if (NULL == (pSortedCtlEntry = (PCTL_ENTRY) PkiNonzeroAlloc(
                sizeof(CTL_ENTRY) * cCtlEntry)))
            goto OutOfMemory;

        j = 0;
        for (i = 0; i < cHashBucket; i++) {
            DWORD dwCollision = 0;
            PHASH_BUCKET_ENTRY p;

            for (p = ppHashBucketHead[i]; p; p = p->pNext) {
                pSortedCtlEntry[j++] = pCtlEntry[p->dwEntryIndex];
                dwCollision++;
            }
            if (dwCollision > dwMaxCollision)
                dwMaxCollision = dwCollision;
        }
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "SortedCtlInfoEncodeEx:: cHashBucket: %d MaxCollision: %d Flags:: 0x%x\n",
            cHashBucket, dwMaxCollision, dwSortedCtlExtFlags);
#endif
        assert(j == cCtlEntry);
        pSortedCtlInfo->rgCTLEntry = pSortedCtlEntry;

        // Insert a SortedCtl extension
        cOrigExtension = pSortedCtlInfo->cExtension;
        pOrigExtension = pSortedCtlInfo->rgExtension;
        // Check if the first extension is the SortedCtl extension
        if (cOrigExtension && 0 == strcmp(pOrigExtension[0].pszObjId,
                szOID_SORTED_CTL)) {
            cOrigExtension--;
            pOrigExtension++;
        }

        cSortedExtension = cOrigExtension + 1;
        if (NULL == (pSortedExtension = (PCERT_EXTENSION) PkiNonzeroAlloc(
                sizeof(CERT_EXTENSION) * cSortedExtension)))
            goto OutOfMemory;

        if (cOrigExtension)
            memcpy(&pSortedExtension[1], pOrigExtension,
                sizeof(CERT_EXTENSION) * cOrigExtension);

        cbSortedCtlExtValue = SORTED_CTL_EXT_HASH_BUCKET_OFFSET +
            sizeof(DWORD) * (cHashBucket + 1);
        if (NULL == (pbSortedCtlExtValue = (BYTE *) PkiNonzeroAlloc(
                cbSortedCtlExtValue)))
            goto OutOfMemory;

        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_FLAGS_OFFSET,
            &dwSortedCtlExtFlags, sizeof(DWORD));
        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_COUNT_OFFSET,
            &cHashBucket, sizeof(DWORD));
        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_MAX_COLLISION_OFFSET,
            &dwMaxCollision, sizeof(DWORD));

        pSortedExtension[0].pszObjId = szOID_SORTED_CTL;
        pSortedExtension[0].fCritical = FALSE;
        pSortedExtension[0].Value.pbData = pbSortedCtlExtValue;
        pSortedExtension[0].Value.cbData = cbSortedCtlExtValue;

        pSortedCtlInfo->cExtension = cSortedExtension;
        pSortedCtlInfo->rgExtension = pSortedExtension;
    }

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            PKCS_CTL,
            pSortedCtlInfo,
            dwFlags,
            pEncodePara,
            (void *) &pbEncoded,
            &cbEncoded
            ))
        goto CtlInfoEncodeError;

    if (0 < cCtlEntry) {
        // Update the SortedCtl extension's array of hash bucket offsets

        // First, extract values for the encoded sequence of subjects
        // and extensions.

        DWORD i;
        DWORD cCtlValue;
        CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT];
        const BYTE *pbEncodedSubject;
        DWORD cbEncodedSubject;
        const BYTE *pbEncodedSortedCtlExtValue;
        DWORD cbEncodedSortedCtlExtValue;
        const BYTE *pbRemainExt;
        DWORD cbRemainExt;
        BYTE *pbEncodedHashBucketOffset;
        DWORD dwEncodedHashBucketOffset;

        cCtlValue = CTL_VALUE_COUNT;
        if (0 >= Asn1UtilExtractValues(
                pbEncoded,
                cbEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cCtlValue,
                rgExtractCtlPara,
                rgCtlValueBlob
                ))
            goto ExtractCtlValuesError;

        pbEncodedSubject = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData;
        cbEncodedSubject = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData;
        assert(pbEncodedSubject > pbEncoded);
        assert(cbEncodedSubject);

        assert(rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData);
        if (!ExtractSortedCtlExtValue(
                rgCtlValueBlob,
                &pbEncodedSortedCtlExtValue,
                &cbEncodedSortedCtlExtValue,
                &pbRemainExt,
                &cbRemainExt
                ))
            goto ExtractSortedCtlExtValueError;
        assert(cbEncodedSortedCtlExtValue == cbSortedCtlExtValue);
        pbEncodedHashBucketOffset = (BYTE *) pbEncodedSortedCtlExtValue +
            SORTED_CTL_EXT_HASH_BUCKET_OFFSET;

        for (i = 0; i < cHashBucket; i++) {
            PHASH_BUCKET_ENTRY p;

            dwEncodedHashBucketOffset = (DWORD)(pbEncodedSubject - pbEncoded);
            memcpy(pbEncodedHashBucketOffset, &dwEncodedHashBucketOffset,
                sizeof(DWORD));
            pbEncodedHashBucketOffset += sizeof(DWORD);

            // Advance through the encoded subjects for the current
            // hash bucket index
            for (p = ppHashBucketHead[i]; p; p = p->pNext) {
                LONG lTagLength;
                DWORD cbContent;
                const BYTE *pbContent;
                DWORD cbSubject;

                lTagLength = Asn1UtilExtractContent(
                    pbEncodedSubject,
                    cbEncodedSubject,
                    &cbContent,
                    &pbContent
                    );
                assert(lTagLength > 0 && CMSG_INDEFINITE_LENGTH != cbContent);
                cbSubject = cbContent + lTagLength;
                assert(cbEncodedSubject >= cbSubject);
                pbEncodedSubject += cbSubject;
                cbEncodedSubject -= cbSubject;
            }
        }

        assert(0 == cbEncodedSubject);
        assert(pbEncodedSubject ==
            rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData +
            rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData);
        assert(pbEncodedHashBucketOffset + sizeof(DWORD) ==
            pbEncodedSortedCtlExtValue + cbEncodedSortedCtlExtValue);
        dwEncodedHashBucketOffset = (DWORD)(pbEncodedSubject - pbEncoded);
        memcpy(pbEncodedHashBucketOffset, &dwEncodedHashBucketOffset,
            sizeof(DWORD));
    }

    *((BYTE **) pvEncoded) = pbEncoded;
    *pcbEncoded = cbEncoded;
    fResult = TRUE;

CommonReturn:
    PkiFree(pSortedCtlInfo);
    PkiFree(pSortedCtlEntry);
    PkiFree(ppHashBucketHead);
    PkiFree(pHashBucketEntry);
    PkiFree(pSortedExtension);
    PkiFree(pbSortedCtlExtValue);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        if (pbEncoded) {
            PFN_CRYPT_FREE pfnFree = PkiGetEncodeFreeFunction(pEncodePara);
            pfnFree(pbEncoded);
        }
        *((BYTE **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CtlInfoEncodeError)
TRACE_ERROR(ExtractCtlValuesError)
TRACE_ERROR(ExtractSortedCtlExtValueError)
}

STATIC BOOL CreateSortedCtlHashBuckets(
    IN OUT PSORTED_CTL_FIND_INFO pSortedCtlFindInfo
    )
{
    BOOL fResult;
    DWORD cHashBucket;
    DWORD *pdwHashBucketHead = NULL;
    PHASH_BUCKET_ENTRY pHashBucketEntry = NULL;
    DWORD cAllocEntry = 0;
    DWORD cEntry = 0;

    const BYTE *pbEncoded;
    DWORD cbEncoded;

#if DBG
    DWORD dwMaxCollision = 0;
#endif

    pbEncoded = pSortedCtlFindInfo->pbEncodedSubjects;
    cbEncoded = pSortedCtlFindInfo->cbEncodedSubjects;

    cHashBucket = GetHashBucketCount(cbEncoded / DEFAULT_BYTES_PER_CTL_ENTRY);
    if (NULL == (pdwHashBucketHead = (DWORD *) PkiZeroAlloc(
            sizeof(DWORD) * cHashBucket)))
        goto OutOfMemory;


    // Loop through the encoded trusted subjects. For each subject, create
    // hash bucket entry, calculate hash bucket index and insert.
    while (cbEncoded) {
        DWORD cValue;
        LONG lAllValues;
        DWORD HashBucketIndex;
        CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEncoded,
                cbEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara,
                rgValueBlob
                )))
            goto ExtractValuesError;

        if (cEntry == cAllocEntry) {
            PHASH_BUCKET_ENTRY pNewHashBucketEntry;

            cAllocEntry += DEFAULT_CTL_ENTRY_COUNT;
            if (NULL == (pNewHashBucketEntry = (PHASH_BUCKET_ENTRY) PkiRealloc(
                    pHashBucketEntry, sizeof(HASH_BUCKET_ENTRY) * cAllocEntry)))
                goto OutOfMemory;
            pHashBucketEntry = pNewHashBucketEntry;
        }

        if (0 == cEntry)
            // Entry[0] is used to indicate no entries for the indexed
            // HashBucket
            cEntry++;

        HashBucketIndex = GetHashBucketIndex(
            cHashBucket,
            FALSE,                  // fHashedIdentifier,
            &rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX]
            );

#if DBG
        {
            DWORD dwEntryIndex = pdwHashBucketHead[HashBucketIndex];
            DWORD dwCollision = 1;
            while (dwEntryIndex) {
                dwCollision++;
                dwEntryIndex = pHashBucketEntry[dwEntryIndex].iNext;
            }
            if (dwCollision > dwMaxCollision)
                dwMaxCollision = dwCollision;
        }
#endif

        pHashBucketEntry[cEntry].iNext = pdwHashBucketHead[HashBucketIndex];
        pHashBucketEntry[cEntry].pbEntry = pbEncoded;
        pdwHashBucketHead[HashBucketIndex] = cEntry;
        cEntry++;

        cbEncoded -= lAllValues;
        pbEncoded += lAllValues;
    }

#if DBG
    DbgPrintf(DBG_SS_CRYPT32,
        "CreateSortedCtlHashBuckets:: cEntry: %d cHashBucket: %d MaxCollision: %d\n",
        cEntry, cHashBucket, dwMaxCollision);
#endif

    pSortedCtlFindInfo->cHashBucket = cHashBucket;
    pSortedCtlFindInfo->pdwHashBucketHead = pdwHashBucketHead;
    pSortedCtlFindInfo->pHashBucketEntry = pHashBucketEntry;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    PkiFree(pdwHashBucketHead);
    PkiFree(pHashBucketEntry);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
TRACE_ERROR(OutOfMemory)
}


STATIC BOOL FastDecodeCtlSubjects(
    IN const BYTE *pbEncodedSubjects,
    IN DWORD cbEncodedSubjects,
    OUT DWORD *pcCTLEntry,
    OUT PCTL_ENTRY *ppCTLEntry
    )
{
    BOOL fResult;

    PCTL_ENTRY pAllocEntry = NULL;
    DWORD cAllocEntry;
    DWORD cbAllocEntry;

    DWORD cEntry = 0;
    PCTL_ENTRY pEntry;
    DWORD cbEntryEncoded;
    const BYTE *pbEntryEncoded;

    DWORD cAttr = 0;
    PCRYPT_ATTRIBUTE pAttr;

    DWORD cAttrValue = 0;
    PCRYPT_ATTR_BLOB pAttrValue;

    DWORD cValue;
    LONG lAllValues;

    // First: Loop through the encoded trusted subjects. Get total count of
    // Entries, Attributes and Values.
    cbEntryEncoded = cbEncodedSubjects;
    pbEntryEncoded = pbEncodedSubjects;
    while (cbEntryEncoded) {
        CRYPT_DER_BLOB rgEntryValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];
        DWORD cbAttrEncoded;
        const BYTE *pbAttrEncoded;

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEntryEncoded,
                cbEntryEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara2,
                rgEntryValueBlob
                )))
            goto ExtractEntryError;
        cEntry++;
        cbEntryEncoded -= lAllValues;
        pbEntryEncoded += lAllValues;

        cbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].cbData;
        pbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].pbData;
        while (cbAttrEncoded) {
            CRYPT_DER_BLOB rgAttrValueBlob[ATTRIBUTE_VALUE_COUNT];
            DWORD cbAttrValueEncoded;
            const BYTE *pbAttrValueEncoded;

            cValue = ATTRIBUTE_VALUE_COUNT;
            if (0 >= (lAllValues = Asn1UtilExtractValues(
                    pbAttrEncoded,
                    cbAttrEncoded,
                    ASN1UTIL_DEFINITE_LENGTH_FLAG,
                    &cValue,
                    rgExtractAttributePara,
                    rgAttrValueBlob
                    )))
                goto ExtractAttrError;
            cAttr++;
            cbAttrEncoded -= lAllValues;
            pbAttrEncoded += lAllValues;

            cbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].cbData;
            pbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].pbData;
            while (cbAttrValueEncoded) {
                LONG lTagLength;
                DWORD cbAttrValue;
                const BYTE *pbContent;

                lTagLength = Asn1UtilExtractContent(
                    pbAttrValueEncoded,
                    cbAttrValueEncoded,
                    &cbAttrValue,
                    &pbContent
                    );
                if (0 >= lTagLength ||
                        CMSG_INDEFINITE_LENGTH == cbAttrValue)
                    goto ExtractValueError;
                cbAttrValue += (DWORD) lTagLength;
                if (cbAttrValue > cbAttrValueEncoded)
                    goto ExtractValueError;
                cAttrValue++;
                cbAttrValueEncoded -= cbAttrValue;
                pbAttrValueEncoded += cbAttrValue;
            }
        }
    }

    cAllocEntry = cEntry;
    if (0 == cEntry)
        goto SuccessReturn;

    cbAllocEntry = cEntry * sizeof(CTL_ENTRY) +
        cAttr * sizeof(CRYPT_ATTRIBUTE) +
        cAttrValue * sizeof(CRYPT_ATTR_BLOB);

    if (NULL == (pAllocEntry = (PCTL_ENTRY) PkiZeroAlloc(cbAllocEntry)))
        goto OutOfMemory;

    pEntry = pAllocEntry;
    pAttr = (PCRYPT_ATTRIBUTE) (pEntry + cEntry);
    pAttrValue = (PCRYPT_ATTR_BLOB) (pAttr + cAttr);

    // Second: Loop through the encoded trusted subjects. Update the
    // allocated Entries, Attributes and Values data structures
    cbEntryEncoded = cbEncodedSubjects;
    pbEntryEncoded = pbEncodedSubjects;
    while (cbEntryEncoded) {
        CRYPT_DER_BLOB rgEntryValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];
        DWORD cbAttrEncoded;
        const BYTE *pbAttrEncoded;

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEntryEncoded,
                cbEntryEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara2,
                rgEntryValueBlob
                )))
            goto ExtractEntryError;
        cbEntryEncoded -= lAllValues;
        pbEntryEncoded += lAllValues;

        assert(0 != cEntry);
        if (0 == cEntry--)
            goto InvalidCountError;
        pEntry->SubjectIdentifier =
            rgEntryValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX];

        cbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].cbData;
        pbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].pbData;
        while (cbAttrEncoded) {
            CRYPT_DER_BLOB rgAttrValueBlob[ATTRIBUTE_VALUE_COUNT];
            DWORD cbAttrValueEncoded;
            const BYTE *pbAttrValueEncoded;

            ASN1encodedOID_t EncodedOid;
            BYTE *pbExtra;
            LONG lRemainExtra;

            cValue = ATTRIBUTE_VALUE_COUNT;
            if (0 >= (lAllValues = Asn1UtilExtractValues(
                    pbAttrEncoded,
                    cbAttrEncoded,
                    ASN1UTIL_DEFINITE_LENGTH_FLAG,
                    &cValue,
                    rgExtractAttributePara,
                    rgAttrValueBlob
                    )))
                goto ExtractAttrError;
            cbAttrEncoded -= lAllValues;
            pbAttrEncoded += lAllValues;

            assert(0 != cAttr);
            if (0 == cAttr--)
                goto InvalidCountError;

            if (0 == pEntry->cAttribute) {
                pEntry->cAttribute = 1;
                pEntry->rgAttribute = pAttr;
            } else
                pEntry->cAttribute++;

            EncodedOid.length = (ASN1uint16_t)
                rgAttrValueBlob[ATTRIBUTE_OID_VALUE_INDEX].cbData;
            EncodedOid.value =
                rgAttrValueBlob[ATTRIBUTE_OID_VALUE_INDEX].pbData;

            pbExtra = NULL;
            lRemainExtra = 0;
            I_CryptGetEncodedOID(
                &EncodedOid,
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &pAttr->pszObjId,
                &pbExtra,
                &lRemainExtra
                );

            cbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].cbData;
            pbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].pbData;
            while (cbAttrValueEncoded) {
                LONG lTagLength;
                DWORD cbAttrValue;
                const BYTE *pbContent;

                lTagLength = Asn1UtilExtractContent(
                    pbAttrValueEncoded,
                    cbAttrValueEncoded,
                    &cbAttrValue,
                    &pbContent
                    );
                if (0 >= lTagLength ||
                        CMSG_INDEFINITE_LENGTH == cbAttrValue)
                    goto ExtractValueError;
                cbAttrValue += (DWORD) lTagLength;
                if (cbAttrValue > cbAttrValueEncoded)
                    goto ExtractValueError;

                assert(0 != cAttrValue);
                if (0 == cAttrValue--)
                    goto InvalidCountError;

                if (0 == pAttr->cValue) {
                    pAttr->cValue = 1;
                    pAttr->rgValue = pAttrValue;
                } else
                    pAttr->cValue++;

                pAttrValue->cbData = cbAttrValue;
                pAttrValue->pbData = (BYTE *) pbAttrValueEncoded;
                pAttrValue++;

                cbAttrValueEncoded -= cbAttrValue;
                pbAttrValueEncoded += cbAttrValue;
            }

            pAttr++;
        }

        pEntry++;
    }

    assert(0 == cEntry && 0 == cAttr && 0 == cAttrValue);
        

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pcCTLEntry = cAllocEntry;
    *ppCTLEntry = pAllocEntry;
    return fResult;

ErrorReturn:
    PkiFree(pAllocEntry);
    pAllocEntry = NULL;
    cAllocEntry = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ExtractEntryError, ERROR_INVALID_DATA)
SET_ERROR(ExtractAttrError, ERROR_INVALID_DATA)
SET_ERROR(ExtractValueError, ERROR_INVALID_DATA)
SET_ERROR(InvalidCountError, ERROR_INVALID_DATA)
TRACE_ERROR(OutOfMemory)
}

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT FastCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN DWORD dwFlags
    )
{
    DWORD dwEncodingType;
    const BYTE *pbContent;                     // not allocated
    DWORD cbContent;
    PCTL_INFO pInfo = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCTL_CONTEXT pCtl;
    PCTL_CONTEXT_SUFFIX pCtlSuffix;             // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;   // not allocated

    const BYTE *pbCtlEncodedHdr;                // not allocated
    DWORD cbCtlEncodedHdr;
    BYTE *pbCtlReencodedHdr = NULL;
    DWORD cbCtlReencodedHdr;
    DWORD cCtlValue;
    CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT];
    const BYTE *pbEncodedSubjects;              // not allocated
    DWORD cbEncodedSubjects;
    const BYTE *pbSortedCtlExtValue;            // not allocated
    DWORD cbSortedCtlExtValue;
    const BYTE *pbRemainExt;                    // not allocated
    DWORD cbRemainExt;

    PCERT_EXTENSIONS pExtInfo = NULL;
    BYTE *pbAllocReencodedExt = NULL;
    BYTE *pbReencodedExt = NULL;                // not allocated
    DWORD cbReencodedExt;

    HCRYPTMSG hMsg = NULL;
    PCTL_ENTRY pCTLEntry = NULL;
    DWORD cCTLEntry;

    if (0 == (dwMsgAndCertEncodingType = GetCtlEncodingType(
             dwMsgAndCertEncodingType)))
        goto InvalidArg;

    // The message encoding type takes precedence
    dwEncodingType = (dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;

    // Advance to the encoded CTL_INFO
    if (0 >= Asn1UtilExtractPKCS7SignedDataContent(
            pbCtlEncoded,
            cbCtlEncoded,
            &EncodedOIDCtl,
            &cbContent,
            &pbContent
            ))
        goto ExtractSignedDataContentError;
    if (CMSG_INDEFINITE_LENGTH == cbContent)
        goto UnsupportedIndefiniteLength;

    // Get pointers to the encoded CTL_INFO values
    cCtlValue = CTL_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbContent,
            cbContent,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cCtlValue,
            rgExtractCtlPara,
            rgCtlValueBlob
            ))
        goto ExtractCtlValuesError;

    pbEncodedSubjects = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData;
    cbEncodedSubjects = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData;

    // Initialize pointer to and length of the Extensions sequence
    pbReencodedExt = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData;
    cbReencodedExt = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].cbData;

    // Get pointer to the first value in the CTL sequence. Get length
    // through the subjectAlgorithm value. Don't include the TrustedSubjects
    // or Extensions.

    pbCtlEncodedHdr = rgCtlValueBlob[CTL_SEQ_VALUE_INDEX].pbData;
    cbCtlEncodedHdr = (DWORD)(rgCtlValueBlob[CTL_SUBJECT_ALG_VALUE_INDEX].pbData +
        rgCtlValueBlob[CTL_SUBJECT_ALG_VALUE_INDEX].cbData -
        pbCtlEncodedHdr);

    // Re-encode the CTL excluding the TrustedSubjects and Extensions.
    // Re-encode the CTL sequence to have an indefinite length and terminated
    // with a NULL tag and length.
    cbCtlReencodedHdr = cbCtlEncodedHdr + 2 + 2;
    if (NULL == (pbCtlReencodedHdr = (BYTE *) PkiNonzeroAlloc(
            cbCtlReencodedHdr)))
        goto OutOfMemory;
    pbCtlReencodedHdr[0] = ASN1UTIL_TAG_SEQ;
    pbCtlReencodedHdr[1] = ASN1UTIL_LENGTH_INDEFINITE;
    memcpy(pbCtlReencodedHdr + 2, pbCtlEncodedHdr, cbCtlEncodedHdr);
    pbCtlReencodedHdr[cbCtlEncodedHdr + 2] = ASN1UTIL_TAG_NULL;
    pbCtlReencodedHdr[cbCtlEncodedHdr + 3] = ASN1UTIL_LENGTH_NULL;

    // Decode CTL_INFO excluding the TrustedSubjects and Extensions
    if (NULL == (pInfo = (PCTL_INFO) AllocAndDecodeObject(
                dwEncodingType,
                PKCS_CTL,
                pbCtlReencodedHdr,
                cbCtlReencodedHdr,
                0                       // dwFlags
                ))) goto DecodeCtlError;

    // Allocate and initialize the CTL element structure
    if (NULL == (pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) +
            sizeof(CTL_CONTEXT) + sizeof(CTL_CONTEXT_SUFFIX) +
            sizeof(SORTED_CTL_FIND_INFO))))
        goto OutOfMemory;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CTL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCtl = (PCTL_CONTEXT) ToCtlContext(pEle);
    pCtl->dwMsgAndCertEncodingType =
        dwMsgAndCertEncodingType;
    pCtl->pbCtlEncoded = (BYTE *) pbCtlEncoded;
    pCtl->cbCtlEncoded = cbCtlEncoded;
    pCtl->pCtlInfo = pInfo;
    pCtl->hCertStore = (HCERTSTORE) pStore;
    // pCtl->hCryptMsg = NULL;
    pCtl->pbCtlContent = (BYTE *) pbContent;
    pCtl->cbCtlContent = cbContent;

    pCtlSuffix = ToCtlContextSuffix(pEle);
    // pCtlSuffix->ppSortedEntry = NULL;
    pCtlSuffix->fFastCreate = TRUE;

    if (0 == (dwFlags & CERT_CREATE_CONTEXT_SORTED_FLAG)) {
        if (0 == (dwFlags & CERT_CREATE_CONTEXT_NO_ENTRY_FLAG)) {
            if (!FastDecodeCtlSubjects(
                    pbEncodedSubjects,
                    cbEncodedSubjects,
                    &cCTLEntry,
                    &pCTLEntry
                    ))
                goto FastDecodeCtlSubjectsError;
            pInfo->cCTLEntry = cCTLEntry;
            pInfo->rgCTLEntry = pCTLEntry;
            pCtlSuffix->pCTLEntry = pCTLEntry;
        }

        if (0 == (dwFlags & CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG)) {
            BOOL fResult;
            DWORD dwLastErr;
            HCRYPTPROV hProv = 0;
            DWORD dwProvFlags = 0;

            // Attempt to get the store's crypt provider. Serialize crypto
            // operations.
            hProv = GetCryptProv(pStore, &dwProvFlags);

            hMsg = CryptMsgOpenToDecode(
                    dwMsgAndCertEncodingType,
                    0,                          // dwFlags
                    0,                          // dwMsgType
                    hProv,
                    NULL,                       // pRecipientInfo
                    NULL                        // pStreamInfo
                    );
            if (hMsg && CryptMsgUpdate(
                    hMsg,
                    pbCtlEncoded,
                    cbCtlEncoded,
                    TRUE                    // fFinal
                    ))
                fResult = TRUE;
            else {
                fResult = FALSE;
                dwLastErr = GetLastError();
            }

            // For the store's crypt provider, release reference count. Leave
            // crypto operations critical section.
            ReleaseCryptProv(pStore, dwProvFlags);

            if (!fResult) {
                SetLastError(dwLastErr);
                goto MsgError;
            }

            pCtl->hCryptMsg = hMsg;
        }
    } else {
        pSortedCtlFindInfo = (PSORTED_CTL_FIND_INFO) ((BYTE *) pCtlSuffix +
            sizeof(CTL_CONTEXT_SUFFIX));
        pCtlSuffix->pSortedCtlFindInfo = pSortedCtlFindInfo;

        pSortedCtlFindInfo->pbEncodedSubjects = pbEncodedSubjects;
        pSortedCtlFindInfo->cbEncodedSubjects = cbEncodedSubjects;

        // Check if the CTL had the SORTED_CTL extension. If it does, update
        // the find info to point to the extension's hash bucket entry
        // offsets.
        if (ExtractSortedCtlExtValue(
                rgCtlValueBlob,
                &pbSortedCtlExtValue,
                &cbSortedCtlExtValue,
                &pbRemainExt,
                &cbRemainExt
                )) {
            DWORD dwCtlExtFlags;

            if (SORTED_CTL_EXT_HASH_BUCKET_OFFSET > cbSortedCtlExtValue)
                goto InvalidSortedCtlExtension;

            memcpy(&dwCtlExtFlags,
                pbSortedCtlExtValue + SORTED_CTL_EXT_FLAGS_OFFSET,
                sizeof(DWORD));
            pSortedCtlFindInfo->fHashedIdentifier =
                dwCtlExtFlags & SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG;

            memcpy(&pSortedCtlFindInfo->cHashBucket,
                pbSortedCtlExtValue + SORTED_CTL_EXT_COUNT_OFFSET,
                sizeof(DWORD));
            pSortedCtlFindInfo->pbEncodedHashBucket =
                pbSortedCtlExtValue + SORTED_CTL_EXT_HASH_BUCKET_OFFSET;

            if (MAX_HASH_BUCKET_COUNT < pSortedCtlFindInfo->cHashBucket ||
                SORTED_CTL_EXT_HASH_BUCKET_OFFSET +
                    (pSortedCtlFindInfo->cHashBucket + 1) * sizeof(DWORD) >
                        cbSortedCtlExtValue)
                goto InvalidSortedCtlExtension;

            if (0 == cbRemainExt)
                cbReencodedExt = 0;
            else {
                // Reencode the remaining extensions.
                // Re-encode the Extensions sequence to have an indefinite
                // length and terminated with a NULL tag and length.
                cbReencodedExt = cbRemainExt + 2 + 2;
                if (NULL == (pbAllocReencodedExt =
                        (BYTE *) PkiNonzeroAlloc(cbReencodedExt)))
                    goto OutOfMemory;
                pbReencodedExt = pbAllocReencodedExt;
                pbReencodedExt[0] = ASN1UTIL_TAG_SEQ;
                pbReencodedExt[1] = ASN1UTIL_LENGTH_INDEFINITE;
                memcpy(pbReencodedExt + 2, pbRemainExt, cbRemainExt);
                pbReencodedExt[cbRemainExt + 2] = ASN1UTIL_TAG_NULL;
                pbReencodedExt[cbRemainExt + 3] = ASN1UTIL_LENGTH_NULL;
            }
        } else if (cbEncodedSubjects) {
            if (!CreateSortedCtlHashBuckets(pSortedCtlFindInfo))
                goto CreateSortedCtlHashBucketsError;
        }
    }

    if (cbReencodedExt) {
        if (NULL == (pExtInfo = (PCERT_EXTENSIONS) AllocAndDecodeObject(
                dwEncodingType,
                X509_EXTENSIONS,
                pbReencodedExt,
                cbReencodedExt,
                0                       // dwFlags
                ))) goto DecodeExtError;
        pInfo->cExtension = pExtInfo->cExtension;
        pInfo->rgExtension = pExtInfo->rgExtension;
        pCtlSuffix->pExtInfo = pExtInfo;
    }

CommonReturn:
    PkiFree(pbCtlReencodedHdr);
    PkiFree(pbAllocReencodedExt);
    return pEle;
ErrorReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    PkiFree(pInfo);
    PkiFree(pExtInfo);
    PkiFree(pCTLEntry);

    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ExtractSignedDataContentError)
SET_ERROR(UnsupportedIndefiniteLength, ERROR_INVALID_DATA)
TRACE_ERROR(ExtractCtlValuesError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeCtlError)
TRACE_ERROR(DecodeExtError)
SET_ERROR(InvalidSortedCtlExtension, ERROR_INVALID_DATA)
TRACE_ERROR(CreateSortedCtlHashBucketsError)
TRACE_ERROR(FastDecodeCtlSubjectsError)
TRACE_ERROR(MsgError)
}

//+-------------------------------------------------------------------------
//  Creates the specified context from the encoded bytes. The created
//  context isn't put in a store.
//
//  dwContextType values:
//      CERT_STORE_CERTIFICATE_CONTEXT
//      CERT_STORE_CRL_CONTEXT
//      CERT_STORE_CTL_CONTEXT
//
//  If CERT_CREATE_CONTEXT_NOCOPY_FLAG is set, the created context points
//  directly to the pbEncoded instead of an allocated copy. See flag
//  definition for more details.
//
//  If CERT_CREATE_CONTEXT_SORTED_FLAG is set, the context is created
//  with sorted entries. This flag may only be set for CERT_STORE_CTL_CONTEXT.
//  Setting this flag implicitly sets CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG and
//  CERT_CREATE_CONTEXT_NO_ENTRY_FLAG. See flag definition for
//  more details.
//
//  If CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG is set, the context is created
//  without creating a HCRYPTMSG handle for the context. This flag may only be
//  set for CERT_STORE_CTL_CONTEXT.  See flag definition for more details.
//
//  If CERT_CREATE_CONTEXT_NO_ENTRY_FLAG is set, the context is created
//  without decoding the entries. This flag may only be set for
//  CERT_STORE_CTL_CONTEXT.  See flag definition for more details.
//
//  If unable to decode and create the context, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT, CRL_CONTEXT or
//  CTL_CONTEXT is returned. The context must be freed by the appropriate
//  free context API. The context can be duplicated by calling the
//  appropriate duplicate context API.
//--------------------------------------------------------------------------
const void *
WINAPI
CertCreateContext(
    IN DWORD dwContextType,
    IN DWORD dwEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_CREATE_CONTEXT_PARA pCreatePara
    )
{
    BYTE *pbAllocEncoded = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo = NULL;
    PCONTEXT_ELEMENT pStoreEle;                 // not allocated

    dwContextType--;
    if (CONTEXT_COUNT <= dwContextType)
        goto InvalidContextType;

    if (dwFlags & CERT_CREATE_CONTEXT_NOCOPY_FLAG) {
        if (NULL == (pNoCopyInfo = (PCONTEXT_NOCOPY_INFO) PkiZeroAlloc(
                sizeof(CONTEXT_NOCOPY_INFO))))
            goto OutOfMemory;
        if (pCreatePara && pCreatePara->cbSize >=
                offsetof(CERT_CREATE_CONTEXT_PARA, pfnFree) +
                    sizeof(pCreatePara->pfnFree)) {
            pNoCopyInfo->pfnFree = pCreatePara->pfnFree;
            if (pCreatePara->cbSize >=
                    offsetof(CERT_CREATE_CONTEXT_PARA, pvFree) +
                        sizeof(pCreatePara->pvFree) &&
                    pCreatePara->pvFree)
                pNoCopyInfo->pvFree = pCreatePara->pvFree;
            else
                pNoCopyInfo->pvFree = (void *) pbEncoded;
        }
    } else {
        if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
            goto OutOfMemory;
        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        pbEncoded = pbAllocEncoded;
    }

    if (CERT_STORE_CTL_CONTEXT - 1 == dwContextType)
        pEle = FastCreateCtlElement(
                &NullCertStore,
                dwEncodingType,
                pbEncoded,
                cbEncoded,
                dwFlags
                );
    else
        pEle = rgpfnCreateElement[dwContextType](
            &NullCertStore,
            dwEncodingType,
            (BYTE *) pbEncoded,
            cbEncoded
            );
    if (NULL == pEle)
        goto CreateElementError;

    pEle->pNoCopyInfo = pNoCopyInfo;

    if (!AddElementToStore(
            &NullCertStore,
            pEle,
            CERT_STORE_ADD_ALWAYS,
            &pStoreEle
            ))
        goto AddElementError;

CommonReturn:
    // Any To*Context would work
    return ToCertContext(pStoreEle);

ErrorReturn:
    if (pEle)
        FreeContextElement(pEle);
    else if (pNoCopyInfo) {
        if (pNoCopyInfo->pfnFree)
            pNoCopyInfo->pfnFree(pNoCopyInfo->pvFree);
        PkiFree(pNoCopyInfo);
    } else
        PkiFree(pbAllocEncoded);
    pStoreEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidContextType, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateElementError)
TRACE_ERROR(AddElementError)
}


STATIC BOOL IsTrustedSubject(
    IN PCRYPT_DATA_BLOB pSubjectIdentifier,
    IN OUT const BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT BOOL *pfTrusted,
    OUT OPTIONAL PCRYPT_DATA_BLOB pEncodedAttributes
    )
{
    const BYTE *pbEncoded = *ppbEncoded;
    DWORD cbEncoded = *pcbEncoded;
    DWORD cValue;
    LONG lAllValues;
    CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

    cValue = TRUSTED_SUBJECT_VALUE_COUNT;
    if (0 >= (lAllValues = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractTrustedSubjectPara,
            rgValueBlob
            ))) {
        *pfTrusted = FALSE;
        return FALSE;
    }
    if (pSubjectIdentifier->cbData ==
            rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX].cbData
                        &&
            0 == memcmp(pSubjectIdentifier->pbData,
                rgValueBlob[
                    TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX].pbData,
                pSubjectIdentifier->cbData)) {
        *pfTrusted = TRUE;
        if (pEncodedAttributes)
            *pEncodedAttributes =
                rgValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX];
    } else {
        cbEncoded -= lAllValues;
        *pcbEncoded = cbEncoded;
        pbEncoded += lAllValues;
        *ppbEncoded = pbEncoded;
        *pfTrusted = FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the SubjectIdentifier exists in the CTL. Optionally
//  returns a pointer to and byte count of the Subject's encoded attributes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFindSubjectInSortedCTL(
    IN PCRYPT_DATA_BLOB pSubjectIdentifier,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT OPTIONAL PCRYPT_DER_BLOB pEncodedAttributes
    )
{
    PCONTEXT_ELEMENT pCacheEle;                     // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;       // not allocated
    DWORD HashBucketIndex;
    BOOL fTrusted;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;

    if (NULL == (pSortedCtlFindInfo =
            ToCtlContextSuffix(pCacheEle)->pSortedCtlFindInfo))
        goto NotSortedCtlContext;

    HashBucketIndex = GetHashBucketIndex(
        pSortedCtlFindInfo->cHashBucket,
        pSortedCtlFindInfo->fHashedIdentifier,
        pSubjectIdentifier
        );

    if (pSortedCtlFindInfo->pbEncodedHashBucket) {
        DWORD dwEntryOffset[2];
        DWORD cbEncoded;
        const BYTE *pbEncoded;

        memcpy(dwEntryOffset, pSortedCtlFindInfo->pbEncodedHashBucket +
            sizeof(DWORD) * HashBucketIndex, sizeof(DWORD) * 2);

        if (dwEntryOffset[1] < dwEntryOffset[0] ||
                dwEntryOffset[1] > pCtlContext->cbCtlContent)
            goto InvalidSortedCtlExtension;

        // Iterate through the encoded TrustedSubjects until a match
        // or reached a TrustedSubject in the next HashBucket.
        cbEncoded = dwEntryOffset[1] - dwEntryOffset[0];
        pbEncoded = pCtlContext->pbCtlContent + dwEntryOffset[0];

        while (cbEncoded) {
            if (!IsTrustedSubject(
                    pSubjectIdentifier,
                    &pbEncoded,
                    &cbEncoded,
                    &fTrusted,
                    pEncodedAttributes))
                goto IsTrustedSubjectError;
            if (fTrusted)
                goto CommonReturn;
        }
    } else if (pSortedCtlFindInfo->pdwHashBucketHead) {
        DWORD dwEntryIndex;

        dwEntryIndex = pSortedCtlFindInfo->pdwHashBucketHead[HashBucketIndex];
        while (dwEntryIndex) {
            PHASH_BUCKET_ENTRY pHashBucketEntry;
            DWORD cbEncoded;
            const BYTE *pbEncoded;

            pHashBucketEntry =
                &pSortedCtlFindInfo->pHashBucketEntry[dwEntryIndex];
            pbEncoded = pHashBucketEntry->pbEntry;
            assert(pbEncoded >= pSortedCtlFindInfo->pbEncodedSubjects &&
                pbEncoded < pSortedCtlFindInfo->pbEncodedSubjects +
                    pSortedCtlFindInfo->cbEncodedSubjects);
            cbEncoded = (DWORD)(pSortedCtlFindInfo->cbEncodedSubjects -
                (pbEncoded - pSortedCtlFindInfo->pbEncodedSubjects));
            assert(cbEncoded);

            if (!IsTrustedSubject(
                    pSubjectIdentifier,
                    &pbEncoded,
                    &cbEncoded,
                    &fTrusted,
                    pEncodedAttributes))
                goto IsTrustedSubjectError;
            if (fTrusted)
                goto CommonReturn;

            dwEntryIndex = pHashBucketEntry->iNext;
        }
    }

    goto NotFoundError;

CommonReturn:
    return fTrusted;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    fTrusted = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
SET_ERROR(NotSortedCtlContext, E_INVALIDARG)
SET_ERROR(InvalidSortedCtlExtension, ERROR_INVALID_DATA)
TRACE_ERROR(IsTrustedSubjectError)
}


//+-------------------------------------------------------------------------
//  Enumerates through the sequence of TrustedSubjects in a CTL context
//  created with CERT_CREATE_CONTEXT_SORTED_FLAG set.
//
//  To start the enumeration, *ppvNextSubject must be NULL. Upon return,
//  *ppvNextSubject is updated to point to the next TrustedSubject in
//  the encoded sequence.
//
//  Returns FALSE for no more subjects or invalid arguments.
//
//  Note, the returned DER_BLOBs point directly into the encoded
//  bytes (not allocated, and must not be freed).
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSubjectInSortedCTL(
    IN PCCTL_CONTEXT pCtlContext,
    IN OUT void **ppvNextSubject,
    OUT OPTIONAL PCRYPT_DER_BLOB pSubjectIdentifier,
    OUT OPTIONAL PCRYPT_DER_BLOB pEncodedAttributes
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;                 // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;   // not allocated
    const BYTE *pbEncodedSubjects;
    const BYTE *pbEncoded;
    DWORD cbEncoded;
    DWORD cValue;
    LONG lAllValues;
    CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;

    if (NULL == (pSortedCtlFindInfo =
            ToCtlContextSuffix(pCacheEle)->pSortedCtlFindInfo))
        goto NotSortedCtlContext;

    cbEncoded = pSortedCtlFindInfo->cbEncodedSubjects;
    if (0 == cbEncoded)
        goto NotFoundError;

    pbEncodedSubjects = pSortedCtlFindInfo->pbEncodedSubjects;
    pbEncoded = *((const BYTE **) ppvNextSubject);
    if (NULL == pbEncoded)
        pbEncoded = pbEncodedSubjects;
    else if (pbEncoded < pbEncodedSubjects ||
            pbEncoded >= pbEncodedSubjects + cbEncoded)
        goto NotFoundError;
    else
        cbEncoded -= (DWORD)(pbEncoded - pbEncodedSubjects);

    cValue = TRUSTED_SUBJECT_VALUE_COUNT;
    if (0 >= (lAllValues = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractTrustedSubjectPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    if (pSubjectIdentifier)
        *pSubjectIdentifier =
            rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX];
    if (pEncodedAttributes)
        *pEncodedAttributes =
            rgValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX];

    pbEncoded += lAllValues;
    *((const BYTE **) ppvNextSubject) = pbEncoded;
    fResult = TRUE;
CommonReturn:
    return fResult;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    *ppvNextSubject = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
SET_ERROR(NotSortedCtlContext, E_INVALIDARG)
TRACE_ERROR(ExtractValuesError)
}

#endif	// CAPI_INCLUDE_CTL

//+=========================================================================
// Key Identifier Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Decode the Key Identifier and its properties.
//--------------------------------------------------------------------------
STATIC PKEYID_ELEMENT DecodeKeyIdElement(
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    PKEYID_ELEMENT pEle = NULL;
    DWORD csStatus;
    MEMINFO MemInfo;

    MemInfo.pByte = (BYTE *) pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    csStatus = LoadStoreElement(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbElement,
        NULL,                       // pStore
        0,                          // dwAddDisposition
        0,                          // dwContextTypeFlags
        NULL,                       // pdwContextType
        (const void **) &pEle,
        TRUE                        // fKeyIdAllowed
        );

    if (NULL == pEle && CSError != csStatus)
        SetLastError((DWORD) CRYPT_E_FILE_ERROR);

    return pEle;
}

STATIC BOOL SerializeKeyIdElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PKEYID_ELEMENT pEle
    )
{
    BOOL fResult;
    PPROP_ELEMENT pPropEle;

    for (pPropEle = pEle->pPropHead; pPropEle; pPropEle = pPropEle->pNext) {
        if (pPropEle->dwPropId != CERT_KEY_CONTEXT_PROP_ID) {
            if (!WriteStoreElement(
                    h,
                    pfn,
                    0,                      // dwEncodingType
                    pPropEle->dwPropId,
                    pPropEle->pbData,
                    pPropEle->cbData
                    ))
                goto WriteElementError;
        }
    }

    if (!WriteStoreElement(
            h,
            pfn,
            0,              // dwEncodingType
            FILE_ELEMENT_KEYID_TYPE,
            pEle->KeyIdentifier.pbData,
            pEle->KeyIdentifier.cbData
            ))
        goto WriteElementError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(WriteElementError);
}

//+-------------------------------------------------------------------------
//  Encode the Key Identifier and its properties.
//--------------------------------------------------------------------------
STATIC BOOL EncodeKeyIdElement(
    IN PKEYID_ELEMENT pEle,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    MEMINFO MemInfo;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;

    memset(&MemInfo, 0, sizeof(MemInfo));
    if (!SerializeKeyIdElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle
            ))
        goto SerializeKeyIdElementError;

    cbElement = MemInfo.cbSeek;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    MemInfo.pByte = pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    if (!SerializeKeyIdElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle
            ))
        goto SerializeKeyIdElementError;

    fResult = TRUE;
CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(SerializeKeyIdElementError)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Get the property for the specified Key Identifier.
//
//  The Key Identifier is the SHA1 hash of the encoded CERT_PUBLIC_KEY_INFO.
//  The Key Identifier for a certificate can be obtained by getting the
//  certificate's CERT_KEY_IDENTIFIER_PROP_ID. The
//  CryptCreateKeyIdentifierFromCSP API can be called to create the Key
//  Identifier from a CSP Public Key Blob.
//
//  A Key Identifier can have the same properties as a certificate context.
//  CERT_KEY_PROV_INFO_PROP_ID is the property of most interest.
//  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO
//  structure. Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData will exceed the size of the structure.
//
//  If CRYPT_KEYID_ALLOC_FLAG is set, then, *pvData is updated with a
//  pointer to allocated memory. LocalFree() must be called to free the
//  allocated memory.
//
//  By default, searches the CurrentUser's list of Key Identifiers.
//  CRYPT_KEYID_MACHINE_FLAG can be set to search the LocalMachine's list
//  of Key Identifiers. When CRYPT_KEYID_MACHINE_FLAG is set, pwszComputerName
//  can also be set to specify the name of a remote computer to be searched
//  instead of the local machine.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetKeyIdentifierProperty(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;

    PKEYID_ELEMENT pKeyIdEle = NULL;

    if (!ILS_ReadKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            &pbElement,
            &cbElement
            ))
        goto ReadKeyIdElementError;

    if (NULL == (pKeyIdEle = DecodeKeyIdElement(
            pbElement,
            cbElement
            )))
        goto DecodeKeyIdElementError;

    fResult = GetCallerProperty(
        pKeyIdEle->pPropHead,
        dwPropId,
        dwFlags & CRYPT_KEYID_ALLOC_FLAG ? TRUE : FALSE,
        pvData,
        pcbData
        );

CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    if (dwFlags & CRYPT_KEYID_ALLOC_FLAG)
        *((void **) pvData) = NULL;
    *pcbData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ReadKeyIdElementError)
TRACE_ERROR(DecodeKeyIdElementError)
}


//+-------------------------------------------------------------------------
//  Set the property for the specified Key Identifier.
//
//  For CERT_KEY_PROV_INFO_PROP_ID pvData points to the
//  CRYPT_KEY_PROV_INFO data structure. For all other properties, pvData
//  points to a CRYPT_DATA_BLOB.
//
//  Setting pvData == NULL, deletes the property.
//
//  Set CRYPT_KEYID_MACHINE_FLAG to set the property for a LocalMachine
//  Key Identifier. Set pwszComputerName, to select a remote computer.
//
//  If CRYPT_KEYID_DELETE_FLAG is set, the Key Identifier and all its
//  properties is deleted.
//
//  If CRYPT_KEYID_SET_NEW_FLAG is set, the set fails if the property already
//  exists. For an existing property, FALSE is returned with LastError set to
//  CRYPT_E_EXISTS.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSetKeyIdentifierProperty(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    IN const void *pvData
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;
    PKEYID_ELEMENT pKeyIdEle = NULL;

    if (dwFlags & CRYPT_KEYID_DELETE_FLAG) {
        return ILS_DeleteKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName
            );
    }

    if (!ILS_ReadKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            &pbElement,
            &cbElement
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto ReadKeyIdElementError;
    }

    if (NULL == pbElement) {
        BYTE *pbKeyIdEncoded;
        if (NULL == (pbKeyIdEncoded = (BYTE *) PkiNonzeroAlloc(
                pKeyIdentifier->cbData)))
            goto OutOfMemory;
        if (NULL == (pKeyIdEle = CreateKeyIdElement(
                pbKeyIdEncoded,
                pKeyIdentifier->cbData
                )))
            goto OutOfMemory;
    } else {
        if (NULL == (pKeyIdEle = DecodeKeyIdElement(
                pbElement,
                cbElement
                )))
            goto DecodeKeyIdElementError;
        }

        if (dwFlags & CRYPT_KEYID_SET_NEW_FLAG) {
            if (FindPropElement(pKeyIdEle->pPropHead, dwPropId))
                goto KeyIdExists;
    }

    if (!SetCallerProperty(
            &pKeyIdEle->pPropHead,
            dwPropId,
            dwFlags,
            pvData
            ))
        goto SetCallerPropertyError;

    PkiFree(pbElement);
    pbElement = NULL;

    if (!EncodeKeyIdElement(
            pKeyIdEle,
            &pbElement,
            &cbElement
            ))
        goto EncodeKeyIdElementError;

    if (!ILS_WriteKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            pbElement,
            cbElement
            ))
        goto WriteKeyIdElementError;

    fResult = TRUE;

CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ReadKeyIdElementError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(KeyIdExists, CRYPT_E_EXISTS)
TRACE_ERROR(DecodeKeyIdElementError)
TRACE_ERROR(SetCallerPropertyError)
TRACE_ERROR(EncodeKeyIdElementError)
TRACE_ERROR(WriteKeyIdElementError)
}

typedef struct _KEYID_ELEMENT_CALLBACK_ARG {
    DWORD                       dwPropId;
    DWORD                       dwFlags;
    void                        *pvArg;
    PFN_CRYPT_ENUM_KEYID_PROP   pfnEnum;
} KEYID_ELEMENT_CALLBACK_ARG, *PKEYID_ELEMENT_CALLBACK_ARG;

STATIC BOOL KeyIdElementCallback(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    BOOL fResult = TRUE;
    PKEYID_ELEMENT_CALLBACK_ARG pKeyIdArg =
        (PKEYID_ELEMENT_CALLBACK_ARG) pvArg;

    PKEYID_ELEMENT pKeyIdEle = NULL;
    PPROP_ELEMENT pPropEle;

    DWORD iProp;
    DWORD cProp = 0;
    DWORD *pdwPropId = NULL;
    void **ppvData = NULL;
    DWORD *pcbData = NULL;

    if (NULL == (pKeyIdEle = DecodeKeyIdElement(
            pbElement,
            cbElement
            )))
        goto DecodeKeyIdElementError;

    // Get number of properties
    cProp = 0;
    pPropEle = pKeyIdEle->pPropHead;
    for ( ; pPropEle; pPropEle = pPropEle->pNext) {
        if (pKeyIdArg->dwPropId) {
            if (pKeyIdArg->dwPropId == pPropEle->dwPropId) {
                cProp = 1;
                break;
            }
        } else
            cProp++;
    }

    if (0 == cProp) {
        if (0 == pKeyIdArg->dwPropId)
            fResult = pKeyIdArg->pfnEnum(
                pKeyIdentifier,
                0,                      // dwFlags
                NULL,                   // pvReserved
                pKeyIdArg->pvArg,
                0,                      // cProp
                NULL,                   // rgdwPropId
                NULL,                   // rgpvData
                NULL                    // rgcbData
                );
    } else {
        pdwPropId = (DWORD *) PkiZeroAlloc(cProp * sizeof(DWORD));
        ppvData = (void **) PkiZeroAlloc(cProp * sizeof(void *));
        pcbData = (DWORD *) PkiZeroAlloc(cProp * sizeof(DWORD));

        if (NULL == pdwPropId || NULL == ppvData || NULL == pcbData)
            goto OutOfMemory;

        iProp = 0;
        pPropEle = pKeyIdEle->pPropHead;
        for ( ; pPropEle; pPropEle = pPropEle->pNext) {
            if (pKeyIdArg->dwPropId &&
                    pKeyIdArg->dwPropId != pPropEle->dwPropId)
                continue;

            if (GetCallerProperty(
                    pPropEle,
                    pPropEle->dwPropId,
                    TRUE,                   // fAlloc
                    (void *) &ppvData[iProp],
                    &pcbData[iProp]
                    )) {
                pdwPropId[iProp] = pPropEle->dwPropId;
                iProp++;
                if (iProp == cProp)
                    break;
            }
        }

        if (0 == iProp)
            goto CommonReturn;

        fResult = pKeyIdArg->pfnEnum(
            pKeyIdentifier,
            0,                      // dwFlags
            NULL,                   // pvReserved
            pKeyIdArg->pvArg,
            iProp,
            pdwPropId,
            ppvData,
            pcbData
            );
    }


CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    if (ppvData) {
        while (cProp--)
            PkiDefaultCryptFree(ppvData[cProp]);
        PkiFree(ppvData);
    }
    PkiFree(pdwPropId);
    PkiFree(pcbData);
    return fResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(DecodeKeyIdElementError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Enumerate the Key Identifiers.
//
//  If pKeyIdentifier is NULL, enumerates all Key Identifers. Otherwise,
//  calls the callback for the specified KeyIdentifier. If dwPropId is
//  0, calls the callback with all the properties. Otherwise, only calls
//  the callback with the specified property (cProp = 1).
//  Furthermore, when dwPropId is specified, skips KeyIdentifiers not
//  having the property.
//
//  Set CRYPT_KEYID_MACHINE_FLAG to enumerate the LocalMachine
//  Key Identifiers. Set pwszComputerName, to enumerate Key Identifiers on
//  a remote computer.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumKeyIdentifierProperties(
    IN OPTIONAL const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg,
    IN PFN_CRYPT_ENUM_KEYID_PROP pfnEnum
    )
{
    BOOL fResult;

    KEYID_ELEMENT_CALLBACK_ARG KeyIdArg =
        { dwPropId, dwFlags, pvArg, pfnEnum };

    if (pKeyIdentifier) {
        BYTE *pbElement = NULL;
        DWORD cbElement;

        fResult = ILS_ReadKeyIdElement(
                pKeyIdentifier,
                dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
                pwszComputerName,
                &pbElement,
                &cbElement
                );
        if (fResult)
            fResult = KeyIdElementCallback(
                pKeyIdentifier,
                pbElement,
                cbElement,
                (void *) &KeyIdArg
                );
        PkiFree(pbElement);
    } else
        fResult = ILS_OpenAllKeyIdElements(
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            (void *) &KeyIdArg,
            KeyIdElementCallback
            );

    return fResult;
}

//+-------------------------------------------------------------------------
//  For either the CERT_KEY_IDENTIFIER_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID
//  set the Crypt KeyIdentifier CERT_KEY_PROV_INFO_PROP_ID property if the
//  other property already exists.
//
//  If dwPropId == 0, does an implicit GetProperty(KEY_PROV_INFO)
//--------------------------------------------------------------------------
STATIC void SetCryptKeyIdentifierKeyProvInfoProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,              // may be 0
    IN const void *pvData
    )
{
    PCRYPT_HASH_BLOB pKeyIdentifier = NULL;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    void *pvOtherData = NULL;
    DWORD cbOtherData;
    CRYPT_HASH_BLOB OtherKeyIdentifier;

    if ((CERT_STORE_CERTIFICATE_CONTEXT - 1) != pEle->dwContextType)
        return;
    if (0 == dwPropId) {
        if (AllocAndGetProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                (void **) &pKeyProvInfo,
                &cbKeyProvInfo
                ) && cbKeyProvInfo) {
            SetCryptKeyIdentifierKeyProvInfoProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                pKeyProvInfo
                );
            PkiFree(pKeyProvInfo);
        }
        return;
    } else if (NULL == pvData)
        return;

    switch (dwPropId) {
        case CERT_KEY_IDENTIFIER_PROP_ID:
            AllocAndGetProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                &pvOtherData,
                &cbOtherData
                );
            if (pvOtherData) {
                pKeyIdentifier = (PCRYPT_HASH_BLOB) pvData;
                pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pvOtherData;
            }
            break;
        case CERT_KEY_PROV_INFO_PROP_ID:
            AllocAndGetProperty(
                pEle,
                CERT_KEY_IDENTIFIER_PROP_ID,
                &pvOtherData,
                &cbOtherData
                );
            if (pvOtherData) {
                pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pvData;
                OtherKeyIdentifier.cbData = cbOtherData;
                OtherKeyIdentifier.pbData = (BYTE *)pvOtherData;
                pKeyIdentifier = &OtherKeyIdentifier;
            }
            break;
        default:
            return;
    }

    if (pvOtherData) {
        DWORD dwFlags = CRYPT_KEYID_SET_NEW_FLAG;
        if (pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
            dwFlags |= CRYPT_KEYID_MACHINE_FLAG;
        CryptSetKeyIdentifierProperty(
            pKeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            dwFlags,
            NULL,               // pwszComputerName
            NULL,               // pvReserved
            (const void *) pKeyProvInfo
            );
        PkiFree(pvOtherData);
    }

}

//+-------------------------------------------------------------------------
//  Get the Key Identifier property for the specified element.
//
//  Only supported for certificates.
//--------------------------------------------------------------------------
STATIC BOOL GetKeyIdProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert;
    PCERT_INFO pCertInfo;
    PCERT_EXTENSION pExt;
    CRYPT_HASH_BLOB KeyIdentifier = { 0, NULL };
    BYTE rgbHash[MAX_HASH_LEN];

    if ((CERT_STORE_CERTIFICATE_CONTEXT - 1) != pEle->dwContextType)
        goto InvalidPropId;

    pCert = ToCertContext(pEle);
    pCertInfo = pCert->pCertInfo;

    if (pExt = CertFindExtension(
            szOID_SUBJECT_KEY_IDENTIFIER,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        // Skip by the octet tag, length bytes
        Asn1UtilExtractContent(
            pExt->Value.pbData,
            pExt->Value.cbData,
            &KeyIdentifier.cbData,
            (const BYTE **) &KeyIdentifier.pbData
            );
    }

    if (0 == KeyIdentifier.cbData) {
        const BYTE *pbPublicKeyInfo;
        DWORD cbPublicKeyInfo;
        if (!Asn1UtilExtractCertificatePublicKeyInfo(
                pCert->pbCertEncoded,
                pCert->cbCertEncoded,
                &cbPublicKeyInfo,
                &pbPublicKeyInfo
                ))
            goto ExtractPublicKeyInfoError;

        KeyIdentifier.cbData = sizeof(rgbHash);
        KeyIdentifier.pbData = rgbHash;
        if (!CryptHashCertificate(
                0,                      // hCryptProv
                CALG_SHA1,
                0,                      // dwFlags
                pbPublicKeyInfo,
                cbPublicKeyInfo,
                rgbHash,
                &KeyIdentifier.cbData
                ))
            goto HashPublicKeyInfoError;
    }

    if (!SetProperty(
            pEle,
            dwPropId,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
            &KeyIdentifier
            ))
        goto SetKeyIdPropertyError;

    fResult = GetProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData
            );
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbData = 0;
    goto CommonReturn;

SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(ExtractPublicKeyInfoError)
TRACE_ERROR(HashPublicKeyInfoError)
TRACE_ERROR(SetKeyIdPropertyError)
}

#ifdef CMS_PKCS7
//+-------------------------------------------------------------------------
//  If the verify signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the issuer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
STATIC BOOL VerifyCertificateSignatureWithChainPubKeyParaInheritance(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN DWORD        dwSubjectType,
    IN void         *pvSubject,
    IN PCCERT_CONTEXT pIssuer
    )
{
    BOOL fResult;

    if (CryptVerifyCertificateSignatureEx(
            hCryptProv,
            dwCertEncodingType,
            dwSubjectType,
            pvSubject,
            CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
            (void *) pIssuer,
            0,                                  // dwFlags
            NULL                                // pvReserved
            ))
        return TRUE;
    else if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
        return FALSE;
    else {
        PCCERT_CHAIN_CONTEXT pChainContext;
        CERT_CHAIN_PARA ChainPara;

        // Build a chain. Hopefully, the issuer inherit's its public key
        // parameters from up the chain

        memset(&ChainPara, 0, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);
        if (CertGetCertificateChain(
                NULL,                   // hChainEngine
                pIssuer,
                NULL,                   // pTime
                pIssuer->hCertStore,
                &ChainPara,
                CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                NULL,                   // pvReserved
                &pChainContext
                ))
            CertFreeCertificateChain(pChainContext);

        // Try again. Hopefully the above chain building updated the issuer's
        // context property with the missing public key parameters
        return CryptVerifyCertificateSignatureEx(
                hCryptProv,
                dwCertEncodingType,
                dwSubjectType,
                pvSubject,
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pIssuer,
                0,                                  // dwFlags
                NULL                                // pvReserved
                );
    }
}
#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\oidinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       oidinfo.cpp
//
//  Contents:   Cryptographic Object ID (OID) Info Functions
//
//  Functions:  I_CryptOIDInfoDllMain
//              CryptFindOIDInfo
//              CryptRegisterOIDInfo
//              CryptUnregisterOIDInfo
//              CryptEnumOIDInfo
//              CryptFindLocalizedName
//
//  Comments:
//
//  History:    24-May-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "wintrust.h"  //wintrust.h is needed for SPC_ oids

// Initialized in I_CryptOIDInfoDllMain at ProcessAttach
static HMODULE hOIDInfoInst;

#define MAX_RESOURCE_OID_NAME_LENGTH    256
static LPCWSTR pwszNullName = L"";

#define LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define CONST_OID_GROUP_PREFIX_CHAR    '!'
#define OID_INFO_ENCODING_TYPE          0
#define OID_INFO_NAME_VALUE_NAME        L"Name"
#define OID_INFO_ALGID_VALUE_NAME       L"Algid"
#define OID_INFO_EXTRA_INFO_VALUE_NAME  L"ExtraInfo"
#define OID_INFO_FLAGS_VALUE_NAME       L"Flags"



//+=========================================================================
//  OID Information Tables (by GROUP_ID)
//==========================================================================

#define OID_INFO_LEN sizeof(CRYPT_OID_INFO)

//+-------------------------------------------------------------------------
//  Hash Algorithm Table
//--------------------------------------------------------------------------
#define HASH_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_HASH_ALG_OID_GROUP_ID, Algid, 0, NULL

static CCRYPT_OID_INFO HashAlgTable[] = {
    HASH_ALG_ENTRY(szOID_OIWSEC_sha1, L"sha1", CALG_SHA1),
    HASH_ALG_ENTRY(szOID_OIWSEC_sha1, L"sha", CALG_SHA1),
    HASH_ALG_ENTRY(szOID_OIWSEC_sha, L"sha", CALG_SHA),
    HASH_ALG_ENTRY(szOID_RSA_MD5, L"md5", CALG_MD5),
    HASH_ALG_ENTRY(szOID_RSA_MD4, L"md4", CALG_MD4),
    HASH_ALG_ENTRY(szOID_RSA_MD2, L"md2", CALG_MD2)
};
#define HASH_ALG_CNT (sizeof(HashAlgTable) / sizeof(HashAlgTable[0]))


//+-------------------------------------------------------------------------
//  Encryption Algorithm Table
//--------------------------------------------------------------------------
#define ENCRYPT_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID, \
    Algid, 0, NULL

static CCRYPT_OID_INFO EncryptAlgTable[] = {
    ENCRYPT_ALG_ENTRY(szOID_OIWSEC_desCBC, L"des", CALG_DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_DES_EDE3_CBC, L"3des", CALG_3DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_RC2CBC, L"rc2", CALG_RC2),
    ENCRYPT_ALG_ENTRY(szOID_RSA_RC4, L"rc4", CALG_RC4),
#ifdef CMS_PKCS7
    ENCRYPT_ALG_ENTRY(szOID_RSA_SMIMEalgESDHwith3DES, L"ESDHwith3DES", CALG_3DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_SMIMEalgESDHwithRC2, L"ESDHwithRC2", CALG_RC2),
    ENCRYPT_ALG_ENTRY(szOID_RSA_SMIMEalg3DESwrap, L"3DESwrap", CALG_3DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_SMIMEalgRC2wrap, L"RC2wrap", CALG_RC2),
#endif  // CMS_PKCS7
};
#define ENCRYPT_ALG_CNT (sizeof(EncryptAlgTable) / sizeof(EncryptAlgTable[0]))


//+-------------------------------------------------------------------------
//  Public Key Algorithm Table
//--------------------------------------------------------------------------
static const DWORD dwMosaicFlags = CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG |
                                        CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG;

static const DWORD dwNoNullParaFlag = CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG;

#define PUBKEY_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, 0, NULL

#define PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, Algid, dwFlags) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, sizeof(dwFlags), (BYTE *) &dwFlags

#define DSA_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DSS_SIGN, dwNoNullParaFlag)

#define DH_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DH_SF, dwNoNullParaFlag)

#ifdef CMS_PKCS7
#define ESDH_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DH_EPHEM, dwNoNullParaFlag)
#endif  // CMS_PKCS7

static CCRYPT_OID_INFO PubKeyAlgTable[] = {
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA", CALG_RSA_KEYX),
    DSA_PUBKEY_ALG_ENTRY(szOID_X957_DSA, L"DSA"),
    DH_PUBKEY_ALG_ENTRY(szOID_ANSI_X942_DH, L"DH"),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA_KEYX", CALG_RSA_KEYX),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA", CALG_RSA_SIGN),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA_SIGN", CALG_RSA_SIGN),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSA"),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSS"),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSA_SIGN"),
    DH_PUBKEY_ALG_ENTRY(szOID_RSA_DH, L"DH"),
    PUBKEY_ALG_ENTRY(szOID_OIWSEC_rsaXchg, L"RSA_KEYX", CALG_RSA_KEYX),
    PUBKEY_EXTRA_ALG_ENTRY(szOID_INFOSEC_mosaicKMandUpdSig,
        L"mosaicKMandUpdSig", CALG_DSS_SIGN, dwMosaicFlags),
#ifdef CMS_PKCS7
    ESDH_PUBKEY_ALG_ENTRY(szOID_RSA_SMIMEalgESDHwith3DES, L"ESDHwith3DES"),
    ESDH_PUBKEY_ALG_ENTRY(szOID_RSA_SMIMEalgESDHwithRC2, L"ESDHwithRC2"),
#endif  // CMS_PKCS7
};
#define PUBKEY_ALG_CNT (sizeof(PubKeyAlgTable) / sizeof(PubKeyAlgTable[0]))


//+-------------------------------------------------------------------------
//  Signature Algorithm Table
//--------------------------------------------------------------------------
static const ALG_ID aiRsaPubKey = CALG_RSA_SIGN;
static const DWORD rgdwMosaicSign[] = {
    CALG_DSS_SIGN,
    CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG |
        CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG
};
static const DWORD rgdwDssSign[] = {
    CALG_DSS_SIGN,
    CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG
};

#define SIGN_ALG_ENTRY(pszOID, pwszName, aiHash, aiPubKey) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_SIGN_ALG_OID_GROUP_ID, aiHash, \
    sizeof(aiPubKey), (BYTE *) &aiPubKey
#define RSA_SIGN_ALG_ENTRY(pszOID, pwszName, aiHash) \
    SIGN_ALG_ENTRY(pszOID, pwszName, aiHash, aiRsaPubKey)

#define SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, aiHash, rgdwExtra) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_SIGN_ALG_OID_GROUP_ID, aiHash, \
    sizeof(rgdwExtra), (BYTE *) rgdwExtra

#define DSS_SIGN_ALG_ENTRY(pszOID, pwszName) \
    SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_SHA1, rgdwDssSign)

static CCRYPT_OID_INFO SignAlgTable[] = {
    RSA_SIGN_ALG_ENTRY(szOID_RSA_SHA1RSA, L"sha1RSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD5RSA, L"md5RSA", CALG_MD5),
    DSS_SIGN_ALG_ENTRY(szOID_X957_SHA1DSA, L"sha1DSA"),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_sha1RSASign, L"sha1RSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_sha1RSASign, L"shaRSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_shaRSA, L"shaRSA", CALG_SHA),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md5RSA, L"md5RSA", CALG_MD5),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD2RSA, L"md2RSA", CALG_MD2),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD4RSA, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md4RSA, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md4RSA2, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWDIR_md2RSA, L"md2RSA", CALG_MD2),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_shaDSA, L"sha1DSA"),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_shaDSA, L"shaDSA"),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_dsaSHA1,L"dsaSHA1"),
    SIGN_EXTRA_ALG_ENTRY(szOID_INFOSEC_mosaicUpdatedSig, L"mosaicUpdatedSig",
        CALG_SHA, rgdwMosaicSign),
};
#define SIGN_ALG_CNT (sizeof(SignAlgTable) / sizeof(SignAlgTable[0]))


//+-------------------------------------------------------------------------
//  RDN Attribute Table
//--------------------------------------------------------------------------

// PLEASE UPDATE the following define in certstr.cpp if you add a new entry
// with a longer pwszName
// #define MAX_X500_KEY_LEN    64

// Ordered lists of acceptable RDN attribute value types. 0 terminates.
static const DWORD rgdwPrintableValueType[] = { CERT_RDN_PRINTABLE_STRING, 0 };
static const DWORD rgdwIA5ValueType[] = { CERT_RDN_IA5_STRING, 0 };
static const DWORD rgdwNumericValueType[] = { CERT_RDN_NUMERIC_STRING, 0 };
static const DWORD rgdwIA5orUTF8ValueType[] = { CERT_RDN_IA5_STRING,
                                                CERT_RDN_UTF8_STRING, 0 };

#define RDN_ATTR_ENTRY(pszOID, pwszName, rgdwValueType) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 0, \
    sizeof(rgdwValueType), (BYTE *) rgdwValueType
#define DEFAULT_RDN_ATTR_ENTRY(pszOID, pwszName) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 0, 0, NULL

static CCRYPT_OID_INFO RDNAttrTable[] = {
    // Ordered with most commonly used key names at the beginning

    // Labeling attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_COMMON_NAME, L"CN"),
    // Geographic attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_LOCALITY_NAME, L"L"),
    // Organizational attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_ORGANIZATION_NAME, L"O"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_ORGANIZATIONAL_UNIT_NAME, L"OU"),

    // Verisign sticks the following in their cert names. Netscape uses the
    // "E" instead of the "Email". Will let "E" take precedence
    RDN_ATTR_ENTRY(szOID_RSA_emailAddr, L"E", rgdwIA5ValueType),
    RDN_ATTR_ENTRY(szOID_RSA_emailAddr, L"Email", rgdwIA5ValueType),

    // The following aren't used in Verisign's certs

    // Geographic attribute types:
    RDN_ATTR_ENTRY(szOID_COUNTRY_NAME, L"C", rgdwPrintableValueType),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME, L"S"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME, L"ST"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STREET_ADDRESS, L"STREET"),

    // Organizational attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_TITLE, L"T"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_TITLE, L"Title"),

    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"G"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"GN"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"GivenName"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_INITIALS, L"I"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_INITIALS, L"Initials"),

    // Labeling attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_SUR_NAME, L"SN"),
//    RDN_ATTR_ENTRY(szOID_DEVICE_SERIAL_NUMBER, L"", rgdwPrintableValueType),

    // Pilot user attribute types:
    RDN_ATTR_ENTRY(szOID_DOMAIN_COMPONENT, L"DC", rgdwIA5orUTF8ValueType),

    // Explanatory attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_DESCRIPTION, L"Description"),
//  szOID_SEARCH_GUIDE                  "2.5.4.14"
//    DEFAULT_RDN_ATTR_ENTRY(szOID_BUSINESS_CATEGORY, L""),

    // Postal addressing attribute types:
//  szOID_POSTAL_ADDRESS                "2.5.4.16"
    DEFAULT_RDN_ATTR_ENTRY(szOID_POSTAL_CODE, L"PostalCode"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_POST_OFFICE_BOX, L"POBox"),
//    DEFAULT_RDN_ATTR_ENTRY(szOID_PHYSICAL_DELIVERY_OFFICE_NAME, L""),

    // Telecommunications addressing attribute types:
    RDN_ATTR_ENTRY(szOID_TELEPHONE_NUMBER, L"Phone", rgdwPrintableValueType),
//  szOID_TELEX_NUMBER                  "2.5.4.21"
//  szOID_TELETEXT_TERMINAL_IDENTIFIER  "2.5.4.22"
//  szOID_FACSIMILE_TELEPHONE_NUMBER    "2.5.4.23"

//  Following is used as a test case for a Numeric value
    RDN_ATTR_ENTRY(szOID_X21_ADDRESS, L"X21Address", rgdwNumericValueType),
//    RDN_ATTR_ENTRY(szOID_INTERNATIONAL_ISDN_NUMBER, L"", rgdwNumericValueType),
//  szOID_REGISTERED_ADDRESS            "2.5.4.26"
//    RDN_ATTR_ENTRY(szOID_DESTINATION_INDICATOR, L"", rgdwPrintableValueType)

    // Preference attribute types:
//  szOID_PREFERRED_DELIVERY_METHOD     "2.5.4.28"

    // OSI application attribute types:
//  szOID_PRESENTATION_ADDRESS          "2.5.4.29"
//  szOID_SUPPORTED_APPLICATION_CONTEXT "2.5.4.30"

    // Relational application attribute types:
//  szOID_MEMBER                        "2.5.4.31"
//  szOID_OWNER                         "2.5.4.32"
//  szOID_ROLE_OCCUPANT                 "2.5.4.33"
//  szOID_SEE_ALSO                      "2.5.4.34"

    // Security attribute types:
//  szOID_USER_PASSWORD                 "2.5.4.35"
//  szOID_USER_CERTIFICATE              "2.5.4.36"
//  szOID_CA_CERTIFICATE                "2.5.4.37"
//  szOID_AUTHORITY_REVOCATION_LIST     "2.5.4.38"
//  szOID_CERTIFICATE_REVOCATION_LIST   "2.5.4.39"
//  szOID_CROSS_CERTIFICATE_PAIR        "2.5.4.40"

    // Undocumented attribute types???
//#define szOID_???                         "2.5.4.41"

    DEFAULT_RDN_ATTR_ENTRY(szOID_DN_QUALIFIER, L"dnQualifier"),
};
#define RDN_ATTR_CNT (sizeof(RDNAttrTable) / sizeof(RDNAttrTable[0]))

//+-------------------------------------------------------------------------
//  Extension or Attribute Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define EXT_ATTR_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_EXT_OR_ATTR_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO ExtAttrTable[] = {
    EXT_ATTR_ENTRY(szOID_AUTHORITY_KEY_IDENTIFIER2,
        IDS_EXT_AUTHORITY_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_AUTHORITY_KEY_IDENTIFIER,
        IDS_EXT_AUTHORITY_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_KEY_ATTRIBUTES,
        IDS_EXT_KEY_ATTRIBUTES),
    EXT_ATTR_ENTRY(szOID_KEY_USAGE_RESTRICTION,
        IDS_EXT_KEY_USAGE_RESTRICTION),
    EXT_ATTR_ENTRY(szOID_SUBJECT_ALT_NAME2,
        IDS_EXT_SUBJECT_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_SUBJECT_ALT_NAME,
        IDS_EXT_SUBJECT_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_ISSUER_ALT_NAME2,
        IDS_EXT_ISSUER_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_ISSUER_ALT_NAME,
        IDS_EXT_ISSUER_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_BASIC_CONSTRAINTS2,
        IDS_EXT_BASIC_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_BASIC_CONSTRAINTS,
        IDS_EXT_BASIC_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_KEY_USAGE,
        IDS_EXT_KEY_USAGE),
    EXT_ATTR_ENTRY(szOID_CERT_POLICIES,
        IDS_EXT_CERT_POLICIES),
    EXT_ATTR_ENTRY(szOID_SUBJECT_KEY_IDENTIFIER,
        IDS_EXT_SUBJECT_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_CRL_REASON_CODE,
        IDS_EXT_CRL_REASON_CODE),
    EXT_ATTR_ENTRY(szOID_CRL_DIST_POINTS,
        IDS_EXT_CRL_DIST_POINTS),
    EXT_ATTR_ENTRY(szOID_ENHANCED_KEY_USAGE,
        IDS_EXT_ENHANCED_KEY_USAGE),
    EXT_ATTR_ENTRY(szOID_AUTHORITY_INFO_ACCESS,
        IDS_EXT_AUTHORITY_INFO_ACCESS),
    EXT_ATTR_ENTRY(szOID_CERT_EXTENSIONS,
        IDS_EXT_CERT_EXTENSIONS),
    EXT_ATTR_ENTRY(szOID_NEXT_UPDATE_LOCATION,
        IDS_EXT_NEXT_UPDATE_LOCATION),
    EXT_ATTR_ENTRY(szOID_YESNO_TRUST_ATTR,
        IDS_EXT_YESNO_TRUST_ATTR),
    EXT_ATTR_ENTRY(szOID_RSA_emailAddr,
        IDS_EXT_RSA_emailAddr),
    EXT_ATTR_ENTRY(szOID_RSA_unstructName,
        IDS_EXT_RSA_unstructName),
    EXT_ATTR_ENTRY(szOID_RSA_contentType,
        IDS_EXT_RSA_contentType),
    EXT_ATTR_ENTRY(szOID_RSA_messageDigest,
        IDS_EXT_RSA_messageDigest),
    EXT_ATTR_ENTRY(szOID_RSA_signingTime,
        IDS_EXT_RSA_signingTime),
    EXT_ATTR_ENTRY(szOID_RSA_counterSign,
        IDS_EXT_RSA_counterSign),
    EXT_ATTR_ENTRY(szOID_RSA_challengePwd,
        IDS_EXT_RSA_challengePwd),
    EXT_ATTR_ENTRY(szOID_RSA_unstructAddr,
        IDS_EXT_RSA_unstructAddr),
    EXT_ATTR_ENTRY(szOID_RSA_extCertAttrs, L""),
    EXT_ATTR_ENTRY(szOID_RSA_SMIMECapabilities,
        IDS_EXT_RSA_SMIMECapabilities),
    EXT_ATTR_ENTRY(szOID_RSA_preferSignedData,
        IDS_EXT_RSA_preferSignedData),
    EXT_ATTR_ENTRY(szOID_PKIX_POLICY_QUALIFIER_CPS,
        IDS_EXT_PKIX_POLICY_QUALIFIER_CPS),
    EXT_ATTR_ENTRY(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
        IDS_EXT_PKIX_POLICY_QUALIFIER_USERNOTICE),
    EXT_ATTR_ENTRY(szOID_PKIX_OCSP,
        IDS_EXT_PKIX_OCSP),
    EXT_ATTR_ENTRY(szOID_PKIX_CA_ISSUERS,
        IDS_EXT_PKIX_CA_ISSUERS),
    EXT_ATTR_ENTRY("1.3.6.1.4.1.311.20.2",
        IDS_EXT_MS_CERTIFICATE_TEMPLATE),
    EXT_ATTR_ENTRY(szOID_ENROLLMENT_AGENT,
        IDS_EXT_ENROLLMENT_AGENT),
    EXT_ATTR_ENTRY(szOID_ENROLL_CERTTYPE_EXTENSION,
        IDS_EXT_ENROLL_CERTTYPE),
    EXT_ATTR_ENTRY(szOID_CERT_MANIFOLD,
        IDS_EXT_CERT_MANIFOLD),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CERT_TYPE,
        IDS_EXT_NETSCAPE_CERT_TYPE),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_BASE_URL,
        IDS_EXT_NETSCAPE_BASE_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_REVOCATION_URL,
        IDS_EXT_NETSCAPE_REVOCATION_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CA_REVOCATION_URL,
        IDS_EXT_NETSCAPE_CA_REVOCATION_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CERT_RENEWAL_URL,
        IDS_EXT_NETSCAPE_CERT_RENEWAL_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CA_POLICY_URL,
        IDS_EXT_NETSCAPE_CA_POLICY_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_SSL_SERVER_NAME,
        IDS_EXT_NETSCAPE_SSL_SERVER_NAME),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_COMMENT,
        IDS_EXT_NETSCAPE_COMMENT),
    EXT_ATTR_ENTRY(SPC_SP_AGENCY_INFO_OBJID,
        IDS_EXT_SPC_SP_AGENCY_INFO_OBJID),
    EXT_ATTR_ENTRY(SPC_FINANCIAL_CRITERIA_OBJID,
        IDS_EXT_SPC_FINANCIAL_CRITERIA_OBJID),
    EXT_ATTR_ENTRY(SPC_MINIMAL_CRITERIA_OBJID,
        IDS_EXT_SPC_MINIMAL_CRITERIA_OBJID),
    EXT_ATTR_ENTRY(szOID_COUNTRY_NAME,
        IDS_EXT_COUNTRY_NAME),
    EXT_ATTR_ENTRY(szOID_ORGANIZATION_NAME,
        IDS_EXT_ORGANIZATION_NAME),
    EXT_ATTR_ENTRY(szOID_ORGANIZATIONAL_UNIT_NAME,
        IDS_EXT_ORGANIZATIONAL_UNIT_NAME),
    EXT_ATTR_ENTRY(szOID_COMMON_NAME,
        IDS_EXT_COMMON_NAME),
    EXT_ATTR_ENTRY(szOID_LOCALITY_NAME,
        IDS_EXT_LOCALITY_NAME),
    EXT_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME,
        IDS_EXT_STATE_OR_PROVINCE_NAME),
    EXT_ATTR_ENTRY(szOID_TITLE,
        IDS_EXT_TITLE),
    EXT_ATTR_ENTRY(szOID_GIVEN_NAME,
        IDS_EXT_GIVEN_NAME),
    EXT_ATTR_ENTRY(szOID_INITIALS,
        IDS_EXT_INITIALS),
    EXT_ATTR_ENTRY(szOID_SUR_NAME,
        IDS_EXT_SUR_NAME),
    EXT_ATTR_ENTRY(szOID_DOMAIN_COMPONENT,
        IDS_EXT_DOMAIN_COMPONENT),
    EXT_ATTR_ENTRY(szOID_STREET_ADDRESS,
        IDS_EXT_STREET_ADDRESS),
    EXT_ATTR_ENTRY(szOID_DEVICE_SERIAL_NUMBER,
        IDS_EXT_DEVICE_SERIAL_NUMBER),
};


#define EXT_ATTR_CNT (sizeof(ExtAttrTable) / sizeof(ExtAttrTable[0]))

//+-------------------------------------------------------------------------
//  Enhanced Key Usage Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define ENHKEY_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_ENHKEY_USAGE_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO EnhKeyTable[] = {
    ENHKEY_ENTRY(szOID_PKIX_KP_SERVER_AUTH,
        IDS_ENHKEY_PKIX_KP_SERVER_AUTH),
    ENHKEY_ENTRY(szOID_PKIX_KP_CLIENT_AUTH,
        IDS_ENHKEY_PKIX_KP_CLIENT_AUTH),
    ENHKEY_ENTRY(szOID_PKIX_KP_CODE_SIGNING,
        IDS_ENHKEY_PKIX_KP_CODE_SIGNING),
    ENHKEY_ENTRY(szOID_PKIX_KP_EMAIL_PROTECTION,
        IDS_ENHKEY_PKIX_KP_EMAIL_PROTECTION),
    ENHKEY_ENTRY(szOID_PKIX_KP_TIMESTAMP_SIGNING,
        IDS_ENHKEY_PKIX_KP_TIMESTAMP_SIGNING),
    ENHKEY_ENTRY(szOID_KP_CTL_USAGE_SIGNING,
        IDS_ENHKEY_KP_CTL_USAGE_SIGNING),
    ENHKEY_ENTRY(szOID_KP_TIME_STAMP_SIGNING,
        IDS_ENHKEY_KP_TIME_STAMP_SIGNING),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_END_SYSTEM,
        IDS_ENHKEY_PKIX_KP_IPSEC_END_SYSTEM),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_TUNNEL,
        IDS_ENHKEY_PKIX_KP_IPSEC_TUNNEL),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_USER,
        IDS_ENHKEY_PKIX_KP_IPSEC_USER),
   // ENHKEY_ENTRY(szOID_SERVER_GATED_CRYPTO,
   //     IDS_ENHKEY_SERVER_GATED_CRYPTO),
   // ENHKEY_ENTRY(szOID_SGC_NETSCAPE,
   //     IDS_ENHKEY_SGC_NETSCAPE),
    ENHKEY_ENTRY(szOID_KP_EFS,
        IDS_ENHKEY_KP_EFS),
    ENHKEY_ENTRY(szOID_WHQL_CRYPTO,
        IDS_ENHKEY_KP_WHQL),
    ENHKEY_ENTRY(szOID_NT5_CRYPTO,
        IDS_ENHKEY_KP_NT5),
    ENHKEY_ENTRY(szOID_OEM_WHQL_CRYPTO,
        IDS_ENHKEY_KP_OEM_WHQL),
    ENHKEY_ENTRY(szOID_EMBEDDED_NT_CRYPTO,
        IDS_ENHKEY_KP_EMBEDDED_NT),
};
#define ENHKEY_CNT (sizeof(EnhKeyTable) / sizeof(EnhKeyTable[0]))

#if 0

//+-------------------------------------------------------------------------
//  Policy Table
//--------------------------------------------------------------------------
#define POLICY_ENTRY(pszOID, pwszName) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_POLICY_OID_GROUP_ID, 0, 0, NULL

static CCRYPT_OID_INFO PolicyTable[] = {
    POLICY_ENTRY(szOID_, L"")
};
#define POLICY_CNT (sizeof(PolicyTable) / sizeof(PolicyTable[0]))

#endif


//+=========================================================================
//  OID Group Tables
//
//  fLocalize is set to TRUE, if the CRYPT_OID_INFO's pwszName may be
//  a Resource ID that is used to get the localized name via LoadStringU().
//
//  Assumption, Resource ID's <= 0xFFFF.
//==========================================================================
typedef struct _GROUP_ENTRY {
    DWORD               cInfo;
    PCCRYPT_OID_INFO    rgInfo;
    BOOL                fLocalize;
} GROUP_ENTRY, *PGROUP_ENTRY;
typedef const GROUP_ENTRY CGROUP_ENTRY, *PCGROUP_ENTRY;

static CGROUP_ENTRY GroupTable[CRYPT_LAST_OID_GROUP_ID + 1] = {
    0, NULL, FALSE,                             // 0
    HASH_ALG_CNT, HashAlgTable, FALSE,          // 1
    ENCRYPT_ALG_CNT, EncryptAlgTable, FALSE,    // 2
    PUBKEY_ALG_CNT, PubKeyAlgTable, FALSE,      // 3
    SIGN_ALG_CNT, SignAlgTable, FALSE,          // 4
    RDN_ATTR_CNT, RDNAttrTable, FALSE,          // 5
    EXT_ATTR_CNT, ExtAttrTable, TRUE,           // 6
    ENHKEY_CNT, EnhKeyTable, TRUE,              // 7
#if 0
    POLICY_CNT, PolicyTable, FALSE              // 8
#else
    0, NULL, FALSE                              // 8
#endif
};


//+-------------------------------------------------------------------------
//  The following groups are dynamically updated from the registry on
//  CryptFindOIDInfo's first call.
//--------------------------------------------------------------------------
static GROUP_ENTRY RegBeforeGroup;
static GROUP_ENTRY RegAfterGroup;

// Do the load once within a critical section
static BOOL fLoadedFromRegAndResources = FALSE;
static CRITICAL_SECTION LoadFromRegCriticalSection;


//+=========================================================================
//  Localized Name Definitions and Data Structures
//==========================================================================

//+-------------------------------------------------------------------------
//  Localized Name Information
//--------------------------------------------------------------------------
typedef struct _LOCALIZED_NAME_INFO {
    LPCWSTR         pwszCryptName;
    union {
        UINT            uIDLocalizedName;
        LPCWSTR         pwszLocalizedName;
    };
} LOCALIZED_NAME_INFO, *PLOCALIZED_NAME_INFO;


//+-------------------------------------------------------------------------
//  Predefined Localized Names Table (Localized via resource strings)
//--------------------------------------------------------------------------
static LOCALIZED_NAME_INFO PredefinedNameTable[] = {
    // System store names
    L"Root",        IDS_SYS_NAME_ROOT,
    L"My",          IDS_SYS_NAME_MY,
    L"Trust",       IDS_SYS_NAME_TRUST,
    L"CA",          IDS_SYS_NAME_CA,
    L"UserDS",      IDS_SYS_NAME_USERDS,
    L"SmartCard",   IDS_SYS_NAME_SMARTCARD,
    L"AddressBook", IDS_SYS_NAME_ADDRESSBOOK,

    // Physical store names
    CERT_PHYSICAL_STORE_DEFAULT_NAME,           IDS_PHY_NAME_DEFAULT,
    CERT_PHYSICAL_STORE_GROUP_POLICY_NAME,      IDS_PHY_NAME_GROUP_POLICY,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME,     IDS_PHY_NAME_LOCAL_MACHINE,
    CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME, IDS_PHY_NAME_DS_USER_CERT,
    CERT_PHYSICAL_STORE_ENTERPRISE_NAME,        IDS_PHY_NAME_ENTERPRISE,
};
#define PREDEFINED_NAME_CNT  (sizeof(PredefinedNameTable) / \
                                    sizeof(PredefinedNameTable[0]))

//+-------------------------------------------------------------------------
//  Localized Name Group Table
//--------------------------------------------------------------------------
typedef struct _LOCALIZED_GROUP_ENTRY {
    DWORD                   cInfo;
    PLOCALIZED_NAME_INFO    rgInfo;
} LOCALIZED_GROUP_ENTRY, *PLOCALIZED_GROUP_ENTRY;

#define REG_LOCALIZED_GROUP             0
#define PREDEFINED_LOCALIZED_GROUP      1
static LOCALIZED_GROUP_ENTRY LocalizedGroupTable[] = {
    // 0 - Loaded from registry
    0, NULL,
    // 1 - Predefined list of names
    PREDEFINED_NAME_CNT, PredefinedNameTable
};
#define LOCALIZED_GROUP_CNT  (sizeof(LocalizedGroupTable) / \
                                    sizeof(LocalizedGroupTable[0]))

// The localized names are loaded once. Uses the above
// LoadFromRegCriticalSection;
static BOOL fLoadedLocalizedNames = FALSE;


//+-------------------------------------------------------------------------
//  OIDInfo allocation and free functions
//--------------------------------------------------------------------------
static void *OIDInfoAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void *OIDInfoRealloc(
    IN void *pvOrg,
    IN size_t cb
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cb) : malloc(cb)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void OIDInfoFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Functions called at ProcessDetach to free the groups updated from the
//  registry during CryptFindOIDInfo's first call.
//--------------------------------------------------------------------------
static void FreeGroup(
    PGROUP_ENTRY pGroup
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++)
        OIDInfoFree((LPSTR)pInfo->pszOID);

    OIDInfoFree((PCRYPT_OID_INFO) pGroup->rgInfo);
}

static void FreeRegGroups()
{
    FreeGroup(&RegBeforeGroup);
    FreeGroup(&RegAfterGroup);
}

//+-------------------------------------------------------------------------
//  Free resource strings allocated in groups having localized pwszName's.
//--------------------------------------------------------------------------
static void FreeGroupResources()
{
    DWORD i;
    if (!fLoadedFromRegAndResources)
        // No resource strings allocated
        return;

    for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
        if (GroupTable[i].fLocalize) {
            DWORD cInfo = GroupTable[i].cInfo;
            PCRYPT_OID_INFO pInfo = (PCRYPT_OID_INFO) GroupTable[i].rgInfo;

            for ( ; cInfo > 0; cInfo--, pInfo++) {
                // pwszName is set to pwszNullName if the allocation failed
                if (pwszNullName != pInfo->pwszName) {
                    OIDInfoFree((LPWSTR) pInfo->pwszName);
                    pInfo->pwszName = pwszNullName;
                }
            }
        }
    }
}

//+-------------------------------------------------------------------------
//  Free memory allocated for localized names
//--------------------------------------------------------------------------
static void FreeLocalizedNames()
{
    if (!fLoadedLocalizedNames)
        // No resource strings allocated
        return;

    for (DWORD i = 0; i < LOCALIZED_GROUP_CNT; i++) {
        DWORD cInfo = LocalizedGroupTable[i].cInfo;
        PLOCALIZED_NAME_INFO pInfo = LocalizedGroupTable[i].rgInfo;

        for ( ; cInfo > 0; cInfo--, pInfo++) {
            LPWSTR pwszLocalizedName = (LPWSTR) pInfo->pwszLocalizedName;
            if (pwszNullName != pwszLocalizedName)
                OIDInfoFree(pwszLocalizedName);
        }
    }

    OIDInfoFree(LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo);
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptOIDInfoDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        hOIDInfoInst = hInst;
        InitializeCriticalSection(&LoadFromRegCriticalSection);
        break;

    case DLL_PROCESS_DETACH:
        FreeRegGroups();
        FreeGroupResources();
        FreeLocalizedNames();
        DeleteCriticalSection(&LoadFromRegCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}

#ifdef CAPI_INCLUDE_REGISTER_OID

//+-------------------------------------------------------------------------
//  Allocated and format the string consisting of the OID and GROUP_ID:
//
//  For example: 1.2.3.4!6
//--------------------------------------------------------------------------
static LPSTR FormatOIDGroupString(
    IN PCCRYPT_OID_INFO pInfo
    )
{
    LPSTR pszOIDGroupString;
    DWORD cchOIDGroupString;
    char szGroupId[34];

    if (NULL == pInfo || pInfo->cbSize < sizeof(CRYPT_OID_INFO) ||
            (DWORD_PTR) pInfo->pszOID <= 0xFFFF) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    szGroupId[0] = CONST_OID_GROUP_PREFIX_CHAR;
    _ltoa((long) pInfo->dwGroupId, &szGroupId[1], 10);

    cchOIDGroupString = strlen(pInfo->pszOID) +
        strlen(szGroupId) +
        1;

    if (pszOIDGroupString = (LPSTR) OIDInfoAlloc(cchOIDGroupString)) {
        strcpy(pszOIDGroupString, pInfo->pszOID);
        strcat(pszOIDGroupString, szGroupId);
    }

    return pszOIDGroupString;
}

//+-------------------------------------------------------------------------
//  Wrapper function for calling CryptSetOIDFunctionValue using OID info's
//  encoding type and function name.
//--------------------------------------------------------------------------
static BOOL SetOIDInfoRegValue(
    IN LPCSTR pszOIDGroupString,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValueType,
    IN const BYTE *pbValueData,
    IN DWORD cbValueData
    )
{
    return CryptSetOIDFunctionValue(
        OID_INFO_ENCODING_TYPE,
        CRYPT_OID_FIND_OID_INFO_FUNC,
        pszOIDGroupString,
        pwszValueName,
        dwValueType,
        pbValueData,
        cbValueData
        );
}

//+-------------------------------------------------------------------------
//  Register OID information.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterOIDInfo(
    IN PCCRYPT_OID_INFO pInfo,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    LPSTR pszOIDGroupString = NULL;

    if (NULL == (pszOIDGroupString = FormatOIDGroupString(pInfo)))
        goto FormatOIDGroupStringError;

    if (pInfo->pwszName && L'\0' != *pInfo->pwszName) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_NAME_VALUE_NAME,
                REG_SZ,
                (const BYTE *) pInfo->pwszName,
                (wcslen(pInfo->pwszName) + 1) * sizeof(WCHAR)
                )) goto SetOIDInfoRegValueError;
    }
    if (0 != pInfo->Algid) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_ALGID_VALUE_NAME,
                REG_DWORD,
                (const BYTE *) &pInfo->Algid,
                sizeof(pInfo->Algid)
                )) goto SetOIDInfoRegValueError;
    }
    if (0 != pInfo->ExtraInfo.cbData) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_EXTRA_INFO_VALUE_NAME,
                REG_BINARY,
                pInfo->ExtraInfo.pbData,
                pInfo->ExtraInfo.cbData
                )) goto SetOIDInfoRegValueError;
    }

    if (0 != dwFlags) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_FLAGS_VALUE_NAME,
                REG_DWORD,
                (const BYTE *) &dwFlags,
                sizeof(dwFlags)
                )) goto SetOIDInfoRegValueError;
    }

    fResult = TRUE;
CommonReturn:
    OIDInfoFree(pszOIDGroupString);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(FormatOIDGroupStringError)
TRACE_ERROR(SetOIDInfoRegValueError)
}

//+-------------------------------------------------------------------------
//  Unregister OID information. Only the pszOID and dwGroupId fields are
//  used to identify the OID information to be unregistered.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUnregisterOIDInfo(
    IN PCCRYPT_OID_INFO pInfo
    )
{
    BOOL fResult;
    LPSTR pszOIDGroupString = NULL;

    if (NULL == (pszOIDGroupString = FormatOIDGroupString(pInfo)))
        goto FormatOIDGroupStringError;
    if (!CryptUnregisterOIDFunction(
            OID_INFO_ENCODING_TYPE,
            CRYPT_OID_FIND_OID_INFO_FUNC,
            pszOIDGroupString
            ))
        goto UnregisterOIDFunctionError;
    fResult = TRUE;
CommonReturn:
    OIDInfoFree(pszOIDGroupString);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(FormatOIDGroupStringError)
TRACE_ERROR(UnregisterOIDFunctionError)
}

//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered OID information.
//
//  Called within critical section
//--------------------------------------------------------------------------
static BOOL WINAPI EnumRegistryCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    DWORD cchOID;
    LPCWSTR pwszName;
    DWORD cchName = 0;
    LPCSTR pszGroupId;
    DWORD dwGroupId = 0;
    ALG_ID Algid = 0;
    CRYPT_DATA_BLOB ExtraInfo = {0, NULL};
    DWORD dwFlags = 0;
    DWORD cbExtra;
    BYTE *pbExtra;
    PGROUP_ENTRY pGroup;
    PCRYPT_OID_INFO pInfo;

    // The pszOID consists of OID!<dwGroupId>, for example, 1.2.3!1
    // Start at the end and search for the '!'
    cchOID = strlen(pszOID);
    pszGroupId = pszOID + cchOID;
    while (pszGroupId > pszOID && CONST_OID_GROUP_PREFIX_CHAR != *pszGroupId)
        pszGroupId--;

    if (CONST_OID_GROUP_PREFIX_CHAR == *pszGroupId) {
        cchOID = (DWORD)(pszGroupId - pszOID);
        dwGroupId = (DWORD) atol(pszGroupId + 1);
    } else
        // Name is missing "!". Skip It.
        return TRUE;

    while (cValue--) {
        LPCWSTR pwszValueName = rgpwszValueName[cValue];
        DWORD dwValueType = rgdwValueType[cValue];
        const BYTE *pbValueData = rgpbValueData[cValue];
        DWORD cbValueData = rgcbValueData[cValue];

        if (0 == _wcsicmp(pwszValueName, OID_INFO_NAME_VALUE_NAME)) {
            if (REG_SZ == dwValueType) {
                pwszName = (LPWSTR) pbValueData;
                cchName = wcslen(pwszName);
            }
        } else if (0 == _wcsicmp(pwszValueName, OID_INFO_ALGID_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(Algid))
                memcpy(&Algid, pbValueData, sizeof(Algid));
        } else if (0 == _wcsicmp(pwszValueName,
                OID_INFO_EXTRA_INFO_VALUE_NAME)) {
            if (REG_BINARY == dwValueType) {
                ExtraInfo.cbData = cbValueData;
                ExtraInfo.pbData = (BYTE *) pbValueData;
            }
        } else if (0 == _wcsicmp(pwszValueName, OID_INFO_FLAGS_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(dwFlags))
                memcpy(&dwFlags, pbValueData, sizeof(dwFlags));
        }
    }

    cbExtra = LEN_ALIGN(cchOID + 1) +
        LEN_ALIGN((cchName + 1) * sizeof(WCHAR)) +
        ExtraInfo.cbData;
    if (NULL == (pbExtra = (BYTE *) OIDInfoAlloc(cbExtra)))
        return FALSE;

    if (dwFlags & CRYPT_INSTALL_OID_INFO_BEFORE_FLAG)
        pGroup = &RegBeforeGroup;
    else
        pGroup = &RegAfterGroup;

    if (NULL == (pInfo = (PCRYPT_OID_INFO) OIDInfoRealloc(
            (PCRYPT_OID_INFO) pGroup->rgInfo,
            (pGroup->cInfo + 1) * sizeof(CRYPT_OID_INFO)))) {
        OIDInfoFree(pbExtra);
        return FALSE;
    }
    pGroup->rgInfo = pInfo;
    pInfo = &pInfo[pGroup->cInfo++];

    pInfo->cbSize = sizeof(CRYPT_OID_INFO);
    pInfo->pszOID = (LPCSTR) pbExtra;
    if (cchOID)
        memcpy(pbExtra, pszOID, cchOID);
    *( ((LPSTR) pbExtra) + cchOID) = '\0';
    pbExtra += LEN_ALIGN(cchOID + 1);

    pInfo->pwszName = (LPCWSTR) pbExtra;
    if (cchName)
        memcpy(pbExtra, pwszName, (cchName + 1) * sizeof(WCHAR));
    else
        *((LPWSTR) pbExtra) = L'\0';
    pbExtra += LEN_ALIGN((cchName + 1) * sizeof(WCHAR));

    pInfo->dwGroupId = dwGroupId;
    pInfo->Algid = Algid;
    pInfo->ExtraInfo.cbData = ExtraInfo.cbData;
    if (ExtraInfo.cbData > 0) {
        pInfo->ExtraInfo.pbData = pbExtra;
        memcpy(pbExtra, ExtraInfo.pbData, ExtraInfo.cbData);
    } else
        pInfo->ExtraInfo.pbData = NULL;

    return TRUE;
}
#endif //CAPI_INCLUDE_REGISTER_OID
//+-------------------------------------------------------------------------
//  Allocate and load the string for the specified resource.
//
//  If LoadString or allocation fails, returns predefined pointer to an
//  empty string.
//--------------------------------------------------------------------------
static LPWSTR AllocAndLoadOIDNameString(
    IN UINT uID
    )
{
#ifndef _XBOX
    WCHAR wszResource[MAX_RESOURCE_OID_NAME_LENGTH + 1];
    int cchResource;
    int cbResource;
    LPWSTR pwszDst;

    cchResource = LoadStringU(hOIDInfoInst, uID, wszResource,
        MAX_RESOURCE_OID_NAME_LENGTH);
    assert(0 < cchResource);
    if (0 >= cchResource)
        return (LPWSTR) pwszNullName;

    cbResource = (cchResource + 1) * sizeof(WCHAR);
    pwszDst = (LPWSTR) OIDInfoAlloc(cbResource);
    assert(pwszDst);
    if (NULL == pwszDst)
        return (LPWSTR) pwszNullName;
    memcpy((BYTE *) pwszDst, (BYTE *) wszResource, cbResource);
    return pwszDst;
#else
	return NULL;
#endif
}

//+-------------------------------------------------------------------------
//  Allocate and copy the string.
//
//  If allocation fails, returns predefined pointer to an empty string.
//--------------------------------------------------------------------------
static LPWSTR AllocAndCopyOIDNameString(
    IN LPCWSTR pwszSrc
    )
{
    DWORD cbSrc;
    LPWSTR pwszDst;

    cbSrc = (wcslen(pwszSrc) + 1) * sizeof(WCHAR);
    pwszDst = (LPWSTR) OIDInfoAlloc(cbSrc);
    assert(pwszDst);
    if (NULL == pwszDst)
        return (LPWSTR) pwszNullName;
    memcpy((BYTE *) pwszDst, (BYTE *) pwszSrc, cbSrc);
    return pwszDst;
}

//+-------------------------------------------------------------------------
//  Does a LoadString for pwszName's initialized with resource IDs in groups
//  with fLocalize set.
//--------------------------------------------------------------------------
static void LoadGroupResources()
{
    DWORD i;
    for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
        if (GroupTable[i].fLocalize) {
            DWORD cInfo = GroupTable[i].cInfo;
            PCRYPT_OID_INFO pInfo = (PCRYPT_OID_INFO) GroupTable[i].rgInfo;
            for ( ; cInfo > 0; cInfo--, pInfo++) {
                UINT_PTR uID;
                uID = (UINT_PTR) pInfo->pwszName;
                if (uID <= 0xFFFF)
                    pInfo->pwszName = AllocAndLoadOIDNameString((UINT)uID);
                else
                    // ProcessDetach expects all pwszName's to be allocated
                    pInfo->pwszName = AllocAndCopyOIDNameString(
                        pInfo->pwszName);
            }
        }
    }
}

//+-------------------------------------------------------------------------
//  Load OID Information from the registry. Updates the RegBeforeGroup and
//  RegAfterGroup.
//
//  Loads resource strings in groups enabling localization of pwszName's.
//--------------------------------------------------------------------------
static void LoadFromRegistryAndResources()
{
    if (fLoadedFromRegAndResources)
        return;
    EnterCriticalSection(&LoadFromRegCriticalSection);
    if (!fLoadedFromRegAndResources) {
#ifdef CAPI_INCLUDE_REGISTER_OID
        CryptEnumOIDFunction(
            OID_INFO_ENCODING_TYPE,
            CRYPT_OID_FIND_OID_INFO_FUNC,
            NULL,                           // pszOID
            0,                              // dwFlags
            NULL,                           // pvArg
            EnumRegistryCallback
            );
#endif  //CAPI_INCLUDE_REGISTER_OID          
        LoadGroupResources();
        fLoadedFromRegAndResources = TRUE;
    }
    LeaveCriticalSection(&LoadFromRegCriticalSection);
}

//+-------------------------------------------------------------------------
//  Search the group according to the specified dwKeyType.
//
//  Note, the groups updated from the registry, RegBeforeGroup and
//  RegAfterGroup, may contain any GROUP_ID.
//--------------------------------------------------------------------------
static PCCRYPT_OID_INFO SearchGroup(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId,
    IN PCGROUP_ENTRY pGroup
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++) {
        if (dwGroupId && dwGroupId != pInfo->dwGroupId)
            continue;

        switch (dwKeyType) {
            case CRYPT_OID_INFO_OID_KEY:
                if (0 == _stricmp((LPSTR) pvKey, pInfo->pszOID))
                    return pInfo;
                break;
            case CRYPT_OID_INFO_NAME_KEY:
                if (0 == _wcsicmp((LPWSTR) pvKey, pInfo->pwszName))
                    return pInfo;
                break;
            case CRYPT_OID_INFO_ALGID_KEY:
                if (*((ALG_ID *) pvKey) == pInfo->Algid)
                    return pInfo;
                break;
            case CRYPT_OID_INFO_SIGN_KEY:
                {
                    ALG_ID *paiKey = (ALG_ID *) pvKey;
                    ALG_ID aiPubKey;

                    if (sizeof(ALG_ID) <= pInfo->ExtraInfo.cbData)
                        aiPubKey = *((ALG_ID *) pInfo->ExtraInfo.pbData);
                    else
                        aiPubKey = 0;

                    if (paiKey[0] == pInfo->Algid &&
                            paiKey[1] == aiPubKey)
                    return pInfo;
                }
                break;
            default:
                SetLastError((DWORD) E_INVALIDARG);
                return NULL;
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Find OID information. Returns NULL if unable to find any information
//  for the specified key and group.
//--------------------------------------------------------------------------
PCCRYPT_OID_INFO
WINAPI
CryptFindOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    )
{
    PCCRYPT_OID_INFO pInfo;

    LoadFromRegistryAndResources();

    if (RegBeforeGroup.cInfo && NULL != (pInfo = SearchGroup(
            dwKeyType,
            pvKey,
            dwGroupId,
            &RegBeforeGroup
            ))) return pInfo;
    if (0 == dwGroupId) {
        DWORD i;
        for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
            if (pInfo = SearchGroup(
                dwKeyType,
                pvKey,
                0,
                &GroupTable[i]
                )) return pInfo;
        }
    } else if (dwGroupId <= CRYPT_LAST_OID_GROUP_ID) {
        if (pInfo = SearchGroup(
                dwKeyType,
                pvKey,
                dwGroupId,
                &GroupTable[dwGroupId]
                )) return pInfo;
    }

    if (RegAfterGroup.cInfo && NULL != (pInfo = SearchGroup(
            dwKeyType,
            pvKey,
            dwGroupId,
            &RegAfterGroup
            ))) return pInfo;

    return NULL;
}


//+-------------------------------------------------------------------------
//  Enumerate the group.
//--------------------------------------------------------------------------
static BOOL EnumGroup(
    IN DWORD dwGroupId,
    IN PCGROUP_ENTRY pGroup,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++) {
        if (dwGroupId && dwGroupId != pInfo->dwGroupId)
            continue;

        if (!pfnEnumOIDInfo(pInfo, pvArg))
            return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Enumerate the OID information.
//
//  pfnEnumOIDInfo is called for each OID information entry.
//
//  Setting dwGroupId to 0 matches all groups. Otherwise, only enumerates
//  entries in the specified group.
//
//  dwFlags currently isn't used and must be set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumOIDInfo(
    IN DWORD dwGroupId,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    )
{
    LoadFromRegistryAndResources();

    if (RegBeforeGroup.cInfo && !EnumGroup(
            dwGroupId,
            &RegBeforeGroup,
            pvArg,
            pfnEnumOIDInfo
            )) return FALSE;
    if (0 == dwGroupId) {
        DWORD i;
        for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
            if (!EnumGroup(
                    0,                  // dwGroupId
                    &GroupTable[i],
                    pvArg,
                    pfnEnumOIDInfo
                    )) return FALSE;
        }
    } else if (dwGroupId <= CRYPT_LAST_OID_GROUP_ID) {
        if (!EnumGroup(
                dwGroupId,
                &GroupTable[dwGroupId],
                pvArg,
                pfnEnumOIDInfo
                )) return FALSE;
    }

    if (RegAfterGroup.cInfo && !EnumGroup(
            dwGroupId,
            &RegAfterGroup,
            pvArg,
            pfnEnumOIDInfo
            )) return FALSE;

    return TRUE;
}



//+=========================================================================
//  Localized Name Functions
//==========================================================================
#ifdef CAPI_INCLUDE_REGISTER_OID    

//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered localized name values.
//
//  Called within critical section
//
//  Note at ProcessDetach, the Info entry pwszLocalizedName strings are freed.
//  Therefore, for each Info entry, do a single allocation for both the
//  pwszLocalizedName and pwszCryptName. The pwszCryptName immediately
//  follows the pwszLocalizedName.
//--------------------------------------------------------------------------
static BOOL WINAPI EnumRegLocalizedNamesCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    BOOL fResult;
    DWORD cInfo = LocalizedGroupTable[REG_LOCALIZED_GROUP].cInfo;
    PLOCALIZED_NAME_INFO pInfo =
        LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo;

    assert(CRYPT_LOCALIZED_NAME_ENCODING_TYPE == dwEncodingType);
    assert(0 == _stricmp(CRYPT_OID_FIND_LOCALIZED_NAME_FUNC, pszFuncName));
    assert(0 == _stricmp(CRYPT_LOCALIZED_NAME_OID, pszOID));

    while (cValue--) {
        if (REG_SZ == rgdwValueType[cValue]) {
            LPCWSTR pwszLocalizedName = (LPCWSTR) rgpbValueData[cValue];
            DWORD cchLocalizedName;
            DWORD cbLocalizedName;
            LPCWSTR pwszCryptName = rgpwszValueName[cValue];
            DWORD cbCryptName;

            LPWSTR pwszBothNames;
            PLOCALIZED_NAME_INFO pNewInfo;

            // Check for empty name string
            cchLocalizedName = wcslen(pwszLocalizedName);
            if (0 == cchLocalizedName)
                continue;

            cbLocalizedName = (cchLocalizedName + 1) * sizeof(WCHAR);
            cbCryptName = (wcslen(pwszCryptName) + 1) * sizeof(WCHAR);

            if (NULL == (pwszBothNames = (LPWSTR) OIDInfoAlloc(
                    cbLocalizedName + cbCryptName)))
                goto OutOfMemory;

            if (NULL == (pNewInfo = (PLOCALIZED_NAME_INFO) OIDInfoRealloc(
                    pInfo, (cInfo + 1) * sizeof(LOCALIZED_NAME_INFO)))) {
                OIDInfoFree(pwszBothNames);
                goto OutOfMemory;
            }
            pInfo = pNewInfo;
            pInfo[cInfo].pwszLocalizedName = (LPCWSTR) pwszBothNames;
            memcpy(pwszBothNames, pwszLocalizedName, cbLocalizedName);
            pwszBothNames =
                (LPWSTR) ((BYTE *) pwszBothNames + cbLocalizedName);
            pInfo[cInfo].pwszCryptName = (LPCWSTR) pwszBothNames;
            memcpy(pwszBothNames, pwszCryptName, cbCryptName);
            cInfo++;
        }
    }
    fResult = TRUE;

CommonReturn:
    LocalizedGroupTable[REG_LOCALIZED_GROUP].cInfo = cInfo;
    LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo = pInfo;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
}
#endif    

static void LoadPredefinedNameResources()
{
    for (DWORD i = 0; i < PREDEFINED_NAME_CNT; i++) {
        LPWSTR pwszLocalizedName;

        // Note, the following always returns a non-NULL string pointer.
        pwszLocalizedName = AllocAndLoadOIDNameString(
            PredefinedNameTable[i].uIDLocalizedName);
        if (L'\0' == *pwszLocalizedName)
            pwszLocalizedName = NULL;
        PredefinedNameTable[i].pwszLocalizedName = (LPCWSTR) pwszLocalizedName;
    }
}

static void LoadLocalizedNamesFromRegAndResources()
{
    if (fLoadedLocalizedNames)
        return;

    EnterCriticalSection(&LoadFromRegCriticalSection);
    if (!fLoadedLocalizedNames) {
#ifdef CAPI_INCLUDE_REGISTER_OID    
        CryptEnumOIDFunction(
            CRYPT_LOCALIZED_NAME_ENCODING_TYPE,
            CRYPT_OID_FIND_LOCALIZED_NAME_FUNC,
            CRYPT_LOCALIZED_NAME_OID,
            0,                              // dwFlags
            NULL,                           // pvArg
            EnumRegLocalizedNamesCallback
            );
#endif //CAPI_INCLUDE_REGISTER_OID          
        LoadPredefinedNameResources();
        fLoadedLocalizedNames = TRUE;
    }
    LeaveCriticalSection(&LoadFromRegCriticalSection);
}

//+-------------------------------------------------------------------------
//  Find the localized name for the specified name. For example, find the
//  localized name for the "Root" system store name. A case insensitive
//  string comparison is done.
//
//  Returns NULL if unable to find the the specified name.
//--------------------------------------------------------------------------
LPCWSTR
WINAPI
CryptFindLocalizedName(
    IN LPCWSTR pwszCryptName
    )
{
    if (NULL == pwszCryptName || L'\0' == *pwszCryptName)
        return NULL;

    LoadLocalizedNamesFromRegAndResources();

    for (DWORD i = 0; i < LOCALIZED_GROUP_CNT; i++) {
        DWORD cInfo = LocalizedGroupTable[i].cInfo;
        PLOCALIZED_NAME_INFO pInfo = LocalizedGroupTable[i].rgInfo;
        for ( ; cInfo > 0; cInfo--, pInfo++) {
            if (0 == _wcsicmp(pwszCryptName, pInfo->pwszCryptName))
                return pInfo->pwszLocalizedName;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\oidinfo.h ===
#define         IDS_EXT_AUTHORITY_KEY_IDENTIFIER    (RESBASE+2000)
#define         IDS_EXT_KEY_ATTRIBUTES              (RESBASE+2001)
#define         IDS_EXT_KEY_USAGE_RESTRICTION       (RESBASE+2002)
#define         IDS_EXT_SUBJECT_ALT_NAME            (RESBASE+2003)
#define         IDS_EXT_ISSUER_ALT_NAME             (RESBASE+2004)
#define         IDS_EXT_BASIC_CONSTRAINTS           (RESBASE+2005)
#define         IDS_EXT_KEY_USAGE                   (RESBASE+2006)
#define         IDS_EXT_CERT_POLICIES               (RESBASE+2007)
#define         IDS_EXT_SUBJECT_KEY_IDENTIFIER      (RESBASE+2008)
#define         IDS_EXT_CRL_REASON_CODE             (RESBASE+2009)
#define         IDS_EXT_CRL_DIST_POINTS             (RESBASE+2010)
#define         IDS_EXT_ENHANCED_KEY_USAGE          (RESBASE+2011)
#define         IDS_EXT_AUTHORITY_INFO_ACCESS       (RESBASE+2012)
#define         IDS_EXT_CERT_EXTENSIONS             (RESBASE+2013)
#define         IDS_EXT_NEXT_UPDATE_LOCATION        (RESBASE+2014)
#define         IDS_EXT_YESNO_TRUST_ATTR            (RESBASE+2015)
#define         IDS_EXT_RSA_emailAddr               (RESBASE+2016)
#define         IDS_EXT_RSA_unstructName            (RESBASE+2017)
#define         IDS_EXT_RSA_contentType             (RESBASE+2018)
#define         IDS_EXT_RSA_messageDigest           (RESBASE+2019)
#define         IDS_EXT_RSA_signingTime             (RESBASE+2020)
#define         IDS_EXT_RSA_counterSign             (RESBASE+2021)
#define         IDS_EXT_RSA_challengePwd            (RESBASE+2022)
#define         IDS_EXT_RSA_unstructAddr            (RESBASE+2023)
#define         IDS_EXT_RSA_SMIMECapabilities       (RESBASE+2024)
#define         IDS_EXT_RSA_preferSignedData        (RESBASE+2025)
#define         IDS_EXT_PKIX_POLICY_QUALIFIER_CPS   (RESBASE+2026)
#define         IDS_EXT_PKIX_POLICY_QUALIFIER_USERNOTICE    (RESBASE+2027)
#define         IDS_EXT_PKIX_OCSP                   (RESBASE+2028)
#define         IDS_EXT_PKIX_CA_ISSUERS             (RESBASE+2029)
#define         IDS_EXT_MS_CERTIFICATE_TEMPLATE     (RESBASE+2030)
#define         IDS_EXT_ENROLLMENT_AGENT            (RESBASE+2031)
#define         IDS_EXT_ENROLL_CERTTYPE             (RESBASE+2032)
#define         IDS_EXT_CERT_MANIFOLD               (RESBASE+2033)
#define         IDS_EXT_NETSCAPE_CERT_TYPE          (RESBASE+2034)
#define         IDS_EXT_NETSCAPE_BASE_URL           (RESBASE+2035)
#define         IDS_EXT_NETSCAPE_REVOCATION_URL     (RESBASE+2036)
#define         IDS_EXT_NETSCAPE_CA_REVOCATION_URL  (RESBASE+2037)
#define         IDS_EXT_NETSCAPE_CERT_RENEWAL_URL   (RESBASE+2038)
#define         IDS_EXT_NETSCAPE_CA_POLICY_URL      (RESBASE+2039)
#define         IDS_EXT_NETSCAPE_SSL_SERVER_NAME    (RESBASE+2040)
#define         IDS_EXT_NETSCAPE_COMMENT            (RESBASE+2041)
#define         IDS_EXT_SPC_SP_AGENCY_INFO_OBJID    (RESBASE+2042)
#define         IDS_EXT_SPC_FINANCIAL_CRITERIA_OBJID        (RESBASE+2043)
#define         IDS_EXT_SPC_MINIMAL_CRITERIA_OBJID  (RESBASE+2044)
#define         IDS_EXT_COUNTRY_NAME                (RESBASE+2045)
#define         IDS_EXT_ORGANIZATION_NAME           (RESBASE+2046)
#define         IDS_EXT_ORGANIZATIONAL_UNIT_NAME    (RESBASE+2047)
#define         IDS_EXT_COMMON_NAME                 (RESBASE+2048)
#define         IDS_EXT_LOCALITY_NAME               (RESBASE+2049)
#define         IDS_EXT_STATE_OR_PROVINCE_NAME      (RESBASE+2050)
#define         IDS_EXT_TITLE                       (RESBASE+2051)
#define         IDS_EXT_GIVEN_NAME                  (RESBASE+2052)
#define         IDS_EXT_INITIALS                    (RESBASE+2053)
#define         IDS_EXT_SUR_NAME                    (RESBASE+2054)
#define         IDS_EXT_DOMAIN_COMPONENT            (RESBASE+2055)
#define         IDS_EXT_STREET_ADDRESS              (RESBASE+2056)
#define         IDS_EXT_DEVICE_SERIAL_NUMBER        (RESBASE+2057)
#define 	    IDS_EXT_CA_VERSION		            (RESBASE+2058)
#define 	    IDS_EXT_SERIALIZED		            (RESBASE+2059)
#define 	    IDS_EXT_NT_PRINCIPAL_NAME	        (RESBASE+2060)
#define 	    IDS_EXT_PRODUCT_UPDATE		        (RESBASE+2061)
#define 	    IDS_EXT_ENROLLMENT_NAME_VALUE_PAIR  (RESBASE+2062)
#define 	    IDS_EXT_OS_VERSION                  (RESBASE+2063)
#define 	    IDS_EXT_ENROLLMENT_CSP_PROVIDER     (RESBASE+2064)

#define         IDS_ENHKEY_PKIX_KP_SERVER_AUTH      (RESBASE+2500)
#define         IDS_ENHKEY_PKIX_KP_CLIENT_AUTH      (RESBASE+2501)
#define         IDS_ENHKEY_PKIX_KP_CODE_SIGNING     (RESBASE+2502)
#define         IDS_ENHKEY_PKIX_KP_EMAIL_PROTECTION (RESBASE+2503)
#define         IDS_ENHKEY_PKIX_KP_TIMESTAMP_SIGNING (RESBASE+2504)
#define         IDS_ENHKEY_KP_CTL_USAGE_SIGNING     (RESBASE+2505)
#define         IDS_ENHKEY_KP_TIME_STAMP_SIGNING    (RESBASE+2506)
#define         IDS_ENHKEY_PKIX_KP_IPSEC_END_SYSTEM (RESBASE+2507)
#define         IDS_ENHKEY_PKIX_KP_IPSEC_TUNNEL     (RESBASE+2508)
#define         IDS_ENHKEY_PKIX_KP_IPSEC_USER       (RESBASE+2509)
#define         IDS_ENHKEY_SERVER_GATED_CRYPTO      (RESBASE+2510)
#define         IDS_ENHKEY_SGC_NETSCAPE             (RESBASE+2511)
#define         IDS_ENHKEY_KP_EFS                   (RESBASE+2512)
#define         IDS_ENHKEY_KP_WHQL                  (RESBASE+2513)
#define         IDS_ENHKEY_KP_NT5                   (RESBASE+2514)
#define         IDS_ENHKEY_KP_OEM_WHQL              (RESBASE+2515)
#define         IDS_ENHKEY_KP_EMBEDDED_NT           (RESBASE+2516)
#define 	    IDS_ENHKEY_LICENSES		            (RESBASE+2517)
#define 	    IDS_ENHKEY_LICENSES_SERVER	        (RESBASE+2518)
#define 	    IDS_ENHKEY_SMARTCARD_LOGON	        (RESBASE+2519)
#define 	    IDS_ENHKEY_DRM			            (RESBASE+2520)

#define         IDS_SYS_NAME_ROOT                   (RESBASE+3000)
#define         IDS_SYS_NAME_MY                     (RESBASE+3001)
#define         IDS_SYS_NAME_TRUST                  (RESBASE+3002)
#define         IDS_SYS_NAME_CA                     (RESBASE+3003)
#define         IDS_SYS_NAME_USERDS                 (RESBASE+3004)
#define         IDS_SYS_NAME_SMARTCARD              (RESBASE+3005)
#define         IDS_SYS_NAME_ADDRESSBOOK            (RESBASE+3006)

#define         IDS_PHY_NAME_DEFAULT                (RESBASE+3100)
#define         IDS_PHY_NAME_GROUP_POLICY           (RESBASE+3101)
#define         IDS_PHY_NAME_LOCAL_MACHINE          (RESBASE+3102)
#define         IDS_PHY_NAME_DS_USER_CERT           (RESBASE+3104)
#define         IDS_PHY_NAME_ENTERPRISE             (RESBASE+3105)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\origin.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       origin.cpp
//
//  Contents:   Origin Identifier implementation
//
//  History:    10-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   CertGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetOriginIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pCertInfo->Issuer.pbData, pCertInfo->Issuer.cbData );
    MD5Update( &md5ctx, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData );

    MD5Update(
       &md5ctx,
       (LPBYTE)pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
       strlen( pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId )
       );

    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData
       );

    // BUGBUG: We assume that the unused public key bits are zero
    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a CTL
//
//----------------------------------------------------------------------------
BOOL WINAPI CtlGetOriginIdentifier (
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    PCTL_INFO  pCtlInfo = pCtlContext->pCtlInfo;
    HCRYPTMSG  hCryptMsg = pCtlContext->hCryptMsg;
    DWORD      cSigners;
    DWORD      cCount;
    DWORD      cbData;
    CERT_INFO  CertInfo;
    PCTL_USAGE pCtlUsage = &( pCtlContext->pCtlInfo->SubjectUsage );

    MD5Init( &md5ctx );

    if ( CryptMsgGetParam(
              hCryptMsg,
              CMSG_SIGNER_COUNT_PARAM,
              0,
              &cSigners,
              &cbData
              ) == FALSE )
    {
        return( FALSE );
    }

    for ( cCount = 0; cCount < cSigners; cCount++ )
    {
        if ( CryptMsgGetParam(
                  hCryptMsg,
                  CMSG_SIGNER_CERT_INFO_PARAM,
                  cCount,
                  &CertInfo,
                  &cbData
                  ) == FALSE )
        {
            return( FALSE );
        }

        MD5Update( &md5ctx, CertInfo.Issuer.pbData, CertInfo.Issuer.cbData );

        MD5Update(
           &md5ctx,
           CertInfo.SerialNumber.pbData,
           CertInfo.SerialNumber.cbData
           );
    }

    for ( cCount = 0; cCount < pCtlUsage->cUsageIdentifier; cCount++ )
    {
        MD5Update(
           &md5ctx,
           (LPBYTE)pCtlUsage->rgpszUsageIdentifier[cCount],
           strlen( pCtlUsage->rgpszUsageIdentifier[cCount] )
           );
    }

    MD5Update(
       &md5ctx,
       pCtlInfo->ListIdentifier.pbData,
       pCtlInfo->ListIdentifier.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI CrlGetOriginIdentifier (
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    PCRL_INFO  pCrlInfo = pCrlContext->pCrlInfo;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pCrlInfo->Issuer.pbData, pCrlInfo->Issuer.cbData );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\origin.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       origin.h
//
//  Contents:   Crypt Origin Identifier Definitions
//
//  History:    10-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ORIGIN_H__)
#define __ORIGIN_H__

//
// A CRYPT_ORIGIN_IDENTIFIER is an MD5 hash of selected components of a
// CAPI2 object.  This allows a unique identifier to be derived for any
// CAPI2 object where any two objects with the same origin identifier
// are the same object at possibly different points in its evolution.
// If those objects have the same HASH id then they are the same object
// at the same point in time.  For the main CAPI2 objects the selected
// components are as follows:
//
// Certificate: Issuer Name, Subject Name, Public Key
//
// CTL: All Issuer Name and Issuer Serial No. pairs, Usage, List Identifier
//
// CRL: Issuer Name (an issuer can only publish ONE CRL, Hygiene work in
//      progress)
//

// BUGBUG: Move to WINCRYPT.H
typedef BYTE CRYPT_ORIGIN_IDENTIFIER[ MD5DIGESTLEN ];

//
// Function prototypes
//

BOOL WINAPI CertGetOriginIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                );

BOOL WINAPI CtlGetOriginIdentifier (
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                );

BOOL WINAPI CrlGetOriginIdentifier (
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\oidfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       oidfunc.cpp
//
//  Contents:   Cryptographic Object ID (OID) Functions
//
//  Functions:  I_CryptOIDFuncDllMain
//              CryptInitOIDFunctionSet
//              CryptInstallOIDFunctionAddress
//
//              CryptSetOIDFunctionValue
//              CryptGetOIDFunctionValue
//              CryptRegisterOIDFunction
//              CryptUnregisterOIDFunction
//              CryptRegisterDefaultOIDFunction
//              CryptUnregisterDefaultOIDFunction
//              CryptEnumOIDFunction
//
//              CryptGetOIDFunctionAddress
//              CryptGetDefaultOIDDllList
//              CryptGetDefaultOIDFunctionAddress
//              CryptFreeOIDFunctionAddress
//
//  Comments:
//              For the CryptGetOIDFunctionAddress we search the installed
//              const and str lists without
//              entering the critical section. The adds which are within
//              the critical section update the list pointers in the proper
//              order to allow list searching without locking.
//
//              However, registry loads are done with OIDFunc
//              locked.
//
//              HOLDING OID LOCK WHILE DOING A LoadLibrary() or FreeLibrary()
//              MAY LEAD TO DEADLOCK !!!
//
//
//  History:    07-Nov-96    philh   created
//              09-Aug-98    philh   changed to NOT hold OID lock when calling
//                                   LoadLibrary() or FreeLibrary().
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include <xdbg.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

#ifdef UNDER_CE
STATIC
FARPROC
MyGetProcAddress(HMODULE hMod, LPCSTR pszName)
{
	ASSERT(!"MyGetProcAddress called");
	return NULL;
}
#else
#define MyGetProcAddress(hMod, pszName) GetProcAddress(hMod, pszName)
#endif

#define LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define CONST_OID_STR_PREFIX_CHAR   '#'

//+-------------------------------------------------------------------------
//  OID Element Type Definitions
//--------------------------------------------------------------------------
#define CONST_OID_TYPE          1
#define STR_OID_TYPE            2
#define DLL_OID_TYPE            3

//+-------------------------------------------------------------------------
//  Dll and Procedure Element Definitions
//--------------------------------------------------------------------------
typedef struct _DLL_ELEMENT DLL_ELEMENT, *PDLL_ELEMENT;
typedef struct _DLL_PROC_ELEMENT DLL_PROC_ELEMENT, *PDLL_PROC_ELEMENT;

struct _DLL_ELEMENT {
    DWORD                   dwOIDType;
    PDLL_ELEMENT            pNext;
    LPWSTR                  pwszDll;    // expanded
    HMODULE                 hDll;
    DWORD                   dwRefCnt;
    BOOL                    fLoaded;
    PDLL_PROC_ELEMENT       pProcHead;
    //LPFNCANUNLOADNOW        pfnDllCanUnloadNow;

    // The following are used to defer the freeing of Dlls until after waiting
    // at least one FREE_DLL_TIMEOUT.
    DWORD                   dwFreeCnt;  // 0, 1 or 2.
    PDLL_ELEMENT            pFreeNext;
    PDLL_ELEMENT            pFreePrev;
};

struct _DLL_PROC_ELEMENT {
    PDLL_PROC_ELEMENT       pNext;
    PDLL_ELEMENT            pDll;
    LPSTR                   pszName;
    void                    *pvAddr;    // NULL'ed when Dll is unloaded
};

// Linked list of all the Dlls. All proc elements are on one of the Dll
// element's proc list.
static PDLL_ELEMENT pDllHead;

// Linked list of Dlls waiting to be freed.
static PDLL_ELEMENT pFreeDllHead;

// Count of elements in the above list
static DWORD dwFreeDllCnt;

// When nonzero, a FreeDll callback has been registered.
static LONG lFreeDll;
static HANDLE hFreeDllRegWaitFor;

// 15 seconds
#define FREE_DLL_TIMEOUT    15000

//+-------------------------------------------------------------------------
//  Installed OID Element Definitions
//--------------------------------------------------------------------------
typedef struct _CONST_OID_FUNC_ELEMENT
    CONST_OID_FUNC_ELEMENT, *PCONST_OID_FUNC_ELEMENT;
struct _CONST_OID_FUNC_ELEMENT {
    DWORD                   dwOIDType;
    DWORD                   dwEncodingType;
    PCONST_OID_FUNC_ELEMENT pNext;
    DWORD_PTR               dwLowOID;
    DWORD_PTR               dwHighOID;
    HMODULE                 hDll;
    void                    **rgpvFuncAddr;
};

typedef struct _STR_OID_FUNC_ELEMENT
    STR_OID_FUNC_ELEMENT, *PSTR_OID_FUNC_ELEMENT;
struct _STR_OID_FUNC_ELEMENT {
    DWORD                   dwOIDType;
    DWORD                   dwEncodingType;
    PSTR_OID_FUNC_ELEMENT   pNext;
    LPSTR                   pszOID;
    HMODULE                 hDll;
    void                    *pvFuncAddr;
};

//+-------------------------------------------------------------------------
//  Registry OID Element Definitions
//--------------------------------------------------------------------------
typedef struct _REG_OID_FUNC_ELEMENT
    REG_OID_FUNC_ELEMENT, *PREG_OID_FUNC_ELEMENT;
struct _REG_OID_FUNC_ELEMENT {
    DWORD                   dwEncodingType;
    PREG_OID_FUNC_ELEMENT   pNext;
    union {
        DWORD_PTR               dwOID;
        LPSTR                   pszOID;
    };
    PDLL_PROC_ELEMENT       pDllProc;
};

//+-------------------------------------------------------------------------
//  Default registry DLL list Element Definitions
//--------------------------------------------------------------------------
typedef struct _DEFAULT_REG_ELEMENT
    DEFAULT_REG_ELEMENT, *PDEFAULT_REG_ELEMENT;
struct _DEFAULT_REG_ELEMENT {
    DWORD                   dwEncodingType;
    PDEFAULT_REG_ELEMENT    pNext;

    LPWSTR                  pwszDllList;
    DWORD                   cchDllList;

    DWORD                   cDll;
    LPWSTR                  *rgpwszDll;
    PDLL_PROC_ELEMENT       *rgpDllProc;
};

//+-------------------------------------------------------------------------
//  Function Set Definition
//--------------------------------------------------------------------------
typedef struct _FUNC_SET FUNC_SET, *PFUNC_SET;
struct _FUNC_SET {
    PFUNC_SET               pNext;
    LPSTR                   pszFuncName;
    PCONST_OID_FUNC_ELEMENT pConstOIDFuncHead;
    PCONST_OID_FUNC_ELEMENT pConstOIDFuncTail;
    PSTR_OID_FUNC_ELEMENT   pStrOIDFuncHead;
    PSTR_OID_FUNC_ELEMENT   pStrOIDFuncTail;

    // Following are updated with OIDFunc locked
    BOOL                    fRegLoaded;
    PREG_OID_FUNC_ELEMENT   pRegBeforeOIDFuncHead;
    PREG_OID_FUNC_ELEMENT   pRegAfterOIDFuncHead;
    PDEFAULT_REG_ELEMENT    pDefaultRegHead;
};

// Linked list of all the function sets
static PFUNC_SET pFuncSetHead;

// Used to protect the adding of function sets and elements to function sets.
// Protects the pDllHead list and registry loads.
static CRITICAL_SECTION OIDFuncCriticalSection;

//+-------------------------------------------------------------------------
//  OIDFunc lock and unlock functions
//--------------------------------------------------------------------------
static inline void LockOIDFunc()
{
    EnterCriticalSection(&OIDFuncCriticalSection);
}
static inline void UnlockOIDFunc()
{
    LeaveCriticalSection(&OIDFuncCriticalSection);
}


//+-------------------------------------------------------------------------
//  First try to get the EncodingType from the lower 16 bits. If 0, get
//  from the upper 16 bits.
//--------------------------------------------------------------------------
static inline DWORD GetEncodingType(
    IN DWORD dwEncodingType
    )
{
    return (dwEncodingType & CERT_ENCODING_TYPE_MASK) ?
        (dwEncodingType & CERT_ENCODING_TYPE_MASK) :
        (dwEncodingType & CMSG_ENCODING_TYPE_MASK) >> 16;
}

//+-------------------------------------------------------------------------
//  Duplicate the Dll library's handle
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
static HMODULE DuplicateLibrary(
    IN HMODULE hDll
    )
{
    // ASSERT(!"DuplicateLibrary called");
    return hDll;
}


//+-------------------------------------------------------------------------
//  Add one or more functions with a constant OID. The constant OIDs are
//  monotonically increasing.
//
//  Upon entry, pFuncSet hasn't been added to the searched pFuncSetHead list.
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC BOOL AddConstOIDFunc(
    IN HMODULE hDll,
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN DWORD cFuncEntry,
    IN const CRYPT_OID_FUNC_ENTRY rgFuncEntry[]
    )
{
    PCONST_OID_FUNC_ELEMENT pEle;
    DWORD cbEle;
    void **ppvFuncAddr;

    cbEle = sizeof(CONST_OID_FUNC_ELEMENT) + cFuncEntry * sizeof(void *);
    if (NULL == (pEle = (PCONST_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        return FALSE;

    pEle->dwOIDType = CONST_OID_TYPE;
    pEle->dwEncodingType = dwEncodingType;
    pEle->pNext = NULL;
    pEle->dwLowOID = (DWORD_PTR) rgFuncEntry[0].pszOID;
    pEle->dwHighOID = pEle->dwLowOID + cFuncEntry - 1;
    pEle->hDll = DuplicateLibrary(hDll);
    ppvFuncAddr =
        (void **) (((BYTE *) pEle) + sizeof(CONST_OID_FUNC_ELEMENT));
    pEle->rgpvFuncAddr = ppvFuncAddr;

    for (DWORD i = 0; i < cFuncEntry; i++, ppvFuncAddr++)
        *ppvFuncAddr = rgFuncEntry[i].pvFuncAddr;

    if (pFuncSet->pConstOIDFuncTail)
        pFuncSet->pConstOIDFuncTail->pNext = pEle;
    else
        pFuncSet->pConstOIDFuncHead = pEle;
    pFuncSet->pConstOIDFuncTail = pEle;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Add single function with a string OID.
//
//  Upon entry, pFuncSet hasn't been added to the searched pFuncSetHead list.
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC BOOL AddStrOIDFunc(
    IN HMODULE hDll,
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN const CRYPT_OID_FUNC_ENTRY *pFuncEntry
    )
{
    PSTR_OID_FUNC_ELEMENT pEle;
    DWORD cbEle;
    DWORD cchOID;
    LPSTR psz;

    cchOID = strlen(pFuncEntry->pszOID) + 1;
    cbEle = sizeof(STR_OID_FUNC_ELEMENT) + cchOID;
    if (NULL == (pEle = (PSTR_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        return FALSE;

    pEle->dwOIDType = STR_OID_TYPE;
    pEle->dwEncodingType = dwEncodingType;
    pEle->pNext = NULL;
    psz = (LPSTR) (((BYTE *) pEle) + sizeof(STR_OID_FUNC_ELEMENT));
    pEle->pszOID = psz;
    memcpy(psz, pFuncEntry->pszOID, cchOID);
    pEle->hDll = DuplicateLibrary(hDll);
    pEle->pvFuncAddr = pFuncEntry->pvFuncAddr;

    if (pFuncSet->pStrOIDFuncTail)
        pFuncSet->pStrOIDFuncTail->pNext = pEle;
    else
        pFuncSet->pStrOIDFuncHead = pEle;
    pFuncSet->pStrOIDFuncTail = pEle;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Free the constant or string function elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeFuncSetConstAndStrElements(
    IN OUT PFUNC_SET pFuncSet
    )
{
    PCONST_OID_FUNC_ELEMENT pConstEle;
    PSTR_OID_FUNC_ELEMENT pStrEle;

    pConstEle = pFuncSet->pConstOIDFuncHead;
    while (pConstEle) {
        PCONST_OID_FUNC_ELEMENT pNextEle = pConstEle->pNext;
        if (pConstEle->hDll)
      	{
	        ASSERT(!"FreeLibrary called");
            //FreeLibrary(pConstEle->hDll);
       	}
        PkiFree(pConstEle);
        pConstEle = pNextEle;
    }

    pStrEle = pFuncSet->pStrOIDFuncHead;
    while (pStrEle) {
        PSTR_OID_FUNC_ELEMENT pNextEle = pStrEle->pNext;
        if (pStrEle->hDll)
      	{
	        ASSERT(!"FreeLibrary called");
            //FreeLibrary(pStrEle->hDll);
       	}
        PkiFree(pStrEle);
        pStrEle = pNextEle;
    }
}

//+-------------------------------------------------------------------------
//  Free the function set and its elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeFuncSet(
    IN OUT PFUNC_SET pFuncSet
    )
{
    PREG_OID_FUNC_ELEMENT pRegEle;
    PDEFAULT_REG_ELEMENT  pDefaultReg;

    FreeFuncSetConstAndStrElements(pFuncSet);

    pRegEle = pFuncSet->pRegBeforeOIDFuncHead;
    while (pRegEle) {
        PREG_OID_FUNC_ELEMENT pNextEle = pRegEle->pNext;
        PkiFree(pRegEle);
        pRegEle = pNextEle;
    }

    pRegEle = pFuncSet->pRegAfterOIDFuncHead;
    while (pRegEle) {
        PREG_OID_FUNC_ELEMENT pNextEle = pRegEle->pNext;
        PkiFree(pRegEle);
        pRegEle = pNextEle;
    }

    pDefaultReg = pFuncSet->pDefaultRegHead;
    while (pDefaultReg) {
        PDEFAULT_REG_ELEMENT pNext = pDefaultReg->pNext;
        PkiFree(pDefaultReg);
        pDefaultReg = pNext;
    }

    PkiFree(pFuncSet);
}

//+-------------------------------------------------------------------------
//  Free the Dll and its proc elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeDll(
    IN OUT PDLL_ELEMENT pDll
    )
{
    PDLL_PROC_ELEMENT pProcEle;

    pProcEle = pDll->pProcHead;
    while (pProcEle) {
        PDLL_PROC_ELEMENT pNextEle = pProcEle->pNext;
        PkiFree(pProcEle);
        pProcEle = pNextEle;
    }

    if (pDll->fLoaded) {
        assert(pDll->hDll);
        ASSERT(!"FreeLibrary called");
        //FreeLibrary(pDll->hDll);
    }

    PkiFree(pDll);
}


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptOIDFuncDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        InitializeCriticalSection(&OIDFuncCriticalSection);
        break;

    case DLL_PROCESS_DETACH:
        // Do interlock to guard against a potential race condition with
        // the RegWaitFor callback thread. We doing this without doing
        // a LockOIDFunc().
#ifndef CE_BUILD        
        if (InterlockedExchange(&lFreeDll, 0)) {
            assert(hFreeDllRegWaitFor);
            ILS_UnregisterWait(hFreeDllRegWaitFor);
            hFreeDllRegWaitFor = NULL;
        }
#endif        

        while (pFuncSetHead) {
            PFUNC_SET pFuncSet = pFuncSetHead;
            pFuncSetHead = pFuncSet->pNext;
            FreeFuncSet(pFuncSet);
        }

        while (pDllHead) {
            PDLL_ELEMENT pDll = pDllHead;
            pDllHead = pDll->pNext;
            FreeDll(pDll);
        }
        DeleteCriticalSection(&OIDFuncCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Initialize and return handle to the OID function set identified by its
//  function name.
//
//  If the set already exists, a handle to the existing set is returned.
//--------------------------------------------------------------------------
HCRYPTOIDFUNCSET
WINAPI
CryptInitOIDFunctionSet(
    IN LPCSTR pszFuncName,
    IN DWORD dwFlags
    )
{
    PFUNC_SET pFuncSet;

    LockOIDFunc();

    // See if the set already exists
    for (pFuncSet = pFuncSetHead; pFuncSet; pFuncSet = pFuncSet->pNext) {
        if (0 == strcmp(pszFuncName, pFuncSet->pszFuncName))
            break;
    }
    if (NULL == pFuncSet) {
        // Allocate and initialize a new set
        DWORD cchFuncName = strlen(pszFuncName) + 1;
        if (pFuncSet = (PFUNC_SET) PkiZeroAlloc(
                sizeof(FUNC_SET) + cchFuncName)) {
            LPSTR psz = (LPSTR) (((BYTE *) pFuncSet) + sizeof(FUNC_SET));
            pFuncSet->pszFuncName = psz;
            memcpy(psz, pszFuncName, cchFuncName);

            pFuncSet->pNext = pFuncSetHead;
            pFuncSetHead = pFuncSet;
        }
    }

    UnlockOIDFunc();

    return (HCRYPTOIDFUNCSET) pFuncSet;
}

//+-------------------------------------------------------------------------
//  Install a set of callable OID function addresses.
//
//  By default the functions are installed at end of the list.
//  Set CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG to install at beginning of list.
//
//  hModule should be updated with the hModule passed to DllMain to prevent
//  the Dll containing the function addresses from being unloaded by
//  CryptGetOIDFuncAddress/CryptFreeOIDFunctionAddress. This would be the
//  case when the Dll has also regsvr32'ed OID functions via
//  CryptRegisterOIDFunction.
//
//  DEFAULT functions are installed by setting rgFuncEntry[].pszOID =
//  CRYPT_DEFAULT_OID.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptInstallOIDFunctionAddress(
    IN HMODULE hModule,         // hModule passed to DllMain
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN DWORD cFuncEntry,
    IN const CRYPT_OID_FUNC_ENTRY rgFuncEntry[],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    PFUNC_SET pFuncSet;
    FUNC_SET AddFuncSet;
    memset(&AddFuncSet, 0, sizeof(AddFuncSet));
    int ConstFirst = -1;
    int ConstLast;
    DWORD_PTR dwOID;
    DWORD_PTR dwLastOID = 0;
    DWORD i;

    dwEncodingType = GetEncodingType(dwEncodingType);
    if (NULL == (pFuncSet = (PFUNC_SET) CryptInitOIDFunctionSet(
            pszFuncName, 0)))
        return FALSE;


    // Don't need to hold lock while updating local copy of AddFuncSet.

    for (i = 0; i < cFuncEntry; i++) {
        if (0xFFFF >= (dwOID = (DWORD_PTR) rgFuncEntry[i].pszOID)) {
            if (ConstFirst < 0)
                ConstFirst = i;
            else if (dwOID != dwLastOID + 1) {
                if (!AddConstOIDFunc(
                        hModule,
                        dwEncodingType,
                        &AddFuncSet,
                        ConstLast - ConstFirst + 1,
                        &rgFuncEntry[ConstFirst]
                        )) goto AddConstOIDFuncError;
                ConstFirst = i;
            }
            ConstLast = i;
            dwLastOID = dwOID;
        } else {
            if (ConstFirst >= 0) {
                if (!AddConstOIDFunc(
                        hModule,
                        dwEncodingType,
                        &AddFuncSet,
                        ConstLast - ConstFirst + 1,
                        &rgFuncEntry[ConstFirst]
                        )) goto AddConstOIDFuncError;
                ConstFirst = -1;
            }

            if (!AddStrOIDFunc(
                    hModule,
                    dwEncodingType,
                    &AddFuncSet,
                    &rgFuncEntry[i]
                    )) goto AddStrOIDFuncError;
        }
    }
    if (ConstFirst >= 0) {
        if (!AddConstOIDFunc(
                hModule,
                dwEncodingType,
                &AddFuncSet,
                ConstLast - ConstFirst + 1,
                &rgFuncEntry[ConstFirst]
                )) goto AddConstOIDFuncError;
    }

    // NOTE:::
    //
    //  Since the get function accesses the lists without entering the critical
    //  section, the following pointers must be updated in the correct
    //  order.  Note, Get doesn't access the tail.

    LockOIDFunc();

    if (AddFuncSet.pConstOIDFuncHead) {
        if (NULL == pFuncSet->pConstOIDFuncHead) {
            pFuncSet->pConstOIDFuncHead = AddFuncSet.pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncTail = AddFuncSet.pConstOIDFuncTail;
        } else if (dwFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
            AddFuncSet.pConstOIDFuncTail->pNext = pFuncSet->pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncHead = AddFuncSet.pConstOIDFuncHead;
        } else {
            pFuncSet->pConstOIDFuncTail->pNext = AddFuncSet.pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncTail = AddFuncSet.pConstOIDFuncTail;
        }
    }

    if (AddFuncSet.pStrOIDFuncHead) {
        if (NULL == pFuncSet->pStrOIDFuncHead) {
            pFuncSet->pStrOIDFuncHead = AddFuncSet.pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncTail = AddFuncSet.pStrOIDFuncTail;
        } else if (dwFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
            AddFuncSet.pStrOIDFuncTail->pNext = pFuncSet->pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncHead = AddFuncSet.pStrOIDFuncHead;
        } else {
            pFuncSet->pStrOIDFuncTail->pNext = AddFuncSet.pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncTail = AddFuncSet.pStrOIDFuncTail;
        }
    }

    UnlockOIDFunc();
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    FreeFuncSetConstAndStrElements(&AddFuncSet);
    goto CommonReturn;
TRACE_ERROR(AddConstOIDFuncError)
TRACE_ERROR(AddStrOIDFuncError)
}

STATIC LPSTR EncodingTypeToRegName(
    IN DWORD dwEncodingType
    )
{
    LPSTR pszRegName;
    DWORD cchRegName;
    char szEncodingTypeValue[33];

    dwEncodingType = GetEncodingType(dwEncodingType);
    _ltoa(dwEncodingType, szEncodingTypeValue, 10);
    cchRegName = strlen(CRYPT_OID_REG_ENCODING_TYPE_PREFIX) +
        strlen(szEncodingTypeValue) +
        1;

    if (pszRegName = (LPSTR) PkiNonzeroAlloc(cchRegName)) {
        strcpy(pszRegName, CRYPT_OID_REG_ENCODING_TYPE_PREFIX);
        strcat(pszRegName, szEncodingTypeValue);
    }

    return pszRegName;
}

// Returns FALSE for an invalid EncodingType reg name
STATIC BOOL RegNameToEncodingType(
    IN LPCSTR pszRegEncodingType,
    OUT DWORD *pdwEncodingType
    )
{
    BOOL fResult = FALSE;
    DWORD dwEncodingType = 0;
    const DWORD cchPrefix = strlen(CRYPT_OID_REG_ENCODING_TYPE_PREFIX);
    if (pszRegEncodingType && (DWORD) strlen(pszRegEncodingType) >= cchPrefix &&
            0 == _strnicmp(pszRegEncodingType, CRYPT_OID_REG_ENCODING_TYPE_PREFIX, cchPrefix)) {
        long lEncodingType;
        lEncodingType = atol(pszRegEncodingType + cchPrefix);
        if (lEncodingType >= 0 && lEncodingType <= 0xFFFF) {
            dwEncodingType = (DWORD) lEncodingType;
            fResult = TRUE;
        }
    }
    *pdwEncodingType = dwEncodingType;
    return fResult;
}

#ifdef CAPI_INCLUDE_REGISTER_OID
STATIC LPSTR FormatOIDFuncRegName(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID
    )
{

    LPSTR pszRegEncodingType;
    LPSTR pszRegName;
    DWORD cchRegName;
    char szOID[34];

    if (pszOID == NULL) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    if (NULL == (pszRegEncodingType = EncodingTypeToRegName(dwEncodingType)))
        return NULL;

    if ((DWORD_PTR) pszOID <= 0xFFFF) {
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((long) ((DWORD_PTR)pszOID), szOID + 1, 10);
        pszOID = szOID;
    }

    cchRegName = strlen(CRYPT_OID_REGPATH "\\") +
        strlen(pszRegEncodingType) + 1 +
        strlen(pszFuncName) + 1 +
        strlen(pszOID) +
        1;

    if (pszRegName = (LPSTR) PkiNonzeroAlloc(cchRegName)) {
        strcpy(pszRegName, CRYPT_OID_REGPATH "\\");
        strcat(pszRegName, pszRegEncodingType);
        strcat(pszRegName, "\\");
        strcat(pszRegName, pszFuncName);
        strcat(pszRegName, "\\");
        strcat(pszRegName, pszOID);
    }

    PkiFree(pszRegEncodingType);
    return pszRegName;
}

//+-------------------------------------------------------------------------
//  Set the value for the specified encoding type, function name, OID and
//  value name.
//
//  See RegSetValueEx for the possible value types.
//
//  String types are UNICODE.
//
//  If pbValueData == NULL and cbValueData == 0, deletes the value.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSetOIDFunctionValue(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValueType,
    IN const BYTE *pbValueData,
    IN DWORD cbValueData
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    HKEY hKey = NULL;
    DWORD dwDisposition;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    if (ERROR_SUCCESS != (lStatus = RegCreateKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition)))
        goto RegCreateKeyError;

    if (NULL == pbValueData && 0 == cbValueData) {
        if (ERROR_SUCCESS != (lStatus = RegDeleteValueU(
                hKey,
                pwszValueName)))
            goto RegDeleteValueError;
    } else {
        if (ERROR_SUCCESS != (lStatus = RegSetValueExU(
                hKey,
                pwszValueName,
                0,          // dwReserved
                dwValueType,
                pbValueData,
                cbValueData)))
            goto RegSetValueError;
    }

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegCreateKeyError, lStatus)
SET_ERROR_VAR(RegDeleteValueError, lStatus)
SET_ERROR_VAR(RegSetValueError, lStatus)
}


//+-------------------------------------------------------------------------
//  Get the value for the specified encoding type, function name, OID and
//  value name.
//
//  See RegEnumValue for the possible value types.
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetOIDFunctionValue(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValueType,
    OUT BYTE *pbValueData,
    IN OUT DWORD *pcbValueData
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    HKEY hKey = NULL;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    if (ERROR_SUCCESS != (lStatus = RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                  // dwReserved
            KEY_READ,
            &hKey))) {
        if (ERROR_FILE_NOT_FOUND == lStatus) {
            // Inhibit error tracing
            SetLastError((DWORD) lStatus);
            goto ErrorReturn;
        }
        goto RegOpenKeyError;
    }

    if (ERROR_SUCCESS != (lStatus = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // lpdwReserved
            pdwValueType,
            pbValueData,
            pcbValueData))) goto RegQueryValueError;

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    *pdwValueType = 0;
    *pcbValueData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegOpenKeyError, lStatus)
SET_ERROR_VAR(RegQueryValueError, lStatus)
}


//+-------------------------------------------------------------------------
//  Register the Dll containing the function to be called for the specified
//  encoding type, function name and OID.
//
//  pwszDll may contain environment-variable strings
//  which are ExpandEnvironmentStrings()'ed before loading the Dll.
//
//  In addition to registering the DLL, you may override the
//  name of the function to be called. For example,
//      pszFuncName = "CryptDllEncodeObject",
//      pszOverrideFuncName = "MyEncodeXyz".
//  This allows a Dll to export multiple OID functions for the same
//  function name without needing to interpose its own OID dispatcher function.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN OPTIONAL LPCWSTR pwszDll,
    IN OPTIONAL LPCSTR pszOverrideFuncName
    )
{
    BOOL fResult;
    LPWSTR pwszOverrideFuncName = NULL;

    if (pwszDll) {
        if (!CryptSetOIDFunctionValue(
                dwEncodingType,
                pszFuncName,
                pszOID,
                CRYPT_OID_REG_DLL_VALUE_NAME,
                REG_SZ,
                (BYTE *) pwszDll,
                (wcslen(pwszDll) + 1) * sizeof(WCHAR)))
            goto SetDllError;
    }

    if (pszOverrideFuncName) {
        if (NULL == (pwszOverrideFuncName = MkWStr(
                (LPSTR) pszOverrideFuncName)))
            goto MkWStrError;
        if (!CryptSetOIDFunctionValue(
                dwEncodingType,
                pszFuncName,
                pszOID,
                CRYPT_OID_REG_FUNC_NAME_VALUE_NAME,
                REG_SZ,
                (BYTE *) pwszOverrideFuncName,
                (wcslen(pwszOverrideFuncName) + 1) * sizeof(WCHAR)))
            goto SetFuncNameError;
    }

    fResult = TRUE;
CommonReturn:
    if (pwszOverrideFuncName)
        FreeWStr(pwszOverrideFuncName);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetDllError)
TRACE_ERROR(SetFuncNameError)
TRACE_ERROR(MkWStrError)
}

//+-------------------------------------------------------------------------
//  Unregister the Dll containing the function to be called for the specified
//  encoding type, function name and OID.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUnregisterOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    LPSTR pszRegOID;
    HKEY hKey = NULL;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    // Separate off the OID component of the RegName. Its the
    // last component of the name.
    pszRegOID = pszRegName + strlen(pszRegName);
    while (*pszRegOID != '\\')
        pszRegOID--;
    *pszRegOID++ = '\0';

    if (ERROR_SUCCESS != (lStatus = RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                  // dwReserved
            KEY_WRITE,
            &hKey))) goto RegOpenKeyError;

    if (ERROR_SUCCESS != (lStatus = RegDeleteKeyA(
            hKey,
            pszRegOID)))
        goto RegDeleteKeyError;

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegOpenKeyError, lStatus)
SET_ERROR_VAR(RegDeleteKeyError, lStatus)
}

STATIC BOOL GetDefaultDllList(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    OUT LPWSTR pwszList,
    IN OUT DWORD *pcchList
    )
{
    BOOL fResult;
    DWORD dwType;
    DWORD cchList;
    DWORD cbList;

    cchList = *pcchList;
    if (pwszList) {
        if (cchList < 3)
            goto InvalidArg;
        else
            // make room for two extra null terminators
            cchList -= 2;
    } else
        cchList = 0;

    cbList = cchList * sizeof(WCHAR);
    fResult = CryptGetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            &dwType,
            (BYTE *) pwszList,
            &cbList);
    cchList = cbList / sizeof(WCHAR);
    if (!fResult) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            if (cchList)
                cchList += 2;
            goto GetOIDFunctionValueError;
        }
        cchList = 0;
    } else if (!(REG_MULTI_SZ == dwType ||
            REG_SZ == dwType || REG_EXPAND_SZ == dwType))
        goto BadDefaultListRegType;

    if (pwszList) {
        // Ensure the list has two null terminators
        pwszList[cchList++] = L'\0';
        pwszList[cchList++] = L'\0';
    } else {
        if (cchList == 0)
            cchList = 3;
        else
            cchList += 2;
    }
    fResult = TRUE;
CommonReturn:
    *pcchList = cchList;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOIDFunctionValueError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(BadDefaultListRegType, E_INVALIDARG)
}

// Remove any entries following the first empty string.
STATIC DWORD AdjustDefaultListLength(
    IN LPCWSTR pwszList
    )
{
    LPCWSTR pwsz = pwszList;
    DWORD cch;
    while (cch = wcslen(pwsz))
        pwsz += cch + 1;

    return (DWORD)(pwsz - pwszList) + 1;
}

//+-------------------------------------------------------------------------
//  Register the Dll containing the default function to be called for the
//  specified encoding type and function name.
//
//  Unlike CryptRegisterOIDFunction, you can't override the function name
//  needing to be exported by the Dll.
//
//  The Dll is inserted before the entry specified by dwIndex.
//    dwIndex == 0, inserts at the beginning.
//    dwIndex == CRYPT_REGISTER_LAST_INDEX, appends at the end.
//
//  pwszDll may contain environment-variable strings
//  which are ExpandEnvironmentStrings()'ed before loading the Dll.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterDefaultOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN DWORD dwIndex,
    IN LPCWSTR pwszDll
    )
{
    BOOL fResult;
    LPWSTR pwszDllList;   // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;

    LPWSTR pwsz, pwszInsert, pwszSrc, pwszDest;
    DWORD cch, cchRemain;

    if (NULL == pwszDll || L'\0' == *pwszDll)
        goto InvalidArg;
    cchDll = wcslen(pwszDll) + 1;

    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            NULL,                   // pwszDllList
            &cchDllList)) goto GetDefaultDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca((cchDllList + cchDll) * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            pwszDllList,
            &cchDllList)) goto GetDefaultDllListError;

    // Remove entries following the first empty entry
    assert(AdjustDefaultListLength(pwszDllList) <= cchDllList);
    cchDllList = AdjustDefaultListLength(pwszDllList);

    // Check if the Dll already exists in the list
    pwsz = pwszDllList;
    while (cch = wcslen(pwsz)) {
        if (0 == _wcsicmp(pwsz, pwszDll))
            goto DllExistsError;
        pwsz += cch + 1;
    }

    // Find the Null terminated DLL in the DllList to insert before.
    // We insert before the dwIndex.
    pwszInsert = pwszDllList;
    while (dwIndex-- && 0 != (cch = wcslen(pwszInsert)))
        pwszInsert += cch + 1;

    // Before inserting, we need to move all the remaining entries in the
    // existing DllList.
    //
    // Note, there must be at least the final zero terminator at
    // pwszDllList[cchDllList - 1].
    assert(pwszInsert < pwszDllList + cchDllList);
    if (pwszInsert >= pwszDllList + cchDllList)
        goto BadRegMultiSzError;
    cchRemain = (DWORD)((pwszDllList + cchDllList) - pwszInsert);
    assert(cchRemain);
    pwszSrc = pwszDllList + cchDllList - 1;
    pwszDest = pwszSrc + cchDll;
    while (cchRemain--)
        *pwszDest-- = *pwszSrc--;
    assert(pwszSrc + 1 == pwszInsert);

    // Insert the pwszDll
    memcpy(pwszInsert, pwszDll, cchDll * sizeof(WCHAR));

    if (!CryptSetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            REG_MULTI_SZ,
            (BYTE *) pwszDllList,
            (cchDllList + cchDll) * sizeof(WCHAR))) goto SetDllListError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(DllExistsError, ERROR_FILE_EXISTS)
SET_ERROR(BadRegMultiSzError, E_INVALIDARG)
TRACE_ERROR(GetDefaultDllListError)
TRACE_ERROR(SetDllListError)
}

BOOL
WINAPI
CryptUnregisterDefaultOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCWSTR pwszDll
    )
{
    BOOL fResult;
    LPWSTR pwszDllList;   // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;

    LPWSTR pwszDelete, pwszMove;
    DWORD cchDelete, cchRemain;

    if (NULL == pwszDll || L'\0' == *pwszDll)
        goto InvalidArg;
    cchDll = wcslen(pwszDll) + 1;

    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            NULL,                   // pwszDllList
            &cchDllList)) goto GetDefaultDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            pwszDllList,
            &cchDllList)) goto GetDefaultDllListError;

    // Remove entries following the first empty entry
    assert(AdjustDefaultListLength(pwszDllList) <= cchDllList);
    cchDllList = AdjustDefaultListLength(pwszDllList);

    // Search the DllList for a match
    pwszDelete = pwszDllList;
    while (cchDelete = wcslen(pwszDelete)) {
        if (0 == _wcsicmp(pwszDll, pwszDelete))
            break;
        pwszDelete += cchDelete + 1;
    }

    if (0 == cchDelete) goto DllNotFound;
    cchDelete++;
    assert(cchDelete == cchDll);

    // Move all the Dll entries that follow.
    //
    // Note, there must be at least the final zero terminator at
    // pwszDllList[cchDllList - 1].
    pwszMove = pwszDelete + cchDelete;
    assert(pwszMove < pwszDllList + cchDllList);
    if (pwszMove >= pwszDllList + cchDllList)
        goto BadRegMultiSzError;
    cchRemain = (DWORD)((pwszDllList + cchDllList) - pwszMove);
    assert(cchRemain);
    while (cchRemain--)
        *pwszDelete++ = *pwszMove++;

    if (!CryptSetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            REG_MULTI_SZ,
            (BYTE *) pwszDllList,
            (cchDllList - cchDelete) * sizeof(WCHAR))) goto SetDllListError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(DllNotFound, ERROR_FILE_NOT_FOUND)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(BadRegMultiSzError, E_INVALIDARG)
TRACE_ERROR(GetDefaultDllListError)
TRACE_ERROR(SetDllListError)
}

#define MAX_SUBKEY_LEN      128

STATIC HKEY GetNextRegSubKey(
    IN HKEY hKey,
    IN OUT DWORD *piSubKey,
    IN LPCSTR pszFuncNameMatch,
    OUT char szSubKeyName[MAX_SUBKEY_LEN]
    )
{
    HKEY hSubKey;

    if (pszFuncNameMatch && *pszFuncNameMatch) {
        if ((*piSubKey)++ > 0 || strlen(pszFuncNameMatch) >= MAX_SUBKEY_LEN)
            return NULL;
        strcpy(szSubKeyName, pszFuncNameMatch);
    } else {
        if (ERROR_SUCCESS != RegEnumKeyA(
                hKey,
                (*piSubKey)++,
                szSubKeyName,
                MAX_SUBKEY_LEN))
            return NULL;
    }

    if (ERROR_SUCCESS == RegOpenKeyExA(
            hKey,
            szSubKeyName,
            0,                  // dwReserved
            KEY_READ,
            &hSubKey))
        return hSubKey;
    else
        return NULL;
}

STATIC BOOL GetRegValues(
    IN HKEY hKey,
    OUT void **ppvAlloc,
    OUT DWORD *pcValue,
    OUT DWORD **ppdwValueType,
    OUT LPWSTR **pppwszValueName,
    OUT BYTE ***pppbValueData,
    OUT DWORD **ppcbValueData
    )
{
    BOOL fResult;
    LONG lStatus;

    void *pvAlloc = NULL;

    DWORD cValue;
    DWORD iValue;
    DWORD cchMaxName;
    DWORD cbMaxData;
    DWORD cbAlignData;

    DWORD *pdwValueType;
    LPWSTR *ppwszValueName;
    BYTE **ppbValueData;
    DWORD *pcbValueData;

    LPWSTR pwszName;
    BYTE *pbData;

    if (ERROR_SUCCESS != (lStatus = RegQueryInfoKeyU(
            hKey,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &cValue,
            &cchMaxName,
            &cbMaxData,
            NULL,
            NULL
            ))) goto RegQueryInfoKeyError;

    // Do a single allocation for all the arrays, value names and
    // value data. Update the array pointers.
    if (cValue > 0) {
        BYTE *pbAlloc;
        DWORD cbAlloc;

        // Include NULL terminator for the name and align the data length
        // Also, include two NULL terminators to be added for the data.
        // Ensures REG_MULTI_SZ is always NULL terminated.
        cchMaxName++;
        if (4 > cbMaxData)
            cbMaxData = 4;
        cbAlignData = LEN_ALIGN(cbMaxData + 2 * sizeof(WCHAR));

        cbAlloc = (sizeof(DWORD) + sizeof(LPWSTR) + sizeof(BYTE *) +
             sizeof(DWORD) + cchMaxName * sizeof(WCHAR) + cbAlignData) * cValue;
        if (NULL == (pvAlloc = PkiNonzeroAlloc(cbAlloc)))
            goto OutOfMemory;

        pbAlloc = (BYTE *) pvAlloc;

        ppwszValueName = (LPWSTR *) pbAlloc;
        pbAlloc += sizeof(LPWSTR) * cValue;
        ppbValueData = (BYTE **) pbAlloc;
        pbAlloc += sizeof(BYTE *) * cValue;
        pdwValueType = (DWORD *) pbAlloc;
        pbAlloc += sizeof(DWORD) * cValue;
        pcbValueData = (DWORD *) pbAlloc;
        pbAlloc += sizeof(DWORD) * cValue;

        pbData = pbAlloc;
        pbAlloc += cbAlignData * cValue;
        pwszName = (LPWSTR) pbAlloc;
        assert(((BYTE *) pvAlloc) + cbAlloc ==
            pbAlloc + (cchMaxName * sizeof(WCHAR)) * cValue);
    } else {
        ppwszValueName = NULL;
        ppbValueData = NULL;
        pdwValueType = NULL;
        pcbValueData = NULL;
        pbData = NULL;
        pwszName = NULL;
    }

    for (iValue = 0; iValue < cValue;
                iValue++, pwszName += cchMaxName, pbData += cbAlignData) {
        DWORD cchName = cchMaxName;
        DWORD cbData = cbMaxData;
        DWORD dwType;

        if (ERROR_SUCCESS != (lStatus = RegEnumValueU(
                hKey,
                iValue,
                pwszName,
                &cchName,
                NULL,       // pdwReserved
                &dwType,
                pbData,
                &cbData
                )))
            goto RegEnumValueError;

        // Ensure the data has two NULL terminators for REG_MULTI_SZ
        // Note cbAlignData >= cbMaxData + 2 * sizeof(WCHAR)
        memset(pbData + cbData, 0, 2 * sizeof(WCHAR));

        pdwValueType[iValue] = dwType;
        ppwszValueName[iValue] = pwszName;
        ppbValueData[iValue] = pbData;
        pcbValueData[iValue] = cbData;
    }

    fResult = TRUE;
CommonReturn:
    *ppvAlloc = pvAlloc;
    *pcValue = cValue;
    *ppdwValueType = pdwValueType;
    *pppwszValueName = ppwszValueName;
    *pppbValueData = ppbValueData;
    *ppcbValueData = pcbValueData;
    return fResult;

ErrorReturn:
    if (pvAlloc) {
        PkiFree(pvAlloc);
        pvAlloc = NULL;
    }

    cValue = 0;
    pdwValueType = NULL;
    ppwszValueName = NULL;
    ppbValueData = NULL;
    pcbValueData = NULL;

    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(RegQueryInfoKeyError, lStatus)
SET_ERROR_VAR(RegEnumValueError, lStatus)
}

//+-------------------------------------------------------------------------
//  Enumerate the OID functions identified by their encoding type,
//  function name and OID.
//
//  pfnEnumOIDFunc is called for each registry key matching the input
//  parameters. Setting dwEncodingType to CRYPT_MATCH_ANY_ENCODING_TYPE matches
//  any. Setting pszFuncName or pszOID to NULL matches any.
//
//  Set pszOID == CRYPT_DEFAULT_OID to restrict the enumeration to only the
//  DEFAULT functions
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc
    )
{
    HKEY hRegKey;
    LPSTR pszEncodingType = NULL;
    char szOID[34];

    if (CRYPT_MATCH_ANY_ENCODING_TYPE != dwEncodingType) {
        dwEncodingType = GetEncodingType(dwEncodingType);
        if (NULL == (pszEncodingType = EncodingTypeToRegName(dwEncodingType)))
            return FALSE;
    }

    if (pszOID && (DWORD_PTR) pszOID <= 0xFFFF) {
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((DWORD) ((DWORD_PTR)pszOID), szOID + 1, 10);
        pszOID = szOID;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT(CRYPT_OID_REGPATH),
            0,                  // dwReserved
            KEY_READ,
            &hRegKey)) {
        // Enumerate and optionally match encoding type
        HKEY hEncodingTypeKey;
        DWORD iEncodingType = 0;
        char szRegEncodingType[MAX_SUBKEY_LEN];
        while (hEncodingTypeKey = GetNextRegSubKey(hRegKey,
                &iEncodingType, pszEncodingType, szRegEncodingType)) {
            // Convert the EncodingType string and validate
            DWORD dwRegEncodingType;
            if (RegNameToEncodingType(szRegEncodingType, &dwRegEncodingType)) {
                // Enumerate and optionally match FuncName, for example,
                // ("CryptDllEncodeObject")
                HKEY hFuncName;
                DWORD iFuncName = 0;
                char szRegFuncName[MAX_SUBKEY_LEN];
                while (hFuncName = GetNextRegSubKey(hEncodingTypeKey,
                        &iFuncName, pszFuncName, szRegFuncName)) {
                    // Enumerate and optionally match OID string ("1.2.3.4")
                    HKEY hOID;
                    DWORD iOID = 0;
                    char szRegOID[MAX_SUBKEY_LEN];
                    while (hOID = GetNextRegSubKey(hFuncName, &iOID, pszOID,
                            szRegOID)) {
                        // Read and allocate  the registry values
                        void *pvAlloc;
                        DWORD cValue;
                        DWORD *pdwValueType;
                        LPWSTR *ppwszValueName;
                        BYTE **ppbValueData;
                        DWORD *pcbValueData;

                        if (GetRegValues(
                                hOID,
                                &pvAlloc,
                                &cValue,
                                &pdwValueType,
                                &ppwszValueName,
                                &ppbValueData,
                                &pcbValueData)) {
                            pfnEnumOIDFunc(
                                dwRegEncodingType,
                                szRegFuncName,
                                szRegOID,
                                cValue,
                                pdwValueType,
                                (LPCWSTR *) ppwszValueName,
                                (const BYTE **) ppbValueData,
                                pcbValueData,
                                pvArg);
                            if (pvAlloc)
                                PkiFree(pvAlloc);
                        }
                        RegCloseKey(hOID);
                    }
                    RegCloseKey(hFuncName);
                }
            }
            RegCloseKey(hEncodingTypeKey);
        }
        RegCloseKey(hRegKey);
    }

    if (pszEncodingType)
        PkiFree(pszEncodingType);
    return TRUE;
}


//+=========================================================================
//  Registry and Dll Load Functions
//==========================================================================

// Note, returned Dll element isn't AddRef'ed
STATIC PDLL_ELEMENT FindDll(
    IN LPCWSTR pwszDll      // not expanded
    )
{
    LPWSTR pwszExpandDll; // _alloca'ed
    DWORD cchDll;
    PDLL_ELEMENT pDll;

#ifndef CE_BUILD
    WCHAR rgch[4];
    if (0 == (cchDll = ExpandEnvironmentStringsU(
            pwszDll,
            rgch,               // lpszDest, NON_NULL for win95
            sizeof(rgch)/sizeof(rgch[0]))))     // cchDest
        return NULL;
    __try {
        pwszExpandDll = (LPWSTR) _alloca(cchDll * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
    if (0 == ExpandEnvironmentStringsU(
            pwszDll,
            pwszExpandDll,
            cchDll))
        return NULL;

#else // CE_BUILD
	pwszExpandDll = (LPWSTR)pwszDll;
	cchDll = wcslen(pwszExpandDll)+1;
#endif
    LockOIDFunc();

    // Check if we already have an entry
    for (pDll = pDllHead; pDll; pDll = pDll->pNext) {
        if (0 == _wcsicmp(pwszExpandDll, pDll->pwszDll))
            break;
    }

    if (NULL == pDll) {
        // Need to create a new DLL entry and add to our list
        if (pDll = (PDLL_ELEMENT) PkiZeroAlloc(
                sizeof(DLL_ELEMENT) + cchDll * sizeof(WCHAR))) {
            LPWSTR pwszEleDll;

            pDll->dwOIDType = DLL_OID_TYPE;
            pwszEleDll = (LPWSTR) ((BYTE *) pDll + sizeof(DLL_ELEMENT));
            memcpy(pwszEleDll, pwszExpandDll, cchDll * sizeof(WCHAR));
            pDll->pwszDll = pwszEleDll;
            pDll->pNext = pDllHead;
            pDllHead = pDll;
        }
    }

    UnlockOIDFunc();
    return pDll;
}

// Upon entry/exit OIDFunc is locked
STATIC PDLL_PROC_ELEMENT AddDllProc(
    IN LPCSTR pszFuncName,
    IN LPCWSTR pwszDll
    )
{
    PDLL_PROC_ELEMENT pProcEle = NULL;
    PDLL_ELEMENT pDll;
    DWORD cchFuncName;
    DWORD cbEle;
    LPSTR psz;

    cchFuncName = strlen(pszFuncName) + 1;
    cbEle = sizeof(DLL_PROC_ELEMENT) + cchFuncName;
    if (NULL == (pProcEle = (PDLL_PROC_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;

    if (NULL == (pDll = FindDll(pwszDll)))
        goto FindDllError;

    pProcEle->pNext = pDll->pProcHead;
    pDll->pProcHead = pProcEle;
    pProcEle->pDll = pDll;
    psz = (LPSTR) ((BYTE *) pProcEle + sizeof(DLL_PROC_ELEMENT));
    memcpy(psz, pszFuncName, cchFuncName);
    pProcEle->pszName = psz;
    pProcEle->pvAddr = NULL;

CommonReturn:
    return pProcEle;
ErrorReturn:
    PkiFree(pProcEle);
    pProcEle = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FindDllError)
}


// Upon entry/exit OIDFunc is locked
STATIC void AddRegOIDFunc(
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszDll,
    IN DWORD dwCryptFlags
    )
{
    PREG_OID_FUNC_ELEMENT pOIDEle = NULL;
    PDLL_PROC_ELEMENT pProcEle; // not allocated, doesn't need to be free'ed
    DWORD cchOID;
    DWORD cbEle;
    LPSTR psz;

    if (0xFFFF < (DWORD_PTR) pszOID)
        cchOID = strlen(pszOID) + 1;
    else
        cchOID = 0;
    cbEle = sizeof(REG_OID_FUNC_ELEMENT) + cchOID;
    if (NULL == (pOIDEle = (PREG_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;

    if (NULL == (pProcEle = AddDllProc(pszFuncName, pwszDll)))
        goto AddDllProcError;

    pOIDEle->dwEncodingType = dwEncodingType;

    if (dwCryptFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
        pOIDEle->pNext = pFuncSet->pRegBeforeOIDFuncHead;
        pFuncSet->pRegBeforeOIDFuncHead = pOIDEle;
    } else {
        pOIDEle->pNext = pFuncSet->pRegAfterOIDFuncHead;
        pFuncSet->pRegAfterOIDFuncHead = pOIDEle;
    }
    if (cchOID) {
        psz = (LPSTR) ((BYTE *) pOIDEle + sizeof(REG_OID_FUNC_ELEMENT));
        memcpy(psz, pszOID, cchOID);
        pOIDEle->pszOID = psz;
    } else
        pOIDEle->dwOID = (DWORD_PTR) pszOID;
    pOIDEle->pDllProc = pProcEle;

CommonReturn:
    return;
ErrorReturn:
    PkiFree(pOIDEle);
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AddDllProcError)
}


// Upon entry/exit OIDFunc is locked
STATIC void AddDefaultDllList(
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN LPCWSTR pwszInDllList,
    IN DWORD cchInDllList
    )
{
    LPWSTR pwszDllList;         // _alloca'ed
    LPWSTR pwsz;
    DWORD cchDllList;
    DWORD cchDll;
    DWORD cDll;

    DWORD i;

    PDEFAULT_REG_ELEMENT pEle = NULL;
    DWORD cbEle;
    LPWSTR *ppwszEleDll;
    PDLL_PROC_ELEMENT *ppEleDllProc;
    LPWSTR pwszEleDllList;

    // Ensure cchDllList has 2 terminating NULL characters
    assert(cchInDllList && pwszInDllList);
    cchDllList = cchInDllList + 2;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    memcpy(pwszDllList, pwszInDllList, cchInDllList * sizeof(WCHAR));
    pwszDllList[cchInDllList] = L'\0';
    pwszDllList[cchInDllList + 1] = L'\0';


    // Get count of null terminated Dlls
    cDll = 0;
    for (pwsz = pwszDllList; 0 != (cchDll = wcslen(pwsz)); pwsz += cchDll + 1)
        cDll++;

    if (0 == cDll)
        goto NoDll;

    cbEle = sizeof(DEFAULT_REG_ELEMENT) +
        cDll * sizeof(LPWSTR) +
        cDll * sizeof(PDLL_PROC_ELEMENT) +
        cchDllList * sizeof(WCHAR)
        ;

    if (NULL == (pEle = (PDEFAULT_REG_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;
    ppwszEleDll = (LPWSTR *) ((BYTE *) pEle + sizeof(DEFAULT_REG_ELEMENT));
    ppEleDllProc = (PDLL_PROC_ELEMENT *) ((BYTE *) ppwszEleDll +
        cDll * sizeof(LPWSTR));
    pwszEleDllList = (LPWSTR) ((BYTE *) ppEleDllProc +
        cDll * sizeof(PDLL_PROC_ELEMENT));

    assert((BYTE *) pwszEleDllList + cchDllList * sizeof(WCHAR) ==
        (BYTE *) pEle + cbEle);

    pEle->dwEncodingType = dwEncodingType;
//  pEle->pNext =
    memcpy(pwszEleDllList, pwszDllList, cchDllList * sizeof(WCHAR));
    pEle->pwszDllList = pwszEleDllList;
    pEle->cchDllList = cchDllList;
    pEle->cDll = cDll;
    pEle->rgpwszDll = ppwszEleDll;
    pEle->rgpDllProc = ppEleDllProc;

    for (pwsz = pwszEleDllList, i  = 0;
                    0 != (cchDll = wcslen(pwsz)); pwsz += cchDll + 1, i++) {
        ppwszEleDll[i] = pwsz;
        if (NULL == (ppEleDllProc[i] = AddDllProc(
                pFuncSet->pszFuncName, pwsz)))
            goto AddDllProcError;
    }
    assert (i == cDll);

    pEle->pNext = pFuncSet->pDefaultRegHead;
    pFuncSet->pDefaultRegHead = pEle;

CommonReturn:
    return;

ErrorReturn:
    PkiFree(pEle);
    goto CommonReturn;

TRACE_ERROR(NoDll);
TRACE_ERROR(OutOfMemory);
TRACE_ERROR(AddDllProcError);
}


//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered OID functions.
//
//  Called with OIDFunc locked
//--------------------------------------------------------------------------
STATIC BOOL WINAPI EnumRegFuncCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{

    PFUNC_SET pFuncSet = (PFUNC_SET) pvArg;

    BOOL fDefaultDllList = FALSE;
    LPCWSTR pwszDll = NULL;                 // not allocated
    DWORD cchDll = 0;
    LPCWSTR pwszOverrideFuncName = NULL;    // not allocated
    DWORD dwCryptFlags = 0;

    assert(pFuncSet);

    if (CONST_OID_STR_PREFIX_CHAR == *pszOID) {
        // Convert "#<number>" string to its corresponding constant OID value
        pszOID = (LPCSTR)(DWORD_PTR) atol(pszOID + 1);
        if (0xFFFF < (DWORD_PTR) pszOID)
            // Invalid OID. Skip it.
            goto InvalidOID;
    } else if (0 == _stricmp(CRYPT_DEFAULT_OID, pszOID))
        fDefaultDllList = TRUE;

    while (cValue--) {
        LPCWSTR pwszValueName = rgpwszValueName[cValue];
        DWORD dwValueType = rgdwValueType[cValue];
        const BYTE *pbValueData = rgpbValueData[cValue];
        DWORD cbValueData = rgcbValueData[cValue];

        if (0 == _wcsicmp(pwszValueName, CRYPT_OID_REG_DLL_VALUE_NAME)) {
            if (REG_SZ == dwValueType || REG_EXPAND_SZ == dwValueType ||
                    (fDefaultDllList && REG_MULTI_SZ == dwValueType)) {
                pwszDll = (LPCWSTR) pbValueData;
                cchDll = cbValueData / sizeof(WCHAR);
            } else
                // Invalid "Dll" value.
                goto InvalidDll;
        } else if (0 == _wcsicmp(pwszValueName,
                CRYPT_OID_REG_FUNC_NAME_VALUE_NAME)) {
            if (REG_SZ == dwValueType) {
                LPCWSTR pwszValue = (LPCWSTR) pbValueData;
                if (L'\0' != *pwszValue)
                    pwszOverrideFuncName = pwszValue;
            } else
                // Invalid "FuncName" value.
                goto InvalidFuncName;
        } else if (0 == _wcsicmp(pwszValueName,
                CRYPT_OID_REG_FLAGS_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(dwCryptFlags))
                memcpy(&dwCryptFlags, pbValueData, sizeof(dwCryptFlags));
            // else
            //  Ignore invalid CryptFlags value type
        }
    }

    if (0 == cchDll || L'\0' == *pwszDll)
        goto NoDll;

    if (fDefaultDllList)
        AddDefaultDllList(
            dwEncodingType,
            pFuncSet,
            pwszDll,
            cchDll
            );
    else {
        BYTE rgb[_MAX_PATH];
        if (pwszOverrideFuncName) {
            if (!MkMBStr(rgb, _MAX_PATH, pwszOverrideFuncName,
                    (LPSTR *) &pszFuncName))
                goto MkMBStrError;
        }
        AddRegOIDFunc(
            dwEncodingType,
            pFuncSet,
            pszFuncName,
            pszOID,
            pwszDll,
            dwCryptFlags
            );
        if (pwszOverrideFuncName)
            FreeMBStr(rgb, (LPSTR) pszFuncName);
    }

CommonReturn:
    return TRUE;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(InvalidOID)
TRACE_ERROR(InvalidDll)
TRACE_ERROR(InvalidFuncName)
TRACE_ERROR(NoDll)
TRACE_ERROR(MkMBStrError)
}
#endif //CAPI_INCLUDE_REGISTER_OID    

STATIC void LoadRegFunc(
    IN OUT PFUNC_SET pFuncSet
    )
{
    LockOIDFunc();
    if (pFuncSet->fRegLoaded)
        goto CommonReturn;

#ifdef CAPI_INCLUDE_REGISTER_OID
    CryptEnumOIDFunction(
        CRYPT_MATCH_ANY_ENCODING_TYPE,
        pFuncSet->pszFuncName,
        NULL,                           // pszOID
        0,                              // dwFlags
        (void *) pFuncSet,              // pvArg
        EnumRegFuncCallback
        );
#endif //CAPI_INCLUDE_REGISTER_OID    
    pFuncSet->fRegLoaded = TRUE;

CommonReturn:
    UnlockOIDFunc();
    return;
}


#ifdef CAPI_INCLUDE_REGISTER_OID

// Upon entry/exit OIDFunc is locked
STATIC void RemoveFreeDll(
    IN PDLL_ELEMENT pDll
    )
{
    // Remove Dll from free list
    if (pDll->pFreeNext)
        pDll->pFreeNext->pFreePrev = pDll->pFreePrev;
    if (pDll->pFreePrev)
        pDll->pFreePrev->pFreeNext = pDll->pFreeNext;
    else if (pDll == pFreeDllHead)
        pFreeDllHead = pDll->pFreeNext;
    // else
    //  Not on any list

    pDll->pFreeNext = NULL;
    pDll->pFreePrev = NULL;

    assert(dwFreeDllCnt);
    if (dwFreeDllCnt)
        dwFreeDllCnt--;
}

// Upon entry/exit OIDFunc is locked
STATIC void AddRefDll(
    IN PDLL_ELEMENT pDll
    )
{
    pDll->dwRefCnt++;
    if (pDll->dwFreeCnt) {
        pDll->dwFreeCnt = 0;
        RemoveFreeDll(pDll);
    }
}

// Note, MUST NOT HOLD OID LOCK WHILE CALLING FreeLibrary()!!
//
// Therefore, will put the Dll's to be freed on a list while holding the
// OID LOCK. After releasing the OID LOCK, will iterate through the
// list and call FreeLibrary().
STATIC VOID NTAPI FreeDllWaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut     // ???
    )
{
    PDLL_ELEMENT pFreeDll;
    HMODULE *phFreeLibrary = NULL;  // _alloca'ed
    DWORD cFreeLibrary = 0;

    LockOIDFunc();

    if (dwFreeDllCnt) {
        DWORD dwOrigFreeDllCnt = dwFreeDllCnt;
    __try {
        phFreeLibrary = (HMODULE *) _alloca(
            dwOrigFreeDllCnt * sizeof(HMODULE));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
            goto OutOfMemory;
    }

        pFreeDll = pFreeDllHead;
        assert(pFreeDll);
        while (pFreeDll) {
            PDLL_ELEMENT pDll = pFreeDll;
            pFreeDll = pFreeDll->pFreeNext;

            assert(pDll->dwFreeCnt);
            if (0 == --pDll->dwFreeCnt) {
                RemoveFreeDll(pDll);

                assert(pDll->fLoaded);
                if (!pDll->fLoaded)
                    continue;
                if (NULL == pDll->pfnDllCanUnloadNow ||
                        S_OK == pDll->pfnDllCanUnloadNow()) {
                    assert(cFreeLibrary < dwOrigFreeDllCnt);
                    if (cFreeLibrary < dwOrigFreeDllCnt) {
                        PDLL_PROC_ELEMENT pEle;

                        // Loop and NULL all proc addresses
                        for (pEle = pDll->pProcHead; pEle; pEle = pEle->pNext)
                            pEle->pvAddr = NULL;

                        pDll->pfnDllCanUnloadNow = NULL;
                        // Add to array to be freed after releasing lock!!
                        assert(pDll->hDll);
                        phFreeLibrary[cFreeLibrary++] = pDll->hDll;
                        pDll->hDll = NULL;
                        pDll->fLoaded = FALSE;
                    }
                }
            }
        }
    } else {
        assert(NULL == pFreeDllHead);
    }

    if (NULL == pFreeDllHead) {
        assert(0 == dwFreeDllCnt);
        // Do interlock to guard against a potential race condition at
        // PROCESS_DETACH. Note, PROCESS_DETACH doesn't do a LockOIDFunc().
        if (InterlockedExchange(&lFreeDll, 0)) {
            HANDLE hRegWaitFor;

            hRegWaitFor = hFreeDllRegWaitFor;
            hFreeDllRegWaitFor = NULL;
            UnlockOIDFunc();

            while (cFreeLibrary--)
                FreeLibrary(phFreeLibrary[cFreeLibrary]);

#ifndef CE_BUILD
            assert(hRegWaitFor);
            ILS_ExitWait(hRegWaitFor);
            assert(FALSE);
#endif            
            return;
        }
    }

CommonReturn:
    UnlockOIDFunc();
    while (cFreeLibrary--)
        FreeLibrary(phFreeLibrary[cFreeLibrary]);
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(OutOfMemory);
}

STATIC void ReleaseDll(
    IN PDLL_ELEMENT pDll
    )
{
    LockOIDFunc();
    assert(pDll->dwRefCnt);
    if (0 == --pDll->dwRefCnt) {
        assert(pDll->fLoaded);
        if (!pDll->fLoaded)
            goto CommonReturn;

        assert(0 == pDll->dwFreeCnt);
        if (pDll->dwFreeCnt)
            goto CommonReturn;

        if (0 == lFreeDll) {
            assert(NULL == hFreeDllRegWaitFor);

#ifndef CE_BUILD
			if (NULL == (hFreeDllRegWaitFor =
                    ILS_RegisterWaitForSingleObjectEx(
                        NULL,                   // hObject
                        FreeDllWaitForCallback,
                        NULL,                   // Context
                        FREE_DLL_TIMEOUT,
                        0                       // dwFlags
                        )))
                goto RegisterWaitForError;

#endif // CE_BUILD
            lFreeDll = 1;
        }

        assert(NULL == pDll->pFreeNext);
        assert(NULL == pDll->pFreePrev);
        pDll->dwFreeCnt = 2;
        if (pFreeDllHead) {
            pFreeDllHead->pFreePrev = pDll;
            pDll->pFreeNext = pFreeDllHead;
        }
        pFreeDllHead = pDll;
        dwFreeDllCnt++;
#ifdef CE_BUILD
		// For the WinCE build, skip the RegisterWaitForSingleObject rigmarole.
		// BUGBUG: Is this dangerous ? (GEORGEJ)
		FreeDllWaitForCallback(NULL, NULL);
#endif		

    }

CommonReturn:
    UnlockOIDFunc();
    return;
#ifndef CE_BUILD    
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(RegisterWaitForError)
#endif
}

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL LoadDll(
    IN PDLL_ELEMENT pDll
    )
{
    BOOL fResult;
    HMODULE hDll = NULL;
    LPFNCANUNLOADNOW pfnDllCanUnloadNow;

    LockOIDFunc();
    if (pDll->fLoaded)
        AddRefDll(pDll);
    else {
        UnlockOIDFunc();
        // NO LoadLibrary() or GetProcAddress() while holding OID lock!!
        hDll = LoadLibraryExU(pDll->pwszDll, NULL, 0);
        if (hDll)
            pfnDllCanUnloadNow = (LPFNCANUNLOADNOW) MyGetProcAddress(
                hDll, "DllCanUnloadNow");
        LockOIDFunc();
        
        AddRefDll(pDll);
        if (!pDll->fLoaded) {
            assert(1 == pDll->dwRefCnt);
            assert(0 == pDll->dwFreeCnt);
            assert(pDll->pwszDll);
            assert(NULL == pDll->hDll);
            if (NULL == (pDll->hDll = hDll)) {
                pDll->dwRefCnt = 0;
                goto LoadLibraryError;
            }
            hDll = NULL;
            pDll->fLoaded = TRUE;

            assert(NULL == pDll->pfnDllCanUnloadNow);
            pDll->pfnDllCanUnloadNow = pfnDllCanUnloadNow;
        }
    }

    fResult = TRUE;
CommonReturn:
    UnlockOIDFunc();
    if (hDll) {
        // Dll was loaded by another thread.
        DWORD dwErr = GetLastError();
        FreeLibrary(hDll);
        SetLastError(dwErr);
    }
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(LoadLibraryError);
}


// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetDllProcAddr(
    IN PDLL_PROC_ELEMENT pEle,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    BOOL fResult;
    void *pvAddr;
    PDLL_ELEMENT pDll;

    LockOIDFunc();

    pDll = pEle->pDll;
    assert(pDll);

    if (pvAddr = pEle->pvAddr)
        AddRefDll(pDll);
    else {
        UnlockOIDFunc();
        // NO LoadLibrary() or GetProcAddress() while holding OID lock!!
        fResult = LoadDll(pDll);
        if (fResult) {
            assert(pDll->hDll);
            pvAddr = MyGetProcAddress(pDll->hDll, pEle->pszName);
        }
        LockOIDFunc();
        if (!fResult)
            goto LoadDllError;

        if (pvAddr)
            pEle->pvAddr = pvAddr;
        else {
            ReleaseDll(pDll);
            goto GetProcAddressError;
        }
    }

    fResult = TRUE;

CommonReturn:
    *ppvFuncAddr = pvAddr;
    *phFuncAddr = (HCRYPTOIDFUNCADDR) pDll;
    UnlockOIDFunc();

    return fResult;
ErrorReturn:
    fResult = FALSE;
    pDll = NULL;
    pvAddr = NULL;
    goto CommonReturn;
TRACE_ERROR(LoadDllError)
TRACE_ERROR(GetProcAddressError)
}

#endif // CAPI_INCLUDE_REGISTER_OID

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetRegOIDFunctionAddress(
    IN PREG_OID_FUNC_ELEMENT pRegEle,
    IN DWORD dwEncodingType,
    IN LPCSTR pszOID,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
#ifdef CAPI_INCLUDE_REGISTER_OID
    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType != pRegEle->dwEncodingType)
            continue;
        if (0xFFFF >= (DWORD_PTR) pszOID) {
            if (pszOID != pRegEle->pszOID)
                continue;
        } else {
            if (0xFFFF >= (DWORD_PTR) pRegEle->pszOID ||
                    0 != _stricmp(pszOID, pRegEle->pszOID))
                continue;
        }

        return GetDllProcAddr(
            pRegEle->pDllProc,
            ppvFuncAddr,
            phFuncAddr
            );
    }

#endif // CAPI_INCLUDE_REGISTER_OID
    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetDefaultRegOIDFunctionAddress(
    IN PFUNC_SET pFuncSet,
    IN DWORD dwEncodingType,
    IN LPCWSTR pwszDll,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
#ifdef CAPI_INCLUDE_REGISTER_OID
    PDEFAULT_REG_ELEMENT pRegEle = pFuncSet->pDefaultRegHead;
    PDLL_ELEMENT pDll;

    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType != pRegEle->dwEncodingType)
            continue;

        for (DWORD i = 0; i < pRegEle->cDll; i++) {
            if (0 == _wcsicmp(pwszDll, pRegEle->rgpwszDll[i]))
                return GetDllProcAddr(
                    pRegEle->rgpDllProc[i],
                    ppvFuncAddr,
                    phFuncAddr
                    );
        }
    }

    if (pDll = FindDll(pwszDll)) {
        if (LoadDll(pDll)) {
            if (*ppvFuncAddr = MyGetProcAddress(pDll->hDll,
                    pFuncSet->pszFuncName)) {
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pDll;
                return TRUE;
            } else
                ReleaseDll(pDll);
        }
    }

#endif // CAPI_INCLUDE_REGISTER_OID
    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}


//+-------------------------------------------------------------------------
//  Search the list of installed functions for an OID and EncodingType match.
//  If not found, search the registry.
//
//  For success, returns TRUE with *ppvFuncAddr updated with the function's
//  address and *phFuncAddr updated with the function address's handle.
//  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
//  be called to release it.
//
//  For a registry match, the Dll containing the function is loaded.
//
//  By default, both the registered and installed function lists are searched.
//  Set CRYPT_GET_INSTALLED_OID_FUNC_FLAG to only search the installed list
//  of functions. This flag would be set by a registered function to get
//  the address of a pre-installed function it was replacing. For example,
//  the registered function might handle a new special case and call the
//  pre-installed function to handle the remaining cases.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetOIDFunctionAddress(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    IN LPCSTR pszOID,
    IN DWORD dwFlags,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;
    DWORD_PTR dwOID;

    dwEncodingType = GetEncodingType(dwEncodingType);

    if (0xFFFF < (DWORD_PTR) pszOID && CONST_OID_STR_PREFIX_CHAR == *pszOID) {
        // Convert "#<number>" string to its corresponding constant OID value
        pszOID = (LPCSTR)(DWORD_PTR) atol(pszOID + 1);
        if (0xFFFF < (DWORD_PTR) pszOID) {
            SetLastError((DWORD) E_INVALIDARG);
            *ppvFuncAddr = NULL;
            *phFuncAddr = NULL;
            return FALSE;
        }
    }

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    if (0 == (dwFlags & CRYPT_GET_INSTALLED_OID_FUNC_FLAG) &&
            pFuncSet->pRegBeforeOIDFuncHead) {
        if (GetRegOIDFunctionAddress(
                pFuncSet->pRegBeforeOIDFuncHead,
                dwEncodingType,
                pszOID,
                ppvFuncAddr,
                phFuncAddr
                ))
            return TRUE;
    }

    if (0xFFFF >= (dwOID = (DWORD_PTR) pszOID)) {
        PCONST_OID_FUNC_ELEMENT pConstEle = pFuncSet->pConstOIDFuncHead;
        while (pConstEle) {
            if (dwEncodingType == pConstEle->dwEncodingType &&
                    dwOID >= pConstEle->dwLowOID &&
                    dwOID <= pConstEle->dwHighOID) {
                *ppvFuncAddr = pConstEle->rgpvFuncAddr[
                    dwOID - pConstEle->dwLowOID];
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pConstEle;
                return TRUE;
            }
            pConstEle = pConstEle->pNext;
        }
    } else {
        PSTR_OID_FUNC_ELEMENT pStrEle = pFuncSet->pStrOIDFuncHead;
        while (pStrEle) {
            if (dwEncodingType == pStrEle->dwEncodingType &&
                    0 == _stricmp(pszOID, pStrEle->pszOID)) {
                *ppvFuncAddr = pStrEle->pvFuncAddr;
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pStrEle;
                return TRUE;
            }
            pStrEle = pStrEle->pNext;
        }
    }

    if (0 == (dwFlags & CRYPT_GET_INSTALLED_OID_FUNC_FLAG) &&
            pFuncSet->pRegAfterOIDFuncHead) {
        if (GetRegOIDFunctionAddress(
                pFuncSet->pRegAfterOIDFuncHead,
                dwEncodingType,
                pszOID,
                ppvFuncAddr,
                phFuncAddr
                ))
            return TRUE;
    }

    SetLastError((DWORD) ERROR_FILE_NOT_FOUND);
    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}

#ifdef CAPI_INCLUDE_REGISTER_OID
//+-------------------------------------------------------------------------
//  Get the list of registered default Dll entries for the specified
//  function set and encoding type.
//
//  The returned list consists of none, one or more null terminated Dll file
//  names. The list is terminated with an empty (L"\0") Dll file name.
//  For example: L"first.dll" L"\0" L"second.dll" L"\0" L"\0"
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetDefaultOIDDllList(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    OUT LPWSTR pwszDllList,
    IN OUT DWORD *pcchDllList
    )
{
    BOOL fResult;
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;
    PDEFAULT_REG_ELEMENT pRegEle;

    DWORD cchRegDllList = 2;
    LPWSTR pwszRegDllList = L"\0\0";

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    pRegEle = pFuncSet->pDefaultRegHead;
    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType == pRegEle->dwEncodingType) {
            cchRegDllList = pRegEle->cchDllList;
            assert(cchRegDllList >= 2);
            pwszRegDllList = pRegEle->pwszDllList;
            break;
        }
    }

    fResult = TRUE;
    if (pwszDllList) {
        if (cchRegDllList > *pcchDllList) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else
            memcpy(pwszDllList, pwszRegDllList, cchRegDllList * sizeof(WCHAR));
    }
    *pcchDllList = cchRegDllList;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Either: get the first or next installed DEFAULT function OR
//  load the Dll containing the DEFAULT function.
//
//  If pwszDll is NULL, search the list of installed DEFAULT functions.
//  *phFuncAddr must be set to NULL to get the first installed function.
//  Successive installed functions are returned by setting *phFuncAddr
//  to the hFuncAddr returned by the previous call.
//
//  If pwszDll is NULL, the input *phFuncAddr
//  is always CryptFreeOIDFunctionAddress'ed by this function, even for
//  an error.
//
//  If pwszDll isn't NULL, then, attempts to load the Dll and the DEFAULT
//  function. *phFuncAddr is ignored upon entry and isn't
//  CryptFreeOIDFunctionAddress'ed.
//
//  For success, returns TRUE with *ppvFuncAddr updated with the function's
//  address and *phFuncAddr updated with the function address's handle.
//  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
//  be called to release it or CryptGetDefaultOIDFunctionAddress can also
//  be called for a NULL pwszDll.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetDefaultOIDFunctionAddress(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    IN OPTIONAL LPCWSTR pwszDll,
    IN DWORD dwFlags,
    OUT void **ppvFuncAddr,
    IN OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    if (NULL == pwszDll) {
        // Get from installed list
        PSTR_OID_FUNC_ELEMENT pStrEle = (PSTR_OID_FUNC_ELEMENT) *phFuncAddr;

        if (pStrEle && STR_OID_TYPE == pStrEle->dwOIDType)
            pStrEle = pStrEle->pNext;
        else
            pStrEle = pFuncSet->pStrOIDFuncHead;
        while (pStrEle) {
            if (dwEncodingType == pStrEle->dwEncodingType &&
                    0 == _stricmp(CRYPT_DEFAULT_OID, pStrEle->pszOID)) {
                *ppvFuncAddr = pStrEle->pvFuncAddr;
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pStrEle;
                return TRUE;
            }
            pStrEle = pStrEle->pNext;
        }

        SetLastError(ERROR_FILE_NOT_FOUND);
        *ppvFuncAddr = NULL;
        *phFuncAddr = NULL;
        return FALSE;
    } else
        return GetDefaultRegOIDFunctionAddress(
            pFuncSet,
            dwEncodingType,
            pwszDll,
            ppvFuncAddr,
            phFuncAddr);
}

#endif // CAPI_INCLUDE_REGISTER_OID

//+-------------------------------------------------------------------------
//  Releases the handle AddRef'ed and returned by CryptGetOIDFunctionAddress
//  or CryptGetDefaultOIDFunctionAddress.
//
//  If a Dll was loaded for the function its unloaded. However, before doing
//  the unload, the DllCanUnloadNow function exported by the loaded Dll is
//  called. It should return S_FALSE to inhibit the unload or S_TRUE to enable
//  the unload. If the Dll doesn't export DllCanUnloadNow, the Dll is unloaded.
//
//  DllCanUnloadNow has the following signature:
//      STDAPI  DllCanUnloadNow(void);
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFreeOIDFunctionAddress(
    IN HCRYPTOIDFUNCADDR hFuncAddr,
    IN DWORD dwFlags
    )
{
    PDLL_ELEMENT pDll = (PDLL_ELEMENT) hFuncAddr;
#ifdef CAPI_INCLUDE_REGISTER_OID    
    if (pDll && DLL_OID_TYPE == pDll->dwOIDType) {
        DWORD dwErr = GetLastError();
        ReleaseDll(pDll);
        SetLastError(dwErr);
    }
#endif // CAPI_INCLUDE_REGISTER_OID
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\policy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       policy.cpp
//
//  Contents:   Certificate Chain Policy APIs
//
//  Functions:  CertChainPolicyDllMain
//              CertVerifyCertificateChainPolicy
//              CertDllVerifyBaseCertificateChainPolicy
//              CertDllVerifyBasicConstraintsCertificateChainPolicy
//              CertDllVerifyAuthenticodeCertificateChainPolicy
//              CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy
//              CertDllVerifySSLCertificateChainPolicy
//              CertDllVerifyNTAuthCertificateChainPolicy
//
//  History:    16-Feb-98   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>
#include "wintrust.h"
#include "softpub.h"

#include "wininet.h"
#ifndef SECURITY_FLAG_IGNORE_REVOCATION
#   define SECURITY_FLAG_IGNORE_REVOCATION          0x00000080
#   define SECURITY_FLAG_IGNORE_UNKNOWN_CA          0x00000100
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define  SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200
#endif

#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000 // expired X509 Cert.
#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000 // bad common name in X509 Cert.

#define SECURITY_FLAG_IGNORE_CERT_CN_INVALID    INTERNET_FLAG_IGNORE_CERT_CN_INVALID
#define SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  INTERNET_FLAG_IGNORE_CERT_DATE_INVALID

//+-------------------------------------------------------------------------
//  Global cert policy critical section.
//--------------------------------------------------------------------------
static CRITICAL_SECTION CertPolicyCriticalSection;

//+-------------------------------------------------------------------------
//  Cached certificate store used for NTAuth certificate chain policy.
//--------------------------------------------------------------------------
static HCERTSTORE hNTAuthCertStore = NULL;

//
//  support for MS test roots!!!!
//
static BYTE rgbTestRoot[] = 
{
#include "mstest1.h"
};

static BYTE rgbTestRootCorrected[] = 
{
#include "mstest2.h"
};

static BYTE rgbTestRootBeta1[] = 
{
#include "mstestb1.h"
};

static CERT_PUBLIC_KEY_INFO rgTestRootPublicKeyInfo[] = 
{
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot), rgbTestRoot, 0},
    {szOID_RSA_RSA, 0, NULL,
        sizeof(rgbTestRootCorrected), rgbTestRootCorrected, 0},
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRootBeta1), rgbTestRootBeta1, 0}
};
#define NTESTROOTS (sizeof(rgTestRootPublicKeyInfo)/ \
                            sizeof(rgTestRootPublicKeyInfo[0]))

HCRYPTOIDFUNCSET hChainPolicyFuncSet;

typedef BOOL (WINAPI *PFN_CHAIN_POLICY_FUNC) (
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyBaseCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyAuthenticodeCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifySSLCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyBasicConstraintsCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyNTAuthCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

static const CRYPT_OID_FUNC_ENTRY ChainPolicyFuncTable[] = {
    CERT_CHAIN_POLICY_BASE, CertDllVerifyBaseCertificateChainPolicy,
    CERT_CHAIN_POLICY_AUTHENTICODE,
        CertDllVerifyAuthenticodeCertificateChainPolicy,
    CERT_CHAIN_POLICY_AUTHENTICODE_TS,
        CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy,
    CERT_CHAIN_POLICY_SSL,
        CertDllVerifySSLCertificateChainPolicy,
    CERT_CHAIN_POLICY_BASIC_CONSTRAINTS,
        CertDllVerifyBasicConstraintsCertificateChainPolicy,
    CERT_CHAIN_POLICY_NT_AUTH,
        CertDllVerifyNTAuthCertificateChainPolicy,
};

#define CHAIN_POLICY_FUNC_COUNT (sizeof(ChainPolicyFuncTable) / \
                                    sizeof(ChainPolicyFuncTable[0]))


BOOL
WINAPI
CertChainPolicyDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        InitializeCriticalSection(&CertPolicyCriticalSection);

        if (NULL == (hChainPolicyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                0,                          // dwEncodingType
                CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC,
                CHAIN_POLICY_FUNC_COUNT,
                ChainPolicyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        break;

    case DLL_PROCESS_DETACH:
        DeleteCriticalSection(&CertPolicyCriticalSection);
        if (hNTAuthCertStore)
            CertCloseStore(hNTAuthCertStore, 0);
        break;

    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}


//+-------------------------------------------------------------------------
//  Lock and unlock global cert policy functions
//--------------------------------------------------------------------------
static inline void CertPolicyLock()
{
    EnterCriticalSection(&CertPolicyCriticalSection);
}
static inline void CertPolicyUnlock()
{
    LeaveCriticalSection(&CertPolicyCriticalSection);
}


//+-------------------------------------------------------------------------
//  Verify that the certificate chain satisfies the specified policy
//  requirements. If we were able to verify the chain policy, TRUE is returned
//  and the dwError field of the pPolicyStatus is updated. A dwError of 0
//  (ERROR_SUCCESS, S_OK) indicates the chain satisfies the specified policy.
//
//  If dwError applies to the entire chain context, both lChainIndex and
//  lElementIndex are set to -1. If dwError applies to a simple chain,
//  lElementIndex is set to -1 and lChainIndex is set to the index of the
//  first offending chain having the error. If dwError applies to a
//  certificate element, lChainIndex and lElementIndex are updated to 
//  index the first offending certificate having the error, where, the
//  the certificate element is at:
//      pChainContext->rgpChain[lChainIndex]->rgpElement[lElementIndex].
//
//  The dwFlags in pPolicyPara can be set to change the default policy checking
//  behaviour. In addition, policy specific parameters can be passed in
//  the pvExtraPolicyPara field of pPolicyPara.
//
//  In addition to returning dwError, in pPolicyStatus, policy OID specific
//  extra status may be returned via pvExtraPolicyStatus.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = 0;
    pPolicyStatus->lChainIndex = -1;
    pPolicyStatus->lElementIndex = -1;

    if (!CryptGetOIDFunctionAddress(
            hChainPolicyFuncSet,
            0,                      // dwEncodingType,
            pszPolicyOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr))
        goto GetOIDFuncAddrError;

    fResult = ((PFN_CHAIN_POLICY_FUNC) pvFuncAddr)(
        pszPolicyOID,
        pChainContext,
        pPolicyPara,
        pPolicyStatus
        );
    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOIDFuncAddrError)
}


static inline PCERT_CHAIN_ELEMENT GetRootChainElement(
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    DWORD dwRootChainIndex = pChainContext->cChain - 1;
    DWORD dwRootElementIndex =
        pChainContext->rgpChain[dwRootChainIndex]->cElement - 1;

    return pChainContext->rgpChain[dwRootChainIndex]->
                                        rgpElement[dwRootElementIndex];
}

void GetElementIndexOfFirstError(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwErrorStatusMask,
    OUT LONG *plChainIndex,
    OUT LONG *plElementIndex
    )
{
    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];

            if (pEle->TrustStatus.dwErrorStatus & dwErrorStatusMask) {
                *plChainIndex = (LONG) i;
                *plElementIndex = (LONG) j;
                return;
            }
        }
    }

    *plChainIndex = -1;
    *plElementIndex = -1;
}

void GetChainIndexOfFirstError(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwErrorStatusMask,
    OUT LONG *plChainIndex
    )
{
    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        if (pChain->TrustStatus.dwErrorStatus & dwErrorStatusMask) {
            *plChainIndex = (LONG) i;
            return;
        }
    }

    *plChainIndex = -1;
}


//+=========================================================================
//  CertDllVerifyBaseCertificateChainPolicy Functions
//==========================================================================

BOOL
WINAPI
CertDllVerifyBaseCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwContextError;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;
    DWORD dwErrorStatusMask;

    dwContextError = pChainContext->TrustStatus.dwErrorStatus;


    if (0 == dwContextError) {
        // Valid chain
        dwError = 0;
        goto CommonReturn;
    }

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;

    if (dwContextError &
            (CERT_TRUST_IS_NOT_SIGNATURE_VALID |
                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID)) {
        dwError = TRUST_E_CERT_SIGNATURE;
        dwErrorStatusMask =
            CERT_TRUST_IS_NOT_SIGNATURE_VALID |
                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
        if (dwErrorStatusMask & CERT_TRUST_IS_NOT_SIGNATURE_VALID)
            goto GetElementIndexReturn;
        else
            goto GetChainIndexReturn;
    } 

    if (dwContextError & CERT_TRUST_IS_UNTRUSTED_ROOT) {
        dwErrorStatusMask = CERT_TRUST_IS_UNTRUSTED_ROOT;
        if (dwFlags & CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG) {
            ;
        } else if (0 == (dwFlags & CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG)) {
            dwError = CERT_E_UNTRUSTEDROOT;
            goto GetElementIndexReturn;
        } else {
            // Check if one of the "test" roots
            DWORD i;
            BOOL fTestRoot;
            PCERT_CHAIN_ELEMENT pRootElement;
            PCCERT_CONTEXT pRootCert;

            pRootElement = GetRootChainElement(pChainContext);
            assert(pRootElement->TrustStatus.dwInfoStatus &
                CERT_TRUST_IS_SELF_SIGNED);
            pRootCert = pRootElement->pCertContext;

            fTestRoot = FALSE;
            for (i = 0; i < NTESTROOTS; i++) {
                if (CertComparePublicKeyInfo(
                        pRootCert->dwCertEncodingType,
                        &pRootCert->pCertInfo->SubjectPublicKeyInfo,
                        &rgTestRootPublicKeyInfo[i])) {
                    fTestRoot = TRUE;
                    break;
                }
            }
            if (fTestRoot) {
                if (0 == (dwFlags & CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG)) {
                    dwError = CERT_E_UNTRUSTEDTESTROOT;
                    goto GetElementIndexReturn;
                }
            } else {
                dwError = CERT_E_UNTRUSTEDROOT;
                goto GetElementIndexReturn;
            }
        }
    }

    if (dwContextError & CERT_TRUST_IS_PARTIAL_CHAIN) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG)) {
            dwError = CERT_E_CHAINING;
            dwErrorStatusMask = CERT_TRUST_IS_PARTIAL_CHAIN;
            goto GetChainIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_REVOKED) {
        dwError = CRYPT_E_REVOKED;
        dwErrorStatusMask = CERT_TRUST_IS_REVOKED;
        goto GetElementIndexReturn;
    }

    if (dwContextError & (CERT_TRUST_IS_NOT_VALID_FOR_USAGE |
            CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE)) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG)) {
            dwError = CERT_E_WRONG_USAGE;
            dwErrorStatusMask = CERT_TRUST_IS_NOT_VALID_FOR_USAGE |
                CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
            if (dwContextError & CERT_TRUST_IS_NOT_VALID_FOR_USAGE)
                goto GetElementIndexReturn;
            else
                goto GetChainIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_NOT_TIME_VALID) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG)) {
            dwError = CERT_E_EXPIRED;
            dwErrorStatusMask = CERT_TRUST_IS_NOT_TIME_VALID;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_CTL_IS_NOT_TIME_VALID) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG)) {
            dwErrorStatusMask = CERT_TRUST_CTL_IS_NOT_TIME_VALID;
            dwError = CERT_E_EXPIRED;
            goto GetChainIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_NOT_TIME_NESTED) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG)) {
            dwErrorStatusMask = CERT_TRUST_IS_NOT_TIME_NESTED;
            dwError = CERT_E_VALIDITYPERIODNESTING;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_REVOCATION_STATUS_UNKNOWN) {
        if ((dwFlags & CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS) !=
                CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS) {
            DWORD i;
            for (i = 0; i < pChainContext->cChain; i++) {
                DWORD j;
                PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

                for (j = 0; j < pChain->cElement; j++) {
                    PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
                    DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
                    DWORD dwEleInfo = pEle->TrustStatus.dwInfoStatus;

                    if (0 == (dwEleError &
                            CERT_TRUST_REVOCATION_STATUS_UNKNOWN))
                        continue;

                    assert(pEle->pRevocationInfo);
                    dwError = pEle->pRevocationInfo->dwRevocationResult;
                    if (CRYPT_E_NO_REVOCATION_CHECK != dwError)
                        dwError = CRYPT_E_REVOCATION_OFFLINE;

                    if (dwEleInfo & CERT_TRUST_IS_SELF_SIGNED) {
                        // Chain Root
                        if (0 == (dwFlags &
                                CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG)) {
                            lChainIndex = (LONG) i;
                            lElementIndex = (LONG) j;
                            goto CommonReturn;
                        }
                    } else if (0 == i && 0 == j) {
                        // End certificate
                        if (0 == (dwFlags &
                                CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG)) {
                            lChainIndex = (LONG) i;
                            lElementIndex = (LONG) j;
                            goto CommonReturn;
                        }
                    } else if (0 == j) {
                        // CTL signer certificate
                        if (0 ==
                                (dwFlags & CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG)) {
                            lChainIndex = (LONG) i;
                            lElementIndex = (LONG) j;
                            goto CommonReturn;
                        }
                    } else  {
                        // CA certificate
                        if (0 ==
                                (dwFlags & CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG)) {
                            lChainIndex = (LONG) i;
                            lElementIndex = (LONG) j;
                            goto CommonReturn;
                        }
                    }
                }
            }
        }
    }

    dwError = 0;

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);

    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;
    return TRUE;

GetElementIndexReturn:
    GetElementIndexOfFirstError(pChainContext, dwErrorStatusMask,
        &lChainIndex, &lElementIndex);
    goto CommonReturn;

GetChainIndexReturn:
    GetChainIndexOfFirstError(pChainContext, dwErrorStatusMask,
        &lChainIndex);
    goto CommonReturn;
}

//+=========================================================================
//  CertDllVerifyBasicConstraintsCertificateChainPolicy Functions
//==========================================================================

// If dwFlags is 0, allow either CA or END_ENTITY for dwEleIndex == 0
BOOL CheckChainElementBasicConstraints(
    IN PCERT_CHAIN_ELEMENT pEle,
    IN DWORD dwEleIndex,
    IN DWORD dwFlags
    )
{
    BOOL fResult;

    PCERT_INFO pCertInfo = pEle->pCertContext->pCertInfo;
    PCERT_EXTENSION pExt;
    PCERT_BASIC_CONSTRAINTS_INFO pInfo = NULL;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo2 = NULL;
    DWORD cbInfo;

    BOOL fCA;
    BOOL fEndEntity;
    BOOL fPathLenConstraint;
    DWORD dwPathLenConstraint;

    if (0 == pCertInfo->cExtension) 
        goto SuccessReturn;

    if (pExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS2,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        if (!CryptDecodeObjectEx(
                pEle->pCertContext->dwCertEncodingType,
                X509_BASIC_CONSTRAINTS2, 
                pExt->Value.pbData,
                pExt->Value.cbData,
                CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                    CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &PkiDecodePara,
                (void *) &pInfo2,
                &cbInfo
                )) {
            if (pExt->fCritical) 
                goto DecodeError;
            else
                goto SuccessReturn;
        }
        fCA = pInfo2->fCA;
        fEndEntity = !fCA;
        fPathLenConstraint = pInfo2->fPathLenConstraint;
        dwPathLenConstraint = pInfo2->dwPathLenConstraint;
    } else if (pExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        if (!CryptDecodeObjectEx(
                pEle->pCertContext->dwCertEncodingType,
                X509_BASIC_CONSTRAINTS, 
                pExt->Value.pbData,
                pExt->Value.cbData,
                CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                    CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &PkiDecodePara,
                (void *) &pInfo,
                &cbInfo
                )) {
            if (pExt->fCritical) 
                goto DecodeError;
            else
                goto SuccessReturn;
        }
        if (pExt->fCritical && pInfo->cSubtreesConstraint)
            goto SubtreesError;

        if (pInfo->SubjectType.cbData > 0) {
            BYTE bRole = pInfo->SubjectType.pbData[0];
            fCA = (0 != (bRole & CERT_CA_SUBJECT_FLAG));
            fEndEntity = (0 != (bRole & CERT_END_ENTITY_SUBJECT_FLAG));
        } else {
            fCA = FALSE;
            fEndEntity = FALSE;
        }
        fPathLenConstraint = pInfo->fPathLenConstraint;
        dwPathLenConstraint = pInfo->dwPathLenConstraint;
    } else
        goto SuccessReturn;


    if (0 == dwEleIndex) {
        if (dwFlags & BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG) {
            if (!fEndEntity)
                goto NotAnEndEntity;
        }
        if (dwFlags & BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG) {
            if (!fCA)
                goto NotACA;
        }
    } else {
        if (!fCA)
            goto NotACA;

        if (fPathLenConstraint) {
            // Check count of CAs below
            if (dwEleIndex - 1 > dwPathLenConstraint)
                goto PathLengthError;
        }
    }
    
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    PkiFree(pInfo2);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
 
TRACE_ERROR(NotACA)
TRACE_ERROR(NotAnEndEntity)
TRACE_ERROR(SubtreesError)
TRACE_ERROR(PathLengthError)
TRACE_ERROR(DecodeError)
}

BOOL
WINAPI
CertDllVerifyBasicConstraintsCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwFlags;

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize) {
        dwFlags = pPolicyPara->dwFlags;
        dwFlags &= (BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG |
            BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG);
        if (dwFlags == (BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG |
                BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG))
            dwFlags = 0;    // 0 => allow CA or END_ENTITY
    } else
        dwFlags = 0;

    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            if (!CheckChainElementBasicConstraints(pChain->rgpElement[j], j,
                    dwFlags)) {
                assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS,
                    lElementIndex) < pPolicyStatus->cbSize);
                pPolicyStatus->dwError = TRUST_E_BASIC_CONSTRAINTS;
                pPolicyStatus->lChainIndex = (LONG) i;
                pPolicyStatus->lElementIndex = (LONG) j;
                return TRUE;
            }
        }
        // Allow CTL to be signed by either a CA or END_ENTITY
        dwFlags = 0;
    }

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = 0;
    pPolicyStatus->lChainIndex = -1;
    pPolicyStatus->lElementIndex = -1;
    return TRUE;
}

//+=========================================================================
//  CertDllVerifyAuthenticodeCertificateChainPolicy Functions
//==========================================================================

BOOL VerifyAuthenticodeSignerStatement(
    IN PCMSG_SIGNER_INFO pSignerInfo,
    OUT BOOL *pfCommercial
    )
{
    BOOL fResult;
    BOOL fIndividual;
    PCRYPT_ATTRIBUTE pAttr;             // not allocated
    PSPC_STATEMENT_TYPE pInfo = NULL;
    DWORD cbInfo;
    DWORD cKeyPurposeId;
    LPSTR *ppszKeyPurposeId;            // not allocated

    *pfCommercial = FALSE;
    if (NULL == pSignerInfo)
        return TRUE;

    if (0 == pSignerInfo->AuthAttrs.cAttr)
        goto NoAttributes;

    if (NULL == (pAttr = CertFindAttribute(
            SPC_STATEMENT_TYPE_OBJID,
            pSignerInfo->AuthAttrs.cAttr,
            pSignerInfo->AuthAttrs.rgAttr
            )) || 0 == pAttr->cValue)
        goto NoStatementType;

    if (!CryptDecodeObjectEx(
            X509_ASN_ENCODING,
            SPC_STATEMENT_TYPE_STRUCT,
            pAttr->rgValue[0].pbData,
            pAttr->rgValue[0].cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    fIndividual = FALSE;
    cKeyPurposeId = pInfo->cKeyPurposeId;
    ppszKeyPurposeId = pInfo->rgpszKeyPurposeId;
    for ( ; cKeyPurposeId > 0; cKeyPurposeId--, ppszKeyPurposeId++) {
        if (0 == strcmp(*ppszKeyPurposeId,
                SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID))
            *pfCommercial  = TRUE;
        else if (0 == strcmp(*ppszKeyPurposeId,
                 SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID))
            fIndividual = TRUE;
    }
    
    if (!fIndividual && !*pfCommercial)
        goto NoPurpose;

    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;

ErrorReturn:
// On 12-Jun-1998 :: changed the authenticode policy to no longer require the
// StatementType attribute

    fResult = TRUE;
    goto CommonReturn;
 
TRACE_ERROR(NoAttributes);    
TRACE_ERROR(NoStatementType);
TRACE_ERROR(NoPurpose);
TRACE_ERROR(DecodeError);
}

#define CERT_PURPOSE_IS_SIGNER_FLAG         0x1
#define CERT_PURPOSE_IS_END_CERT_FLAG       0x2
#define CERT_PURPOSE_GET_COMMERCIAL_FLAG    0x4


BOOL CheckAuthenticodeEnhancedKeyUsage(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwPurposeFlags,
    IN OUT OPTIONAL BOOL *pfCommercial
    )
{
    BOOL fResult;
    BOOL fCommercialMsg = *pfCommercial;
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    PCERT_EXTENSION pExt;
    PCERT_ENHKEY_USAGE pInfo = NULL;
    DWORD cbInfo;

    BOOL fCodeSigning;
    BOOL fCommercial;
    BOOL fIndividual;
    DWORD cUsage;
    LPSTR *ppszUsage;

    if (0 == pCertInfo->cExtension)
        goto SuccessReturn;
    
    if (NULL == (pExt = CertFindExtension(
            szOID_ENHANCED_KEY_USAGE,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )))
        goto SuccessReturn;

    if (!CryptDecodeObjectEx(
            pCert->dwCertEncodingType,
            X509_ENHANCED_KEY_USAGE,
            pExt->Value.pbData,
            pExt->Value.cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;


    fCodeSigning = FALSE;
    fCommercial = FALSE;
    fIndividual = FALSE;
    cUsage = pInfo->cUsageIdentifier;
    ppszUsage = pInfo->rgpszUsageIdentifier;
    for ( ; cUsage > 0; cUsage--, ppszUsage++) {
        if (0 == strcmp(*ppszUsage, szOID_PKIX_KP_CODE_SIGNING)) {
            fCodeSigning = TRUE;
        } else if (0 == strcmp(*ppszUsage,
                SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID)) {
            fCodeSigning = TRUE;
            fCommercial = TRUE;
        } else if (0 == strcmp(*ppszUsage,
                SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID)) {
            fCodeSigning = TRUE;
            fIndividual = TRUE;
        }
    }

    if (!fCodeSigning) {
        if (dwPurposeFlags & CERT_PURPOSE_IS_SIGNER_FLAG)
            goto KeyPurposeError;
    } else {
        if (dwPurposeFlags & CERT_PURPOSE_GET_COMMERCIAL_FLAG) {
            assert(pfCommercial);
            *pfCommercial = fCommercial;
        } else if (fCommercial && fIndividual)
            ; // It supports both
        else if (!fIndividual && !fCommercial &&
                0 == (dwPurposeFlags & CERT_PURPOSE_IS_END_CERT_FLAG))
            ; // CA supports CodeSigning EKU
        else if ((fCommercialMsg && !fCommercial) ||
                 (!fCommercialMsg && fCommercial))
            goto KeyPurposeError;
    }
    
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
 
TRACE_ERROR(KeyPurposeError);
TRACE_ERROR(DecodeError);
}

BOOL CheckAuthenticodeCertPurpose(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwPurposeFlags,
    IN OUT OPTIONAL BOOL *pfCommercial
    )
{
    BOOL fResult;
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    PCERT_EXTENSION pExt;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = NULL;
    DWORD cbInfo;

    BOOL fCommercialMsg = *pfCommercial;

    if (0 == pCertInfo->cExtension)
        goto SuccessReturn;
    
    if (NULL == (pExt = CertFindExtension(
            szOID_KEY_USAGE_RESTRICTION,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )))
        return CheckAuthenticodeEnhancedKeyUsage(
            pCert,
            dwPurposeFlags,
            pfCommercial
            );

    if (!CryptDecodeObjectEx(
            pCert->dwCertEncodingType,
            X509_KEY_USAGE_RESTRICTION,
            pExt->Value.pbData,
            pExt->Value.cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    if (pInfo->cCertPolicyId) {
        BYTE bKeyUsage;
        BOOL fCommercial;
        BOOL fIndividual;
        DWORD cPolicyId;
        PCERT_POLICY_ID pPolicyId;

        fCommercial = FALSE;
        fIndividual = FALSE;
        cPolicyId = pInfo->cCertPolicyId;
        pPolicyId = pInfo->rgCertPolicyId;
        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++) {
            DWORD cElementId = pPolicyId->cCertPolicyElementId;
            LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;

            for ( ; cElementId > 0; cElementId--, ppszElementId++) 
            {
                if (0 == strcmp(*ppszElementId,
                        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID))
                    fCommercial = TRUE;
                else if (0 == strcmp(*ppszElementId,
                        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID))
                    fIndividual = TRUE;
            }
        }

        if (!fCommercial && !fIndividual &&
                (dwPurposeFlags & CERT_PURPOSE_IS_SIGNER_FLAG))
            goto KeyPurposeError;

        if (dwPurposeFlags & CERT_PURPOSE_GET_COMMERCIAL_FLAG) {
            assert(pfCommercial);
            *pfCommercial = fCommercial;
        } else if (fCommercial && fIndividual)
           ; // place holder -- it supports both (??? -- test cert only)
        else if ((fCommercialMsg && !fCommercial) ||
                 (!fCommercialMsg && fCommercial))
            goto KeyPurposeError;

        if (pInfo->RestrictedKeyUsage.cbData) {
            bKeyUsage = pInfo->RestrictedKeyUsage.pbData[0];
            
            if (0 == (bKeyUsage &
                    (CERT_DIGITAL_SIGNATURE_KEY_USAGE |
                        CERT_KEY_CERT_SIGN_KEY_USAGE))) {
                if (fCommercial || fIndividual)
                    goto KeyUsageError;
            }
        }
    }
    
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
 
TRACE_ERROR(KeyPurposeError);
TRACE_ERROR(KeyUsageError);
TRACE_ERROR(DecodeError);
}



void MapAuthenticodeRegPolicySettingsToBaseChainPolicyFlags(
    IN DWORD dwRegPolicySettings,
    IN BOOL fCommercial,
    IN OUT DWORD *pdwFlags
    )
{
    DWORD dwFlags;

    if (0 == dwRegPolicySettings)
        return;

    dwFlags = *pdwFlags;
    if (dwRegPolicySettings & WTPF_TRUSTTEST)
        dwFlags |= CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_TESTCANBEVALID)
        dwFlags |= CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_IGNOREEXPIRATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;

    if (dwRegPolicySettings & WTPF_IGNOREREVOKATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
    else {
        if (fCommercial) {
            if (dwRegPolicySettings & WTPF_OFFLINEOK_COM)
                dwFlags |= CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;
        } else {
            if (dwRegPolicySettings & WTPF_OFFLINEOK_IND)
                dwFlags |= CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;
        }
    }

    *pdwFlags = dwFlags;
}


void GetAuthenticodePara(
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    OUT DWORD *pdwRegPolicySettings,
    OUT PCMSG_SIGNER_INFO *ppSignerInfo
    )
{
    *ppSignerInfo = NULL;
    *pdwRegPolicySettings = 0;
    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA pAuthPara =
            (PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA)
                pPolicyPara->pvExtraPolicyPara;

        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA,
                dwRegPolicySettings) < pAuthPara->cbSize)
            *pdwRegPolicySettings = pAuthPara->dwRegPolicySettings;
        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA,
                pSignerInfo) < pAuthPara->cbSize)
            *ppSignerInfo = pAuthPara->pSignerInfo;
    }
}

// Map the CRYPT_E_ revocation errors to the corresponding CERT_E_
// revocation errors
static DWORD MapToAuthenticodeError(
    IN DWORD dwError
    )
{
    switch (dwError) {
        case CRYPT_E_REVOKED:
            return CERT_E_REVOKED;
            break;
        case CRYPT_E_NO_REVOCATION_DLL:
        case CRYPT_E_NO_REVOCATION_CHECK:
        case CRYPT_E_REVOCATION_OFFLINE:
        case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
            return CERT_E_REVOCATION_FAILURE;
            break;
    }
    return dwError;
}

BOOL
WINAPI
CertDllVerifyAuthenticodeCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwRegPolicySettings;
    PCMSG_SIGNER_INFO pSignerInfo;
    BOOL fAuthSignerStatement;
    BOOL fAuthCertPurpose;
    DWORD dwPurposeFlags;
    BOOL fCommercial;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;


    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;
    GetAuthenticodePara(pPolicyPara, &dwRegPolicySettings, &pSignerInfo);

    if (pSignerInfo) {
        fAuthSignerStatement = VerifyAuthenticodeSignerStatement(
            pSignerInfo, &fCommercial);

        dwPurposeFlags = CERT_PURPOSE_IS_SIGNER_FLAG |
            CERT_PURPOSE_IS_END_CERT_FLAG;
    } else {
        fAuthSignerStatement = TRUE;
        fCommercial = FALSE;
        dwPurposeFlags = CERT_PURPOSE_IS_END_CERT_FLAG |
            CERT_PURPOSE_GET_COMMERCIAL_FLAG;
    }

    // If no signer info, get fCommercial from the end certificate
    // itself.
    fAuthCertPurpose = CheckAuthenticodeCertPurpose(
        pChainContext->rgpChain[0]->rgpElement[0]->pCertContext,
        dwPurposeFlags,
        &fCommercial
        );

    dwPurposeFlags &= ~(CERT_PURPOSE_IS_END_CERT_FLAG |
        CERT_PURPOSE_GET_COMMERCIAL_FLAG);

    MapAuthenticodeRegPolicySettingsToBaseChainPolicyFlags(
        dwRegPolicySettings, fCommercial, &dwFlags);

    // Do the basic chain policy verification. Authenticode overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        dwError = MapToAuthenticodeError(dwError);
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        goto CommonReturn;
    }
        
    if (!fAuthSignerStatement || !fAuthCertPurpose) {
        // Note, any errors detected while doing basic chain policy
        // verification take precedence over a bad signer statement.
        dwError = CERT_E_PURPOSE;
        lChainIndex = 0;
        lElementIndex = 0;
        goto CommonReturn;
    }

    {
        // Check that all certs in the first chain have the appropriate
        // Commercial or Individual publisher purpose.
        //
        // For no signer, the first certificate determines if it has
        // commercial purpose

        DWORD i;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[0];

        for (i = 1; i < pChain->cElement; i++) {
            PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[i];

            if (!CheckAuthenticodeCertPurpose(
                    pEle->pCertContext,
                    dwPurposeFlags,
                    &fCommercial
                    )) {
                dwError = CERT_E_PURPOSE;
                lChainIndex = 0;
                lElementIndex = (LONG) i;
                goto CommonReturn;
            }
        }
    }

    if (pSignerInfo)
        BasePolicyPara.dwFlags =
            BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG;
    else
        BasePolicyPara.dwFlags = 0;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASIC_CONSTRAINTS,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        goto CommonReturn;
    }

    dwError = 0;

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;

    if (offsetof(CERT_CHAIN_POLICY_STATUS, pvExtraPolicyStatus) <
            pPolicyStatus->cbSize &&
                pPolicyStatus->pvExtraPolicyStatus) {
        // Return signer statement's Commercial/Individual flag
        PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS pAuthStatus =
            (PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS)
                pPolicyStatus->pvExtraPolicyStatus;
        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS,
                fCommercial) < pAuthStatus->cbSize)
            pAuthStatus->fCommercial = fCommercial;
    }
    return TRUE;
}

//+=========================================================================
//  CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy Functions
//==========================================================================

void MapAuthenticodeTimeStampRegPolicySettingsToBaseChainPolicyFlags(
    IN DWORD dwRegPolicySettings,
    IN BOOL fCommercial,
    IN OUT DWORD *pdwFlags
    )
{
    DWORD dwFlags;

    if (0 == dwRegPolicySettings)
        return;

    dwFlags = *pdwFlags;
    if (dwRegPolicySettings & WTPF_TRUSTTEST)
        dwFlags |= CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_TESTCANBEVALID)
        dwFlags |= CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_IGNOREEXPIRATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;

    if (dwRegPolicySettings & WTPF_IGNOREREVOCATIONONTS)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
    else {
        if (fCommercial) {
            if (dwRegPolicySettings & WTPF_OFFLINEOK_COM)
                dwFlags |= CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;
        } else {
            if (dwRegPolicySettings & WTPF_OFFLINEOK_IND)
                dwFlags |= CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;
        }
    }

    *pdwFlags = dwFlags;
}


void GetAuthenticodeTimeStampPara(
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    OUT DWORD *pdwRegPolicySettings,
    OUT BOOL *pfCommercial
    )
{
    *pdwRegPolicySettings = 0;
    *pfCommercial = FALSE;
    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA pAuthPara =
            (PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA)
                pPolicyPara->pvExtraPolicyPara;

        if (offsetof(AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA,
                dwRegPolicySettings) < pAuthPara->cbSize)
            *pdwRegPolicySettings = pAuthPara->dwRegPolicySettings;
        if (offsetof(AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA,
                fCommercial) < pAuthPara->cbSize)
            *pfCommercial = pAuthPara->fCommercial;
    }
}


BOOL
WINAPI
CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwRegPolicySettings;
    BOOL fCommercial;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;

    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;
    GetAuthenticodeTimeStampPara(
        pPolicyPara, &dwRegPolicySettings, &fCommercial);

    MapAuthenticodeTimeStampRegPolicySettingsToBaseChainPolicyFlags(
        dwRegPolicySettings, fCommercial, &dwFlags);

    // Do the basic chain policy verification. Authenticode overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        dwError = MapToAuthenticodeError(dwError);
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        goto CommonReturn;
    }

    dwError = 0;

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;
    return TRUE;
}

//+=========================================================================
//  CertDllVerifySSLCertificateChainPolicy Functions
//==========================================================================

BOOL CompareSSLDNStoCommonName(LPCWSTR pDNS, LPCWSTR pCN)
{
    int      nCountPeriods;
    BOOL     fExactMatch;
    LPCWSTR  pBakDNS;
    LPCWSTR  pBakCN;

    nCountPeriods   = 1;  // start of DNS amount to virtual '.' as prefix
    fExactMatch     = TRUE;
    pBakDNS         = pDNS;
    pBakCN          = pCN;

    // Note: Verisign use to put "*" in certificate subject names
    while (((towupper(*pDNS) == towupper(*pCN)) || (*pCN == L'*')) && (*pDNS) && (*pCN))
    {
        if (towupper(*pDNS) != towupper(*pCN))
        {
            fExactMatch = FALSE;
        }

        if (*pCN == L'*')
        {
            nCountPeriods = 0;

            if (*pDNS == L'.')
            {
                pCN++;
            }
            else
            {
                pDNS++;
            }
        }
        else
        {
            if (*pDNS == L'.')
            {
                nCountPeriods++;
            }

            pDNS++;
            pCN++;
        }
    }
    //
    // if they are sized 0, we make sure not to say they match.
    //
    if ((pBakDNS == pDNS) || (pBakCN == pCN))
    {
         fExactMatch = FALSE;
    }

    return((*pDNS == NULL) && (*pCN == NULL) && ((nCountPeriods >= 2) ||  (fExactMatch)));
}

BOOL IsSSLServerNameInNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pNameInfoBlob,
    IN LPCWSTR pwszServerName
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cRDN;
    PCERT_RDN pRDN;
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            pNameInfoBlob->pbData,
            pNameInfoBlob->cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    cRDN = pInfo->cRDN;
    pRDN = pInfo->rgRDN;
    for ( ; cRDN > 0; cRDN--, pRDN++) {
        DWORD cAttr = pRDN->cRDNAttr;
        PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
        for ( ; cAttr > 0; cAttr--, pAttr++) {
            if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                continue;
            if (0 == strcmp(pAttr->pszObjId, szOID_COMMON_NAME)) {
                if (CompareSSLDNStoCommonName(pwszServerName,
                        (LPCWSTR) pAttr->Value.pbData))
                    goto SuccessReturn;
            }
        }
    }

    goto ErrorReturn;
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

BOOL IsSSLServerNameInAltName(
    IN DWORD dwCertEncodingType,
    IN PCRYPT_DER_BLOB pAltNameBlob,
    IN LPCWSTR pwszServerName
    )
{
    BOOL fResult;
    PCERT_ALT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_ALTERNATE_NAME,
            pAltNameBlob->pbData,
            pAltNameBlob->cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    cEntry = pInfo->cAltEntry;
    pEntry = pInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        switch (pEntry->dwAltNameChoice) {
            case CERT_ALT_NAME_DNS_NAME:
                if (CompareSSLDNStoCommonName(pwszServerName,
                        pEntry->pwszDNSName))
                    goto SuccessReturn;
                break;
            case CERT_ALT_NAME_DIRECTORY_NAME:
                if (IsSSLServerNameInNameInfo(dwCertEncodingType,
                        &pEntry->DirectoryName, pwszServerName))
                    goto SuccessReturn;
                break;
            default:
                break;
        }
    }

    goto ErrorReturn;
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

BOOL IsSSLServerName(
    IN PCCERT_CONTEXT pCertContext,
    IN LPCWSTR pwszServerName
    )
{
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    DWORD dwCertEncodingType = pCertContext->dwCertEncodingType;
    PCERT_EXTENSION pExt;

    if (pExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME2,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        if (IsSSLServerNameInAltName(dwCertEncodingType,
                &pExt->Value, pwszServerName))
            return TRUE;
    }

    if (pExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        if (IsSSLServerNameInAltName(dwCertEncodingType,
                &pExt->Value, pwszServerName))
            return TRUE;
    }

    return IsSSLServerNameInNameInfo(dwCertEncodingType,
                &pCertInfo->Subject, pwszServerName);
}


BOOL
WINAPI
CertDllVerifySSLCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD fdwChecks;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;

    SSL_EXTRA_CERT_CHAIN_POLICY_PARA NullSSLExtraPara;
    PSSL_EXTRA_CERT_CHAIN_POLICY_PARA pSSLExtraPara;    // not allocated

    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);


    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        pSSLExtraPara =
            (PSSL_EXTRA_CERT_CHAIN_POLICY_PARA) pPolicyPara->pvExtraPolicyPara;
        if (offsetof(SSL_EXTRA_CERT_CHAIN_POLICY_PARA, pwszServerName) >=
                pSSLExtraPara->cbSize) {
            SetLastError((DWORD) ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    } else {
        pSSLExtraPara = &NullSSLExtraPara;
        memset(&NullSSLExtraPara, 0, sizeof(NullSSLExtraPara));
        NullSSLExtraPara.cbSize = sizeof(NullSSLExtraPara);
        NullSSLExtraPara.dwAuthType = AUTHTYPE_SERVER;
    }
        
    fdwChecks = pSSLExtraPara->fdwChecks;
    if (fdwChecks) {
        if (fdwChecks & SECURITY_FLAG_IGNORE_UNKNOWN_CA)
            // 11-Nov-98 per Sanjay Shenoy removed
            // CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG;
            dwFlags |= CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;

        if (fdwChecks & SECURITY_FLAG_IGNORE_WRONG_USAGE)
            dwFlags |= CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG;
        if (fdwChecks & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID)
            dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;
    }

    // Do the basic chain policy verification. SSL overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        if (CERT_E_CHAINING == dwError)
            dwError = CERT_E_UNTRUSTEDROOT;

        // Note, in looking at the wininet source, it appears they
        // look at CRYPT_E_REVOKED and not CERT_E_REVOKED.
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        goto CommonReturn;
    }
        

    if (pSSLExtraPara->pwszServerName) {
        BOOL fSGCCert = FALSE;
        if (0 == (fdwChecks & SECURITY_FLAG_IGNORE_WRONG_USAGE) && 
                0 == (fdwChecks & SECURITY_FLAG_IGNORE_UNKNOWN_CA)) {
            if (pSSLExtraPara->dwAuthType == AUTHTYPE_SERVER) {
                if (!IFC_IsEndCertValidForUsage(
                        pChainContext->rgpChain[0]->rgpElement[0]->pCertContext,
                        szOID_PKIX_KP_SERVER_AUTH
                        )) {
                    //  this flag controls:
                    //      1. CN names MUST match
                    //      2. if CN names don't match, return an error code
                    //         that is unknown to wininet.dll so that the user
                    //         can NOT select "Yes" to go to the site anyway...
                    fSGCCert = TRUE;
                }
            }
        }

        if (0 == (fdwChecks & SECURITY_FLAG_IGNORE_CERT_CN_INVALID) ||
                fSGCCert) {
            if (!IsSSLServerName(
                    pChainContext->rgpChain[0]->rgpElement[0]->pCertContext,
                    pSSLExtraPara->pwszServerName
                    )) {
                dwError = fSGCCert ? CERT_E_ROLE : CERT_E_CN_NO_MATCH;
                goto EndCertError;
            }
        }
    }

    dwError = 0;

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;

    return TRUE;

EndCertError:
    lChainIndex = 0;
    lElementIndex = 0;
    goto CommonReturn;
}


//+=========================================================================
//  CertDllVerifyNTAuthCertificateChainPolicy Functions
//==========================================================================

// Open and cache the store containing CAs trusted for NT Authentication.
// Also, enable auto resync for the cached store.
HCERTSTORE OpenNTAuthStore()
{
    HCERTSTORE hStore;

    hStore = hNTAuthCertStore;
    if (NULL == hStore) {
        // Serialize opening of the cached store
        CertPolicyLock();

        hStore = hNTAuthCertStore;
        if (NULL == hStore) {
            hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                0,                  // dwEncodingType
                0,                  // hCryptProv
                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE |
                    CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                L"NTAuth"
                );
            if (hStore) {
                CertControlStore(
                    hStore,
                    0,                  // dwFlags
                    CERT_STORE_CTRL_AUTO_RESYNC,
                    NULL                // pvCtrlPara
                    );
                hNTAuthCertStore = hStore;
            }
        }

        CertPolicyUnlock();
    }

    return hStore;
}

BOOL
WINAPI
CertDllVerifyNTAuthCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    BOOL fResult;
    DWORD dwError;
    PCERT_SIMPLE_CHAIN pChain;
    PCCERT_CONTEXT pFindCert;           // freed if found
    HCERTSTORE hStore;                  // cached, don't close
    BYTE rgbCertHash[SHA1_HASH_LEN];
    CRYPT_HASH_BLOB CertHash;

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);

    fResult = CertDllVerifyBaseCertificateChainPolicy(
        pszPolicyOID,
        pChainContext,
        pPolicyPara,
        pPolicyStatus
        );
    if (!fResult || 0 != pPolicyStatus->dwError)
        return fResult;

    fResult = CertDllVerifyBasicConstraintsCertificateChainPolicy(
        pszPolicyOID,
        pChainContext,
        pPolicyPara,
        pPolicyStatus
        );
    if (!fResult || 0 != pPolicyStatus->dwError)
        return fResult;

    // Check if we have a CA certificate that issued the end entity
    // certificate. Its Element[1] in the first simple chain.
    pChain = pChainContext->rgpChain[0];
    if (2 > pChain->cElement)
        goto MissingNTAuthCert;

    // Open the store where the CA certificate must exist to be trusted.
    // Note, this store is cached with auto resync enabled.
    if (NULL == (hStore = OpenNTAuthStore()))
        goto OpenNTAuthStoreError;

    // Try to find the CA certificate in the store
    CertHash.cbData = sizeof(rgbCertHash);
    CertHash.pbData = rgbCertHash;
    if (!CertGetCertificateContextProperty(
            pChain->rgpElement[1]->pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            CertHash.pbData,
            &CertHash.cbData
            ))
        goto GetHashPropertyError;
    if (NULL == (pFindCert = CertFindCertificateInStore(
            hStore,
            0,                      // dwCertEncodingType
            0,                      // dwFindFlags
            CERT_FIND_SHA1_HASH,
            &CertHash,
            NULL                    // pPrevCertContext
            )))
        goto UntrustedNTAuthCert;
    CertFreeCertificateContext(pFindCert);

    dwError = 0;
CommonReturn:
    pPolicyStatus->dwError = dwError;
    return TRUE;

ErrorReturn:
    pPolicyStatus->lChainIndex = 0;
    pPolicyStatus->lElementIndex = 1;
MissingNTAuthCert:
    dwError = CERT_E_UNTRUSTEDCA;
    goto CommonReturn;
TRACE_ERROR(OpenNTAuthStoreError)
TRACE_ERROR(GetHashPropertyError)
TRACE_ERROR(UntrustedNTAuthCert)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\protroot.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       protroot.cpp
//
//  Contents:   Protect Current User (CU) Root Store APIs
//
//  Functions:  I_ProtectedRootDllMain
//              I_CertProtectFunction
//              I_CertSrvProtectFunction
//              IPR_IsCurrentUserRootsAllowed
//              IPR_OnlyLocalMachineGroupPolicyRootsAllowed
//              IPR_InitProtectedRootInfo
//              IPR_DeleteUnprotectedRootsFromStore
//              IPR_ProtectedRootMessageBox
//
//  History:    23-Nov-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// Used for "root" system store's message box
static HMODULE hRegStoreInst;

// # of bytes for a hash. Such as, SHA (20) or MD5 (16)
#define MAX_HASH_LEN                20

#define PROT_ROOT_SUBKEY_NAME       L"ProtectedRoots"
#define PROT_ROOT_CERT_VALUE_NAME   L"Certificates"
#define PROT_ROOT_MAX_CNT           1000000

#define SYSTEM_STORE_REGPATH        L"Software\\Microsoft\\SystemCertificates"
#define PROT_ROOT_REGPATH           \
                SYSTEM_STORE_REGPATH L"\\Root\\" PROT_ROOT_SUBKEY_NAME

//+-------------------------------------------------------------------------
//  Protected root information data structure and defines
//
//  The protected root information is stored in the "Certificates" value of
//  the "root" store's "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------

// In V1, all hashes are SHA1 (length of 20 bytes) and are at the end of
// the info. cbInfo = dwRootOffset + cRoot * 20
typedef struct _PROT_ROOT_INFO {
    DWORD               cbSize;         // sizeof(PROT_ROOT_INFO)
    DWORD               dwVersion;
    FILETIME            LastUpdate;
    DWORD               cRoot;
    DWORD               dwRootOffset;
} PROT_ROOT_INFO, *PPROT_ROOT_INFO;

#define PROT_ROOT_V1            1

// SHA1 hash length
#define PROT_ROOT_HASH_LEN      20


//+-------------------------------------------------------------------------
//  Predefined SIDs allocated once by GetPredefinedSids. Freed at
//  ProcessDetach.
//--------------------------------------------------------------------------
static CRITICAL_SECTION ProtRootCriticalSection;
static BOOL fInitializedPredefinedSids = FALSE;
static PSID psidLocalSystem = NULL;
static PSID psidAdministrators = NULL;
static PSID psidEveryone = NULL;

//+-------------------------------------------------------------------------
//  SID definitions used to set security on the "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------
// Only enable the following if you want to do special testing without
// going through the LocalSystem service.
//#define TESTING_NO_PROT_ROOT_RPC    1

#define PSID_PROT_OWNER             psidAdministrators
#ifdef TESTING_NO_PROT_ROOT_RPC
#define PSID_PROT_SYSTEM            psidAdministrators
#else
#define PSID_PROT_SYSTEM            psidLocalSystem
#endif
#define PSID_PROT_EVERYONE          psidEveryone

//+-------------------------------------------------------------------------
//  ACL definitions used to set security on the "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------
#define PROT_SYSTEM_ACE_MASK        KEY_ALL_ACCESS
#define PROT_EVERYONE_ACE_MASK      KEY_READ
#define PROT_ACE_FLAGS              CONTAINER_INHERIT_ACE

#define PROT_ACE_COUNT              2
#define PROT_SYSTEM_ACE_INDEX       0
#define PROT_EVERYONE_ACE_INDEX     1


//+-------------------------------------------------------------------------
//  Allocate/free predefined SIDs
//--------------------------------------------------------------------------
static BOOL GetPredefinedSids()
{
    if (fInitializedPredefinedSids)
        return TRUE;

    BOOL fResult;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    EnterCriticalSection(&ProtRootCriticalSection);

    if (!fInitializedPredefinedSids) {
        if (!AllocateAndInitializeSid(
                &siaNtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                &psidLocalSystem
                )) 
            goto AllocateAndInitializeSidError;

        if (!AllocateAndInitializeSid(
                &siaNtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &psidAdministrators
                ))
            goto AllocateAndInitializeSidError;

        if (!AllocateAndInitializeSid(
                &siaWorldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                &psidEveryone
                ))
            goto AllocateAndInitializeSidError;

        fInitializedPredefinedSids = TRUE;
    }
    fResult = TRUE;
CommonReturn:
    LeaveCriticalSection(&ProtRootCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(AllocateAndInitializeSidError)
}

static void FreePredefinedSids()
{
    if (fInitializedPredefinedSids) {
        FreeSid(psidLocalSystem);
        FreeSid(psidAdministrators);
        FreeSid(psidEveryone);
    }
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_ProtectedRootDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        // Used for "root" system store's message box
        hRegStoreInst = hInst;

        InitializeCriticalSection(&ProtRootCriticalSection);
        break;

    case DLL_PROCESS_DETACH:
        FreePredefinedSids();
        DeleteCriticalSection(&ProtRootCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}

//+=========================================================================
//  Protected root registry flags support function
//==========================================================================

//+-------------------------------------------------------------------------
//  Get the ProtectedRoots Flags DWORD registry value stored in HKLM.
//--------------------------------------------------------------------------
STATIC DWORD GetProtectedRootFlags()
{
    HKEY hKey = NULL;
    LONG err;
    DWORD dwProtRootFlags = 0;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_PROT_ROOT_FLAGS_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))) goto RegOpenKeyError;
    if (!ILS_ReadDWORDValueFromRegistry(
            hKey,
            CERT_PROT_ROOT_FLAGS_VALUE_NAME,
            &dwProtRootFlags
            )) goto ReadValueError;

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return dwProtRootFlags;
ErrorReturn:
    dwProtRootFlags = 0;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenKeyError, err)
TRACE_ERROR(ReadValueError)
}

//+=========================================================================
//  Protected root information support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Open the SubKey containing the protected root information.
//--------------------------------------------------------------------------
STATIC HKEY OpenProtectedRootSubKey(
    IN HKEY hKeyCU,
    IN REGSAM samDesired
    )
{
    LONG err;
    HKEY hKeyProtRoot;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            hKeyCU,
            PROT_ROOT_REGPATH,
            0,                      // dwReserved
            samDesired,
            &hKeyProtRoot)))
        goto RegOpenKeyError;

CommonReturn:
    return hKeyProtRoot;
ErrorReturn:
    hKeyProtRoot = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenKeyError, err)
}

//+-------------------------------------------------------------------------
//  Create the SubKey containing the protected root information.
//--------------------------------------------------------------------------
STATIC HKEY CreateProtectedRootSubKey(
    IN HKEY hKeyCU,
    IN REGSAM samDesired
    )
{
    LONG err;
    HKEY hKeyProtRoot;
    DWORD dwDisposition;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            hKeyCU,
            PROT_ROOT_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            samDesired,
            NULL,                   // lpSecurityAttributes
            &hKeyProtRoot,
            &dwDisposition)))
        goto RegCreateKeyError;
CommonReturn:
    return hKeyProtRoot;
ErrorReturn:
    hKeyProtRoot = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegCreateKeyError, err)
}

//+-------------------------------------------------------------------------
//  Allocate, read from registry and verify the protected root info.
//
//  The root hashes are at the end of the info.
//--------------------------------------------------------------------------
STATIC PPROT_ROOT_INFO ReadProtectedRootInfo(
    IN HKEY hKeyProtRoot
    )
{
    PPROT_ROOT_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cRoot;
    DWORD dwRootOffset;

    if (!ILS_ReadBINARYValueFromRegistry(
            hKeyProtRoot,
            PROT_ROOT_CERT_VALUE_NAME,
            (BYTE **) &pInfo,
            &cbInfo
            )) goto ReadCertificatesProtInfoValueError;

    if (sizeof(PROT_ROOT_INFO) > cbInfo ||
            sizeof(PROT_ROOT_INFO) > pInfo->cbSize ||
            pInfo->cbSize > cbInfo ||
            PROT_ROOT_V1 != pInfo->dwVersion
            ) goto InvalidProtectedRootInfo;

    // The root hashes must be at the end of the info
    cRoot = pInfo->cRoot;
    dwRootOffset = pInfo->dwRootOffset;
    if (dwRootOffset < pInfo->cbSize || dwRootOffset > cbInfo ||
            PROT_ROOT_MAX_CNT < cRoot ||
            cRoot * PROT_ROOT_HASH_LEN != cbInfo - dwRootOffset
            ) goto InvalidProtectedRootInfo;

CommonReturn:
    return pInfo;
ErrorReturn:
    PkiFree(pInfo);
    pInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadCertificatesProtInfoValueError)
SET_ERROR(InvalidProtectedRootInfo, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Write the protected root info to the registry.
//
//  The root hashes are at the end of the info. Updates the info's
//  LastUpdate time.
//--------------------------------------------------------------------------
STATIC BOOL WriteProtectedRootInfo(
    IN HKEY hKeyProtRoot,
    IN OUT PPROT_ROOT_INFO pInfo
    )
{
    BOOL fResult;
    LONG err;
    DWORD cbInfo;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    cbInfo = pInfo->dwRootOffset + pInfo->cRoot * PROT_ROOT_HASH_LEN;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    pInfo->LastUpdate = FileTime;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKeyProtRoot,
            PROT_ROOT_CERT_VALUE_NAME,
            NULL,
            REG_BINARY,
            (BYTE *) pInfo,
            cbInfo
            ))) goto RegSetValueError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegSetValueError, err)
}


// In the debugger I saw 0x58
#define PROT_ROOT_SD_LEN      0x100

//+-------------------------------------------------------------------------
//  Allocate and get the security descriptor information for the specified
//  registry key.
//--------------------------------------------------------------------------
static PSECURITY_DESCRIPTOR AllocAndGetSecurityDescriptor(
    IN HKEY hKey,
    SECURITY_INFORMATION SecInf
    )
{
    LONG err;
    PSECURITY_DESCRIPTOR psd = NULL;
    DWORD cbsd;

    cbsd = PROT_ROOT_SD_LEN;
    if (NULL == (psd = (PSECURITY_DESCRIPTOR) PkiNonzeroAlloc(cbsd)))
        goto OutOfMemory;

    err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            );
    if (ERROR_SUCCESS == err)
        goto CommonReturn;
    if (ERROR_INSUFFICIENT_BUFFER != err)
        goto RegGetKeySecurityError;

    if (0 == cbsd)
        goto NoSecurityDescriptor;

    PkiFree(psd);
    psd = NULL;
    if (NULL == (psd = (PSECURITY_DESCRIPTOR) PkiNonzeroAlloc(cbsd)))
        goto OutOfMemory;

    if (ERROR_SUCCESS != (err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            ))) goto RegGetKeySecurityError;

CommonReturn:
    return psd;
ErrorReturn:
    PkiFree(psd);
    psd = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(RegGetKeySecurityError, err)
SET_ERROR(NoSecurityDescriptor, ERROR_INVALID_SECURITY_DESCR)
}

//+-------------------------------------------------------------------------
//  Opens the "ProtectedRoots" registry key and verifies its security owner,
//  group, DACLs and SACLs. Must match the security set by
//  SrvGetProtectedRootInfo().
//
//  If the "ProtectedRoots" SubKey has the proper security. Allocates, reads
//  and verifies the "Certificates" value to get the protected root info.
//--------------------------------------------------------------------------
STATIC BOOL GetProtectedRootInfo(
    IN HKEY hKeyCU,
    IN REGSAM samDesired,
    OUT OPTIONAL HKEY *phKeyProtRoot,
    OUT OPTIONAL PPROT_ROOT_INFO *ppInfo
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PSID psidOwner;                 // not allocated
    BOOL fOwnerDefaulted;
    BOOL fDaclPresent;
    PACL pAcl;                      // not allocated
    BOOL fDaclDefaulted;
    DWORD dwAceIndex;
    PACCESS_ALLOWED_ACE rgpAce[PROT_ACE_COUNT];

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, samDesired)))
        goto OpenProtectedRootSubKeyError;
    if (NULL == (psd = AllocAndGetSecurityDescriptor(
            hKeyProtRoot,
            OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION
            ))) goto GetSecurityDescriptorError;

    if (!GetPredefinedSids())
        goto GetPredefinedSidsError;

    // Verify owner
    if (!GetSecurityDescriptorOwner(psd, &psidOwner, &fOwnerDefaulted))
        goto GetSecurityDescriptorOwnerError;
    if (NULL == psidOwner || !EqualSid(psidOwner, PSID_PROT_OWNER))
        goto InvalidProtectedRootOwner;

    // Verify DACL
    if (!GetSecurityDescriptorDacl(psd, &fDaclPresent, &pAcl,
            &fDaclDefaulted))
        goto GetSecurityDescriptorDaclError;
    if (!fDaclPresent || NULL == pAcl)
        goto MissingProtectedRootDaclError;
    if (PROT_ACE_COUNT != pAcl->AceCount)
        goto InvalidProtectedRootDacl;

    for (dwAceIndex = 0; dwAceIndex < PROT_ACE_COUNT; dwAceIndex++) {
        PACCESS_ALLOWED_ACE pAce;
        if (!GetAce(pAcl, dwAceIndex, (void **) &pAce))
            goto InvalidProtectedRootDacl;
        rgpAce[dwAceIndex] = pAce;

        if (ACCESS_ALLOWED_ACE_TYPE != pAce->Header.AceType ||
                PROT_ACE_FLAGS != pAce->Header.AceFlags)
            goto InvalidProtectedRootDacl;
    }

    if (PROT_SYSTEM_ACE_MASK != rgpAce[PROT_SYSTEM_ACE_INDEX]->Mask ||
            !EqualSid(PSID_PROT_SYSTEM,
                (PSID) &rgpAce[PROT_SYSTEM_ACE_INDEX]->SidStart) ||
            PROT_EVERYONE_ACE_MASK != rgpAce[PROT_EVERYONE_ACE_INDEX]->Mask ||
            !EqualSid(PSID_PROT_EVERYONE,
                (PSID) &rgpAce[PROT_EVERYONE_ACE_INDEX]->SidStart))
        goto InvalidProtectedRootDacl;

    // Get verified protected root info
    if (NULL == (pInfo = ReadProtectedRootInfo(hKeyProtRoot)))
        goto ReadProtectedRootInfoError;

    fResult = TRUE;
CommonReturn:
    PkiFree(psd);
    if (phKeyProtRoot)
        *phKeyProtRoot = hKeyProtRoot;
    else
        ILS_CloseRegistryKey(hKeyProtRoot);
    if (ppInfo)
        *ppInfo = pInfo;
    else
        PkiFree(pInfo);
    return fResult;
ErrorReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    hKeyProtRoot = NULL;
    PkiFree(pInfo);
    pInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(GetSecurityDescriptorError)
TRACE_ERROR(GetPredefinedSidsError)
TRACE_ERROR(GetSecurityDescriptorOwnerError)
TRACE_ERROR(GetSecurityDescriptorDaclError)
SET_ERROR(InvalidProtectedRootOwner, ERROR_INVALID_OWNER)
SET_ERROR(MissingProtectedRootDaclError, ERROR_INVALID_ACL)
SET_ERROR(InvalidProtectedRootDacl, ERROR_INVALID_ACL)
TRACE_ERROR(ReadProtectedRootInfoError)
}


//+=========================================================================
//  Functions to find, add or delete a root hash from the protected root
//  info.
//==========================================================================
STATIC BOOL FindProtectedRoot(
    IN PPROT_ROOT_INFO pInfo,
    IN BYTE rgbFindRootHash[PROT_ROOT_HASH_LEN],
    OUT OPTIONAL DWORD *pdwRootIndex = NULL
    )
{
    BYTE *pbRoot = (BYTE *) pInfo + pInfo->dwRootOffset;
    DWORD cRoot = pInfo->cRoot;
    DWORD dwRootIndex = 0;
    BYTE bFirst = rgbFindRootHash[0];

    for ( ; dwRootIndex < cRoot; dwRootIndex++, pbRoot += PROT_ROOT_HASH_LEN) {
        if (bFirst == *pbRoot &&
                0 == memcmp(rgbFindRootHash, pbRoot, PROT_ROOT_HASH_LEN)) {
            if (pdwRootIndex)
                *pdwRootIndex = dwRootIndex;
            return TRUE;
        }
    }
    if (pdwRootIndex)
        *pdwRootIndex = 0;
    return FALSE;
}

// Root hash is appended to the end of the list
STATIC BOOL AddProtectedRoot(
    IN OUT PPROT_ROOT_INFO *ppInfo,
    IN BYTE rgbAddRootHash[PROT_ROOT_HASH_LEN]
    )
{
    PPROT_ROOT_INFO pInfo = *ppInfo;
    DWORD cRoot = pInfo->cRoot;
    DWORD dwRootOffset = pInfo->dwRootOffset;
    DWORD cbInfo;

    if (PROT_ROOT_MAX_CNT <= cRoot) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    cbInfo = dwRootOffset + (cRoot + 1) * PROT_ROOT_HASH_LEN;

    if (NULL == (pInfo = (PPROT_ROOT_INFO) PkiRealloc(pInfo, cbInfo)))
        return FALSE;

    memcpy((BYTE *) pInfo + (dwRootOffset + cRoot * PROT_ROOT_HASH_LEN),
        rgbAddRootHash, PROT_ROOT_HASH_LEN);
    pInfo->cRoot = cRoot + 1;
    *ppInfo = pInfo;
    return TRUE;
}

STATIC void DeleteProtectedRoot(
    IN PPROT_ROOT_INFO pInfo,
    IN DWORD dwDeleteRootIndex
    )
{
    DWORD cRoot = pInfo->cRoot;
    BYTE *pbRoot = (BYTE *) pInfo + pInfo->dwRootOffset;

    assert(0 < cRoot);
    assert(dwDeleteRootIndex < cRoot);
    cRoot--;

    if (cRoot > dwDeleteRootIndex) {
        // Move following roots down
        BYTE *pbDst = pbRoot + dwDeleteRootIndex * PROT_ROOT_HASH_LEN;
        BYTE *pbSrc = pbDst + PROT_ROOT_HASH_LEN;
        DWORD cbMove = (cRoot - dwDeleteRootIndex) * PROT_ROOT_HASH_LEN;
        while (cbMove--)
            *pbDst++ = *pbSrc++;
    }
    // else
    //  last root in list

    pInfo->cRoot = cRoot;
}

//+=========================================================================
//  Certificate store support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Opens the SystemRegistry "Root" store unprotected and relative to the
//  specifed base SubKey.
//--------------------------------------------------------------------------
STATIC HCERTSTORE OpenUnprotectedRootStore(
    IN HKEY hKeyCU,
    IN DWORD dwOpenFlags = 0
    )
{
    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    RelocatePara.hKeyBase = hKeyCU;
    RelocatePara.pwszSystemStore = L"Root";
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_W,
        0,                                  // dwEncodingType
        NULL,                               // hCryptProv
        CERT_SYSTEM_STORE_RELOCATE_FLAG |
            CERT_SYSTEM_STORE_UNPROTECTED_FLAG |
            CERT_SYSTEM_STORE_CURRENT_USER |
            dwOpenFlags,
        (const void *) &RelocatePara
        );
}

//+-------------------------------------------------------------------------
//  Gets the certificate's SHA1 hash property. Rehashes the encoded
//  certificate. Returns TRUE if the property matches the regenerated hash.
//--------------------------------------------------------------------------
static BOOL GetVerifiedCertHashProperty(
    IN PCCERT_CONTEXT pCert,
    OUT BYTE rgbHash[PROT_ROOT_HASH_LEN]
    )
{
    BYTE rgbProp[PROT_ROOT_HASH_LEN];
    DWORD cbData;
    
    cbData = PROT_ROOT_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbProp,
            &cbData
            ) || PROT_ROOT_HASH_LEN != cbData)
        return FALSE;

    // Verify the property
    cbData = PROT_ROOT_HASH_LEN;
    if (!CryptHashCertificate(
            0,                  // hProv
            CALG_SHA1,
            0,                  //dwFlags
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            rgbHash,
            &cbData
            ) || PROT_ROOT_HASH_LEN != cbData)
        return FALSE;
    return (0 == memcmp(rgbHash, rgbProp, PROT_ROOT_HASH_LEN));
}


//+=========================================================================
//  FormatMsgBox support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Formats multi bytes into WCHAR hex. Includes a space after every 4 bytes.
//
//  Needs (cb * 2 + cb/4 + 1) characters in wsz
//--------------------------------------------------------------------------
static void FormatMsgBoxMultiBytes(DWORD cb, BYTE *pb, LPWSTR wsz)
{
    for (DWORD i = 0; i<cb; i++) {
        int b;
        if (i && 0 == (i & 3))
            *wsz++ = L' ';
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Format and allocate a single message box item
//
//  The formatted item needs to be LocalFree'ed.
//--------------------------------------------------------------------------
static void FormatMsgBoxItem(
    OUT LPWSTR *ppwszMsg,
    OUT DWORD *pcchMsg,
    IN UINT nFormatID,
    ...
    )
{
    // get format string from resources
    WCHAR wszFormat[256];
    wszFormat[0] = '\0';
    LoadStringU(hRegStoreInst, nFormatID, wszFormat,
        sizeof(wszFormat)/sizeof(wszFormat[0]));

    // format message into requested buffer
    va_list argList;
    va_start(argList, nFormatID);
    *ppwszMsg = NULL;
    *pcchMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) ppwszMsg,
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);
}


//+=========================================================================
//  Protected root functions called from the services process
//==========================================================================


//+-------------------------------------------------------------------------
//  Enable the specified security privilege for the current process.
//--------------------------------------------------------------------------
static BOOL EnableSecurityPrivilege(
    LPCSTR pszPrivilege
    )
{
    BOOL fResult;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious;

    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            ))
        goto OpenProcessTokenError;

    if (!LookupPrivilegeValueA(NULL, pszPrivilege, &luid))
        goto LookupPrivilegeValueError;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    cbPrevious = sizeof(TOKEN_PRIVILEGES);
    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );
    if (ERROR_SUCCESS != GetLastError())
        goto AdjustTokenPrivilegesError;

    //
    // second pass.  enable privilege
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;
    tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );
    if (ERROR_SUCCESS != GetLastError())
        goto AdjustTokenPrivilegesError;

    fResult = TRUE;
CommonReturn:
    if (hToken)
        CloseHandle(hToken);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenProcessTokenError)
TRACE_ERROR(LookupPrivilegeValueError)
TRACE_ERROR(AdjustTokenPrivilegesError)
}

//+-------------------------------------------------------------------------
//  Take ownership of the "ProtectedRoots" SubKey
//--------------------------------------------------------------------------
STATIC BOOL SetProtectedRootOwner(
    IN HKEY hKeyCU,
    OUT BOOL *pfNew
    )
{
    BOOL fResult;
    LONG err;
    BOOL fNew = FALSE;
    HKEY hKeyProtRoot = NULL;
    SECURITY_DESCRIPTOR sd;

    if (!EnableSecurityPrivilege(SE_TAKE_OWNERSHIP_NAME))
        goto EnableTakeOwnershipPrivilegeError;

    if (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, WRITE_OWNER))
        fNew = FALSE;
    else {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
            hKeyProtRoot = CreateProtectedRootSubKey(hKeyCU, WRITE_OWNER);
        if (NULL == hKeyProtRoot)
            goto OpenProtectedRootSubKeyError;
        fNew = TRUE;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;

    if (!SetSecurityDescriptorOwner(&sd, PSID_PROT_OWNER, FALSE))
        goto SetSecurityDescriptorOwnerError;

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKeyProtRoot,
            OWNER_SECURITY_INFORMATION,
            &sd
            )))
        goto RegSetKeySecurityError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    *pfNew = fNew;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnableTakeOwnershipPrivilegeError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(SetSecurityDescriptorOwnerError)
SET_ERROR_VAR(RegSetKeySecurityError, err)
}

//+-------------------------------------------------------------------------
//  Allocate and get the specified token info.
//--------------------------------------------------------------------------
static void * AllocAndGetTokenInfo(
    IN HANDLE hToken,
    IN TOKEN_INFORMATION_CLASS tic
    )
{
    void *pvInfo = NULL;
    DWORD cbInfo = 0;
    DWORD cbInfo2;

    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            0,              // cbInfo
            &cbInfo
            )) {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
            goto GetTokenInfoError;
    }
    if (0 == cbInfo)
        goto NoTokenInfoError;
    if (NULL == (pvInfo = PkiNonzeroAlloc(cbInfo)))
        goto OutOfMemory;

    cbInfo2 = cbInfo;
    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            cbInfo,
            &cbInfo2
            ))
        goto GetTokenInfoError;

CommonReturn:
    return pvInfo;
ErrorReturn:
    PkiFree(pvInfo);
    pvInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(GetTokenInfoError)
SET_ERROR(NoTokenInfoError, ERROR_NO_TOKEN)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Set the security group, DACLs and SACLs for the "ProtectedRoots" SubKey
//--------------------------------------------------------------------------
STATIC BOOL SetProtectedRootGroupDaclSacl(
    IN HKEY hKeyCU
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKeyProtRoot = NULL;
    SECURITY_DESCRIPTOR sd;
    HANDLE hToken = NULL;
    void *pvTokenInfo = NULL;

    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce;
    DWORD dwAclSize;
    DWORD i;

    if (!EnableSecurityPrivilege(SE_SECURITY_NAME))
        goto EnableSecurityNamePrivilegeError;

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(
            hKeyCU,
            WRITE_OWNER | WRITE_DAC | ACCESS_SYSTEM_SECURITY
            )))
        goto OpenProtectedRootSubKeyError;

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;

    // Set group SID using current process token's primary group SID
    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            ))
        goto OpenProcessTokenError;
    if (NULL == (pvTokenInfo = AllocAndGetTokenInfo(hToken, TokenPrimaryGroup)))
        goto GetTokenInfoError;
    else {
        PTOKEN_PRIMARY_GROUP pTokenPrimaryGroup =
            (PTOKEN_PRIMARY_GROUP) pvTokenInfo;
        PSID psidGroup = pTokenPrimaryGroup->PrimaryGroup;

        if (!SetSecurityDescriptorGroup(&sd, psidGroup, FALSE))
            goto SetSecurityDescriptorGroupError;
    }

    // Set DACL

    //
    // compute size of ACL
    //
    dwAclSize = sizeof(ACL) +
        PROT_ACE_COUNT * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(PSID_PROT_SYSTEM) +
        GetLengthSid(PSID_PROT_EVERYONE)
        ;

    //
    // allocate storage for Acl
    //
    if (NULL == (pDacl = (PACL) PkiNonzeroAlloc(dwAclSize)))
        goto OutOfMemory;

    if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        goto InitializeAclError;

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            PROT_SYSTEM_ACE_MASK,
            PSID_PROT_SYSTEM
            ))
        goto AddAceError;
    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            PROT_EVERYONE_ACE_MASK,
            PSID_PROT_EVERYONE
            ))
        goto AddAceError;

    //
    // make containers inherit.
    //
    for (i = 0; i < PROT_ACE_COUNT; i++) {
        if(!GetAce(pDacl, i, (void **) &pAce))
            goto GetAceError;
        pAce->Header.AceFlags = PROT_ACE_FLAGS;
    }

    if (!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
        goto SetSecurityDescriptorDaclError;

    // Set SACL
    if (!SetSecurityDescriptorSacl(&sd, FALSE, NULL, FALSE))
        goto SetSecurityDescriptorSaclError;

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKeyProtRoot,
            GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION |
                SACL_SECURITY_INFORMATION,
            &sd
            )))
        goto RegSetKeySecurityError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    if (hToken)
        CloseHandle(hToken);
    PkiFree(pvTokenInfo);
    PkiFree(pDacl);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnableSecurityNamePrivilegeError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(OpenProcessTokenError)
TRACE_ERROR(GetTokenInfoError)
TRACE_ERROR(SetSecurityDescriptorGroupError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(AddAceError)
TRACE_ERROR(GetAceError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
TRACE_ERROR(SetSecurityDescriptorSaclError)
SET_ERROR_VAR(RegSetKeySecurityError, err)
}

//+-------------------------------------------------------------------------
//  Create the initial protected root info.
//
//  If not inhibited, add all the roots in the unprotected CurrentUser
//  "Root" store.
//--------------------------------------------------------------------------
STATIC BOOL InitAndSetProtectedRootInfo(
    IN HKEY hKeyCU,
    IN BOOL fNew
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    HCERTSTORE hStore = NULL;
    PPROT_ROOT_INFO pInfo = NULL;

    if (NULL == (pInfo = (PPROT_ROOT_INFO) PkiNonzeroAlloc(
            sizeof(PROT_ROOT_INFO))))
        goto OutOfMemory;
    memset(pInfo, 0, sizeof(PROT_ROOT_INFO));
    pInfo->cbSize = sizeof(PROT_ROOT_INFO);
    pInfo->dwVersion = PROT_ROOT_V1;
    pInfo->dwRootOffset = sizeof(PROT_ROOT_INFO);

    if (fNew && 0 == (GetProtectedRootFlags() &
            CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG)) {
        if (hStore = OpenUnprotectedRootStore(hKeyCU,
                CERT_STORE_READONLY_FLAG)) {
            PCCERT_CONTEXT pCert = NULL;
            while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
                BYTE rgbHash[PROT_ROOT_HASH_LEN];
                if (GetVerifiedCertHashProperty(pCert, rgbHash)) {
                    if (!AddProtectedRoot(&pInfo, rgbHash))
                        goto AddProtectedRootError;
                }
            }
        }
    }

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(
            hKeyCU,
            KEY_ALL_ACCESS
            ))) goto OpenProtectedRootSubKeyError;

    if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
        goto WritedProtectedRootInfoError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    CertCloseStore(hStore, 0);
    ILS_CloseRegistryKey(hKeyProtRoot);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AddProtectedRootError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(WritedProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Open the "ProtectedRoots" SubKey and verify its security. Allocate,
//  read and verify the protected root information.
//
//  If the "ProtectedRoots" SubKey doesn't exist or is invalid, initialize.
//--------------------------------------------------------------------------
STATIC BOOL SrvGetProtectedRootInfo(
    IN HKEY hKeyCU,
    OUT OPTIONAL HKEY *phKeyProtRoot,
    OUT OPTIONAL PPROT_ROOT_INFO *ppProtRootInfo
    )
{
    BOOL fNew;
    if (GetProtectedRootInfo(
            hKeyCU,
            KEY_ALL_ACCESS,
            phKeyProtRoot,
            ppProtRootInfo
            ))
        return TRUE;

    if (!GetPredefinedSids())
        return FALSE;

    if (!SetProtectedRootOwner(hKeyCU, &fNew))
        return FALSE;
    if (!SetProtectedRootGroupDaclSacl(hKeyCU))
        return FALSE;
    if (!InitAndSetProtectedRootInfo(hKeyCU, fNew))
        return FALSE;

    return GetProtectedRootInfo(
        hKeyCU,
        KEY_ALL_ACCESS,
        phKeyProtRoot,
        ppProtRootInfo
        );
}

//+-------------------------------------------------------------------------
//  Initialize the protected list of CurrentUser roots
//--------------------------------------------------------------------------
STATIC BOOL SrvInitProtectedRoots(
    IN HKEY hKeyCU
    )
{
    return SrvGetProtectedRootInfo(
        hKeyCU,
        NULL,           // phKeyProtRoot
        NULL            // ppProtRootInfo
        );
}

//+-------------------------------------------------------------------------
//  Purge all CurrentUser roots from the protected list that also exist
//  in the LocalMachine SystemRegistry "Root" store. Also removes duplicated
//  certificates from the CurrentUser SystemRegistry "Root" store.
//--------------------------------------------------------------------------
STATIC BOOL SrvPurgeLocalMachineProtectedRoots(
    IN HKEY hKeyCU
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    HCERTSTORE hCURootStore = NULL;
    HCERTSTORE hLMRootStore = NULL;
    BOOL fProtDeleted;
    BYTE rgbHash[PROT_ROOT_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;
    DWORD dwRootIndex;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (GetProtectedRootFlags() & CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG)
        goto AccessDenied;

    if (NULL == (hCURootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenCURootStoreError;

    if (NULL == (hLMRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
            (const void *) L"Root"
            )))
        goto OpenLMRootStoreError;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = PROT_ROOT_HASH_LEN;
    fProtDeleted = FALSE;
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hCURootStore, pCert)) {
        if (GetVerifiedCertHashProperty(pCert, rgbHash)) {
            PCCERT_CONTEXT pLMCert;

            if (pLMCert = CertFindCertificateInStore(
                    hLMRootStore,
                    0,                  // dwCertEncodingType
                    0,                  // dwFindFlags
                    CERT_FIND_SHA1_HASH,
                    (const void *) &HashBlob,
                    NULL                //pPrevCertContext
                    )) {
                // CurrentUser Root also exists in LocalMachine. Delete
                // it from the CurrentUser Root store.
                DWORD dwRootIndex;
                PCCERT_CONTEXT pDeleteCert =
                    CertDuplicateCertificateContext(pCert);

                CertFreeCertificateContext(pLMCert);
                if (!CertDeleteCertificateFromStore(pDeleteCert))
                    goto DeleteCertFromRootStoreError;

                if (FindProtectedRoot(pInfo, rgbHash, &dwRootIndex)) {
                    // The CurrentUser Root is in the protected list,
                    // delete it from there.
                    DeleteProtectedRoot(pInfo, dwRootIndex);
                    fProtDeleted = TRUE;
                }
            }
        }
    }

    // If a protected root exists in the LocalMachine, then, delete it
    // from  the protected list. This step is necessary, if the root
    // was removed from the CurrentUser unprotected store.
    dwRootIndex = pInfo->cRoot;
    HashBlob.pbData = (BYTE *) pInfo + pInfo->dwRootOffset +
        PROT_ROOT_HASH_LEN * dwRootIndex;
    while (dwRootIndex--) {
        PCCERT_CONTEXT pLMCert;

        HashBlob.pbData -= PROT_ROOT_HASH_LEN;
        if (pLMCert = CertFindCertificateInStore(
                hLMRootStore,
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SHA1_HASH,
                (const void *) &HashBlob,
                NULL                //pPrevCertContext
                )) {
            CertFreeCertificateContext(pLMCert);
            // Cert exists in the LocalMachine store, delete
            // from protected list.
            DeleteProtectedRoot(pInfo, dwRootIndex);
            fProtDeleted = TRUE;
        }
    }

    if (fProtDeleted) {
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hCURootStore, 0);
    CertCloseStore(hLMRootStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(OpenCURootStoreError)
TRACE_ERROR(OpenLMRootStoreError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(DeleteCertFromRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Add the specified certificate to the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the add.
//--------------------------------------------------------------------------
STATIC BOOL SrvAddProtectedRoot(
    IN HKEY hKeyCU,
    IN BYTE *pbSerializedCert,
    IN DWORD cbSerializedCert
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    BYTE rgbCertHash[PROT_ROOT_HASH_LEN];
    HCERTSTORE hRootStore = NULL;
    BOOL fProtExists;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (!CertAddSerializedElementToStore(
            NULL,               // hCertStore, NULL => create context
            pbSerializedCert,
            cbSerializedCert,
            CERT_STORE_ADD_ALWAYS,
            0,                  // dwFlags
            CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
            NULL,               // pdwContextType
            (const void **) &pCert
            )) goto CreateCertContextError;

    if (!GetVerifiedCertHashProperty(pCert, rgbCertHash))
        goto VerifyHashPropertyError;

    fProtExists = FindProtectedRoot(pInfo, rgbCertHash);
    if (!fProtExists) {
        if (IDYES != IPR_ProtectedRootMessageBox(pCert,
                IDS_ROOT_MSG_BOX_ADD_ACTION,
                MB_TOPMOST | MB_SERVICE_NOTIFICATION ))
            goto Cancelled;
    }

    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    if (!CertAddSerializedElementToStore(
            hRootStore,
            pbSerializedCert,
            cbSerializedCert,
            CERT_STORE_ADD_REPLACE_EXISTING,
            0,                  // dwFlags
            CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
            NULL,               // pdwContextType
            NULL                // ppvContext
            )) goto AddCertToRootStoreError;

    if (!fProtExists) {
        if (!AddProtectedRoot(&pInfo, rgbCertHash))
            goto AddProtectedRootError;
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(CreateCertContextError)
TRACE_ERROR(VerifyHashPropertyError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(AddCertToRootStoreError)
TRACE_ERROR(AddProtectedRootError)
TRACE_ERROR(WriteProtectedRootInfoError)
}


//+-------------------------------------------------------------------------
//  Delete the specified certificate from the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the delete.
//--------------------------------------------------------------------------
STATIC BOOL SrvDeleteProtectedRoot(
    IN HKEY hKeyCU,
    IN BYTE rgbRootHash[PROT_ROOT_HASH_LEN]
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    HCERTSTORE hRootStore = NULL;
    BYTE rgbCertHash[PROT_ROOT_HASH_LEN];
    DWORD dwRootIndex;
    BOOL fProtExists;
    CRYPT_DATA_BLOB RootHashBlob;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    RootHashBlob.pbData = rgbRootHash;
    RootHashBlob.cbData = PROT_ROOT_HASH_LEN;
    if (NULL == (pCert = CertFindCertificateInStore(
            hRootStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &RootHashBlob,
            NULL                //pPrevCertContext
            ))) goto FindCertError;

    if (!GetVerifiedCertHashProperty(pCert, rgbCertHash))
        goto VerifyHashPropertyError;

    fProtExists = FindProtectedRoot(pInfo, rgbCertHash, &dwRootIndex);
    if (fProtExists) {
        if (IDYES != IPR_ProtectedRootMessageBox(pCert,
                IDS_ROOT_MSG_BOX_DELETE_ACTION,
                MB_TOPMOST | MB_SERVICE_NOTIFICATION ))
            goto Cancelled;
    }

    fResult = CertDeleteCertificateFromStore(pCert);
    pCert = NULL;
    if (!fResult)
        goto DeleteCertFromRootStoreError;
    if (fProtExists) {
        DeleteProtectedRoot(pInfo, dwRootIndex);
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(FindCertError)
TRACE_ERROR(VerifyHashPropertyError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(DeleteCertFromRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Delete all CurrentUser roots from the protected list that don't also
//  exist in the CurrentUser SystemRegistry "Root" store. The user is
//  prompted before doing the delete.
//--------------------------------------------------------------------------
STATIC BOOL SrvDeleteUnknownProtectedRoots(
    IN HKEY hKeyCU
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    HCERTSTORE hRootStore = NULL;
    DWORD cOrigRoot;
    CRYPT_DATA_BLOB HashBlob;
    DWORD dwRootIndex;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;
    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    cOrigRoot = pInfo->cRoot;

    HashBlob.pbData = (BYTE *) pInfo + pInfo->dwRootOffset +
        PROT_ROOT_HASH_LEN * cOrigRoot;
    HashBlob.cbData = PROT_ROOT_HASH_LEN;
    dwRootIndex = cOrigRoot;
    while (dwRootIndex--) {
        PCCERT_CONTEXT pCert;

        HashBlob.pbData -= PROT_ROOT_HASH_LEN;
        if (pCert = CertFindCertificateInStore(
                hRootStore,
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SHA1_HASH,
                (const void *) &HashBlob,
                NULL                //pPrevCertContext
                ))
            CertFreeCertificateContext(pCert);
        else
            // Cert doesn't exist in the unprotected store, delete
            // from protected list.
            DeleteProtectedRoot(pInfo, dwRootIndex);
    }

    if (cOrigRoot > pInfo->cRoot) {
        // At least one root was deleted above
        int id;
        LPWSTR pwszTitle;
        LPWSTR pwszText;
        DWORD cchText;

        FormatMsgBoxItem(&pwszTitle, &cchText, IDS_ROOT_MSG_BOX_TITLE);
        FormatMsgBoxItem(&pwszText, &cchText,
            IDS_ROOT_MSG_BOX_DELETE_UNKNOWN_PROT_ROOTS,
                cOrigRoot - pInfo->cRoot);

        id = MessageBoxU(
                NULL,       // hwndOwner
                pwszText,
                pwszTitle,
                MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING |
                    MB_TOPMOST | MB_SERVICE_NOTIFICATION
                );
        LocalFree((HLOCAL) pwszTitle);
        LocalFree((HLOCAL) pwszText);
        if (IDYES != id)
            goto AccessDenied;

        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Called from the services process to process a protected certificate 
//  function.
//
//  Returns the error status, ie, not returned in LastError.
//--------------------------------------------------------------------------
DWORD
WINAPI
I_CertSrvProtectFunction(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    )
{
    DWORD dwErr;
    BOOL fResult;
    HKEY hKeyCU = NULL;
    LONG err;
    RPC_STATUS RpcStatus;

#ifdef TESTING_NO_PROT_ROOT_RPC
    // For testing, called from the client's process
    err = RegOpenHKCU(&hKeyCU);
    if (ERROR_SUCCESS != err)
        goto RegOpenHKCUError;
#else
    if (NULL == hRpc)
        goto InvalidArg;

    // Get the client's HKCU.
    if (ERROR_SUCCESS != (RpcStatus = RpcImpersonateClient(hRpc)))
        goto ImpersonateClientError;
    err = RegOpenHKCUEx(&hKeyCU, REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG);
    RpcRevertToSelf();
    if (ERROR_SUCCESS != err)
        goto RegOpenHKCUError;
#endif

    switch (dwFuncId) {
        case CERT_PROT_INIT_ROOTS_FUNC_ID:
            fResult = SrvInitProtectedRoots(hKeyCU);
            break;
        case CERT_PROT_PURGE_LM_ROOTS_FUNC_ID:
            fResult = SrvPurgeLocalMachineProtectedRoots(hKeyCU);
            break;
        case CERT_PROT_ADD_ROOT_FUNC_ID:
            if (NULL == pbIn || 0 == cbIn)
                goto InvalidArg;
            if (IsBadReadPtr(pbIn, cbIn))
                goto InvalidData;
            fResult = SrvAddProtectedRoot(hKeyCU, pbIn, cbIn);
            break;
        case CERT_PROT_DELETE_ROOT_FUNC_ID:
            if (NULL == pbIn || PROT_ROOT_HASH_LEN != cbIn)
                goto InvalidArg;
            if (IsBadReadPtr(pbIn, cbIn))
                goto InvalidData;
            fResult = SrvDeleteProtectedRoot(hKeyCU, pbIn);
            break;
        case CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID:
            fResult = SrvDeleteUnknownProtectedRoots(hKeyCU);
            break;
        default:
            goto InvalidArg;
    }

    if (!fResult)
        goto ErrorReturn;
    dwErr = ERROR_SUCCESS;
CommonReturn:
    if (hKeyCU)
        RegCloseHKCU(hKeyCU);
    return dwErr;
ErrorReturn:
    dwErr = GetLastError();
    if (0 == dwErr)
        dwErr = (DWORD) E_UNEXPECTED;
    goto CommonReturn;

SET_ERROR(InvalidData, ERROR_INVALID_DATA)
SET_ERROR(InvalidArg, E_INVALIDARG)
#ifdef TESTING_NO_PROT_ROOT_RPC
#else
SET_ERROR_VAR(ImpersonateClientError, RpcStatus)
#endif
SET_ERROR_VAR(RegOpenHKCUError, err)
}

//+-------------------------------------------------------------------------
// If a cert has a 0 NotAfter and a KeyProvInfo property, convert its
// NotAfter time to +50 years in the future and resign.
//
// Earlier versions of Outlook generated a self signed CTL signer certificate
// with NotAfter set to 0. The UI displayed this as the year 1/1/1601. This
// fix regenerates the same certificate with the NotAfter set to
// NotBefore +50 years
//
// If the certificate is updated, then, the input certificate context is
// deleted from the store. However before deleting, the input certificate
// context is duplicated to preserve its reference count upon input.
//--------------------------------------------------------------------------
STATIC void UpdateZeroNotAfterRoot(
    IN HCERTSTORE hStore,
    IN PCCERT_CONTEXT pCert
    )
{
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    DWORD cbKeyProvInfo;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo;          // _alloca'ed
    HCRYPTPROV hCryptProv = 0;
    CERT_INFO CertInfo;
    SYSTEMTIME st;
    BYTE *pbCertEncoded;                        // _alloca'ed
    DWORD cbCertEncoded;
    PCCERT_CONTEXT pUpdateCert = NULL;

    // Check for 0 NotAfter
    if (pCertInfo->NotAfter.dwLowDateTime ||
            pCertInfo->NotAfter.dwHighDateTime)
        goto CommonReturn;

    // See if it has a KeyProvInfo property
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                               // pbData
            &cbKeyProvInfo))
        goto CommonReturn;

    __try {
        pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) _alloca(cbKeyProvInfo);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbKeyProvInfo))
        goto GetKeyProvInfoError;

    if (!CryptAcquireCertificatePrivateKey(
            pCert,
            CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,                               // pvReserved
            &hCryptProv,
            NULL,                               // pdwKeySpec
            NULL                                // pfCallerFreeProv
            ))
        goto AcquirePrivateKeyError;

    // Update NotAfter to +50 years
    CertInfo = *pCertInfo;
    FileTimeToSystemTime(&CertInfo.NotBefore, &st);
    st.wYear += 50;
    if (!SystemTimeToFileTime(&st, &CertInfo.NotAfter)) {
        // This may fail on the last day of February.
        st.wDay = 1;
        if (!SystemTimeToFileTime(&st, &CertInfo.NotAfter))
            goto SystemTimeToFileTimeError;
    }

    if (!CryptSignAndEncodeCertificate(
            hCryptProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &CertInfo,
            &CertInfo.SignatureAlgorithm,
            NULL,                           // pvHashAuxInfo
            NULL,                           // pbEncoded
            &cbCertEncoded
            ))
        goto SignAndEncodeCertificateError;

    __try {
        pbCertEncoded = (BYTE *) _alloca(cbCertEncoded);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }

    if (!CryptSignAndEncodeCertificate(
            hCryptProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &CertInfo,
            &CertInfo.SignatureAlgorithm,
            NULL,                           // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            ))
        goto SignAndEncodeCertificateError;

    if (NULL == (pUpdateCert = CertCreateCertificateContext(
            X509_ASN_ENCODING,
            pbCertEncoded,
            cbCertEncoded
            )))
        goto CreateCertificateContextError;

    if (!CertSetCertificateContextProperty(
            pUpdateCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            0,                              // dwFlags
            pKeyProvInfo
            ))
        goto SetKeyProvInfoError;

    if (!CertAddCertificateContextToStore(
            hStore,
            pUpdateCert,
            CERT_STORE_ADD_ALWAYS,
            NULL                        // ppStoreContext
            ))
        goto AddCertificateContextError;

    CertDuplicateCertificateContext(pCert);
    CertDeleteCertificateFromStore(pCert);

CommonReturn:
    if (pUpdateCert)
        CertFreeCertificateContext(pUpdateCert);
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
    return;

ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetKeyProvInfoError)
TRACE_ERROR(AcquirePrivateKeyError)
TRACE_ERROR(SystemTimeToFileTimeError)
TRACE_ERROR(SignAndEncodeCertificateError)
TRACE_ERROR(CreateCertificateContextError)
TRACE_ERROR(SetKeyProvInfoError)
TRACE_ERROR(AddCertificateContextError)
}

void
WINAPI
UpdateZeroNotAfterRoots()
{
    HKEY hKeyCU;

    if (!FIsWinNT5())
        return;

    if (ERROR_SUCCESS == RegOpenHKCU(&hKeyCU)) {
        HKEY hKeyProtRoot;

        if (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, KEY_READ))
            // Protected root subkey exists
            ILS_CloseRegistryKey(hKeyProtRoot);
        else {
            HCERTSTORE hStore;

            if (hStore = OpenUnprotectedRootStore(hKeyCU,
                    CERT_STORE_OPEN_EXISTING_FLAG)) {
                PCCERT_CONTEXT pCert = NULL;
                while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
                    UpdateZeroNotAfterRoot(hStore, pCert);
                }

                CertCloseStore(hStore, 0);
            }
        }

        RegCloseHKCU(hKeyCU);
    }
}

#ifdef TESTING_NO_PROT_ROOT_RPC
// For testing: the server stuff resides in the client process
BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    )
{
    DWORD dwErr;
    dwErr = I_CertSrvProtectFunction(
        NULL,           // hRpc
        dwFuncId,
        dwFlags,
        pwszIn,
        pbIn,
        cbIn,
        NULL,           // ppbOut
        NULL,           // pcbOut
        NULL,           // pfnAlloc
        NULL            // pfnFree
        );

    if (ERROR_SUCCESS == dwErr)
        return TRUE;
    else {
        SetLastError(dwErr);
        return FALSE;
    }
}
#else

BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    )
{

    // The following is done in the user process to allow access
    // to the user's private key to be used to resign a
    // zero NotAfter cert.
    UpdateZeroNotAfterRoots();

    return I_CertCltProtectFunction(
        dwFuncId,
        dwFlags,
        pwszIn,
        pbIn,
        cbIn,
        ppbOut,
        pcbOut
        );
}
#endif



//+=========================================================================
//  Protected root functions called from the client process in logstor.cpp.
//==========================================================================
    
//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag wasn't set to disable the opening
//  of the CurrentUser's "root\.Default" physical store.
//--------------------------------------------------------------------------
BOOL
IPR_IsCurrentUserRootsAllowed()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return 0 == (dwProtRootFlags & CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG);
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag was set to only allow the
//  opening of the CurrentUser's "root\.LocalMachineGroupPolicy" physical store.
//--------------------------------------------------------------------------
BOOL
IPR_OnlyLocalMachineGroupPolicyRootsAllowed()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return (dwProtRootFlags & CERT_PROT_ROOT_ONLY_LM_GPT_FLAG);
}

//+-------------------------------------------------------------------------
//  Gets the protected root information containing the list of protected
//  root stores.
//
//  If protected root store isn't supported, returns TRUE with
//  *ppProtRootInfo set to NULL.
//--------------------------------------------------------------------------
BOOL CltGetProtectedRootInfo(
    OUT PPROT_ROOT_INFO *ppInfo
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKeyCU = NULL;

    *ppInfo = NULL;

#ifndef TESTING_NO_PROT_ROOT_RPC
    if (!FIsWinNT5())
        // No protected roots on Win9x or NT4.0
        return TRUE;
#endif

    if (ERROR_SUCCESS != (err = RegOpenHKCU(&hKeyCU)))
        goto RegOpenHKCUError;

    if (GetProtectedRootInfo(
            hKeyCU,
            KEY_READ,
            NULL,                   // phKeyProtRoot
            ppInfo
            )) goto SuccessReturn;

    if (!I_CertProtectFunction(
            CERT_PROT_INIT_ROOTS_FUNC_ID,
            0,                              // dwFlags
            NULL,                           // pwszIn
            NULL,                           // pbIn
            0,                              // cbIn
            NULL,                           // ppbOut
            NULL                            // pcbOut
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_CALL_NOT_IMPLEMENTED == dwErr || RPC_S_UNKNOWN_IF == dwErr)
            goto SuccessReturn;
        goto ProtFuncError;
    }

    if (!GetProtectedRootInfo(
            hKeyCU,
            KEY_READ,
            NULL,                   // phKeyProtRoot
            ppInfo
            ))
        goto GetProtectedRootInfoError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (hKeyCU)
        RegCloseHKCU(hKeyCU);
    return fResult;
ErrorReturn:
    *ppInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenHKCUError, err)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(ProtFuncError)
}
    
//+-------------------------------------------------------------------------
//  Initializes the protected list of roots.
//--------------------------------------------------------------------------
void
IPR_InitProtectedRootInfo()
{
    HKEY hKeyCU;

#ifndef TESTING_NO_PROT_ROOT_RPC
    if (!FIsWinNT5())
        // No protected roots on Win9x or NT4.0
        return;
#endif

    if (ERROR_SUCCESS == RegOpenHKCU(&hKeyCU)) {
        HKEY hKeyProtRoot;

        if (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, KEY_READ))
            // Protected root subkey exists
            ILS_CloseRegistryKey(hKeyProtRoot);
        else {
            I_CertProtectFunction(
                CERT_PROT_INIT_ROOTS_FUNC_ID,
                0,                              // dwFlags
                NULL,                           // pwszIn
                NULL,                           // pbIn
                0,                              // cbIn
                NULL,                           // ppbOut
                NULL                            // pcbOut
                );
        }

        RegCloseHKCU(hKeyCU);
    }
}

//+-------------------------------------------------------------------------
//  Delete certificates not in the protected store list.
//--------------------------------------------------------------------------
BOOL
IPR_DeleteUnprotectedRootsFromStore(
    IN HCERTSTORE hStore,
    OUT BOOL *pfProtected
    )
{
    PPROT_ROOT_INFO pInfo;
    PCCERT_CONTEXT pCert;

    if (!CltGetProtectedRootInfo(&pInfo)) {
        *pfProtected = FALSE;
        // Delete all certificates from the store's cache.
        while (pCert = CertEnumCertificatesInStore(hStore, NULL))
            CertDeleteCertificateFromStore(pCert);
        return FALSE;
    }

    if (NULL == pInfo)
        // Root store isn't protected.
        *pfProtected = FALSE;
    else {
        *pfProtected = TRUE;
        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            BYTE rgbHash[PROT_ROOT_HASH_LEN];
            if (!GetVerifiedCertHashProperty(pCert, rgbHash) ||
                    !FindProtectedRoot(pInfo, rgbHash)) {
                PCCERT_CONTEXT pDeleteCert =
                    CertDuplicateCertificateContext(pCert);
                CertDeleteCertificateFromStore(pDeleteCert);
            }
        }

        PkiFree(pInfo);
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  The add/delete root message box.
//
//  If protected roots aren't supported, called from the client process.
//  Otherwise, called from the services process.
//--------------------------------------------------------------------------
int
IPR_ProtectedRootMessageBox(
    IN PCCERT_CONTEXT pCert,
    IN UINT wActionID,
    IN UINT uFlags
    )
{
    int id;

    WCHAR wszTmp[256];
    LPWSTR pwszTmp;       // _alloca'ed
    DWORD cchTmp;

// Includes the title
#define MAX_ROOT_BOX_ITEMS 10
    struct {
        LPWSTR  pwszItem;
        DWORD   cchItem;
    } rgItem[MAX_ROOT_BOX_ITEMS];
    DWORD cItem = 0;
    LPWSTR pwszText = NULL;
    DWORD cchText = 0;

    // ACTION: add or delete
    FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
        wActionID);
    cchText += rgItem[cItem].cchItem;
    cItem++;

    // SUBJECT
    cchTmp = CertNameToStrW(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            NULL,                   // pwsz
            0);                     // cwsz
    __try {
        pwszTmp = (LPWSTR) _alloca(cchTmp * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        pwszTmp = NULL;
    }
    if (NULL == pwszTmp) {
        assert(0);
        pwszTmp = L"";
    } else
        CertNameToStrW(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            pwszTmp,
            cchTmp);
    FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
        IDS_ROOT_MSG_BOX_SUBJECT, pwszTmp);
    cchText += rgItem[cItem].cchItem;
    cItem++;

    // ISSUER. May be self issued
    if (CertCompareCertificateName(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            &pCert->pCertInfo->Issuer
            ))
        // Self issued
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            IDS_ROOT_MSG_BOX_SELF_ISSUED);
    else {
        // Format certificate's issuer
        cchTmp = CertNameToStrW(
                pCert->dwCertEncodingType,
                &pCert->pCertInfo->Issuer,
                CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                NULL,                   // pwsz
                0);                     // cwsz
        __try {
            pwszTmp = (LPWSTR) _alloca(cchTmp * sizeof(WCHAR));
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            pwszTmp = NULL;
        }
        if (NULL == pwszTmp) {
            assert(0);
            pwszTmp = L"";
        } else
            CertNameToStrW(
                pCert->dwCertEncodingType,
                &pCert->pCertInfo->Issuer,
                CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                pwszTmp,
                cchTmp);
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            IDS_ROOT_MSG_BOX_ISSUER, pwszTmp);
    }
    cchText += rgItem[cItem].cchItem;
    cItem++;

    // TIME VALIDITY
    {
        FILETIME ftLocal;
        SYSTEMTIME stLocal;
        WCHAR wszNotBefore[128];
        WCHAR wszNotAfter[128];
        wszNotBefore[0] = '\0';
        wszNotAfter[0] = '\0';

        FileTimeToLocalFileTime(&pCert->pCertInfo->NotBefore, &ftLocal);
        FileTimeToSystemTime(&ftLocal, &stLocal);
        GetDateFormatU(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stLocal,
            NULL, wszNotBefore, 128);
        FileTimeToLocalFileTime(&pCert->pCertInfo->NotAfter, &ftLocal);
        FileTimeToSystemTime(&ftLocal, &stLocal);
        GetDateFormatU(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stLocal,
            NULL, wszNotAfter, 128);

        FormatMsgBoxItem(&rgItem[cItem].pwszItem,
            &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_TIME_VALIDITY,
            wszNotBefore, wszNotAfter);
        cchText += rgItem[cItem].cchItem;
        cItem++;
    }

    // SERIAL NUMBER
    if (pCert->pCertInfo->SerialNumber.cbData) {
        DWORD cb = pCert->pCertInfo->SerialNumber.cbData;
        BYTE *pb;
        if (pb = PkiAsn1AllocAndReverseBytes(
                pCert->pCertInfo->SerialNumber.pbData, cb)) {
            LPWSTR pwsz;
            if (pwsz = (LPWSTR) PkiNonzeroAlloc(
                    (cb*2 + cb/4 + 1) * sizeof(WCHAR))) {
                FormatMsgBoxMultiBytes(cb, pb, pwsz);
                FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                    &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_SERIAL_NUMBER,
                    pwsz);
                cchText += rgItem[cItem].cchItem;
                cItem++;
                PkiFree(pwsz);
            }
            PkiAsn1Free(pb);
        }
    }

    // THUMBPRINTS: sha1 and md5
    {
        BYTE    rgbHash[MAX_HASH_LEN];
        DWORD   cbHash = MAX_HASH_LEN;

        // get the sha1 thumbprint
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_SHA1_HASH_PROP_ID,
                rgbHash,
                &cbHash)) {
            FormatMsgBoxMultiBytes(cbHash, rgbHash, wszTmp);
            FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_SHA1_THUMBPRINT,
                wszTmp);
            cchText += rgItem[cItem].cchItem;
            cItem++;
        }

        // get the md5 thumbprint
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_MD5_HASH_PROP_ID,
                rgbHash,
                &cbHash)) {
            FormatMsgBoxMultiBytes(cbHash, rgbHash, wszTmp);
            FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_MD5_THUMBPRINT,
                wszTmp);
            cchText += rgItem[cItem].cchItem;
            cItem++;
        }
    }

    // Concatenate all the items into a single allocated string
    assert(cchText);
    if (NULL != (pwszText = (LPWSTR) PkiNonzeroAlloc(
            (cchText + 1) * sizeof(WCHAR)))) {
        LPWSTR pwsz = pwszText;
        DWORD ItemIdx;
        for (ItemIdx = 0; ItemIdx < cItem; ItemIdx++) {
            DWORD cch = rgItem[ItemIdx].cchItem;
            if (cch) {
                assert(rgItem[ItemIdx].pwszItem);
                memcpy(pwsz, rgItem[ItemIdx].pwszItem, cch * sizeof(WCHAR));
                pwsz += cch;
            }
        }
        assert (pwsz == pwszText + cchText);
        *pwsz = '\0';

        // TITLE
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            IDS_ROOT_MSG_BOX_TITLE);

        id = MessageBoxU(
                NULL,       // hwndOwner
                pwszText,
                rgItem[cItem].pwszItem,
                MB_TOPMOST | MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING | uFlags
                );

        cItem++;
        PkiFree(pwszText);
    } else
        id = IDNO;


    // Free up all the individually allocated items
    while (cItem--) {
        if (rgItem[cItem].pwszItem)
            LocalFree((HLOCAL) rgItem[cItem].pwszItem);
    }

    return id;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\sca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       sca.cpp
//
//  Contents:   Simplified Cryptographic APIs (SCA)
//
//              This implementation layers upon the CryptMsg and CertStore
//              APIs.
//
//  Functions:
//              CryptSignMessage
//              CryptVerifyMessageSignature
//              CryptVerifyDetachedMessageSignature
//              CryptGetMessageSignerCount
//              CryptGetMessageCertificates
//              CryptDecodeMessage
//              CryptEncryptMessage
//              CryptDecryptMessage
//              CryptSignAndEncryptMessage
//              CryptDecryptAndVerifyMessageSignature
//              CryptHashMessage
//              CryptVerifyMessageHash
//              CryptVerifyDetachedMessageHash
//              CryptSignMessageWithKey
//              CryptVerifyMessageSignatureWithKey
//
//  History:    14-Feb-96   philh   created
//              21-Feb-96   phil    redid to reflect changes made to sca.h
//              19-Jan-97   philh   removed SET stuff
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// #define ENABLE_SCA_STREAM_TEST              1
#define SCA_STREAM_ENABLE_FLAG              0x80000000
#define SCA_INDEFINITE_STREAM_FLAG          0x40000000

static const CRYPT_OBJID_TABLE MsgTypeObjIdTable[] = {
    CMSG_DATA,                  szOID_RSA_data              ,
    CMSG_SIGNED,                szOID_RSA_signedData        ,
    CMSG_ENVELOPED,             szOID_RSA_envelopedData     ,
    CMSG_SIGNED_AND_ENVELOPED,  szOID_RSA_signEnvData       ,
    CMSG_HASHED,                szOID_RSA_digestedData      ,
    CMSG_ENCRYPTED,             szOID_RSA_encryptedData
};
#define MSG_TYPE_OBJID_CNT (sizeof(MsgTypeObjIdTable)/sizeof(MsgTypeObjIdTable[0]))


//+-------------------------------------------------------------------------
//  Convert the MsgType to the ASN.1 Object Identifier string
//
//  Returns NULL if there isn't an ObjId corresponding to the MsgType.
//--------------------------------------------------------------------------
static LPCSTR MsgTypeToOID(
    IN DWORD dwMsgType
    )
{

    int i;
    for (i = 0; i < MSG_TYPE_OBJID_CNT; i++)
        if (MsgTypeObjIdTable[i].dwAlgId == dwMsgType)
            return MsgTypeObjIdTable[i].pszObjId;
    return NULL;
}

//+-------------------------------------------------------------------------
//  Convert the ASN.1 Object Identifier string to the MsgType
//
//  Returns 0 if there isn't a MsgType corresponding to the ObjId.
//--------------------------------------------------------------------------
static DWORD OIDToMsgType(
    IN LPCSTR pszObjId
    )
{
    int i;
    for (i = 0; i < MSG_TYPE_OBJID_CNT; i++)
        if (_stricmp(pszObjId, MsgTypeObjIdTable[i].pszObjId) == 0)
            return MsgTypeObjIdTable[i].dwAlgId;
    return 0;
}

//+-------------------------------------------------------------------------
//  SCA allocation and free routines
//--------------------------------------------------------------------------
static void *SCAAlloc(
    IN size_t cbBytes
    );
static void SCAFree(
    IN void *pv
    );

//+-------------------------------------------------------------------------
//  Null implementation of the get signer certificate
//--------------------------------------------------------------------------
static PCCERT_CONTEXT WINAPI NullGetSignerCertificate(
    IN void *pvGetArg,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pSignerId,
    IN HCERTSTORE hMsgCertStore
    );

//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------
static PCMSG_SIGNER_ENCODE_INFO InitSignerEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara
    );
static void FreeSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO pSigner
    );
static BOOL InitSignedCertAndCrl(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCERT_BLOB *ppCertEncoded,
    OUT PCRL_BLOB *ppCrlEncoded
    );
static void FreeSignedCertAndCrl(
    IN PCERT_BLOB pCertEncoded,
    IN PCRL_BLOB pCrlEncoded
    );

static BOOL InitSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );
static void FreeSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );


#ifdef CMS_PKCS7
// Returned array of CMSG_RECIPIENT_ENCODE_INFOs needs to be SCAFree'd
static PCMSG_RECIPIENT_ENCODE_INFO InitCmsRecipientEncodeInfo(
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN DWORD dwFlags
    );
#else
// Returned array of PCERT_INFOs needs to be SCAFree'd
static PCERT_INFO *InitRecipientEncodeInfo(
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[]
    );
#endif  // CMS_PKCS7

static BOOL InitEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );
static void FreeEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );

//+-------------------------------------------------------------------------
//  Encodes the message.
//--------------------------------------------------------------------------
static BOOL EncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    );

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//--------------------------------------------------------------------------
static BOOL DecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

#ifdef ENABLE_SCA_STREAM_TEST
//+-------------------------------------------------------------------------
//  Encodes the message using streaming.
//--------------------------------------------------------------------------
static BOOL StreamEncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    );

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  Uses streaming.
//--------------------------------------------------------------------------
static BOOL StreamDecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );
#endif

//+-------------------------------------------------------------------------
//  Decodes the HASHED message type
//--------------------------------------------------------------------------
static BOOL DecodeHashMsg(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeHashed,
    IN OPTIONAL const BYTE *rgpbToBeHashed[],
    IN OPTIONAL DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Get certificate for and verify the message's signer.
//--------------------------------------------------------------------------
static BOOL GetSignerCertAndVerify(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );
//+-------------------------------------------------------------------------
// Get a certificate with a key provider property for one of the message's
// recipients and use to decrypt the message.
//--------------------------------------------------------------------------
static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    );
//+-------------------------------------------------------------------------
// Allocate and get message parameter
//--------------------------------------------------------------------------
static void * AllocAndMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    );

//+-------------------------------------------------------------------------
//  Sign the message.
//
//  If fDetachedSignature is TRUE, the "to be signed" content isn't included
//  in the encoded signed blob.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignMessage(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN BOOL fDetachedSignature,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;

    fResult = InitSignedMsgEncodeInfo(
        pSignPara,
        &SignedMsgEncodeInfo
        );
    if (fResult) {
        BOOL fBareContent;
        DWORD dwInnerContentType;
        DWORD dwFlags = 0;

        if (fDetachedSignature)
            dwFlags |= CMSG_DETACHED_FLAG;

        if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
                dwInnerContentType)) {
            fBareContent =
                pSignPara->dwFlags & CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG;
            dwInnerContentType =
                pSignPara->dwInnerContentType;
#ifdef CMS_PKCS7
            if (pSignPara->dwFlags &
                    CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG)
                dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7
        } else {
            fBareContent = FALSE;
            dwInnerContentType = 0;
        }
#ifdef ENABLE_SCA_STREAM_TEST
        if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
                    dwFlags) &&
                (pSignPara->dwFlags & SCA_STREAM_ENABLE_FLAG)) {
            dwFlags |= pSignPara->dwFlags & SCA_INDEFINITE_STREAM_FLAG;

            fResult = StreamEncodeMsg(
                pSignPara->dwMsgEncodingType,
                dwFlags,
                CMSG_SIGNED,
                &SignedMsgEncodeInfo,
                cToBeSigned,
                rgpbToBeSigned,
                rgcbToBeSigned,
                fBareContent,
                dwInnerContentType,
                pbSignedBlob,
                pcbSignedBlob
                );
        } else
#endif
        fResult = EncodeMsg(
            pSignPara->dwMsgEncodingType,
            dwFlags,
            CMSG_SIGNED,
            &SignedMsgEncodeInfo,
            cToBeSigned,
            rgpbToBeSigned,
            rgcbToBeSigned,
            fBareContent,
            dwInnerContentType,
            pbSignedBlob,
            pcbSignedBlob
            );
        FreeSignedMsgEncodeInfo(pSignPara, &SignedMsgEncodeInfo);
    } else
        *pcbSignedBlob = 0;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify a signed message.
//
//  For *pcbDecoded == 0 on input, the signer isn't verified.
//
//  A message might have more than one signer. Set dwSignerIndex to iterate
//  through all the signers. dwSignerIndex == 0 selects the first signer.
//
//  pVerifyPara's pfnGetSignerCertificate is called to get the signer's
//  certificate.
//
//  For a verified signer and message, *ppSignerCert is updated
//  with the CertContext of the signer. It must be freed by calling
//  CertFreeCertificateContext. Otherwise, *ppSignerCert is set to NULL.
//  For *pbcbDecoded == 0 on input, *ppSignerCert is always set to
//  NULL.
//
//  ppSignerCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext of the signer.
//
//  pcbDecoded can be NULL, indicating the caller isn't interested in getting
//  the decoded content. Furthermore, if the message doesn't contain any
//  content or signers, then, pcbDecoded must be set to NULL, to allow the
//  pVerifyPara->pfnGetSignerCertificate to be called. Normally, this would be
//  the case when the signed message contains only certficates and CRLs.
//  If pcbDecoded is NULL and the message doesn't have the indicated signer,
//  pfnGetSignerCertificate is called with pSignerId set to NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageSignature(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbSignedBlob,
            cbSignedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecoded,
            pcbDecoded,
            NULL,               // ppXchgCert
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        CMSG_SIGNED_FLAG,
        NULL,               // pDecryptPara
        pVerifyPara,
        dwSignerIndex,
        pbSignedBlob,
        cbSignedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecoded,
        pcbDecoded,
        NULL,               // ppXchgCert
        ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Verify a signed message containing detached signature(s).
//  The "to be signed" content is passed in separately. No
//  decoded output. Otherwise, identical to CryptVerifyMessageSignature.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyDetachedMessageSignature(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbDetachedSignBlob,
    IN DWORD cbDetachedSignBlob,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbDetachedSignBlob,
            cbDetachedSignBlob,
            cToBeSigned,
            rgpbToBeSigned,
            rgcbToBeSigned,
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            NULL,               // pbDecoded
            NULL,               // pcbDecoded
            NULL,               // ppXchgCert
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        CMSG_SIGNED_FLAG,
        NULL,               // pDecryptPara
        pVerifyPara,
        dwSignerIndex,
        pbDetachedSignBlob,
        cbDetachedSignBlob,
        cToBeSigned,
        rgpbToBeSigned,
        rgcbToBeSigned,
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        NULL,               // pbDecoded
        NULL,               // pcbDecoded
        NULL,               // ppXchgCert
        ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Returns the count of signers in the signed message. For no signers, returns
//  0. For an error returns -1 with LastError updated accordingly.
//--------------------------------------------------------------------------
LONG
WINAPI
CryptGetMessageSignerCount(
    IN DWORD dwMsgEncodingType,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob
    )
{
    HCRYPTMSG hMsg = NULL;
    LONG lSignerCount;
    DWORD cbData;

    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            0,                          // hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto ErrorReturn;
    if (!CryptMsgUpdate(
            hMsg,
            pbSignedBlob,
            cbSignedBlob,
            TRUE                    // fFinal
            )) goto ErrorReturn;

    lSignerCount = 0;
    cbData = sizeof(lSignerCount);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_SIGNER_COUNT_PARAM,
            0,                      // dwIndex
            &lSignerCount,
            &cbData
            )) goto ErrorReturn;

    goto CommonReturn;

ErrorReturn:
    lSignerCount = -1;
CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return lSignerCount;
}

//+-------------------------------------------------------------------------
//  Returns the cert store containing the message's certs and CRLs.
//  For an error, returns NULL with LastError updated.
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CryptGetMessageCertificates(
    IN DWORD dwMsgAndCertEncodingType,
    IN HCRYPTPROV hCryptProv,           // passed to CertOpenStore
    IN DWORD dwFlags,                   // passed to CertOpenStore
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob
    )
{
    CRYPT_DATA_BLOB SignedBlob;
    SignedBlob.pbData = (BYTE *) pbSignedBlob;
    SignedBlob.cbData = cbSignedBlob;

    return CertOpenStore(
        CERT_STORE_PROV_PKCS7,
        dwMsgAndCertEncodingType,
        hCryptProv,
        dwFlags,
        (const void *) &SignedBlob
        );
}

//+-------------------------------------------------------------------------
//  Encrypts the message for the recipient(s).
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEncryptMessage(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE *pbEncryptedBlob,
    IN OUT DWORD *pcbEncryptedBlob
    )
{
    BOOL fResult;
    CMSG_ENVELOPED_ENCODE_INFO EnvelopedMsgEncodeInfo;

    fResult = InitEnvelopedMsgEncodeInfo(
        pEncryptPara,
        cRecipientCert,
        rgpRecipientCert,
        &EnvelopedMsgEncodeInfo
        );
    if (fResult) {
        BOOL fBareContent;
        DWORD dwInnerContentType;
        DWORD dwFlags = 0;

        if (pEncryptPara->cbSize >= sizeof(CRYPT_ENCRYPT_MESSAGE_PARA)) {
            fBareContent =
                pEncryptPara->dwFlags & CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG;
            dwInnerContentType =
                pEncryptPara->dwInnerContentType;
#ifdef CMS_PKCS7
            if (pEncryptPara->dwFlags &
                    CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG)
                dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7
        } else {
            fBareContent = FALSE;
            dwInnerContentType = 0;
        }

#ifdef ENABLE_SCA_STREAM_TEST
        if (pEncryptPara->cbSize >= STRUCT_CBSIZE(CRYPT_ENCRYPT_MESSAGE_PARA,
                    dwFlags) &&
                (pEncryptPara->dwFlags & SCA_STREAM_ENABLE_FLAG)) {
            dwFlags |= pEncryptPara->dwFlags & SCA_INDEFINITE_STREAM_FLAG;

            fResult = StreamEncodeMsg(
                pEncryptPara->dwMsgEncodingType,
                dwFlags,
                CMSG_ENVELOPED,
                &EnvelopedMsgEncodeInfo,
                1,                              // cToBeEncrypted
                &pbToBeEncrypted,
                &cbToBeEncrypted,
                fBareContent,
                dwInnerContentType,
                pbEncryptedBlob,
                pcbEncryptedBlob
                );
        } else
#endif
        fResult = EncodeMsg(
            pEncryptPara->dwMsgEncodingType,
            dwFlags,
            CMSG_ENVELOPED,
            &EnvelopedMsgEncodeInfo,
            1,                              // cToBeEncrypted
            &pbToBeEncrypted,
            &cbToBeEncrypted,
            fBareContent,
            dwInnerContentType,
            pbEncryptedBlob,
            pcbEncryptedBlob
            );
        FreeEnvelopedMsgEncodeInfo(pEncryptPara, &EnvelopedMsgEncodeInfo);
    } else
        *pcbEncryptedBlob = 0;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decrypts the message.
//
//  For *pcbDecrypted == 0 on input, the message isn't decrypted.
//
//  For a successfully decrypted message, *ppXchgCert is updated
//  with the CertContext used to decrypt. It must be freed by calling
//  CertFreeCertificateContext. Otherwise, *ppXchgCert is set to NULL.
//  For *pbcbDecrypted == 0 on input, *ppXchgCert is always set to
//  NULL.
//
//  ppXchgCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext used to decrypt.
//
//  pcbDecrypted can be NULL, indicating the caller isn't interested in
//  getting the decrypted content. However, when pcbDecrypted is NULL,
//  the message is still decrypted.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecryptMessage(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecrypted,
            pcbDecrypted,
            ppXchgCert,
            NULL                // ppSignerCert
            );
    else

#endif
    return DecodeMsg(
        CMSG_ENVELOPED_FLAG,
        pDecryptPara,
        NULL,               // pVerifyPara
        0,                  // dwSignerIndex
        pbEncryptedBlob,
        cbEncryptedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecrypted,
        pcbDecrypted,
        ppXchgCert,
        NULL                // ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Sign the message and encrypt for the recipient(s)
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignAndEncryptMessage(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeSignedAndEncrypted,
    IN DWORD cbToBeSignedAndEncrypted,
    OUT BYTE *pbSignedAndEncryptedBlob,
    IN OUT DWORD *pcbSignedAndEncryptedBlob
    )
{
#if 1
    BOOL fResult;
    DWORD cbSigned;
    DWORD cbSignedDelta = 0;
    BYTE *pbSigned = NULL;

    if (pbSignedAndEncryptedBlob == NULL)
        *pcbSignedAndEncryptedBlob = 0;

    cbSigned = 0;
    CryptSignMessage(
            pSignPara,
            FALSE,          // fDetachedSignature
            1,              // cToBeSigned
            &pbToBeSignedAndEncrypted,
            &cbToBeSignedAndEncrypted,
            NULL,           // pbSignedBlob
            &cbSigned
            );
    if (cbSigned == 0) goto ErrorReturn;
    if (*pcbSignedAndEncryptedBlob) {
        DWORD cbSignedMax;
        pbSigned = (BYTE *) SCAAlloc(cbSigned);
        if (pbSigned == NULL) goto ErrorReturn;
        cbSignedMax = cbSigned;
        if (!CryptSignMessage(
                pSignPara,
                FALSE,          // fDetachedSignature
                1,              // cToBeSigned
                &pbToBeSignedAndEncrypted,
                &cbToBeSignedAndEncrypted,
                pbSigned,
                &cbSigned
                )) goto ErrorReturn;

        if (cbSignedMax > cbSigned)
            // For DSS, the signature length varies since it consists of
            // a sequence of unsigned integers.
            cbSignedDelta = cbSignedMax - cbSigned;
    }

    fResult = CryptEncryptMessage(
            pEncryptPara,
            cRecipientCert,
            rgpRecipientCert,
            pbSigned,
            cbSigned,
            pbSignedAndEncryptedBlob,
            pcbSignedAndEncryptedBlob
            );
    if (!fResult && 0 != *pcbSignedAndEncryptedBlob)
        // Adjust if necessary for DSS signature length
        *pcbSignedAndEncryptedBlob += cbSignedDelta;
    goto CommonReturn;

ErrorReturn:
    *pcbSignedAndEncryptedBlob = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSigned)
        SCAFree(pbSigned);
    return fResult;

#else
    BOOL fResult;
    CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO SignedAndEnvelopedMsgEncodeInfo;

    SignedAndEnvelopedMsgEncodeInfo.cbSize =
        sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO);
    fResult = InitSignedMsgEncodeInfo(
        pSignPara,
        &SignedAndEnvelopedMsgEncodeInfo.SignedInfo
        );
    if (fResult) {
        fResult = InitEnvelopedMsgEncodeInfo(
            pEncryptPara,
            cRecipientCert,
            rgpRecipientCert,
            &SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo
            );
        if (fResult) {
            fResult = EncodeMsg(
                pSignPara->dwMsgEncodingType,
                CMSG_SIGNED_AND_ENVELOPED,
                &SignedAndEnvelopedMsgEncodeInfo,
                pbToBeSignedAndEncrypted,
                cbToBeSignedAndEncrypted,
                FALSE,                      // fBareContent
                0,                          // dwInnerContentType
                pbSignedAndEncryptedBlob,
                pcbSignedAndEncryptedBlob
                );
            FreeEnvelopedMsgEncodeInfo(pEncryptPara,
                &SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo);
        }
        FreeSignedMsgEncodeInfo(pSignPara,
            &SignedAndEnvelopedMsgEncodeInfo.SignedInfo);
    }
    return fResult;
#endif
}

//+-------------------------------------------------------------------------
//  Decrypts the message and verifies the signer.
//
//  For *pcbDecrypted == 0 on input, the message isn't decrypted and the
//  signer isn't verified.
//
//  A message might have more than one signer. Set dwSignerIndex to iterate
//  through all the signers. dwSignerIndex == 0 selects the first signer.
//
//  The hVerify's GetSignerCertificate is called to verify the signer's
//  certificate.
//
//  For a successfully decrypted and verified message, *ppXchgCert and
//  *ppSignerCert are updated. They must be freed by calling
//  CertFreeCertificateContext. Otherwise, they are set to NULL.
//  For *pbcbDecrypted == 0 on input, both are always set to NULL.
//
//  ppXchgCert and/or ppSignerCert can be NULL, indicating the
//  caller isn't interested in getting the CertContext.
//
//  pcbDecrypted can be NULL, indicating the caller isn't interested in
//  getting the decrypted content. However, when pcbDecrypted is NULL,
//  the message is still decrypted and verified.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecryptAndVerifyMessageSignature(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#if 1
    BOOL fResult;
    DWORD cbSignedBlob;
    BYTE *pbSignedBlob = NULL;
    DWORD dwEnvelopeInnerContentType;

    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

#ifdef ENABLE_SCA_STREAM_TEST
    if (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG) {
        cbSignedBlob = 0;
        StreamDecodeMsg(
                CMSG_ENVELOPED_FLAG,
                pDecryptPara,
                NULL,               // pVerifyPara
                0,                  // dwSignerIndex
                pbEncryptedBlob,
                cbEncryptedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                0,                  // dwPrevInnerContentType
                NULL,               // pdwMsgType
                NULL,               // pdwInnerContentType
                NULL,               // pbDecrypted
                &cbSignedBlob,
                NULL,               // ppXchgCert
                NULL                // ppSignerCert
                );
        if (cbSignedBlob == 0) goto ErrorReturn;
        pbSignedBlob = (BYTE *) SCAAlloc(cbSignedBlob);
        if (pbSignedBlob == NULL) goto ErrorReturn;
        if (!StreamDecodeMsg(
                CMSG_ENVELOPED_FLAG,
                pDecryptPara,
                NULL,               // pVerifyPara
                0,                  // dwSignerIndex
                pbEncryptedBlob,
                cbEncryptedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                0,                  // dwPrevInnerContentType
                NULL,               // pdwMsgType
                &dwEnvelopeInnerContentType,
                pbSignedBlob,
                &cbSignedBlob,
                ppXchgCert,
                NULL                // ppSignerCert
                )) goto ErrorReturn;
    } else {

#endif

    cbSignedBlob = 0;
    DecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            NULL,               // pbDecrypted
            &cbSignedBlob,
            NULL,               // ppXchgCert
            NULL                // ppSignerCert
            );
    if (cbSignedBlob == 0) goto ErrorReturn;
    pbSignedBlob = (BYTE *) SCAAlloc(cbSignedBlob);
    if (pbSignedBlob == NULL) goto ErrorReturn;
    if (!DecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            &dwEnvelopeInnerContentType,
            pbSignedBlob,
            &cbSignedBlob,
            ppXchgCert,
            NULL                // ppSignerCert
            )) goto ErrorReturn;

#ifdef ENABLE_SCA_STREAM_TEST
    }
#endif

#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        fResult = StreamDecodeMsg(
                CMSG_SIGNED_FLAG,
                NULL,               // pDecryptPara
                pVerifyPara,
                dwSignerIndex,
                pbSignedBlob,
                cbSignedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                dwEnvelopeInnerContentType,
                NULL,               // pdwMsgType
                NULL,               // pdwInnerContentType
                pbDecrypted,
                pcbDecrypted,
                NULL,               // ppXchgCert
                ppSignerCert
                );
    else
#endif
    fResult = DecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbSignedBlob,
            cbSignedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            dwEnvelopeInnerContentType,
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecrypted,
            pcbDecrypted,
            NULL,               // ppXchgCert
            ppSignerCert
            );
    if (!fResult) goto VerifyError;
    goto CommonReturn;

ErrorReturn:
    if (pcbDecrypted)
        *pcbDecrypted = 0;
VerifyError:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }
    fResult = FALSE;
CommonReturn:
    if (pbSignedBlob)
        SCAFree(pbSignedBlob);
    return fResult;

#else
    // This needs to be updated if we switch back to this option
    return DecodeMsg(
        CMSG_SIGNED_AND_ENVELOPED_FLAG,
        pDecryptPara,
        pVerifyPara,
        dwSignerIndex,
        pbEncryptedBlob,
        cbEncryptedBlob,
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecrypted,
        pcbDecrypted,
        ppXchgCert,
        ppSignerCert
        );
#endif
}


//+-------------------------------------------------------------------------
//  Get the hash length for the specified algorithm identifier.
//
//  Returns 0 for an unknown identifier.
//--------------------------------------------------------------------------
static DWORD GetComputedHashLength(PCRYPT_ALGORITHM_IDENTIFIER pAlgId)
{
    DWORD cbHash;
    DWORD dwAlgId;

    dwAlgId = CertOIDToAlgId(pAlgId->pszObjId);
    switch (dwAlgId) {
        case CALG_SHA:
            cbHash = 20;
            break;
        case CALG_MD2:
        case CALG_MD4:
        case CALG_MD5:
            cbHash = 16;
            break;
        default:
            cbHash = 0;
    }
    return cbHash;
}


//+-------------------------------------------------------------------------
//  Hash the message.
//
//  If fDetachedHash is TRUE, only the ComputedHash is encoded in the
//  pbHashedBlob. Otherwise, both the ToBeHashed and ComputedHash
//  are encoded.
//
//  pcbHashedBlob or pcbComputedHash can be NULL, indicating the caller
//  isn't interested in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashMessage(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BOOL fDetachedHash,
    IN DWORD cToBeHashed,
    IN const BYTE *rgpbToBeHashed[],
    IN DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbHashedBlob,
    IN OUT OPTIONAL DWORD *pcbHashedBlob,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    DWORD dwFlags = fDetachedHash ? CMSG_DETACHED_FLAG : 0;
    HCRYPTMSG hMsg = NULL;
    CMSG_HASHED_ENCODE_INFO HashedMsgEncodeInfo;
    DWORD cbHashedBlob;
    DWORD cbComputedHash;

    // Get input lengths and default return lengths to 0
    cbHashedBlob = 0;
    if (pcbHashedBlob) {
        if (pbHashedBlob)
            cbHashedBlob = *pcbHashedBlob;
        *pcbHashedBlob = 0;
    }
    cbComputedHash = 0;
    if (pcbComputedHash) {
        if (pbComputedHash)
            cbComputedHash = *pcbComputedHash;
        *pcbComputedHash = 0;
    }

    assert(pHashPara->cbSize == sizeof(CRYPT_HASH_MESSAGE_PARA));
    if (pHashPara->cbSize != sizeof(CRYPT_HASH_MESSAGE_PARA))
        goto InvalidArg;

    HashedMsgEncodeInfo.cbSize = sizeof(CMSG_HASHED_ENCODE_INFO);
    HashedMsgEncodeInfo.hCryptProv = pHashPara->hCryptProv;
    HashedMsgEncodeInfo.HashAlgorithm = pHashPara->HashAlgorithm;
    HashedMsgEncodeInfo.pvHashAuxInfo = pHashPara->pvHashAuxInfo;

    fResult = TRUE;
    if (0 == cbHashedBlob && 0 == cbComputedHash &&
            (NULL == pcbComputedHash ||
                0 != (*pcbComputedHash = GetComputedHashLength(
                    &pHashPara->HashAlgorithm)))) {
        // Length only

        if (pcbHashedBlob) {
            DWORD c;
            DWORD cbTotal = 0;
            DWORD *pcb;
            for (c = cToBeHashed, pcb = rgcbToBeHashed; c > 0; c--, pcb++)
                cbTotal += *pcb;

            if (0 == (*pcbHashedBlob = CryptMsgCalculateEncodedLength(
                    pHashPara->dwMsgEncodingType,
                    dwFlags,
                    CMSG_HASHED,
                    &HashedMsgEncodeInfo,
                    NULL,                   // pszInnerContentObjID
                    cbTotal
                    ))) goto CalculateEncodedLengthError;
            if (pbHashedBlob) goto LengthError;
        }

        if (pcbComputedHash && pbComputedHash)
            goto LengthError;

    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                pHashPara->dwMsgEncodingType,
                dwFlags,
                CMSG_HASHED,
                &HashedMsgEncodeInfo,
                NULL,                   // pszInnerContentObjID
                NULL                    // pStreamInfo
                ))) goto OpenToEncodeError;

        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeHashed,
             pcb = rgcbToBeHashed,
             ppb = rgpbToBeHashed; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }

        if (pcbHashedBlob) {
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                pbHashedBlob,
                &cbHashedBlob
                );
            *pcbHashedBlob = cbHashedBlob;
        }
        if (pcbComputedHash) {
            DWORD dwErr;
            BOOL fResult2;
            if (!fResult)
                dwErr = GetLastError();
            fResult2 = CryptMsgGetParam(
                hMsg,
                CMSG_COMPUTED_HASH_PARAM,
                0,                      // dwIndex
                pbComputedHash,
                &cbComputedHash
                );
            *pcbComputedHash = cbComputedHash;
            if (!fResult2)
                fResult = FALSE;
            else if (!fResult)
                SetLastError(dwErr);
        }
        if (!fResult)
            goto ErrorReturn;     // NO_TRACE
    }

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(LengthError, ERROR_MORE_DATA)
TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}

//+-------------------------------------------------------------------------
//  Verify a hashed message.
//
//  pcbToBeHashed or pcbComputedHash can be NULL,
//  indicating the caller isn't interested in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageHash(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BYTE *pbHashedBlob,
    IN DWORD cbHashedBlob,
    OUT OPTIONAL BYTE *pbToBeHashed,
    IN OUT OPTIONAL DWORD *pcbToBeHashed,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    return DecodeHashMsg(
        pHashPara,
        pbHashedBlob,
        cbHashedBlob,
        NULL,               // cToBeHashed
        NULL,               // rgpbToBeHashed
        NULL,               // rgcbToBeHashed
        pbToBeHashed,
        pcbToBeHashed,
        pbComputedHash,
        pcbComputedHash
        );
}

//+-------------------------------------------------------------------------
//  Verify a hashed message containing a detached hash.
//  The "to be hashed" content is passed in separately. No
//  decoded output. Otherwise, identical to CryptVerifyMessageHash.
//
//  pcbComputedHash can be NULL, indicating the caller isn't interested
//  in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyDetachedMessageHash(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BYTE *pbDetachedHashBlob,
    IN DWORD cbDetachedHashBlob,
    IN DWORD cToBeHashed,
    IN const BYTE *rgpbToBeHashed[],
    IN DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    return DecodeHashMsg(
        pHashPara,
        pbDetachedHashBlob,
        cbDetachedHashBlob,
        cToBeHashed,
        rgpbToBeHashed,
        rgcbToBeHashed,
        NULL,               // pbDecoded
        NULL,               // pcbDecoded
        pbComputedHash,
        pcbComputedHash
        );
}

//+-------------------------------------------------------------------------
//  Decodes a cryptographic message which may be one of the following types:
//    CMSG_DATA
//    CMSG_SIGNED
//    CMSG_ENVELOPED
//    CMSG_SIGNED_AND_ENVELOPED
//    CMSG_HASHED
//
//  dwMsgTypeFlags specifies the set of allowable messages. For example, to
//  decode either SIGNED or ENVELOPED messages, set dwMsgTypeFlags to:
//      CMSG_SIGNED_FLAG | CMSG_ENVELOPED_FLAG.
//
//  dwProvInnerContentType is only applicable when processing nested
//  crytographic messages. When processing an outer crytographic message
//  it must be set to 0. When decoding a nested cryptographic message
//  its the dwInnerContentType returned by a previous CryptDecodeMessage
//  of the outer message. The InnerContentType can be any of the CMSG types,
//  for example, CMSG_DATA, CMSG_SIGNED, ...
//
//  The optional *pdwMsgType is updated with the type of message.
//
//  The optional *pdwInnerContentType is updated with the type of the inner
//  message. Unless there is cryptographic message nesting, CMSG_DATA
//  is returned.
//
//  For CMSG_DATA: returns decoded content.
//  For CMSG_SIGNED: same as CryptVerifyMessageSignature.
//  For CMSG_ENVELOPED: same as CryptDecryptMessage.
//  For CMSG_SIGNED_AND_ENVELOPED: same as CryptDecryptMessage plus
//      CryptVerifyMessageSignature.
//  For CMSG_HASHED: verifies the hash and returns decoded content.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecodeMessage(
    IN DWORD dwMsgTypeFlags,
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if ((pVerifyPara &&
            (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG))
                    ||
        (pDecryptPara &&
            (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)))
        return StreamDecodeMsg(
            dwMsgTypeFlags,
            pDecryptPara,
            pVerifyPara,
            dwSignerIndex,
            pbEncodedBlob,
            cbEncodedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            dwPrevInnerContentType,
            pdwMsgType,
            pdwInnerContentType,
            pbDecoded,
            pcbDecoded,
            ppXchgCert,
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        dwMsgTypeFlags,
        pDecryptPara,
        pVerifyPara,
        dwSignerIndex,
        pbEncodedBlob,
        cbEncodedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        dwPrevInnerContentType,
        pdwMsgType,
        pdwInnerContentType,
        pbDecoded,
        pcbDecoded,
        ppXchgCert,
        ppSignerCert
        );
}


//+-------------------------------------------------------------------------
//  Sign the message using the provider's private key specified in the
//  parameters. A dummy SignerId is created and stored in the message.
//
//  Normally used until a certificate has been created for the key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignMessageWithKey(
    IN PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara,
    IN const BYTE *pbToBeSigned,
    IN DWORD cbToBeSigned,
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CERT_INFO CertInfo;
    DWORD dwSerialNumber = 0x12345678;

#define NO_CERT_COMMON_NAME     "NO CERT SIGNATURE"
    CERT_RDN rgRDN[1];
    CERT_RDN_ATTR rgAttr[1];
    CERT_NAME_INFO NameInfo;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;

    assert(pSignPara->cbSize >= offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
        pvHashAuxInfo) + sizeof(pSignPara->pvHashAuxInfo));
    if (pSignPara->cbSize < offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
            pvHashAuxInfo) + sizeof(pSignPara->pvHashAuxInfo))
        goto InvalidArg;

    // Create a dummy issuer name
    NameInfo.cRDN = 1;
    NameInfo.rgRDN = rgRDN;
    rgRDN[0].cRDNAttr = 1;
    rgRDN[0].rgRDNAttr = rgAttr;
    rgAttr[0].pszObjId = szOID_COMMON_NAME;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = (BYTE *) NO_CERT_COMMON_NAME;
    rgAttr[0].Value.cbData = strlen(NO_CERT_COMMON_NAME);

    cbNameEncoded = 0;
    CryptEncodeObject(
        pSignPara->dwMsgAndCertEncodingType,
        X509_NAME,
        &NameInfo,
        NULL,                           // pbEncoded
        &cbNameEncoded
        );
    if (cbNameEncoded == 0) goto ErrorReturn;
    pbNameEncoded = (BYTE *) SCAAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            pSignPara->dwMsgAndCertEncodingType,
            X509_NAME,
            &NameInfo,
            pbNameEncoded,
            &cbNameEncoded
            )) goto ErrorReturn;

    // CertInfo needs to only be initialized with issuer, serial number
    // and public key algorithm
    memset(&CertInfo, 0, sizeof(CertInfo));
    CertInfo.Issuer.pbData = pbNameEncoded;
    CertInfo.Issuer.cbData = cbNameEncoded;
    CertInfo.SerialNumber.pbData = (BYTE *) &dwSerialNumber;
    CertInfo.SerialNumber.cbData = sizeof(dwSerialNumber);

    if (pSignPara->cbSize >= offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
                PubKeyAlgorithm) + sizeof(pSignPara->PubKeyAlgorithm) &&
            pSignPara->PubKeyAlgorithm.pszObjId &&
            '\0' != *pSignPara->PubKeyAlgorithm.pszObjId)
        CertInfo.SubjectPublicKeyInfo.Algorithm = pSignPara->PubKeyAlgorithm;
    else
        CertInfo.SubjectPublicKeyInfo.Algorithm.pszObjId =
            CERT_DEFAULT_OID_PUBLIC_KEY_SIGN;

    memset(&SignerEncodeInfo, 0, sizeof(SignerEncodeInfo));
    SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);
    SignerEncodeInfo.pCertInfo = &CertInfo;
    SignerEncodeInfo.hCryptProv = pSignPara->hCryptProv;
    SignerEncodeInfo.dwKeySpec = pSignPara->dwKeySpec;
    SignerEncodeInfo.HashAlgorithm = pSignPara->HashAlgorithm;
    SignerEncodeInfo.pvHashAuxInfo = pSignPara->pvHashAuxInfo;

    memset(&SignedMsgEncodeInfo, 0, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.cSigners = 1;
    SignedMsgEncodeInfo.rgSigners = &SignerEncodeInfo;

    fResult = EncodeMsg(
        pSignPara->dwMsgAndCertEncodingType,
        0,                              // dwFlags
        CMSG_SIGNED,
        &SignedMsgEncodeInfo,
        1,                              // cToBeSigned
        &pbToBeSigned,
        &cbToBeSigned,
        FALSE,                          // fBareContent
        0,                              // dwInnerContentType
        pbSignedBlob,
        pcbSignedBlob
        );
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    fResult = FALSE;
    *pcbSignedBlob = 0;
CommonReturn:
    if (pbNameEncoded)
        SCAFree(pbNameEncoded);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify a signed message using the specified public key info.
//
//  Normally called by a CA until it has created a certificate for the
//  key.
//
//  pPublicKeyInfo contains the public key to use to verify the signed
//  message. If NULL, the signature isn't verified (for instance, the decoded
//  content may contain the PublicKeyInfo).
//
//  pcbDecoded can be NULL, indicating the caller isn't interested
//  in getting the decoded content.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageSignatureWithKey(
    IN PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara,
    IN OPTIONAL PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded
    )
{
    BOOL fResult = TRUE;
    HCRYPTMSG hMsg = NULL;
    PCERT_INFO pCertInfo = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;

    assert(pVerifyPara->cbSize == sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA));
    if (pVerifyPara->cbSize != sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA))
        goto InvalidArg;

    if (pbDecoded == NULL && pcbDecoded)
        *pcbDecoded = 0;

    if (pcbDecoded && *pcbDecoded == 0 && pPublicKeyInfo == NULL)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    hMsg = CryptMsgOpenToDecode(
        pVerifyPara->dwMsgEncodingType,
        dwFlags,
        0,                          // dwMsgType
        pVerifyPara->hCryptProv,
        NULL,                       // pRecipientInfo
        NULL                        // pStreamInfo
        );
    if (hMsg == NULL) goto ErrorReturn;

    fResult = CryptMsgUpdate(
        hMsg,
        pbSignedBlob,
        cbSignedBlob,
        TRUE                    // fFinal
        );
    if (!fResult) goto ErrorReturn;

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_TYPE_PARAM,
        0,                  // dwIndex
        &dwMsgType,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (dwMsgType != CMSG_SIGNED)
    {
        SetLastError((DWORD) CRYPT_E_UNEXPECTED_MSG_TYPE);
        goto ErrorReturn;
    }

    if (pPublicKeyInfo) {
        // Allocate and get the CERT_INFO containing the SignerId 
        // (Issuer and SerialNumber)
        pCertInfo = (PCERT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0                           // dwSignerIndex
            );
        if (pCertInfo == NULL) goto ErrorReturn;

        pCertInfo->SubjectPublicKeyInfo = *pPublicKeyInfo;

        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pCertInfo
            );
        if (!fResult)  goto ErrorReturn;
    }

    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            pcbDecoded
            );
    }
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    if (pcbDecoded)
        *pcbDecoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pCertInfo)
        SCAFree(pCertInfo);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;
}

//+-------------------------------------------------------------------------
//  SCA allocation and free routines
//--------------------------------------------------------------------------
static void *SCAAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void SCAFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Null implementation of the callback get and verify signer certificate
//--------------------------------------------------------------------------
static PCCERT_CONTEXT WINAPI NullGetSignerCertificate(
    IN void *pvGetArg,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pSignerId,    // Only the Issuer and SerialNumber
                                // fields are used
    IN HCERTSTORE hMsgCertStore
    )
{
    return CertGetSubjectCertificateFromStore(hMsgCertStore, dwCertEncodingType,
        pSignerId);
}


//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------

static PCMSG_SIGNER_ENCODE_INFO InitSignerEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara
    )
{
    BOOL fResult;
    PCMSG_SIGNER_ENCODE_INFO pSigner = NULL;
    BOOL *pfDidCryptAcquire;
    DWORD cbSigner;

    if (pSignPara->pSigningCert == NULL)
        return NULL;

    // The flag indicating we did a CryptAcquireContext
    // follows the CMSG_SIGNER_ENCODE_INFO. If set, the HCRYPTPROV will need to be
    // released when SignerEncodeInfo is freed.
    cbSigner = sizeof(CMSG_SIGNER_ENCODE_INFO) + sizeof(BOOL);
    pSigner = (PCMSG_SIGNER_ENCODE_INFO) SCAAlloc(cbSigner);
    if (pSigner == NULL) goto ErrorReturn;
    memset(pSigner, 0, cbSigner);
    pSigner->cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);

    pfDidCryptAcquire =
        (BOOL *) (((BYTE *) pSigner) + sizeof(CMSG_SIGNER_ENCODE_INFO));

    pSigner->pCertInfo = pSignPara->pSigningCert->pCertInfo;
    pSigner->HashAlgorithm = pSignPara->HashAlgorithm;
    pSigner->pvHashAuxInfo = pSignPara->pvHashAuxInfo;

    fResult = CryptAcquireCertificatePrivateKey(
        pSignPara->pSigningCert,
        CRYPT_ACQUIRE_USE_PROV_INFO_FLAG,
        NULL,                               // pvReserved
        &pSigner->hCryptProv,
        &pSigner->dwKeySpec,
        pfDidCryptAcquire
        );
    if (!fResult) goto ErrorReturn;

    if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
            rgUnauthAttr)) {
    	pSigner->cAuthAttr      = pSignPara->cAuthAttr;
    	pSigner->rgAuthAttr 	= pSignPara->rgAuthAttr;
    	pSigner->cUnauthAttr 	= pSignPara->cUnauthAttr;
    	pSigner->rgUnauthAttr 	= pSignPara->rgUnauthAttr;
    }

#ifdef CMS_PKCS7
    if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
            pvHashEncryptionAuxInfo)) {
    	pSigner->HashEncryptionAlgorithm = pSignPara->HashEncryptionAlgorithm;
    	pSigner->pvHashEncryptionAuxInfo = pSignPara->pvHashEncryptionAuxInfo;
    }
#endif  // CMS_PKCS7
    
    goto CommonReturn;

ErrorReturn:
    if (pSigner) {
        FreeSignerEncodeInfo(pSigner);
        pSigner = NULL;
    }

CommonReturn:
    return pSigner;
}

static void FreeSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO pSigner
    )
{
    BOOL *pfDidCryptAcquire;

    if (pSigner == NULL)
        return;

    // The flag indicating we did a CryptAcquireContext
    // follows the CMSG_SIGNER_ENCODE_INFO.
    pfDidCryptAcquire =
        (BOOL *) (((BYTE *) pSigner) + sizeof(CMSG_SIGNER_ENCODE_INFO));
    if (*pfDidCryptAcquire) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(pSigner->hCryptProv, 0);
        SetLastError(dwErr);
    }
    
    SCAFree(pSigner);
}

static BOOL InitSignedCertAndCrl(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCERT_BLOB *ppCertEncoded,
    OUT PCRL_BLOB *ppCrlEncoded
    )
{
    PCERT_BLOB pCertEncoded = NULL;
    PCRL_BLOB pCrlEncoded = NULL;
    DWORD cMsgCert = pSignPara->cMsgCert;
    DWORD cMsgCrl = pSignPara->cMsgCrl;

    BOOL fResult;
    DWORD dwIdx;

    if (cMsgCert) {
        pCertEncoded = (PCERT_BLOB) SCAAlloc(sizeof(CERT_BLOB) * cMsgCert);
        if (pCertEncoded == NULL) goto ErrorReturn;
        for (dwIdx = 0; dwIdx < cMsgCert; dwIdx++) {
            pCertEncoded[dwIdx].pbData = pSignPara->rgpMsgCert[dwIdx]->pbCertEncoded;
            pCertEncoded[dwIdx].cbData = pSignPara->rgpMsgCert[dwIdx]->cbCertEncoded;
        }
    }

    if (cMsgCrl) {
        pCrlEncoded = (PCRL_BLOB) SCAAlloc(sizeof(CRL_BLOB) * cMsgCrl);
        if (pCrlEncoded == NULL) goto ErrorReturn;
        for (dwIdx = 0; dwIdx < cMsgCrl; dwIdx++) {
            pCrlEncoded[dwIdx].pbData = pSignPara->rgpMsgCrl[dwIdx]->pbCrlEncoded;
            pCrlEncoded[dwIdx].cbData = pSignPara->rgpMsgCrl[dwIdx]->cbCrlEncoded;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    FreeSignedCertAndCrl(pCertEncoded, pCrlEncoded);
    pCertEncoded = NULL;
    pCrlEncoded = NULL;
    fResult = FALSE;
CommonReturn:
    *ppCertEncoded = pCertEncoded;
    *ppCrlEncoded = pCrlEncoded;
    return fResult;
}

static void FreeSignedCertAndCrl(
    IN PCERT_BLOB pCertEncoded,
    IN PCRL_BLOB pCrlEncoded
    )
{
    if (pCertEncoded)
        SCAFree(pCertEncoded);
    if (pCrlEncoded)
        SCAFree(pCrlEncoded);
}

static BOOL InitSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    BOOL fResult = FALSE;

    assert(pSignPara->cbSize >=
        STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA, rgpMsgCrl));

    if (pSignPara->cbSize < STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA, rgpMsgCrl))
        SetLastError((DWORD) E_INVALIDARG);
    else {
        memset(pSignedMsgEncodeInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
        pSignedMsgEncodeInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
        pSignedMsgEncodeInfo->cSigners = 
            (pSignPara->pSigningCert != NULL) ? 1 : 0;
        pSignedMsgEncodeInfo->rgSigners = InitSignerEncodeInfo(pSignPara);
        if (pSignedMsgEncodeInfo->rgSigners ||
            pSignedMsgEncodeInfo->cSigners == 0) {
            pSignedMsgEncodeInfo->cCertEncoded = pSignPara->cMsgCert;
            pSignedMsgEncodeInfo->cCrlEncoded = pSignPara->cMsgCrl;
    
            fResult = InitSignedCertAndCrl(
                pSignPara,
                &pSignedMsgEncodeInfo->rgCertEncoded,
                &pSignedMsgEncodeInfo->rgCrlEncoded
                );
            if(!fResult)
                FreeSignerEncodeInfo(pSignedMsgEncodeInfo->rgSigners);
        }
    }

    if (!fResult)
        memset(pSignedMsgEncodeInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    return fResult;
}

static void FreeSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    FreeSignerEncodeInfo(pSignedMsgEncodeInfo->rgSigners);
    FreeSignedCertAndCrl(
        pSignedMsgEncodeInfo->rgCertEncoded,
        pSignedMsgEncodeInfo->rgCrlEncoded
        );
}

#ifdef CMS_PKCS7
// Returned array of CMSG_RECIPIENT_ENCODE_INFOs needs to be SCAFree'd
//
// BUGBUG for now, assume only Key Transport recipients
static PCMSG_RECIPIENT_ENCODE_INFO InitCmsRecipientEncodeInfo(
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN DWORD dwFlags
    )
{
    PCMSG_RECIPIENT_ENCODE_INFO pCmsRecipientEncodeInfo = NULL;
    DWORD cbCmsRecipientEncodeInfo;
    PCMSG_RECIPIENT_ENCODE_INFO pEncodeInfo;                // not allocated
    PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans;        // not allocated
    PCCERT_CONTEXT *ppRecipientCert;                        // not allocated
    BYTE *pbHash;                                           // not allocated

    assert(cRecipientCert);

    cbCmsRecipientEncodeInfo = (sizeof(CMSG_RECIPIENT_ENCODE_INFO) +
            sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)) * cRecipientCert;
    if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG)
        cbCmsRecipientEncodeInfo += MAX_HASH_LEN * cRecipientCert;

    pCmsRecipientEncodeInfo =
        (PCMSG_RECIPIENT_ENCODE_INFO) SCAAlloc(cbCmsRecipientEncodeInfo);
    if (NULL == pCmsRecipientEncodeInfo)
        goto OutOfMemory;

    pEncodeInfo = pCmsRecipientEncodeInfo;
    pKeyTrans = (PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)
        &pEncodeInfo[cRecipientCert];
    memset(pKeyTrans, 0, sizeof(*pKeyTrans) * cRecipientCert);

    if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG)
        pbHash = (BYTE *) &pKeyTrans[cRecipientCert];

    ppRecipientCert = rgpRecipientCert;
    for ( ; 0 < cRecipientCert; cRecipientCert--,
                                    pEncodeInfo++,
                                    pKeyTrans++,
                                    ppRecipientCert++) {
        PCERT_INFO pCertInfo = (*ppRecipientCert)->pCertInfo;

        pEncodeInfo->dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
        pEncodeInfo->pKeyTrans = pKeyTrans;

        pKeyTrans->cbSize = sizeof(*pKeyTrans);
        pKeyTrans->KeyEncryptionAlgorithm =
            pCertInfo->SubjectPublicKeyInfo.Algorithm;
        // pKeyTrans->pvKeyEncryptionAuxInfo =
        // pKeyTrans->hCryptProv =
        pKeyTrans->RecipientPublicKey =
            pCertInfo->SubjectPublicKeyInfo.PublicKey;

        if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG) {
            pKeyTrans->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
            pKeyTrans->RecipientId.KeyId.pbData = pbHash;
            pKeyTrans->RecipientId.KeyId.cbData = MAX_HASH_LEN;

            if (!CertGetCertificateContextProperty(
                    *ppRecipientCert,
                    CERT_KEY_IDENTIFIER_PROP_ID,
                    pbHash,
                    &pKeyTrans->RecipientId.KeyId.cbData
                    ))
                goto GetKeyIdPropError;
            pbHash += MAX_HASH_LEN;
        } else {
            pKeyTrans->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            pKeyTrans->RecipientId.IssuerSerialNumber.Issuer =
                pCertInfo->Issuer;
            pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber =
                pCertInfo->SerialNumber;
        }
    }

CommonReturn:
    return pCmsRecipientEncodeInfo;

ErrorReturn:
    SCAFree(pCmsRecipientEncodeInfo);
    pCmsRecipientEncodeInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetKeyIdPropError)
}

#else

// Returned array of PCERT_INFOs needs to be SCAFree'd
static PCERT_INFO *InitRecipientEncodeInfo(
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[]
    )
{
    DWORD dwIdx;
    PCERT_INFO *ppRecipientEncodeInfo;

    if (cRecipientCert == 0) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    ppRecipientEncodeInfo = (PCERT_INFO *)
        SCAAlloc(sizeof(PCERT_INFO) * cRecipientCert);
    if (ppRecipientEncodeInfo != NULL) {
        for (dwIdx = 0; dwIdx < cRecipientCert; dwIdx++)
            ppRecipientEncodeInfo[dwIdx] = rgpRecipientCert[dwIdx]->pCertInfo;
    }

    return ppRecipientEncodeInfo;
}

#endif  // CMS_PKCS7

static BOOL InitEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    BOOL fResult = FALSE;

#ifdef CMS_PKCS7
    PCMSG_RECIPIENT_ENCODE_INFO pCmsRecipientEncodeInfo = NULL;
#else
    PCERT_INFO *ppRecipientEncodeInfo;
#endif  // CMS_PKCS7

    assert(pEncryptPara->cbSize == sizeof(CRYPT_ENCRYPT_MESSAGE_PARA) ||
        pEncryptPara->cbSize == offsetof(CRYPT_ENCRYPT_MESSAGE_PARA, dwFlags));
    if (pEncryptPara->cbSize < offsetof(CRYPT_ENCRYPT_MESSAGE_PARA, dwFlags))
        SetLastError((DWORD) E_INVALIDARG);
    else {
#ifdef CMS_PKCS7
        if (0 == cRecipientCert || (pCmsRecipientEncodeInfo =
                InitCmsRecipientEncodeInfo(
                    cRecipientCert,
                    rgpRecipientCert,
                    pEncryptPara->cbSize >= sizeof(CRYPT_ENCRYPT_MESSAGE_PARA) ?
                        pEncryptPara->dwFlags : 0
                    ))) {
#else
        ppRecipientEncodeInfo = InitRecipientEncodeInfo(
            cRecipientCert,
            rgpRecipientCert
            );
    
        if (ppRecipientEncodeInfo) {
#endif  // CMS_PKCS7
            memset(pEnvelopedMsgEncodeInfo, 0,
                sizeof(CMSG_ENVELOPED_ENCODE_INFO));
            pEnvelopedMsgEncodeInfo->cbSize =
                sizeof(CMSG_ENVELOPED_ENCODE_INFO);
            pEnvelopedMsgEncodeInfo->hCryptProv = pEncryptPara->hCryptProv;
            pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm =
                pEncryptPara->ContentEncryptionAlgorithm;
            pEnvelopedMsgEncodeInfo->pvEncryptionAuxInfo =
                pEncryptPara->pvEncryptionAuxInfo;
            pEnvelopedMsgEncodeInfo->cRecipients = cRecipientCert;
#ifdef CMS_PKCS7
            pEnvelopedMsgEncodeInfo->rgCmsRecipients = pCmsRecipientEncodeInfo;
#else
            pEnvelopedMsgEncodeInfo->rgpRecipients = ppRecipientEncodeInfo;
#endif  // CMS_PKCS7
            fResult = TRUE;
        } else
            fResult = FALSE;
    }
    if (!fResult) 
        memset(pEnvelopedMsgEncodeInfo, 0, sizeof(CMSG_ENVELOPED_ENCODE_INFO));
    return fResult;
}

static void FreeEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
#ifdef CMS_PKCS7
    if (pEnvelopedMsgEncodeInfo->rgCmsRecipients)
        SCAFree(pEnvelopedMsgEncodeInfo->rgCmsRecipients);
#else
    if (pEnvelopedMsgEncodeInfo->rgpRecipients)
        SCAFree(pEnvelopedMsgEncodeInfo->rgpRecipients);
#endif  // CMS_PKCS7
}

//+-------------------------------------------------------------------------
//  Encode the message.
//--------------------------------------------------------------------------
static BOOL EncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbEncodedBlob;
    LPCSTR pszInnerContentOID;

    // Get input length and default return length to 0
    if (pbEncodedBlob == NULL)
        cbEncodedBlob = 0;
    else
        cbEncodedBlob = *pcbEncodedBlob;
    *pcbEncodedBlob = 0;

    if (dwInnerContentType)
        pszInnerContentOID = MsgTypeToOID(dwInnerContentType);
    else
        pszInnerContentOID = NULL;

    if (0 == cbEncodedBlob) {
        DWORD c;
        DWORD cbTotal = 0;
        DWORD *pcb;
        for (c = cToBeEncoded, pcb = rgcbToBeEncoded; c > 0; c--, pcb++)
            cbTotal += *pcb;

        if (fBareContent)
            dwFlags |= CMSG_BARE_CONTENT_FLAG;

        if (0 == (*pcbEncodedBlob = CryptMsgCalculateEncodedLength(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            (LPSTR) pszInnerContentOID,
            cbTotal
            ))) goto CalculateEncodedLengthError;
        if (pbEncodedBlob) goto LengthError;
    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwFlags,
                dwMsgType,
                pvMsgEncodeInfo,
                (LPSTR) pszInnerContentOID,
                NULL                    // pStreamInfo
                ))) goto OpenToEncodeError;

        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeEncoded,
             pcb = rgcbToBeEncoded,
             ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }

        fResult = CryptMsgGetParam(
            hMsg,
            fBareContent ? CMSG_BARE_CONTENT_PARAM : CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbEncodedBlob,
            &cbEncodedBlob
            );
        *pcbEncodedBlob = cbEncodedBlob;
        if (!fResult) goto ErrorReturn;     // NO_TRACE
    }
    fResult = TRUE;

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(LengthError, ERROR_MORE_DATA)
TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  For detached signature (cToBeEncoded != 0), then, pcbDecoded == NULL.
//--------------------------------------------------------------------------
static BOOL DecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;

    // Get input length and default return length to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }

    // Default optional return values to 0
    if (pdwMsgType)
        *pdwMsgType = 0;
    if (pdwInnerContentType)
        *pdwInnerContentType = 0;
    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

    if (pDecryptPara) {
        assert(pDecryptPara->cbSize == sizeof(CRYPT_DECRYPT_MESSAGE_PARA));
        if (pDecryptPara->cbSize != sizeof(CRYPT_DECRYPT_MESSAGE_PARA))
            goto InvalidArg;
    }

    if (pVerifyPara) {
        assert(pVerifyPara->cbSize == sizeof(CRYPT_VERIFY_MESSAGE_PARA));
        if (pVerifyPara->cbSize != sizeof(CRYPT_VERIFY_MESSAGE_PARA))
            goto InvalidArg;
        hCryptProv = pVerifyPara->hCryptProv;
        dwMsgEncodingType = pVerifyPara->dwMsgAndCertEncodingType;
    } else {
        hCryptProv = 0;
        if (NULL == pDecryptPara) goto InvalidArg;
        dwMsgEncodingType = pDecryptPara->dwMsgAndCertEncodingType;
    }

    if (cToBeEncoded)
        dwFlags = CMSG_DETACHED_FLAG;
    else if (pcbDecoded && 0 == cbDecoded &&
            NULL == ppXchgCert && NULL == ppSignerCert)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    if (dwPrevInnerContentType) {
        dwMsgType = dwPrevInnerContentType;
        if (CMSG_DATA == dwMsgType)
            dwMsgType = 0;
    } else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto OpenToDecodeError;

    if (!CryptMsgUpdate(
            hMsg,
            pbEncodedBlob,
            cbEncodedBlob,
            TRUE                    // fFinal
            )) goto UpdateError;

    if (cToBeEncoded) {
        // Detached signature
        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeEncoded,
             pcb = rgcbToBeEncoded,
             ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (pdwMsgType)
        *pdwMsgType = dwMsgType;
    if (0 == ((1 << dwMsgType) & dwMsgTypeFlags))
        goto UnexpectedMsgTypeError;

    if (pdwInnerContentType) {
        char szInnerContentType[128];
        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        *pdwInnerContentType = OIDToMsgType(szInnerContentType);
    }

    if (0 == (dwFlags & CMSG_LENGTH_ONLY_FLAG)) {
        if (dwMsgType == CMSG_ENVELOPED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pDecryptPara == NULL) goto InvalidArg;
            if (!GetXchgCertAndDecrypt(
                    pDecryptPara,
                    hMsg,
                    ppXchgCert
                    )) goto GetXchgCertAndDecryptError;
        }

        if (dwMsgType == CMSG_SIGNED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pVerifyPara == NULL) goto InvalidArg;
            if (!GetSignerCertAndVerify(
                    pVerifyPara,
                    dwSignerIndex,
                    hMsg,
                    ppSignerCert
                    )) goto GetSignerCertAndVerifyError;
        }
    }


    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            &cbDecoded
            );
        *pcbDecoded = cbDecoded;
        if (!fResult) goto ErrorReturn;     // NO_TRACE
    }

    fResult = TRUE;

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetXchgCertAndDecryptError)
TRACE_ERROR(GetSignerCertAndVerifyError)
}

#ifdef ENABLE_SCA_STREAM_TEST

typedef struct _STREAM_OUTPUT_INFO {
    BYTE    *pbData;
    DWORD   cbData;
    DWORD   cFinal;
} STREAM_OUTPUT_INFO, *PSTREAM_OUTPUT_INFO;

static void *SCARealloc(
    IN void *pvOrg,
    IN size_t cbBytes
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static BOOL WINAPI StreamOutputCallback(
        IN const void *pvArg,
        IN BYTE *pbData,
        IN DWORD cbData,
        IN BOOL fFinal
        )
{
    BOOL fResult = TRUE;
    PSTREAM_OUTPUT_INFO pInfo = (PSTREAM_OUTPUT_INFO) pvArg;
    if (fFinal)
        pInfo->cFinal++;

    if (cbData) {
        BYTE *pb;

        if (NULL == (pb = (BYTE *) SCARealloc(pInfo->pbData,
                pInfo->cbData + cbData)))
            fResult = FALSE;
        else {
            memcpy(pb + pInfo->cbData, pbData, cbData);
            pInfo->pbData = pb;
            pInfo->cbData += cbData;
        }
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Encodes the message using streaming.
//--------------------------------------------------------------------------
static BOOL StreamEncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbEncodedBlob;
    LPCSTR pszInnerContentOID;

    STREAM_OUTPUT_INFO OutputInfo;
    memset(&OutputInfo, 0, sizeof(OutputInfo));

    CMSG_STREAM_INFO StreamInfo;
    memset(&StreamInfo, 0, sizeof(StreamInfo));

    StreamInfo.pfnStreamOutput = StreamOutputCallback;
    StreamInfo.pvArg = (void *) &OutputInfo;
    if (dwFlags & SCA_INDEFINITE_STREAM_FLAG)
        StreamInfo.cbContent = CMSG_INDEFINITE_LENGTH;
    else {
        DWORD c;
        DWORD cbTotal = 0;
        DWORD *pcb;
        for (c = cToBeEncoded, pcb = rgcbToBeEncoded; c > 0; c--, pcb++)
            cbTotal += *pcb;

        StreamInfo.cbContent = cbTotal;
    }
    dwFlags &= ~(SCA_STREAM_ENABLE_FLAG | SCA_INDEFINITE_STREAM_FLAG);

    // Get input length and default return length to 0
    if (pbEncodedBlob == NULL)
        cbEncodedBlob = 0;
    else
        cbEncodedBlob = *pcbEncodedBlob;
    *pcbEncodedBlob = 0;

    if (dwInnerContentType)
        pszInnerContentOID = MsgTypeToOID(dwInnerContentType);
    else
        pszInnerContentOID = NULL;

    {
        if (fBareContent)
            dwFlags |= CMSG_BARE_CONTENT_FLAG;
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwFlags,
                dwMsgType,
                pvMsgEncodeInfo,
                (LPSTR) pszInnerContentOID,
                &StreamInfo
                ))) goto OpenToEncodeError;

        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeEncoded,
             pcb = rgcbToBeEncoded,
             ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
            BYTE *pbAlloc = NULL;
            const BYTE *pb = *ppb;

            if (NULL == pb) {
                pbAlloc = (BYTE *) SCAAlloc(*pcb);
                pb = pbAlloc;
            }
            
            fResult = CryptMsgUpdate(
                    hMsg,
                    pb,
                    *pcb,
                    c == 1                    // fFinal
                    );
            if (pbAlloc)
                SCAFree(pbAlloc);
            if (!fResult)
                goto UpdateError;
        }

        if (1 != OutputInfo.cFinal)
            goto BadStreamFinalCountError;

        *pcbEncodedBlob = OutputInfo.cbData;
        if (pbEncodedBlob) {
            if (cbEncodedBlob < OutputInfo.cbData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                goto ErrorReturn;       // no trace
            }

            if (OutputInfo.cbData > 0)
                memcpy(pbEncodedBlob, OutputInfo.pbData, OutputInfo.cbData);
        }
    }
    fResult = TRUE;

CommonReturn:
    SCAFree(OutputInfo.pbData);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
SET_ERROR(BadStreamFinalCountError, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  Uses streaming.
//--------------------------------------------------------------------------
static BOOL StreamDecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;

    STREAM_OUTPUT_INFO OutputInfo;
    memset(&OutputInfo, 0, sizeof(OutputInfo));
    CMSG_STREAM_INFO StreamInfo;
    memset(&StreamInfo, 0, sizeof(StreamInfo));

    StreamInfo.pfnStreamOutput = StreamOutputCallback;
    StreamInfo.pvArg = (void *) &OutputInfo;
    StreamInfo.cbContent = CMSG_INDEFINITE_LENGTH;

    // Get input length and default return length to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }

    // Default optional return values to 0
    if (pdwMsgType)
        *pdwMsgType = 0;
    if (pdwInnerContentType)
        *pdwInnerContentType = 0;
    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

    if (pDecryptPara) {
        assert(pDecryptPara->cbSize == sizeof(CRYPT_DECRYPT_MESSAGE_PARA));
        if (pDecryptPara->cbSize != sizeof(CRYPT_DECRYPT_MESSAGE_PARA))
            goto InvalidArg;
    }

    if (pVerifyPara) {
        assert(pVerifyPara->cbSize == sizeof(CRYPT_VERIFY_MESSAGE_PARA));
        if (pVerifyPara->cbSize != sizeof(CRYPT_VERIFY_MESSAGE_PARA))
            goto InvalidArg;
        hCryptProv = pVerifyPara->hCryptProv;
        dwMsgEncodingType = pVerifyPara->dwMsgAndCertEncodingType;
    } else {
        hCryptProv = 0;
        if (NULL == pDecryptPara) goto InvalidArg;
        dwMsgEncodingType = pDecryptPara->dwMsgAndCertEncodingType;
    }

    dwMsgEncodingType &= ~SCA_STREAM_ENABLE_FLAG;

    if (cToBeEncoded)
        dwFlags = CMSG_DETACHED_FLAG;
    else
        dwFlags = 0;

    if (dwPrevInnerContentType) {
        dwMsgType = dwPrevInnerContentType;
        if (CMSG_DATA == dwMsgType)
            dwMsgType = 0;
    } else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            NULL,                       // pRecipientInfo
            &StreamInfo
            ))) goto OpenToDecodeError;

    {
#if 1
        DWORD cbDelta = cbEncodedBlob / 10;
#else
        DWORD cbDelta = 1;
#endif
        DWORD cbRemain = cbEncodedBlob;
        const BYTE *pb = pbEncodedBlob;

        do {
            DWORD cb;

            if (cbRemain > cbDelta)
                cb = cbDelta;
            else
                cb = cbRemain;

            if (!CryptMsgUpdate(
                    hMsg,
                    pb,
                    cb,
                    cbRemain == cb     // fFinal
                    )) goto UpdateError;
            pb += cb;
            cbRemain -= cb;
        } while (0 != cbRemain);
    }

    if (cToBeEncoded) {
        // Detached signature
        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeEncoded,
             pcb = rgcbToBeEncoded,
             ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (pdwMsgType)
        *pdwMsgType = dwMsgType;
    if (0 == ((1 << dwMsgType) & dwMsgTypeFlags))
        goto UnexpectedMsgTypeError;

    if (pdwInnerContentType) {
        char szInnerContentType[128];
        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        *pdwInnerContentType = OIDToMsgType(szInnerContentType);
    }

    if (pcbDecoded && 0 == cbDecoded &&
            NULL == ppXchgCert && NULL == ppSignerCert &&
            dwMsgType != CMSG_ENVELOPED)
        ; // Length only
    else {
        if (dwMsgType == CMSG_ENVELOPED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pDecryptPara == NULL) goto InvalidArg;
            if (!GetXchgCertAndDecrypt(
                    pDecryptPara,
                    hMsg,
                    ppXchgCert
                    )) goto GetXchgCertAndDecryptError;
        }

        if (dwMsgType == CMSG_SIGNED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pVerifyPara == NULL) goto InvalidArg;
            if (!GetSignerCertAndVerify(
                    pVerifyPara,
                    dwSignerIndex,
                    hMsg,
                    ppSignerCert
                    )) goto GetSignerCertAndVerifyError;
        }
    }

    if (1 != OutputInfo.cFinal)
        goto BadStreamFinalCountError;

    if (pcbDecoded) {
        *pcbDecoded = OutputInfo.cbData;
        if (pbDecoded) {
            if (cbDecoded < OutputInfo.cbData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                goto ErrorReturn;       // no trace
            }

            if (OutputInfo.cbData > 0)
                memcpy(pbDecoded, OutputInfo.pbData, OutputInfo.cbData);
        }
    }

    fResult = TRUE;

CommonReturn:
    SCAFree(OutputInfo.pbData);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetXchgCertAndDecryptError)
TRACE_ERROR(GetSignerCertAndVerifyError)
SET_ERROR(BadStreamFinalCountError, E_UNEXPECTED)
}

#endif      // ENABLE_SCA_STREAM_TEST


//+-------------------------------------------------------------------------
//  Decodes the HASHED message type
//
//  For detached hash (cToBeHashed != 0), then, pcbDecoded == NULL.
//--------------------------------------------------------------------------
static BOOL DecodeHashMsg(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeHashed,
    IN OPTIONAL const BYTE *rgpbToBeHashed[],
    IN OPTIONAL DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    BOOL fReturnResult = TRUE;
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;
    DWORD cbComputedHash;

    // Get input lengths and default return lengths to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }
    cbComputedHash = 0;
    if (pcbComputedHash) {
        if (pbComputedHash)
            cbComputedHash = *pcbComputedHash;
        *pcbComputedHash = 0;
    }

    assert(pHashPara->cbSize == sizeof(CRYPT_HASH_MESSAGE_PARA));
    if (pHashPara->cbSize != sizeof(CRYPT_HASH_MESSAGE_PARA))
        goto InvalidArg;

    hCryptProv = pHashPara->hCryptProv;
    dwMsgEncodingType = pHashPara->dwMsgEncodingType;

    if (cToBeHashed)
        dwFlags = CMSG_DETACHED_FLAG;
    else if (0 == cbDecoded && NULL == pcbComputedHash)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            0,                          // dwMsgType
            hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto OpenToDecodeError;

    if (!CryptMsgUpdate(
            hMsg,
            pbEncodedBlob,
            cbEncodedBlob,
            TRUE                    // fFinal
            )) goto UpdateError;

    if (cToBeHashed) {
        // Detached signature or hash
        DWORD c = 0;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeHashed,
             pcb = rgcbToBeHashed,
             ppb = rgpbToBeHashed; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (dwMsgType != CMSG_HASHED)
        goto UnexpectedMsgTypeError;

    if (0 == (dwFlags & CMSG_LENGTH_ONLY_FLAG)) {
        if (!CryptMsgControl(
                hMsg,
                0,                      // dwFlags
                CMSG_CTRL_VERIFY_HASH,
                NULL                    // pvCtrlPara
                )) goto ControlError;
    }

    fResult = TRUE;
    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            &cbDecoded
            );
        *pcbDecoded = cbDecoded;
    }
    if (pcbComputedHash) {
        DWORD dwErr;
        BOOL fResult2;
        if (!fResult)
            dwErr = GetLastError();
        fResult2 = CryptMsgGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            0,                      // dwIndex
            pbComputedHash,
            &cbComputedHash
            );
        *pcbComputedHash = cbComputedHash;
        if (!fResult2)
            fResult = FALSE;
        else if (!fResult)
            SetLastError(dwErr);
    }
    if (!fResult)
        goto ErrorReturn;     // NO_TRACE

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(ControlError)
}

//+-------------------------------------------------------------------------
//  Get certificate for and verify the message's signer.
//--------------------------------------------------------------------------
static BOOL GetSignerCertAndVerify(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    BOOL fNoSigner = FALSE;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSignerCert = NULL;
    HCERTSTORE hMsgCertStore = NULL;
    DWORD dwLastError = 0;


    {
        // First, get count of signers in the message and verify the
        // dwSignerIndex
        DWORD cSigner = 0;
        DWORD cbData = sizeof(cSigner);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &cSigner,
                &cbData
                )) goto ErrorReturn;
        if (cSigner <= dwSignerIndex) fNoSigner = TRUE;
    }

    if (!fNoSigner) {
        // Allocate and get the CERT_INFO containing the SignerId 
        // (Issuer and SerialNumber)
        if (NULL == (pSignerId = (PCERT_INFO) AllocAndMsgGetParam(
                hMsg,
                CMSG_SIGNER_CERT_INFO_PARAM,
                dwSignerIndex
                ))) goto ErrorReturn;
    }

    // Open a cert store initialized with certs and CRLs from the message
    hMsgCertStore = CertOpenStore(
        CERT_STORE_PROV_MSG,
#ifdef ENABLE_SCA_STREAM_TEST
        pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
        pVerifyPara->dwMsgAndCertEncodingType,
#endif
        pVerifyPara->hCryptProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
        hMsg                        // pvPara
        );
    if (hMsgCertStore == NULL) goto ErrorReturn;

    if (pVerifyPara->pfnGetSignerCertificate)
        pSignerCert = pVerifyPara->pfnGetSignerCertificate(
            pVerifyPara->pvGetArg,
#ifdef ENABLE_SCA_STREAM_TEST
            pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
            pVerifyPara->dwMsgAndCertEncodingType,
#endif
            pSignerId,
            hMsgCertStore
            );
    else
        pSignerCert = NullGetSignerCertificate(
            NULL,
#ifdef ENABLE_SCA_STREAM_TEST
            pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
            pVerifyPara->dwMsgAndCertEncodingType,
#endif
            pSignerId,
            hMsgCertStore
            );
    if (fNoSigner) goto NoSigner;
    if (pSignerCert == NULL) goto ErrorReturn;

#ifdef CMS_PKCS7
    {
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =
        CtrlPara.dwSignerIndex = dwSignerIndex;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pSignerCert;
        if (!CryptMsgControl(
                hMsg,
                0,                  // dwFlags
                CMSG_CTRL_VERIFY_SIGNATURE_EX,
                &CtrlPara
                )) {
            if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
                goto ErrorReturn;
            else {
                PCCERT_CHAIN_CONTEXT pChainContext;
                CERT_CHAIN_PARA ChainPara;

                // Build a chain. Hopefully, the signer inherit's its public key
                // parameters from up the chain

                memset(&ChainPara, 0, sizeof(ChainPara));
                ChainPara.cbSize = sizeof(ChainPara);
                if (CertGetCertificateChain(
                        NULL,                   // hChainEngine
                        pSignerCert,
                        NULL,                   // pTime
                        hMsgCertStore,
                        &ChainPara,
                        CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                        NULL,                   // pvReserved
                        &pChainContext
                        ))
                    CertFreeCertificateChain(pChainContext);

                // Try again. Hopefully the above chain building updated the
                // signer's context property with the missing public key
                // parameters
                if (!CryptMsgControl(
                        hMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_VERIFY_SIGNATURE_EX,
                        &CtrlPara)) goto ErrorReturn;
            }
        }
    }
#else
    if (!CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pSignerCert->pCertInfo
            )) goto ErrorReturn;
#endif  // CMS_PKCS7

    if (ppSignerCert)
        *ppSignerCert = pSignerCert;
    else
        CertFreeCertificateContext(pSignerCert);

    fResult = TRUE;
    goto CommonReturn;

NoSigner:
    SetLastError((DWORD) CRYPT_E_NO_SIGNER);
ErrorReturn:
    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);
    if (ppSignerCert)
        *ppSignerCert = NULL;
    fResult = FALSE;
    dwLastError = GetLastError();
CommonReturn:
    if (pSignerId)
        SCAFree(pSignerId);
    if (hMsgCertStore)
        CertCloseStore(hMsgCertStore, 0);
    if (dwLastError)
        SetLastError(dwLastError);
    return fResult;
}

#ifdef CMS_PKCS7

static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    BOOL fResult;
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo = NULL;
    PCCERT_CONTEXT pXchgCert = NULL;
    DWORD cRecipient;
    DWORD cbData;
    DWORD dwRecipientIdx;
    DWORD dwStoreIdx;

    // Get # of CMS recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CMS_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (cRecipient == 0) {
        SetLastError((DWORD) CRYPT_E_RECIPIENT_NOT_FOUND);
        goto ErrorReturn;
    }

    // Loop through the recipients in the message until we find a
    // recipient cert in one of the stores with either the
    // CERT_KEY_CONTEXT_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID.
    for (dwRecipientIdx = 0; dwRecipientIdx < cRecipient; dwRecipientIdx++) {
        PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;

        pRecipientInfo = (PCMSG_CMS_RECIPIENT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_CMS_RECIPIENT_INFO_PARAM,
            dwRecipientIdx
            );
        if (pRecipientInfo == NULL) goto ErrorReturn;

        // BUGBUG only handle Key Transport recipients
        if (CMSG_KEY_TRANS_RECIPIENT != pRecipientInfo->dwRecipientChoice) {
            SCAFree(pRecipientInfo);
            pRecipientInfo = NULL;
            continue;
        }

        pKeyTrans = pRecipientInfo->pKeyTrans;

        for (dwStoreIdx = 0;
                dwStoreIdx < pDecryptPara->cCertStore; dwStoreIdx++) {
            pXchgCert = CertFindCertificateInStore(
                pDecryptPara->rghCertStore[dwStoreIdx],
                pDecryptPara->dwMsgAndCertEncodingType,
                0,                                          // dwFindFlags
                CERT_FIND_CERT_ID,
                &pKeyTrans->RecipientId,
                NULL                                        // pPrevCertContext
                );

            if (pXchgCert) {
                CMSG_CTRL_KEY_TRANS_DECRYPT_PARA Para;
                BOOL fDidCryptAcquire;
                memset(&Para, 0, sizeof(Para));
                Para.cbSize = sizeof(Para);

                fResult = CryptAcquireCertificatePrivateKey(
                    pXchgCert,
                    CRYPT_ACQUIRE_USE_PROV_INFO_FLAG,
                    NULL,                               // pvReserved
                    &Para.hCryptProv,
                    &Para.dwKeySpec,
                    &fDidCryptAcquire
                    );
                if (fResult) {
                    Para.pKeyTrans = pKeyTrans;
                    Para.dwRecipientIndex = dwRecipientIdx;
                    fResult = CryptMsgControl(
                        hMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_KEY_TRANS_DECRYPT,
                        &Para
                        );
                    if (fDidCryptAcquire) {
                        DWORD dwErr = GetLastError();
                        CryptReleaseContext(Para.hCryptProv, 0);
                        SetLastError(dwErr);
                    }
                    if (fResult) {
                        if (ppXchgCert)
                            *ppXchgCert = pXchgCert;
                        else
                            CertFreeCertificateContext(pXchgCert);
                        goto CommonReturn;
                    } else
                        goto ErrorReturn;
                }
                CertFreeCertificateContext(pXchgCert);
                pXchgCert = NULL;
            }
        }
        SCAFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }
    SetLastError((DWORD) CRYPT_E_NO_DECRYPT_CERT);

ErrorReturn:
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    if (ppXchgCert)
        *ppXchgCert = NULL;
    fResult = FALSE;

CommonReturn:
    if (pRecipientInfo)
        SCAFree(pRecipientInfo);

    return fResult;
}

#else

//+-------------------------------------------------------------------------
// Get a certificate with a key provider property for one of the message's
// recipients and use to decrypt the message.
//--------------------------------------------------------------------------
static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    BOOL fResult;
    PCERT_INFO pRecipientId = NULL;
    PCCERT_CONTEXT pXchgCert = NULL;
    DWORD cRecipient;
    DWORD cbData;
    DWORD dwRecipientIdx;
    DWORD dwStoreIdx;

    // Get # of recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (cRecipient == 0) {
        SetLastError((DWORD) CRYPT_E_RECIPIENT_NOT_FOUND);
        goto ErrorReturn;
    }

    // Loop through the recipients in the message until we find a
    // recipient cert in one of the stores with either the
    // CERT_KEY_CONTEXT_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID.
    for (dwRecipientIdx = 0; dwRecipientIdx < cRecipient; dwRecipientIdx++) {
        // Allocate and get the CERT_INFO containing the RecipientId 
        // (Issuer and SerialNumber)
        pRecipientId = (PCERT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_RECIPIENT_INFO_PARAM,
            dwRecipientIdx
            );
        if (pRecipientId == NULL) goto ErrorReturn;
        for (dwStoreIdx = 0;
                dwStoreIdx < pDecryptPara->cCertStore; dwStoreIdx++) {
            pXchgCert = CertGetSubjectCertificateFromStore(
                pDecryptPara->rghCertStore[dwStoreIdx],
                pDecryptPara->dwMsgAndCertEncodingType,
                pRecipientId
                );
            if (pXchgCert) {
                CMSG_CTRL_DECRYPT_PARA Para;
                BOOL fDidCryptAcquire;
                Para.cbSize = sizeof(CMSG_CTRL_DECRYPT_PARA);
                fResult = CryptAcquireCertificatePrivateKey(
                    pXchgCert,
                    CRYPT_ACQUIRE_USE_PROV_INFO_FLAG,
                    NULL,                               // pvReserved
                    &Para.hCryptProv,
                    &Para.dwKeySpec,
                    &fDidCryptAcquire
                    );
                if (fResult) {
                    Para.dwRecipientIndex = dwRecipientIdx;
                    fResult = CryptMsgControl(
                        hMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_DECRYPT,
                        &Para
                        );
                    if (fDidCryptAcquire) {
                        DWORD dwErr = GetLastError();
                        CryptReleaseContext(Para.hCryptProv, 0);
                        SetLastError(dwErr);
                    }
                    if (fResult) {
                        if (ppXchgCert)
                            *ppXchgCert = pXchgCert;
                        else
                            CertFreeCertificateContext(pXchgCert);
                        goto CommonReturn;
                    } else
                        goto ErrorReturn;
                }
                CertFreeCertificateContext(pXchgCert);
                pXchgCert = NULL;
            }
        }
        SCAFree(pRecipientId);
        pRecipientId = NULL;
    }
    SetLastError((DWORD) CRYPT_E_NO_DECRYPT_CERT);

ErrorReturn:
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    if (ppXchgCert)
        *ppXchgCert = NULL;
    fResult = FALSE;

CommonReturn:
    if (pRecipientId)
        SCAFree(pRecipientId);

    return fResult;
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_CERT_INFO_PARAM or CMSG_RECIPIENT_INFO_PARAM
// from the message
//--------------------------------------------------------------------------
static void * AllocAndMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    )
{
    BOOL fResult;
    void *pvData;
    DWORD cbData;

    // First get the length of the CertId's CERT_INFO
    cbData = 0;
    CryptMsgGetParam(
        hMsg,
        dwParamType,
        dwIndex,
        NULL,                   // pvData
        &cbData
        );
    if (cbData == 0) return NULL;
    pvData = SCAAlloc(cbData);
    if (pvData == NULL) return NULL;

    fResult = CryptMsgGetParam(
        hMsg,
        dwParamType,
        dwIndex,
        pvData,
        &cbData
        );
    if (fResult)
        return pvData;
    else {
        SCAFree(pvData);
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\revfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       revfunc.cpp
//
//  Contents:   Certificate Revocation Dispatch Functions
//
//  Functions:  I_CertRevFuncDllMain
//              CertVerifyRevocation
//
//  History:    12-Dec-96    philh   created
//              11-Mar-97    philh   changed signature of CertVerifyRevocation
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

static HCRYPTOIDFUNCSET hRevFuncSet;

typedef BOOL (WINAPI *PFN_CERT_DLL_VERIFY_REVOCATION)(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertRevFuncDllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hRevFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                0)))                                // dwFlags
            goto CryptInitOIDFunctionSetError;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
}

static inline void ZeroRevStatus(OUT PCERT_REVOCATION_STATUS pRevStatus)
{
    pRevStatus->dwIndex = 0;
    pRevStatus->dwError = 0;
    pRevStatus->dwReason = 0;
}

// Remember the first "interesting" error. *pdwError is initialized to
// CRYPT_E_NO_REVOCATION_DLL.
static void UpdateNoRevocationCheckStatus(
    IN PCERT_REVOCATION_STATUS pRevStatus,
    IN OUT DWORD *pdwError,
    IN OUT DWORD *pdwReason
    )
{
    if (pRevStatus->dwError &&
            (*pdwError == (DWORD) CRYPT_E_NO_REVOCATION_DLL ||
                *pdwError == (DWORD) CRYPT_E_NO_REVOCATION_CHECK)) {
        *pdwError = pRevStatus->dwError;
        *pdwReason = pRevStatus->dwReason;
    }
}

static BOOL VerifyDefaultRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult;
    DWORD dwError = (DWORD) CRYPT_E_NO_REVOCATION_DLL;
    DWORD dwReason = 0;
    LPWSTR pwszDllList;       // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    // Iterate through the installed default functions.
    // Setting pwszDll to NULL searches the installed list. Setting
    // hFuncAddr to NULL starts the search at the beginning.
    hFuncAddr = NULL;
    while (CryptGetDefaultOIDFunctionAddress(
                hRevFuncSet,
                dwEncodingType,
                NULL,               // pwszDll
                0,                  // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
        ZeroRevStatus(pRevStatus);
        fResult = ((PFN_CERT_DLL_VERIFY_REVOCATION) pvFuncAddr)(
                dwEncodingType,
                dwRevType,
                cContext,
                rgpvContext,
                dwFlags,
                pRevPara,
                pRevStatus);
        if (fResult || CRYPT_E_REVOKED == pRevStatus->dwError ||
                0 < pRevStatus->dwIndex) {
            // All contexts successfully checked, one of the contexts
            // was revoked or successfully able to check at least one
            // of the contexts.
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            goto CommonReturn;
        } else
            // Unable to check revocation for this installed
            // function. However, remember any "interesting"
            // errors such as, offline.
            UpdateNoRevocationCheckStatus(pRevStatus, &dwError, &dwReason);
    }

    if (!CryptGetDefaultOIDDllList(
            hRevFuncSet,
            dwEncodingType,
            NULL,               // pszDllList
            &cchDllList)) goto GetDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!CryptGetDefaultOIDDllList(
            hRevFuncSet,
            dwEncodingType,
            pwszDllList,
            &cchDllList)) goto GetDllListError;

    for (; 0 != (cchDll = wcslen(pwszDllList)); pwszDllList += cchDll + 1) {
        if (CryptGetDefaultOIDFunctionAddress(
                hRevFuncSet,
                dwEncodingType,
                pwszDllList,
                0,              // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroRevStatus(pRevStatus);
            fResult = ((PFN_CERT_DLL_VERIFY_REVOCATION) pvFuncAddr)(
                    dwEncodingType,
                    dwRevType,
                    cContext,
                    rgpvContext,
                    dwFlags,
                    pRevPara,
                    pRevStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            if (fResult || CRYPT_E_REVOKED == pRevStatus->dwError ||
                    0 < pRevStatus->dwIndex)
                // All contexts successfully checked, one of the contexts
                // was revoked or successfully able to check at least one
                // of the contexts.
                goto CommonReturn;
            else
                // Unable to check revocation for this registered
                // function. However, remember any "interesting"
                // errors such as, offline.
                UpdateNoRevocationCheckStatus(pRevStatus, &dwError, &dwReason);
        }
    }

    goto ErrorReturn;

CommonReturn:
    return fResult;
ErrorReturn:
    pRevStatus->dwIndex = 0;
    pRevStatus->dwError = dwError;
    pRevStatus->dwReason = dwReason;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDllListError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Verifies the array of contexts for revocation. The dwRevType parameter
//  indicates the type of the context data structure passed in rgpvContext.
//  Currently only the revocation of certificates is defined.
//
//  If the CERT_VERIFY_REV_CHAIN_FLAG flag is set, then, CertVerifyRevocation
//  is verifying a chain of certs where, rgpvContext[i + 1] is the issuer
//  of rgpvContext[i]. Otherwise, CertVerifyRevocation makes no assumptions
//  about the order of the contexts.
//
//  To assist in finding the issuer, the pRevPara may optionally be set. See
//  the CERT_REVOCATION_PARA data structure for details.
//
//  The contexts must contain enough information to allow the
//  installable or registered revocation DLLs to find the revocation server. For
//  certificates, this information would normally be conveyed in an
//  extension such as the IETF's AuthorityInfoAccess extension.
//
//  CertVerifyRevocation returns TRUE if all of the contexts were successfully
//  checked and none were revoked. Otherwise, returns FALSE and updates the
//  returned pRevStatus data structure as follows:
//    dwIndex
//      Index of the first context that was revoked or unable to
//      be checked for revocation
//    dwError
//      Error status. LastError is also set to this error status.
//      dwError can be set to one of the following error codes defined
//      in winerror.h:
//        ERROR_SUCCESS - good context
//        CRYPT_E_REVOKED - context was revoked. dwReason contains the
//           reason for revocation
//        CRYPT_E_REVOCATION_OFFLINE - unable to connect to the
//           revocation server
//        CRYPT_E_NOT_IN_REVOCATION_DATABASE - the context to be checked
//           was not found in the revocation server's database.
//        CRYPT_E_NO_REVOCATION_CHECK - the called revocation function
//           wasn't able to do a revocation check on the context
//        CRYPT_E_NO_REVOCATION_DLL - no installed or registered Dll was
//           found to verify revocation
//    dwReason
//      The dwReason is currently only set for CRYPT_E_REVOKED and contains
//      the reason why the context was revoked. May be one of the following
//      CRL reasons defined by the CRL Reason Code extension ("2.5.29.21")
//          CRL_REASON_UNSPECIFIED              0
//          CRL_REASON_KEY_COMPROMISE           1
//          CRL_REASON_CA_COMPROMISE            2
//          CRL_REASON_AFFILIATION_CHANGED      3
//          CRL_REASON_SUPERSEDED               4
//          CRL_REASON_CESSATION_OF_OPERATION   5
//          CRL_REASON_CERTIFICATE_HOLD         6
//
//  For each entry in rgpvContext, CertVerifyRevocation iterates
//  through the CRYPT_OID_VERIFY_REVOCATION_FUNC
//  function set's list of installed DEFAULT functions.
//  CryptGetDefaultOIDFunctionAddress is called with pwszDll = NULL. If no
//  installed functions are found capable of doing the revocation verification,
//  CryptVerifyRevocation iterates through CRYPT_OID_VERIFY_REVOCATION_FUNC's
//  list of registered DEFAULT Dlls. CryptGetDefaultOIDDllList is called to
//  get the list. CryptGetDefaultOIDFunctionAddress is called to load the Dll.
//
//  The called functions have the same signature as CertVerifyRevocation. A
//  called function returns TRUE if it was able to successfully check all of
//  the contexts and none were revoked. Otherwise, the called function returns
//  FALSE and updates pRevStatus. dwIndex is set to the index of
//  the first context that was found to be revoked or unable to be checked.
//  dwError and LastError are updated. For CRYPT_E_REVOKED, dwReason
//  is updated. Upon input to the called function, dwIndex, dwError and
//  dwReason have been zero'ed. cbSize has been checked to be >=
//  sizeof(CERT_REVOCATION_STATUS).
//  
//  If the called function returns FALSE, and dwError isn't set to
//  CRYPT_E_REVOKED, then, CertVerifyRevocation either continues on to the
//  next DLL in the list for a returned dwIndex of 0 or for a returned
//  dwIndex > 0, restarts the process of finding a verify function by
//  advancing the start of the context array to the returned dwIndex and
//  decrementing the count of remaining contexts.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult;
    DWORD dwIndex;

    assert(pRevStatus->cbSize >= sizeof(CERT_REVOCATION_STATUS));
    if (pRevStatus->cbSize < sizeof(CERT_REVOCATION_STATUS))
        goto InvalidArg;

    dwIndex = 0;
    while (dwIndex < cContext) {
        fResult = VerifyDefaultRevocation(
                dwEncodingType,
                dwRevType,
                cContext - dwIndex,
                &rgpvContext[dwIndex],
                dwFlags,
                pRevPara,
                pRevStatus);
        if (fResult)
            // All contexts successfully checked.
            break;
        else if (CRYPT_E_REVOKED == pRevStatus->dwError ||
                0 == pRevStatus->dwIndex) {
            // One of the contexts was revoked or unable to check the
            // dwIndex context.
            pRevStatus->dwIndex += dwIndex;
            SetLastError(pRevStatus->dwError);
            break;
        } else
            // Advance past the checked contexts
            dwIndex += pRevStatus->dwIndex;
    }

    if (dwIndex >= cContext) {
        // Able to check all the contexts
        fResult = TRUE;
        ZeroRevStatus(pRevStatus);
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\resource.h ===
#undef RESBASE
#define RESBASE 6000    // defined in common\oak\inc\resbases.h as RESBASE_crypt32

#define         IDS_ROOT_MSG_BOX_TITLE              (RESBASE + 100)
#define         IDS_ROOT_MSG_BOX_SUBJECT            (RESBASE + 110)
#define         IDS_ROOT_MSG_BOX_ISSUER             (RESBASE + 120)
#define         IDS_ROOT_MSG_BOX_SELF_ISSUED        (RESBASE + 121)
#define         IDS_ROOT_MSG_BOX_SERIAL_NUMBER      (RESBASE + 130)
#define         IDS_ROOT_MSG_BOX_SHA1_THUMBPRINT    (RESBASE + 140)
#define         IDS_ROOT_MSG_BOX_MD5_THUMBPRINT     (RESBASE + 150)
#define         IDS_ROOT_MSG_BOX_TIME_VALIDITY      (RESBASE + 160)
#define         IDS_ROOT_MSG_BOX_ADD_ACTION         (RESBASE + 170)
#define         IDS_ROOT_MSG_BOX_DELETE_ACTION      (RESBASE + 180)
#define         IDS_ROOT_MSG_BOX_DELETE_UNKNOWN_PROT_ROOTS (RESBASE + 190)

#define			IDS_BASIC_CONS2_PATH				(RESBASE + 1002)
#define			IDS_BASIC_CONS2_NONE				(RESBASE + 1003)
#define			IDS_NONE							(RESBASE + 1004)
#define			IDS_SUB_EE							(RESBASE + 1005)
#define			IDS_SUB_CA							(RESBASE + 1006)
#define			IDS_UNSPECIFIED						(RESBASE + 1007)
#define			IDS_KEY_COMPROMISE					(RESBASE + 1008)
#define			IDS_CA_COMPROMISE					(RESBASE + 1009)
#define			IDS_AFFILIATION_CHANGED				(RESBASE + 1010)
#define			IDS_SUPERSEDED						(RESBASE + 1011)
#define			IDS_CESSATION_OF_OPERATION			(RESBASE + 1012)
#define			IDS_CERTIFICATE_HOLD				(RESBASE + 1013)
#define			IDS_UNKNOWN_VALUE					(RESBASE + 1014)
#define			IDS_REMOVE_FROM_CRL					(RESBASE + 1015)
#define         IDS_SUBTREE_CONSTRAINT              (RESBASE + 1016)
#define         IDS_NO_INFO                         (RESBASE + 1017)
#define         IDS_OTHER_NAME                      (RESBASE + 1018)
#define         IDS_RFC822_NAME                     (RESBASE + 1019)
#define         IDS_DNS_NAME                        (RESBASE + 1020)
#define         IDS_X400_ADDRESS                    (RESBASE + 1021)
#define         IDS_DIRECTORY_NAME                  (RESBASE + 1022)
#define         IDS_EDI_PARTY_NAME                  (RESBASE + 1023)
#define         IDS_URL                             (RESBASE + 1024)
#define         IDS_IP_ADDRESS                      (RESBASE + 1025)
#define         IDS_REGISTERED_ID                   (RESBASE + 1026)
#define         IDS_ALT_NAME_ENTRY_UNKNOWN          (RESBASE + 1027)
#define         IDS_ALT_NAME_ENTRY                  (RESBASE + 1030)
#define         IDS_YES                             (RESBASE + 1031)
#define         IDS_NO                              (RESBASE + 1032)
#define         IDS_AVAILABLE                       (RESBASE + 1033)
#define         IDS_NOT_AVAILABLE                   (RESBASE + 1034)
#define         IDS_SPC_FINANCIAL_NOT_AVAIL         (RESBASE + 1035)
#define         IDS_MIME_CAPABILITY                 (RESBASE + 1036)
#define         IDS_SPC_FINANCIAL_AVAIL             (RESBASE + 1037)
#define         IDS_AUTH_KEY_ID                     (RESBASE + 1038)
#define         IDS_AUTH_CERT_NUMBER                (RESBASE + 1039)
#define         IDS_AUTH_CERT_ISSUER                (RESBASE + 1040)
#define         IDS_DIG_SIG                         (RESBASE + 1041)
#define         IDS_KEY_ENCIPHERMENT                (RESBASE + 1042)
#define         IDS_DATA_ENCIPHERMENT               (RESBASE + 1043)
#define         IDS_KEY_AGREEMENT                   (RESBASE + 1044)
#define         IDS_CERT_SIGN                       (RESBASE + 1045)
#define         IDS_OFFLINE_CRL_SIGN                (RESBASE + 1046)
#define         IDS_CRL_SIGN                        (RESBASE + 1047)
#define         IDS_DECIPHER_ONLY                   (RESBASE + 1048)
#define         IDS_NON_REPUDIATION                 (RESBASE + 1049)
#define         IDS_ENCIPHER_ONLY                   (RESBASE + 1050)
#define         IDS_MIME_CAPABILITY_NO_PARAM        (RESBASE + 1052)
#define         IDS_ENHANCED_KEY_USAGE              (RESBASE + 1053)
#define         IDS_NO_ALT_NAME                     (RESBASE + 1054)
#define         IDS_UNKNOWN_ACCESS_METHOD           (RESBASE + 1055)
#define         IDS_AUTHORITY_ACCESS_INFO           (RESBASE + 1056)
#define         IDS_CRL_REASON                      (RESBASE + 1057)
#define         IDS_UNKNOWN_KEY_USAGE               (RESBASE + 1058)
#define         IDS_BIT_BLOB                        (RESBASE + 1059)
#define         IDS_SUNDAY                          (RESBASE + 1060)
#define         IDS_MONDAY                          IDS_SUNDAY+1  
#define         IDS_TUESDAY                         IDS_MONDAY+1  
#define         IDS_WED                             IDS_TUESDAY+1 
#define         IDS_THUR                            IDS_WED+1     
#define         IDS_FRI                             IDS_THUR+1    
#define         IDS_SAT                             IDS_FRI+1     
#define         IDS_JAN                             (RESBASE + 1070)
#define         IDS_FEB                             IDS_JAN+1   
#define         IDS_MAR                             IDS_FEB+1   
#define         IDS_APR                             IDS_MAR+1   
#define         IDS_MAY                             IDS_APR+1   
#define         IDS_JUNE                            IDS_MAY+1   
#define         IDS_JULY                            IDS_JUNE+1  
#define         IDS_AUG                             IDS_JULY+1  
#define         IDS_SEP                             IDS_AUG+1   
#define         IDS_OCT                             IDS_SEP+1   
#define         IDS_NOV                             IDS_OCT+1   
#define         IDS_DEC                             IDS_NOV+1  
#define         IDS_FILE_TIME                       (RESBASE + 1085)
#define         IDS_FILE_TIME_DWORD                 (RESBASE + 1086)
#define         IDS_KEY_ATTR_ID                     (RESBASE + 1087)
#define         IDS_KEY_ATTR_USAGE                  (RESBASE + 1088)
#define         IDS_KEY_ATTR_AFTER                  (RESBASE + 1089)
#define         IDS_KEY_ATTR_BEFORE                 (RESBASE + 1090)
#define         IDS_KEY_RES_USAGE                   (RESBASE + 1091)
#define         IDS_KEY_RES_ID                      (RESBASE + 1092)
#define         IDS_CRL_DIST_FULL_NAME              (RESBASE + 1093)
#define         IDS_CRL_DIST_ISSUER_RDN             (RESBASE + 1094)
#define         IDS_DWORD                           (RESBASE + 1095)
#define         IDS_UNKNOWN_CRL_REASON              (RESBASE + 1096)
#define         IDS_CRL_DIST_NAME                   (RESBASE + 1097)
#define         IDS_CRL_DIST_REASON                 (RESBASE + 1098)
#define         IDS_CRL_DIST_ENTRY                  (RESBASE + 1099)
#define         IDS_CRL_DIST_ISSUER                 (RESBASE + 1100)
#define         IDS_POLICY_QUALIFIER                (RESBASE + 1101)
#define         IDS_POLICY_QUALIFIER_NO_BLOB        (RESBASE + 1102)
#define         IDS_POLICY_QUALIFIER_INFO           (RESBASE + 1103)
#define         IDS_CERT_POLICY_NO_QUA              (RESBASE + 1104)
#define         IDS_CERT_POLICY                     (RESBASE + 1105)
#define         IDS_SPC_URL_LINK                    (RESBASE + 1107)
#define         IDS_SPC_MONIKER_LINK                (RESBASE + 1108)
#define         IDS_SPC_FILE_LINK                   (RESBASE + 1109)
#define         IDS_SPC_LINK_UNKNOWN                (RESBASE + 1110)
#define         IDS_IMAGE_LINK                      (RESBASE + 1111)
#define         IDS_IMAGE_BITMAP                    (RESBASE + 1112)
#define         IDS_IMAGE_METAFILE                  (RESBASE + 1113)
#define         IDS_IMAGE_ENHANCED_METAFILE         (RESBASE + 1114)
#define         IDS_IMAGE_GIFFILE                   (RESBASE + 1115)
#define         IDS_AGENCY_POLICY_INFO              (RESBASE + 1116)
#define         IDS_AGENCY_POLICY_DSPLY             (RESBASE + 1117)
#define         IDS_AGENCY_LOGO_LINK                (RESBASE + 1118)
#define         IDS_SPC_OBJECT_NO_BLOB              (RESBASE + 1119)
#define         IDS_AGENCY_LOGO_IMAGE               (RESBASE + 1120)
#define         IDS_BASIC_CONS2_PATH_MULTI          (RESBASE + 1121)
#define         IDS_BASIC_CONS2_NONE_MULTI          (RESBASE + 1122)
#define         IDS_SUBTREE_CONSTRAINT_MULTI        (RESBASE + 1123)
#define         IDS_SPC_FINANCIAL_AVAIL_MULTI       (RESBASE + 1124)
#define         IDS_SPC_FINANCIAL_NOT_AVAIL_MULTI   (RESBASE + 1125)
#define         IDS_MIME_CAPABILITY_MULTI           (RESBASE + 1126)
#define         IDS_MIME_CAPABILITY_NO_PARAM_MULTI  (RESBASE + 1127)
#define         IDS_AUTHORITY_ACCESS_INFO_MULTI     (RESBASE + 1128)
#define         IDS_AUTHORITY_ACCESS_NO_METHOD_MULTI    (RESBASE + 1129)
#define         IDS_KEY_ATTR_ID_MULTI               (RESBASE + 1130)
#define         IDS_KEY_ATTR_USAGE_MULTI            (RESBASE + 1131)
#define         IDS_KEY_ATTR_BEFORE_MULTI           (RESBASE + 1132)
#define         IDS_KEY_ATTR_AFTER_MULTI            (RESBASE + 1133)
#define         IDS_KEY_RES_ID_MULTI                (RESBASE + 1134)
#define         IDS_KEY_RES_USAGE_MULTI             (RESBASE + 1135)
#define         IDS_CRL_DIST_FULL_NAME_MULTI        (RESBASE + 1136)
#define         IDS_CRL_DIST_NAME_MULTI             (RESBASE + 1137)
#define         IDS_CRL_DIST_REASON_MULTI           (RESBASE + 1138)
#define         IDS_CRL_DIST_ISSUER_MULTI           (RESBASE + 1139)
#define         IDS_CRL_DIST_ENTRY_MULTI            (RESBASE + 1140)
#define         IDS_POLICY_QUALIFIER_MULTI          (RESBASE + 1141)
#define         IDS_POLICY_QUALIFIER_INFO_MULTI     (RESBASE + 1142)
#define         IDS_CERT_POLICY_MULTI               (RESBASE + 1143)
#define         IDS_CERT_POLICY_NO_QUA_MULTI        (RESBASE + 1144)
#define         IDS_SPC_MONIKER_LINK_MULTI          (RESBASE + 1145)
#define         IDS_IMAGE_LINK_MULTI                (RESBASE + 1146)
#define         IDS_IMAGE_BITMAP_MULTI              (RESBASE + 1147)
#define         IDS_IMAGE_METAFILE_MULTI            (RESBASE + 1148)
#define         IDS_IMAGE_ENHANCED_METAFILE_MULTI   (RESBASE + 1149)
#define         IDS_IMAGE_GIFFILE_MULTI             (RESBASE + 1150)
#define         IDS_AGENCY_POLICY_INFO_MULTI        (RESBASE + 1151)
#define         IDS_AGENCY_POLICY_DSPLY_MULTI       (RESBASE + 1152)
#define         IDS_AGENCY_LOGO_IMAGE_MULTI         (RESBASE + 1153)
#define         IDS_AGENCY_LOGO_LINK_MULTI          (RESBASE + 1154)
#define         IDS_AUTH_CERT_ISSUER_MULTI          (RESBASE + 1155)
#define         IDS_AUTHORITY_ACCESS_NO_METHOD      (RESBASE + 1156)
#define         IDS_SPC_OBJECT_DATA                 (RESBASE + 1157)
#define         IDS_SPC_OBJECT_CLASS                (RESBASE + 1158)
#define         IDS_ONE_TAB                         (RESBASE + 1159)
#define         IDS_TWO_TABS                        (RESBASE + 1160)
#define         IDS_THREE_TABS                      (RESBASE + 1161)
#define         IDS_FOUR_TABS                       (RESBASE + 1162)
#define	        IDS_FRMT_SPACE						(RESBASE + 1170)
#define	        IDS_FRMT_A							(RESBASE + 1171)
#define	        IDS_FRMT_ZERO						(RESBASE + 1172)
#define	        IDS_FRMT_HEX						(RESBASE + 1173)
#define	        IDS_DIRECTORY_NAME_MULTI            (RESBASE + 1174)

// CSP resources in range 7500 ... 7600
// THESE RESOURCES ARE LOADED BY THE MS CSPs SO THE
// DEFINE VALUES MAY NOT CHANGE UNLESS THEY ARE
// CHANGED IN THE CSPs
#define         IDS_CSP_RSA_SIG_DESCR               (RESBASE + 1501)
#define         IDS_CSP_RSA_EXCH_DESCR              (RESBASE + 1502)
#define         IDS_CSP_IMPORT_SIMPLE               (RESBASE + 1503)
#define         IDS_CSP_SIGNING_E                   (RESBASE + 1504)
#define         IDS_CSP_CREATE_RSA_SIG              (RESBASE + 1505)
#define         IDS_CSP_CREATE_RSA_EXCH             (RESBASE + 1506)
#define         IDS_CSP_DSS_SIG_DESCR               (RESBASE + 1507)
#define         IDS_CSP_DSS_EXCH_DESCR              (RESBASE + 1508)
#define         IDS_CSP_CREATE_DSS_SIG              (RESBASE + 1509)
#define         IDS_CSP_CREATE_DH_EXCH              (RESBASE + 1510)
#define         IDS_CSP_IMPORT_E_PUB                (RESBASE + 1511)
#define         IDS_CSP_MIGR                        (RESBASE + 1512)
#define         IDS_CSP_DELETE_SIG                  (RESBASE + 1513)
#define         IDS_CSP_DELETE_KEYX                 (RESBASE + 1514)
#define         IDS_CSP_DELETE_SIG_MIGR             (RESBASE + 1515)
#define         IDS_CSP_DELETE_KEYX_MIGR            (RESBASE + 1516)
#define         IDS_CSP_SIGNING_S                   (RESBASE + 1517)
#define         IDS_CSP_EXPORT_E_PRIV               (RESBASE + 1518)
#define         IDS_CSP_EXPORT_S_PRIV               (RESBASE + 1519)
#define         IDS_CSP_IMPORT_E_PRIV               (RESBASE + 1520)
#define         IDS_CSP_IMPORT_S_PRIV               (RESBASE + 1521)

#include "oidinfo.h"
// Note IDS_EXT_*                          in range 8000 .. 8499
// Note IDS_ENHKEY_*                       in range 8500 .. 8999
// Note IDS_SYS_NAME_                      in range 9000 .. 9099
// Note IDS_PHY_NAME_                      in range 9100 .. 9199
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\scrdcert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       scrdcert.cpp
//
//  Contents:   Smart Card Certificate API
//
//  History:    11-24-1997    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   I_CryptRegisterSmartCardStore
//
//  Synopsis:   register smart card store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptRegisterSmartCardStore (
       IN LPCWSTR pwszCardName,
       IN OPTIONAL LPCWSTR pwszProvider,
       IN OPTIONAL DWORD dwProviderType,
       IN OPTIONAL LPCWSTR pwszContainer,
       IN DWORD dwFlags
       )
{
    BOOL                     fResult;
    DWORD                    cw;
    CHAR                     szProviderType[MAX_PROVIDER_TYPE_STRLEN];
    WCHAR                    wszProviderType[MAX_PROVIDER_TYPE_STRLEN];
    LPWSTR                   pwszOpenFilter;
    DWORD                    dwRegisterFlags = 0;
    CERT_SYSTEM_STORE_INFO   cssi;
    CERT_PHYSICAL_STORE_INFO cpsi;
    
    cw = wcslen( pwszCardName ) + 1;
    
    if ( pwszProvider == NULL )
    {
        pwszProvider = MS_BASE_PROVIDER;
    }
    
    cw += wcslen( pwszProvider ) + 1;
    cw += MAX_PROVIDER_TYPE_STRLEN + 1;
    
    if ( pwszContainer == NULL )
    {
        pwszContainer = pwszCardName;
    }
    
    cw += wcslen( pwszContainer ) + 1;
    
    pwszOpenFilter = new WCHAR [cw];
    if ( pwszOpenFilter == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }
    
    _ultoa( dwProviderType, szProviderType, 10 );
    
    MultiByteToWideChar(
         CP_ACP,
         0,
         szProviderType,
         MAX_PROVIDER_TYPE_STRLEN,
         wszProviderType,
         MAX_PROVIDER_TYPE_STRLEN
         );
    
    wcscpy( pwszOpenFilter, pwszCardName );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, pwszProvider );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, wszProviderType );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, pwszContainer );
    
    memset( &cssi, 0, sizeof( cssi ) );
    cssi.cbSize = sizeof( cssi );
           
    // BUGBUG: What about the localized name property?                      
    CertRegisterSystemStore(
        SMART_CARD_SYSTEM_STORE,
        CERT_SYSTEM_STORE_CURRENT_USER,
        &cssi,
        NULL
        );
    
    memset( &cpsi, 0, sizeof( cpsi ) );
    cpsi.cbSize = sizeof( cpsi );
    cpsi.pszOpenStoreProvider = sz_CERT_STORE_PROV_SMART_CARD;
    cpsi.OpenParameters.cbData = cw * sizeof( WCHAR );
    cpsi.OpenParameters.pbData = (LPBYTE)pwszOpenFilter;
    cpsi.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
    cpsi.dwFlags |= CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG;
    
    if ( !( dwFlags & SMART_CARD_STORE_REPLACE_EXISTING ) )
    {
        dwRegisterFlags |= CERT_STORE_CREATE_NEW_FLAG;
    }
          
    fResult = CertRegisterPhysicalStore(
                  SMART_CARD_SYSTEM_STORE,
                  dwRegisterFlags | CERT_SYSTEM_STORE_CURRENT_USER,
                  pwszCardName,
                  &cpsi,
                  NULL
                  );
                  
    delete pwszOpenFilter;
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptUnregisterSmartCardStore
//
//  Synopsis:   unregister a smart card store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptUnregisterSmartCardStore (
       IN LPCWSTR pwszCardName
       )
{
    return( CertUnregisterPhysicalStore(
                SMART_CARD_SYSTEM_STORE,
                CERT_SYSTEM_STORE_CURRENT_USER,
                pwszCardName
                ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindSmartCardCertInStore
//
//  Synopsis:   find a smart card certificate matching the given criteria
//
//----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI
I_CryptFindSmartCardCertInStore (
       IN HCERTSTORE hStore,
       IN PCCERT_CONTEXT pPrevCert,
       IN OPTIONAL PSMART_CARD_CERT_FIND_DATA pFindData,
       IN OUT OPTIONAL PCRYPT_DATA_BLOB* ppSmartCardData
       )
{
    BOOL             fResult;
    BOOL             fFound = FALSE;
    PCCERT_CONTEXT   pCertContext = pPrevCert;
    DWORD            cb;
    PCRYPT_DATA_BLOB pSmartCardData = NULL;
    DWORD            dwPropId = CERT_SMART_CARD_DATA_PROP_ID;
    
    assert( hStore != NULL );
    
    while ( fFound == FALSE )
    {
        pCertContext = CertFindCertificateInStore(
                           hStore,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           0,
                           CERT_FIND_PROPERTY,
                           (const void *)&dwPropId,
                           pCertContext
                           );
                           
        if ( ( ppSmartCardData != NULL ) && ( *ppSmartCardData != NULL ) )
        {
            LocalFree( (HLOCAL)*ppSmartCardData );
            *ppSmartCardData = NULL;
        }
                                                       
        if ( pCertContext != NULL )
        {
            if ( pFindData != NULL )
            {
                PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
                
                fResult = CertGetCertificateContextProperty(
                              pCertContext,
                              CERT_KEY_PROV_INFO_PROP_ID,
                              NULL,
                              &cb
                              );
                              
                if ( fResult == TRUE )
                {
                    pKeyProvInfo = (PCRYPT_KEY_PROV_INFO)new BYTE [cb];
                    if ( pKeyProvInfo != NULL )
                    {
                        fResult = CertGetCertificateContextProperty(
                                      pCertContext,
                                      CERT_KEY_PROV_INFO_PROP_ID,
                                      pKeyProvInfo,
                                      &cb  
                                      );
                    }
                    else
                    {
                        fResult = FALSE;
                    }
                }
                
                if ( fResult == TRUE )
                {
                    fFound = TRUE;
                    
                    if ( ( pFindData->pwszProvider != NULL ) &&
                         ( _wcsicmp( 
                               pKeyProvInfo->pwszProvName, 
                               pFindData->pwszProvider
                               ) != 0 ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->dwProviderType != 0 ) &&
                         ( pKeyProvInfo->dwProvType != 
                           pFindData->dwProviderType ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->pwszContainer != NULL ) &&
                         ( _wcsicmp( 
                               pKeyProvInfo->pwszContainerName, 
                               pFindData->pwszContainer
                               ) != 0 ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->dwKeySpec != 0 ) &&
                         ( pKeyProvInfo->dwKeySpec != 
                           pFindData->dwKeySpec ) )
                    {
                        fFound = FALSE;
                    }
                }
                
                delete (LPBYTE)pKeyProvInfo;
            }
            else
            {
                fFound = TRUE;
            }
        }
        else
        {
            fFound = TRUE;
        }
    }
    
    assert( fFound == TRUE );
    
    if ( ( ppSmartCardData != NULL ) && ( pCertContext != NULL ) )
    {
        fResult = CertGetCertificateContextProperty(
                      pCertContext,
                      CERT_SMART_CARD_DATA_PROP_ID,
                      NULL,
                      &cb
                      );
                      
        if ( fResult == TRUE )
        {
            pSmartCardData = (PCRYPT_DATA_BLOB)LocalAlloc( 
                                                    GPTR, 
                                                    cb + sizeof( CRYPT_DATA_BLOB )
                                                    );
                                          
            if ( pSmartCardData != NULL )
            {
                pSmartCardData->cbData = cb;
                pSmartCardData->pbData = (LPBYTE)pSmartCardData + sizeof( CRYPT_DATA_BLOB );
                
                fResult = CertGetCertificateContextProperty(
                              pCertContext,
                              CERT_SMART_CARD_DATA_PROP_ID,
                              pSmartCardData->pbData,
                              &cb
                              );
            }
            else
            {
                fResult = FALSE;
            }
        }
        
        if ( fResult == TRUE )
        {
            *ppSmartCardData = pSmartCardData;
        }
        else
        {
            if ( pSmartCardData != NULL )
            {
                LocalFree( (HLOCAL)pSmartCardData );
            }
            
            CertFreeCertificateContext( pCertContext );
            pCertContext = NULL;
        }
    }
    
    return( pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptAddSmartCardCertToStore
//
//  Synopsis:   add a smart card certificate to the specified store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptAddSmartCardCertToStore (
       IN HCERTSTORE hStore,
       IN PCRYPT_DATA_BLOB pEncodedCert,
       IN OPTIONAL LPWSTR pwszCertFriendlyName,
       IN PCRYPT_DATA_BLOB pSmartCardData,
       IN PCRYPT_KEY_PROV_INFO pKeyProvInfo
       )
{
    BOOL            fResult = TRUE;
    PCCERT_CONTEXT  pCertContext;
    CRYPT_DATA_BLOB DataBlob;
    
    pCertContext = CertCreateCertificateContext(
                       X509_ASN_ENCODING,
                       pEncodedCert->pbData,
                       pEncodedCert->cbData
                       );
                  
    if ( pCertContext == NULL )
    {
        return( FALSE );
    }
    
    if ( pwszCertFriendlyName != NULL )
    {
        DataBlob.cbData = ( wcslen( pwszCertFriendlyName ) + 1 ) * sizeof( WCHAR );
        DataBlob.pbData = (LPBYTE)pwszCertFriendlyName;
        
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_FRIENDLY_NAME_PROP_ID,
                      0,
                      (const void *)&DataBlob
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_SMART_CARD_DATA_PROP_ID,
                      0,
                      (const void *)pSmartCardData
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_KEY_PROV_INFO_PROP_ID,
                      0,
                      (const void *)pKeyProvInfo
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertAddCertificateContextToStore(
                      hStore,
                      pCertContext,
                      CERT_STORE_ADD_REPLACE_EXISTING,
                      NULL
                      );
    }
                  
    CertFreeCertificateContext( pCertContext );
    
    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\queryobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:	queryobj.cpp
//
//  Contents:   OID format functions
//
//  Functions:
//              CryptQueryObject
//
//  History:    15-05-97    xiaohs   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "frmtfunc.h"

//**************************************************************************
//
//     The following section is for CryptQueryObject
//**************************************************************************

//+-------------------------------------------------------------------------
//  Base64DecodeA: Decode the BLOB
//
//--------------------------------------------------------------------------
BOOL    DecodeBlobA(CHAR    *pbByte,
                    DWORD   cbByte,
                    BYTE    **ppbData,
                    DWORD   *pcbData)
{
    DWORD   err=0;
    BOOL    fResult=FALSE;

    *ppbData=NULL;
    *pcbData=0;

    if(ERROR_SUCCESS !=(err=Base64DecodeA(pbByte,
                      cbByte,
                      NULL,
                      pcbData)))
        goto DecodeErr;

    *ppbData=(BYTE *)malloc(*pcbData);

    if(NULL==*ppbData)
        goto OutOfMemoryErr;

    if(ERROR_SUCCESS !=(err=Base64DecodeA(pbByte,
                      cbByte,
                      *ppbData,
                      pcbData)))
        goto DecodeErr;


    fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(DecodeErr, err);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);

}

//+-------------------------------------------------------------------------
//  Base64DecodeW: Decode the BLOB
//
//--------------------------------------------------------------------------
BOOL    DecodeBlobW(WCHAR    *pbByte,
                    DWORD   cbByte,
                    BYTE    **ppbData,
                    DWORD   *pcbData)
{
    DWORD   err=0;
    BOOL    fResult=FALSE;

    *ppbData=NULL;
    *pcbData=0;

    if(ERROR_SUCCESS !=(err=Base64DecodeW(pbByte,
                      cbByte,
                      NULL,
                      pcbData)))
        goto DecodeErr;

    *ppbData=(BYTE *)malloc(*pcbData);

    if(NULL==*ppbData)
        goto OutOfMemoryErr;

    if(ERROR_SUCCESS !=(err=Base64DecodeW(pbByte,
                      cbByte,
                      *ppbData,
                      pcbData)))
        goto DecodeErr;


    fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(DecodeErr, err);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);

}


//+-------------------------------------------------------------------------
//  Skip over the identifier and length octets in an ASN encoded blob.
//  Returns the number of bytes skipped.
//
//  For an invalid identifier or length octet returns 0.
//--------------------------------------------------------------------------
 DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
#define TAG_MASK 0x1f
    DWORD   cb;
    DWORD   cbLength;
    const BYTE   *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
        return 0;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++) {
            if (cb >= cbDER)
                return 0;
        }
    } else
        // low-tag-number form
        cb = 1;

    // need at least one more byte for length
    if (cb >= cbDER)
        return 0;

    if (0x80 == *pb)
        // Indefinite
        cb++;
    else if ((cbLength = *pb) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;
        if (cb > cbDER)
            return 0;
    } else
        cb++;

    return cb;
}

//--------------------------------------------------------------------------
//
//	Skip over the tag and length
//----------------------------------------------------------------------------
BOOL SignNoContentWrap(IN const BYTE *pbDER, IN DWORD cbDER)
{
    DWORD cb;

    cb = SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if (cb > 0 && cb < cbDER && pbDER[cb] == 0x02)
        return TRUE;
    else
        return FALSE;
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb)
{


	HRESULT	hr=E_FAIL;
	HANDLE	hFile=NULL;
    HANDLE  hFileMapping=NULL;

    DWORD   cbData=0;
    BYTE    *pbData=0;
	DWORD	cbHighSize=0;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

    if ((hFile = CreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    if((cbData = GetFileSize(hFile, &cbHighSize)) == 0xffffffff)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	//we do not handle file more than 4G bytes
	if(cbHighSize != 0)
	{
			hr=E_FAIL;
			goto CLEANUP;
	}

    //create a file mapping object
    if(NULL == (hFileMapping=CreateFileMapping(
                hFile,
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    //create a view of the file
	if(NULL == (pbData=(BYTE *)MapViewOfFile(
		hFileMapping,
		FILE_MAP_READ,
		0,
		0,
		cbData)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	hr=S_OK;

	*pcb=cbData;
	*ppb=pbData;

CLEANUP:

	if(hFile)
		CloseHandle(hFile);

	if(hFileMapping)
		CloseHandle(hFileMapping);

	return hr;

}

//-------------------------------------------------------------------------
//
//   Check to see if the BLOB has an embeded PKCS7 using SIP functions
//
//-------------------------------------------------------------------------
BOOL    GetEmbeddedPKCS7(CERT_BLOB  *pCertBlob,
                         LPWSTR     pwszFileName,
                         BYTE       **ppbData,
                         DWORD      *pcbData,
                         DWORD      *pdwEncodingType)
{
    BOOL                fResult=FALSE;
    CHAR                szTempPath[MAX_PATH];
    CHAR                szTempFileName[MAX_PATH];
    LPSTR               szPreFix="Tmp";     //we should not localize this string
                                            //since it has to be in ANSCII characeter set
    DWORD               dwBytesWritten=0;
    GUID				gSubject;
    SIP_DISPATCH_INFO	SipDispatch;
    SIP_SUBJECTINFO		SubjectInfo;


    HANDLE              hFile=NULL;
    LPWSTR              pwszFileToUse=NULL;

    //init the output
    *ppbData=NULL;
    *pcbData=0;
    *pdwEncodingType=0;

    //create a temporary file since SIP functions only takes a file name
    if(NULL==pwszFileName)
    {
        if(0==GetTempPath(sizeof(szTempPath), szTempPath))
            goto GetTempPathErr;

        if(0==GetTempFileName(szTempPath, szPreFix, 0, szTempFileName))
            goto GetTempFileNameErr;

        if(INVALID_HANDLE_VALUE==(hFile=CreateFile(szTempFileName,
                        GENERIC_WRITE |GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL)))
            goto CreateFileErr;

        //write the BLOB to the file
        if(!WriteFile(hFile,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            &dwBytesWritten,
                            NULL))
            goto WriteFileErr;

        if(dwBytesWritten != pCertBlob->cbData)
            goto WriteBytesErr;

        //close the file handle
        if(!CloseHandle(hFile))
        {
            hFile=NULL;
            goto CloseHandleErr;
        }

        hFile=NULL;

        //get the unicode version of the file name
        pwszFileToUse=MkWStr(szTempFileName);

        if(NULL==pwszFileToUse)
           goto MkWStrErr;

    }
    else
        pwszFileToUse=pwszFileName;

    //call the sip functions
    //get the GUID
    if (!CryptSIPRetrieveSubjectGuid(
            pwszFileToUse,
            NULL,
            &gSubject))
        goto CryptNoMatchErr;

    //load the dispatch
    memset(&SipDispatch, 0, sizeof(SipDispatch));
    SipDispatch.cbSize = sizeof(SipDispatch);

    if (!CryptSIPLoad(
            &gSubject,
            0,
            &SipDispatch))
        goto CryptNoMatchErr;

    //fill out the subjectInfo
    memset(&SubjectInfo, 0, sizeof(SubjectInfo));
    SubjectInfo.cbSize = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType = (GUID*) &gSubject;
    SubjectInfo.hFile = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName = pwszFileToUse;
    SubjectInfo.dwEncodingType = *pdwEncodingType;

    //get the embedded PKCS7
     if (!SipDispatch.pfGet(
            &SubjectInfo,
            pdwEncodingType,
            0,                          // dwIndex
            pcbData,
            NULL                        // pbSignedData
            ) || 0 == (*pcbData))
        goto CryptNoMatchErr;

    if (NULL == (*ppbData=(BYTE *)malloc(*pcbData)))
        goto OutOfMemoryErr;


    if (!SipDispatch.pfGet(
            &SubjectInfo,
            pdwEncodingType,
            0,                          // dwIndex
            pcbData,
            *ppbData
            ))
        goto CryptNoMatchErr;


    fResult=TRUE;


CommonReturn:

    //close the file handle
    if(INVALID_HANDLE_VALUE!=hFile && NULL !=hFile)
        CloseHandle(hFile);

    //delete the file if it was created
    if(NULL==pwszFileName)
    {
        DeleteFileU(pwszFileToUse);

        FreeWStr(pwszFileToUse);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	goto CommonReturn;

TRACE_ERROR(GetTempPathErr);
TRACE_ERROR(GetTempFileNameErr);
TRACE_ERROR(CreateFileErr);
TRACE_ERROR(WriteFileErr);
SET_ERROR(WriteBytesErr, E_FAIL);
TRACE_ERROR(CloseHandleErr);
TRACE_ERROR(MkWStrErr);
SET_ERROR(CryptNoMatchErr, CRYPT_E_NO_MATCH);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);
}


//-------------------------------------------------------------------------
//
//   The real implementation of CryptQueryObject
//
//-------------------------------------------------------------------------
BOOL   I_CryptQueryObject(CERT_BLOB      *pCertBlob,
                       LPWSTR           pwszFileName,
                       DWORD            dwContentTypeFlag,
                       DWORD            dwFormatTypeFlag,
                       DWORD            dwFlag,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext)
{
    BOOL                fResult=FALSE;
    DWORD               dwMsgEncodingType=PKCS_7_ASN_ENCODING;
    DWORD               dwEncodingType=X509_ASN_ENCODING;
    DWORD               dwPKCS7EncodingType=X509_ASN_ENCODING|PKCS_7_ASN_ENCODING;
    DWORD               dwContentType=0;
    DWORD               dwMsgType=0;
    DWORD               cbData=0;
    BOOL                fEmbedded=FALSE;
    CERT_BLOB           PKCS7Blob;

    BYTE                *pbPKCS7=NULL;
    DWORD               cbPKCS7=0;
    HCERTSTORE          hCertStore=NULL;
    HCRYPTMSG           hMsg=NULL;
    PCCERT_CONTEXT      pCertContext=NULL;
    PCCRL_CONTEXT       pCRLContext=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;
    PCERT_REQUEST_INFO  pReqInfo=NULL;

    //NULL the output
    if(pdwMsgAndCertEncodingType)
        *pdwMsgAndCertEncodingType=0;

    if(pdwContentType)
        *pdwContentType=0;

    if(pdwFormatType)
        *pdwFormatType=0;

    if(phCertStore)
        *phCertStore=NULL;

    if(phMsg)
        *phMsg=NULL;

    if(ppvContext)
        *ppvContext=NULL;

    //open a generic memory store
    hCertStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 0,
						 NULL,
						 0,
						 NULL);

    if(NULL == hCertStore)
        goto CertOpenStoreErr;


    //single encoded cert
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CERT)
    {
        if(CertAddEncodedCertificateToStore(hCertStore,
								dwEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCertContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CERT;
            goto Found;
        }
    }

     //single encoded CTL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CTL)
    {

        if(CertAddEncodedCTLToStore(hCertStore,
								dwEncodingType | dwMsgEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCTLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CTL;
            dwEncodingType |= dwMsgEncodingType;
            goto Found;
        }
    }

    //single encoded CRL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CRL)
    {

        if(CertAddEncodedCRLToStore(hCertStore,
								dwEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCRLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CRL;
            goto Found;
        }
    }

    //PFX
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PFX)
    {
          if(PFXIsPFXBlob((CRYPT_DATA_BLOB*)pCertBlob))
          {
              dwContentType=CERT_QUERY_CONTENT_PFX;
    		//we need to close the temporary store
    		CertCloseStore(hCertStore, 0);
    		hCertStore=NULL;

              goto Found;
          }

    }



    //serialized CERT
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCertContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CERT;
            dwEncodingType=pCertContext->dwCertEncodingType;
            goto Found;
        }

    }

    //serialized CTL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CTL_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCTLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CTL;
            dwEncodingType=pCTLContext->dwMsgAndCertEncodingType;
            goto Found;
        }

    }


    //serialized CRL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CRL_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCRLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CRL;
            dwEncodingType=pCRLContext->dwCertEncodingType;
            goto Found;
        }

    }

    //we need to close the temporary store
    CertCloseStore(hCertStore, 0);

    hCertStore=NULL;


    //serialized store
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE)
    {
        if(hCertStore=CertOpenStore(
                            CERT_STORE_PROV_SERIALIZED,
							dwEncodingType | dwMsgEncodingType,
							NULL,
							0,
							pCertBlob))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_STORE;
            dwEncodingType |= dwMsgEncodingType;
            goto Found;
        }
    }

    //PKCS7 signed message
    if((dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED) ||
       (dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED) )
    {

       //get the embedded signed pkcs7
       if((CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED & dwContentTypeFlag))
       {
            if(GetEmbeddedPKCS7(pCertBlob, pwszFileName, &pbPKCS7, &cbPKCS7, &dwPKCS7EncodingType))
                fEmbedded=TRUE;
            else
            {
                if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED)
                {
                    //there is no embedded PKCS7
                    dwPKCS7EncodingType=dwEncodingType | dwMsgEncodingType;

                    pbPKCS7=pCertBlob->pbData;
                    cbPKCS7=pCertBlob->cbData;
                }
                else
                    pbPKCS7=NULL;
            }
       }
       else
       {
            //there is no embedded PKCS7
            dwPKCS7EncodingType=dwEncodingType | dwMsgEncodingType;

            pbPKCS7=pCertBlob->pbData;
            cbPKCS7=pCertBlob->cbData;
        }

        //proceed if there is a pkcs7 to decode
        if(NULL != pbPKCS7)
        {
            //check if the header is missing
            if(SignNoContentWrap(pbPKCS7, cbPKCS7))
                dwMsgType=CMSG_SIGNED;

            if(NULL==(hMsg=CryptMsgOpenToDecode(dwPKCS7EncodingType,
                            0,
                            dwMsgType,
                            NULL,
                            NULL,
                            NULL)))
                goto CryptMsgOpenErr;

            //update the message
            if(CryptMsgUpdate(hMsg,
                        pbPKCS7,
                        cbPKCS7,
                        TRUE))
            {

                //get the message type
                cbData=sizeof(dwMsgType);

                if(!CryptMsgGetParam(hMsg,
                            CMSG_TYPE_PARAM,
                            0,
                            &dwMsgType,
                            &cbData))
                    goto CryptMsgGetParamErr;

                if(CMSG_SIGNED == dwMsgType)
                {
                    PKCS7Blob.cbData=cbPKCS7;
                    PKCS7Blob.pbData=pbPKCS7;

                    //open a certificate store
                    hCertStore=CertOpenStore(CERT_STORE_PROV_PKCS7,
							dwPKCS7EncodingType,
							NULL,
							0,
							&PKCS7Blob);

                    if(NULL==hCertStore)
                        goto CertOpenStoreErr;

                    //we succeeded in opening a signed PKCS7
                    dwEncodingType = dwPKCS7EncodingType;

                    if(TRUE==fEmbedded)
                        dwContentType=CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED;
                    else
                        dwContentType=CERT_QUERY_CONTENT_PKCS7_SIGNED;

                    goto Found;
                }
            }

            //close the message
            CryptMsgClose(hMsg);

            hMsg=NULL;

        }
    }


    //PKCS7 unsigned message, not embedded
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED)
    {
        //no need to check if the header is missing
        if(NULL==(hMsg=CryptMsgOpenToDecode(dwEncodingType | dwMsgEncodingType,
                            0,
                            0,
                            NULL,
                            NULL,
                            NULL)))
            goto CryptMsgOpenErr;

        //update the message
        if(CryptMsgUpdate(hMsg,
                        pCertBlob->pbData,
                        pCertBlob->cbData,
                        TRUE))
        {

            //get the message type
            cbData=sizeof(dwMsgType);

            if(!CryptMsgGetParam(hMsg,
                            CMSG_TYPE_PARAM,
                            0,
                            &dwMsgType,
                            &cbData))
                goto CryptMsgGetParamErr;

            if(CMSG_SIGNED != dwMsgType)
            {
                //we succeeded in opening a unsigned PKCS7
                dwContentType=CERT_QUERY_CONTENT_PKCS7_UNSIGNED;
                dwEncodingType =dwEncodingType | dwMsgEncodingType;

                goto Found;
            }
        }

        //close the message
        CryptMsgClose(hMsg);

        hMsg=NULL;
    }

    //PKCS10
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS10)
    {
        //try to decode the BLOB
        cbData = 0;
        if(CryptDecodeObject(dwEncodingType,
                            X509_CERT_REQUEST_TO_BE_SIGNED,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            0,
                            NULL,
                            &cbData))
        {
            dwContentType=CERT_QUERY_CONTENT_PKCS10;

            // CryptDecodeObjectEX should be usable here, but since this object
            // is included with XEnroll and XEnroll must run with Auth2UPD Crypt32
            // we must stick with the old CryptDecodeObject 2 pass calls.
            if( (dwFlag & CRYPT_DECODE_ALLOC_FLAG) == CRYPT_DECODE_ALLOC_FLAG ) {

                // allocate the space, must use local alloc
                if( NULL == (pReqInfo = (PCERT_REQUEST_INFO) LocalAlloc(LPTR, cbData)) )
                    goto LocalAllocErr;

                // decode the request
                if( !CryptDecodeObject(dwEncodingType,
                            X509_CERT_REQUEST_TO_BE_SIGNED,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            0,
                            pReqInfo,
                            &cbData))
                goto CryptDecodeObjectErr;

            }
            goto Found;

        }
    }


    //we give up
    goto NoMatchErr;

Found:

    //fill in the output if required; Free the resources
    if(pdwMsgAndCertEncodingType)
        *pdwMsgAndCertEncodingType=dwEncodingType;

    if(pdwContentType)
        *pdwContentType=dwContentType;

    if(phCertStore)
        *phCertStore=hCertStore;
    else
    {
        if(hCertStore)
            CertCloseStore(hCertStore, 0);
    }

    if(phMsg)
        *phMsg=hMsg;
    else
    {
        if(hMsg)
            CryptMsgClose(hMsg);
    }

    if(ppvContext)
    {
        //only one of pCertContext or pCRLContext or pCRLContext is set
        if(pCertContext)
            *ppvContext=pCertContext;
        else
        {
            if(pCRLContext)
                *ppvContext=pCRLContext;

            else if(pReqInfo)
                *ppvContext=pReqInfo;

            else
                *ppvContext=pCTLContext;
        }
    }
    else
    {
        if(pCertContext)
            CertFreeCertificateContext(pCertContext);

        if(pCRLContext)
            CertFreeCRLContext(pCRLContext);

        if(pCTLContext)
            CertFreeCTLContext(pCTLContext);

        if(pReqInfo)
            LocalFree(pReqInfo);
    }


    fResult=TRUE;


CommonReturn:

    if(pbPKCS7)
    {
        if(TRUE==fEmbedded)
            free(pbPKCS7);
    }

	return fResult;

ErrorReturn:

    //relaset the stores and reset the local parameters
    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hMsg)
        CryptMsgClose(hMsg);

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    if(pCRLContext)
        CertFreeCRLContext(pCRLContext);

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(NoMatchErr,CRYPT_E_NO_MATCH);
SET_ERROR(LocalAllocErr, ERROR_OUTOFMEMORY);
TRACE_ERROR(CryptDecodeObjectErr);
TRACE_ERROR(CryptMsgOpenErr);
TRACE_ERROR(CryptMsgGetParamErr);
TRACE_ERROR(CertOpenStoreErr);


}
//-------------------------------------------------------------------------
//
//  CryptQueryObject takes a CERT_BLOB or a file name and returns the
//  information about the content in the blob or in the file.
//
//  Parameters:
//  INPUT   dwObjectType:
//                       Indicate the type of the object.  Should be one of the
//                       following:
//                          CERT_QUERY_OBJECT_FILE
//                          CERT_QUERY_OBJECT_BLOB
//
//  INPUT   pvObject:
//                        If dwObjectType == CERT_QUERY_OBJECT_FILE, it is a
//                        LPWSTR, that is, the pointer to a wchar file name
//                        if dwObjectType == CERT_QUERY_OBJECT_BLOB, it is a
//                        PCERT_BLOB, that is, a pointer to a CERT_BLOB
//
//  INPUT   dwExpectedContentTypeFlags:
//                        Indicate the expected contenet type.
//                        Can be one of the following:
//                              CERT_QUERY_CONTENT_FLAG_ALL  (the content can be any type)
//                              CERT_QUERY_CONTENT_FLAG_CERT
//                              CERT_QUERY_CONTENT_FLAG_CTL
//                              CERT_QUERY_CONTENT_FLAG_CRL
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTNET_FLAG_PKCS10
//
//  INPUT   dwExpectedFormatTypeFlags:
//                        Indicate the expected format type.
//                        Can be one of the following:
//                              CERT_QUERY_FORMAT_FLAG_ALL (the content can be any format)
//                              CERT_QUERY_FORMAT_FLAG_BINARY
//                              CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED
//
//
//  INPUT   dwFlags
//                        Reserved flag.  Should always set to 0
//
//  OUTPUT  pdwMsgAndCertEncodingType
//                        Optional output.  If NULL != pdwMsgAndCertEncodingType,
//                        it contains the encoding type of the content as any
//                        combination of the following:
//                              X509_ASN_ENCODING	
//                              PKCS_7_ASN_ENCODING	
//
//  OUTPUT  pdwContentType
//                        Optional output.  If NULL!=pdwContentType, it contains
//                        the content type as any combination of the the following:
//                              CERT_QUERY_CONTENT_CERT
//                              CERT_QUERY_CONTENT_CTL
//                              CERT_QUERY_CONTENT_CRL
//                              CERT_QUERY_CONTENT_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTNET_PKCS10
//
//  OUTPUT  pdwFormatType
//                        Optional output.  If NULL !=pdwFormatType, it
//                        contains the format type of the content as one of the
//                        following:
//                              CERT_QUERY_FORMAT_BINARY
//                              CERT_QUERY_FORMAT_BASE64_ENCODED
//
//
//  OUTPUT  phCertStore
//                        Optional output.  If NULL !=phStore,
//                        it contains a cert store that includes all of certificates,
//                        CRL, and CTL in the object if the object content type is
//                        one of the following:
//                              CERT_QUERY_CONTENT_CERT
//                              CERT_QUERY_CONTENT_CTL
//                              CERT_QUERY_CONTENT_CRL
//                              CERT_QUERY_CONTENT_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//
//
//  OUTPUT  phMsg        Optional output.  If NULL != phMsg,
//                        it contains a handle to a opened message if
//                        the content type is one of the following:
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//
//  OUTPUT pContext     Optional output.  If NULL != pContext,
//                      it contains either a PCCERT_CONTEXT or PCCRL_CONTEXT,
//                      or PCCTL_CONTEXT based on the content type.
//                      If the content type is CERT_QUERY_CONTENT_CERT or
//                      CERT_QUERY_CONTENT_SERIALIZED_CERT, it is a PCCERT_CONTEXT;
//                      If the content type is CERT_QUERY_CONTENT_CRL or
//                      CERT_QUERY_CONTENT_SERIALIZED_CRL, it is a PCCRL_CONTEXT;
//                      If the content type is CERT_QUERY_CONTENT_CTL or
//                      CERT_QUERY_CONTENT_SERIALIZED_CTL, it is a PCCTL_CONTEXT;
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptQueryObject(DWORD            dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext)
{
        BOOL        fResult=FALSE;
        CERT_BLOB   CertBlob;
        DWORD       cbData=0;
        BYTE        *pbData=NULL;

        BYTE        *pbToDecode=NULL;
        DWORD       cbToDecode=0;

        DWORD       cbDecodedData=0;
        BYTE        *pbDecodedData=NULL;
        HRESULT     hr=S_OK;
        DWORD       dwFormatType=0;

        //check input parameters
        if(NULL==pvObject)
            goto InvalidArgErr;

        //make sure we have a correct dwFormatTypeFlag
        if(0==(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_ALL))
            goto InvalidArgErr;

        //make sure we have a correct dwContentTypeFlag
        if(0==(dwExpectedContentTypeFlags & CERT_QUERY_CONTENT_FLAG_ALL))
            goto InvalidArgErr;

        //NULL out local variables
        memset(&CertBlob, 0, sizeof(CERT_BLOB));

        //get the BLOB
        if(CERT_QUERY_OBJECT_FILE == dwObjectType)
        {
              if(S_OK!=(hr=RetrieveBLOBFromFile((LPWSTR)pvObject, &cbData, &pbData)))
                    goto  RetrieveBLOBFromFileErr;

        }
        else
        {
            if(CERT_QUERY_OBJECT_BLOB == dwObjectType)
            {
                cbData=((PCERT_BLOB)pvObject)->cbData;
                pbData=((PCERT_BLOB)pvObject)->pbData;

            }
            else
                goto InvalidArgErr;
        }

       //make sure the input are valid
       if(0==cbData || NULL==pbData)
            goto InvalidArgErr;


        //assume the BLOBs are ANSCII
        CertBlob.cbData=cbData;
        CertBlob.pbData=pbData;


        //binary decoding
        if(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_BINARY)
        {

            if(I_CryptQueryObject(
                        &CertBlob,
                        (CERT_QUERY_OBJECT_FILE == dwObjectType) ? (LPWSTR)pvObject : NULL,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext))
            {
                dwFormatType=CERT_QUERY_FORMAT_BINARY;
                goto Done;
            }
            else
            {
                //if dwFormatTypeFlag did not specify BASED64 encoded,
                //return error
                if(0==(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED))
                    goto I_CryptQueryObjectErr;
            }
        }


        if(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED)
        {

           //try to base64 decode the content
           //1st, try decode as ANSCII character without header,
           //then try decode as ANSCII character with header
            if(cbData > CBBEGINCERT_A)
            {
                if(!strncmp(BEGINCERT_A, (CHAR *)pbData, CBBEGINCERT_A))
                {
                    pbToDecode = (BYTE *)((DWORD_PTR)pbData+CBBEGINCERT_A);
                    cbToDecode = cbData-CBBEGINCERT_A;
                }
                else
                {
                    pbToDecode = pbData;
                    cbToDecode = cbData;
                }
            }
            else
            {
                pbToDecode = pbData;
                cbToDecode = cbData;
            }


            if(!DecodeBlobA((CHAR *)pbToDecode, cbToDecode, &pbDecodedData, &cbDecodedData))
            {
                //now, try the UNICODE without header
                //cbData has to the multiple of sizeof(WCHAR)
                if(cbData % sizeof(WCHAR) == 0)
                {
                    //get rid of the header
                    if(cbData > sizeof(WCHAR) * CBBEGINCERT_W)
                    {
                        if(!wcsncmp(BEGINCERT_W, (WCHAR *)pbData, CBBEGINCERT_W))
                        {
                            pbToDecode = (BYTE *)((DWORD_PTR)pbData+sizeof(WCHAR)*CBBEGINCERT_W);
                            cbToDecode = cbData - sizeof(WCHAR) * CBBEGINCERT_W;
                        }
                        else
                        {
                            pbToDecode = pbData;
                            cbToDecode = cbData;
                        }
                    }
                    else
                    {
                        pbToDecode = pbData;
                        cbToDecode = cbData;
                     }

                    //we need to pass the count of characters for DecodeBlobW
                    if(!DecodeBlobW((WCHAR *)pbToDecode, (DWORD)(cbToDecode/sizeof(WCHAR)), &pbDecodedData, &cbDecodedData))
                            //now we are conviced the BLOB is not base64 encoded
                         goto NoMatchErr;
                }
                else
                    //now we are conviced the BLOB is not base64 encoded
                    goto NoMatchErr;
            }

            //the BLOB has been properly decoded
            dwFormatType=CERT_QUERY_FORMAT_BASE64_ENCODED;

            //make sure the base64 decode routine worked
            if(0==cbDecodedData || NULL==pbDecodedData)
                goto BadEncodeErr;

            CertBlob.cbData=cbDecodedData;
            CertBlob.pbData=pbDecodedData;


            //try the base64 decoded BLOB
            if(!I_CryptQueryObject(
                        &CertBlob,
                        (CERT_QUERY_OBJECT_FILE == dwObjectType) ? (LPWSTR)pvObject : NULL,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext))
                    goto I_CryptQueryObjectErr;
        }

Done:
        //return the FormatType
        if(NULL != pdwFormatType)
            *pdwFormatType = dwFormatType;

        fResult=TRUE;

CommonReturn:

    //free memory
    if(CERT_QUERY_OBJECT_FILE == dwObjectType)
    {
        if(pbData)
            UnmapViewOfFile(pbData);
    }

    if(pbDecodedData)
        free(pbDecodedData);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(RetrieveBLOBFromFileErr, hr);
SET_ERROR(InvalidArgErr,E_INVALIDARG);
TRACE_ERROR(I_CryptQueryObjectErr);
SET_ERROR(NoMatchErr, CRYPT_E_NO_MATCH);
SET_ERROR(BadEncodeErr, CRYPT_E_BAD_ENCODE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\scstore.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       scstore.cpp
//
//  Contents:   Smart Card Store Provider implementation
//
//  History:    03-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::CSmartCardStore, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSmartCardStore::CSmartCardStore ()
                : m_dwOpenFlags( 0 ),
                  m_pwszCardName( NULL ),
                  m_pwszProvider( NULL ),
                  m_dwProviderType( 0 ),
                  m_pwszContainer( NULL ),
                  m_hCacheStore( NULL )
{
    InitializeCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::~CSmartCardStore, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSmartCardStore::~CSmartCardStore ()
{
    DeleteCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::OpenStore, public
//
//  Synopsis:   open store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::OpenStore (
                     LPCSTR pszStoreProv,
                     DWORD dwMsgAndCertEncodingType,
                     HCRYPTPROV hCryptProv,
                     DWORD dwFlags,
                     const void* pvPara,
                     HCERTSTORE hCertStore,
                     PCERT_STORE_PROV_INFO pStoreProvInfo
                     )
{
    BOOL fResult;
    
    assert( m_dwOpenFlags == 0 );
    assert( m_pwszCardName == NULL );
    assert( m_pwszProvider == NULL );
    assert( m_pwszContainer == NULL );
    assert( m_hCacheStore == NULL );
    
    if ( ( pvPara == NULL ) || ( dwFlags & CERT_STORE_DELETE_FLAG ) )
    {
        SetLastError( E_INVALIDARG );
        return( FALSE );
    }
    
    if ( SCStoreParseOpenFilter(
                (LPWSTR)pvPara,
                &m_pwszCardName,
                &m_pwszProvider,
                &m_dwProviderType,
                &m_pwszContainer
                ) == FALSE )
    {
        return( FALSE );
    }
    
    m_dwOpenFlags = dwFlags;
    m_hCacheStore = hCertStore;                                  
                                      
    fResult = FillCacheStore( FALSE );  
    
    if ( fResult == TRUE )
    {
        pStoreProvInfo->cStoreProvFunc = SMART_CARD_PROV_FUNC_COUNT;
        pStoreProvInfo->rgpvStoreProvFunc = (void **)rgpvSmartCardProvFunc;
        pStoreProvInfo->hStoreProv = (HCERTSTOREPROV)this;
    }
    else
    {
        CloseStore( 0 );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::CloseStore, public
//
//  Synopsis:   close store
//
//----------------------------------------------------------------------------
VOID
CSmartCardStore::CloseStore (DWORD dwFlags)
{
    EnterCriticalSection( &m_StoreLock );
    
    delete m_pwszCardName;
    m_pwszCardName = NULL;
    
    delete m_pwszProvider;
    m_pwszProvider = NULL;
    
    delete m_pwszContainer;
    m_pwszContainer = NULL;
    
    LeaveCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::DeleteCert, public
//
//  Synopsis:   delete cert
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( ModifyCertOnCard( pCertContext, TRUE ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::SetCertProperty, public
//
//  Synopsis:   set certificate property
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::SetCertProperty (
                    PCCERT_CONTEXT pCertContext,
                    DWORD dwPropId,
                    DWORD dwFlags,
                    const void* pvPara
                    )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::WriteCert, public
//
//  Synopsis:   write certificate
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( ModifyCertOnCard( pCertContext, FALSE ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::StoreControl, public
//
//  Synopsis:   store control
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::StoreControl (
                      DWORD dwFlags, 
                      DWORD dwCtrlType, 
                      LPVOID pvCtrlPara
                      )
{
    switch ( dwCtrlType )
    {
    case CERT_STORE_CTRL_RESYNC:
         return( Resync() );
    }
    
    SetLastError( ERROR_NOT_SUPPORTED );                    
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::Resync, public
//
//  Synopsis:   resync store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::Resync ()
{
    BOOL fResult;
    
    EnterCriticalSection( &m_StoreLock );
    
    fResult = FillCacheStore( TRUE );
    
    LeaveCriticalSection( &m_StoreLock );
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::FillCacheStore, public
//
//  Synopsis:   fill the cache store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::FillCacheStore (BOOL fClearCache)
{
    BOOL                      fResult = TRUE;
    PCCERT_CONTEXT            pCertContext;
    PCCRL_CONTEXT             pCrlContext;
    PCCTL_CONTEXT             pCtlContext;
    DWORD                     dwFlags = 0;
    SMART_CARD_CERT_FIND_DATA sccfind;
    HCERTSTORE                hMyStore;
    
    if ( fClearCache == TRUE )
    {
        while ( pCertContext = CertEnumCertificatesInStore( m_hCacheStore, NULL ) )
        {
            CertDeleteCertificateFromStore( pCertContext );
        }
        
        while ( pCrlContext = CertGetCRLFromStore( m_hCacheStore, NULL, NULL, &dwFlags ) )
        {
            CertDeleteCRLFromStore( pCrlContext );
        }
            
        while ( pCtlContext = CertEnumCTLsInStore( m_hCacheStore, NULL ) )
        {
            CertDeleteCTLFromStore( pCtlContext );
        }
    }                 
    
    hMyStore = CertOpenSystemStoreW( NULL, L"MY" );
    if ( hMyStore == NULL )
    {
        return( FALSE );
    }
    
    sccfind.cbSize = sizeof( sccfind );
    sccfind.pwszProvider = m_pwszProvider;
    sccfind.dwProviderType = m_dwProviderType;
    sccfind.pwszContainer = m_pwszContainer;
    sccfind.dwKeySpec = 0;
    
    pCertContext = NULL;                       
    while ( ( fResult == TRUE ) && 
            ( ( pCertContext = I_CryptFindSmartCardCertInStore(
                                    hMyStore,
                                    pCertContext,
                                    &sccfind,
                                    NULL
                                    ) ) != NULL ) ) 
    {
        fResult = CertAddCertificateContextToStore(
                      m_hCacheStore,
                      pCertContext,
                      CERT_STORE_ADD_ALWAYS,
                      NULL
                      );
    }
    
    CertCloseStore( hMyStore, 0 );
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::ModifyCertOnCard, public
//
//  Synopsis:   modify the cert corresponding to the public key in the given
//              cert context
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::ModifyCertOnCard (PCCERT_CONTEXT pCertContext, BOOL fDelete)
{
    BOOL       fResult;
    HCRYPTPROV hContainer = NULL;
    HCRYPTKEY  hKeyPair;
    
    fResult = CryptAcquireContextU(
                   &hContainer,
                   m_pwszContainer,
                   m_pwszProvider,
                   m_dwProviderType,
                   0
                   );
                   
    if ( fResult == TRUE )
    {
        fResult = SCStoreAcquireHandleForCertKeyPair( 
                         hContainer,
                         pCertContext,
                         &hKeyPair
                         );
    }
    
    if ( fResult == TRUE )
    {
        fResult = SCStoreWriteCertToCard(
                         ( fDelete == FALSE ) ? pCertContext : NULL,
                         hKeyPair
                         );
                         
        CryptDestroyKey( hKeyPair );                 
    }
    
    if ( hContainer != NULL )
    {
        CryptReleaseContext( hContainer, 0 );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvOpenStore
//
//  Synopsis:   provider open store entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvOpenStore (
                 IN LPCSTR pszStoreProv,
                 IN DWORD dwMsgAndCertEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN DWORD dwFlags,
                 IN const void* pvPara,
                 IN HCERTSTORE hCertStore,
                 IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                 )
{
    BOOL             fResult;
    CSmartCardStore* pSCStore;

    pSCStore = new CSmartCardStore;
    if ( pSCStore == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = pSCStore->OpenStore(
                            pszStoreProv,
                            dwMsgAndCertEncodingType,
                            hCryptProv,
                            dwFlags,
                            pvPara,
                            hCertStore,
                            pStoreProvInfo
                            );

    if ( fResult == FALSE )
    {
        delete pSCStore;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvCloseStore
//
//  Synopsis:   provider close store entry point
//
//----------------------------------------------------------------------------
void WINAPI SmartCardProvCloseStore (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags
                 )
{
    ( (CSmartCardStore *)hStoreProv )->CloseStore( dwFlags );
    delete (CSmartCardStore *)hStoreProv;
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvDeleteCert
//
//  Synopsis:   provider delete cert entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvDeleteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->DeleteCert( 
                                                     pCertContext, 
                                                     dwFlags 
                                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvSetCertProperty
//
//  Synopsis:   provider set cert property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvSetCertProperty (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwPropId,
                 IN DWORD dwFlags,
                 IN const void* pvData
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->SetCertProperty(
                                                  pCertContext,
                                                  dwPropId,
                                                  dwFlags,
                                                  pvData
                                                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvWriteCert
//
//  Synopsis:   provider write cert entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvWriteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->WriteCert( 
                                                    pCertContext, 
                                                    dwFlags 
                                                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvStoreControl
//
//  Synopsis:   provider store control entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvStoreControl (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags,
                 IN DWORD dwCtrlType,
                 IN LPVOID pvCtrlPara
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->StoreControl( 
                                                    dwFlags, 
                                                    dwCtrlType, 
                                                    pvCtrlPara 
                                                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreParseOpenFilter
//
//  Synopsis:   parse open filter
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreParseOpenFilter (
       IN LPWSTR pwszOpenFilter,
       OUT LPWSTR* ppwszCardName,
       OUT LPWSTR* ppwszProvider,
       OUT DWORD* pdwProviderType,
       OUT LPWSTR* ppwszContainer
       )
{
    BOOL   fResult = TRUE;
    LPWSTR pwsz;
    DWORD  cw = wcslen( pwszOpenFilter ) + 1;
    DWORD  cParse = 1;
    DWORD  cCount;
    DWORD  aParse[PARSE_ELEM];
    LPWSTR pwszCardName;
    LPWSTR pwszProvider;
    LPSTR  pszProviderType;
    DWORD  dwProviderType;
    LPWSTR pwszContainer;
    
    pwsz = new WCHAR [ cw ];                                   
    if ( pwsz == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }
    
    wcscpy( pwsz, pwszOpenFilter );
    memset( aParse, 0, sizeof( aParse ) );
    
    for ( cCount = 0; ( cCount < cw ) && ( cParse < PARSE_ELEM ); cCount++ )
    {
        if ( pwsz[cCount] == L'\\' )
        {
            aParse[cParse++] = cCount + 1;
            pwsz[cCount] = L'\0';
        }
    }
    
    if ( cParse < PARSE_ELEM - 1 )
    {
        delete pwsz;
        SetLastError( E_INVALIDARG );
        return( FALSE );
    }
    
    pwszCardName = new WCHAR [wcslen( &pwsz[aParse[0]] ) + 1];
    pwszProvider = new WCHAR [wcslen( &pwsz[aParse[1]] ) + 1];
    cw = wcslen( &pwsz[aParse[2]] ) + 1;
    pszProviderType = new CHAR [cw];
    pwszContainer = new WCHAR [wcslen( &pwsz[aParse[3]] ) + 1];
    
    if ( ( pwszCardName == NULL ) || ( pwszProvider == NULL ) ||
         ( pszProviderType == NULL ) || ( pwszContainer == NULL ) )
    {
        delete pwszCardName;
        delete pwszProvider;
        delete pszProviderType;
        delete pwszContainer;
        delete pwsz;
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }
    
    wcscpy( pwszCardName, &pwsz[aParse[0]] );
    wcscpy( pwszProvider, &pwsz[aParse[1]] );
    
    WideCharToMultiByte(
        CP_ACP,
        0,
        &pwsz[aParse[2]],
        cw,
        pszProviderType,
        cw,
        NULL,
        NULL
        );
    
    dwProviderType = atol( pszProviderType );
    wcscpy( pwszContainer, &pwsz[aParse[3]] );
    
    *ppwszCardName = pwszCardName;
    *ppwszProvider = pwszProvider;
    *pdwProviderType = dwProviderType;
    *ppwszContainer = pwszContainer;               
                   
    delete pszProviderType;
    delete pwsz;
    
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreAcquireHandleForCertKeyPair
//
//  Synopsis:   get the provider handle corresponding to the key pair
//              identified by the public key given in the cert context
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreAcquireHandleForCertKeyPair (
       IN HCRYPTPROV hContainer,
       IN PCCERT_CONTEXT pCertContext,
       OUT HCRYPTKEY* phKeyPair
       )
{
    BOOL  fResult;
    DWORD dwKeySpec = AT_SIGNATURE;
    
    fResult = I_CertCompareCertAndProviderPublicKey(
                    pCertContext,
                    hContainer,
                    dwKeySpec
                    );
                    
    if ( fResult == FALSE )
    {
        dwKeySpec = AT_KEYEXCHANGE;
        
        fResult = I_CertCompareCertAndProviderPublicKey(
                        pCertContext,
                        hContainer,
                        dwKeySpec
                        );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CryptGetUserKey( hContainer, dwKeySpec, phKeyPair );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreWriteCertToCard
//
//  Synopsis:   write the cert to the card
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreWriteCertToCard (
       IN OPTIONAL PCCERT_CONTEXT pCertContext,
       IN HCRYPTKEY hKeyPair
       )
{
    LPBYTE pbEncoded = NULL;
    
    if ( pCertContext != NULL )
    {
        pbEncoded = pCertContext->pbCertEncoded;
    }
    
    return( CryptSetKeyParam( hKeyPair, KP_CERTIFICATE, pbEncoded, 0 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\scstore.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       scstore.h
//
//  Contents:   Smart Card Store Provider
//
//  History:    11-25-1997    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SCSTORE_H__)
#define __SCSTORE_H__

//
// Store provider open store function name
//

#define SMART_CARD_OPEN_STORE_PROV_FUNC "SmartCardProvOpenStore"

//
// CSmartCardStore.  This class implements all callbacks for the Smart Card
// Store provider.  A pointer to an instance of this class is used as the 
// hStoreProv parameter for the callback functions implemented
//

class CSmartCardStore
{
public:

    //
    // Construction
    //

    CSmartCardStore ();
    ~CSmartCardStore ();

    //
    // Store functions
    //

    BOOL OpenStore (
             LPCSTR pszStoreProv,
             DWORD dwMsgAndCertEncodingType,
             HCRYPTPROV hCryptProv,
             DWORD dwFlags,
             const void* pvPara,
             HCERTSTORE hCertStore,
             PCERT_STORE_PROV_INFO pStoreProvInfo
             );

    VOID CloseStore (DWORD dwFlags);

    BOOL DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL SetCertProperty (
            PCCERT_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL StoreControl (DWORD dwFlags, DWORD dwCtrlType, LPVOID pvCtrlPara);
    
    BOOL Resync ();

private:

    //
    // Object lock
    //
    
    CRITICAL_SECTION m_StoreLock;          
    
    //
    // Open Store flags
    //

    DWORD            m_dwOpenFlags;
    
    //
    // Open filter parameters
    //
    
    LPWSTR           m_pwszCardName;
    LPWSTR           m_pwszProvider;
    DWORD            m_dwProviderType;
    LPWSTR           m_pwszContainer;
    
    //
    // Cache Store
    //
    
    HCERTSTORE       m_hCacheStore;
    
    //
    // Private methods
    //

    BOOL FillCacheStore (BOOL fClearCache);    
    
    BOOL ModifyCertOnCard (PCCERT_CONTEXT pCertContext, BOOL fDelete);
};

//
// Smart Card Store Provider functions
//

BOOL WINAPI SmartCardProvOpenStore (
                 IN LPCSTR pszStoreProv,
                 IN DWORD dwMsgAndCertEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN DWORD dwFlags,
                 IN const void* pvPara,
                 IN HCERTSTORE hCertStore,
                 IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                 );

void WINAPI SmartCardProvCloseStore (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvDeleteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvSetCertProperty (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwPropId,
                 IN DWORD dwFlags,
                 IN const void* pvData
                 );

BOOL WINAPI SmartCardProvWriteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvStoreControl (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags,
                 IN DWORD dwCtrlType,
                 IN LPVOID pvCtrlPara
                 );

//
// Smart Card Store Provider Function table
//

static void* const rgpvSmartCardProvFunc[] = {

    // CERT_STORE_PROV_CLOSE_FUNC              0
    SmartCardProvCloseStore,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    NULL,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    SmartCardProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    SmartCardProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    SmartCardProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    NULL,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    NULL,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    NULL,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    NULL,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    NULL,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    NULL,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    NULL,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    NULL,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    SmartCardProvStoreControl
};

#define SMART_CARD_PROV_FUNC_COUNT (sizeof(rgpvSmartCardProvFunc) / \
                                    sizeof(rgpvSmartCardProvFunc[0]))
       
//
// Smart Card Store Helper Functions
//

BOOL WINAPI
SCStoreParseOpenFilter (
       IN LPWSTR pwszOpenFilter,
       OUT LPWSTR* ppwszCardName,
       OUT LPWSTR* ppwszProvider,
       OUT DWORD* pdwProviderType,
       OUT LPWSTR* ppwszContainer
       );
          
BOOL WINAPI
SCStoreAcquireHandleForCertKeyPair (
       IN HCRYPTPROV hContainer,
       IN PCCERT_CONTEXT pCertContext,
       OUT HCRYPTKEY* phKeyPair
       );
       
BOOL WINAPI
SCStoreWriteCertToCard (
       IN OPTIONAL PCCERT_CONTEXT pCertContext,
       IN HCRYPTKEY hKeyPair
       );       
       
//
// Open filter parsing definitions
//       

#define PARSE_ELEM 4
       
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\syscert.cpp ===
#include "global.hxx"

HCERTSTORE WINAPI CertOpenSystemStoreA(HCRYPTPROV  hProv,
                                                const char * szSubsystemProtocol) {

    DWORD dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    if (0 == _stricmp(szSubsystemProtocol, "SPC"))
        dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
    else
        dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_A,
        0,                          // dwEncodingType
        hProv,
        dwFlags,
        (const void *) szSubsystemProtocol
        );
}

HCERTSTORE WINAPI CertOpenSystemStoreW(HCRYPTPROV  hProv, 
                                                const WCHAR * wcsSubsystemProtocol) {

    DWORD dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    if (0 == _wcsicmp(wcsSubsystemProtocol, L"SPC"))
        dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
    else
        dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,                          // dwEncodingType
        hProv,
        dwFlags,
        (const void *) wcsSubsystemProtocol
        );
}

BOOL WINAPI CertAddEncodedCertificateToSystemStoreA(
    const char *    szCertStoreName,
    const BYTE *    pbCertEncoded,
    DWORD           cbCertEncoded
    )
{

    HCERTSTORE      hStore = NULL;
    BOOL            fOk;

    fOk =
          (hStore = CertOpenSystemStoreA(NULL, szCertStoreName)) != NULL                                 &&
          CertAddEncodedCertificateToStore(hStore, X509_ASN_ENCODING,
                pbCertEncoded, cbCertEncoded, CERT_STORE_ADD_USE_EXISTING,
                NULL);

    if(hStore != NULL)
        CertCloseStore(hStore, 0);

    return(fOk);
}

BOOL WINAPI CertAddEncodedCertificateToSystemStoreW(
    const WCHAR *   wcsCertStoreName,
    const BYTE *    pbCertEncoded,
    DWORD           cbCertEncoded
    )
{

    HCERTSTORE      hStore = NULL;
    BOOL            fOk;

    fOk =
          (hStore = CertOpenSystemStoreW(NULL, wcsCertStoreName)) != NULL                                &&
          CertAddEncodedCertificateToStore(hStore, X509_ASN_ENCODING,
            pbCertEncoded, cbCertEncoded, CERT_STORE_ADD_USE_EXISTING, NULL);

    if(hStore != NULL)
        CertCloseStore(hStore, 0);

    return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\x509.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#include <windows.h>
#include "x509.h"
#ifdef UNDER_CE
#define lstrlenA(x) strlen(x)
#endif

ASN1module_t X509_Module = NULL;

static int ASN1CALL ASN1Enc_EncodedObjectID(ASN1encoding_t enc, ASN1uint32_t tag, EncodedObjectID *val);
static int ASN1CALL ASN1Enc_Bits(ASN1encoding_t enc, ASN1uint32_t tag, Bits *val);
static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Enc_EnumeratedType(ASN1encoding_t enc, ASN1uint32_t tag, EnumeratedType *val);
static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Enc_NoticeReference_noticeNumbers(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference_noticeNumbers *val);
static int ASN1CALL ASN1Enc_AnyString(ASN1encoding_t enc, ASN1uint32_t tag, AnyString *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_Name(ASN1encoding_t enc, ASN1uint32_t tag, Name *val);
static int ASN1CALL ASN1Enc_RelativeDistinguishedName(ASN1encoding_t enc, ASN1uint32_t tag, RelativeDistinguishedName *val);
static int ASN1CALL ASN1Enc_AttributeTypeValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeTypeValue *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Enc_DSSParameters(ASN1encoding_t enc, ASN1uint32_t tag, DSSParameters *val);
static int ASN1CALL ASN1Enc_DSSSignature(ASN1encoding_t enc, ASN1uint32_t tag, DSSSignature *val);
static int ASN1CALL ASN1Enc_DHParameters(ASN1encoding_t enc, ASN1uint32_t tag, DHParameters *val);
static int ASN1CALL ASN1Enc_X942DhValidationParams(ASN1encoding_t enc, ASN1uint32_t tag, X942DhValidationParams *val);
static int ASN1CALL ASN1Enc_RC2CBCParameters(ASN1encoding_t enc, ASN1uint32_t tag, RC2CBCParameters *val);
static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Enc_SubjectPublicKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, SubjectPublicKeyInfo *val);
static int ASN1CALL ASN1Enc_ChoiceOfTime(ASN1encoding_t enc, ASN1uint32_t tag, ChoiceOfTime *val);
static int ASN1CALL ASN1Enc_Validity(ASN1encoding_t enc, ASN1uint32_t tag, Validity *val);
static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Enc_SignedContent(ASN1encoding_t enc, ASN1uint32_t tag, SignedContent *val);
static int ASN1CALL ASN1Enc_RevokedCertificates(ASN1encoding_t enc, ASN1uint32_t tag, RevokedCertificates *val);
static int ASN1CALL ASN1Enc_CRLEntry(ASN1encoding_t enc, ASN1uint32_t tag, CRLEntry *val);
static int ASN1CALL ASN1Enc_CertificationRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfo *val);
static int ASN1CALL ASN1Enc_CertificationRequestInfoDecode(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfoDecode *val);
static int ASN1CALL ASN1Enc_KeygenRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeygenRequestInfo *val);
static int ASN1CALL ASN1Enc_AuthorityKeyId(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId *val);
static int ASN1CALL ASN1Enc_PrivateKeyValidity(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyValidity *val);
static int ASN1CALL ASN1Enc_CertPolicySet(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicySet *val);
static int ASN1CALL ASN1Enc_CertPolicyId(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicyId *val);
static int ASN1CALL ASN1Enc_AltNames(ASN1encoding_t enc, ASN1uint32_t tag, AltNames *val);
static int ASN1CALL ASN1Enc_GeneralNames(ASN1encoding_t enc, ASN1uint32_t tag, GeneralNames *val);
static int ASN1CALL ASN1Enc_OtherName(ASN1encoding_t enc, ASN1uint32_t tag, OtherName *val);
static int ASN1CALL ASN1Enc_EDIPartyName(ASN1encoding_t enc, ASN1uint32_t tag, EDIPartyName *val);
static int ASN1CALL ASN1Enc_SubtreesConstraint(ASN1encoding_t enc, ASN1uint32_t tag, SubtreesConstraint *val);
static int ASN1CALL ASN1Enc_BasicConstraints2(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints2 *val);
static int ASN1CALL ASN1Enc_CertificatePolicies(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies *val);
static int ASN1CALL ASN1Enc_PolicyQualifiers(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifiers *val);
static int ASN1CALL ASN1Enc_PolicyQualifierInfo(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifierInfo *val);
static int ASN1CALL ASN1Enc_NoticeReference(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference *val);
static int ASN1CALL ASN1Enc_DisplayText(ASN1encoding_t enc, ASN1uint32_t tag, DisplayText *val);
static int ASN1CALL ASN1Enc_CertificatePolicies95(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies95 *val);
static int ASN1CALL ASN1Enc_CpsURLs(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs *val);
static int ASN1CALL ASN1Enc_AuthorityKeyId2(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId2 *val);
static int ASN1CALL ASN1Enc_AuthorityInfoAccess(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityInfoAccess *val);
static int ASN1CALL ASN1Enc_CRLDistributionPoints(ASN1encoding_t enc, ASN1uint32_t tag, CRLDistributionPoints *val);
static int ASN1CALL ASN1Enc_DistributionPointName(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPointName *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_SeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SeqOfAny *val);
static int ASN1CALL ASN1Enc_TimeStampRequest(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequest *val);
static int ASN1CALL ASN1Enc_ContentInfoOTS(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoOTS *val);
static int ASN1CALL ASN1Enc_TimeStampRequestOTS(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequestOTS *val);
static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Enc_SubjectUsage(ASN1encoding_t enc, ASN1uint32_t tag, SubjectUsage *val);
static int ASN1CALL ASN1Enc_TrustedSubjects(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubjects *val);
static int ASN1CALL ASN1Enc_TrustedSubject(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubject *val);
static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Enc_CpsURLs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs_Seq *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_X942DhParameters(ASN1encoding_t enc, ASN1uint32_t tag, X942DhParameters *val);
static int ASN1CALL ASN1Enc_CertificateToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateToBeSigned *val);
static int ASN1CALL ASN1Enc_CertificateRevocationListToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val);
static int ASN1CALL ASN1Enc_KeyAttributes(ASN1encoding_t enc, ASN1uint32_t tag, KeyAttributes *val);
static int ASN1CALL ASN1Enc_KeyUsageRestriction(ASN1encoding_t enc, ASN1uint32_t tag, KeyUsageRestriction *val);
static int ASN1CALL ASN1Enc_GeneralName(ASN1encoding_t enc, ASN1uint32_t tag, GeneralName *val);
static int ASN1CALL ASN1Enc_BasicConstraints(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints *val);
static int ASN1CALL ASN1Enc_PolicyInformation(ASN1encoding_t enc, ASN1uint32_t tag, PolicyInformation *val);
static int ASN1CALL ASN1Enc_UserNotice(ASN1encoding_t enc, ASN1uint32_t tag, UserNotice *val);
static int ASN1CALL ASN1Enc_VerisignQualifier1(ASN1encoding_t enc, ASN1uint32_t tag, VerisignQualifier1 *val);
static int ASN1CALL ASN1Enc_AccessDescription(ASN1encoding_t enc, ASN1uint32_t tag, AccessDescription *val);
static int ASN1CALL ASN1Enc_DistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPoint *val);
static int ASN1CALL ASN1Enc_ContentInfoSeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoSeqOfAny *val);
static int ASN1CALL ASN1Enc_CertificateTrustList(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTrustList *val);
static int ASN1CALL ASN1Dec_EncodedObjectID(ASN1decoding_t dec, ASN1uint32_t tag, EncodedObjectID *val);
static int ASN1CALL ASN1Dec_Bits(ASN1decoding_t dec, ASN1uint32_t tag, Bits *val);
static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Dec_EnumeratedType(ASN1decoding_t dec, ASN1uint32_t tag, EnumeratedType *val);
static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Dec_NoticeReference_noticeNumbers(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference_noticeNumbers *val);
static int ASN1CALL ASN1Dec_AnyString(ASN1decoding_t dec, ASN1uint32_t tag, AnyString *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_Name(ASN1decoding_t dec, ASN1uint32_t tag, Name *val);
static int ASN1CALL ASN1Dec_RelativeDistinguishedName(ASN1decoding_t dec, ASN1uint32_t tag, RelativeDistinguishedName *val);
static int ASN1CALL ASN1Dec_AttributeTypeValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeTypeValue *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Dec_DSSParameters(ASN1decoding_t dec, ASN1uint32_t tag, DSSParameters *val);
static int ASN1CALL ASN1Dec_DSSSignature(ASN1decoding_t dec, ASN1uint32_t tag, DSSSignature *val);
static int ASN1CALL ASN1Dec_DHParameters(ASN1decoding_t dec, ASN1uint32_t tag, DHParameters *val);
static int ASN1CALL ASN1Dec_X942DhValidationParams(ASN1decoding_t dec, ASN1uint32_t tag, X942DhValidationParams *val);
static int ASN1CALL ASN1Dec_RC2CBCParameters(ASN1decoding_t dec, ASN1uint32_t tag, RC2CBCParameters *val);
static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Dec_SubjectPublicKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, SubjectPublicKeyInfo *val);
static int ASN1CALL ASN1Dec_ChoiceOfTime(ASN1decoding_t dec, ASN1uint32_t tag, ChoiceOfTime *val);
static int ASN1CALL ASN1Dec_Validity(ASN1decoding_t dec, ASN1uint32_t tag, Validity *val);
static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Dec_SignedContent(ASN1decoding_t dec, ASN1uint32_t tag, SignedContent *val);
static int ASN1CALL ASN1Dec_RevokedCertificates(ASN1decoding_t dec, ASN1uint32_t tag, RevokedCertificates *val);
static int ASN1CALL ASN1Dec_CRLEntry(ASN1decoding_t dec, ASN1uint32_t tag, CRLEntry *val);
static int ASN1CALL ASN1Dec_CertificationRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfo *val);
static int ASN1CALL ASN1Dec_CertificationRequestInfoDecode(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfoDecode *val);
static int ASN1CALL ASN1Dec_KeygenRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeygenRequestInfo *val);
static int ASN1CALL ASN1Dec_AuthorityKeyId(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId *val);
static int ASN1CALL ASN1Dec_PrivateKeyValidity(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyValidity *val);
static int ASN1CALL ASN1Dec_CertPolicySet(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicySet *val);
static int ASN1CALL ASN1Dec_CertPolicyId(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicyId *val);
static int ASN1CALL ASN1Dec_AltNames(ASN1decoding_t dec, ASN1uint32_t tag, AltNames *val);
static int ASN1CALL ASN1Dec_GeneralNames(ASN1decoding_t dec, ASN1uint32_t tag, GeneralNames *val);
static int ASN1CALL ASN1Dec_OtherName(ASN1decoding_t dec, ASN1uint32_t tag, OtherName *val);
static int ASN1CALL ASN1Dec_EDIPartyName(ASN1decoding_t dec, ASN1uint32_t tag, EDIPartyName *val);
static int ASN1CALL ASN1Dec_SubtreesConstraint(ASN1decoding_t dec, ASN1uint32_t tag, SubtreesConstraint *val);
static int ASN1CALL ASN1Dec_BasicConstraints2(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints2 *val);
static int ASN1CALL ASN1Dec_CertificatePolicies(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies *val);
static int ASN1CALL ASN1Dec_PolicyQualifiers(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifiers *val);
static int ASN1CALL ASN1Dec_PolicyQualifierInfo(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifierInfo *val);
static int ASN1CALL ASN1Dec_NoticeReference(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference *val);
static int ASN1CALL ASN1Dec_DisplayText(ASN1decoding_t dec, ASN1uint32_t tag, DisplayText *val);
static int ASN1CALL ASN1Dec_CertificatePolicies95(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies95 *val);
static int ASN1CALL ASN1Dec_CpsURLs(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs *val);
static int ASN1CALL ASN1Dec_AuthorityKeyId2(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId2 *val);
static int ASN1CALL ASN1Dec_AuthorityInfoAccess(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityInfoAccess *val);
static int ASN1CALL ASN1Dec_CRLDistributionPoints(ASN1decoding_t dec, ASN1uint32_t tag, CRLDistributionPoints *val);
static int ASN1CALL ASN1Dec_DistributionPointName(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPointName *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_SeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SeqOfAny *val);
static int ASN1CALL ASN1Dec_TimeStampRequest(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequest *val);
static int ASN1CALL ASN1Dec_ContentInfoOTS(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoOTS *val);
static int ASN1CALL ASN1Dec_TimeStampRequestOTS(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequestOTS *val);
static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Dec_SubjectUsage(ASN1decoding_t dec, ASN1uint32_t tag, SubjectUsage *val);
static int ASN1CALL ASN1Dec_TrustedSubjects(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubjects *val);
static int ASN1CALL ASN1Dec_TrustedSubject(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubject *val);
static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Dec_CpsURLs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs_Seq *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_X942DhParameters(ASN1decoding_t dec, ASN1uint32_t tag, X942DhParameters *val);
static int ASN1CALL ASN1Dec_CertificateToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateToBeSigned *val);
static int ASN1CALL ASN1Dec_CertificateRevocationListToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val);
static int ASN1CALL ASN1Dec_KeyAttributes(ASN1decoding_t dec, ASN1uint32_t tag, KeyAttributes *val);
static int ASN1CALL ASN1Dec_KeyUsageRestriction(ASN1decoding_t dec, ASN1uint32_t tag, KeyUsageRestriction *val);
static int ASN1CALL ASN1Dec_GeneralName(ASN1decoding_t dec, ASN1uint32_t tag, GeneralName *val);
static int ASN1CALL ASN1Dec_BasicConstraints(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints *val);
static int ASN1CALL ASN1Dec_PolicyInformation(ASN1decoding_t dec, ASN1uint32_t tag, PolicyInformation *val);
static int ASN1CALL ASN1Dec_UserNotice(ASN1decoding_t dec, ASN1uint32_t tag, UserNotice *val);
static int ASN1CALL ASN1Dec_VerisignQualifier1(ASN1decoding_t dec, ASN1uint32_t tag, VerisignQualifier1 *val);
static int ASN1CALL ASN1Dec_AccessDescription(ASN1decoding_t dec, ASN1uint32_t tag, AccessDescription *val);
static int ASN1CALL ASN1Dec_DistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPoint *val);
static int ASN1CALL ASN1Dec_ContentInfoSeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoSeqOfAny *val);
static int ASN1CALL ASN1Dec_CertificateTrustList(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTrustList *val);
static void ASN1CALL ASN1Free_EncodedObjectID(EncodedObjectID *val);
static void ASN1CALL ASN1Free_Bits(Bits *val);
static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val);
static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val);
static void ASN1CALL ASN1Free_UtcTime(UtcTime *val);
static void ASN1CALL ASN1Free_NoticeReference_noticeNumbers(NoticeReference_noticeNumbers *val);
static void ASN1CALL ASN1Free_AnyString(AnyString *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_Name(Name *val);
static void ASN1CALL ASN1Free_RelativeDistinguishedName(RelativeDistinguishedName *val);
static void ASN1CALL ASN1Free_AttributeTypeValue(AttributeTypeValue *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val);
static void ASN1CALL ASN1Free_DSSParameters(DSSParameters *val);
static void ASN1CALL ASN1Free_DSSSignature(DSSSignature *val);
static void ASN1CALL ASN1Free_DHParameters(DHParameters *val);
static void ASN1CALL ASN1Free_X942DhValidationParams(X942DhValidationParams *val);
static void ASN1CALL ASN1Free_RC2CBCParameters(RC2CBCParameters *val);
static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val);
static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val);
static void ASN1CALL ASN1Free_SubjectPublicKeyInfo(SubjectPublicKeyInfo *val);
static void ASN1CALL ASN1Free_ChoiceOfTime(ChoiceOfTime *val);
static void ASN1CALL ASN1Free_Validity(Validity *val);
static void ASN1CALL ASN1Free_Extensions(Extensions *val);
static void ASN1CALL ASN1Free_Extension(Extension *val);
static void ASN1CALL ASN1Free_SignedContent(SignedContent *val);
static void ASN1CALL ASN1Free_RevokedCertificates(RevokedCertificates *val);
static void ASN1CALL ASN1Free_CRLEntry(CRLEntry *val);
static void ASN1CALL ASN1Free_CertificationRequestInfo(CertificationRequestInfo *val);
static void ASN1CALL ASN1Free_CertificationRequestInfoDecode(CertificationRequestInfoDecode *val);
static void ASN1CALL ASN1Free_KeygenRequestInfo(KeygenRequestInfo *val);
static void ASN1CALL ASN1Free_AuthorityKeyId(AuthorityKeyId *val);
static void ASN1CALL ASN1Free_PrivateKeyValidity(PrivateKeyValidity *val);
static void ASN1CALL ASN1Free_CertPolicySet(CertPolicySet *val);
static void ASN1CALL ASN1Free_CertPolicyId(CertPolicyId *val);
static void ASN1CALL ASN1Free_AltNames(AltNames *val);
static void ASN1CALL ASN1Free_GeneralNames(GeneralNames *val);
static void ASN1CALL ASN1Free_OtherName(OtherName *val);
static void ASN1CALL ASN1Free_EDIPartyName(EDIPartyName *val);
static void ASN1CALL ASN1Free_SubtreesConstraint(SubtreesConstraint *val);
static void ASN1CALL ASN1Free_CertificatePolicies(CertificatePolicies *val);
static void ASN1CALL ASN1Free_PolicyQualifiers(PolicyQualifiers *val);
static void ASN1CALL ASN1Free_PolicyQualifierInfo(PolicyQualifierInfo *val);
static void ASN1CALL ASN1Free_NoticeReference(NoticeReference *val);
static void ASN1CALL ASN1Free_DisplayText(DisplayText *val);
static void ASN1CALL ASN1Free_CertificatePolicies95(CertificatePolicies95 *val);
static void ASN1CALL ASN1Free_CpsURLs(CpsURLs *val);
static void ASN1CALL ASN1Free_AuthorityKeyId2(AuthorityKeyId2 *val);
static void ASN1CALL ASN1Free_AuthorityInfoAccess(AuthorityInfoAccess *val);
static void ASN1CALL ASN1Free_CRLDistributionPoints(CRLDistributionPoints *val);
static void ASN1CALL ASN1Free_DistributionPointName(DistributionPointName *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_SeqOfAny(SeqOfAny *val);
static void ASN1CALL ASN1Free_TimeStampRequest(TimeStampRequest *val);
static void ASN1CALL ASN1Free_ContentInfoOTS(ContentInfoOTS *val);
static void ASN1CALL ASN1Free_TimeStampRequestOTS(TimeStampRequestOTS *val);
static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val);
static void ASN1CALL ASN1Free_SubjectUsage(SubjectUsage *val);
static void ASN1CALL ASN1Free_TrustedSubjects(TrustedSubjects *val);
static void ASN1CALL ASN1Free_TrustedSubject(TrustedSubject *val);
static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val);
static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val);
static void ASN1CALL ASN1Free_CpsURLs_Seq(CpsURLs_Seq *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_X942DhParameters(X942DhParameters *val);
static void ASN1CALL ASN1Free_CertificateToBeSigned(CertificateToBeSigned *val);
static void ASN1CALL ASN1Free_CertificateRevocationListToBeSigned(CertificateRevocationListToBeSigned *val);
static void ASN1CALL ASN1Free_KeyAttributes(KeyAttributes *val);
static void ASN1CALL ASN1Free_KeyUsageRestriction(KeyUsageRestriction *val);
static void ASN1CALL ASN1Free_GeneralName(GeneralName *val);
static void ASN1CALL ASN1Free_BasicConstraints(BasicConstraints *val);
static void ASN1CALL ASN1Free_PolicyInformation(PolicyInformation *val);
static void ASN1CALL ASN1Free_UserNotice(UserNotice *val);
static void ASN1CALL ASN1Free_VerisignQualifier1(VerisignQualifier1 *val);
static void ASN1CALL ASN1Free_AccessDescription(AccessDescription *val);
static void ASN1CALL ASN1Free_DistributionPoint(DistributionPoint *val);
static void ASN1CALL ASN1Free_ContentInfoSeqOfAny(ContentInfoSeqOfAny *val);
static void ASN1CALL ASN1Free_CertificateTrustList(CertificateTrustList *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[51] = {
    (ASN1EncFun_t) ASN1Enc_EncodedObjectID,
    (ASN1EncFun_t) ASN1Enc_Bits,
    (ASN1EncFun_t) ASN1Enc_IntegerType,
    (ASN1EncFun_t) ASN1Enc_HugeIntegerType,
    (ASN1EncFun_t) ASN1Enc_OctetStringType,
    (ASN1EncFun_t) ASN1Enc_EnumeratedType,
    (ASN1EncFun_t) ASN1Enc_UtcTime,
    (ASN1EncFun_t) ASN1Enc_AnyString,
    (ASN1EncFun_t) ASN1Enc_Name,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_RSAPublicKey,
    (ASN1EncFun_t) ASN1Enc_DSSParameters,
    (ASN1EncFun_t) ASN1Enc_DSSSignature,
    (ASN1EncFun_t) ASN1Enc_DHParameters,
    (ASN1EncFun_t) ASN1Enc_RC2CBCParameters,
    (ASN1EncFun_t) ASN1Enc_SMIMECapabilities,
    (ASN1EncFun_t) ASN1Enc_SubjectPublicKeyInfo,
    (ASN1EncFun_t) ASN1Enc_ChoiceOfTime,
    (ASN1EncFun_t) ASN1Enc_Extensions,
    (ASN1EncFun_t) ASN1Enc_SignedContent,
    (ASN1EncFun_t) ASN1Enc_CertificationRequestInfo,
    (ASN1EncFun_t) ASN1Enc_CertificationRequestInfoDecode,
    (ASN1EncFun_t) ASN1Enc_KeygenRequestInfo,
    (ASN1EncFun_t) ASN1Enc_AuthorityKeyId,
    (ASN1EncFun_t) ASN1Enc_AltNames,
    (ASN1EncFun_t) ASN1Enc_EDIPartyName,
    (ASN1EncFun_t) ASN1Enc_BasicConstraints2,
    (ASN1EncFun_t) ASN1Enc_CertificatePolicies,
    (ASN1EncFun_t) ASN1Enc_CertificatePolicies95,
    (ASN1EncFun_t) ASN1Enc_AuthorityKeyId2,
    (ASN1EncFun_t) ASN1Enc_AuthorityInfoAccess,
    (ASN1EncFun_t) ASN1Enc_CRLDistributionPoints,
    (ASN1EncFun_t) ASN1Enc_ContentInfo,
    (ASN1EncFun_t) ASN1Enc_SeqOfAny,
    (ASN1EncFun_t) ASN1Enc_TimeStampRequest,
    (ASN1EncFun_t) ASN1Enc_ContentInfoOTS,
    (ASN1EncFun_t) ASN1Enc_TimeStampRequestOTS,
    (ASN1EncFun_t) ASN1Enc_EnhancedKeyUsage,
    (ASN1EncFun_t) ASN1Enc_EnrollmentNameValuePair,
    (ASN1EncFun_t) ASN1Enc_CSPProvider,
    (ASN1EncFun_t) ASN1Enc_Attribute,
    (ASN1EncFun_t) ASN1Enc_X942DhParameters,
    (ASN1EncFun_t) ASN1Enc_CertificateToBeSigned,
    (ASN1EncFun_t) ASN1Enc_CertificateRevocationListToBeSigned,
    (ASN1EncFun_t) ASN1Enc_KeyAttributes,
    (ASN1EncFun_t) ASN1Enc_KeyUsageRestriction,
    (ASN1EncFun_t) ASN1Enc_BasicConstraints,
    (ASN1EncFun_t) ASN1Enc_UserNotice,
    (ASN1EncFun_t) ASN1Enc_VerisignQualifier1,
    (ASN1EncFun_t) ASN1Enc_ContentInfoSeqOfAny,
    (ASN1EncFun_t) ASN1Enc_CertificateTrustList,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[51] = {
    (ASN1DecFun_t) ASN1Dec_EncodedObjectID,
    (ASN1DecFun_t) ASN1Dec_Bits,
    (ASN1DecFun_t) ASN1Dec_IntegerType,
    (ASN1DecFun_t) ASN1Dec_HugeIntegerType,
    (ASN1DecFun_t) ASN1Dec_OctetStringType,
    (ASN1DecFun_t) ASN1Dec_EnumeratedType,
    (ASN1DecFun_t) ASN1Dec_UtcTime,
    (ASN1DecFun_t) ASN1Dec_AnyString,
    (ASN1DecFun_t) ASN1Dec_Name,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_RSAPublicKey,
    (ASN1DecFun_t) ASN1Dec_DSSParameters,
    (ASN1DecFun_t) ASN1Dec_DSSSignature,
    (ASN1DecFun_t) ASN1Dec_DHParameters,
    (ASN1DecFun_t) ASN1Dec_RC2CBCParameters,
    (ASN1DecFun_t) ASN1Dec_SMIMECapabilities,
    (ASN1DecFun_t) ASN1Dec_SubjectPublicKeyInfo,
    (ASN1DecFun_t) ASN1Dec_ChoiceOfTime,
    (ASN1DecFun_t) ASN1Dec_Extensions,
    (ASN1DecFun_t) ASN1Dec_SignedContent,
    (ASN1DecFun_t) ASN1Dec_CertificationRequestInfo,
    (ASN1DecFun_t) ASN1Dec_CertificationRequestInfoDecode,
    (ASN1DecFun_t) ASN1Dec_KeygenRequestInfo,
    (ASN1DecFun_t) ASN1Dec_AuthorityKeyId,
    (ASN1DecFun_t) ASN1Dec_AltNames,
    (ASN1DecFun_t) ASN1Dec_EDIPartyName,
    (ASN1DecFun_t) ASN1Dec_BasicConstraints2,
    (ASN1DecFun_t) ASN1Dec_CertificatePolicies,
    (ASN1DecFun_t) ASN1Dec_CertificatePolicies95,
    (ASN1DecFun_t) ASN1Dec_AuthorityKeyId2,
    (ASN1DecFun_t) ASN1Dec_AuthorityInfoAccess,
    (ASN1DecFun_t) ASN1Dec_CRLDistributionPoints,
    (ASN1DecFun_t) ASN1Dec_ContentInfo,
    (ASN1DecFun_t) ASN1Dec_SeqOfAny,
    (ASN1DecFun_t) ASN1Dec_TimeStampRequest,
    (ASN1DecFun_t) ASN1Dec_ContentInfoOTS,
    (ASN1DecFun_t) ASN1Dec_TimeStampRequestOTS,
    (ASN1DecFun_t) ASN1Dec_EnhancedKeyUsage,
    (ASN1DecFun_t) ASN1Dec_EnrollmentNameValuePair,
    (ASN1DecFun_t) ASN1Dec_CSPProvider,
    (ASN1DecFun_t) ASN1Dec_Attribute,
    (ASN1DecFun_t) ASN1Dec_X942DhParameters,
    (ASN1DecFun_t) ASN1Dec_CertificateToBeSigned,
    (ASN1DecFun_t) ASN1Dec_CertificateRevocationListToBeSigned,
    (ASN1DecFun_t) ASN1Dec_KeyAttributes,
    (ASN1DecFun_t) ASN1Dec_KeyUsageRestriction,
    (ASN1DecFun_t) ASN1Dec_BasicConstraints,
    (ASN1DecFun_t) ASN1Dec_UserNotice,
    (ASN1DecFun_t) ASN1Dec_VerisignQualifier1,
    (ASN1DecFun_t) ASN1Dec_ContentInfoSeqOfAny,
    (ASN1DecFun_t) ASN1Dec_CertificateTrustList,
};
static const ASN1FreeFun_t freefntab[51] = {
    (ASN1FreeFun_t) ASN1Free_EncodedObjectID,
    (ASN1FreeFun_t) ASN1Free_Bits,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_HugeIntegerType,
    (ASN1FreeFun_t) ASN1Free_OctetStringType,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_UtcTime,
    (ASN1FreeFun_t) ASN1Free_AnyString,
    (ASN1FreeFun_t) ASN1Free_Name,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_RSAPublicKey,
    (ASN1FreeFun_t) ASN1Free_DSSParameters,
    (ASN1FreeFun_t) ASN1Free_DSSSignature,
    (ASN1FreeFun_t) ASN1Free_DHParameters,
    (ASN1FreeFun_t) ASN1Free_RC2CBCParameters,
    (ASN1FreeFun_t) ASN1Free_SMIMECapabilities,
    (ASN1FreeFun_t) ASN1Free_SubjectPublicKeyInfo,
    (ASN1FreeFun_t) ASN1Free_ChoiceOfTime,
    (ASN1FreeFun_t) ASN1Free_Extensions,
    (ASN1FreeFun_t) ASN1Free_SignedContent,
    (ASN1FreeFun_t) ASN1Free_CertificationRequestInfo,
    (ASN1FreeFun_t) ASN1Free_CertificationRequestInfoDecode,
    (ASN1FreeFun_t) ASN1Free_KeygenRequestInfo,
    (ASN1FreeFun_t) ASN1Free_AuthorityKeyId,
    (ASN1FreeFun_t) ASN1Free_AltNames,
    (ASN1FreeFun_t) ASN1Free_EDIPartyName,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_CertificatePolicies,
    (ASN1FreeFun_t) ASN1Free_CertificatePolicies95,
    (ASN1FreeFun_t) ASN1Free_AuthorityKeyId2,
    (ASN1FreeFun_t) ASN1Free_AuthorityInfoAccess,
    (ASN1FreeFun_t) ASN1Free_CRLDistributionPoints,
    (ASN1FreeFun_t) ASN1Free_ContentInfo,
    (ASN1FreeFun_t) ASN1Free_SeqOfAny,
    (ASN1FreeFun_t) ASN1Free_TimeStampRequest,
    (ASN1FreeFun_t) ASN1Free_ContentInfoOTS,
    (ASN1FreeFun_t) ASN1Free_TimeStampRequestOTS,
    (ASN1FreeFun_t) ASN1Free_EnhancedKeyUsage,
    (ASN1FreeFun_t) ASN1Free_EnrollmentNameValuePair,
    (ASN1FreeFun_t) ASN1Free_CSPProvider,
    (ASN1FreeFun_t) ASN1Free_Attribute,
    (ASN1FreeFun_t) ASN1Free_X942DhParameters,
    (ASN1FreeFun_t) ASN1Free_CertificateToBeSigned,
    (ASN1FreeFun_t) ASN1Free_CertificateRevocationListToBeSigned,
    (ASN1FreeFun_t) ASN1Free_KeyAttributes,
    (ASN1FreeFun_t) ASN1Free_KeyUsageRestriction,
    (ASN1FreeFun_t) ASN1Free_BasicConstraints,
    (ASN1FreeFun_t) ASN1Free_UserNotice,
    (ASN1FreeFun_t) ASN1Free_VerisignQualifier1,
    (ASN1FreeFun_t) ASN1Free_ContentInfoSeqOfAny,
    (ASN1FreeFun_t) ASN1Free_CertificateTrustList,
};
static const ULONG sizetab[51] = {
    SIZE_X509_Module_PDU_0,
    SIZE_X509_Module_PDU_1,
    SIZE_X509_Module_PDU_2,
    SIZE_X509_Module_PDU_3,
    SIZE_X509_Module_PDU_4,
    SIZE_X509_Module_PDU_5,
    SIZE_X509_Module_PDU_6,
    SIZE_X509_Module_PDU_7,
    SIZE_X509_Module_PDU_8,
    SIZE_X509_Module_PDU_9,
    SIZE_X509_Module_PDU_10,
    SIZE_X509_Module_PDU_11,
    SIZE_X509_Module_PDU_12,
    SIZE_X509_Module_PDU_13,
    SIZE_X509_Module_PDU_14,
    SIZE_X509_Module_PDU_15,
    SIZE_X509_Module_PDU_16,
    SIZE_X509_Module_PDU_17,
    SIZE_X509_Module_PDU_18,
    SIZE_X509_Module_PDU_19,
    SIZE_X509_Module_PDU_20,
    SIZE_X509_Module_PDU_21,
    SIZE_X509_Module_PDU_22,
    SIZE_X509_Module_PDU_23,
    SIZE_X509_Module_PDU_24,
    SIZE_X509_Module_PDU_25,
    SIZE_X509_Module_PDU_26,
    SIZE_X509_Module_PDU_27,
    SIZE_X509_Module_PDU_28,
    SIZE_X509_Module_PDU_29,
    SIZE_X509_Module_PDU_30,
    SIZE_X509_Module_PDU_31,
    SIZE_X509_Module_PDU_32,
    SIZE_X509_Module_PDU_33,
    SIZE_X509_Module_PDU_34,
    SIZE_X509_Module_PDU_35,
    SIZE_X509_Module_PDU_36,
    SIZE_X509_Module_PDU_37,
    SIZE_X509_Module_PDU_38,
    SIZE_X509_Module_PDU_39,
    SIZE_X509_Module_PDU_40,
    SIZE_X509_Module_PDU_41,
    SIZE_X509_Module_PDU_42,
    SIZE_X509_Module_PDU_43,
    SIZE_X509_Module_PDU_44,
    SIZE_X509_Module_PDU_45,
    SIZE_X509_Module_PDU_46,
    SIZE_X509_Module_PDU_47,
    SIZE_X509_Module_PDU_48,
    SIZE_X509_Module_PDU_49,
    SIZE_X509_Module_PDU_50,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
CTLVersion CertificateTrustList_version_default = 0;
ASN1bool_t BasicConstraints2_cA_default = 0;
ASN1bool_t Extension_critical_default = 0;
CertificateVersion CertificateToBeSigned_version_default = 0;

void ASN1CALL X509_Module_Startup(void)
{
    X509_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 51, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x39303578);
}

void ASN1CALL X509_Module_Cleanup(void)
{
    ASN1_CloseModule(X509_Module);
    X509_Module = NULL;
}

static int ASN1CALL ASN1Enc_EncodedObjectID(ASN1encoding_t enc, ASN1uint32_t tag, EncodedObjectID *val)
{
    if (!ASN1BEREncEoid(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedObjectID(ASN1decoding_t dec, ASN1uint32_t tag, EncodedObjectID *val)
{
    if (!ASN1BERDecEoid(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedObjectID(EncodedObjectID *val)
{
    if (val) {
	ASN1BEREoid_free(val);
    }
}

static int ASN1CALL ASN1Enc_Bits(ASN1encoding_t enc, ASN1uint32_t tag, Bits *val)
{
    if (!ASN1DEREncBitString(enc, tag ? tag : 0x3, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Bits(ASN1decoding_t dec, ASN1uint32_t tag, Bits *val)
{
    if (!ASN1BERDecBitString2(dec, tag ? tag : 0x3, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Bits(Bits *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BEREncS32(enc, tag ? tag : 0x2, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BERDecS32Val(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BEREncSX(enc, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BERDecSXVal(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val)
{
    if (val) {
	ASN1intx_free(val);
    }
}

static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1BERDecOctetString2(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_EnumeratedType(ASN1encoding_t enc, ASN1uint32_t tag, EnumeratedType *val)
{
    if (!ASN1BEREncU32(enc, tag ? tag : 0xa, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnumeratedType(ASN1decoding_t dec, ASN1uint32_t tag, EnumeratedType *val)
{
    if (!ASN1BERDecU32Val(dec, tag ? tag : 0xa, (ASN1uint32_t *)val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1DEREncUTCTime(enc, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1BERDecUTCTime(dec, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UtcTime(UtcTime *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NoticeReference_noticeNumbers(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference_noticeNumbers *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncS32(enc, 0x2, ((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NoticeReference_noticeNumbers(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference_noticeNumbers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NoticeReference_noticeNumbers_Seq *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecS32Val(dd, 0x2, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NoticeReference_noticeNumbers(NoticeReference_noticeNumbers *val)
{
    if (val) {
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AnyString(ASN1encoding_t enc, ASN1uint32_t tag, AnyString *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->u.octetString).length, ((val)->u.octetString).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->u.utf8String).length, ((val)->u.utf8String).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncCharString(enc, 0x12, ((val)->u.numericString).length, ((val)->u.numericString).value))
	    return 0;
	break;
    case 4:
	if (!ASN1DEREncCharString(enc, 0x13, ((val)->u.printableString).length, ((val)->u.printableString).value))
	    return 0;
	break;
    case 5:
	if (!ASN1DEREncMultibyteString(enc, 0x14, &(val)->u.teletexString))
	    return 0;
	break;
    case 6:
	if (!ASN1DEREncMultibyteString(enc, 0x15, &(val)->u.videotexString))
	    return 0;
	break;
    case 7:
	if (!ASN1DEREncCharString(enc, 0x16, ((val)->u.ia5String).length, ((val)->u.ia5String).value))
	    return 0;
	break;
    case 8:
	if (!ASN1DEREncCharString(enc, 0x19, ((val)->u.graphicString).length, ((val)->u.graphicString).value))
	    return 0;
	break;
    case 9:
	if (!ASN1DEREncCharString(enc, 0x1a, ((val)->u.visibleString).length, ((val)->u.visibleString).value))
	    return 0;
	break;
    case 10:
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->u.generalString).length, ((val)->u.generalString).value))
	    return 0;
	break;
    case 11:
	if (!ASN1DEREncChar32String(enc, 0x1c, ((val)->u.universalString).length, ((val)->u.universalString).value))
	    return 0;
	break;
    case 12:
	if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->u.bmpString).length, ((val)->u.bmpString).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AnyString(ASN1decoding_t dec, ASN1uint32_t tag, AnyString *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x4:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString2(dec, 0x4, &(val)->u.octetString))
	    return 0;
	break;
    case 0xc:
	(val)->choice = 2;
	if (!ASN1BERDecUTF8String(dec, 0xc, &(val)->u.utf8String))
	    return 0;
	break;
    case 0x12:
	(val)->choice = 3;
	if (!ASN1BERDecCharString(dec, 0x12, &(val)->u.numericString))
	    return 0;
	break;
    case 0x13:
	(val)->choice = 4;
	if (!ASN1BERDecCharString(dec, 0x13, &(val)->u.printableString))
	    return 0;
	break;
    case 0x14:
	(val)->choice = 5;
	if (!ASN1BERDecMultibyteString(dec, 0x14, &(val)->u.teletexString))
	    return 0;
	break;
    case 0x15:
	(val)->choice = 6;
	if (!ASN1BERDecMultibyteString(dec, 0x15, &(val)->u.videotexString))
	    return 0;
	break;
    case 0x16:
	(val)->choice = 7;
	if (!ASN1BERDecCharString(dec, 0x16, &(val)->u.ia5String))
	    return 0;
	break;
    case 0x19:
	(val)->choice = 8;
	if (!ASN1BERDecCharString(dec, 0x19, &(val)->u.graphicString))
	    return 0;
	break;
    case 0x1a:
	(val)->choice = 9;
	if (!ASN1BERDecCharString(dec, 0x1a, &(val)->u.visibleString))
	    return 0;
	break;
    case 0x1b:
	(val)->choice = 10;
	if (!ASN1BERDecCharString(dec, 0x1b, &(val)->u.generalString))
	    return 0;
	break;
    case 0x1c:
	(val)->choice = 11;
	if (!ASN1BERDecChar32String(dec, 0x1c, &(val)->u.universalString))
	    return 0;
	break;
    case 0x1e:
	(val)->choice = 12;
	if (!ASN1BERDecChar16String(dec, 0x1e, &(val)->u.bmpString))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AnyString(AnyString *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1utf8string_free(&(val)->u.utf8String);
	    break;
	case 3:
	    ASN1charstring_free(&(val)->u.numericString);
	    break;
	case 4:
	    ASN1charstring_free(&(val)->u.printableString);
	    break;
	case 5:
	    ASN1charstring_free(&(val)->u.teletexString);
	    break;
	case 6:
	    ASN1charstring_free(&(val)->u.videotexString);
	    break;
	case 7:
	    ASN1charstring_free(&(val)->u.ia5String);
	    break;
	case 8:
	    ASN1charstring_free(&(val)->u.graphicString);
	    break;
	case 9:
	    ASN1charstring_free(&(val)->u.visibleString);
	    break;
	case 10:
	    ASN1charstring_free(&(val)->u.generalString);
	    break;
	case 11:
	    ASN1char32string_free(&(val)->u.universalString);
	    break;
	case 12:
	    ASN1char16string_free(&(val)->u.bmpString);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_Name(ASN1encoding_t enc, ASN1uint32_t tag, Name *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RelativeDistinguishedName(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Name(ASN1decoding_t dec, ASN1uint32_t tag, Name *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (RelativeDistinguishedName *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_RelativeDistinguishedName(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Name(Name *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RelativeDistinguishedName(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RelativeDistinguishedName(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RelativeDistinguishedName(ASN1encoding_t enc, ASN1uint32_t tag, RelativeDistinguishedName *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AttributeTypeValue(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RelativeDistinguishedName(ASN1decoding_t dec, ASN1uint32_t tag, RelativeDistinguishedName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeTypeValue *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_AttributeTypeValue(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RelativeDistinguishedName(RelativeDistinguishedName *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AttributeTypeValue(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AttributeTypeValue(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeTypeValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeTypeValue *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeTypeValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeTypeValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeTypeValue(AttributeTypeValue *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
    }
}

static int ASN1CALL ASN1Enc_DSSParameters(ASN1encoding_t enc, ASN1uint32_t tag, DSSParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->q))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DSSParameters(ASN1decoding_t dec, ASN1uint32_t tag, DSSParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->q))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DSSParameters(DSSParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->q);
	ASN1intx_free(&(val)->g);
    }
}

static int ASN1CALL ASN1Enc_DSSSignature(ASN1encoding_t enc, ASN1uint32_t tag, DSSSignature *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->r))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->s))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DSSSignature(ASN1decoding_t dec, ASN1uint32_t tag, DSSSignature *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->r))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->s))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DSSSignature(DSSSignature *val)
{
    if (val) {
	ASN1intx_free(&(val)->r);
	ASN1intx_free(&(val)->s);
    }
}

static int ASN1CALL ASN1Enc_DHParameters(ASN1encoding_t enc, ASN1uint32_t tag, DHParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->privateValueLength))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DHParameters(ASN1decoding_t dec, ASN1uint32_t tag, DHParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateValueLength))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DHParameters(DHParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->g);
	if ((val)->o[0] & 0x80) {
	    ASN1intx_free(&(val)->privateValueLength);
	}
    }
}

static int ASN1CALL ASN1Enc_X942DhValidationParams(ASN1encoding_t enc, ASN1uint32_t tag, X942DhValidationParams *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->seed).length, ((val)->seed).value))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pgenCounter))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhValidationParams(ASN1decoding_t dec, ASN1uint32_t tag, X942DhValidationParams *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->seed))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, &(val)->pgenCounter))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhValidationParams(X942DhValidationParams *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RC2CBCParameters(ASN1encoding_t enc, ASN1uint32_t tag, RC2CBCParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->iv).length, ((val)->iv).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RC2CBCParameters(ASN1decoding_t dec, ASN1uint32_t tag, RC2CBCParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->iv))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RC2CBCParameters(RC2CBCParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->capabilityID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->smimeParameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->capabilityID))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->smimeParameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->capabilityID);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SMIMECapability(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SMIMECapability *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SMIMECapability(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SMIMECapability(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SMIMECapability(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SubjectPublicKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, SubjectPublicKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubjectPublicKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, SubjectPublicKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubjectPublicKeyInfo(SubjectPublicKeyInfo *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
    }
}

static int ASN1CALL ASN1Enc_ChoiceOfTime(ASN1encoding_t enc, ASN1uint32_t tag, ChoiceOfTime *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncUTCTime(enc, 0x17, &(val)->u.utcTime))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->u.generalTime))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChoiceOfTime(ASN1decoding_t dec, ASN1uint32_t tag, ChoiceOfTime *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x17:
	(val)->choice = 1;
	if (!ASN1BERDecUTCTime(dec, 0x17, &(val)->u.utcTime))
	    return 0;
	break;
    case 0x18:
	(val)->choice = 2;
	if (!ASN1BERDecGeneralizedTime(dec, 0x18, &(val)->u.generalTime))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChoiceOfTime(ChoiceOfTime *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Validity(ASN1encoding_t enc, ASN1uint32_t tag, Validity *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->notBefore))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->notAfter))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Validity(ASN1decoding_t dec, ASN1uint32_t tag, Validity *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->notBefore))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->notAfter))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Validity(Validity *val)
{
    if (val) {
	ASN1Free_ChoiceOfTime(&(val)->notBefore);
	ASN1Free_ChoiceOfTime(&(val)->notAfter);
    }
}

static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_Extension(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Extension *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Extension(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extensions(Extensions *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Extension(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Extension(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->critical)
	o[0] &= ~0x80;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->extnId))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->critical))
	    return 0;
    }
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->extnValue).length, ((val)->extnValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->extnId))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->critical))
	    return 0;
    }
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->extnValue))
	return 0;
    if (!((val)->o[0] & 0x80))
	(val)->critical = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extension(Extension *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->extnId);
    }
}

static int ASN1CALL ASN1Enc_SignedContent(ASN1encoding_t enc, ASN1uint32_t tag, SignedContent *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedContent(ASN1decoding_t dec, ASN1uint32_t tag, SignedContent *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->toBeSigned))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedContent(SignedContent *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
    }
}

static int ASN1CALL ASN1Enc_RevokedCertificates(ASN1encoding_t enc, ASN1uint32_t tag, RevokedCertificates *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CRLEntry(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RevokedCertificates(ASN1decoding_t dec, ASN1uint32_t tag, RevokedCertificates *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CRLEntry *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CRLEntry(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RevokedCertificates(RevokedCertificates *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CRLEntry(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CRLEntry(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CRLEntry(ASN1encoding_t enc, ASN1uint32_t tag, CRLEntry *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->userCertificate))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->revocationDate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Extensions(enc, 0, &(val)->crlEntryExtensions))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRLEntry(ASN1decoding_t dec, ASN1uint32_t tag, CRLEntry *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->userCertificate))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->revocationDate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Extensions(dd, 0, &(val)->crlEntryExtensions))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CRLEntry(CRLEntry *val)
{
    if (val) {
	ASN1intx_free(&(val)->userCertificate);
	ASN1Free_ChoiceOfTime(&(val)->revocationDate);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Extensions(&(val)->crlEntryExtensions);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificationRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificationRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificationRequestInfo(CertificationRequestInfo *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	ASN1Free_Attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_CertificationRequestInfoDecode(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfoDecode *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificationRequestInfoDecode(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfoDecode *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificationRequestInfoDecode(CertificationRequestInfoDecode *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_KeygenRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeygenRequestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->challenge).length, ((val)->challenge).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeygenRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeygenRequestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->challenge))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeygenRequestInfo(KeygenRequestInfo *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	ASN1charstring_free(&(val)->challenge);
    }
}

static int ASN1CALL ASN1Enc_AuthorityKeyId(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->certIssuer))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x80000002, &(val)->certSerialNumber))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityKeyId(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x80000000, &(val)->keyIdentifier))
	    return 0;
    }
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000001) {
	    (val)->o[0] |= 0x40;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->certIssuer))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x80000002, &(val)->certSerialNumber))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityKeyId(AuthorityKeyId *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->certSerialNumber);
	}
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyValidity(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyValidity *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x80000000, &(val)->notBefore))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x80000001, &(val)->notAfter))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyValidity(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyValidity *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x80000000, &(val)->notBefore))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecGeneralizedTime(dd, 0x80000001, &(val)->notAfter))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyValidity(PrivateKeyValidity *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_CertPolicySet(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicySet *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CertPolicyId(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertPolicySet(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicySet *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertPolicyId *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CertPolicyId(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertPolicySet(CertPolicySet *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CertPolicyId(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CertPolicyId(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertPolicyId(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicyId *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncEoid(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertPolicyId(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicyId *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertPolicyElementId *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecEoid(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertPolicyId(CertPolicyId *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1BEREoid_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1BEREoid_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AltNames(ASN1encoding_t enc, ASN1uint32_t tag, AltNames *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_GeneralName(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltNames(ASN1decoding_t dec, ASN1uint32_t tag, AltNames *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (GeneralName *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_GeneralName(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AltNames(AltNames *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_GeneralName(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_GeneralName(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_GeneralNames(ASN1encoding_t enc, ASN1uint32_t tag, GeneralNames *val)
{
    if (!ASN1Enc_AltNames(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralNames(ASN1decoding_t dec, ASN1uint32_t tag, GeneralNames *val)
{
    if (!ASN1Dec_AltNames(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GeneralNames(GeneralNames *val)
{
    if (val) {
	ASN1Free_AltNames(val);
    }
}

static int ASN1CALL ASN1Enc_OtherName(ASN1encoding_t enc, ASN1uint32_t tag, OtherName *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherName(ASN1decoding_t dec, ASN1uint32_t tag, OtherName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType2(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherName(OtherName *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_EDIPartyName(ASN1encoding_t enc, ASN1uint32_t tag, EDIPartyName *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->nameAssigner))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->partyName))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EDIPartyName(ASN1decoding_t dec, ASN1uint32_t tag, EDIPartyName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->nameAssigner))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType2(dd0, &(val)->partyName))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EDIPartyName(EDIPartyName *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SubtreesConstraint(ASN1encoding_t enc, ASN1uint32_t tag, SubtreesConstraint *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubtreesConstraint(ASN1decoding_t dec, ASN1uint32_t tag, SubtreesConstraint *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubtreesConstraint(SubtreesConstraint *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BasicConstraints2(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->cA)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->cA))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->pathLenConstraint))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BasicConstraints2(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->cA))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->pathLenConstraint))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->cA = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CertificatePolicies(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyInformation(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatePolicies(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PolicyInformation *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_PolicyInformation(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatePolicies(CertificatePolicies *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyInformation(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyInformation(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyQualifiers(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifiers *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyQualifierInfo(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyQualifiers(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PolicyQualifierInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_PolicyQualifierInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyQualifiers(PolicyQualifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyQualifierInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyQualifierInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyQualifierInfo(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifierInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->policyQualifierId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->qualifier))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyQualifierInfo(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifierInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->policyQualifierId))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->qualifier))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyQualifierInfo(PolicyQualifierInfo *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->policyQualifierId);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_NoticeReference(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->organization);
    if (!ASN1DEREncCharString(enc, 0x16, t, (val)->organization))
	return 0;
    if (!ASN1Enc_NoticeReference_noticeNumbers(enc, 0, &(val)->noticeNumbers))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NoticeReference(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->organization))
	return 0;
    if (!ASN1Dec_NoticeReference_noticeNumbers(dd, 0, &(val)->noticeNumbers))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NoticeReference(NoticeReference *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->organization);
	ASN1Free_NoticeReference_noticeNumbers(&(val)->noticeNumbers);
    }
}

static int ASN1CALL ASN1Enc_DisplayText(ASN1encoding_t enc, ASN1uint32_t tag, DisplayText *val)
{
    ASN1uint32_t t;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.theVisibleString);
	if (!ASN1DEREncCharString(enc, 0x1a, t, (val)->u.theVisibleString))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->u.theBMPString).length, ((val)->u.theBMPString).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisplayText(ASN1decoding_t dec, ASN1uint32_t tag, DisplayText *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x1a:
	(val)->choice = 1;
	if (!ASN1BERDecZeroCharString(dec, 0x1a, &(val)->u.theVisibleString))
	    return 0;
	break;
    case 0x1e:
	(val)->choice = 2;
	if (!ASN1BERDecChar16String(dec, 0x1e, &(val)->u.theBMPString))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisplayText(DisplayText *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1ztcharstring_free((val)->u.theVisibleString);
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.theBMPString);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CertificatePolicies95(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies95 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyQualifiers(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatePolicies95(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies95 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PolicyQualifiers *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_PolicyQualifiers(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatePolicies95(CertificatePolicies95 *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyQualifiers(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyQualifiers(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CpsURLs(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CpsURLs_Seq(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpsURLs(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CpsURLs_Seq *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CpsURLs_Seq(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpsURLs(CpsURLs *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CpsURLs_Seq(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CpsURLs_Seq(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AuthorityKeyId2(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_GeneralNames(enc, 0x80000001, &(val)->authorityCertIssuer))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x80000002, &(val)->authorityCertSerialNumber))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityKeyId2(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x80000000, &(val)->keyIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_GeneralNames(dd, 0x80000001, &(val)->authorityCertIssuer))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x80000002, &(val)->authorityCertSerialNumber))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityKeyId2(AuthorityKeyId2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_GeneralNames(&(val)->authorityCertIssuer);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->authorityCertSerialNumber);
	}
    }
}

static int ASN1CALL ASN1Enc_AuthorityInfoAccess(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityInfoAccess *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_AccessDescription(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityInfoAccess(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityInfoAccess *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AccessDescription *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_AccessDescription(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityInfoAccess(AuthorityInfoAccess *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AccessDescription(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AccessDescription(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CRLDistributionPoints(ASN1encoding_t enc, ASN1uint32_t tag, CRLDistributionPoints *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_DistributionPoint(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRLDistributionPoints(ASN1decoding_t dec, ASN1uint32_t tag, CRLDistributionPoints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (DistributionPoint *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_DistributionPoint(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CRLDistributionPoints(CRLDistributionPoints *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_DistributionPoint(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_DistributionPoint(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DistributionPointName(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPointName *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_GeneralNames(enc, 0x80000000, &(val)->u.fullName))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_RelativeDistinguishedName(enc, 0x80000001, &(val)->u.nameRelativeToCRLIssuer))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DistributionPointName(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPointName *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_GeneralNames(dec, 0x80000000, &(val)->u.fullName))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_RelativeDistinguishedName(dec, 0x80000001, &(val)->u.nameRelativeToCRLIssuer))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DistributionPointName(DistributionPointName *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_GeneralNames(&(val)->u.fullName);
	    break;
	case 2:
	    ASN1Free_RelativeDistinguishedName(&(val)->u.nameRelativeToCRLIssuer);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentType);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SeqOfAny *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SeqOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SeqOfAny(SeqOfAny *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TimeStampRequest(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->timeStampAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->attributesTS))
	    return 0;
    }
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->content))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TimeStampRequest(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->timeStampAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->attributesTS))
	    return 0;
    }
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->content))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TimeStampRequest(TimeStampRequest *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->timeStampAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributesTS);
	}
	ASN1Free_ContentInfo(&(val)->content);
    }
}

static int ASN1CALL ASN1Enc_ContentInfoOTS(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoOTS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentTypeOTS))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contentOTS).length, ((val)->contentOTS).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoOTS(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoOTS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentTypeOTS))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString2(dd0, 0x4, &(val)->contentOTS))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoOTS(ContentInfoOTS *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentTypeOTS);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_TimeStampRequestOTS(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequestOTS *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->timeStampAlgorithmOTS))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->attributesOTS))
	    return 0;
    }
    if (!ASN1Enc_ContentInfoOTS(enc, 0, &(val)->contentOTS))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TimeStampRequestOTS(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequestOTS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->timeStampAlgorithmOTS))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->attributesOTS))
	    return 0;
    }
    if (!ASN1Dec_ContentInfoOTS(dd, 0, &(val)->contentOTS))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TimeStampRequestOTS(TimeStampRequestOTS *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->timeStampAlgorithmOTS);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributesOTS);
	}
	ASN1Free_ContentInfoOTS(&(val)->contentOTS);
    }
}

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncEoid(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (UsageIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecEoid(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1BEREoid_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1BEREoid_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SubjectUsage(ASN1encoding_t enc, ASN1uint32_t tag, SubjectUsage *val)
{
    if (!ASN1Enc_EnhancedKeyUsage(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubjectUsage(ASN1decoding_t dec, ASN1uint32_t tag, SubjectUsage *val)
{
    if (!ASN1Dec_EnhancedKeyUsage(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubjectUsage(SubjectUsage *val)
{
    if (val) {
	ASN1Free_EnhancedKeyUsage(val);
    }
}

static int ASN1CALL ASN1Enc_TrustedSubjects(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubjects *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TrustedSubject(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TrustedSubjects(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubjects *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (TrustedSubject *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_TrustedSubject(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TrustedSubjects(TrustedSubjects *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TrustedSubject(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TrustedSubject(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TrustedSubject(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubject *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->subjectIdentifier).length, ((val)->subjectIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->subjectAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TrustedSubject(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubject *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->subjectIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->subjectAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TrustedSubject(TrustedSubject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->subjectAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->name).length, ((val)->name).value))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->value).length, ((val)->value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->name))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val)
{
    if (val) {
	ASN1char16string_free(&(val)->name);
	ASN1char16string_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keySpec))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->cspName).length, ((val)->cspName).value))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->keySpec))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->cspName))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val)
{
    if (val) {
	ASN1char16string_free(&(val)->cspName);
    }
}

static int ASN1CALL ASN1Enc_CpsURLs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->url);
    if (!ASN1DEREncCharString(enc, 0x16, t, (val)->url))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->digestAlgorithmId))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpsURLs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->url))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->digestAlgorithmId))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->digest))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpsURLs_Seq(CpsURLs_Seq *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->url);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AlgorithmIdentifier(&(val)->digestAlgorithmId);
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_X942DhParameters(ASN1encoding_t enc, ASN1uint32_t tag, X942DhParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->q))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->j))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_X942DhValidationParams(enc, 0, &(val)->validationParams))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhParameters(ASN1decoding_t dec, ASN1uint32_t tag, X942DhParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->q))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->j))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_X942DhValidationParams(dd, 0, &(val)->validationParams))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhParameters(X942DhParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->g);
	ASN1intx_free(&(val)->q);
	if ((val)->o[0] & 0x80) {
	    ASN1intx_free(&(val)->j);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_X942DhValidationParams(&(val)->validationParams);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateToBeSigned *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->version == 0)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->signature))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1Enc_Validity(enc, 0, &(val)->validity))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x80000001, ((val)->issuerUniqueIdentifier).length, ((val)->issuerUniqueIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1DEREncBitString(enc, 0x80000002, ((val)->subjectUniqueIdentifier).length, ((val)->subjectUniqueIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateToBeSigned *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->signature))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->issuer))
	return 0;
    if (!ASN1Dec_Validity(dd, 0, &(val)->validity))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x80000001, &(val)->issuerUniqueIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecBitString2(dd, 0x80000002, &(val)->subjectUniqueIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->version = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateToBeSigned(CertificateToBeSigned *val)
{
    if (val) {
	ASN1intx_free(&(val)->serialNumber);
	ASN1Free_AlgorithmIdentifier(&(val)->signature);
	ASN1Free_Validity(&(val)->validity);
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Extensions(&(val)->extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateRevocationListToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
    }
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->signature))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->thisUpdate))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->nextUpdate))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RevokedCertificates(enc, 0, &(val)->revokedCertificates))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->crlExtensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateRevocationListToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	    return 0;
    }
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->signature))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->issuer))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->thisUpdate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x17 || t == 0x18) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->nextUpdate))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_RevokedCertificates(dd, 0, &(val)->revokedCertificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->crlExtensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateRevocationListToBeSigned(CertificateRevocationListToBeSigned *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->signature);
	ASN1Free_ChoiceOfTime(&(val)->thisUpdate);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ChoiceOfTime(&(val)->nextUpdate);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_RevokedCertificates(&(val)->revokedCertificates);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Extensions(&(val)->crlExtensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyAttributes(ASN1encoding_t enc, ASN1uint32_t tag, KeyAttributes *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->intendedKeyUsage).length, ((val)->intendedKeyUsage).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_PrivateKeyValidity(enc, 0, &(val)->privateKeyUsagePeriod))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyAttributes(ASN1decoding_t dec, ASN1uint32_t tag, KeyAttributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->keyIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x3, &(val)->intendedKeyUsage))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_PrivateKeyValidity(dd, 0, &(val)->privateKeyUsagePeriod))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyAttributes(KeyAttributes *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PrivateKeyValidity(&(val)->privateKeyUsagePeriod);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyUsageRestriction(ASN1encoding_t enc, ASN1uint32_t tag, KeyUsageRestriction *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertPolicySet(enc, 0, &(val)->certPolicySet))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->restrictedKeyUsage).length, ((val)->restrictedKeyUsage).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyUsageRestriction(ASN1decoding_t dec, ASN1uint32_t tag, KeyUsageRestriction *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertPolicySet(dd, 0, &(val)->certPolicySet))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x3, &(val)->restrictedKeyUsage))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyUsageRestriction(KeyUsageRestriction *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertPolicySet(&(val)->certPolicySet);
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_GeneralName(ASN1encoding_t enc, ASN1uint32_t tag, GeneralName *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_OtherName(enc, 0x80000000, &(val)->u.otherName))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncCharString(enc, 0x80000001, ((val)->u.rfc822Name).length, ((val)->u.rfc822Name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncCharString(enc, 0x80000002, ((val)->u.dNSName).length, ((val)->u.dNSName).value))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SeqOfAny(enc, 0x80000003, &(val)->u.x400Address))
	    return 0;
	break;
    case 5:
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->u.directoryName))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_SeqOfAny(enc, 0x80000005, &(val)->u.ediPartyName))
	    return 0;
	break;
    case 7:
	if (!ASN1DEREncCharString(enc, 0x80000006, ((val)->u.uniformResourceLocator).length, ((val)->u.uniformResourceLocator).value))
	    return 0;
	break;
    case 8:
	if (!ASN1DEREncOctetString(enc, 0x80000007, ((val)->u.iPAddress).length, ((val)->u.iPAddress).value))
	    return 0;
	break;
    case 9:
	if (!ASN1BEREncEoid(enc, 0x80000008, &(val)->u.registeredID))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralName(ASN1decoding_t dec, ASN1uint32_t tag, GeneralName *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_OtherName(dec, 0x80000000, &(val)->u.otherName))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecCharString(dec, 0x80000001, &(val)->u.rfc822Name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecCharString(dec, 0x80000002, &(val)->u.dNSName))
	    return 0;
	break;
    case 0x80000003:
	(val)->choice = 4;
	if (!ASN1Dec_SeqOfAny(dec, 0x80000003, &(val)->u.x400Address))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 5;
	if (!ASN1BERDecExplicitTag(dec, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOpenType2(dd0, &(val)->u.directoryName))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000005:
	(val)->choice = 6;
	if (!ASN1Dec_SeqOfAny(dec, 0x80000005, &(val)->u.ediPartyName))
	    return 0;
	break;
    case 0x80000006:
	(val)->choice = 7;
	if (!ASN1BERDecCharString(dec, 0x80000006, &(val)->u.uniformResourceLocator))
	    return 0;
	break;
    case 0x80000007:
	(val)->choice = 8;
	if (!ASN1BERDecOctetString2(dec, 0x80000007, &(val)->u.iPAddress))
	    return 0;
	break;
    case 0x80000008:
	(val)->choice = 9;
	if (!ASN1BERDecEoid(dec, 0x80000008, &(val)->u.registeredID))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GeneralName(GeneralName *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_OtherName(&(val)->u.otherName);
	    break;
	case 2:
	    ASN1charstring_free(&(val)->u.rfc822Name);
	    break;
	case 3:
	    ASN1charstring_free(&(val)->u.dNSName);
	    break;
	case 4:
	    ASN1Free_SeqOfAny(&(val)->u.x400Address);
	    break;
	case 5:
	    break;
	case 6:
	    ASN1Free_SeqOfAny(&(val)->u.ediPartyName);
	    break;
	case 7:
	    ASN1charstring_free(&(val)->u.uniformResourceLocator);
	    break;
	case 8:
	    break;
	case 9:
	    ASN1BEREoid_free(&(val)->u.registeredID);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BasicConstraints(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectType).length, ((val)->subjectType).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->pathLenConstraint))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SubtreesConstraint(enc, 0, &(val)->subtreesConstraint))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BasicConstraints(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->subjectType))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->pathLenConstraint))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_SubtreesConstraint(dd, 0, &(val)->subtreesConstraint))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BasicConstraints(BasicConstraints *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SubtreesConstraint(&(val)->subtreesConstraint);
	}
    }
}

static int ASN1CALL ASN1Enc_PolicyInformation(ASN1encoding_t enc, ASN1uint32_t tag, PolicyInformation *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->policyIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PolicyQualifiers(enc, 0, &(val)->policyQualifiers))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyInformation(ASN1decoding_t dec, ASN1uint32_t tag, PolicyInformation *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->policyIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_PolicyQualifiers(dd, 0, &(val)->policyQualifiers))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyInformation(PolicyInformation *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->policyIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PolicyQualifiers(&(val)->policyQualifiers);
	}
    }
}

static int ASN1CALL ASN1Enc_UserNotice(ASN1encoding_t enc, ASN1uint32_t tag, UserNotice *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NoticeReference(enc, 0, &(val)->noticeRef))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_DisplayText(enc, 0, &(val)->explicitText))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserNotice(ASN1decoding_t dec, ASN1uint32_t tag, UserNotice *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_NoticeReference(dd, 0, &(val)->noticeRef))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1a || t == 0x1e) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_DisplayText(dd, 0, &(val)->explicitText))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UserNotice(UserNotice *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NoticeReference(&(val)->noticeRef);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_DisplayText(&(val)->explicitText);
	}
    }
}

static int ASN1CALL ASN1Enc_VerisignQualifier1(ASN1encoding_t enc, ASN1uint32_t tag, VerisignQualifier1 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->practicesReference);
	if (!ASN1DEREncCharString(enc, 0x16, t, (val)->practicesReference))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncEoid(enc, 0x6, &(val)->noticeId))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncEoid(enc, 0x6, &(val)->nsiNoticeId))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_CpsURLs(enc, 0, &(val)->cpsURLs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VerisignQualifier1(ASN1decoding_t dec, ASN1uint32_t tag, VerisignQualifier1 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x16) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->practicesReference))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecEoid(dd0, 0x6, &(val)->noticeId))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecEoid(dd0, 0x6, &(val)->nsiNoticeId))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x10;
	if (!ASN1Dec_CpsURLs(dd, 0, &(val)->cpsURLs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VerisignQualifier1(VerisignQualifier1 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->practicesReference);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1BEREoid_free(&(val)->noticeId);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1BEREoid_free(&(val)->nsiNoticeId);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_CpsURLs(&(val)->cpsURLs);
	}
    }
}

static int ASN1CALL ASN1Enc_AccessDescription(ASN1encoding_t enc, ASN1uint32_t tag, AccessDescription *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->accessMethod))
	return 0;
    if (!ASN1Enc_GeneralName(enc, 0, &(val)->accessLocation))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AccessDescription(ASN1decoding_t dec, ASN1uint32_t tag, AccessDescription *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->accessMethod))
	return 0;
    if (!ASN1Dec_GeneralName(dd, 0, &(val)->accessLocation))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AccessDescription(AccessDescription *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->accessMethod);
	ASN1Free_GeneralName(&(val)->accessLocation);
    }
}

static int ASN1CALL ASN1Enc_DistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPoint *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_DistributionPointName(enc, 0, &(val)->distributionPoint))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x80000001, ((val)->reasons).length, ((val)->reasons).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_GeneralNames(enc, 0x80000002, &(val)->cRLIssuer))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPoint *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_DistributionPointName(dd0, 0, &(val)->distributionPoint))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x80000001, &(val)->reasons))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_GeneralNames(dd, 0x80000002, &(val)->cRLIssuer))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DistributionPoint(DistributionPoint *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DistributionPointName(&(val)->distributionPoint);
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_GeneralNames(&(val)->cRLIssuer);
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfoSeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoSeqOfAny *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SeqOfAny(enc, 0, &(val)->contentSeqOfAny))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoSeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoSeqOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentType))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SeqOfAny(dd0, 0, &(val)->contentSeqOfAny))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoSeqOfAny(ContentInfoSeqOfAny *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentType);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SeqOfAny(&(val)->contentSeqOfAny);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateTrustList(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTrustList *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->version == 0)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
    }
    if (!ASN1Enc_SubjectUsage(enc, 0, &(val)->subjectUsage))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->listIdentifier).length, ((val)->listIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->sequenceNumber))
	    return 0;
    }
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->ctlThisUpdate))
	return 0;
    if (o[0] & 0x10) {
	if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->ctlNextUpdate))
	    return 0;
    }
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->subjectAlgorithm))
	return 0;
    if (o[0] & 0x8) {
	if (!ASN1Enc_TrustedSubjects(enc, 0, &(val)->trustedSubjects))
	    return 0;
    }
    if (o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->ctlExtensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateTrustList(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTrustList *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	    return 0;
    }
    if (!ASN1Dec_SubjectUsage(dd, 0, &(val)->subjectUsage))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->listIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->sequenceNumber))
	    return 0;
    }
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->ctlThisUpdate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x17 || t == 0x18) {
	(val)->o[0] |= 0x10;
	if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->ctlNextUpdate))
	    return 0;
    }
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->subjectAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_TrustedSubjects(dd, 0, &(val)->trustedSubjects))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->ctlExtensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->version = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateTrustList(CertificateTrustList *val)
{
    if (val) {
	ASN1Free_SubjectUsage(&(val)->subjectUsage);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequenceNumber);
	}
	ASN1Free_ChoiceOfTime(&(val)->ctlThisUpdate);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ChoiceOfTime(&(val)->ctlNextUpdate);
	}
	ASN1Free_AlgorithmIdentifier(&(val)->subjectAlgorithm);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_TrustedSubjects(&(val)->trustedSubjects);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Extensions(&(val)->ctlExtensions);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\x509.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#ifndef _X509_Module_H_
#define _X509_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1int32_t NoticeReference_noticeNumbers_Seq;

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1wstring_t UTF8STRING;

typedef ASN1encodedOID_t EncodedObjectID;
#define EncodedObjectID_PDU 0
#define SIZE_X509_Module_PDU_0 sizeof(EncodedObjectID)

typedef BITSTRING Bits;
#define Bits_PDU 1
#define SIZE_X509_Module_PDU_1 sizeof(Bits)

typedef ASN1int32_t CertificateVersion;
#define CertificateVersion_v1 0
#define CertificateVersion_v2 1
#define CertificateVersion_v3 2

typedef HUGEINTEGER CertificateSerialNumber;

typedef BITSTRING UniqueIdentifier;

typedef ASN1int32_t CRLVersion;
#define CRLVersion_v1 0
#define CRLVersion_v2 1

typedef ASN1int32_t CertificationRequestInfoVersion;

typedef OCTETSTRING KeyIdentifier;

typedef BITSTRING KeyUsage;

typedef EncodedObjectID CertPolicyElementId;

typedef BITSTRING SubjectType;

typedef BITSTRING ReasonFlags;

typedef ASN1int32_t IntegerType;
#define IntegerType_PDU 2
#define SIZE_X509_Module_PDU_2 sizeof(IntegerType)

typedef HUGEINTEGER HugeIntegerType;
#define HugeIntegerType_PDU 3
#define SIZE_X509_Module_PDU_3 sizeof(HugeIntegerType)

typedef OCTETSTRING OctetStringType;
#define OctetStringType_PDU 4
#define SIZE_X509_Module_PDU_4 sizeof(OctetStringType)

typedef enum EnumeratedType {
    dummyEnumerated0 = 0,
} EnumeratedType;
#define EnumeratedType_PDU 5
#define SIZE_X509_Module_PDU_5 sizeof(EnumeratedType)

typedef ASN1utctime_t UtcTime;
#define UtcTime_PDU 6
#define SIZE_X509_Module_PDU_6 sizeof(UtcTime)

typedef EncodedObjectID ContentType;

typedef EncodedObjectID UsageIdentifier;

typedef ASN1int32_t CTLVersion;
#define CTLVersion_v1 0

typedef OCTETSTRING ListIdentifier;

typedef OCTETSTRING SubjectIdentifier;

typedef struct NoticeReference_noticeNumbers {
    ASN1uint32_t count;
    NoticeReference_noticeNumbers_Seq *value;
} NoticeReference_noticeNumbers;

typedef struct AnyString {
    ASN1choice_t choice;
    union {
#	define octetString_chosen 1
	OCTETSTRING octetString;
#	define utf8String_chosen 2
	UTF8STRING utf8String;
#	define numericString_chosen 3
	NUMERICSTRING numericString;
#	define printableString_chosen 4
	PRINTABLESTRING printableString;
#	define teletexString_chosen 5
	TELETEXSTRING teletexString;
#	define videotexString_chosen 6
	VIDEOTEXSTRING videotexString;
#	define ia5String_chosen 7
	IA5STRING ia5String;
#	define graphicString_chosen 8
	GRAPHICSTRING graphicString;
#	define visibleString_chosen 9
	VISIBLESTRING visibleString;
#	define generalString_chosen 10
	GENERALSTRING generalString;
#	define universalString_chosen 11
	UNIVERSALSTRING universalString;
#	define bmpString_chosen 12
	BMPSTRING bmpString;
    } u;
} AnyString;
#define AnyString_PDU 7
#define SIZE_X509_Module_PDU_7 sizeof(AnyString)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} AlgorithmIdentifier;

typedef struct Name {
    ASN1uint32_t count;
    struct RelativeDistinguishedName *value;
} Name;
#define Name_PDU 8
#define SIZE_X509_Module_PDU_8 sizeof(Name)

typedef struct RelativeDistinguishedName {
    ASN1uint32_t count;
    struct AttributeTypeValue *value;
} RelativeDistinguishedName;

typedef struct AttributeTypeValue {
    EncodedObjectID type;
    NOCOPYANY value;
} AttributeTypeValue;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    NOCOPYANY *value;
} AttributeSetValue;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;
#define Attributes_PDU 9
#define SIZE_X509_Module_PDU_9 sizeof(Attributes)

typedef struct RSAPublicKey {
    HUGEINTEGER modulus;
    ASN1uint32_t publicExponent;
} RSAPublicKey;
#define RSAPublicKey_PDU 10
#define SIZE_X509_Module_PDU_10 sizeof(RSAPublicKey)

typedef struct DSSParameters {
    HUGEINTEGER p;
    HUGEINTEGER q;
    HUGEINTEGER g;
} DSSParameters;
#define DSSParameters_PDU 11
#define SIZE_X509_Module_PDU_11 sizeof(DSSParameters)

typedef struct DSSSignature {
    HUGEINTEGER r;
    HUGEINTEGER s;
} DSSSignature;
#define DSSSignature_PDU 12
#define SIZE_X509_Module_PDU_12 sizeof(DSSSignature)

typedef struct DHParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    HUGEINTEGER p;
    HUGEINTEGER g;
#   define privateValueLength_present 0x80
    HUGEINTEGER privateValueLength;
} DHParameters;
#define DHParameters_PDU 13
#define SIZE_X509_Module_PDU_13 sizeof(DHParameters)

typedef struct X942DhValidationParams {
    BITSTRING seed;
    ASN1uint32_t pgenCounter;
} X942DhValidationParams;

typedef struct RC2CBCParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
#   define iv_present 0x80
    OCTETSTRING iv;
} RC2CBCParameters;
#define RC2CBCParameters_PDU 14
#define SIZE_X509_Module_PDU_14 sizeof(RC2CBCParameters)

typedef struct SMIMECapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID capabilityID;
#   define smimeParameters_present 0x80
    NOCOPYANY smimeParameters;
} SMIMECapability;

typedef struct SMIMECapabilities {
    ASN1uint32_t count;
    struct SMIMECapability *value;
} SMIMECapabilities;
#define SMIMECapabilities_PDU 15
#define SIZE_X509_Module_PDU_15 sizeof(SMIMECapabilities)

typedef struct SubjectPublicKeyInfo {
    AlgorithmIdentifier algorithm;
    BITSTRING subjectPublicKey;
} SubjectPublicKeyInfo;
#define SubjectPublicKeyInfo_PDU 16
#define SIZE_X509_Module_PDU_16 sizeof(SubjectPublicKeyInfo)

typedef struct ChoiceOfTime {
    ASN1choice_t choice;
    union {
#	define utcTime_chosen 1
	ASN1utctime_t utcTime;
#	define generalTime_chosen 2
	ASN1generalizedtime_t generalTime;
    } u;
} ChoiceOfTime;
#define ChoiceOfTime_PDU 17
#define SIZE_X509_Module_PDU_17 sizeof(ChoiceOfTime)

typedef struct Validity {
    ChoiceOfTime notBefore;
    ChoiceOfTime notAfter;
} Validity;

typedef struct Extensions {
    ASN1uint32_t count;
    struct Extension *value;
} Extensions;
#define Extensions_PDU 18
#define SIZE_X509_Module_PDU_18 sizeof(Extensions)

typedef struct Extension {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID extnId;
#   define critical_present 0x80
    ASN1bool_t critical;
    OCTETSTRING extnValue;
} Extension;

typedef struct SignedContent {
    NOCOPYANY toBeSigned;
    AlgorithmIdentifier algorithm;
    BITSTRING signature;
} SignedContent;
#define SignedContent_PDU 19
#define SIZE_X509_Module_PDU_19 sizeof(SignedContent)

typedef struct RevokedCertificates {
    ASN1uint32_t count;
    struct CRLEntry *value;
} RevokedCertificates;

typedef struct CRLEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CertificateSerialNumber userCertificate;
    ChoiceOfTime revocationDate;
#   define crlEntryExtensions_present 0x80
    Extensions crlEntryExtensions;
} CRLEntry;

typedef struct CertificationRequestInfo {
    CertificationRequestInfoVersion version;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
    Attributes attributes;
} CertificationRequestInfo;
#define CertificationRequestInfo_PDU 20
#define SIZE_X509_Module_PDU_20 sizeof(CertificationRequestInfo)

typedef struct CertificationRequestInfoDecode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CertificationRequestInfoVersion version;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
#   define attributes_present 0x80
    Attributes attributes;
} CertificationRequestInfoDecode;
#define CertificationRequestInfoDecode_PDU 21
#define SIZE_X509_Module_PDU_21 sizeof(CertificationRequestInfoDecode)

typedef struct KeygenRequestInfo {
    SubjectPublicKeyInfo subjectPublicKeyInfo;
    IA5STRING challenge;
} KeygenRequestInfo;
#define KeygenRequestInfo_PDU 22
#define SIZE_X509_Module_PDU_22 sizeof(KeygenRequestInfo)

typedef struct AuthorityKeyId {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthorityKeyId_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define certIssuer_present 0x40
    NOCOPYANY certIssuer;
#   define certSerialNumber_present 0x20
    CertificateSerialNumber certSerialNumber;
} AuthorityKeyId;
#define AuthorityKeyId_PDU 23
#define SIZE_X509_Module_PDU_23 sizeof(AuthorityKeyId)

typedef struct PrivateKeyValidity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define notBefore_present 0x80
    ASN1generalizedtime_t notBefore;
#   define notAfter_present 0x40
    ASN1generalizedtime_t notAfter;
} PrivateKeyValidity;

typedef struct CertPolicySet {
    ASN1uint32_t count;
    struct CertPolicyId *value;
} CertPolicySet;

typedef struct CertPolicyId {
    ASN1uint32_t count;
    CertPolicyElementId *value;
} CertPolicyId;

typedef struct AltNames {
    ASN1uint32_t count;
    struct GeneralName *value;
} AltNames;
#define AltNames_PDU 24
#define SIZE_X509_Module_PDU_24 sizeof(AltNames)

typedef AltNames GeneralNames;

typedef struct OtherName {
    EncodedObjectID type;
    NOCOPYANY value;
} OtherName;

typedef struct EDIPartyName {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define nameAssigner_present 0x80
    NOCOPYANY nameAssigner;
    NOCOPYANY partyName;
} EDIPartyName;
#define EDIPartyName_PDU 25
#define SIZE_X509_Module_PDU_25 sizeof(EDIPartyName)

typedef struct SubtreesConstraint {
    ASN1uint32_t count;
    NOCOPYANY *value;
} SubtreesConstraint;

typedef struct BasicConstraints2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cA_present 0x80
    ASN1bool_t cA;
#   define BasicConstraints2_pathLenConstraint_present 0x40
    ASN1int32_t pathLenConstraint;
} BasicConstraints2;
#define BasicConstraints2_PDU 26
#define SIZE_X509_Module_PDU_26 sizeof(BasicConstraints2)

typedef struct CertificatePolicies {
    ASN1uint32_t count;
    struct PolicyInformation *value;
} CertificatePolicies;
#define CertificatePolicies_PDU 27
#define SIZE_X509_Module_PDU_27 sizeof(CertificatePolicies)

typedef struct PolicyQualifiers {
    ASN1uint32_t count;
    struct PolicyQualifierInfo *value;
} PolicyQualifiers;

typedef struct PolicyQualifierInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID policyQualifierId;
#   define qualifier_present 0x80
    NOCOPYANY qualifier;
} PolicyQualifierInfo;

typedef struct NoticeReference {
    ASN1ztcharstring_t organization;
    NoticeReference_noticeNumbers noticeNumbers;
} NoticeReference;

typedef struct DisplayText {
    ASN1choice_t choice;
    union {
#	define theVisibleString_chosen 1
	ASN1ztcharstring_t theVisibleString;
#	define theBMPString_chosen 2
	ASN1char16string_t theBMPString;
    } u;
} DisplayText;

typedef struct CertificatePolicies95 {
    ASN1uint32_t count;
    struct PolicyQualifiers *value;
} CertificatePolicies95;
#define CertificatePolicies95_PDU 28
#define SIZE_X509_Module_PDU_28 sizeof(CertificatePolicies95)

typedef struct CpsURLs {
    ASN1uint32_t count;
    struct CpsURLs_Seq *value;
} CpsURLs;

typedef struct AuthorityKeyId2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthorityKeyId2_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define authorityCertIssuer_present 0x40
    GeneralNames authorityCertIssuer;
#   define authorityCertSerialNumber_present 0x20
    CertificateSerialNumber authorityCertSerialNumber;
} AuthorityKeyId2;
#define AuthorityKeyId2_PDU 29
#define SIZE_X509_Module_PDU_29 sizeof(AuthorityKeyId2)

typedef struct AuthorityInfoAccess {
    ASN1uint32_t count;
    struct AccessDescription *value;
} AuthorityInfoAccess;
#define AuthorityInfoAccess_PDU 30
#define SIZE_X509_Module_PDU_30 sizeof(AuthorityInfoAccess)

typedef struct CRLDistributionPoints {
    ASN1uint32_t count;
    struct DistributionPoint *value;
} CRLDistributionPoints;
#define CRLDistributionPoints_PDU 31
#define SIZE_X509_Module_PDU_31 sizeof(CRLDistributionPoints)

typedef struct DistributionPointName {
    ASN1choice_t choice;
    union {
#	define fullName_chosen 1
	GeneralNames fullName;
#	define nameRelativeToCRLIssuer_chosen 2
	RelativeDistinguishedName nameRelativeToCRLIssuer;
    } u;
} DistributionPointName;

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define content_present 0x80
    NOCOPYANY content;
} ContentInfo;
#define ContentInfo_PDU 32
#define SIZE_X509_Module_PDU_32 sizeof(ContentInfo)

typedef struct SeqOfAny {
    ASN1uint32_t count;
    NOCOPYANY *value;
} SeqOfAny;
#define SeqOfAny_PDU 33
#define SIZE_X509_Module_PDU_33 sizeof(SeqOfAny)

typedef struct TimeStampRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID timeStampAlgorithm;
#   define attributesTS_present 0x80
    Attributes attributesTS;
    ContentInfo content;
} TimeStampRequest;
#define TimeStampRequest_PDU 34
#define SIZE_X509_Module_PDU_34 sizeof(TimeStampRequest)

typedef struct ContentInfoOTS {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentTypeOTS;
#   define contentOTS_present 0x80
    OCTETSTRING contentOTS;
} ContentInfoOTS;
#define ContentInfoOTS_PDU 35
#define SIZE_X509_Module_PDU_35 sizeof(ContentInfoOTS)

typedef struct TimeStampRequestOTS {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID timeStampAlgorithmOTS;
#   define attributesOTS_present 0x80
    Attributes attributesOTS;
    ContentInfoOTS contentOTS;
} TimeStampRequestOTS;
#define TimeStampRequestOTS_PDU 36
#define SIZE_X509_Module_PDU_36 sizeof(TimeStampRequestOTS)

typedef struct EnhancedKeyUsage {
    ASN1uint32_t count;
    UsageIdentifier *value;
} EnhancedKeyUsage;
#define EnhancedKeyUsage_PDU 37
#define SIZE_X509_Module_PDU_37 sizeof(EnhancedKeyUsage)

typedef EnhancedKeyUsage SubjectUsage;

typedef struct TrustedSubjects {
    ASN1uint32_t count;
    struct TrustedSubject *value;
} TrustedSubjects;

typedef struct TrustedSubject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectIdentifier subjectIdentifier;
#   define subjectAttributes_present 0x80
    Attributes subjectAttributes;
} TrustedSubject;

typedef struct EnrollmentNameValuePair {
    BMPSTRING name;
    BMPSTRING value;
} EnrollmentNameValuePair;
#define EnrollmentNameValuePair_PDU 38
#define SIZE_X509_Module_PDU_38 sizeof(EnrollmentNameValuePair)

typedef struct CSPProvider {
    ASN1int32_t keySpec;
    BMPSTRING cspName;
    BITSTRING signature;
} CSPProvider;
#define CSPProvider_PDU 39
#define SIZE_X509_Module_PDU_39 sizeof(CSPProvider)

typedef struct CpsURLs_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1ztcharstring_t url;
#   define digestAlgorithmId_present 0x80
    AlgorithmIdentifier digestAlgorithmId;
#   define digest_present 0x40
    OCTETSTRING digest;
} CpsURLs_Seq;

typedef struct Attribute {
    EncodedObjectID type;
    AttributeSetValue values;
} Attribute;
#define Attribute_PDU 40
#define SIZE_X509_Module_PDU_40 sizeof(Attribute)

typedef struct X942DhParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    HUGEINTEGER p;
    HUGEINTEGER g;
    HUGEINTEGER q;
#   define j_present 0x80
    HUGEINTEGER j;
#   define validationParams_present 0x40
    X942DhValidationParams validationParams;
} X942DhParameters;
#define X942DhParameters_PDU 41
#define SIZE_X509_Module_PDU_41 sizeof(X942DhParameters)

typedef struct CertificateToBeSigned {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateToBeSigned_version_present 0x80
    CertificateVersion version;
    CertificateSerialNumber serialNumber;
    AlgorithmIdentifier signature;
    NOCOPYANY issuer;
    Validity validity;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
#   define issuerUniqueIdentifier_present 0x40
    UniqueIdentifier issuerUniqueIdentifier;
#   define subjectUniqueIdentifier_present 0x20
    UniqueIdentifier subjectUniqueIdentifier;
#   define extensions_present 0x10
    Extensions extensions;
} CertificateToBeSigned;
#define CertificateToBeSigned_PDU 42
#define SIZE_X509_Module_PDU_42 sizeof(CertificateToBeSigned)

typedef struct CertificateRevocationListToBeSigned {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateRevocationListToBeSigned_version_present 0x80
    CRLVersion version;
    AlgorithmIdentifier signature;
    NOCOPYANY issuer;
    ChoiceOfTime thisUpdate;
#   define nextUpdate_present 0x40
    ChoiceOfTime nextUpdate;
#   define revokedCertificates_present 0x20
    RevokedCertificates revokedCertificates;
#   define crlExtensions_present 0x10
    Extensions crlExtensions;
} CertificateRevocationListToBeSigned;
#define CertificateRevocationListToBeSigned_PDU 43
#define SIZE_X509_Module_PDU_43 sizeof(CertificateRevocationListToBeSigned)

typedef struct KeyAttributes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define KeyAttributes_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define intendedKeyUsage_present 0x40
    KeyUsage intendedKeyUsage;
#   define privateKeyUsagePeriod_present 0x20
    PrivateKeyValidity privateKeyUsagePeriod;
} KeyAttributes;
#define KeyAttributes_PDU 44
#define SIZE_X509_Module_PDU_44 sizeof(KeyAttributes)

typedef struct KeyUsageRestriction {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define certPolicySet_present 0x80
    CertPolicySet certPolicySet;
#   define restrictedKeyUsage_present 0x40
    KeyUsage restrictedKeyUsage;
} KeyUsageRestriction;
#define KeyUsageRestriction_PDU 45
#define SIZE_X509_Module_PDU_45 sizeof(KeyUsageRestriction)

typedef struct GeneralName {
    ASN1choice_t choice;
    union {
#	define otherName_chosen 1
	OtherName otherName;
#	define rfc822Name_chosen 2
	IA5STRING rfc822Name;
#	define dNSName_chosen 3
	IA5STRING dNSName;
#	define x400Address_chosen 4
	SeqOfAny x400Address;
#	define directoryName_chosen 5
	NOCOPYANY directoryName;
#	define ediPartyName_chosen 6
	SeqOfAny ediPartyName;
#	define uniformResourceLocator_chosen 7
	IA5STRING uniformResourceLocator;
#	define iPAddress_chosen 8
	OCTETSTRING iPAddress;
#	define registeredID_chosen 9
	EncodedObjectID registeredID;
    } u;
} GeneralName;

typedef struct BasicConstraints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectType subjectType;
#   define BasicConstraints_pathLenConstraint_present 0x80
    ASN1int32_t pathLenConstraint;
#   define subtreesConstraint_present 0x40
    SubtreesConstraint subtreesConstraint;
} BasicConstraints;
#define BasicConstraints_PDU 46
#define SIZE_X509_Module_PDU_46 sizeof(BasicConstraints)

typedef struct PolicyInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID policyIdentifier;
#   define policyQualifiers_present 0x80
    PolicyQualifiers policyQualifiers;
} PolicyInformation;

typedef struct UserNotice {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define noticeRef_present 0x80
    NoticeReference noticeRef;
#   define explicitText_present 0x40
    DisplayText explicitText;
} UserNotice;
#define UserNotice_PDU 47
#define SIZE_X509_Module_PDU_47 sizeof(UserNotice)

typedef struct VerisignQualifier1 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define practicesReference_present 0x80
    ASN1ztcharstring_t practicesReference;
#   define noticeId_present 0x40
    EncodedObjectID noticeId;
#   define nsiNoticeId_present 0x20
    EncodedObjectID nsiNoticeId;
#   define cpsURLs_present 0x10
    CpsURLs cpsURLs;
} VerisignQualifier1;
#define VerisignQualifier1_PDU 48
#define SIZE_X509_Module_PDU_48 sizeof(VerisignQualifier1)

typedef struct AccessDescription {
    EncodedObjectID accessMethod;
    GeneralName accessLocation;
} AccessDescription;

typedef struct DistributionPoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define distributionPoint_present 0x80
    DistributionPointName distributionPoint;
#   define reasons_present 0x40
    ReasonFlags reasons;
#   define cRLIssuer_present 0x20
    GeneralNames cRLIssuer;
} DistributionPoint;

typedef struct ContentInfoSeqOfAny {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define contentSeqOfAny_present 0x80
    SeqOfAny contentSeqOfAny;
} ContentInfoSeqOfAny;
#define ContentInfoSeqOfAny_PDU 49
#define SIZE_X509_Module_PDU_49 sizeof(ContentInfoSeqOfAny)

typedef struct CertificateTrustList {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateTrustList_version_present 0x80
    CTLVersion version;
    SubjectUsage subjectUsage;
#   define listIdentifier_present 0x40
    ListIdentifier listIdentifier;
#   define sequenceNumber_present 0x20
    HUGEINTEGER sequenceNumber;
    ChoiceOfTime ctlThisUpdate;
#   define ctlNextUpdate_present 0x10
    ChoiceOfTime ctlNextUpdate;
    AlgorithmIdentifier subjectAlgorithm;
#   define trustedSubjects_present 0x8
    TrustedSubjects trustedSubjects;
#   define ctlExtensions_present 0x4
    Extensions ctlExtensions;
} CertificateTrustList;
#define CertificateTrustList_PDU 50
#define SIZE_X509_Module_PDU_50 sizeof(CertificateTrustList)

extern CTLVersion CertificateTrustList_version_default;
extern ASN1bool_t BasicConstraints2_cA_default;
extern ASN1bool_t Extension_critical_default;
extern CertificateVersion CertificateToBeSigned_version_default;

extern ASN1module_t X509_Module;
extern void ASN1CALL X509_Module_Startup(void);
extern void ASN1CALL X509_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _X509_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\selfsign.cpp ===
#include "global.hxx"
#include <dbgdef.h>

PCCERT_CONTEXT
WINAPI
CertCreateSelfSignCertificate(
    IN          HCRYPTPROV                  hProv,          
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    ) {

    PCCERT_CONTEXT              pCertContext    = NULL;
    DWORD                       errBefore       = GetLastError();
    DWORD                       err             = ERROR_SUCCESS;
    DWORD                       cbPubKeyInfo    = 0;
    PCERT_PUBLIC_KEY_INFO       pPubKeyInfo     = NULL;
    BYTE *                      pbCert          = NULL;
    DWORD                       cbCert          = 0;
    LPSTR                       sz              = NULL;
    DWORD                       cb              = 0;

    CERT_INFO                   certInfo;
    GUID                        serialNbr;
    CRYPT_KEY_PROV_INFO         keyProvInfo;
    CERT_SIGNED_CONTENT_INFO    sigInfo;
    
    CRYPT_ALGORITHM_IDENTIFIER  algID;
    SYSTEMTIME                  startTime;
    SYSTEMTIME                  endTime;

    LPWSTR                      wsz             = NULL;
    BOOL                        fFreehProv      = FALSE;
    HCRYPTKEY                   hKey            = NULL;
    UUID                        guidContainerName;

    memset(&certInfo, 0, sizeof(CERT_INFO));
    memset(&serialNbr, 0, sizeof(serialNbr));
    memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
    memset(&sigInfo, 0, sizeof(CERT_SIGNED_CONTENT_INFO));

    // do key spec now because we need it
    if(pKeyProvInfo == NULL) 
        keyProvInfo.dwKeySpec = AT_SIGNATURE;
    else 
        keyProvInfo.dwKeySpec = pKeyProvInfo->dwKeySpec;

    // see if we have an hProv, if not, create one
    if(hProv == NULL) {

        fFreehProv = TRUE;

        // if not prov info, make one up, signing RSA cert, default provider
        if(pKeyProvInfo == NULL) {

            UuidCreate(&guidContainerName);
            UuidToStringU(&guidContainerName, &wsz);
        
    	    if( !CryptAcquireContextU(
    	        &hProv,
                 wsz,
                 NULL,
                 PROV_RSA_FULL,
                 CRYPT_NEWKEYSET) ) {
                 hProv = NULL;
                goto ErrorCryptAcquireContext;                
            }
        }
        else {

            // first use the existing keyset
    	    if( !CryptAcquireContextU(
    	        &hProv,
                 pKeyProvInfo->pwszContainerName,
                 pKeyProvInfo->pwszProvName,
                 pKeyProvInfo->dwProvType,
                 0) )  {

                // otherwise generate a keyset
        	    if( !CryptAcquireContextU(
        	        &hProv,
                     pKeyProvInfo->pwszContainerName,
                     pKeyProvInfo->pwszProvName,
                     pKeyProvInfo->dwProvType,
                     CRYPT_NEWKEYSET) )  {
                    hProv = NULL;
                    goto ErrorCryptAcquireContext; 
                }
            }
        }

        // we have the keyset, now make sure we have the key gen'ed
        if( !CryptGetUserKey(   hProv,
                                keyProvInfo.dwKeySpec,
                                &hKey) ) {

            // doesn't exist so gen it                        
            assert(hKey == NULL);
            if(!CryptGenKey(    hProv, 
                                keyProvInfo.dwKeySpec, 
                                0,
                                &hKey) ) {
                goto ErrorCryptGenKey;
            }
        }
    }

    __try {
        // get the exportable public key bits
        if( !CryptExportPublicKeyInfo( hProv,
                                keyProvInfo.dwKeySpec, 
                                X509_ASN_ENCODING,
                                NULL, 
                                &cbPubKeyInfo)                              ||
            (pPubKeyInfo =
                (PCERT_PUBLIC_KEY_INFO) _alloca(cbPubKeyInfo)) == NULL      ||
            !CryptExportPublicKeyInfo( hProv,
                                keyProvInfo.dwKeySpec, 
                                X509_ASN_ENCODING,
                                pPubKeyInfo,
                                &cbPubKeyInfo) )
            goto ErrorCryptExportPublicKeyInfo;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto ErrorCryptExportPublicKeyInfo;
    }

    // default if we don't have an algid
    if(pSignatureAlgorithm == NULL) {
        memset(&algID, 0, sizeof(algID));
        algID.pszObjId = szOID_OIWSEC_sha1RSASign;
        pSignatureAlgorithm = &algID;
    }

    //default if we don't have times
    if(pStartTime == NULL) {
        GetSystemTime(&startTime);
        pStartTime = &startTime;
    }

    if(pEndTime == NULL) {
        endTime = *pStartTime;
        endTime.wYear++;
        pEndTime = &endTime;
    }

    // make a temp cert, only care about key info
    // and serial number for uniqueness
    UuidCreate(&serialNbr);
    certInfo.dwVersion              = CERT_V3;
    certInfo.SubjectPublicKeyInfo   = *pPubKeyInfo;
    certInfo.SerialNumber.cbData    = sizeof(serialNbr);
    certInfo.SerialNumber.pbData    = (BYTE *) &serialNbr;
    certInfo.SignatureAlgorithm     = *pSignatureAlgorithm;
    certInfo.Issuer                 = *pSubjectIssuerBlob;
    certInfo.Subject                = *pSubjectIssuerBlob;

    // only put in extensions if we have them
    if( pExtensions != NULL) {
        certInfo.cExtension             = pExtensions->cExtension;
        certInfo.rgExtension            = pExtensions->rgExtension;
    }

    // put in the times
    SystemTimeToFileTime(pStartTime, &certInfo.NotBefore);
    SystemTimeToFileTime(pEndTime, &certInfo.NotAfter);
    
    __try {
        // encode the cert
        if( !CryptEncodeObject(
                CRYPT_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
                &certInfo,
                NULL,           // pbEncoded
                &sigInfo.ToBeSigned.cbData
                )                                               ||
            (sigInfo.ToBeSigned.pbData = (BYTE *) 
                _alloca(sigInfo.ToBeSigned.cbData)) == NULL     ||
            !CryptEncodeObject(
                CRYPT_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
                &certInfo,
                sigInfo.ToBeSigned.pbData,
                &sigInfo.ToBeSigned.cbData
                ) ) 
            goto ErrorEncodeTempCertToBeSigned;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto ErrorEncodeTempCertToBeSigned;
    }

    // sign the certificate
    sigInfo.SignatureAlgorithm = certInfo.SignatureAlgorithm;

    // this is to work around an OSS bug of not accepting zero length bit strings
    // this is only needed if we don't actually sign the code.
    sigInfo.Signature.pbData = (BYTE *) &sigInfo;
    sigInfo.Signature.cbData = 1;
    
    if( (CERT_CREATE_SELFSIGN_NO_SIGN & dwFlags) == 0 ) {

        __try {
            if( !CryptSignCertificate(
                    hProv,
                    keyProvInfo.dwKeySpec,
                    CRYPT_ASN_ENCODING,
                    sigInfo.ToBeSigned.pbData,
                    sigInfo.ToBeSigned.cbData,
                    &sigInfo.SignatureAlgorithm,
                    NULL,
                    NULL,
                    &sigInfo.Signature.cbData)      ||
            (sigInfo.Signature.pbData = (BYTE *) 
                _alloca(sigInfo.Signature.cbData)) == NULL     ||
            !CryptSignCertificate(
                    hProv,
                    keyProvInfo.dwKeySpec,
                    CRYPT_ASN_ENCODING,
                    sigInfo.ToBeSigned.pbData,
                    sigInfo.ToBeSigned.cbData,
                    &sigInfo.SignatureAlgorithm,
                    NULL,
                    sigInfo.Signature.pbData,
                    &sigInfo.Signature.cbData)  )
                goto ErrorCryptSignCertificate;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            goto ErrorCryptSignCertificate;
        }
    }
    
    __try {
        // encode the final cert.
        if( !CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_CERT,
                &sigInfo,
                NULL,
                &cbCert
                )                               ||
            (pbCert = (BYTE *)               
                _alloca(cbCert)) == NULL     ||
            !CryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_CERT,
                &sigInfo,
                pbCert, 
                &cbCert ) ) 
            goto ErrorEncodeTempCert;            
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto ErrorEncodeTempCert;            
    }

     // get a cert context from the encoding
    if( (pCertContext = CertCreateCertificateContext(
        CRYPT_ASN_ENCODING,
        pbCert,
        cbCert)) == NULL ) 
        goto ErrorCreateTempCertContext;

    if( (CERT_CREATE_SELFSIGN_NO_KEY_INFO & dwFlags) == 0 ) {
    
        // get the key prov info
        if(pKeyProvInfo == NULL)   {
        
            __try {
                // get a key prov info from the hProv
                if( !CryptGetProvParam( hProv,
                                    PP_NAME,
                                    NULL,
                                    &cb,
                                    0)                  ||
                    (sz = (char *) _alloca(cb)) == NULL ||
                    !CryptGetProvParam( hProv,
                                    PP_NAME,
                                    (BYTE *) sz,
                                    &cb,
                                    0) )
                    goto ErrorGetProvName;
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                goto ErrorGetProvName;
            }
            keyProvInfo.pwszProvName = MkWStr(sz);

            cb = 0; 
            sz = NULL;
            __try {
                if( !CryptGetProvParam( hProv,
                                    PP_CONTAINER,
                                    NULL,
                                    &cb,
                                    0)                  ||
                    (sz = (char *) _alloca(cb)) == NULL ||
                    !CryptGetProvParam( hProv,
                                    PP_CONTAINER,
                                    (BYTE *) sz,
                                    &cb,
                                    0) )
                    goto ErrorGetContainerName;
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                goto ErrorGetContainerName;
            }
            keyProvInfo.pwszContainerName = MkWStr(sz);

            cb = sizeof(keyProvInfo.dwProvType);
            if( !CryptGetProvParam( hProv,
                                PP_PROVTYPE,
                                (BYTE *) &keyProvInfo.dwProvType,
                                &cb,
                                0) )
                goto ErrorGetProvType;
            
            pKeyProvInfo = &keyProvInfo;
        }

        // put the key property on the certificate
        if( !CertSetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                pKeyProvInfo) )
            goto ErrorSetTempCertPropError;
    }
        
CommonReturn:

    if(hKey != NULL)
        CryptDestroyKey(hKey);
        
    if(fFreehProv && hProv != NULL)
        CryptReleaseContext(hProv, 0);
        
    if(keyProvInfo.pwszProvName != NULL)
        FreeWStr(keyProvInfo.pwszProvName);

    if(keyProvInfo.pwszContainerName != NULL)
        FreeWStr(keyProvInfo.pwszContainerName);

    if(wsz != NULL)
        LocalFree(wsz);

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);

    return(pCertContext);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS) 
        SetLastError(E_UNEXPECTED);
    err = GetLastError();

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    if(pCertContext != NULL)
        CertFreeCertificateContext(pCertContext);
    pCertContext = NULL;     

    goto CommonReturn;

TRACE_ERROR(ErrorCryptGenKey);
TRACE_ERROR(ErrorCryptAcquireContext);
TRACE_ERROR(ErrorCryptExportPublicKeyInfo);
TRACE_ERROR(ErrorEncodeTempCertToBeSigned);
TRACE_ERROR(ErrorEncodeTempCert);
TRACE_ERROR(ErrorCreateTempCertContext);
TRACE_ERROR(ErrorGetProvName);
TRACE_ERROR(ErrorGetContainerName);
TRACE_ERROR(ErrorGetProvType);
TRACE_ERROR(ErrorSetTempCertPropError);
TRACE_ERROR(ErrorCryptSignCertificate);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\callctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       callctx.cpp
//
//  Contents:   Certificate Chaining Infrastructure Call Context
//
//  History:    02-Mar-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::CChainCallContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CChainCallContext::CChainCallContext (
                         OUT BOOL& rfResult
                         )
{
    LRU_CACHE_CONFIG Config;

    m_hObjectCreationCache = NULL;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.pfnHash = CertObjectCacheHashMd5Identifier;
    Config.pfnOnRemoval = CallContextOnCreationCacheObjectRemoval;
    Config.cBuckets = DEFAULT_CREATION_CACHE_BUCKETS;

    rfResult = I_CryptCreateLruCache( &Config, &m_hObjectCreationCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::~CChainCallContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CChainCallContext::~CChainCallContext ()
{
    if ( m_hObjectCreationCache != NULL )
    {
        I_CryptFreeLruCache( m_hObjectCreationCache, 0, NULL );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::AddObjectToCreationCache, public
//
//  Synopsis:   add a certificate object to the creation cache
//
//----------------------------------------------------------------------------
BOOL
CChainCallContext::AddObjectToCreationCache (
                      IN PCCERTOBJECT pCertObject
                      )
{
    BOOL            fResult;
    CRYPT_DATA_BLOB DataBlob;
    HLRUENTRY       hEntry;

    DataBlob.cbData = pCertObject->CertificateHashSize();
    DataBlob.pbData = pCertObject->CertificateHash();

    fResult = I_CryptCreateLruEntry(
                     m_hObjectCreationCache,
                     &DataBlob,
                     pCertObject,
                     &hEntry
                     );

    if ( fResult == TRUE )
    {
        pCertObject->AddRef();
        I_CryptInsertLruEntry( hEntry, pCertObject );
        I_CryptReleaseLruEntry( hEntry );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::FindObjectInCreationCache, public
//
//  Synopsis:   find a certificate object in the creation cache
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CChainCallContext::FindObjectInCreationCache (
                       IN PCRYPT_DATA_BLOB pIdentifier
                       )
{
    HLRUENTRY    hFound;
    PCCERTOBJECT pFound = NULL;

    hFound = I_CryptFindLruEntry( m_hObjectCreationCache, pIdentifier );
    if ( hFound != NULL )
    {
        pFound = (PCCERTOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextCreateCallObject
//
//  Synopsis:   create a chain call context object
//
//----------------------------------------------------------------------------
BOOL WINAPI
CallContextCreateCallObject (
    OUT PCCHAINCALLCONTEXT* ppCallContext
    )
{
    BOOL               fResult = FALSE;
    PCCHAINCALLCONTEXT pCallContext;

    pCallContext = new CChainCallContext( fResult );
    if ( pCallContext == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == TRUE )
    {
        *ppCallContext = pCallContext;
    }
    else
    {
        CallContextFreeCallObject( pCallContext );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextFreeCallObject
//
//  Synopsis:   free the chain call context object
//
//----------------------------------------------------------------------------
VOID WINAPI
CallContextFreeCallObject (
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
    delete pCallContext;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextOnCreationCacheObjectRemoval
//
//  Synopsis:   removal notification callback
//
//----------------------------------------------------------------------------
VOID WINAPI
CallContextOnCreationCacheObjectRemoval (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    )
{
    ( (PCCERTOBJECT)pv )->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\wincert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       wincert.cpp
//
//  Contents:   Certificate, Certificate Revocation List (CRL),
//              Certificate Request and Certificate Name
//              Encode/Decode APIs
//
//              ASN.1 implementation uses the ASN1 compiler.
//
//  Functions:  CryptEncodeObject
//              CryptDecodeObject
//              CryptEncodeObjectEx
//              CryptDecodeObjectEx
//
//  History:    29-Feb-96       philh   created
//              20-Jan-98       philh   added "Ex" version
//
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifndef OSS_CRYPT_ASN1
#define ASN1_SUPPORTS_UTF8_TAG       1
#endif  // OSS_CRYPT_ASN1

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static const BYTE NullDer[2] = {0x05, 0x00};
static const CRYPT_OBJID_BLOB NullDerBlob = {2, (BYTE *)&NullDer[0]};

HCRYPTASN1MODULE hX509Asn1Module;

HCRYPTOIDFUNCSET hX509EncodeFuncSet;
HCRYPTOIDFUNCSET hX509DecodeFuncSet;
HCRYPTOIDFUNCSET hX509EncodeExFuncSet;
HCRYPTOIDFUNCSET hX509DecodeExFuncSet;


//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hX509Asn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hX509Asn1Module);
}

typedef BOOL (WINAPI *PFN_ENCODE_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const void *pvStructInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_DECODE_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

typedef BOOL (WINAPI *PFN_ENCODE_EX_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const void *pvStructInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_DECODE_EX_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CSPProviderEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CSP_PROVIDER pCSPProvider,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1CSPProviderDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
        
BOOL WINAPI Asn1NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
        
BOOL WINAPI Asn1NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CertInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CrlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CertRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509KeygenRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeygenRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509SignedContentEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_SIGNED_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509SignedContentDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509NameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509NameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 ASN.1 X509 Certificate Extensions Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_EXTENSIONS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );


//+-------------------------------------------------------------------------
//  ASN1 ASN.1 Public Key Info Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509PublicKeyInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 ASN.1 PKCS#1 RSAPublicKey Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pPubKeyStruc,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1RSAPublicKeyStrucDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 Extension ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityKeyIdDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AuthorityKeyId2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityKeyId2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509KeyAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeyAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AltNameEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_ALT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AltNameDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509KeyUsageRestrictionEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BasicConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BasicConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BasicConstraints2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BasicConstraints2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BitsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BitsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BitsWithoutTrailingZeroesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertPoliciesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICIES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertPoliciesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );


BOOL WINAPI Asn1X509PKIXUserNoticeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509AuthorityInfoAccessEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CrlDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrlDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509IntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509IntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509MultiByteIntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_INTEGER_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509MultiByteIntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509EnumeratedEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509EnumeratedDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509OctetStringEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509OctetStringDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ChoiceOfTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ChoiceOfTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AttributeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AttributeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ContentInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ContentInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509SequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509SequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509MultiByteUINTEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_UINT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509MultiByteUINTDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509DSSParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DSS_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DSSParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509DSSSignatureEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DSSSignatureDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509DHParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DHParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X942DhParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_X942_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X942DhParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1RC2CBCParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_RC2_CBC_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1RC2CBCParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1SMIMECapabilitiesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SMIME_CAPABILITIES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1SMIMECapabilitiesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1UtcTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN FILETIME * pFileTime,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1UtcTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1TimeStampRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_TIME_STAMP_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1TimeStampRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509AttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 Certificate Trust List (CTL) ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CtlUsageDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CtlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

#ifndef OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Encode / Decode the "UNICODE" Name Info
//
//  from certstr.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI UnicodeNameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
extern BOOL WINAPI UnicodeNameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Encode / Decode the "UNICODE" Name Value
//
//  from certstr.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI UnicodeNameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
extern BOOL WINAPI UnicodeNameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Encode sorted ctl info
//
//  from newstor.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI SortedCtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pCtlInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

#endif  // OSS_CRYPT_ASN1

#ifdef OSS_CRYPT_ASN1
#define ASN1_OID_OFFSET         10000 +
#define ASN1_OID_PREFIX         "OssCryptAsn1."
#else
#define ASN1_OID_OFFSET
#define ASN1_OID_PREFIX
#endif  // OSS_CRYPT_ASN1

#ifdef DEBUG_CRYPT_ASN1_MASTER
#define OSS_OID_OFFSET         10000
#define OSS_OID_PREFIX         "OssCryptAsn1."
#endif  // DEBUG_CRYPT_ASN1_MASTER

static const CRYPT_OID_FUNC_ENTRY X509EncodeExFuncTable[] = {
    ASN1_OID_OFFSET X509_CERT, Asn1X509SignedContentEncodeEx,
    ASN1_OID_OFFSET X509_CERT_TO_BE_SIGNED, Asn1X509CertInfoEncodeEx,
    ASN1_OID_OFFSET X509_CERT_CRL_TO_BE_SIGNED, Asn1X509CrlInfoEncodeEx,
    ASN1_OID_OFFSET X509_CERT_REQUEST_TO_BE_SIGNED, Asn1X509CertRequestInfoEncodeEx,
    ASN1_OID_OFFSET X509_EXTENSIONS, Asn1X509ExtensionsEncodeEx,
    ASN1_OID_OFFSET X509_NAME_VALUE, Asn1X509NameValueEncodeEx,
    ASN1_OID_OFFSET X509_NAME, Asn1X509NameInfoEncodeEx,
    ASN1_OID_OFFSET X509_PUBLIC_KEY_INFO, Asn1X509PublicKeyInfoEncodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID, Asn1X509AuthorityKeyIdEncodeEx,
    ASN1_OID_OFFSET X509_KEY_ATTRIBUTES, Asn1X509KeyAttributesEncodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionEncodeEx,
    ASN1_OID_OFFSET X509_ALTERNATE_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsEncodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE, Asn1X509BitsEncodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2EncodeEx,
    ASN1_OID_OFFSET X509_CERT_POLICIES, Asn1X509CertPoliciesEncodeEx,
    ASN1_OID_OFFSET PKCS_UTC_TIME, Asn1UtcTimeEncodeEx,
    ASN1_OID_OFFSET PKCS_TIME_REQUEST, Asn1TimeStampRequestInfoEncodeEx,
    ASN1_OID_OFFSET RSA_CSP_PUBLICKEYBLOB, Asn1RSAPublicKeyStrucEncodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME, UnicodeNameInfoEncodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X509_KEYGEN_REQUEST_TO_BE_SIGNED, Asn1X509KeygenRequestInfoEncodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTE, Asn1X509AttributeEncodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, Asn1X509ContentInfoSequenceOfAnyEncodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME_VALUE, UnicodeNameValueEncodeEx,
#endif  // OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_OCTET_STRING, Asn1X509OctetStringEncodeEx,
    ASN1_OID_OFFSET X509_BITS, Asn1X509BitsEncodeEx,
    ASN1_OID_OFFSET X509_INTEGER, Asn1X509IntegerEncodeEx,
    ASN1_OID_OFFSET X509_MULTI_BYTE_INTEGER, Asn1X509MultiByteIntegerEncodeEx,
    ASN1_OID_OFFSET X509_ENUMERATED, Asn1X509EnumeratedEncodeEx,
    ASN1_OID_OFFSET X509_CHOICE_OF_TIME, Asn1X509ChoiceOfTimeEncodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID2, Asn1X509AuthorityKeyId2EncodeEx, 
    ASN1_OID_OFFSET X509_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessEncodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO, Asn1X509ContentInfoEncodeEx,
    ASN1_OID_OFFSET X509_SEQUENCE_OF_ANY, Asn1X509SequenceOfAnyEncodeEx,
    ASN1_OID_OFFSET X509_CRL_DIST_POINTS, Asn1X509CrlDistPointsEncodeEx,

    ASN1_OID_OFFSET X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageEncodeEx,
    ASN1_OID_OFFSET PKCS_CTL, Asn1X509CtlInfoEncodeEx,

    ASN1_OID_OFFSET X509_MULTI_BYTE_UINT, Asn1X509MultiByteUINTEncodeEx,
    ASN1_OID_OFFSET X509_DSS_PARAMETERS, Asn1X509DSSParametersEncodeEx,
    ASN1_OID_OFFSET X509_DSS_SIGNATURE, Asn1X509DSSSignatureEncodeEx,
    ASN1_OID_OFFSET PKCS_RC2_CBC_PARAMETERS, Asn1RC2CBCParametersEncodeEx,
    ASN1_OID_OFFSET PKCS_SMIME_CAPABILITIES, Asn1SMIMECapabilitiesEncodeEx,

    ASN1_OID_OFFSET X509_DH_PARAMETERS, Asn1X509DHParametersEncodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTES, Asn1X509AttributesEncodeEx,
#ifdef CAPI_INCLUDE_CTL
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET PKCS_SORTED_CTL, SortedCtlInfoEncodeEx,
#endif  // OSS_CRYPT_ASN1
#endif // CAPI_INCLUDE_CTL
    ASN1_OID_OFFSET X942_DH_PARAMETERS, Asn1X942DhParametersEncodeEx,
    ASN1_OID_OFFSET X509_BITS_WITHOUT_TRAILING_ZEROES, Asn1X509BitsWithoutTrailingZeroesEncodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER, Asn1X509AuthorityKeyIdEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_ATTRIBUTES, Asn1X509KeyAttributesEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionEncodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE, Asn1X509BitsEncodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2EncodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES, Asn1X509CertPoliciesEncodeEx,

    ASN1_OID_PREFIX szOID_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeEncodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER2, Asn1X509AuthorityKeyId2EncodeEx, 
    ASN1_OID_PREFIX szOID_SUBJECT_KEY_IDENTIFIER, Asn1X509OctetStringEncodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME2, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME2, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_CRL_REASON_CODE, Asn1X509EnumeratedEncodeEx,
    ASN1_OID_PREFIX szOID_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessEncodeEx,
    ASN1_OID_PREFIX szOID_CRL_DIST_POINTS, Asn1X509CrlDistPointsEncodeEx,

    ASN1_OID_PREFIX szOID_CERT_EXTENSIONS, Asn1X509ExtensionsEncodeEx,
    ASN1_OID_PREFIX szOID_NEXT_UPDATE_LOCATION, Asn1X509AltNameEncodeEx,

    ASN1_OID_PREFIX szOID_ENHANCED_KEY_USAGE, Asn1X509CtlUsageEncodeEx,
    ASN1_OID_PREFIX szOID_CTL, Asn1X509CtlInfoEncodeEx,

    ASN1_OID_PREFIX szOID_RSA_RC2CBC, Asn1RC2CBCParametersEncodeEx,
    ASN1_OID_PREFIX szOID_RSA_SMIMECapabilities, Asn1SMIMECapabilitiesEncodeEx,
    ASN1_OID_PREFIX szOID_RSA_signingTime, Asn1UtcTimeEncodeEx,

    ASN1_OID_PREFIX szOID_ENROLLMENT_NAME_VALUE_PAIR, Asn1NameValueEncodeEx,
	szOID_ENROLLMENT_CSP_PROVIDER, Asn1CSPProviderEncodeEx,
};

#define X509_ENCODE_EX_FUNC_COUNT (sizeof(X509EncodeExFuncTable) / \
                                    sizeof(X509EncodeExFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeExFuncTable[] = {
    ASN1_OID_OFFSET X509_CERT, Asn1X509SignedContentDecodeEx,
    ASN1_OID_OFFSET X509_CERT_TO_BE_SIGNED, Asn1X509CertInfoDecodeEx,
    ASN1_OID_OFFSET X509_CERT_CRL_TO_BE_SIGNED, Asn1X509CrlInfoDecodeEx,
    ASN1_OID_OFFSET X509_CERT_REQUEST_TO_BE_SIGNED, Asn1X509CertRequestInfoDecodeEx,
    ASN1_OID_OFFSET X509_EXTENSIONS, Asn1X509ExtensionsDecodeEx,
    ASN1_OID_OFFSET X509_NAME_VALUE, Asn1X509NameValueDecodeEx,
    ASN1_OID_OFFSET X509_NAME, Asn1X509NameInfoDecodeEx,
    ASN1_OID_OFFSET X509_PUBLIC_KEY_INFO, Asn1X509PublicKeyInfoDecodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID, Asn1X509AuthorityKeyIdDecodeEx,
    ASN1_OID_OFFSET X509_KEY_ATTRIBUTES, Asn1X509KeyAttributesDecodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionDecodeEx,
    ASN1_OID_OFFSET X509_ALTERNATE_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsDecodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE, Asn1X509BitsDecodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2DecodeEx,
    ASN1_OID_OFFSET X509_CERT_POLICIES, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_OFFSET PKCS_UTC_TIME, Asn1UtcTimeDecodeEx,
    ASN1_OID_OFFSET PKCS_TIME_REQUEST, Asn1TimeStampRequestInfoDecodeEx,
    ASN1_OID_OFFSET RSA_CSP_PUBLICKEYBLOB, Asn1RSAPublicKeyStrucDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME, UnicodeNameInfoDecodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X509_KEYGEN_REQUEST_TO_BE_SIGNED, Asn1X509KeygenRequestInfoDecodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTE, Asn1X509AttributeDecodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, Asn1X509ContentInfoSequenceOfAnyDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME_VALUE, UnicodeNameValueDecodeEx,
#endif  // OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_OCTET_STRING, Asn1X509OctetStringDecodeEx,
    ASN1_OID_OFFSET X509_BITS, Asn1X509BitsDecodeEx,
    ASN1_OID_OFFSET X509_INTEGER, Asn1X509IntegerDecodeEx,
    ASN1_OID_OFFSET X509_MULTI_BYTE_INTEGER, Asn1X509MultiByteIntegerDecodeEx,
    ASN1_OID_OFFSET X509_ENUMERATED, Asn1X509EnumeratedDecodeEx,
    ASN1_OID_OFFSET X509_CHOICE_OF_TIME, Asn1X509ChoiceOfTimeDecodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID2, Asn1X509AuthorityKeyId2DecodeEx, 
    ASN1_OID_OFFSET X509_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessDecodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO, Asn1X509ContentInfoDecodeEx,
    ASN1_OID_OFFSET X509_SEQUENCE_OF_ANY, Asn1X509SequenceOfAnyDecodeEx,
    ASN1_OID_OFFSET X509_CRL_DIST_POINTS, Asn1X509CrlDistPointsDecodeEx,

    ASN1_OID_OFFSET X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageDecodeEx,
    ASN1_OID_OFFSET PKCS_CTL, Asn1X509CtlInfoDecodeEx,

    ASN1_OID_OFFSET X509_MULTI_BYTE_UINT, Asn1X509MultiByteUINTDecodeEx,
    ASN1_OID_OFFSET X509_DSS_PARAMETERS, Asn1X509DSSParametersDecodeEx,
    ASN1_OID_OFFSET X509_DSS_SIGNATURE, Asn1X509DSSSignatureDecodeEx,
    ASN1_OID_OFFSET PKCS_RC2_CBC_PARAMETERS, Asn1RC2CBCParametersDecodeEx,
    ASN1_OID_OFFSET PKCS_SMIME_CAPABILITIES, Asn1SMIMECapabilitiesDecodeEx,

    ASN1_OID_OFFSET X509_DH_PARAMETERS, Asn1X509DHParametersDecodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTES, Asn1X509AttributesDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET PKCS_SORTED_CTL, Asn1X509CtlInfoDecodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X942_DH_PARAMETERS, Asn1X942DhParametersDecodeEx,
    ASN1_OID_OFFSET X509_BITS_WITHOUT_TRAILING_ZEROES, Asn1X509BitsDecodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER, Asn1X509AuthorityKeyIdDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_ATTRIBUTES, Asn1X509KeyAttributesDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionDecodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE, Asn1X509BitsDecodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2DecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES_95, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES_95_QUALIFIER1, Asn1X509CertPoliciesQualifier1DecodeEx,

    ASN1_OID_PREFIX szOID_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeDecodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER2, Asn1X509AuthorityKeyId2DecodeEx, 
    ASN1_OID_PREFIX szOID_SUBJECT_KEY_IDENTIFIER, Asn1X509OctetStringDecodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME2, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME2, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_CRL_REASON_CODE, Asn1X509EnumeratedDecodeEx,
    ASN1_OID_PREFIX szOID_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessDecodeEx,
    ASN1_OID_PREFIX szOID_CRL_DIST_POINTS, Asn1X509CrlDistPointsDecodeEx,

    ASN1_OID_PREFIX szOID_CERT_EXTENSIONS, Asn1X509ExtensionsDecodeEx,
    ASN1_OID_PREFIX szOID_NEXT_UPDATE_LOCATION, Asn1X509AltNameDecodeEx,

    ASN1_OID_PREFIX szOID_ENHANCED_KEY_USAGE, Asn1X509CtlUsageDecodeEx,
    ASN1_OID_PREFIX szOID_CTL, Asn1X509CtlInfoDecodeEx,

    ASN1_OID_PREFIX szOID_RSA_RC2CBC, Asn1RC2CBCParametersDecodeEx,
    ASN1_OID_PREFIX szOID_RSA_SMIMECapabilities, Asn1SMIMECapabilitiesDecodeEx,
    ASN1_OID_PREFIX szOID_RSA_signingTime, Asn1UtcTimeDecodeEx,

    ASN1_OID_PREFIX szOID_ENROLLMENT_NAME_VALUE_PAIR, Asn1NameValueDecodeEx,
    ASN1_OID_PREFIX szOID_ENROLLMENT_CSP_PROVIDER, Asn1CSPProviderDecodeEx,
};

#define X509_DECODE_EX_FUNC_COUNT (sizeof(X509DecodeExFuncTable) / \
                                    sizeof(X509DecodeExFuncTable[0]))

#ifdef DEBUG_CRYPT_ASN1_MASTER
static HMODULE hOssCryptDll = NULL;
#endif  // DEBUG_CRYPT_ASN1_MASTER

BOOL
WINAPI
CertASNDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    // BUGBUG move to crypt32.cpp
    if (!I_CryptOIDConvDllMain(hInst, ulReason, lpReserved))
        goto ErrorReturn;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
#ifdef OSS_CRYPT_ASN1
        if (0 == (hX509Asn1Module = I_CryptInstallAsn1Module(ossx509, 0, NULL)))
#else
        X509_Module_Startup();
        if (0 == (hX509Asn1Module = I_CryptInstallAsn1Module(
                X509_Module, 0, NULL)))
#endif  // OSS_CRYPT_ASN1
            goto CryptInstallAsn1ModuleError;
        if (NULL == (hX509EncodeFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hX509DecodeFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_DECODE_OBJECT_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hX509EncodeExFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hX509DecodeExFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_DECODE_OBJECT_EX_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
                X509_ENCODE_EX_FUNC_COUNT,
                X509EncodeExFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_EX_FUNC,
                X509_DECODE_EX_FUNC_COUNT,
                X509DecodeExFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        break;

    case DLL_PROCESS_DETACH:
#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (hOssCryptDll) {
            FreeLibrary(hOssCryptDll);
            hOssCryptDll = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        I_CryptUninstallAsn1Module(hX509Asn1Module);
#ifndef OSS_CRYPT_ASN1
        X509_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInstallAsn1ModuleError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}

#ifdef DEBUG_CRYPT_ASN1_MASTER

#define DEBUG_OSS_CRYPT_ASN1_ENCODE_FLAG        0x1
#define DEBUG_OSS_CRYPT_ASN1_DECODE_FLAG        0x2
#define DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG       0x4

static BOOL fGotDebugCryptAsn1Flags = FALSE;
static int iDebugCryptAsn1Flags = 0;

int
WINAPI
GetDebugCryptAsn1Flags()
{

    if (!fGotDebugCryptAsn1Flags) {
        char    *pszEnvVar;
        char    *p;
        int     iFlags;

        if (pszEnvVar = getenv("DEBUG_CRYPT_ASN1_FLAGS"))
            iFlags = strtol(pszEnvVar, &p, 16);
        else
            iFlags = DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG;

        if (iFlags) {
            if (NULL == (hOssCryptDll = LoadLibraryA("osscrypt.dll"))) {
                iFlags = 0;
                if (pszEnvVar)
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "LoadLibrary(osscrypt.dll) failed",
                        "CheckCryptEncodeDecodeAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
            }
        }

        iDebugCryptAsn1Flags = iFlags;
        fGotDebugCryptAsn1Flags = TRUE;
    }
    return iDebugCryptAsn1Flags;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
static BOOL WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
    } else {
        DWORD dwBytesWritten;
        fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                );
        CloseHandle(hFile);
    }
    return fResult;
}

#endif  // DEBUG_CRYPT_ASN1_MASTER

//+-------------------------------------------------------------------------
// Encode the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEncodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT void *pvEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
    int iOssAsn1Flags;
    LPSTR lpszOssAsn1StructType = NULL;
    char szOssOID[128];
    HCRYPTOIDFUNCADDR hOssAsn1FuncAddr = NULL;
    void *pvOssAsn1FuncAddr = NULL;

    iOssAsn1Flags = GetDebugCryptAsn1Flags() &
        (DEBUG_OSS_CRYPT_ASN1_ENCODE_FLAG |
            DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG);
    if (iOssAsn1Flags) {
        if (0xFFFF < (DWORD_PTR) lpszStructType) {
            if ((DWORD) strlen(lpszStructType) <
                (sizeof(szOssOID) - strlen(OSS_OID_PREFIX) - 1)) {
                strcpy(szOssOID, OSS_OID_PREFIX);
                strcat(szOssOID, lpszStructType);
                lpszOssAsn1StructType = szOssOID;
            }
        } else
            lpszOssAsn1StructType = (LPSTR) lpszStructType +
                OSS_OID_OFFSET;

        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509EncodeExFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
    }

    if (pvOssAsn1FuncAddr &&
            0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG)) {
        fResult = ((PFN_ENCODE_EX_FUNC) pvOssAsn1FuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    } else
#endif  // DEBUG_CRYPT_ASN1_MASTER

    if (CryptGetOIDFunctionAddress(
            hX509EncodeExFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_ENCODE_EX_FUNC) pvFuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr && fResult && pvEncoded) {
            BYTE *pbEncoded;
            BOOL fOssAsn1Result;
            BYTE *pbOssAsn1 = NULL;
            DWORD cbOssAsn1;

            
            if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
                pbEncoded = *((BYTE **)pvEncoded);
            else
                pbEncoded = (BYTE *) pvEncoded;

            fOssAsn1Result = ((PFN_ENCODE_EX_FUNC) pvOssAsn1FuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                dwFlags | CRYPT_ENCODE_ALLOC_FLAG,
                &PkiEncodePara,
                (void *) &pbOssAsn1,
                &cbOssAsn1
                );

            if (!fOssAsn1Result) {
                int id;

                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode failed. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            } else if (*pcbEncoded != cbOssAsn1 ||
                    0 != memcmp(pbEncoded, pbOssAsn1, cbOssAsn1)) {
                int id;

                WriteDERToFile("msasn1.der", pbEncoded, *pcbEncoded);
                WriteDERToFile("ossasn1.der", pbOssAsn1, cbOssAsn1);
                
                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode compare failed. Check ossasn1.der and msasn1.der. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            }

            if (pbOssAsn1)
                PkiFree(pbOssAsn1);
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER
    } else {
        BYTE *pbEncoded;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (lpszOssAsn1StructType) {
            if (hOssAsn1FuncAddr)
                CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);

            if (!CryptGetOIDFunctionAddress(
                    hX509EncodeFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        if (dwFlags & ~CRYPT_ENCODE_ALLOC_FLAG)
            goto InvalidFlags;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr &&
                0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG)) {
            pvFuncAddr = pvOssAsn1FuncAddr;
            pvOssAsn1FuncAddr = NULL;
            hFuncAddr = hOssAsn1FuncAddr;
            hOssAsn1FuncAddr = NULL;
        } else
#endif  // DEBUG_CRYPT_ASN1_MASTER
        if (!CryptGetOIDFunctionAddress(
                hX509EncodeFuncSet,
                dwCertEncodingType,
                lpszStructType,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoEncodeFunction;
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
            PFN_CRYPT_ALLOC pfnAlloc;

            *pcbEncoded = 0;
            fResult = ((PFN_ENCODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                NULL,
                pcbEncoded
                );
            if (!fResult || 0 == *pcbEncoded)
                goto CommonReturn;

            pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
            if (NULL == (pbEncoded = (BYTE *) pfnAlloc(*pcbEncoded)))
                goto OutOfMemory;
        } else
            pbEncoded = (BYTE *) pvEncoded;

        fResult = ((PFN_ENCODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                pbEncoded,
                pcbEncoded
                );

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr && fResult && pbEncoded) {
            BOOL fOssAsn1Result;
            BYTE *pbOssAsn1 = NULL;
            DWORD cbOssAsn1;

            cbOssAsn1 = *pcbEncoded;
            pbOssAsn1 = (BYTE *) PkiNonzeroAlloc(cbOssAsn1);
            if (NULL == pbOssAsn1)
                fOssAsn1Result = FALSE;
            else
                fOssAsn1Result = ((PFN_ENCODE_FUNC) pvOssAsn1FuncAddr)(
                    dwCertEncodingType,
                    lpszStructType,
                    pvStructInfo,
                    pbOssAsn1,
                    &cbOssAsn1
                    );

            if (!fOssAsn1Result) {
                int id;

                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode failed. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            } else if (*pcbEncoded != cbOssAsn1 ||
                    0 != memcmp(pbEncoded, pbOssAsn1, cbOssAsn1)) {
                int id;

                WriteDERToFile("msasn1.der", pbEncoded, *pcbEncoded);
                WriteDERToFile("ossasn1.der", pbOssAsn1, cbOssAsn1);
                
                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode compare failed. Check ossasn1.der and msasn1.der. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            }

            PkiFree(pbOssAsn1);
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
            if (fResult)
                *((BYTE **) pvEncoded) = pbEncoded;
            else {
                PFN_CRYPT_FREE pfnFree;
                pfnFree = PkiGetEncodeFreeFunction(pEncodePara);
                pfnFree(pbEncoded);
            }
        }
    }

CommonReturn:
    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
#ifdef DEBUG_CRYPT_ASN1_MASTER
    if (hOssAsn1FuncAddr)
        CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);
#endif  // DEBUG_CRYPT_ASN1_MASTER

    return fResult;
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidFlags, E_INVALIDARG)
TRACE_ERROR(NoEncodeFunction)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

BOOL
WINAPI
CryptEncodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        0,                          // dwFlags
        NULL,                       // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
// Decode the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
    int iOssAsn1Flags;
    LPSTR lpszOssAsn1StructType = NULL;
    char szOssOID[128];
    HCRYPTOIDFUNCADDR hOssAsn1FuncAddr = NULL;
    void *pvOssAsn1FuncAddr = NULL;

    iOssAsn1Flags = GetDebugCryptAsn1Flags() &
        DEBUG_OSS_CRYPT_ASN1_DECODE_FLAG;
    if (iOssAsn1Flags) {
        if (0xFFFF < (DWORD_PTR) lpszStructType) {
            if ((DWORD) strlen(lpszStructType) <
                (sizeof(szOssOID) - strlen(OSS_OID_PREFIX) - 1)) {
                strcpy(szOssOID, OSS_OID_PREFIX);
                strcat(szOssOID, lpszStructType);
                lpszOssAsn1StructType = szOssOID;
            }
        } else
            lpszOssAsn1StructType = (LPSTR) lpszStructType + OSS_OID_OFFSET;

        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509DecodeExFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
    }

    if (pvOssAsn1FuncAddr) {
        fResult = ((PFN_DECODE_EX_FUNC) pvOssAsn1FuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            pvStructInfo,
            pcbStructInfo
            );
    } else
#endif  // DEBUG_CRYPT_ASN1_MASTER
    if (CryptGetOIDFunctionAddress(
            hX509DecodeExFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_DECODE_EX_FUNC) pvFuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            pvStructInfo,
            pcbStructInfo
            );
    } else {
        void *pv;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509DecodeFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
            *((void **) pvStructInfo) = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr) {
            pvFuncAddr = pvOssAsn1FuncAddr;
            pvOssAsn1FuncAddr = NULL;
            hFuncAddr = hOssAsn1FuncAddr;
            hOssAsn1FuncAddr = NULL;
        } else
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (!CryptGetOIDFunctionAddress(
                hX509DecodeFuncSet,
                dwCertEncodingType,
                lpszStructType,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoDecodeFunction;
        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
            PFN_CRYPT_ALLOC pfnAlloc;

            *pcbStructInfo = 0;
            fResult = ((PFN_DECODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pbEncoded,
                cbEncoded,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                NULL,
                pcbStructInfo
                );
            if (!fResult || 0 == *pcbStructInfo)
                goto CommonReturn;

            pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);
            if (NULL == (pv = pfnAlloc(*pcbStructInfo)))
                goto OutOfMemory;
        } else
            pv = pvStructInfo;

        fResult = ((PFN_DECODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pbEncoded,
                cbEncoded,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pv,
                pcbStructInfo
                );
        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
            if (fResult)
                *((void **) pvStructInfo) = pv;
            else {
                PFN_CRYPT_FREE pfnFree;
                pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
                pfnFree(pv);
            }
        }
    }

CommonReturn:
    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
#ifdef DEBUG_CRYPT_ASN1_MASTER
    if (hOssAsn1FuncAddr)
        CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);
#endif  // DEBUG_CRYPT_ASN1_MASTER
    return fResult;
ErrorReturn:
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(NoDecodeFunction)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


BOOL
WINAPI
CryptDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo
    )
{
    return CryptDecodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        NULL,                   // pDecodePara
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncodeEx(
        IN int pdunum,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        GetEncoder(),
        pdunum,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppvAsn1Info);
}

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static void Asn1InfoFree(
        IN int pdunum,
        IN void *pAsn1Info
        )
{
    if (pAsn1Info) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pAsn1Info);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  Decode into an ASN1 formatted info structure. Call the callback
//  function to convert into the 'C' data structure. If
//  CRYPT_DECODE_ALLOC_FLAG is set, call the callback twice. First,
//  to get the length of the 'C' data structure. Then after allocating,
//  call again to update the 'C' data structure.
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAllocEx(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return PkiAsn1DecodeAndAllocInfoEx(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Set / Get functions
//
//  Called by the ASN1 X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Get Encoded Object Identifier string
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
#define Asn1X509SetEncodedObjId(pszObjId, pAsn1) \
            I_CryptSetEncodedOID(pszObjId, (OssEncodedOID *) (pAsn1))

#define Asn1X509GetEncodedObjId(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra) \
            I_CryptGetEncodedOID((OssEncodedOID *) (pAsn1), dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra)

#else

#define Asn1X509SetEncodedObjId(pszObjId, pAsn1) \
            I_CryptSetEncodedOID(pszObjId, pAsn1)

#define Asn1X509GetEncodedObjId(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra) \
            I_CryptGetEncodedOID(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra)

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void Asn1X509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pAsn1
        )
{
    pAsn1->value = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}
inline void Asn1X509GetOctetString(
        IN OCTETSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_INTEGER_BLOB
//--------------------------------------------------------------------------
inline BOOL Asn1X509SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT HUGEINTEGER *pAsn1
        )
{
    return PkiAsn1SetHugeInteger(pInfo, &pAsn1->length, &pAsn1->value);
}
inline void Asn1X509FreeHugeInteger(
        IN HUGEINTEGER *pAsn1
        )
{
    PkiAsn1FreeHugeInteger(pAsn1->value);
    pAsn1->value = NULL;
    pAsn1->length = 0;
}
inline void Asn1X509GetHugeInteger(
        IN HUGEINTEGER *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetHugeInteger(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_UINT_BLOB
//--------------------------------------------------------------------------
inline BOOL Asn1X509SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT HUGEINTEGER *pAsn1
        )
{
    return PkiAsn1SetHugeUINT(pInfo, &pAsn1->length, &pAsn1->value);
}

#define Asn1X509FreeHugeUINT     Asn1X509FreeHugeInteger

inline void Asn1X509GetHugeUINT(
        IN HUGEINTEGER *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetHugeUINT(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_BIT_BLOB
//--------------------------------------------------------------------------
inline void Asn1X509SetBit(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BITSTRING *pAsn1
        )
{
    PkiAsn1SetBitString(pInfo, &pAsn1->length, &pAsn1->value);
}
inline void Asn1X509GetBit(
        IN BITSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBitString(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

inline void Asn1X509SetBitWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BITSTRING *pAsn1
        )
{
    PkiAsn1SetBitStringWithoutTrailingZeroes(
        pInfo, &pAsn1->length, &pAsn1->value);
}


//+-------------------------------------------------------------------------
//  Set/Get LPSTR (IA5 String)
//--------------------------------------------------------------------------
inline void Asn1X509SetIA5(
        IN LPSTR psz,
        OUT IA5STRING *pAsn1
        )
{
    pAsn1->value = psz;
    pAsn1->length = strlen(psz);
}
inline void Asn1X509GetIA5(
        IN IA5STRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5String(pAsn1->length, pAsn1->value, dwFlags,
        ppsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL Asn1X509SetUnicodeConvertedToIA5(
        IN LPWSTR pwsz,
        OUT IA5STRING *pAsn1,
        IN DWORD dwIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    fResult = PkiAsn1SetUnicodeConvertedToIA5String(pwsz,
        &pAsn1->length, &pAsn1->value);
    if (!fResult && (DWORD) CRYPT_E_INVALID_IA5_STRING == GetLastError())
        *pdwErrLocation = (dwIndex << 16) | pAsn1->length;
    else
        *pdwErrLocation = 0;
    return fResult;
}
inline void Asn1X509FreeUnicodeConvertedToIA5(IN IA5STRING *pAsn1)
{
    PkiAsn1FreeUnicodeConvertedToIA5String(pAsn1->value);
    pAsn1->value = NULL;
}
inline void Asn1X509GetIA5ConvertedToUnicode(
        IN IA5STRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5StringConvertedToUnicode(pAsn1->length, pAsn1->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get LPWSTR (BMP String)
//--------------------------------------------------------------------------
inline void Asn1X509SetBMP(
        IN LPWSTR pwsz,
        OUT BMPSTRING *pAsn1
        )
{
    pAsn1->value = pwsz;
    pAsn1->length = wcslen(pwsz);
}
inline void Asn1X509GetBMP(
        IN BMPSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBMPString(pAsn1->length, pAsn1->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void Asn1X509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pAsn1
        )
{
    PkiAsn1SetAny(pInfo, pAsn1);
}
inline void Asn1X509GetAny(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetAny(pAsn1, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
BOOL Asn1X509SetAlgorithm(
        IN PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        OUT AlgorithmIdentifier *pAsn1,
        IN DWORD dwGroupId = 0
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (pInfo->pszObjId) {
        if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->algorithm))
            return FALSE;

        if (pInfo->Parameters.cbData) {
            Asn1X509SetAny(&pInfo->Parameters, &pAsn1->parameters);
            pAsn1->bit_mask |= parameters_present;
        } else {
            if (dwGroupId) {
                // For public key or signature algorithms, check if
                // NO NULL parameters.

                PCCRYPT_OID_INFO pOIDInfo;
                DWORD dwFlags = 0;

                switch (dwGroupId) {
                    case CRYPT_PUBKEY_ALG_OID_GROUP_ID:
                        if (pOIDInfo = CryptFindOIDInfo(
                                CRYPT_OID_INFO_OID_KEY,
                                pInfo->pszObjId,
                                CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
                            if (1 <= pOIDInfo->ExtraInfo.cbData /
                                    sizeof(DWORD)) {
                                DWORD *pdwExtra = (DWORD *)
                                    pOIDInfo->ExtraInfo.pbData;
                                dwFlags = pdwExtra[0];
                            }
                        }
                        break;
                    case CRYPT_SIGN_ALG_OID_GROUP_ID:
                        if (pOIDInfo = CryptFindOIDInfo(
                                CRYPT_OID_INFO_OID_KEY,
                                pInfo->pszObjId,
                                CRYPT_SIGN_ALG_OID_GROUP_ID)) {
                            if (2 <= pOIDInfo->ExtraInfo.cbData /
                                    sizeof(DWORD)) {
                                DWORD *pdwExtra = (DWORD *)
                                    pOIDInfo->ExtraInfo.pbData;
                                dwFlags = pdwExtra[1];
                            }
                        }
                        break;
                    default:
                        break;
                }

                if (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG)
                    return TRUE;
            }

            // Per PKCS #1: default to the ASN.1 type NULL.
            Asn1X509SetAny((PCRYPT_OBJID_BLOB) &NullDerBlob, &pAsn1->parameters);
            pAsn1->bit_mask |= parameters_present;
        }
    }
    return TRUE;
}

void Asn1X509GetAlgorithm(
        IN AlgorithmIdentifier *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (*plRemainExtra >= 0)
        memset(pInfo, 0, sizeof(*pInfo));
    Asn1X509GetEncodedObjId(&pAsn1->algorithm, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);
    if (pAsn1->bit_mask & parameters_present)
        Asn1X509GetAny(&pAsn1->parameters, dwFlags, &pInfo->Parameters,
            ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CERT_PUBLIC_KEY_INFO
//--------------------------------------------------------------------------
BOOL Asn1X509SetPublicKeyInfo(
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        OUT SubjectPublicKeyInfo *pAsn1
        )
{
    if (!Asn1X509SetAlgorithm(&pInfo->Algorithm, &pAsn1->algorithm,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID))
        return FALSE;
    Asn1X509SetBit(&pInfo->PublicKey, &pAsn1->subjectPublicKey);
    return TRUE;
}

void Asn1X509GetPublicKeyInfo(
        IN SubjectPublicKeyInfo *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_PUBLIC_KEY_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    Asn1X509GetAlgorithm(&pAsn1->algorithm, dwFlags, &pInfo->Algorithm,
        ppbExtra, plRemainExtra);
    Asn1X509GetBit(&pAsn1->subjectPublicKey, dwFlags, &pInfo->PublicKey,
        ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get Extensions
//--------------------------------------------------------------------------
BOOL Asn1X509SetExtensions(
        IN DWORD cExtension,
        IN PCERT_EXTENSION pExtension,
        OUT Extensions *pAsn1
        )
{
    Extension *pAsn1Ext;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cExtension == 0)
        return TRUE;

    pAsn1Ext = (Extension *) PkiZeroAlloc(cExtension * sizeof(Extension));
    if (pAsn1Ext == NULL)
        return FALSE;
    pAsn1->value = pAsn1Ext;
    pAsn1->count = cExtension;

    for ( ; cExtension > 0; cExtension--, pExtension++, pAsn1Ext++) {
        if (!Asn1X509SetEncodedObjId(pExtension->pszObjId, &pAsn1Ext->extnId))
            return FALSE;
        if (pExtension->fCritical) {
            pAsn1Ext->critical = TRUE;
            pAsn1Ext->bit_mask |= critical_present;
        }
        Asn1X509SetOctetString(&pExtension->Value, &pAsn1Ext->extnValue);
    }
    return TRUE;
}

void Asn1X509FreeExtensions(
        IN Extensions *pAsn1)
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetExtensions(
        IN Extensions *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcExtension,
        OUT PCERT_EXTENSION *ppExtension,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cExt;
    Extension *pAsn1Ext;
    PCERT_EXTENSION pGetExt;

    cExt = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cExt * sizeof(CERT_EXTENSION));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcExtension = cExt;
        pGetExt = (PCERT_EXTENSION) pbExtra;
        *ppExtension = pGetExt;
        pbExtra += lAlignExtra;
    } else
        pGetExt = NULL;

    pAsn1Ext = pAsn1->value;
    for ( ; cExt > 0; cExt--, pAsn1Ext++, pGetExt++) {
        Asn1X509GetEncodedObjId(&pAsn1Ext->extnId, dwFlags, &pGetExt->pszObjId,
                &pbExtra, &lRemainExtra);
        if (lRemainExtra >= 0) {
            pGetExt->fCritical = FALSE;
            if (pAsn1Ext->bit_mask & critical_present)
                pGetExt->fCritical = (BOOLEAN) pAsn1Ext->critical;
        }

        Asn1X509GetOctetString(&pAsn1Ext->extnValue, dwFlags, &pGetExt->Value,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRL Entries
//--------------------------------------------------------------------------
BOOL Asn1X509SetCrlEntries(
        IN DWORD cEntry,
        IN PCRL_ENTRY pEntry,
        OUT RevokedCertificates *pAsn1
        )
{
    CRLEntry *pAsn1Entry;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cEntry == 0)
        return TRUE;

    pAsn1Entry = (CRLEntry *) PkiZeroAlloc(cEntry * sizeof(CRLEntry));
    if (pAsn1Entry == NULL)
        return FALSE;
    pAsn1->value = pAsn1Entry;
    pAsn1->count = cEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        if (!Asn1X509SetHugeInteger(&pEntry->SerialNumber,
                &pAsn1Entry->userCertificate))
            return FALSE;
        if (!PkiAsn1ToChoiceOfTime(&pEntry->RevocationDate,
                &pAsn1Entry->revocationDate.choice,
                &pAsn1Entry->revocationDate.u.generalTime,
                &pAsn1Entry->revocationDate.u.utcTime
                )) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            return FALSE;
        }
        if (pEntry->cExtension) {
            if (!Asn1X509SetExtensions(pEntry->cExtension, pEntry->rgExtension,
                    &pAsn1Entry->crlEntryExtensions))
                return FALSE;
            pAsn1Entry->bit_mask |= crlEntryExtensions_present;
        }
    }
    return TRUE;
}

void Asn1X509FreeCrlEntries(
        IN RevokedCertificates *pAsn1)
{
    if (pAsn1->value) {
        CRLEntry *pAsn1Entry = pAsn1->value;
        DWORD cEntry = pAsn1->count;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++) {
            Asn1X509FreeHugeInteger(&pAsn1Entry->userCertificate);
            Asn1X509FreeExtensions(&pAsn1Entry->crlEntryExtensions);
        }
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

BOOL Asn1X509GetCrlEntries(
        IN RevokedCertificates *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcEntry,
        OUT PCRL_ENTRY *ppEntry,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cEntry;
    CRLEntry *pAsn1Entry;
    PCRL_ENTRY pGetEntry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CRL_ENTRY));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcEntry = cEntry;
        pGetEntry = (PCRL_ENTRY) pbExtra;
        *ppEntry = pGetEntry;
        pbExtra += lAlignExtra;
    } else
        pGetEntry = NULL;

    pAsn1Entry = pAsn1->value;
    for ( ; cEntry > 0; cEntry--, pAsn1Entry++, pGetEntry++) {
        Asn1X509GetHugeInteger(&pAsn1Entry->userCertificate, dwFlags,
            &pGetEntry->SerialNumber, &pbExtra, &lRemainExtra);

        // RevocationDate
        if (lRemainExtra >= 0) {
            if (!PkiAsn1FromChoiceOfTime(pAsn1Entry->revocationDate.choice,
                    &pAsn1Entry->revocationDate.u.generalTime,
                    &pAsn1Entry->revocationDate.u.utcTime,
                    &pGetEntry->RevocationDate)) {
                SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
                return FALSE;
            }
        }

        // Extensions
        if (pAsn1Entry->bit_mask & crlEntryExtensions_present)
            Asn1X509GetExtensions(&pAsn1Entry->crlEntryExtensions, dwFlags,
                &pGetEntry->cExtension, &pGetEntry->rgExtension,
                &pbExtra, &lRemainExtra);
        else if (lRemainExtra >= 0) {
            pGetEntry->cExtension = 0;
            pGetEntry->rgExtension = NULL;
        }
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    return TRUE;
}

#ifndef ASN1_SUPPORTS_UTF8_TAG

void inline Asn1X509ReverseCopy(
    OUT BYTE *pbOut,
    IN BYTE *pbInOrg,
    IN DWORD cbIn
    )
{
    BYTE *pbIn = pbInOrg + cbIn - 1;

    while (cbIn-- > 0)
        *pbOut++ = *pbIn--;
}

#define MAX_LENGTH_OCTETS   5

//+-------------------------------------------------------------------------
//  Copy out the encoding of the length octets for a specified content length.
//
//  Returns the number of length octets
//--------------------------------------------------------------------------
DWORD Asn1X509GetLengthOctets(
    IN DWORD cbContent,
    OUT BYTE rgbLength[MAX_LENGTH_OCTETS]
    )
{
    DWORD cbLength;

    if (cbContent < 0x80) {
        rgbLength[0] = (BYTE) cbContent;
        cbLength = 0;
    } else {
        if (cbContent > 0xffffff)
            cbLength = 4;
        else if (cbContent > 0xffff)
            cbLength = 3;
        else if (cbContent > 0xff)
            cbLength = 2;
        else
            cbLength = 1;
        rgbLength[0] = (BYTE) cbLength | 0x80;
        Asn1X509ReverseCopy(rgbLength + 1, (BYTE *) &cbContent, cbLength);
    }
    return cbLength + 1;
}

// Prefix includes:
//  - 1 byte for number of unused bytes in the prefix
//  - 1 byte for the tag
//  - up to 5 bytes for the length octets
#define MAX_ENCODED_UTF8_PREFIX     (1 + 1 + MAX_LENGTH_OCTETS)
#define UTF8_ASN_TAG                0x0C

//+-------------------------------------------------------------------------
//  Allocate and Encode UTF8
//
//  The returned pbEncoded points to an ASN.1 encoded UTF8 string.
//  pbEncoded points to the UTF8_ASN_TAG, followed by the length octets and
//  then the UTF8 bytes.
//
//  *(pbEncoded -1) contains the number of unused bytes preceding the encoded
//  UTF8, ie, pbAllocEncoded = pbEncoded - *(pbEncoded -1).
//--------------------------------------------------------------------------
BOOL Asn1X509AllocAndEncodeUTF8(
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT BYTE **ppbEncoded,
        OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbAllocEncoded = NULL;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BYTE rgbLength[MAX_LENGTH_OCTETS];
    DWORD cbLength;
    DWORD cbUnusedPrefix;
    int cchUnicode;
    int cchUTF8;

    cchUnicode = pValue->cbData / sizeof(WCHAR);

    // In the largest buffer case there are 3 bytes per Unicode character.
    // The encoded UTF8 is preceded with a prefix consisting of a byte
    // indicating the number of unused bytes in the prefix, a byte for the
    // UTF8 tag and up to 5 bytes for the length octets.
    if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(
            MAX_ENCODED_UTF8_PREFIX + cchUnicode * 3)))
        goto OutOfMemory;

    if (0 == cchUnicode)
        cchUTF8 = 0;
    else {
        if (0 >= (cchUTF8 = WideCharToUTF8(
                (LPCWSTR) pValue->pbData,
                cchUnicode,
                (LPSTR) (pbAllocEncoded + MAX_ENCODED_UTF8_PREFIX),
                cchUnicode * 3
                )))
            goto WideCharToUTF8Error;
    }

    cbLength = Asn1X509GetLengthOctets(cchUTF8, rgbLength);
    assert(MAX_ENCODED_UTF8_PREFIX > (1 + cbLength));
    cbUnusedPrefix = MAX_ENCODED_UTF8_PREFIX - (1 + cbLength);
    pbEncoded = pbAllocEncoded + cbUnusedPrefix;
    cbEncoded = 1 + cbLength + cchUTF8;
    *(pbEncoded - 1) = (BYTE) cbUnusedPrefix;
    *(pbEncoded) = UTF8_ASN_TAG;
    memcpy(pbEncoded + 1, rgbLength, cbLength);

    fResult = TRUE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    PkiFree(pbAllocEncoded);
    pbEncoded = NULL;
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(WideCharToUTF8Error)
}

//+-------------------------------------------------------------------------
//  Free previously encoded UTF8
//
//  *(pbEncoded -1) contains the number of unused bytes preceding the encoded
//  UTF8, ie, pbAllocEncoded = pbEncoded - *(pbEncoded -1).
//--------------------------------------------------------------------------
void Asn1X509FreeEncodedUTF8(
        IN BYTE *pbEncoded
        )
{
    if (pbEncoded) {
        BYTE *pbAllocEncoded;

        assert(MAX_ENCODED_UTF8_PREFIX > *(pbEncoded -1));

        pbAllocEncoded = pbEncoded - *(pbEncoded - 1);
        PkiFree(pbAllocEncoded);
    }
}

//+-------------------------------------------------------------------------
//  Get UTF8
//--------------------------------------------------------------------------
BOOL Asn1X509GetUTF8(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    const BYTE *pbEncoded = (const BYTE *) pAsn1->encoded;
    DWORD cbEncoded = pAsn1->length;
    const BYTE *pbContent;
    DWORD cbContent;
    int cchUnicode;
    LPWSTR pwszUnicode = NULL;
    LONG lAlignExtra;
    LONG lData;


    if (0 == cbEncoded || UTF8_ASN_TAG != *pbEncoded)
        goto InvalidUTF8Tag;

    if (0 >= Asn1UtilExtractContent(
            pbEncoded,
            cbEncoded,
            &cbContent,
            &pbContent
            ))
        goto InvalidUTF8Header;

    if (0 == cbContent)
        cchUnicode = 0;
    else {
        if (pbContent + cbContent > pbEncoded + cbEncoded)
            goto InvalidUTF8Header;

        // In the largest buffer case there is one Unicode character per
        // UTF8 character
        if (NULL == (pwszUnicode = (LPWSTR) PkiNonzeroAlloc(
                cbContent * sizeof(WCHAR))))
            goto OutOfMemory;

        if (0 >= (cchUnicode = UTF8ToWideChar(
                (LPCSTR) pbContent,
                cbContent,              // cchUTF8
                pwszUnicode,
                cbContent               // cchUnicode
                )))
            goto UTF8ToWideCharError;
    }

    // Add + sizeof(WCHAR) for added 0 bytes. Want to ensure that the WCHAR
    // string is always null terminated
    lData = cchUnicode * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pdwValueType = CERT_RDN_UTF8_STRING;
        pValue->pbData = *ppbExtra;
        pValue->cbData = (DWORD) lData;
        if (lData > 0)
            memcpy(pValue->pbData, pwszUnicode, lData);
        memset(pValue->pbData + lData, 0, sizeof(WCHAR));
        *ppbExtra += lAlignExtra;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszUnicode);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidUTF8Tag, CRYPT_E_BAD_ENCODE)
SET_ERROR(InvalidUTF8Header, CRYPT_E_BAD_ENCODE)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(UTF8ToWideCharError)
}

#endif  // not defined ASN1_SUPPORTS_UTF8_TAG


//+-------------------------------------------------------------------------
//  Set/Get AnyString
//--------------------------------------------------------------------------
void Asn1X509SetAnyString(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT AnyString *pAsn1
        )
{
    pAsn1->u.octetString.value = pValue->pbData;
    pAsn1->u.octetString.length = pValue->cbData;
    switch (dwValueType) {
        case CERT_RDN_OCTET_STRING:
            pAsn1->choice = octetString_chosen;
            break;
        case CERT_RDN_NUMERIC_STRING:
            pAsn1->choice = numericString_chosen;
            break;
        case CERT_RDN_PRINTABLE_STRING:
            pAsn1->choice = printableString_chosen;
            break;
        case CERT_RDN_TELETEX_STRING:
            pAsn1->choice = teletexString_chosen;
            break;
        case CERT_RDN_VIDEOTEX_STRING:
            pAsn1->choice = videotexString_chosen;
            break;
        case CERT_RDN_IA5_STRING:
            pAsn1->choice = ia5String_chosen;
            break;
        case CERT_RDN_GRAPHIC_STRING:
            pAsn1->choice = graphicString_chosen;
            break;
        case CERT_RDN_VISIBLE_STRING:
            pAsn1->choice = visibleString_chosen;
            break;
        case CERT_RDN_GENERAL_STRING:
            pAsn1->choice = generalString_chosen;
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            pAsn1->choice = universalString_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 4;
            break;
        case CERT_RDN_BMP_STRING:
            pAsn1->choice = bmpString_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 2;
            break;
#ifdef ASN1_SUPPORTS_UTF8_TAG
        case CERT_RDN_UTF8_STRING:
            pAsn1->choice = utf8String_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 2;
            break;
#endif // ASN1_SUPPORTS_UTF8_TAG
        default:
            assert(dwValueType >= CERT_RDN_OCTET_STRING &&
                dwValueType <= CERT_RDN_UTF8_STRING);
            pAsn1->choice = 0;
    }
}

void Asn1X509GetAnyString(
        IN AnyString *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;

    DWORD dwValueType;
    BYTE *pbData;
    LONG lData;

    pbData = pAsn1->u.octetString.value;
    lData = pAsn1->u.octetString.length;
    switch (pAsn1->choice) {
        case octetString_chosen:
            dwValueType = CERT_RDN_OCTET_STRING;
            break;
        case numericString_chosen:
            dwValueType = CERT_RDN_NUMERIC_STRING;
            break;
        case printableString_chosen:
            dwValueType = CERT_RDN_PRINTABLE_STRING;
            break;
        case teletexString_chosen:
            dwValueType = CERT_RDN_TELETEX_STRING;
            break;
        case videotexString_chosen:
            dwValueType = CERT_RDN_VIDEOTEX_STRING;
            break;
        case ia5String_chosen:
            dwValueType = CERT_RDN_IA5_STRING;
            break;
        case graphicString_chosen:
            dwValueType = CERT_RDN_GRAPHIC_STRING;
            break;
        case visibleString_chosen:
            dwValueType = CERT_RDN_VISIBLE_STRING;
            break;
        case generalString_chosen:
            dwValueType = CERT_RDN_GENERAL_STRING;
            break;
        case universalString_chosen:
            dwValueType = CERT_RDN_UNIVERSAL_STRING;
            lData = pAsn1->u.universalString.length * 4;
            break;
        case bmpString_chosen:
            dwValueType = CERT_RDN_BMP_STRING;
            lData = pAsn1->u.bmpString.length * 2;
            break;
#ifdef ASN1_SUPPORTS_UTF8_TAG
        case utf8String_chosen:
            dwValueType = CERT_RDN_UTF8_STRING;
            lData = pAsn1->u.utf8String.length * 2;
            break;
#endif // ASN1_SUPPORTS_UTF8_TAG
        default:
            assert(pAsn1->choice >= 1 && pAsn1->choice <= bmpString_chosen);
            dwValueType = 0;
    }

    // Add + sizeof(WCHAR) for added 0 bytes. Want to ensure that a char
    // or WCHAR string is always null terminated
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pdwValueType = dwValueType;
        pValue->pbData = *ppbExtra;
        pValue->cbData = (DWORD) lData;
        if (lData > 0)
            memcpy(pValue->pbData, pbData, lData);
        memset(pValue->pbData + lData, 0, sizeof(WCHAR));
        *ppbExtra += lAlignExtra;
    }
}


//+-------------------------------------------------------------------------
//  Allocate and Encode AnyString
//--------------------------------------------------------------------------
BOOL Asn1X509AllocAndEncodeAnyString(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT BYTE **ppbEncoded,
        OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AnyString Asn1String;
    ASN1error_e Asn1Err;
    ASN1encoding_t pEnc = GetEncoder();

    Asn1X509SetAnyString(dwValueType, pValue, &Asn1String);

    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Encode(
                pEnc,
                &Asn1String,
                AnyString_PDU,
                ppbEncoded,
                pcbEncoded
                )))
        goto Asn1EncodeError;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute value
//--------------------------------------------------------------------------
BOOL Asn1X509SetRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT NOCOPYANY *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (dwValueType == CERT_RDN_ANY_TYPE) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    // Determine if value is an encoded representation or is a known string
    // type. Encode accordingly.
    if (dwValueType == CERT_RDN_ENCODED_BLOB) {
        Asn1X509SetAny(pValue, pAsn1);
#ifndef ASN1_SUPPORTS_UTF8_TAG
    } else if (dwValueType == CERT_RDN_UTF8_STRING) {
        CRYPT_OBJID_BLOB ObjIdBlob;

        if (!Asn1X509AllocAndEncodeUTF8(
                pValue,
                &ObjIdBlob.pbData,
                &ObjIdBlob.cbData))
            return FALSE;
        Asn1X509SetAny(&ObjIdBlob, pAsn1);
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    } else {
        CRYPT_OBJID_BLOB ObjIdBlob;

        if (!Asn1X509AllocAndEncodeAnyString(
                dwValueType,
                pValue,
                &ObjIdBlob.pbData,
                &ObjIdBlob.cbData))
            return FALSE;
        Asn1X509SetAny(&ObjIdBlob, pAsn1);
    }
    return TRUE;
}

void Asn1X509FreeRDNAttributeValue(
        IN DWORD dwValueType,
        IN OUT NOCOPYANY *pAsn1
        )
{
#ifndef ASN1_SUPPORTS_UTF8_TAG
    if (dwValueType == CERT_RDN_UTF8_STRING) {
        Asn1X509FreeEncodedUTF8((BYTE *) pAsn1->encoded);
        pAsn1->encoded = NULL;
        pAsn1->length = 0;
    } else
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    if (dwValueType != CERT_RDN_ENCODED_BLOB) {
        if (pAsn1->encoded) {
            DWORD dwErr = GetLastError();

            // TlsGetValue globbers LastError
            PkiAsn1FreeEncoded(GetEncoder(), pAsn1->encoded);
            pAsn1->encoded = NULL;

            SetLastError(dwErr);
        }
        pAsn1->length = 0;
    }
}

BOOL Asn1X509GetRDNAttributeValue(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    ASN1decoding_t pDec = GetDecoder();
    AnyString *pAsn1String = NULL;

#ifndef ASN1_SUPPORTS_UTF8_TAG
    if (0 < pAsn1->length && UTF8_ASN_TAG == *((BYTE *) pAsn1->encoded))
        return Asn1X509GetUTF8(
            pAsn1,
            dwFlags,
            pdwValueType,
            pValue,
            ppbExtra,
            plRemainExtra
            );
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG


#ifdef OSS_CRYPT_ASN1
    unsigned long ulPrevDecodingFlags;


    // Since its acceptable for the following decode to fail, don't output
    // decode errors.
    ulPrevDecodingFlags = ossGetDecodingFlags((POssGlobal) pDec);
    if (ulPrevDecodingFlags & DEBUG_ERRORS)
        ossSetDecodingFlags((POssGlobal) pDec,
            ulPrevDecodingFlags & ~DEBUG_ERRORS);
    ossSetEncodingRules((POssGlobal) pDec, OSS_BER);
#endif  // OSS_CRYPT_ASN1

    // Check if the value is a string type
    if (ASN1_SUCCESS == PkiAsn1Decode(
            pDec,
            (void **) &pAsn1String,
            AnyString_PDU,
            (BYTE *) pAsn1->encoded,
            pAsn1->length
            )) {
        Asn1X509GetAnyString(pAsn1String, dwFlags, pdwValueType, pValue,
            ppbExtra, plRemainExtra);
    } else {
        // Encoded representation
        if (*plRemainExtra >= 0)
            *pdwValueType = CERT_RDN_ENCODED_BLOB;

        Asn1X509GetAny(pAsn1, dwFlags, pValue, ppbExtra, plRemainExtra);
    }

#ifdef OSS_CRYPT_ASN1
    // Restore previous flags
    if (ulPrevDecodingFlags & DEBUG_ERRORS)
        ossSetDecodingFlags((POssGlobal) pDec, ulPrevDecodingFlags);
#endif  // OSS_CRYPT_ASN1

    PkiAsn1FreeDecoded(
        pDec,
        pAsn1String,
        AnyString_PDU
        );

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute
//--------------------------------------------------------------------------
BOOL Asn1X509SetRDNAttribute(
        IN PCERT_RDN_ATTR pInfo,
        OUT AttributeTypeValue *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (pInfo->pszObjId) {
        if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->type))
            return FALSE;
    }

    return Asn1X509SetRDNAttributeValue(
            pInfo->dwValueType,
            &pInfo->Value,
            &pAsn1->value
            );
}

void Asn1X509FreeRDNAttribute(
        IN PCERT_RDN_ATTR pInfo,
        IN OUT AttributeTypeValue *pAsn1
        )
{
    Asn1X509FreeRDNAttributeValue(
        pInfo->dwValueType,
        &pAsn1->value
        );
}

BOOL Asn1X509GetRDNAttribute(
        IN AttributeTypeValue *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_RDN_ATTR pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Get ObjectIdentifier
    Asn1X509GetEncodedObjId(&pAsn1->type, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);

    // Get value
    return Asn1X509GetRDNAttributeValue(&pAsn1->value, dwFlags,
        &pInfo->dwValueType, &pInfo->Value, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get SeqOfAny
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetSeqOfAny(
        IN DWORD cValue,
        IN PCRYPT_DER_BLOB pValue,
#ifdef OSS_CRYPT_ASN1
        OUT unsigned int *pAsn1Count,
#else
        OUT ASN1uint32_t *pAsn1Count,
#endif  // OSS_CRYPT_ASN1
        OUT NOCOPYANY **ppAsn1Value
        )
{
    
    *pAsn1Count = 0;
    *ppAsn1Value = NULL;
    if (cValue > 0) {
        NOCOPYANY *pAsn1Value;

        pAsn1Value = (NOCOPYANY *) PkiZeroAlloc(cValue * sizeof(NOCOPYANY));
        if (pAsn1Value == NULL)
            return FALSE;
        *pAsn1Count = cValue;
        *ppAsn1Value = pAsn1Value;
        for ( ; cValue > 0; cValue--, pValue++, pAsn1Value++)
            Asn1X509SetAny(pValue, pAsn1Value);
    }
    return TRUE;
}

void Asn1X509FreeSeqOfAny(
        IN NOCOPYANY *pAsn1Value
        )
{
    if (pAsn1Value)
        PkiFree(pAsn1Value);
}

void Asn1X509GetSeqOfAny(
        IN unsigned int Asn1Count,
        IN NOCOPYANY *pAsn1Value,
        IN DWORD dwFlags,
        OUT DWORD *pcValue,
        OUT PCRYPT_DER_BLOB *ppValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PCRYPT_ATTR_BLOB pValue;

    lAlignExtra = INFO_LEN_ALIGN(Asn1Count * sizeof(CRYPT_DER_BLOB));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pcValue = Asn1Count;
        pValue = (PCRYPT_DER_BLOB) *ppbExtra;
        *ppValue = pValue;
        *ppbExtra += lAlignExtra;
    } else
        pValue = NULL;

    for (; Asn1Count > 0; Asn1Count--, pAsn1Value++, pValue++)
        Asn1X509GetAny(pAsn1Value, dwFlags, pValue, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetAttribute(
        IN PCRYPT_ATTRIBUTE pInfo,
        OUT Attribute *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->type))
        return FALSE;

    return Asn1X509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &pAsn1->values.count,
            &pAsn1->values.value);
}

void Asn1X509FreeAttribute(
        IN OUT Attribute *pAsn1
        )
{
    Asn1X509FreeSeqOfAny(pAsn1->values.value);
}

void Asn1X509GetAttribute(
        IN Attribute *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_ATTRIBUTE pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    Asn1X509GetEncodedObjId(&pAsn1->type, dwFlags,
        &pInfo->pszObjId, ppbExtra, plRemainExtra);
    Asn1X509GetSeqOfAny(pAsn1->values.count, pAsn1->values.value, dwFlags,
        &pInfo->cValue, &pInfo->rgValue, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_ENTRY
//--------------------------------------------------------------------------
BOOL Asn1X509SetAltNameEntry(
        IN PCERT_ALT_NAME_ENTRY pInfo,
        OUT GeneralName *pAsn1,
        IN DWORD dwEntryIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;

    // Assumption: ASN1 choice == dwAltNameChoice
    // Asn1X509GetAltNameEntry has asserts to verify
    pAsn1->choice = (unsigned short) pInfo->dwAltNameChoice;

    *pdwErrLocation = 0;

    switch (pInfo->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        if (!Asn1X509SetEncodedObjId(pInfo->pOtherName->pszObjId,
                &pAsn1->u.otherName.type))
            goto ErrorReturn;
        Asn1X509SetAny(&pInfo->pOtherName->Value, &pAsn1->u.otherName.value);
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        Asn1X509SetAny(&pInfo->DirectoryName, &pAsn1->u.directoryName);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        if (!Asn1X509SetUnicodeConvertedToIA5(pInfo->pwszRfc822Name,
                &pAsn1->u.rfc822Name, dwEntryIndex, pdwErrLocation))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        Asn1X509SetOctetString(&pInfo->IPAddress, &pAsn1->u.iPAddress);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        if (!Asn1X509SetEncodedObjId(pInfo->pszRegisteredID, &pAsn1->u.registeredID))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
    default:
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAltNameEntry(
        IN GeneralName *pAsn1
        )
{
    switch (pAsn1->choice) {
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        Asn1X509FreeUnicodeConvertedToIA5(&pAsn1->u.rfc822Name);
        break;
    default:
        break;
    }
}

BOOL Asn1X509GetAltNameEntry(
        IN GeneralName *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_ENTRY pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    DWORD dwAltNameChoice;

    assert(otherName_chosen == CERT_ALT_NAME_OTHER_NAME);
    assert(rfc822Name_chosen == CERT_ALT_NAME_RFC822_NAME);
    assert(dNSName_chosen == CERT_ALT_NAME_DNS_NAME);
    assert(x400Address_chosen == CERT_ALT_NAME_X400_ADDRESS);
    assert(directoryName_chosen == CERT_ALT_NAME_DIRECTORY_NAME);
    assert(ediPartyName_chosen == CERT_ALT_NAME_EDI_PARTY_NAME);
    assert(uniformResourceLocator_chosen == CERT_ALT_NAME_URL);
    assert(iPAddress_chosen == CERT_ALT_NAME_IP_ADDRESS);
    assert(registeredID_chosen == CERT_ALT_NAME_REGISTERED_ID);


    dwAltNameChoice = pAsn1->choice;
    if (*plRemainExtra >= 0)
        pInfo->dwAltNameChoice = dwAltNameChoice;
    switch (dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        {
            LONG lAlignExtra;
            PCERT_OTHER_NAME pOtherName;

            lAlignExtra = INFO_LEN_ALIGN(sizeof(CERT_OTHER_NAME));
            *plRemainExtra -= lAlignExtra;
            if (*plRemainExtra >= 0) {
                pOtherName = (PCERT_OTHER_NAME) *ppbExtra;
                pInfo->pOtherName = pOtherName;
                *ppbExtra += lAlignExtra;
            } else
                pOtherName = NULL;

            Asn1X509GetEncodedObjId(&pAsn1->u.otherName.type, dwFlags,
                &pOtherName->pszObjId, ppbExtra, plRemainExtra);
            Asn1X509GetAny(&pAsn1->u.otherName.value, dwFlags,
                &pOtherName->Value, ppbExtra, plRemainExtra);
        }
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        Asn1X509GetAny(&pAsn1->u.directoryName, dwFlags,
            &pInfo->DirectoryName, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        Asn1X509GetIA5ConvertedToUnicode(&pAsn1->u.rfc822Name, dwFlags,
            &pInfo->pwszRfc822Name, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        Asn1X509GetOctetString(&pAsn1->u.iPAddress, dwFlags,
            &pInfo->IPAddress, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        Asn1X509GetEncodedObjId(&pAsn1->u.registeredID, dwFlags,
            &pInfo->pszRegisteredID, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
        break;
    default:
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_INFO
//--------------------------------------------------------------------------
BOOL Asn1X509SetAltNames(
        IN PCERT_ALT_NAME_INFO pInfo,
        OUT AltNames *pAsn1,
        IN DWORD dwIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pAsn1Entry;

    *pdwErrLocation = 0;

    cEntry = pInfo->cAltEntry;
    pEntry = pInfo->rgAltEntry;
    pAsn1->count = cEntry;
    pAsn1->value = NULL;
    if (cEntry > 0) {
        pAsn1Entry =
            (GeneralName *) PkiZeroAlloc(cEntry * sizeof(GeneralName));
        if (pAsn1Entry == NULL)
            goto ErrorReturn;
        pAsn1->value = pAsn1Entry;
    }

    // Array of AltName entries
    for (i = 0; i < cEntry; i++, pEntry++, pAsn1Entry++) {
        if (!Asn1X509SetAltNameEntry(pEntry, pAsn1Entry,
                (dwIndex << 8) | i, pdwErrLocation))
            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAltNames(
        OUT AltNames *pAsn1
        )
{
    if (pAsn1->value) {
        DWORD cEntry = pAsn1->count;
        GeneralName *pAsn1Entry = pAsn1->value;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++)
            Asn1X509FreeAltNameEntry(pAsn1Entry);
        PkiFree(pAsn1->value);
    }
}

BOOL Asn1X509GetAltNames(
        IN AltNames *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pAsn1Entry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CERT_ALT_NAME_ENTRY));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        pInfo->cAltEntry = cEntry;
        pEntry = (PCERT_ALT_NAME_ENTRY) *ppbExtra;
        pInfo->rgAltEntry = pEntry;
        *ppbExtra += lAlignExtra;
    } else
        pEntry = NULL;

    // Array of AltName entries
    pAsn1Entry = pAsn1->value;
    for (; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        if (!Asn1X509GetAltNameEntry(pAsn1Entry, dwFlags,
                    pEntry, ppbExtra, plRemainExtra))
                return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ACCESS_DESCRIPTION
//--------------------------------------------------------------------------
BOOL Asn1X509SetAccessDescriptions(
        IN DWORD cAccDescr,
        IN PCERT_ACCESS_DESCRIPTION pAccDescr,
        OUT AccessDescription *pAsn1,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;

    *pdwErrLocation = 0;
    for (i = 0; i < cAccDescr; i++, pAccDescr++, pAsn1++) {
        if (!Asn1X509SetEncodedObjId(pAccDescr->pszAccessMethod, &pAsn1->accessMethod))
            goto ErrorReturn;
        if (!Asn1X509SetAltNameEntry(&pAccDescr->AccessLocation,
                &pAsn1->accessLocation,
                i,
                pdwErrLocation))
            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAccessDescriptions(
        IN DWORD cAccDescr,
        IN OUT AccessDescription *pAsn1
        )
{
    for ( ; cAccDescr > 0; cAccDescr--, pAsn1++)
        Asn1X509FreeAltNameEntry(&pAsn1->accessLocation);
}

BOOL Asn1X509GetAccessDescriptions(
        IN DWORD cAccDescr,
        IN AccessDescription *pAsn1,
        IN DWORD dwFlags,
        IN PCERT_ACCESS_DESCRIPTION pAccDescr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Array of AccessDescription entries
    for (; cAccDescr > 0; cAccDescr--, pAccDescr++, pAsn1++) {
        Asn1X509GetEncodedObjId(&pAsn1->accessMethod, dwFlags,
                &pAccDescr->pszAccessMethod, ppbExtra, plRemainExtra);
        if (!Asn1X509GetAltNameEntry(&pAsn1->accessLocation, dwFlags,
                &pAccDescr->AccessLocation, ppbExtra, plRemainExtra))
            return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Encode the Cert Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateToBeSigned Cert;

    memset(&Cert, 0, sizeof(Cert));
    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Cert.CertificateToBeSigned_version = pInfo->dwVersion;
#else
        Cert.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Cert.bit_mask |= CertificateToBeSigned_version_present;
    }

    if (!Asn1X509SetHugeInteger(&pInfo->SerialNumber, &Cert.serialNumber))
        goto ErrorReturn;
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm, &Cert.signature,
            CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;
    Asn1X509SetAny(&pInfo->Issuer, &Cert.issuer);
    if (!PkiAsn1ToChoiceOfTime(&pInfo->NotBefore, 
            &Cert.validity.notBefore.choice,
            &Cert.validity.notBefore.u.generalTime,
            &Cert.validity.notBefore.u.utcTime
            ))
        goto EncodeError;
    if (!PkiAsn1ToChoiceOfTime(&pInfo->NotAfter, 
            &Cert.validity.notAfter.choice,
            &Cert.validity.notAfter.u.generalTime,
            &Cert.validity.notAfter.u.utcTime
            ))
        goto EncodeError;
    Asn1X509SetAny(&pInfo->Subject, &Cert.subject);
    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &Cert.subjectPublicKeyInfo))
        goto ErrorReturn;

    if (pInfo->IssuerUniqueId.cbData) {
        Asn1X509SetBit(&pInfo->IssuerUniqueId, &Cert.issuerUniqueIdentifier);
        Cert.bit_mask |= issuerUniqueIdentifier_present;
    }
    if (pInfo->SubjectUniqueId.cbData) {
        Asn1X509SetBit(&pInfo->SubjectUniqueId, &Cert.subjectUniqueIdentifier);
        Cert.bit_mask |= subjectUniqueIdentifier_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Cert.extensions))
            goto ErrorReturn;
        Cert.bit_mask |= extensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateToBeSigned_PDU,
        &Cert,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeInteger(&Cert.serialNumber);
    Asn1X509FreeExtensions(&Cert.extensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Cert Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateToBeSigned *pCert = (CertificateToBeSigned *) pvAsn1Info;
    PCERT_INFO pInfo = (PCERT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        if (pCert->bit_mask & CertificateToBeSigned_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion = pCert->CertificateToBeSigned_version;
#else
            pInfo->dwVersion = pCert->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCert->validity.notBefore.choice,
                &pCert->validity.notBefore.u.generalTime,
                &pCert->validity.notBefore.u.utcTime,
                &pInfo->NotBefore))
            goto DecodeError;
        if (!PkiAsn1FromChoiceOfTime(pCert->validity.notAfter.choice,
                &pCert->validity.notAfter.u.generalTime,
                &pCert->validity.notAfter.u.utcTime,
                &pInfo->NotAfter))
            goto DecodeError;
        pbExtra = (BYTE *) pInfo + sizeof(CERT_INFO);
    }

    Asn1X509GetHugeInteger(&pCert->serialNumber, dwFlags,
            &pInfo->SerialNumber, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pCert->signature, dwFlags,
            &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCert->issuer, dwFlags,
            &pInfo->Issuer, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCert->subject, dwFlags,
            &pInfo->Subject, &pbExtra, &lRemainExtra);
    Asn1X509GetPublicKeyInfo(&pCert->subjectPublicKeyInfo, dwFlags,
            &pInfo->SubjectPublicKeyInfo, &pbExtra, &lRemainExtra);

    if (pCert->bit_mask & issuerUniqueIdentifier_present)
        Asn1X509GetBit(&pCert->issuerUniqueIdentifier, dwFlags,
            &pInfo->IssuerUniqueId, &pbExtra, &lRemainExtra);
    if (pCert->bit_mask & subjectUniqueIdentifier_present)
        Asn1X509GetBit(&pCert->subjectUniqueIdentifier, dwFlags,
            &pInfo->SubjectUniqueId, &pbExtra, &lRemainExtra);
    if (pCert->bit_mask & extensions_present)
        Asn1X509GetExtensions(&pCert->extensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CertInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificateToBeSigned_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CertInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the CRL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateRevocationListToBeSigned Crl;

    memset(&Crl, 0, sizeof(Crl));

    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Crl.CertificateRevocationListToBeSigned_version = pInfo->dwVersion;
#else
        Crl.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Crl.bit_mask |= CertificateRevocationListToBeSigned_version_present;
    }
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm, &Crl.signature,
            CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;
    Asn1X509SetAny(&pInfo->Issuer, &Crl.issuer);
    if (!PkiAsn1ToChoiceOfTime(&pInfo->ThisUpdate, 
            &Crl.thisUpdate.choice,
            &Crl.thisUpdate.u.generalTime,
            &Crl.thisUpdate.u.utcTime
            ))
        goto EncodeError;
    if (pInfo->NextUpdate.dwLowDateTime || pInfo->NextUpdate.dwHighDateTime) {
        Crl.bit_mask |= nextUpdate_present;
        if (!PkiAsn1ToChoiceOfTime(&pInfo->NextUpdate, 
                &Crl.nextUpdate.choice,
                &Crl.nextUpdate.u.generalTime,
                &Crl.nextUpdate.u.utcTime
                ))
            goto EncodeError;
    }
    if (pInfo->cCRLEntry) {
        if (!Asn1X509SetCrlEntries(pInfo->cCRLEntry, pInfo->rgCRLEntry,
                &Crl.revokedCertificates))
            goto ErrorReturn;
        Crl.bit_mask |= revokedCertificates_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Crl.crlExtensions))
            goto ErrorReturn;
        Crl.bit_mask |= crlExtensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateRevocationListToBeSigned_PDU,
        &Crl,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeCrlEntries(&Crl.revokedCertificates);
    Asn1X509FreeExtensions(&Crl.crlExtensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the CRL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateRevocationListToBeSigned *pCrl = 
        (CertificateRevocationListToBeSigned *) pvAsn1Info;
    PCRL_INFO pInfo = (PCRL_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRL_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRL_INFO));

        // Update fields not needing extra memory after the CRL_INFO
        if (pCrl->bit_mask &
                CertificateRevocationListToBeSigned_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion =
                pCrl->CertificateRevocationListToBeSigned_version;
#else
            pInfo->dwVersion = pCrl->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCrl->thisUpdate.choice,
                &pCrl->thisUpdate.u.generalTime,
                &pCrl->thisUpdate.u.utcTime,
                &pInfo->ThisUpdate))
            goto DecodeError;
        if (pCrl->bit_mask & nextUpdate_present) {
            if (!PkiAsn1FromChoiceOfTime(pCrl->nextUpdate.choice,
                    &pCrl->nextUpdate.u.generalTime,
                    &pCrl->nextUpdate.u.utcTime,
                    &pInfo->NextUpdate))
                goto DecodeError;
        }

        pbExtra = (BYTE *) pInfo + sizeof(CRL_INFO);
    }

    Asn1X509GetAlgorithm(&pCrl->signature, dwFlags,
            &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCrl->issuer, dwFlags,
            &pInfo->Issuer, &pbExtra, &lRemainExtra);
    if (pCrl->bit_mask & revokedCertificates_present)
        Asn1X509GetCrlEntries(&pCrl->revokedCertificates, dwFlags,
            &pInfo->cCRLEntry, &pInfo->rgCRLEntry, &pbExtra, &lRemainExtra);
    if (pCrl->bit_mask & crlExtensions_present)
        Asn1X509GetExtensions(&pCrl->crlExtensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CrlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificateRevocationListToBeSigned_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CrlInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Cert Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificationRequestInfo CertReq;
    DWORD cAttr;
    PCRYPT_ATTRIBUTE pAttr;
    Attribute *pAsn1Attr;

    memset(&CertReq, 0, sizeof(CertReq));
    CertReq.version = pInfo->dwVersion;

    Asn1X509SetAny(&pInfo->Subject, &CertReq.subject);
    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &CertReq.subjectPublicKeyInfo))
        goto ErrorReturn;

    cAttr = pInfo->cAttribute;
    pAttr = pInfo->rgAttribute;
    CertReq.attributes.count = cAttr;
    CertReq.attributes.value = NULL;
    if (cAttr > 0) {
        pAsn1Attr = (Attribute *) PkiZeroAlloc(cAttr * sizeof(Attribute));
        if (pAsn1Attr == NULL)
            goto ErrorReturn;
        CertReq.attributes.value = pAsn1Attr;
    }

    for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++) {
        if (!Asn1X509SetAttribute(pAttr, pAsn1Attr))
            goto ErrorReturn;
    }

    fResult = Asn1InfoEncodeEx(
        CertificationRequestInfo_PDU,
        &CertReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (CertReq.attributes.value) {
        pAsn1Attr = CertReq.attributes.value;
        cAttr = CertReq.attributes.count;
        for ( ; cAttr > 0; cAttr--, pAsn1Attr++)
            Asn1X509FreeAttribute(pAsn1Attr);

        PkiFree(CertReq.attributes.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Cert Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificationRequestInfoDecode *pCertReq = 
        (CertificationRequestInfoDecode *) pvAsn1Info;
    PCERT_REQUEST_INFO pInfo = (PCERT_REQUEST_INFO) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;

    lRemainExtra -= sizeof(CERT_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_REQUEST_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        pInfo->dwVersion = pCertReq->version;
        pbExtra = (BYTE *) pInfo + sizeof(CERT_REQUEST_INFO);
    }

    Asn1X509GetAny(&pCertReq->subject, dwFlags,
            &pInfo->Subject, &pbExtra, &lRemainExtra);
    Asn1X509GetPublicKeyInfo(&pCertReq->subjectPublicKeyInfo, dwFlags,
            &pInfo->SubjectPublicKeyInfo,
            &pbExtra, &lRemainExtra);

    if (pCertReq->bit_mask & attributes_present) {
        DWORD cAttr;
        PCRYPT_ATTRIBUTE pAttr;
        Attribute *pAsn1Attr;
        LONG lAlignExtra;

        cAttr = pCertReq->attributes.count;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cAttribute = cAttr;
            pAttr = (PCRYPT_ATTRIBUTE) pbExtra;
            pInfo->rgAttribute = pAttr;
            pbExtra += lAlignExtra;
        } else
            pAttr = NULL;

        pAsn1Attr = pCertReq->attributes.value;
        for (; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
            Asn1X509GetAttribute(pAsn1Attr, dwFlags,
                pAttr, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificationRequestInfoDecode_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CertRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Keygen Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeygenRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    KeygenRequestInfo KeygenReq;
    DWORD dwErrLocation;

    memset(&KeygenReq, 0, sizeof(KeygenReq));

    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &KeygenReq.subjectPublicKeyInfo))
        goto ErrorReturn;
    if (!Asn1X509SetUnicodeConvertedToIA5(pInfo->pwszChallengeString,
            &KeygenReq.challenge, 0, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        goto InvalidIA5;
    }

    fResult = Asn1InfoEncodeEx(
        KeygenRequestInfo_PDU,
        &KeygenReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
InvalidIA5:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeUnicodeConvertedToIA5(&KeygenReq.challenge);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Keygen Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeygenRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    KeygenRequestInfo *pKeygenReq = (KeygenRequestInfo *) pvAsn1Info;
    PCERT_KEYGEN_REQUEST_INFO pInfo = (PCERT_KEYGEN_REQUEST_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEYGEN_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEYGEN_REQUEST_INFO));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEYGEN_REQUEST_INFO);
    }

    Asn1X509GetPublicKeyInfo(&pKeygenReq->subjectPublicKeyInfo, dwFlags,
        &pInfo->SubjectPublicKeyInfo, &pbExtra, &lRemainExtra);
    Asn1X509GetIA5ConvertedToUnicode(&pKeygenReq->challenge, dwFlags,
            &pInfo->pwszChallengeString, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509KeygenRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        KeygenRequestInfo_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509KeygenRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Signed Content (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SignedContentEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_SIGNED_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SignedContent Asn1SignedContent;
    CRYPT_BIT_BLOB SignatureBlob;
    BYTE *pbAllocSignature = NULL;

    memset(&Asn1SignedContent, 0, sizeof(Asn1SignedContent));
    Asn1X509SetAny(&pInfo->ToBeSigned, &Asn1SignedContent.toBeSigned);
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm,
            &Asn1SignedContent.algorithm, CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;

    if (dwFlags & CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG) {
        SignatureBlob.pbData = pInfo->Signature.pbData;
    } else {
        if (NULL == (pbAllocSignature = PkiAsn1AllocAndReverseBytes(
                pInfo->Signature.pbData, pInfo->Signature.cbData)))
            goto ErrorReturn;
        SignatureBlob.pbData = pbAllocSignature;
    }
    SignatureBlob.cbData = pInfo->Signature.cbData;
    SignatureBlob.cUnusedBits = 0;
    Asn1X509SetBit(&SignatureBlob, &Asn1SignedContent.signature);

    fResult = Asn1InfoEncodeEx(
        SignedContent_PDU,
        &Asn1SignedContent,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbAllocSignature)
        PkiAsn1Free(pbAllocSignature);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Signed Content (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SignedContentDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SignedContent *pSignedContent = (SignedContent *) pvAsn1Info;
    PCERT_SIGNED_CONTENT_INFO pInfo = (PCERT_SIGNED_CONTENT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_SIGNED_CONTENT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_SIGNED_CONTENT_INFO);

    Asn1X509GetAny(&pSignedContent->toBeSigned, dwFlags,
        &pInfo->ToBeSigned, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pSignedContent->algorithm, dwFlags,
        &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    // Since bits will be reversed, always need to make a copy (dwFlags = 0)
    Asn1X509GetBit(&pSignedContent->signature, 0,
        &pInfo->Signature, &pbExtra, &lRemainExtra);
    if (lRemainExtra >= 0) {
        if (0 == (dwFlags & CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG))
            PkiAsn1ReverseBytes(pInfo->Signature.pbData,
                pInfo->Signature.cbData);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509SignedContentDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
            SignedContent_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X509SignedContentDecodeExCallback,
            pvStructInfo,
            pcbStructInfo
            );
}

//+-------------------------------------------------------------------------
//  Encode the Name Info (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cRDN, cAttr;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    Name Asn1Name;
    RelativeDistinguishedName *pAsn1RDN;
    AttributeTypeValue *pAsn1Attr;

    cRDN = pInfo->cRDN;
    pRDN = pInfo->rgRDN;
    Asn1Name.count = cRDN;
    Asn1Name.value = NULL;
    if (cRDN > 0) {
        pAsn1RDN =
            (RelativeDistinguishedName *) PkiZeroAlloc(
                cRDN * sizeof(RelativeDistinguishedName));
        if (pAsn1RDN == NULL)
            goto ErrorReturn;
        Asn1Name.value = pAsn1RDN;
    }

    // Array of RDNs
    for ( ; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
        cAttr = pRDN->cRDNAttr;
        pAttr = pRDN->rgRDNAttr;
        pAsn1RDN->count = cAttr;

        if (cAttr > 0) {
            pAsn1Attr =
                (AttributeTypeValue *) PkiZeroAlloc(cAttr *
                    sizeof(AttributeTypeValue));
            if (pAsn1Attr == NULL)
                goto ErrorReturn;
            pAsn1RDN->value = pAsn1Attr;
        }

        // Array of attribute/values
        for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++) {
            // We're now ready to encode the attribute/value stuff
            if (!Asn1X509SetRDNAttribute(pAttr, pAsn1Attr))
                goto ErrorReturn;
        }
    }

    fResult = Asn1InfoEncodeEx(
        Name_PDU,
        &Asn1Name,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1Name.value) {
        cRDN = Asn1Name.count;
        pRDN = pInfo->rgRDN;
        pAsn1RDN = Asn1Name.value;
        for ( ; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
            if (pAsn1RDN->value) {
                cAttr = pAsn1RDN->count;
                pAttr = pRDN->rgRDNAttr;
                pAsn1Attr = pAsn1RDN->value;
                for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
                    Asn1X509FreeRDNAttribute(pAttr, pAsn1Attr);
                PkiFree(pAsn1RDN->value);
            }
        }
        PkiFree(Asn1Name.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Name Info (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Name *pAsn1Name =  (Name *) pvAsn1Info;
    PCERT_NAME_INFO pInfo = (PCERT_NAME_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    DWORD cRDN, cAttr;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    RelativeDistinguishedName *pAsn1RDN;
    AttributeTypeValue *pAsn1Attr;

    lRemainExtra -= sizeof(CERT_NAME_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_INFO);

    cRDN = pAsn1Name->count;
    pAsn1RDN = pAsn1Name->value;
    lAlignExtra = INFO_LEN_ALIGN(cRDN * sizeof(CERT_RDN));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cRDN = cRDN;
        pRDN = (PCERT_RDN) pbExtra;
        pInfo->rgRDN = pRDN;
        pbExtra += lAlignExtra;
    } else
        pRDN = NULL;

    // Array of RDNs
    for (; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
        cAttr = pAsn1RDN->count;
        pAsn1Attr = pAsn1RDN->value;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CERT_RDN_ATTR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pRDN->cRDNAttr = cAttr;
            pAttr = (PCERT_RDN_ATTR) pbExtra;
            pRDN->rgRDNAttr = pAttr;
            pbExtra += lAlignExtra;
        } else
            pAttr = NULL;

        // Array of attribute/values
        for (; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
            // We're now ready to decode the attribute/value stuff
            if (!Asn1X509GetRDNAttribute(pAsn1Attr, dwFlags,
                    pAttr, &pbExtra, &lRemainExtra))
                return FALSE;
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}


BOOL WINAPI Asn1X509NameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Name_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509NameInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Encode a single Name Value (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwValueType;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    dwValueType = pInfo->dwValueType;
    switch (dwValueType) {
    case CERT_RDN_ANY_TYPE:
        SetLastError((DWORD) E_INVALIDARG);
        *pcbEncoded = 0;
        fResult = FALSE;
        break;
#ifndef ASN1_SUPPORTS_UTF8_TAG
    case CERT_RDN_UTF8_STRING:
        {
            CERT_NAME_VALUE EncodedBlobInfo;

            fResult = Asn1X509AllocAndEncodeUTF8(
                &pInfo->Value,
                &EncodedBlobInfo.Value.pbData,
                &EncodedBlobInfo.Value.cbData
                );
            if (fResult) {
                EncodedBlobInfo.dwValueType = CERT_RDN_ENCODED_BLOB;
                fResult = Asn1X509NameValueEncodeEx(
                    dwCertEncodingType,
                    lpszStructType,
                    &EncodedBlobInfo,
                    dwFlags,
                    pEncodePara,
                    pvEncoded,
                    pcbEncoded
                    );
                Asn1X509FreeEncodedUTF8(EncodedBlobInfo.Value.pbData);
            } else
                *pcbEncoded = 0;
        }
        break;
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    case CERT_RDN_ENCODED_BLOB:
        {
            DWORD cbEncoded = pInfo->Value.cbData;

            fResult = TRUE;
            if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
                if (cbEncoded) {
                    BYTE *pb;
                    PFN_CRYPT_ALLOC pfnAlloc =
                        PkiGetEncodeAllocFunction(pEncodePara);
                    if (NULL == (pb = (BYTE *) pfnAlloc(cbEncoded))) {
                        fResult = FALSE;
                        cbEncoded = 0;
                    } else {
                        memcpy(pb, pInfo->Value.pbData, cbEncoded);
                        *((BYTE **) pvEncoded) = pb;
                    }
                }
            } else {
                if (NULL == pvEncoded)
                    *pcbEncoded = 0;
                if (*pcbEncoded < cbEncoded) {
                    if (pvEncoded) {
                        SetLastError((DWORD) ERROR_MORE_DATA);
                        fResult = FALSE;
                    }
                } else if (cbEncoded)
                    memcpy((BYTE *) pvEncoded, pInfo->Value.pbData, cbEncoded);
            }
            *pcbEncoded = cbEncoded;
        }
        break;
    default:
        {
            AnyString Asn1AnyString;

            Asn1X509SetAnyString(dwValueType, &pInfo->Value, &Asn1AnyString);
            fResult = Asn1InfoEncodeEx(
                AnyString_PDU,
                &Asn1AnyString,
                dwFlags,
                pEncodePara,
                pvEncoded,
                pcbEncoded
                );
        }
        break;
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode a single Name Value (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    PCERT_NAME_VALUE pInfo = (PCERT_NAME_VALUE) pvStructInfo;
    NOCOPYANY Asn1Value;
    BYTE *pbExtra;
    LONG lRemainExtra;


    if (pInfo == NULL || (dwFlags & CRYPT_DECODE_ALLOC_FLAG))
        *pcbStructInfo = 0;

    memset(&Asn1Value, 0, sizeof(Asn1Value));
    Asn1Value.encoded = (void *)pbEncoded;
    Asn1Value.length = cbEncoded;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbStructInfo - sizeof(CERT_NAME_VALUE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_VALUE);

    if (!Asn1X509GetRDNAttributeValue(&Asn1Value, dwFlags,
            &pInfo->dwValueType, &pInfo->Value, &pbExtra, &lRemainExtra))
        goto GetRDNAttributeValueError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        PCERT_NAME_VALUE pAllocInfo;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;

        pAllocInfo = (PCERT_NAME_VALUE) pfnAlloc(lRemainExtra);
        *((PCERT_NAME_VALUE *) pvStructInfo) = pAllocInfo;
        if (NULL == pAllocInfo)
            goto OutOfMemory;
        *pcbStructInfo = lRemainExtra;

        pbExtra = (BYTE *) pAllocInfo + sizeof(CERT_NAME_VALUE);
        lRemainExtra -= sizeof(CERT_NAME_VALUE);
        if (!Asn1X509GetRDNAttributeValue(&Asn1Value, dwFlags,
                &pAllocInfo->dwValueType, &pAllocInfo->Value,
                &pbExtra, &lRemainExtra))
            goto GetRDNAttributeValueError;
        assert(lRemainExtra >= 0);
    }

    if (lRemainExtra >= 0)
        *pcbStructInfo = *pcbStructInfo - (DWORD) lRemainExtra;
    else {
        *pcbStructInfo = *pcbStructInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbStructInfo = 0;
    goto CommonReturn;
TRACE_ERROR(GetRDNAttributeValueError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Encode X509 certificate extensions (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_EXTENSIONS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Extensions Asn1Ext;

    if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension, &Asn1Ext))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        Extensions_PDU,
        &Asn1Ext,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeExtensions(&Asn1Ext);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode X509 certificate extensions (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Extensions *pAsn1Ext = (Extensions *) pvAsn1Info;
    PCERT_EXTENSIONS pInfo = (PCERT_EXTENSIONS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_EXTENSIONS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_EXTENSIONS);

    Asn1X509GetExtensions(pAsn1Ext, dwFlags,
        &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509ExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Extensions_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ExtensionsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Public Key Info Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SubjectPublicKeyInfo PublicKey;

    if (!Asn1X509SetPublicKeyInfo(pInfo, &PublicKey))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        SubjectPublicKeyInfo_PDU,
        &PublicKey,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}


//+-------------------------------------------------------------------------
//  Public Key Info Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SubjectPublicKeyInfo *pPublicKey = (SubjectPublicKeyInfo *) pvAsn1Info;
    PCERT_PUBLIC_KEY_INFO pInfo = (PCERT_PUBLIC_KEY_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_PUBLIC_KEY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_PUBLIC_KEY_INFO);

    Asn1X509GetPublicKeyInfo(pPublicKey, dwFlags,
        pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509PublicKeyInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SubjectPublicKeyInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PublicKeyInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

//+-------------------------------------------------------------------------
//  RSA Public Key Structure Encode (ASN1 X509)
//
//  Converts from the CAPI public key representation to a PKCS #1 RSAPublicKey
//
//  BUGBUG: BYTE reversal::
//   - this only needs to be done for little endian
//   - this needs to be fixed in the ASN1 compiler
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pPubKeyStruc,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    RSAPUBKEY *pRsaPubKey;
    const BYTE *pbModulus;
    DWORD cbModulus;
    BYTE *pbAllocModulus = NULL;
    RSAPublicKey Asn1PubKey;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pRsaPubKey = (RSAPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbModulus = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus = pRsaPubKey->bitlen / 8;

    assert(cbModulus > 0);
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey->magic == RSA1);
    assert(pRsaPubKey->bitlen % 8 == 0);

    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;

    // PKCS #1 ASN.1 encode
    //
    // BUGBUG:: ASN1 isn't reversing HUGE_INTEGERs. Also, after doing the
    // reversal insert a leading 0 byte to force it to always be treated
    // as an unsigned integer
    if (NULL == (pbAllocModulus = (BYTE *) PkiNonzeroAlloc(cbModulus + 1)))
        goto ErrorReturn;
    *pbAllocModulus = 0;
    memcpy(pbAllocModulus + 1, pbModulus, cbModulus);
    PkiAsn1ReverseBytes(pbAllocModulus + 1, cbModulus);
    pbModulus = pbAllocModulus;
    cbModulus++;

    Asn1PubKey.publicExponent = pRsaPubKey->pubexp;
    Asn1PubKey.modulus.length = cbModulus;
    Asn1PubKey.modulus.value = (BYTE *) pbModulus;

    fResult = Asn1InfoEncodeEx(
        RSAPublicKey_PDU,
        &Asn1PubKey,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbAllocModulus)
        PkiFree(pbAllocModulus);
    return fResult;
}


//+-------------------------------------------------------------------------
//  RSA Public Key Structure Decode (ASN1 X509)
//
//  Converts from a PKCS #1 RSAPublicKey to a CAPI public key representation
//
//  BUGBUG: BYTE reversal::
//   - this only needs to be done for little endian
//   - this needs to be fixed in the ASN1 compiler
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    RSAPublicKey *pAsn1PubKey = (RSAPublicKey *) pvAsn1Info;
    PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pvStructInfo;
    BYTE *pbAsn1Modulus;
    DWORD cbModulus;

    // Now convert the ASN1 RSA public key into CAPI's representation which
    // consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    cbModulus = pAsn1PubKey->modulus.length;
    pbAsn1Modulus = pAsn1PubKey->modulus.value;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbModulus > 1 && *pbAsn1Modulus == 0) {
        pbAsn1Modulus++;
        cbModulus--;
    }
    *plRemainExtra -= sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus;
    if (0 <= *plRemainExtra) {
        BYTE *pbKeyBlob = (BYTE *) pPubKeyStruc;
        RSAPUBKEY *pRsaPubKey =
            (RSAPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
        BYTE *pbModulus = pbKeyBlob + sizeof(PUBLICKEYSTRUC) +
            sizeof(RSAPUBKEY);

        pPubKeyStruc->bType = PUBLICKEYBLOB;
        pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
        pPubKeyStruc->reserved = 0;
        // Note: KEYX can also be used for doing a signature
        pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        pRsaPubKey->magic = RSA1;
        pRsaPubKey->bitlen = cbModulus * 8;
        pRsaPubKey->pubexp = pAsn1PubKey->publicExponent;
        if (cbModulus > 0) {
            memcpy(pbModulus, pbAsn1Modulus, cbModulus);
            // ASN1 isn't reversing HUGEINTEGERs
            PkiAsn1ReverseBytes(pbModulus, cbModulus);
        }
    }
    return TRUE;
}

BOOL WINAPI Asn1RSAPublicKeyStrucDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        RSAPublicKey_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1RSAPublicKeyStrucDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Authority Key Id Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;

    AuthorityKeyId Asn1AuthorityKeyId;
    memset(&Asn1AuthorityKeyId, 0, sizeof(Asn1AuthorityKeyId));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1AuthorityKeyId.AuthorityKeyId_keyIdentifier);
#else
            &Asn1AuthorityKeyId.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1AuthorityKeyId.bit_mask |= AuthorityKeyId_keyIdentifier_present;
    }
    if (pInfo->CertIssuer.cbData) {
        Asn1X509SetAny(&pInfo->CertIssuer, &Asn1AuthorityKeyId.certIssuer);
        Asn1AuthorityKeyId.bit_mask |= certIssuer_present;
    }
    if (pInfo->CertSerialNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->CertSerialNumber,
                &Asn1AuthorityKeyId.certSerialNumber))
            goto ErrorReturn;
        Asn1AuthorityKeyId.bit_mask |= certSerialNumber_present;
    }

    fResult = Asn1InfoEncodeEx(
        AuthorityKeyId_PDU,
        &Asn1AuthorityKeyId,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeInteger(&Asn1AuthorityKeyId.certSerialNumber);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Key Id Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    AuthorityKeyId *pAuthorityKeyId = (AuthorityKeyId *) pvAsn1Info;
    PCERT_AUTHORITY_KEY_ID_INFO pInfo =
        (PCERT_AUTHORITY_KEY_ID_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_AUTHORITY_KEY_ID_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_AUTHORITY_KEY_ID_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_KEY_ID_INFO);
    }

    if (pAuthorityKeyId->bit_mask & AuthorityKeyId_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pAuthorityKeyId->AuthorityKeyId_keyIdentifier,
#else
        Asn1X509GetOctetString(&pAuthorityKeyId->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId->bit_mask & certIssuer_present)
        Asn1X509GetAny(&pAuthorityKeyId->certIssuer, dwFlags,
            &pInfo->CertIssuer, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId->bit_mask & certSerialNumber_present)
        Asn1X509GetHugeInteger(&pAuthorityKeyId->certSerialNumber, dwFlags,
            &pInfo->CertSerialNumber, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AuthorityKeyIdDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityKeyId_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityKeyIdDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Authority Key Id2 Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyId2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwErrLocation;

    AuthorityKeyId2 Asn1AuthorityKeyId2;
    memset(&Asn1AuthorityKeyId2, 0, sizeof(Asn1AuthorityKeyId2));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1AuthorityKeyId2.AuthorityKeyId2_keyIdentifier);
#else
            &Asn1AuthorityKeyId2.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1AuthorityKeyId2.bit_mask |= AuthorityKeyId2_keyIdentifier_present;
    }
    if (pInfo->AuthorityCertIssuer.cAltEntry) {
        if (!Asn1X509SetAltNames(&pInfo->AuthorityCertIssuer,
                &Asn1AuthorityKeyId2.authorityCertIssuer, 0, &dwErrLocation)) {
            *pcbEncoded = dwErrLocation;
            goto AltNamesError;
        }
        Asn1AuthorityKeyId2.bit_mask |= authorityCertIssuer_present;
    }
    if (pInfo->AuthorityCertSerialNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->AuthorityCertSerialNumber,
                &Asn1AuthorityKeyId2.authorityCertSerialNumber))
            goto ErrorReturn;
        Asn1AuthorityKeyId2.bit_mask |= authorityCertSerialNumber_present;
    }

    fResult = Asn1InfoEncodeEx(
        AuthorityKeyId2_PDU,
        &Asn1AuthorityKeyId2,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
AltNamesError:
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeAltNames(&Asn1AuthorityKeyId2.authorityCertIssuer);
    Asn1X509FreeHugeInteger(&Asn1AuthorityKeyId2.authorityCertSerialNumber);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Key Id2 Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyId2DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AuthorityKeyId2 *pAuthorityKeyId2 = (AuthorityKeyId2 *) pvAsn1Info;
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo =
        (PCERT_AUTHORITY_KEY_ID2_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_AUTHORITY_KEY_ID2_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_AUTHORITY_KEY_ID2_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_KEY_ID2_INFO);
    }

    if (pAuthorityKeyId2->bit_mask & AuthorityKeyId2_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pAuthorityKeyId2->AuthorityKeyId2_keyIdentifier,
#else
        Asn1X509GetOctetString(&pAuthorityKeyId2->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId2->bit_mask & authorityCertIssuer_present) {
        if (!Asn1X509GetAltNames(&pAuthorityKeyId2->authorityCertIssuer, dwFlags,
                &pInfo->AuthorityCertIssuer, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }
    if (pAuthorityKeyId2->bit_mask & authorityCertSerialNumber_present)
        Asn1X509GetHugeInteger(&pAuthorityKeyId2->authorityCertSerialNumber, dwFlags,
            &pInfo->AuthorityCertSerialNumber, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509AuthorityKeyId2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityKeyId2_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityKeyId2DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Key Attributes Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    KeyAttributes Asn1KeyAttributes;
    memset(&Asn1KeyAttributes, 0, sizeof(Asn1KeyAttributes));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1KeyAttributes.KeyAttributes_keyIdentifier);
#else
            &Asn1KeyAttributes.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1KeyAttributes.bit_mask |= KeyAttributes_keyIdentifier_present;
    }
    if (pInfo->IntendedKeyUsage.cbData) {
        Asn1X509SetBitWithoutTrailingZeroes(&pInfo->IntendedKeyUsage,
            &Asn1KeyAttributes.intendedKeyUsage);
        Asn1KeyAttributes.bit_mask |= intendedKeyUsage_present;
    }
    if (pInfo->pPrivateKeyUsagePeriod) {
        if (!PkiAsn1ToGeneralizedTime(
                &pInfo->pPrivateKeyUsagePeriod->NotBefore,
                &Asn1KeyAttributes.privateKeyUsagePeriod.notBefore))
            goto EncodeError;
        if (!PkiAsn1ToGeneralizedTime(
                &pInfo->pPrivateKeyUsagePeriod->NotAfter,
                &Asn1KeyAttributes.privateKeyUsagePeriod.notAfter))
            goto EncodeError;
        Asn1KeyAttributes.privateKeyUsagePeriod.bit_mask |=
            notBefore_present | notAfter_present;
        Asn1KeyAttributes.bit_mask |= privateKeyUsagePeriod_present;
    }

    fResult = Asn1InfoEncodeEx(
        KeyAttributes_PDU,
        &Asn1KeyAttributes,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

//+-------------------------------------------------------------------------
//  Key Attributes Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyAttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    KeyAttributes *pKeyAttributes = (KeyAttributes *) pvAsn1Info;
    PCERT_KEY_ATTRIBUTES_INFO pInfo = (PCERT_KEY_ATTRIBUTES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEY_ATTRIBUTES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEY_ATTRIBUTES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEY_ATTRIBUTES_INFO);
    }

    if (pKeyAttributes->bit_mask & KeyAttributes_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pKeyAttributes->KeyAttributes_keyIdentifier,
#else
        Asn1X509GetOctetString(&pKeyAttributes->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pKeyAttributes->bit_mask & intendedKeyUsage_present)
        Asn1X509GetBit(&pKeyAttributes->intendedKeyUsage, dwFlags,
            &pInfo->IntendedKeyUsage, &pbExtra, &lRemainExtra);

    if (pKeyAttributes->bit_mask & privateKeyUsagePeriod_present) {
        LONG lAlignExtra;
        PrivateKeyValidity *pAsn1KeyUsage =
            &pKeyAttributes->privateKeyUsagePeriod;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(CERT_PRIVATE_KEY_VALIDITY));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            PCERT_PRIVATE_KEY_VALIDITY pKeyUsage =
                (PCERT_PRIVATE_KEY_VALIDITY) pbExtra;

            // Default all optional fields to zero
            memset(pKeyUsage, 0, sizeof(CERT_PRIVATE_KEY_VALIDITY));
            if (pAsn1KeyUsage->bit_mask & notBefore_present) {
                if (!PkiAsn1FromGeneralizedTime(&pAsn1KeyUsage->notBefore,
                        &pKeyUsage->NotBefore))
                    goto DecodeError;
            }
            if (pAsn1KeyUsage->bit_mask & notAfter_present) {
                if (!PkiAsn1FromGeneralizedTime(&pAsn1KeyUsage->notAfter,
                        &pKeyUsage->NotAfter))
                    goto DecodeError;
            }
            pInfo->pPrivateKeyUsagePeriod = pKeyUsage;
            pbExtra += lAlignExtra;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509KeyAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        KeyAttributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509KeyAttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  AltName Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AltNameEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_ALT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AltNames AltNames;
    DWORD dwErrLocation;

    if (!Asn1X509SetAltNames(pInfo, &AltNames, 0, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        goto CommonReturn;
    }

    fResult = Asn1InfoEncodeEx(
        AltNames_PDU,
        &AltNames,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeAltNames(&AltNames);
    return fResult;
}


//+-------------------------------------------------------------------------
//  AltName Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AltNameDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AltNames *pAltNames = (AltNames *) pvAsn1Info;
    PCERT_ALT_NAME_INFO pInfo = (PCERT_ALT_NAME_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_ALT_NAME_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_ALT_NAME_INFO);

    if (!Asn1X509GetAltNames(pAltNames, dwFlags,
            pInfo, &pbExtra, &lRemainExtra))
        goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509AltNameDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AltNames_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AltNameDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}



//+-------------------------------------------------------------------------
//  Key Usage Restriction Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyUsageRestrictionEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cPolicyId;

    KeyUsageRestriction Asn1KeyUsageRestriction;
    memset(&Asn1KeyUsageRestriction, 0, sizeof(Asn1KeyUsageRestriction));

    cPolicyId = pInfo->cCertPolicyId;
    if (cPolicyId) {
        PCERT_POLICY_ID pPolicyId = pInfo->rgCertPolicyId;
        CertPolicyId *pAsn1PolicyId =
            (CertPolicyId *) PkiZeroAlloc(cPolicyId * sizeof(CertPolicyId));
        if (pAsn1PolicyId == NULL) goto ErrorReturn;
        Asn1KeyUsageRestriction.certPolicySet.count = cPolicyId;
        Asn1KeyUsageRestriction.certPolicySet.value = pAsn1PolicyId;

        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++, pAsn1PolicyId++) {
            DWORD cElement = pPolicyId->cCertPolicyElementId;
            if (cElement > 0) {
                LPSTR *ppszElement = pPolicyId->rgpszCertPolicyElementId;
                EncodedObjectID *pAsn1Element =
                    (EncodedObjectID *) PkiZeroAlloc(cElement * sizeof(EncodedObjectID));
                if (pAsn1Element == NULL) goto ErrorReturn;
                pAsn1PolicyId->count = cElement;
                pAsn1PolicyId->value = pAsn1Element;
                for ( ; cElement > 0; cElement--, ppszElement++, pAsn1Element++)
                    if (!Asn1X509SetEncodedObjId(*ppszElement, pAsn1Element))
                        goto ErrorReturn;
            }
        }
        Asn1KeyUsageRestriction.bit_mask |= certPolicySet_present;
    }

    if (pInfo->RestrictedKeyUsage.cbData) {
        Asn1X509SetBitWithoutTrailingZeroes(&pInfo->RestrictedKeyUsage,
            &Asn1KeyUsageRestriction.restrictedKeyUsage);
        Asn1KeyUsageRestriction.bit_mask |= restrictedKeyUsage_present;
    }

    fResult = Asn1InfoEncodeEx(
        KeyUsageRestriction_PDU,
        &Asn1KeyUsageRestriction,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1KeyUsageRestriction.certPolicySet.value) {
        cPolicyId = Asn1KeyUsageRestriction.certPolicySet.count;
        CertPolicyId *pAsn1PolicyId = Asn1KeyUsageRestriction.certPolicySet.value;
        for ( ; cPolicyId > 0; cPolicyId--, pAsn1PolicyId++)
            if (pAsn1PolicyId->value)
                PkiFree(pAsn1PolicyId->value);
        PkiFree(Asn1KeyUsageRestriction.certPolicySet.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Key Usage Restriction Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    KeyUsageRestriction *pKeyUsageRestriction =
        (KeyUsageRestriction *) pvAsn1Info;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo =
        (PCERT_KEY_USAGE_RESTRICTION_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEY_USAGE_RESTRICTION_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEY_USAGE_RESTRICTION_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEY_USAGE_RESTRICTION_INFO);
    }

    if (pKeyUsageRestriction->bit_mask & certPolicySet_present) {
        LONG lAlignExtra;
        DWORD cPolicyId;
        PCERT_POLICY_ID pPolicyId;
        CertPolicyId *pAsn1PolicyId;

        cPolicyId = pKeyUsageRestriction->certPolicySet.count;
        lAlignExtra = INFO_LEN_ALIGN(cPolicyId * sizeof(CERT_POLICY_ID));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cCertPolicyId = cPolicyId;
            pPolicyId = (PCERT_POLICY_ID) pbExtra;
            pInfo->rgCertPolicyId = pPolicyId;
            pbExtra += lAlignExtra;
        } else
            pPolicyId = NULL;

        pAsn1PolicyId = pKeyUsageRestriction->certPolicySet.value;
        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++, pAsn1PolicyId++) {
            DWORD cElement;
            LPSTR *ppszElement;
            EncodedObjectID *pAsn1Element;

            cElement = pAsn1PolicyId->count;
            lAlignExtra = INFO_LEN_ALIGN(cElement * sizeof(LPSTR *));
            lRemainExtra -= lAlignExtra;
            if (lRemainExtra >= 0) {
                pPolicyId->cCertPolicyElementId = cElement;
                ppszElement = (LPSTR *) pbExtra;
                pPolicyId->rgpszCertPolicyElementId = ppszElement;
                pbExtra += lAlignExtra;
            } else
                ppszElement = NULL;

            pAsn1Element = pAsn1PolicyId->value;
            for ( ; cElement > 0; cElement--, ppszElement++, pAsn1Element++)
                Asn1X509GetEncodedObjId(pAsn1Element, dwFlags,
                    ppszElement, &pbExtra, &lRemainExtra);
        }
    }

    if (pKeyUsageRestriction->bit_mask & restrictedKeyUsage_present)
        Asn1X509GetBit(&pKeyUsageRestriction->restrictedKeyUsage, dwFlags,
            &pInfo->RestrictedKeyUsage, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        KeyUsageRestriction_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509KeyUsageRestrictionDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cSubtrees;

    BasicConstraints Asn1BasicConstraints;
    memset(&Asn1BasicConstraints, 0, sizeof(Asn1BasicConstraints));

    Asn1X509SetBitWithoutTrailingZeroes(&pInfo->SubjectType,
        &Asn1BasicConstraints.subjectType);
    if (pInfo->fPathLenConstraint) {
#ifdef OSS_CRYPT_ASN1
        Asn1BasicConstraints.BasicConstraints_pathLenConstraint =
#else
        Asn1BasicConstraints.pathLenConstraint =
#endif  // OSS_CRYPT_ASN1
            pInfo->dwPathLenConstraint;
        Asn1BasicConstraints.bit_mask |=
            BasicConstraints_pathLenConstraint_present;
    }
    cSubtrees = pInfo->cSubtreesConstraint;
    if (cSubtrees) {
        PCERT_NAME_BLOB pSubtrees = pInfo->rgSubtreesConstraint;
        NOCOPYANY *pAsn1Subtrees =
            (NOCOPYANY *) PkiZeroAlloc(
                cSubtrees * sizeof(NOCOPYANY));
        if (pAsn1Subtrees == NULL) goto ErrorReturn;
        Asn1BasicConstraints.subtreesConstraint.count = cSubtrees;
        Asn1BasicConstraints.subtreesConstraint.value = pAsn1Subtrees;

        for ( ; cSubtrees > 0; cSubtrees--, pSubtrees++, pAsn1Subtrees++)
            Asn1X509SetAny(pSubtrees, pAsn1Subtrees);
        Asn1BasicConstraints.bit_mask |= subtreesConstraint_present;
    }

    fResult = Asn1InfoEncodeEx(
        BasicConstraints_PDU,
        &Asn1BasicConstraints,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1BasicConstraints.subtreesConstraint.value)
        PkiFree(Asn1BasicConstraints.subtreesConstraint.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Basic Constraints Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraintsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BasicConstraints *pBasicConstraints = (BasicConstraints *) pvAsn1Info;
    PCERT_BASIC_CONSTRAINTS_INFO pInfo =
        (PCERT_BASIC_CONSTRAINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_BASIC_CONSTRAINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_BASIC_CONSTRAINTS_INFO));

        // Update fields not needing extra memory after the
        // CERT_BASIC_CONSTRAINTS_INFO
        if (pBasicConstraints->bit_mask &
                BasicConstraints_pathLenConstraint_present) {
            pInfo->fPathLenConstraint = TRUE;
            pInfo->dwPathLenConstraint =
#ifdef OSS_CRYPT_ASN1
                pBasicConstraints->BasicConstraints_pathLenConstraint;
#else
                pBasicConstraints->pathLenConstraint;
#endif  // OSS_CRYPT_ASN1
        }

        pbExtra = (BYTE *) pInfo + sizeof(CERT_BASIC_CONSTRAINTS_INFO);
    }

    Asn1X509GetBit(&pBasicConstraints->subjectType, dwFlags,
        &pInfo->SubjectType, &pbExtra, &lRemainExtra);

    if (pBasicConstraints->bit_mask & subtreesConstraint_present) {
        LONG lAlignExtra;
        DWORD cSubtrees;
        PCERT_NAME_BLOB pSubtrees;
        NOCOPYANY *pAsn1Subtrees;

        cSubtrees = pBasicConstraints->subtreesConstraint.count;
        lAlignExtra = INFO_LEN_ALIGN(cSubtrees * sizeof(CERT_NAME_BLOB));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cSubtreesConstraint = cSubtrees;
            pSubtrees = (PCERT_NAME_BLOB) pbExtra;
            pInfo->rgSubtreesConstraint = pSubtrees;
            pbExtra += lAlignExtra;
        } else
            pSubtrees = NULL;

        pAsn1Subtrees = pBasicConstraints->subtreesConstraint.value;
        for ( ; cSubtrees > 0; cSubtrees--, pSubtrees++, pAsn1Subtrees++)
            Asn1X509GetAny(pAsn1Subtrees, dwFlags,
                pSubtrees, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509BasicConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        BasicConstraints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BasicConstraintsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints #2 Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraints2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BasicConstraints2 Asn1Info;
    memset(&Asn1Info, 0, sizeof(Asn1Info));

    if (pInfo->fCA) {
        Asn1Info.cA = TRUE;
        Asn1Info.bit_mask |= cA_present;
    }
    if (pInfo->fPathLenConstraint) {
#ifdef OSS_CRYPT_ASN1
        Asn1Info.BasicConstraints2_pathLenConstraint =
#else
        Asn1Info.pathLenConstraint =
#endif  // OSS_CRYPT_ASN1
            pInfo->dwPathLenConstraint;
        Asn1Info.bit_mask |= BasicConstraints2_pathLenConstraint_present;
    }

    return Asn1InfoEncodeEx(
        BasicConstraints2_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints #2 Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraints2DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BasicConstraints2 *pAsn1Info = (BasicConstraints2 *) pvAsn1Info;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo =
        (PCERT_BASIC_CONSTRAINTS2_INFO) pvStructInfo;

    *plRemainExtra -= sizeof(CERT_BASIC_CONSTRAINTS2_INFO);
    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CERT_BASIC_CONSTRAINTS2_INFO));

        if (pAsn1Info->bit_mask & cA_present)
            pInfo->fCA = (BOOLEAN) pAsn1Info->cA;

        if (pAsn1Info->bit_mask &
                BasicConstraints2_pathLenConstraint_present) {
            pInfo->fPathLenConstraint = TRUE;
            pInfo->dwPathLenConstraint =
#ifdef OSS_CRYPT_ASN1
                pAsn1Info->BasicConstraints2_pathLenConstraint;
#else
                pAsn1Info->pathLenConstraint;
#endif  // OSS_CRYPT_ASN1
        }
    }
    return TRUE;
}

BOOL WINAPI Asn1X509BasicConstraints2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        BasicConstraints2_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BasicConstraints2DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Bits Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BITSTRING Asn1Info;

    Asn1X509SetBit(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        Bits_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Bits Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BITSTRING *pAsn1Info = (BITSTRING *) pvAsn1Info;
    PCRYPT_BIT_BLOB pInfo = (PCRYPT_BIT_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_BIT_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_BIT_BLOB);

    Asn1X509GetBit(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509BitsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Bits_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BitsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Bits Without Trailing Zeroes Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsWithoutTrailingZeroesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BITSTRING Asn1Info;

    Asn1X509SetBitWithoutTrailingZeroes(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        Bits_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Certificate Policies Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICIES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cPolicyInfo;

    CertificatePolicies Asn1Info;
    memset(&Asn1Info, 0, sizeof(Asn1Info));

    cPolicyInfo = pInfo->cPolicyInfo;
    if (cPolicyInfo) {
        PCERT_POLICY_INFO pPolicyInfo = pInfo->rgPolicyInfo;
        PolicyInformation *pAsn1PolicyInfo =
            (PolicyInformation *) PkiZeroAlloc(
                cPolicyInfo * sizeof(PolicyInformation));
        if (pAsn1PolicyInfo == NULL) goto ErrorReturn;
        Asn1Info.count = cPolicyInfo;
        Asn1Info.value = pAsn1PolicyInfo;

        for ( ; cPolicyInfo > 0;
                            cPolicyInfo--, pPolicyInfo++, pAsn1PolicyInfo++) {
            DWORD cQualifier = pPolicyInfo->cPolicyQualifier;
            if (!Asn1X509SetEncodedObjId(pPolicyInfo->pszPolicyIdentifier,
                    &pAsn1PolicyInfo->policyIdentifier))
                    goto ErrorReturn;
            if (cQualifier > 0) {
                PCERT_POLICY_QUALIFIER_INFO pQualifier =
                    pPolicyInfo->rgPolicyQualifier;
                PolicyQualifierInfo *pAsn1Qualifier =
                    (PolicyQualifierInfo *) PkiZeroAlloc(
                        cQualifier * sizeof(PolicyQualifierInfo));
                if (pAsn1Qualifier == NULL) goto ErrorReturn;
                pAsn1PolicyInfo->policyQualifiers.count = cQualifier;
                pAsn1PolicyInfo->policyQualifiers.value = pAsn1Qualifier;
                pAsn1PolicyInfo->bit_mask |= policyQualifiers_present;

                for ( ; cQualifier > 0;
                            cQualifier--, pQualifier++, pAsn1Qualifier++) {
                    if (!Asn1X509SetEncodedObjId(pQualifier->pszPolicyQualifierId,
                            &pAsn1Qualifier->policyQualifierId))
                        goto ErrorReturn;

                    if (pQualifier->Qualifier.cbData) {
                        Asn1X509SetAny(&pQualifier->Qualifier,
                            &pAsn1Qualifier->qualifier);
                        pAsn1Qualifier->bit_mask |= qualifier_present;
                    }
                }
            }
        }
    }

    fResult = Asn1InfoEncodeEx(
        CertificatePolicies_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1Info.value) {
        cPolicyInfo = Asn1Info.count;
        PolicyInformation *pAsn1PolicyInfo = Asn1Info.value;
        for ( ; cPolicyInfo > 0; cPolicyInfo--, pAsn1PolicyInfo++)
            if (pAsn1PolicyInfo->policyQualifiers.value)
                PkiFree(pAsn1PolicyInfo->policyQualifiers.value);
        PkiFree(Asn1Info.value);
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Certificate Policies Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificatePolicies *pAsn1Info = (CertificatePolicies *) pvAsn1Info;
    PCERT_POLICIES_INFO pInfo = (PCERT_POLICIES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    DWORD cPolicyInfo;

    lRemainExtra -= sizeof(CERT_POLICIES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICIES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICIES_INFO);
    }

    cPolicyInfo = pAsn1Info->count;
    if (cPolicyInfo) {
        LONG lAlignExtra;
        PCERT_POLICY_INFO pPolicyInfo;
        PolicyInformation *pAsn1PolicyInfo;

        lAlignExtra = INFO_LEN_ALIGN(cPolicyInfo * sizeof(CERT_POLICY_INFO));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cPolicyInfo = cPolicyInfo;
            pPolicyInfo = (PCERT_POLICY_INFO) pbExtra;
            pInfo->rgPolicyInfo = pPolicyInfo;
            memset(pPolicyInfo, 0, cPolicyInfo * sizeof(CERT_POLICY_INFO));
            pbExtra += lAlignExtra;
        } else
            pPolicyInfo = NULL;

        pAsn1PolicyInfo = pAsn1Info->value;
        for ( ; cPolicyInfo > 0;
                            cPolicyInfo--, pPolicyInfo++, pAsn1PolicyInfo++) {
            DWORD cQualifier;

            // check to see if there is a policy identifier
            if (pAsn1PolicyInfo->policyIdentifier.length != 0) {
                Asn1X509GetEncodedObjId(&pAsn1PolicyInfo->policyIdentifier, dwFlags,
                &pPolicyInfo->pszPolicyIdentifier, &pbExtra, &lRemainExtra);
            }
            else {
                lAlignExtra = INFO_LEN_ALIGN(strlen("")+1);
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0) {
                    pPolicyInfo->pszPolicyIdentifier = (LPSTR) pbExtra;
                    strcpy(pPolicyInfo->pszPolicyIdentifier, "");
                    pbExtra += lAlignExtra;
                }
            }
            
            cQualifier = pAsn1PolicyInfo->bit_mask & policyQualifiers_present ?
                pAsn1PolicyInfo->policyQualifiers.count : 0;
            if (cQualifier > 0) {
                PCERT_POLICY_QUALIFIER_INFO pQualifier;
                PolicyQualifierInfo *pAsn1Qualifier;

                lAlignExtra = INFO_LEN_ALIGN(cQualifier *
                    sizeof(CERT_POLICY_QUALIFIER_INFO));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0) {
                    pPolicyInfo->cPolicyQualifier = cQualifier;
                    pQualifier = (PCERT_POLICY_QUALIFIER_INFO) pbExtra;
                    pPolicyInfo->rgPolicyQualifier = pQualifier;
                    memset(pQualifier, 0,
                        cQualifier * sizeof(CERT_POLICY_QUALIFIER_INFO));
                    pbExtra += lAlignExtra;
                } else
                    pQualifier = NULL;

                pAsn1Qualifier = pAsn1PolicyInfo->policyQualifiers.value;
                for ( ; cQualifier > 0;
                            cQualifier--, pQualifier++, pAsn1Qualifier++) {
                    Asn1X509GetEncodedObjId(&pAsn1Qualifier->policyQualifierId, dwFlags,
                        &pQualifier->pszPolicyQualifierId,
                        &pbExtra, &lRemainExtra);
                    if (pAsn1Qualifier->bit_mask & qualifier_present)
                        Asn1X509GetAny(&pAsn1Qualifier->qualifier, dwFlags,
                            &pQualifier->Qualifier, &pbExtra, &lRemainExtra);
                }
            }
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertPoliciesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    CertificatePolicies *pAsn1Info = NULL;
    CertificatePolicies95 *pAsn1Info95 = NULL;
    PolicyInformation *pPolicyInformation;
    CertificatePolicies certificatePolicies;
    DWORD i;

    if (!Asn1InfoDecodeAndAlloc(
            CertificatePolicies_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pAsn1Info))
    {
        // try to decode it as the old style
        if (!Asn1InfoDecodeAndAlloc(
                CertificatePolicies95_PDU,
                pbEncoded,
                cbEncoded,
                (void **) &pAsn1Info95))
             goto ErrorReturn;

        // that decode worked, so alloc some memory, fix up some pointers
        // and role through the rest of the routine per usual
        certificatePolicies.count = pAsn1Info95->count;
        if (NULL == (pPolicyInformation = 
                    (PolicyInformation *) PkiNonzeroAlloc(pAsn1Info95->count * sizeof(PolicyInformation))))
            goto ErrorReturn;

        certificatePolicies.value = pPolicyInformation;
        
        for (i=0; i<pAsn1Info95->count; i++)
        {
            pPolicyInformation[i].bit_mask = policyQualifiers_present;
            pPolicyInformation[i].policyIdentifier.length = 0;
            pPolicyInformation[i].policyIdentifier.value = NULL;
            pPolicyInformation[i].policyQualifiers.count = pAsn1Info95->value[i].count;
            pPolicyInformation[i].policyQualifiers.value = pAsn1Info95->value[i].value;
        }
            
        pAsn1Info = &certificatePolicies;
    }

    fResult = PkiAsn1AllocStructInfoEx(
        pAsn1Info,
        dwFlags,
        pDecodePara,
        Asn1X509CertPoliciesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    if (pAsn1Info95)
    {
        if (pPolicyInformation)
            PkiFree(pPolicyInformation);
        Asn1InfoFree(CertificatePolicies95_PDU, pAsn1Info95);
    }
    else
    {
        Asn1InfoFree(CertificatePolicies_PDU, pAsn1Info);
    }
    
    return fResult;

ErrorReturn:
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Policy Information 95 - Qualifier 1 decode
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    VerisignQualifier1 *pAsn1Info = (VerisignQualifier1 *) pvAsn1Info; 
    PCERT_POLICY95_QUALIFIER1 pInfo =
        (PCERT_POLICY95_QUALIFIER1) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD i;
    
    lRemainExtra -= sizeof(CERT_POLICY95_QUALIFIER1);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICY95_QUALIFIER1));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICY95_QUALIFIER1);
    }

    if (
#ifndef OSS_CRYPT_ASN1
            0 != (pAsn1Info->bit_mask & practicesReference_present) &&
#endif  // OSS_CRYPT_ASN1
            pAsn1Info->practicesReference != NULL)
    {
        lAlignExtra = INFO_LEN_ALIGN((strlen(pAsn1Info->practicesReference)+1) * 2);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->pszPracticesReference = (LPWSTR) pbExtra;
            MultiByteToWideChar(CP_ACP, 
                                0, 
                                pAsn1Info->practicesReference, 
                                -1, 
                                pInfo->pszPracticesReference,
                                lAlignExtra);
            pbExtra += lAlignExtra;
        }
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszPracticesReference = NULL;
    }
    
    if (pAsn1Info->bit_mask & noticeId_present)
    {
        Asn1X509GetEncodedObjId(&pAsn1Info->noticeId, dwFlags,
                        &pInfo->pszNoticeIdentifier,
                        &pbExtra, &lRemainExtra);  
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszNoticeIdentifier = NULL;
    }

    if (pAsn1Info->bit_mask & nsiNoticeId_present)
    {
        Asn1X509GetEncodedObjId(&pAsn1Info->nsiNoticeId, dwFlags,
                        &pInfo->pszNSINoticeIdentifier,
                        &pbExtra, &lRemainExtra);  
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszNSINoticeIdentifier = NULL;
    }

    if (pAsn1Info->bit_mask & cpsURLs_present)
    {
        lAlignExtra = INFO_LEN_ALIGN(pAsn1Info->cpsURLs.count * sizeof(CPS_URLS));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) { 
            pInfo->rgCPSURLs = (CPS_URLS *) pbExtra;
            memset(pInfo->rgCPSURLs, 0, lAlignExtra);
            pInfo->cCPSURLs = pAsn1Info->cpsURLs.count;   
            pbExtra += lAlignExtra;
        }
        
        for (i=0; i<pAsn1Info->cpsURLs.count; i++)
        {
            lAlignExtra = INFO_LEN_ALIGN((strlen(pAsn1Info->cpsURLs.value[i].url)+1) * 2);
            lRemainExtra -= lAlignExtra;
            if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pszURL = (LPWSTR) pbExtra;
                MultiByteToWideChar(CP_ACP, 
                                    0, 
                                    pAsn1Info->cpsURLs.value[i].url, 
                                    -1, 
                                    pInfo->rgCPSURLs[i].pszURL,
                                    lAlignExtra);
                pbExtra += lAlignExtra;
            }

            if (pAsn1Info->cpsURLs.value[i].bit_mask & digestAlgorithmId_present)
            {
                lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_ALGORITHM_IDENTIFIER));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0)
                {
                    pInfo->rgCPSURLs[i].pAlgorithm = (CRYPT_ALGORITHM_IDENTIFIER *) pbExtra;
                    memset(pInfo->rgCPSURLs[i].pAlgorithm, 0, lAlignExtra);
                    pbExtra += lAlignExtra;
                }

                Asn1X509GetAlgorithm(
                        &(pAsn1Info->cpsURLs.value[i].digestAlgorithmId),
                        dwFlags,
                        pInfo->rgCPSURLs[i].pAlgorithm,
                        &pbExtra,
                        &lRemainExtra);
            }
            else if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pAlgorithm = NULL;
            }

            if (pAsn1Info->cpsURLs.value[i].bit_mask & digest_present)
            {
                lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_DATA_BLOB));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0)
                {
                    pInfo->rgCPSURLs[i].pDigest = (CRYPT_DATA_BLOB *) pbExtra;
                    memset(pInfo->rgCPSURLs[i].pAlgorithm, 0, lAlignExtra);
                    pbExtra += lAlignExtra;
                }   

                Asn1X509GetOctetString(
                        &(pAsn1Info->cpsURLs.value[i].digest),
                        dwFlags,
                        pInfo->rgCPSURLs[i].pDigest,
                        &pbExtra,
                        &lRemainExtra);
            }
            else if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pDigest = NULL;
            }
        }   
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->rgCPSURLs = NULL;
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        VerisignQualifier1_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CertPoliciesQualifier1DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Authority Information Access Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityInfoAccessEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AuthorityInfoAccess Asn1Info;
    DWORD cAccDescr;
    AccessDescription *pAsn1AccDescr;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));

    cAccDescr = pInfo->cAccDescr;
    if (cAccDescr > 0) {
        pAsn1AccDescr =
            (AccessDescription *) PkiZeroAlloc(cAccDescr *
                sizeof(AccessDescription));
        if (pAsn1AccDescr == NULL)
            goto ErrorReturn;
        Asn1Info.count = cAccDescr;
        Asn1Info.value = pAsn1AccDescr;

        if (!Asn1X509SetAccessDescriptions(
                cAccDescr,
                pInfo->rgAccDescr,
                pAsn1AccDescr,
                &dwErrLocation))
            goto AccessDescriptionsError;

    } else
        pAsn1AccDescr = NULL;

    fResult = Asn1InfoEncodeEx(
        AuthorityInfoAccess_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

AccessDescriptionsError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pAsn1AccDescr) {
        Asn1X509FreeAccessDescriptions(cAccDescr, pAsn1AccDescr);
        PkiFree(pAsn1AccDescr);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Information Access Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AuthorityInfoAccess *pAsn1 = (AuthorityInfoAccess *) pvAsn1Info;
    PCERT_AUTHORITY_INFO_ACCESS pInfo =
        (PCERT_AUTHORITY_INFO_ACCESS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD cAccDescr;
    PCERT_ACCESS_DESCRIPTION pAccDescr;

    cAccDescr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cAccDescr * sizeof(CERT_ACCESS_DESCRIPTION));

    lRemainExtra -= sizeof(CERT_AUTHORITY_INFO_ACCESS) + lAlignExtra;
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pAccDescr = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_INFO_ACCESS);
        pAccDescr = (PCERT_ACCESS_DESCRIPTION) pbExtra;
        pInfo->cAccDescr = cAccDescr;
        pInfo->rgAccDescr = pAccDescr;
        pbExtra += lAlignExtra;
    }

    if (!Asn1X509GetAccessDescriptions(
            cAccDescr,
            pAsn1->value,
            dwFlags,
            pAccDescr,
            &pbExtra,
            &lRemainExtra
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityInfoAccess_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityInfoAccessDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CRL Distribution Points Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CRLDistributionPoints Asn1Info;
    DistributionPoint *pAsn1DistPoint;
    PCRL_DIST_POINT pDistPoint;
    DWORD cDistPoint;
    DWORD i;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (0 == (cDistPoint = pInfo->cDistPoint))
        goto InvalidArg;

    if (NULL == (pAsn1DistPoint = (DistributionPoint *) PkiZeroAlloc(
            cDistPoint * sizeof(DistributionPoint))))
        goto ErrorReturn;
    Asn1Info.count = cDistPoint;
    Asn1Info.value = pAsn1DistPoint;

    pDistPoint = pInfo->rgDistPoint;
    for (i = 0; i < cDistPoint; i++, pDistPoint++, pAsn1DistPoint++) {
        PCRL_DIST_POINT_NAME pDistPointName =
            &pDistPoint->DistPointName;
        if (CRL_DIST_POINT_NO_NAME !=
                pDistPointName->dwDistPointNameChoice) {
            DistributionPointName *pAsn1DistPointName =
                &pAsn1DistPoint->distributionPoint;

            pAsn1DistPoint->bit_mask |= distributionPoint_present;
            pAsn1DistPointName->choice = (unsigned short)
                pDistPointName->dwDistPointNameChoice;
            
            assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
            assert(nameRelativeToCRLIssuer_chosen ==
                CRL_DIST_POINT_ISSUER_RDN_NAME);

            switch (pDistPointName->dwDistPointNameChoice) {
                case CRL_DIST_POINT_FULL_NAME:
                    if (!Asn1X509SetAltNames(
                            &pDistPointName->FullName,
                            &pAsn1DistPointName->u.fullName, i, &dwErrLocation))
                        goto AltNamesError;
                    break;
                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                default:
                    goto InvalidArg;
            }
        }

        if (pDistPoint->ReasonFlags.cbData) {
            pAsn1DistPoint->bit_mask |= reasons_present;
            Asn1X509SetBitWithoutTrailingZeroes(&pDistPoint->ReasonFlags,
                &pAsn1DistPoint->reasons);
        }

        if (pDistPoint->CRLIssuer.cAltEntry) {
            pAsn1DistPoint->bit_mask |= cRLIssuer_present;
            if (!Asn1X509SetAltNames(
                    &pDistPoint->CRLIssuer,
                    &pAsn1DistPoint->cRLIssuer,
                    (CRL_DIST_POINT_ERR_CRL_ISSUER_BIT >> 24) | i,
                    &dwErrLocation))
                goto AltNamesError;
        }
    }

    fResult = Asn1InfoEncodeEx(
        CRLDistributionPoints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;


AltNamesError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    pAsn1DistPoint = Asn1Info.value;
    if (pAsn1DistPoint) {
        cDistPoint = Asn1Info.count;
        pDistPoint = pInfo->rgDistPoint;
        for ( ; cDistPoint > 0; cDistPoint--, pDistPoint++, pAsn1DistPoint++) {
            DistributionPointName *pAsn1DistPointName =
                &pAsn1DistPoint->distributionPoint;

            switch (pAsn1DistPointName->choice) {
                case CRL_DIST_POINT_FULL_NAME:
                    Asn1X509FreeAltNames(&pAsn1DistPointName->u.fullName);
                    break;
                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                default:
                    break;
            }

            Asn1X509FreeAltNames(&pAsn1DistPoint->cRLIssuer);
        }
        PkiFree(Asn1Info.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  CRL Distribution Points Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlDistPointsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CRLDistributionPoints *pAsn1 = (CRLDistributionPoints *) pvAsn1Info;
    PCRL_DIST_POINTS_INFO pInfo = (PCRL_DIST_POINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRL_DIST_POINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRL_DIST_POINTS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CRL_DIST_POINTS_INFO);
    }

    if (pAsn1->count) {
        DWORD cDistPoint = pAsn1->count;
        DistributionPoint *pAsn1DistPoint = pAsn1->value;
        PCRL_DIST_POINT pDistPoint;

        lAlignExtra = INFO_LEN_ALIGN(cDistPoint * sizeof(CRL_DIST_POINT));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pDistPoint = (PCRL_DIST_POINT) pbExtra;
            memset(pDistPoint, 0, cDistPoint * sizeof(CRL_DIST_POINT));
            pInfo->cDistPoint = cDistPoint;
            pInfo->rgDistPoint = pDistPoint;
            pbExtra += lAlignExtra;
        } else
            pDistPoint = NULL;

        for ( ; cDistPoint > 0; cDistPoint--, pAsn1DistPoint++, pDistPoint++) {
            if (pAsn1DistPoint->bit_mask & distributionPoint_present) {
                DistributionPointName *pAsn1DistPointName =
                    &pAsn1DistPoint->distributionPoint;
                DWORD dwDistPointNameChoice = pAsn1DistPointName->choice;
                PCRL_DIST_POINT_NAME pDistPointName;

                if (lRemainExtra >= 0) {
                    pDistPointName = &pDistPoint->DistPointName;
                    pDistPointName->dwDistPointNameChoice =
                        dwDistPointNameChoice;
                } else
                    pDistPointName = NULL;

                assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
                assert(nameRelativeToCRLIssuer_chosen ==
                    CRL_DIST_POINT_ISSUER_RDN_NAME);

                switch (dwDistPointNameChoice) {
                    case CRL_DIST_POINT_FULL_NAME:
                        if (!Asn1X509GetAltNames(&pAsn1DistPointName->u.fullName,
                                dwFlags, &pDistPointName->FullName,
                                &pbExtra, &lRemainExtra))
                            goto ErrorReturn;
                        break;
                    case CRL_DIST_POINT_ISSUER_RDN_NAME:
                        break;
                    default:
                        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
                        goto ErrorReturn;
                }
            }

            if (pAsn1DistPoint->bit_mask & reasons_present)
                Asn1X509GetBit(&pAsn1DistPoint->reasons, dwFlags,
                    &pDistPoint->ReasonFlags, &pbExtra, &lRemainExtra);

            if (pAsn1DistPoint->bit_mask & cRLIssuer_present) {
                if (!Asn1X509GetAltNames(&pAsn1DistPoint->cRLIssuer, dwFlags,
                        &pDistPoint->CRLIssuer, &pbExtra, &lRemainExtra))
                    goto ErrorReturn;
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509CrlDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CRLDistributionPoints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CrlDistPointsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Integer Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509IntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    int Asn1Info = *pInfo;

    return Asn1InfoEncodeEx(
        IntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Integer Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509IntegerDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    int *pAsn1Info = (int *) pvAsn1Info;
    int *pInfo = (int *) pvStructInfo;

    *plRemainExtra -= sizeof(int);
    if (*plRemainExtra >= 0)
        *pInfo = *pAsn1Info;
    return TRUE;
}

BOOL WINAPI Asn1X509IntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        IntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509IntegerDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  MultiByte Integer Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteIntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_INTEGER_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    HUGEINTEGER Asn1Info;


    if (!Asn1X509SetHugeInteger(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        HugeIntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeHugeInteger(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  MultiByte Integer Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteIntegerDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    HUGEINTEGER *pAsn1Info = (HUGEINTEGER *) pvAsn1Info;
    PCRYPT_INTEGER_BLOB pInfo = (PCRYPT_INTEGER_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_INTEGER_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_INTEGER_BLOB);

    Asn1X509GetHugeInteger(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509MultiByteIntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        HugeIntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509MultiByteIntegerDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  MultiByte UINT Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteUINTEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_UINT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    HUGEINTEGER Asn1Info;

    if (!Asn1X509SetHugeUINT(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        HugeIntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeHugeUINT(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  MultiByte UINT Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteUINTDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    HUGEINTEGER *pAsn1Info = (HUGEINTEGER *) pvAsn1Info;
    PCRYPT_UINT_BLOB pInfo = (PCRYPT_UINT_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_UINT_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_UINT_BLOB);

    Asn1X509GetHugeUINT(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509MultiByteUINTDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        HugeIntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509MultiByteUINTDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DSS Parameters Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DSS_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DSSParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->q, &Asn1Info.q))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        DSSParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.q);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    return fResult;
}

//+-------------------------------------------------------------------------
//  DSS Parameters Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DSSParameters *pAsn1Info = (DSSParameters *) pvAsn1Info;
    PCERT_DSS_PARAMETERS pInfo = (PCERT_DSS_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DSS_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DSS_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->q, dwFlags,
        &pInfo->q, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509DSSParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        DSSParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DSSParametersDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DSS Signature Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSSignatureEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgbR[1 + CERT_DSS_R_LEN];
    BYTE rgbS[1 + CERT_DSS_S_LEN];
    DSSSignature Asn1Signature;
    DWORD i;

    // Treat the r and s components of the DSS signature as being unsigned.
    // Also need to swap before doing the encode.
    rgbR[0] = 0;
    for (i = 0; i < CERT_DSS_R_LEN; i++)
        rgbR[(1 + CERT_DSS_R_LEN - 1) - i] = rgbSignature[i];
    Asn1Signature.r.length = sizeof(rgbR);
    Asn1Signature.r.value = rgbR;

    rgbS[0] = 0;
    for (i = 0; i < CERT_DSS_S_LEN; i++)
        rgbS[(1 + CERT_DSS_S_LEN - 1) - i] =
            rgbSignature[CERT_DSS_R_LEN + i];
    Asn1Signature.s.length = sizeof(rgbS);
    Asn1Signature.s.value = rgbS;

    return Asn1InfoEncodeEx(
        DSSSignature_PDU,
        &Asn1Signature,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  DSS Signature Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSSignatureDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    DSSSignature *pAsn1Signature = (DSSSignature *) pvAsn1Info;
//  BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
    BYTE *rgbSignature = (BYTE *) pvStructInfo;
    DWORD cb;
    BYTE *pb;
    DWORD i;

    *plRemainExtra -= CERT_DSS_SIGNATURE_LEN;
    if (*plRemainExtra >= 0) {
        memset(rgbSignature, 0, CERT_DSS_SIGNATURE_LEN);

        // Strip off a leading 0 byte. Byte reverse while copying
        cb = pAsn1Signature->r.length;
        pb = pAsn1Signature->r.value;
        if (cb > 1 && *pb == 0) {
            pb++;
            cb--;
        }
        if (0 == cb || cb > CERT_DSS_R_LEN)
            goto DecodeError;
        for (i = 0; i < cb; i++)
            rgbSignature[i] = pb[cb - 1 - i];

        // Strip off a leading 0 byte. Byte reverse while copying
        cb = pAsn1Signature->s.length;
        pb = pAsn1Signature->s.value;
        if (cb > 1 && *pb == 0) {
            pb++;
            cb--;
        }
        if (0 == cb || cb > CERT_DSS_S_LEN)
            goto DecodeError;
        for (i = 0; i < cb; i++)
            rgbSignature[CERT_DSS_R_LEN + i] = pb[cb - 1 - i];
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509DSSSignatureDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        DSSSignature_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DSSSignatureDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DH Parameters Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DHParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        DHParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    return fResult;
}

//+-------------------------------------------------------------------------
//  DH Parameters Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DHParameters *pAsn1Info = (DHParameters *) pvAsn1Info;
    PCERT_DH_PARAMETERS pInfo = (PCERT_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DH_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  DH Parameters Decode (ASN1) New Style X942
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersX942DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    X942DhParameters *pAsn1Info = (X942DhParameters *) pvAsn1Info;
    PCERT_DH_PARAMETERS pInfo = (PCERT_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DH_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509DHParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;

    fResult = Asn1InfoDecodeAndAllocEx(
        DHParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DHParametersDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );

    if (!fResult && 0 == *pcbStructInfo) {
        // Try to decode as new style X942 parameters

        DWORD dwErr = GetLastError();

        fResult = Asn1InfoDecodeAndAllocEx(
            X942DhParameters_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X509DHParametersX942DecodeExCallback,
            pvStructInfo,
            pcbStructInfo
            );
        if (!fResult && 0 == *pcbStructInfo)
            SetLastError(dwErr);
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_X942_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    X942DhParameters Asn1Info;

    if (0 == pInfo->q.cbData) {
        CERT_DH_PARAMETERS Pkcs3Info;

        Pkcs3Info.p = pInfo->p;
        Pkcs3Info.g = pInfo->g;
        return Asn1X509DHParametersEncodeEx(
            dwCertEncodingType,
            lpszStructType,
            &Pkcs3Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    }

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->q, &Asn1Info.q))
        goto ErrorReturn;

    if (pInfo->j.cbData) {
        if (!Asn1X509SetHugeUINT(&pInfo->j, &Asn1Info.j))
            goto ErrorReturn;
        Asn1Info.bit_mask |= j_present;
    }

    if (pInfo->pValidationParams) {
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams =
            pInfo->pValidationParams;

        Asn1X509SetBit(&pValidationParams->seed,
            &Asn1Info.validationParams.seed);
        Asn1Info.validationParams.pgenCounter = pValidationParams->pgenCounter;
        Asn1Info.bit_mask |= validationParams_present;
    }

    fResult = Asn1InfoEncodeEx(
        X942DhParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    Asn1X509FreeHugeUINT(&Asn1Info.q);
    Asn1X509FreeHugeUINT(&Asn1Info.j);
    return fResult;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    X942DhParameters *pAsn1Info = (X942DhParameters *) pvAsn1Info;
    PCERT_X942_DH_PARAMETERS pInfo = (PCERT_X942_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_X942_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_X942_DH_PARAMETERS));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_X942_DH_PARAMETERS);
    }

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->q, dwFlags,
        &pInfo->q, &pbExtra, &lRemainExtra);

    if (pAsn1Info->bit_mask & j_present)
        Asn1X509GetHugeUINT(&pAsn1Info->j, dwFlags,
            &pInfo->j, &pbExtra, &lRemainExtra);

    if (pAsn1Info->bit_mask & validationParams_present) {
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;

        lRemainExtra -= sizeof(CERT_X942_DH_VALIDATION_PARAMS);

        if (lRemainExtra < 0) {
            pValidationParams = NULL;
        } else {
            pValidationParams = (PCERT_X942_DH_VALIDATION_PARAMS) pbExtra;
            pbExtra += sizeof(CERT_X942_DH_VALIDATION_PARAMS);
            pValidationParams->pgenCounter =
                pAsn1Info->validationParams.pgenCounter;
        }

        Asn1X509GetBit(&pAsn1Info->validationParams.seed, dwFlags,
            &pValidationParams->seed, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Decode (ASN1) Old Style Pkcs #3
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersPkcs3DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DHParameters *pAsn1Info = (DHParameters *) pvAsn1Info;
    PCERT_X942_DH_PARAMETERS pInfo = (PCERT_X942_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_X942_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_X942_DH_PARAMETERS));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_X942_DH_PARAMETERS);
    }
    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X942DhParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;

    fResult = Asn1InfoDecodeAndAllocEx(
        X942DhParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X942DhParametersDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );

    if (!fResult && 0 == *pcbStructInfo) {
        // Try to decode as old style PKCS #3 parameters

        DWORD dwErr = GetLastError();

        fResult = Asn1InfoDecodeAndAllocEx(
            DHParameters_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X942DhParametersPkcs3DecodeExCallback,
            pvStructInfo,
            pcbStructInfo
            );
        if (!fResult && 0 == *pcbStructInfo)
            SetLastError(dwErr);
    }

    return fResult;
}


//+-------------------------------------------------------------------------
//  RC2 CBC Parameters Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RC2CBCParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_RC2_CBC_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    RC2CBCParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.version = pInfo->dwVersion;
    if (pInfo->fIV) {
        Asn1Info.bit_mask |= iv_present;
        Asn1Info.iv.length = sizeof(pInfo->rgbIV);
        Asn1Info.iv.value = pInfo->rgbIV;
    }

    return Asn1InfoEncodeEx(
        RC2CBCParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  RC2 CBC Parameters Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RC2CBCParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    RC2CBCParameters *pAsn1Info = (RC2CBCParameters *) pvAsn1Info;
    PCRYPT_RC2_CBC_PARAMETERS pInfo = (PCRYPT_RC2_CBC_PARAMETERS) pvStructInfo;

    *plRemainExtra -= sizeof(CRYPT_RC2_CBC_PARAMETERS);
    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CRYPT_RC2_CBC_PARAMETERS));
        pInfo->dwVersion = pAsn1Info->version;
        if (pAsn1Info->bit_mask & iv_present) {
            pInfo->fIV = TRUE;
            if (pAsn1Info->iv.length != sizeof(pInfo->rgbIV))
                goto DecodeError;
            memcpy(pInfo->rgbIV, pAsn1Info->iv.value, sizeof(pInfo->rgbIV));
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1RC2CBCParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        RC2CBCParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1RC2CBCParametersDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  SMIME Capabilities Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1SMIMECapabilitiesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SMIME_CAPABILITIES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SMIMECapabilities Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (0 != pInfo->cCapability) {
        DWORD cCap = pInfo->cCapability;
        PCRYPT_SMIME_CAPABILITY pCap = pInfo->rgCapability;
        SMIMECapability *pAsn1Cap;
        
        if (NULL == (pAsn1Cap = (SMIMECapability *) PkiZeroAlloc(
                cCap * sizeof(SMIMECapability))))
            goto ErrorReturn;

        Asn1Info.count = cCap;
        Asn1Info.value = pAsn1Cap;
        for ( ; cCap > 0; cCap--, pCap++, pAsn1Cap++) {
            if (!Asn1X509SetEncodedObjId(pCap->pszObjId, &pAsn1Cap->capabilityID))
                goto ErrorReturn;
            if (pCap->Parameters.cbData) {
                pAsn1Cap->bit_mask |= smimeParameters_present;
                Asn1X509SetAny(&pCap->Parameters,
                    &pAsn1Cap->smimeParameters);
            }
        }
    }

    fResult = Asn1InfoEncodeEx(
        SMIMECapabilities_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    PkiFree(Asn1Info.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SMIME Capabilities Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1SMIMECapabilitiesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SMIMECapabilities *pAsn1Info = (SMIMECapabilities *) pvAsn1Info;
    PCRYPT_SMIME_CAPABILITIES pInfo = (PCRYPT_SMIME_CAPABILITIES) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD cCap;
    SMIMECapability *pAsn1Cap;
    PCRYPT_SMIME_CAPABILITY pCap;

    cCap = pAsn1Info->count;
    lAlignExtra = cCap * sizeof(CRYPT_SMIME_CAPABILITY);

    lRemainExtra -= sizeof(CRYPT_SMIME_CAPABILITIES) + lAlignExtra;
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pCap = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_SMIME_CAPABILITIES);
        pCap = (PCRYPT_SMIME_CAPABILITY) pbExtra;
        pInfo->cCapability = cCap;
        pInfo->rgCapability = pCap;
        if (lAlignExtra) {
            memset(pbExtra, 0, lAlignExtra);
            pbExtra += lAlignExtra;
        }
    }

    pAsn1Cap = pAsn1Info->value;
    for ( ; cCap > 0; cCap--, pAsn1Cap++, pCap++) {
        Asn1X509GetEncodedObjId(&pAsn1Cap->capabilityID, dwFlags, &pCap->pszObjId,
            &pbExtra, &lRemainExtra);
        if (pAsn1Cap->bit_mask & smimeParameters_present)
            Asn1X509GetAny(&pAsn1Cap->smimeParameters, dwFlags,
                &pCap->Parameters, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1SMIMECapabilitiesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SMIMECapabilities_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1SMIMECapabilitiesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Enumerated Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509EnumeratedEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    EnumeratedType Asn1Info = (EnumeratedType) *pInfo;

    return Asn1InfoEncodeEx(
        EnumeratedType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Enumerated Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509EnumeratedDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnumeratedType *pAsn1Info = (EnumeratedType *) pvAsn1Info;
    int *pInfo = (int *) pvStructInfo;

    *plRemainExtra -= sizeof(int);
    if (*plRemainExtra >= 0)
        *pInfo = *pAsn1Info;
    return TRUE;
}

BOOL WINAPI Asn1X509EnumeratedDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnumeratedType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509EnumeratedDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Octet String Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509OctetStringEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    OCTETSTRING Asn1Info;

    Asn1X509SetOctetString(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        OctetStringType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
// Octet String Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509OctetStringDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    OCTETSTRING *pAsn1Info = (OCTETSTRING *) pvAsn1Info;
    PCRYPT_DATA_BLOB pInfo = (PCRYPT_DATA_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_DATA_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_DATA_BLOB);

    Asn1X509GetOctetString(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509OctetStringDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        OctetStringType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509OctetStringDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  ChoiceOfTime Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ChoiceOfTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ChoiceOfTime Asn1Info;

    if (!PkiAsn1ToChoiceOfTime(pInfo,
            &Asn1Info.choice,
            &Asn1Info.u.generalTime ,
            &Asn1Info.u.utcTime
            )) {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    return Asn1InfoEncodeEx(
        ChoiceOfTime_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  ChoiceOfTime Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ChoiceOfTimeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    ChoiceOfTime *pAsn1Info = (ChoiceOfTime *) pvAsn1Info;
    LPFILETIME pInfo = (LPFILETIME) pvStructInfo;

    *plRemainExtra -= sizeof(FILETIME);
    if (*plRemainExtra >= 0) {
        if (!PkiAsn1FromChoiceOfTime(pAsn1Info->choice,
                &pAsn1Info->u.generalTime,
                &pAsn1Info->u.utcTime,
                pInfo))
            goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509ChoiceOfTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ChoiceOfTime_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ChoiceOfTimeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Attribute Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Attribute Asn1Info;


    if (!Asn1X509SetAttribute(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        Attribute_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeAttribute(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Attribute Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Attribute *pAsn1Info = (Attribute *) pvAsn1Info;
    PCRYPT_ATTRIBUTE pInfo = (PCRYPT_ATTRIBUTE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_ATTRIBUTE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_ATTRIBUTE);

    Asn1X509GetAttribute(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AttributeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Attribute_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AttributeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  ContentInfo Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ContentInfo Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &Asn1Info.contentType)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }

    if (pInfo->Content.cbData) {
        Asn1Info.bit_mask |= content_present;
        Asn1X509SetAny(&pInfo->Content, &Asn1Info.content);
    }

    return Asn1InfoEncodeEx(
        ContentInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  ContentInfo Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    ContentInfo *pAsn1Info = (ContentInfo *) pvAsn1Info;
    PCRYPT_CONTENT_INFO pInfo = (PCRYPT_CONTENT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_CONTENT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRYPT_CONTENT_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_CONTENT_INFO);
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->contentType, dwFlags,
        &pInfo->pszObjId, &pbExtra, &lRemainExtra);
    if (pAsn1Info->bit_mask & content_present)
        Asn1X509GetAny(&pAsn1Info->content, dwFlags,
            &pInfo->Content, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509ContentInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ContentInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ContentInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  ContentInfoSequenceOfAny Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ContentInfoSeqOfAny Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &Asn1Info.contentType))
        goto ErrorReturn;

    if (pInfo->cValue) {
        Asn1Info.bit_mask |= contentSeqOfAny_present;
        if (!Asn1X509SetSeqOfAny(
                pInfo->cValue,
                pInfo->rgValue,
                &Asn1Info.contentSeqOfAny.count,
                &Asn1Info.contentSeqOfAny.value))
            goto ErrorReturn;
    }

    fResult = Asn1InfoEncodeEx(
        ContentInfoSeqOfAny_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeSeqOfAny(Asn1Info.contentSeqOfAny.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  ContentInfoSequenceOfAny Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    ContentInfoSeqOfAny *pAsn1Info = (ContentInfoSeqOfAny *) pvAsn1Info;
    PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo =
        (PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY));
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY);
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->contentType, dwFlags,
        &pInfo->pszObjId, &pbExtra, &lRemainExtra);
    if (pAsn1Info->bit_mask & contentSeqOfAny_present)
        Asn1X509GetSeqOfAny(pAsn1Info->contentSeqOfAny.count,
            pAsn1Info->contentSeqOfAny.value, dwFlags,
            &pInfo->cValue, &pInfo->rgValue, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ContentInfoSeqOfAny_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ContentInfoSequenceOfAnyDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  SequenceOfAny Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SeqOfAny Asn1Info;

    if (!Asn1X509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &Asn1Info.count,
            &Asn1Info.value))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        SeqOfAny_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeSeqOfAny(Asn1Info.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SequenceOfAny Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SequenceOfAnyDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SeqOfAny *pAsn1Info = (SeqOfAny *) pvAsn1Info;
    PCRYPT_SEQUENCE_OF_ANY pInfo = (PCRYPT_SEQUENCE_OF_ANY) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_SEQUENCE_OF_ANY);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_SEQUENCE_OF_ANY);
    }

    Asn1X509GetSeqOfAny(pAsn1Info->count, pAsn1Info->value, dwFlags,
            &pInfo->cValue, &pInfo->rgValue, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509SequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SeqOfAny_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509SequenceOfAnyDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  UTC TIME Encode/Decode
//--------------------------------------------------------------------------
BOOL WINAPI Asn1UtcTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN FILETIME * pFileTime,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        ) {

    assert(pcbEncoded != NULL);

    BOOL fResult;
    UtcTime utcTime;

    memset(&utcTime, 0, sizeof(UtcTime));

    if( !PkiAsn1ToUTCTime(pFileTime, &utcTime) )
            goto PkiAsn1ToUTCTimeError;

    fResult = Asn1InfoEncodeEx(
                UtcTime_PDU,
                &utcTime,
                dwFlags,
                pEncodePara,
                pvEncoded,
                pcbEncoded
                );

CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(PkiAsn1ToUTCTimeError);
}


BOOL WINAPI Asn1UtcTimeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    UtcTime *putcTime = (UtcTime *) pvAsn1Info;
    LPFILETIME pInfo = (LPFILETIME) pvStructInfo;

    *plRemainExtra -= sizeof(FILETIME);
    if (*plRemainExtra >= 0) {
        if(!PkiAsn1FromUTCTime(putcTime, pInfo))
            goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1UtcTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        UtcTime_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1UtcTimeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

BOOL WINAPI Asn1TimeStampRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_TIME_STAMP_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cAttr;
    PCRYPT_ATTRIBUTE pAttr;
    Attribute *pAsn1Attr;
    DWORD   pdu;

    union {
        TimeStampRequest tsr;
        TimeStampRequestOTS tsrocs;
        } timeStampReq;

    memset(&timeStampReq, 0, sizeof(TimeStampRequest));

    if( !Asn1X509SetEncodedObjId(pInfo->pszTimeStampAlgorithm, &timeStampReq.tsr.timeStampAlgorithm) ||
        !Asn1X509SetEncodedObjId(pInfo->pszContentType, &timeStampReq.tsr.content.contentType) )
	goto Asn1X509SetEncodedObjIdError;

    // only write content if it is present
    if(pInfo->Content.cbData != 0)
        timeStampReq.tsr.content.bit_mask |= content_present;

    if(!strcmp(pInfo->pszContentType, szOID_RSA_data)) {
        Asn1X509SetOctetString(&pInfo->Content, &timeStampReq.tsrocs.contentOTS.contentOTS);
        pdu = TimeStampRequestOTS_PDU;
        }
    else {
        Asn1X509SetAny(&pInfo->Content, &timeStampReq.tsr.content.content);
        pdu = TimeStampRequest_PDU;
        }

    cAttr = pInfo->cAttribute;
    pAttr = pInfo->rgAttribute;
    timeStampReq.tsr.attributesTS.count = cAttr;
    timeStampReq.tsr.attributesTS.value = NULL;
    if (cAttr > 0) {
        pAsn1Attr = (Attribute *) PkiZeroAlloc(cAttr * sizeof(Attribute));
        if (pAsn1Attr == NULL)
            goto ErrorReturn;
        timeStampReq.tsr.attributesTS.value = pAsn1Attr;
        timeStampReq.tsr.bit_mask |= attributesTS_present;
    }

    for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++) {
        if (!Asn1X509SetAttribute(pAttr, pAsn1Attr))
            goto ErrorReturn;
    }

    fResult = Asn1InfoEncodeEx(
        pdu,
        &timeStampReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

CommonReturn:
    if (timeStampReq.tsr.attributesTS.value) {
        pAsn1Attr = timeStampReq.tsr.attributesTS.value;
        cAttr = timeStampReq.tsr.attributesTS.count;
        for ( ; cAttr > 0; cAttr--, pAsn1Attr++)
            Asn1X509FreeAttribute(pAsn1Attr);

        PkiFree(timeStampReq.tsr.attributesTS.value);
    }
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(Asn1X509SetEncodedObjIdError);
}


//+-------------------------------------------------------------------------
//  Decode the Time Stamp Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1TimeStampRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    TimeStampRequest *pTimeStampReq = (TimeStampRequest *) pvAsn1Info;
    PCRYPT_TIME_STAMP_REQUEST_INFO pInfo =
        (PCRYPT_TIME_STAMP_REQUEST_INFO) pvStructInfo;

    OctetStringType *pOctetStringType = NULL;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRYPT_TIME_STAMP_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRYPT_TIME_STAMP_REQUEST_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_TIME_STAMP_REQUEST_INFO);
    }

    Asn1X509GetEncodedObjId(   &pTimeStampReq->timeStampAlgorithm,
                        dwFlags,
                       &pInfo->pszTimeStampAlgorithm,
                       &pbExtra,
                       &lRemainExtra
                   );
    Asn1X509GetEncodedObjId(   &pTimeStampReq->content.contentType,
                        dwFlags,
                       &pInfo->pszContentType,
                       &pbExtra,
                       &lRemainExtra
                   );

    if(pTimeStampReq->content.bit_mask == content_present) {
    
        // OctetStrings will be smaller, so when doing byte counting go to
        // ANY which will requre more room for decode...
        if(pInfo && !strcmp(pInfo->pszContentType, szOID_RSA_data)) {

            if (!Asn1InfoDecodeAndAlloc(
                        OctetStringType_PDU,
                        (const unsigned char *) pTimeStampReq->content.content.encoded,
                        pTimeStampReq->content.content.length,
                        (void **) &pOctetStringType))
                    goto Asn1InfoDecodeAndAllocError;

            Asn1X509GetOctetString(pOctetStringType, dwFlags,
                &pInfo->Content, &pbExtra, &lRemainExtra);
        }
        else
            Asn1X509GetAny(&pTimeStampReq->content.content, dwFlags,
                &pInfo->Content, &pbExtra, &lRemainExtra);
    }

    if (pTimeStampReq->bit_mask & attributesTS_present) {
        DWORD cAttr;
        PCRYPT_ATTRIBUTE pAttr;
        Attribute *pAsn1Attr;

        cAttr = pTimeStampReq->attributesTS.count;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cAttribute = cAttr;
            pAttr = (PCRYPT_ATTRIBUTE) pbExtra;
            pInfo->rgAttribute = pAttr;
            pbExtra += lAlignExtra;
        } else
            pAttr = NULL;

        pAsn1Attr = pTimeStampReq->attributesTS.value;
        for (; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
            Asn1X509GetAttribute(pAsn1Attr, dwFlags,
                pAttr, &pbExtra, &lRemainExtra);
    }

    fResult = TRUE;

CommonReturn:
    Asn1InfoFree(OctetStringType_PDU, pOctetStringType);
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(Asn1InfoDecodeAndAllocError);
}

BOOL WINAPI Asn1TimeStampRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        TimeStampRequest_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1TimeStampRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Usage object identifiers
//--------------------------------------------------------------------------
BOOL Asn1X509SetCtlUsage(
        IN PCTL_USAGE pUsage,
        OUT EnhancedKeyUsage *pAsn1
        )
{
    DWORD cId;
    LPSTR *ppszId;
    UsageIdentifier *pAsn1Id;

    pAsn1->count = 0;
    pAsn1->value = NULL;
    cId = pUsage->cUsageIdentifier;
    if (0 == cId)
        return TRUE;

    pAsn1Id = (UsageIdentifier *) PkiNonzeroAlloc(cId * sizeof(UsageIdentifier));
    if (pAsn1Id == NULL)
        return FALSE;

    pAsn1->count = cId;
    pAsn1->value = pAsn1Id;
    ppszId = pUsage->rgpszUsageIdentifier;
    for ( ; cId > 0; cId--, ppszId++, pAsn1Id++) {
        if (!Asn1X509SetEncodedObjId(*ppszId, pAsn1Id))
            return FALSE;
    }

    return TRUE;
}

void Asn1X509FreeCtlUsage(
        IN EnhancedKeyUsage *pAsn1)
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
}

void Asn1X509GetCtlUsage(
        IN EnhancedKeyUsage *pAsn1,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pAsn1Id;
    LPSTR *ppszId;

    cId = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pAsn1Id = pAsn1->value;
    for ( ; cId > 0; cId--, pAsn1Id++, ppszId++)
        Asn1X509GetEncodedObjId(pAsn1Id, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnhancedKeyUsage Asn1Info;

    if (!Asn1X509SetCtlUsage(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        fResult = FALSE;
    } else
        fResult = Asn1InfoEncodeEx(
            EnhancedKeyUsage_PDU,
            &Asn1Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    Asn1X509FreeCtlUsage(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnhancedKeyUsage *pAsn1Info = (EnhancedKeyUsage *) pvAsn1Info;
    PCTL_USAGE pInfo = (PCTL_USAGE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    Asn1X509GetCtlUsage(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CtlUsageDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnhancedKeyUsage_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CtlUsageDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Entries
//--------------------------------------------------------------------------
BOOL Asn1X509SetCtlEntries(
        IN DWORD cEntry,
        IN PCTL_ENTRY pEntry,
        OUT TrustedSubjects *pAsn1
        )
{
    TrustedSubject *pAsn1Entry;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cEntry == 0)
        return TRUE;

    pAsn1Entry = (TrustedSubject *) PkiZeroAlloc(
        cEntry * sizeof(TrustedSubject));
    if (pAsn1Entry == NULL)
        return FALSE;
    pAsn1->value = pAsn1Entry;
    pAsn1->count = cEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        Asn1X509SetOctetString(&pEntry->SubjectIdentifier,
            &pAsn1Entry->subjectIdentifier);
        if (pEntry->cAttribute > 0) {
            DWORD cAttr;
            PCRYPT_ATTRIBUTE pAttr;
            Attribute *pAsn1Attr;

            cAttr = pEntry->cAttribute;
            pAttr = pEntry->rgAttribute;
            pAsn1Attr = (Attribute *) PkiZeroAlloc(cAttr * sizeof(Attribute));
            if (pAsn1Attr == NULL)
                return FALSE;

            pAsn1Entry->bit_mask |= subjectAttributes_present;
            pAsn1Entry->subjectAttributes.count = cAttr;
            pAsn1Entry->subjectAttributes.value = pAsn1Attr;
            for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++) {
                if (!Asn1X509SetAttribute(pAttr, pAsn1Attr))
                    return FALSE;
            }
        }
    }
    return TRUE;
}

void Asn1X509FreeCtlEntries(
        IN TrustedSubjects *pAsn1)
{
    if (pAsn1->value) {
        DWORD cEntry = pAsn1->count;
        TrustedSubject *pAsn1Entry = pAsn1->value;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++) {
            if (pAsn1Entry->subjectAttributes.value) {
                DWORD cAttr = pAsn1Entry->subjectAttributes.count;
                Attribute *pAsn1Attr = pAsn1Entry->subjectAttributes.value;

                for ( ; cAttr > 0; cAttr--, pAsn1Attr++)
                    Asn1X509FreeAttribute(pAsn1Attr);
                PkiFree(pAsn1Entry->subjectAttributes.value);
            }
        }
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetCtlEntries(
        IN TrustedSubjects *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcEntry,
        OUT PCTL_ENTRY *ppEntry,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cEntry;
    TrustedSubject *pAsn1Entry;
    PCTL_ENTRY pEntry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CTL_ENTRY));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcEntry = cEntry;
        pEntry = (PCTL_ENTRY) pbExtra;
        memset(pEntry, 0, cEntry * sizeof(CTL_ENTRY));
        *ppEntry = pEntry;
        pbExtra += lAlignExtra;
    } else
        pEntry = NULL;

    pAsn1Entry = pAsn1->value;
    for ( ; cEntry > 0; cEntry--, pAsn1Entry++, pEntry++) {
        // SubjectIdentifier
        Asn1X509GetOctetString(&pAsn1Entry->subjectIdentifier, dwFlags,
                &pEntry->SubjectIdentifier, &pbExtra, &lRemainExtra);

        // Attributes
        if (pAsn1Entry->bit_mask & subjectAttributes_present) {
            DWORD cAttr;
            PCRYPT_ATTRIBUTE pAttr;
            Attribute *pAsn1Attr;

            cAttr = pAsn1Entry->subjectAttributes.count;
            lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
            lRemainExtra -= lAlignExtra;
            if (lRemainExtra >= 0) {
                pEntry->cAttribute = cAttr;
                pAttr = (PCRYPT_ATTRIBUTE) pbExtra;
                pEntry->rgAttribute = pAttr;
                pbExtra += lAlignExtra;
            } else
                pAttr = NULL;

            pAsn1Attr = pAsn1Entry->subjectAttributes.value;
            for (; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
                Asn1X509GetAttribute(pAsn1Attr, dwFlags,
                    pAttr, &pbExtra, &lRemainExtra);
        }
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Encode the CTL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateTrustList Ctl;

    memset(&Ctl, 0, sizeof(Ctl));

    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Ctl.CertificateTrustList_version = pInfo->dwVersion;
#else
        Ctl.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Ctl.bit_mask |= CertificateTrustList_version_present;
    }
    if (!Asn1X509SetCtlUsage(&pInfo->SubjectUsage, &Ctl.subjectUsage))
        goto ErrorReturn;
    if (pInfo->ListIdentifier.cbData) {
        Asn1X509SetOctetString(&pInfo->ListIdentifier, &Ctl.listIdentifier);
        Ctl.bit_mask |= listIdentifier_present;
    }
    if (pInfo->SequenceNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->SequenceNumber,
                &Ctl.sequenceNumber))
            goto ErrorReturn;
        Ctl.bit_mask |= sequenceNumber_present;
    }
    if (!PkiAsn1ToChoiceOfTime(&pInfo->ThisUpdate, 
            &Ctl.ctlThisUpdate.choice,
            &Ctl.ctlThisUpdate.u.generalTime,
            &Ctl.ctlThisUpdate.u.utcTime
            ))
        goto EncodeError;
    if (pInfo->NextUpdate.dwLowDateTime || pInfo->NextUpdate.dwHighDateTime) {
        Ctl.bit_mask |= ctlNextUpdate_present;
        if (!PkiAsn1ToChoiceOfTime(&pInfo->NextUpdate, 
                &Ctl.ctlNextUpdate.choice,
                &Ctl.ctlNextUpdate.u.generalTime,
                &Ctl.ctlNextUpdate.u.utcTime
                ))
            goto EncodeError;
    }
    if (!Asn1X509SetAlgorithm(&pInfo->SubjectAlgorithm, &Ctl.subjectAlgorithm))
        goto ErrorReturn;
    if (pInfo->cCTLEntry) {
        if (!Asn1X509SetCtlEntries(pInfo->cCTLEntry, pInfo->rgCTLEntry,
                &Ctl.trustedSubjects))
            goto ErrorReturn;
        Ctl.bit_mask |= trustedSubjects_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Ctl.ctlExtensions))
            goto ErrorReturn;
        Ctl.bit_mask |= ctlExtensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateTrustList_PDU,
        &Ctl,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeCtlUsage(&Ctl.subjectUsage);
    Asn1X509FreeHugeInteger(&Ctl.sequenceNumber);
    Asn1X509FreeCtlEntries(&Ctl.trustedSubjects);
    Asn1X509FreeExtensions(&Ctl.ctlExtensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the CTL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateTrustList *pCtl = (CertificateTrustList *) pvAsn1Info;
    PCTL_INFO pInfo = (PCTL_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CTL_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CTL_INFO));

        // Update fields not needing extra memory after the CTL_INFO
        if (pCtl->bit_mask &
                CertificateTrustList_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion =
                pCtl->CertificateTrustList_version;
#else
            pInfo->dwVersion = pCtl->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCtl->ctlThisUpdate.choice,
                &pCtl->ctlThisUpdate.u.generalTime,
                &pCtl->ctlThisUpdate.u.utcTime,
                &pInfo->ThisUpdate))
            goto DecodeError;
        if (pCtl->bit_mask & ctlNextUpdate_present) {
            if (!PkiAsn1FromChoiceOfTime(pCtl->ctlNextUpdate.choice,
                    &pCtl->ctlNextUpdate.u.generalTime,
                    &pCtl->ctlNextUpdate.u.utcTime,
                    &pInfo->NextUpdate))
                goto DecodeError;
        }

        pbExtra = (BYTE *) pInfo + sizeof(CTL_INFO);
    }

    Asn1X509GetCtlUsage(&pCtl->subjectUsage, dwFlags,
            &pInfo->SubjectUsage, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & listIdentifier_present)
        // Always copy to force alignment
        Asn1X509GetOctetString(&pCtl->listIdentifier,
                dwFlags & ~CRYPT_DECODE_NOCOPY_FLAG,
                &pInfo->ListIdentifier, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & sequenceNumber_present)
        Asn1X509GetHugeInteger(&pCtl->sequenceNumber, dwFlags,
                &pInfo->SequenceNumber, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pCtl->subjectAlgorithm, dwFlags,
            &pInfo->SubjectAlgorithm, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & trustedSubjects_present)
        Asn1X509GetCtlEntries(&pCtl->trustedSubjects, dwFlags,
            &pInfo->cCTLEntry, &pInfo->rgCTLEntry, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & ctlExtensions_present)
        Asn1X509GetExtensions(&pCtl->ctlExtensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CtlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CertificateTrustList_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CtlInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


BOOL WINAPI Asn1X509PKIXUserNoticeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    UserNotice Asn1Info;

    memset (&Asn1Info, 0, sizeof(Asn1Info));

    if (pInfo->pNoticeReference != NULL)
    {
        Asn1Info.bit_mask |= noticeRef_present;
        Asn1Info.noticeRef.organization = pInfo->pNoticeReference->pszOrganization;
        Asn1Info.noticeRef.noticeNumbers.count = pInfo->pNoticeReference->cNoticeNumbers;
#ifdef OSS_CRYPT_ASN1
        Asn1Info.noticeRef.noticeNumbers.value = pInfo->pNoticeReference->rgNoticeNumbers;
#else
        Asn1Info.noticeRef.noticeNumbers.value = (ASN1int32_t *) pInfo->pNoticeReference->rgNoticeNumbers;
#endif  // OSS_CRYPT_ASN1
    }

    if (pInfo->pszDisplayText)
    {
        Asn1Info.bit_mask |= explicitText_present;
        Asn1Info.explicitText.choice = theBMPString_chosen;
        Asn1Info.explicitText.u.theBMPString.length = wcslen(pInfo->pszDisplayText) * 2;
        Asn1Info.explicitText.u.theBMPString.value = (unsigned short *) pInfo->pszDisplayText;
    }
    
    fResult = Asn1InfoEncodeEx(
            UserNotice_PDU,
            &Asn1Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    
    return fResult;
}

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    UserNotice *pAsn1UserNotice = (UserNotice *) pvAsn1Info;
    PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo =
        (PCERT_POLICY_QUALIFIER_USER_NOTICE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE);
    }

    // check to see if there is a notice reference
    if (pAsn1UserNotice->bit_mask & noticeRef_present)
    {
        lRemainExtra -= sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE);
        if (lRemainExtra >= 0)
        {
            pInfo->pNoticeReference = (PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE) pbExtra;
            memset(pInfo->pNoticeReference, 0, sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE));
            pbExtra += sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE);
        }

        lRemainExtra -= strlen(pAsn1UserNotice->noticeRef.organization)+1;
        if (lRemainExtra >= 0)
        {
            pInfo->pNoticeReference->pszOrganization = (LPSTR) pbExtra;
            strcpy(pInfo->pNoticeReference->pszOrganization, pAsn1UserNotice->noticeRef.organization);
            pbExtra += strlen(pAsn1UserNotice->noticeRef.organization)+1;
        }

        lRemainExtra -= pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int);
        if (lRemainExtra >= 0)
        {   
            pInfo->pNoticeReference->cNoticeNumbers = pAsn1UserNotice->noticeRef.noticeNumbers.count;
            pInfo->pNoticeReference->rgNoticeNumbers = (int *) pbExtra;
            memcpy(
                pInfo->pNoticeReference->rgNoticeNumbers, 
                pAsn1UserNotice->noticeRef.noticeNumbers.value, 
                pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int));
            pbExtra += pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int);
        }
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pNoticeReference = NULL;
    }

    // check to see if there is a notice reference
    if (pAsn1UserNotice->bit_mask & explicitText_present)
    {
        // check whether it is a visible or bmp string
        if (pAsn1UserNotice->explicitText.choice & theVisibleString_chosen)
        {
            lRemainExtra -= (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1) * sizeof(WCHAR);
            if (lRemainExtra >= 0)
            {
                pInfo->pszDisplayText = (LPWSTR) pbExtra;
                MultiByteToWideChar(
                    CP_ACP, 
                    0, 
                    pAsn1UserNotice->explicitText.u.theVisibleString,
                    -1,
                    pInfo->pszDisplayText,
                    (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1) * sizeof(WCHAR));
                pbExtra += (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1) * sizeof(WCHAR);
            }
        }
        else if (pAsn1UserNotice->explicitText.choice & theBMPString_chosen)
        {
            lRemainExtra -= pAsn1UserNotice->explicitText.u.theBMPString.length + 2;
            if (lRemainExtra >= 0)
            {
                pInfo->pszDisplayText = (LPWSTR) pbExtra;
                memcpy(
                    (void *)pInfo->pszDisplayText, 
                    pAsn1UserNotice->explicitText.u.theBMPString.value,
                    pAsn1UserNotice->explicitText.u.theBMPString.length);
                pInfo->pszDisplayText[pAsn1UserNotice->explicitText.u.theBMPString.length/2] = 0;
                pbExtra += pAsn1UserNotice->explicitText.u.theBMPString.length + 2;
            }
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        UserNotice_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PKIXUserNoticeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Encode Attributes (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Attributes Asn1Info;
    DWORD cAttr;
    PCRYPT_ATTRIBUTE pAttr;
    Attribute *pAsn1Attr;

    cAttr = pInfo->cAttr;
    pAttr = pInfo->rgAttr;
    Asn1Info.count = cAttr;
    Asn1Info.value = NULL;
    if (cAttr > 0) {
        pAsn1Attr = (Attribute *) PkiZeroAlloc(cAttr * sizeof(Attribute));
        if (pAsn1Attr == NULL)
            goto ErrorReturn;
        Asn1Info.value = pAsn1Attr;
    }

    for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++) {
        if (!Asn1X509SetAttribute(pAttr, pAsn1Attr))
            goto ErrorReturn;
    }

    fResult = Asn1InfoEncodeEx(
        Attributes_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1Info.value) {
        pAsn1Attr = Asn1Info.value;
        cAttr = Asn1Info.count;
        for ( ; cAttr > 0; cAttr--, pAsn1Attr++)
            Asn1X509FreeAttribute(pAsn1Attr);

        PkiFree(Asn1Info.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode Attributes (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Attributes *pAsn1Info = (Attributes *) pvAsn1Info;
    PCRYPT_ATTRIBUTES pInfo = (PCRYPT_ATTRIBUTES) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    DWORD cAttr;
    PCRYPT_ATTRIBUTE pAttr;
    Attribute *pAsn1Attr;

    lRemainExtra -= sizeof(CRYPT_ATTRIBUTES);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_ATTRIBUTES);
    }

    cAttr = pAsn1Info->count;
    lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cAttr = cAttr;
        pAttr = (PCRYPT_ATTRIBUTE) pbExtra;
        pInfo->rgAttr = pAttr;
        pbExtra += lAlignExtra;
    } else
        pAttr = NULL;

    pAsn1Attr = pAsn1Info->value;
    for (; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
        Asn1X509GetAttribute(pAsn1Attr, dwFlags,
            pAttr, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Attributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Decode Enrollment Name Value Pair Authenticated Attributes in RA PKCS7s
//--------------------------------------------------------------------------

BOOL WINAPI Asn1NameValueDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnrollmentNameValuePair *pAsn1Info = (EnrollmentNameValuePair *) pvAsn1Info;
    PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValuePair = (PCRYPT_ENROLLMENT_NAME_VALUE_PAIR) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pNameValuePair + sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR);
    }

    lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pbExtra += lAlignExtra;
    }

    PkiAsn1GetBMPString(
        pAsn1Info->name.length,
        pAsn1Info->name.value,
        0,
        &pNameValuePair->pwszName,
        &pbExtra,
        &lRemainExtra
        );
        
    PkiAsn1GetBMPString(
        pAsn1Info->value.length,
        pAsn1Info->value.value,
        0,
        &pNameValuePair->pwszValue,
        &pbExtra,
        &lRemainExtra
        );

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnrollmentNameValuePair_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1NameValueDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode Name Value Pair Authenticated Attributes in RA PKCS7s
//--------------------------------------------------------------------------
BOOL WINAPI Asn1NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnrollmentNameValuePair NameValue;

    NameValue.name.length = wcslen(pNameValue->pwszName);
    NameValue.name.value  = pNameValue->pwszName;
    
    NameValue.value.length = wcslen(pNameValue->pwszValue);
    NameValue.value.value  = pNameValue->pwszValue;
    
    fResult = Asn1InfoEncodeEx(
        EnrollmentNameValuePair_PDU,
        &NameValue,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
        
    if (!fResult && (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)) {
        *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode CSP Provider Attribute
//--------------------------------------------------------------------------

BOOL WINAPI Asn1CSPProviderDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CSPProvider *pAsn1Info = (CSPProvider *) pvAsn1Info;
    PCRYPT_CSP_PROVIDER pCSPProvider = (PCRYPT_CSP_PROVIDER) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRYPT_CSP_PROVIDER);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pCSPProvider + sizeof(CRYPT_CSP_PROVIDER);
    }

    lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_CSP_PROVIDER));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pbExtra += lAlignExtra;
    }

    pCSPProvider->dwKeySpec = (DWORD) pAsn1Info->keySpec;
    
    PkiAsn1GetBMPString(
        pAsn1Info->cspName.length,
        pAsn1Info->cspName.value,
        0,
        &pCSPProvider->pwszProviderName,
        &pbExtra,
        &lRemainExtra
        );

    Asn1X509GetBit(
            &pAsn1Info->signature,
            dwFlags,
            &pCSPProvider->Signature,
            &pbExtra,
            &lRemainExtra
            );
            
    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1CSPProviderDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CSPProvider_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CSPProviderDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode CSP Provider Attribute
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CSPProviderEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CSP_PROVIDER pCSPProvider,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CSPProvider CspProvider;

    CspProvider.keySpec = (int) pCSPProvider->dwKeySpec;
    CspProvider.cspName.length = wcslen(pCSPProvider->pwszProviderName);
    CspProvider.cspName.value  = pCSPProvider->pwszProviderName;
    
     Asn1X509SetBit(
        &pCSPProvider->Signature,
        &CspProvider.signature
        );

    fResult = Asn1InfoEncodeEx(
        CSPProvider_PDU,
        &CspProvider,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    if (!fResult && (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)) {
        *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\xlogstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       logstor.cpp
//
//  Contents:   Registry Certificate Store Provider APIs
//
//  Functions:  I_RegStoreDllMain
//              I_CertDllOpenRegStoreProv
//              CertRegisterSystemStore
//              CertRegisterPhysicalStore
//              CertUnregisterSystemStore
//              CertUnregisterPhysicalStore
//              CertEnumSystemStoreLocation
//              CertEnumSystemStore
//              CertEnumPhysicalStore
//              I_CertDllOpenSystemRegistryStoreProvW
//              I_CertDllOpenSystemRegistryStoreProvA
//              I_CertDllOpenSystemStoreProvW
//              I_CertDllOpenSystemStoreProvA
//              I_CertDllOpenPhysicalStoreProvW
//
//  History:    28-Dec-96    philh   created
//              13-Aug-96    philh   added change notify and resync support
//              24-Aug-96    philh   added logical store support
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "xwinreg.h"
#include "xdbg.h"

#ifdef STATIC
#undef STATIC
#endif
#define STATIC


// Pointer to an allocated LONG containing thread's enum recursion depth
static HCRYPTTLS hTlsEnumPhysicalStoreDepth;
#define MAX_ENUM_PHYSICAL_STORE_DEPTH       20

#define SYSTEM_STORE_REGPATH        L"Software\\Microsoft\\SystemCertificates"
#define PHYSICAL_STORES_SUBKEY_NAME L"PhysicalStores"
#define CONST_OID_STR_PREFIX_CHAR   '#'
#define SERVICES_REGPATH            L"Software\\Microsoft\\Cryptography\\Services"
#define SYSTEM_CERTIFICATES_SUBKEY_NAME L"SystemCertificates"
#define GROUP_POLICY_STORE_REGPATH  L"Software\\Policies\\Microsoft\\SystemCertificates"
#define ENTERPRISE_STORE_REGPATH    L"Software\\Microsoft\\EnterpriseCertificates"

#define ROAMING_MY_STORE_SUBDIR     L"Microsoft\\SystemCertificates\\My"

#define REGISTER_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_CREATE_NEW_FLAG)
#define UNREGISTER_FLAGS_MASK       (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG)
#define ENUM_FLAGS_MASK             (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG)

#define OPEN_REG_FLAGS_MASK         (CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG | \
                                        CERT_REGISTRY_STORE_REMOTE_FLAG | \
                                        CERT_REGISTRY_STORE_SERIALIZED_FLAG | \
                                        CERT_REGISTRY_STORE_ROAMING_FLAG | \
                                        CERT_REGISTRY_STORE_CLIENT_GPT_FLAG | \
                                        CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG | \
                                        CERT_REGISTRY_STORE_LM_GPT_FLAG)
#define OPEN_SYS_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG)
#define OPEN_PHY_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG)
//+-------------------------------------------------------------------------
//  Common, global logical store critical section. Used by:
//      GptStore, Win95Store, RoamingStore.
//--------------------------------------------------------------------------
static CRITICAL_SECTION ILS_CriticalSection;


//+-------------------------------------------------------------------------
//  Registry Store Context SubKeys
//--------------------------------------------------------------------------

#ifdef CAPI_INCLUDE_CTL
#define CONTEXT_COUNT       3
#elif defined(CAPI_INCLUDE_CRL)
#define CONTEXT_COUNT		2
#else
#define CONTEXT_COUNT		1
#endif

static const LPCWSTR rgpwszContextSubKeyName[CONTEXT_COUNT] = {
    L"Certificates",

#if CONTEXT_COUNT > 1
    L"CRLs",
#endif

#if CONTEXT_COUNT > 2
    L"CTLs"
#endif    
};

#define KEYID_CONTEXT_NAME          L"Keys"

static DWORD rgdwContextTypeFlags[CONTEXT_COUNT] = {
    CERT_STORE_CERTIFICATE_CONTEXT_FLAG,

#if CONTEXT_COUNT > 1
    CERT_STORE_CRL_CONTEXT_FLAG,
#endif

#if CONTEXT_COUNT > 2
    CERT_STORE_CTL_CONTEXT_FLAG
#endif    
};

#define MY_SYSTEM_INDEX         0
#define ROOT_SYSTEM_INDEX       1
#define TRUST_SYSTEM_INDEX      2
#define CA_SYSTEM_INDEX         3
#define USER_DS_SYSTEM_INDEX    4

#define MY_SYSTEM_FLAG          (1 << MY_SYSTEM_INDEX)
#define ROOT_SYSTEM_FLAG        (1 << ROOT_SYSTEM_INDEX)
#define TRUST_SYSTEM_FLAG       (1 << TRUST_SYSTEM_INDEX)
#define CA_SYSTEM_FLAG          (1 << CA_SYSTEM_INDEX)
#define USER_DS_SYSTEM_FLAG     (1 << USER_DS_SYSTEM_INDEX)

#define COMMON_SYSTEM_FLAGS     ( \
    MY_SYSTEM_FLAG | \
    ROOT_SYSTEM_FLAG | \
    TRUST_SYSTEM_FLAG | \
    CA_SYSTEM_FLAG \
    )

#define wsz_MY_STORE        L"My"
#define wsz_ROOT_STORE      L"Root"
#define wsz_TRUST_STORE     L"Trust"
#define wsz_CA_STORE        L"CA"
#define wsz_USER_DS_STORE   L"UserDS"
static LPCWSTR rgpwszPredefinedSystemStore[] = {
    wsz_MY_STORE,
    wsz_ROOT_STORE,
    wsz_TRUST_STORE,
    wsz_CA_STORE,
    wsz_USER_DS_STORE
};
#define NUM_PREDEFINED_SYSTEM_STORE (sizeof(rgpwszPredefinedSystemStore) / \
                                        sizeof(rgpwszPredefinedSystemStore[0]))


#define DEFAULT_PHYSICAL_INDEX          0
#define GROUP_POLICY_PHYSICAL_INDEX     1
#define LOCAL_MACHINE_PHYSICAL_INDEX    2
#define DS_USER_CERT_PHYSICAL_INDEX     3
#define LMGP_PHYSICAL_INDEX             4
#define ENTERPRISE_PHYSICAL_INDEX       5
#define NUM_PREDEFINED_PHYSICAL         6

#define DEFAULT_PHYSICAL_FLAG           (1 << DEFAULT_PHYSICAL_INDEX)
#ifdef CE_BUILD
#define GROUP_POLICY_PHYSICAL_FLAG		0	// hack to make sure GP store are not in predefined collections
#else
#define GROUP_POLICY_PHYSICAL_FLAG      (1 << GROUP_POLICY_PHYSICAL_INDEX)
#endif
#define LOCAL_MACHINE_PHYSICAL_FLAG     (1 << LOCAL_MACHINE_PHYSICAL_INDEX)
#define DS_USER_CERT_PHYSICAL_FLAG      (1 << DS_USER_CERT_PHYSICAL_INDEX)
#define LMGP_PHYSICAL_FLAG              (1 << LMGP_PHYSICAL_INDEX)
#define ENTERPRISE_PHYSICAL_FLAG        (1 << ENTERPRISE_PHYSICAL_INDEX)

static LPCWSTR rgpwszPredefinedPhysical[NUM_PREDEFINED_PHYSICAL] = {
    CERT_PHYSICAL_STORE_DEFAULT_NAME,
    CERT_PHYSICAL_STORE_GROUP_POLICY_NAME,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME,
    CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME,
    CERT_PHYSICAL_STORE_ENTERPRISE_NAME,
};

#define NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG  0x1
#define REMOTABLE_SYSTEM_STORE_LOCATION_FLAG        0x2
#define SERIALIZED_SYSTEM_STORE_LOCATION_FLAG       0x4

typedef struct _SYSTEM_STORE_LOCATION_INFO {
    DWORD       dwFlags;
    DWORD       dwPredefinedSystemFlags;
    DWORD       dwPredefinedPhysicalFlags;
} SYSTEM_STORE_LOCATION_INFO, *PSYSTEM_STORE_LOCATION_INFO;


static const SYSTEM_STORE_LOCATION_INFO rgSystemStoreLocationInfo[] = {
    //  Not Defined                                     0
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    //  CERT_SYSTEM_STORE_CURRENT_USER_ID               1
    0,
    COMMON_SYSTEM_FLAGS | USER_DS_SYSTEM_FLAG,
    DEFAULT_PHYSICAL_FLAG | GROUP_POLICY_PHYSICAL_FLAG |
        LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ID               2
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | GROUP_POLICY_PHYSICAL_FLAG |
        ENTERPRISE_PHYSICAL_FLAG,

    //  Not Defined                                     3
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

#ifndef UNDER_CE
    // CERT_SYSTEM_STORE_CURRENT_SERVICE_ID             4
    0,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_SERVICES_ID                    5
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_USERS_ID                       6
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID   7
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG,
    0,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID  8
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG |
        REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID    9
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG
#else
// CE does not support the following locations:
    // CERT_SYSTEM_STORE_CURRENT_SERVICE_ID             4
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_SERVICES_ID                    5
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_USERS_ID                       6
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID   7
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG,
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,
    // CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID  8
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG |
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID    9
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,
#endif
};

#define NUM_SYSTEM_STORE_LOCATION   (sizeof(rgSystemStoreLocationInfo) / \
                                        sizeof(rgSystemStoreLocationInfo[0]))

#define CURRENT_USER_ROOT_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    LOCAL_MACHINE_PHYSICAL_FLAG \
    )

#define USERS_ROOT_PHYSICAL_FLAGS ( \
    LOCAL_MACHINE_PHYSICAL_FLAG \
    )

#define MY_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG \
    )

#define USER_DS_PHYSICAL_FLAGS ( \
    DS_USER_CERT_PHYSICAL_FLAG \
    )


#define sz_CRYPTNET_DLL             "cryptnet.dll"
#define sz_GetUserDsStoreUrl        "I_CryptNetGetUserDsStoreUrl"
typedef BOOL (WINAPI *PFN_GET_USER_DS_STORE_URL)(
          IN LPWSTR pwszUserAttribute,
          OUT LPWSTR* ppwszUrl
          );

#define wsz_USER_CERTIFICATE_ATTR   L"userCertificate"


#define PHYSICAL_NAME_INDEX     0
#define SYSTEM_NAME_INDEX       1
#define SERVICE_NAME_INDEX      2
#define USER_NAME_INDEX         2
#define COMPUTER_NAME_INDEX     3
#define SYSTEM_NAME_PATH_COUNT  4

#define DEFAULT_USER_NAME       L".Default"

typedef struct _SYSTEM_NAME_INFO {
    LPWSTR      rgpwszName[SYSTEM_NAME_PATH_COUNT];
    // non-NULL for relocated store. Note hKeyBase isn't opened and
    // doesn't need to be closed
    HKEY        hKeyBase;
} SYSTEM_NAME_INFO, *PSYSTEM_NAME_INFO;


typedef struct _REG_STORE REG_STORE, *PREG_STORE;

typedef struct _ILS_RESYNC_ENTRY {
    HANDLE              hOrigEvent;
    HANDLE              hEvent;
    PREG_STORE          pRegStore;
} ILS_RESYNC_ENTRY, *PILS_RESYNC_ENTRY;

typedef struct _REGISTRY_STORE_CHANGE_INFO {
    HANDLE              hChange;
    HANDLE              hRegWaitFor;
    DWORD               cNotifyEntry;
    PILS_RESYNC_ENTRY   rgNotifyEntry;
} REGISTRY_STORE_CHANGE_INFO, *PREGISTRY_STORE_CHANGE_INFO;

//+-------------------------------------------------------------------------
//  Registry Store Provider handle information
//
//  hMyNotifyChange is our internal NotifyChange event handle.
//--------------------------------------------------------------------------
struct _REG_STORE {
    HCERTSTORE          hCertStore;         // not duplicated
    CRITICAL_SECTION    CriticalSection;
    HANDLE              hMyNotifyChange;
    BOOL                fResync;            // when set, ignore callback deletes
    HKEY                hKey;
    DWORD               dwFlags;

    // Following field is applicable to the CurrentUser "Root" store
    BOOL                fProtected;

    // Following field is applicable when
    // CERT_REGISTRY_STORE_SERIALIZED_FLAG is set in dwFlags
    BOOL                fTouched;      // set for write, delete or set property

    union {
        // Following field is applicable when
        // CERT_REGISTRY_STORE_CLIENT_GPT_FLAG is set in dwFlags
        CERT_REGISTRY_STORE_CLIENT_GPT_PARA GptPara;

        // Following field is applicable when
        // CERT_REGISTRY_STORE_ROAMING_FLAG is set in dwFlags
        LPWSTR              pwszStoreDirectory;
    };

    // Following field is applicable for change notify of registry or
    // roaming file store
    PREGISTRY_STORE_CHANGE_INFO pRegistryStoreChangeInfo;
};


typedef struct _ENUM_SYSTEM_STORE_LOCATION_INFO {
    DWORD               dwFlags;
    LPCWSTR             pwszLocation;
} ENUM_SYSTEM_STORE_LOCATION_INFO, *PENUM_SYSTEM_STORE_LOCATION_INFO;

// Predefined crypt32.dll locations. MUST NOT BE REGISTERED!!!
static const ENUM_SYSTEM_STORE_LOCATION_INFO rgEnumSystemStoreLocationInfo[] = {
    CERT_SYSTEM_STORE_CURRENT_USER, L"CurrentUser",
    CERT_SYSTEM_STORE_LOCAL_MACHINE, L"LocalMachine",
    CERT_SYSTEM_STORE_CURRENT_SERVICE, L"CurrentService",
    CERT_SYSTEM_STORE_SERVICES, L"Services",
    CERT_SYSTEM_STORE_USERS, L"Users",
    CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY, L"CurrentUserGroupPolicy",
    CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, L"LocalMachineGroupPolicy",
    CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, L"LocalMachineEnterprise"
};
#define ENUM_SYSTEM_STORE_LOCATION_CNT \
        (sizeof(rgEnumSystemStoreLocationInfo) / \
            sizeof(rgEnumSystemStoreLocationInfo[0]))

#define OPEN_SYSTEM_STORE_PROV_FUNC_SET     0
#define REGISTER_SYSTEM_STORE_FUNC_SET      1
#define UNREGISTER_SYSTEM_STORE_FUNC_SET    2
#define ENUM_SYSTEM_STORE_FUNC_SET          3
#define REGISTER_PHYSICAL_STORE_FUNC_SET    4
#define UNREGISTER_PHYSICAL_STORE_FUNC_SET  5
#define ENUM_PHYSICAL_STORE_FUNC_SET        6
#define FUNC_SET_COUNT                      7

static HCRYPTOIDFUNCSET rghFuncSet[FUNC_SET_COUNT];
static const LPCSTR rgpszFuncName[FUNC_SET_COUNT] = {
    CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC,
    CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC,
    CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC,
    CRYPT_OID_ENUM_SYSTEM_STORE_FUNC,
    CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC,
    CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC,
    CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC
};

typedef BOOL (WINAPI *PFN_REGISTER_SYSTEM_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    );
typedef BOOL (WINAPI *PFN_UNREGISTER_SYSTEM_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags
    );
typedef BOOL (WINAPI *PFN_ENUM_SYSTEM_STORE)(
    IN DWORD dwFlags,
    IN OPTIONAL void *pvSystemStoreLocationPara,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    );

typedef BOOL (WINAPI *PFN_REGISTER_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    );
typedef BOOL (WINAPI *PFN_UNREGISTER_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName
    );
typedef BOOL (WINAPI *PFN_ENUM_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    );


//+-------------------------------------------------------------------------
//  Registry Store Provider Functions.
//--------------------------------------------------------------------------
STATIC void WINAPI RegStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        );

static void * const rgpvRegStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    RegStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    RegStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    RegStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    RegStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    RegStoreProvSetCertProperty,
#ifdef CAPI_INCLUDE_CRL    
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    RegStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    RegStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    RegStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    RegStoreProvSetCrlProperty,
#else
	NULL,NULL,NULL,NULL,
#endif
#ifdef CAPI_INCLUDE_CTL
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    RegStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    RegStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    RegStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    RegStoreProvSetCtlProperty,
  #else
 	NULL,NULL,NULL,NULL,
 #endif

#ifndef CE_BUILD
   // CERT_STORE_PROV_CONTROL_FUNC            13
    RegStoreProvControl
#else
	NULL
#endif	
};
#define REG_STORE_PROV_FUNC_COUNT (sizeof(rgpvRegStoreProvFunc) / \
                                    sizeof(rgpvRegStoreProvFunc[0]))

STATIC BOOL WINAPI RootStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );

STATIC BOOL WINAPI RootStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );

static void * const rgpvRootStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    RegStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    RegStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    RootStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    RootStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    RegStoreProvSetCertProperty,
#ifdef CAPI_INCLUDE_CRL
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    RegStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    RegStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    RegStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    RegStoreProvSetCrlProperty,
#else
	NULL,NULL,NULL,NULL,
#endif
#ifdef CAPI_INCLUDE_CTL
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    RegStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    RegStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    RegStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    RegStoreProvSetCtlProperty,
#else
	NULL,NULL,NULL,NULL,
#endif

#ifndef CE_BUILD
    // CERT_STORE_PROV_CONTROL_FUNC            13
    RegStoreProvControl
#else
	NULL
#endif
};
#define ROOT_STORE_PROV_FUNC_COUNT (sizeof(rgpvRootStoreProvFunc) / \
                                    sizeof(rgpvRootStoreProvFunc[0]))

//+-------------------------------------------------------------------------
//  Add the serialized store to the store.
//
//  from newstor.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI I_CertAddSerializedStore(
        IN HCERTSTORE hCertStore,
        IN BYTE *pbStore,
        IN DWORD cbStore
        );

//+-------------------------------------------------------------------------
//  CertStore allocation and free functions
//--------------------------------------------------------------------------
STATIC LPWSTR AllocAndCopyString(
    IN LPCWSTR pwszSrc,
    IN LONG cchSrc = -1
    )
{
    LPWSTR pwszDst;

    if (cchSrc < 0)
        cchSrc = wcslen(pwszSrc);
    if (NULL == (pwszDst = (LPWSTR) PkiNonzeroAlloc(
            (cchSrc + 1) * sizeof(WCHAR))))
        return NULL;
    if (0 < cchSrc)
        memcpy((BYTE *) pwszDst, (BYTE *) pwszSrc, cchSrc * sizeof(WCHAR));
    pwszDst[cchSrc] = L'\0';
    return pwszDst;
}

#if 1
// BUGBUG move to crypt32.dll
extern
BOOL
WINAPI
I_ProtectedRootDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);
#endif

//+=========================================================================
//  Register WaitFor Forward Function References
//==========================================================================
STATIC void RegWaitForProcessAttach();
STATIC void RegWaitForProcessDetach();

//+=========================================================================
//  Client "GPT" Store Forward Function References
//==========================================================================
STATIC void GptStoreProcessAttach();
STATIC void GptStoreProcessDetach();

STATIC BOOL OpenAllFromGptRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    );

STATIC BOOL CommitAllToGptRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    );

STATIC void GptStoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    );

STATIC BOOL RegGptStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    );

static inline BOOL IsClientGptStore(
    IN PSYSTEM_NAME_INFO pInfo,
    IN DWORD dwFlags
    )
{
    DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

    if (!(CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY == dwStoreLocation ||
          CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwStoreLocation))
        return FALSE;

    if (dwFlags & (CERT_SYSTEM_STORE_RELOCATE_FLAG | CERT_STORE_DELETE_FLAG))
        return FALSE;

    return TRUE;
}

//+=========================================================================
//  Win95 Notify Store Forward Function References
//==========================================================================

// Following is created at ProcessAttach for Win95 clients
static HANDLE hWin95NotifyEvent = NULL;

STATIC void Win95StoreProcessAttach();
STATIC void Win95StoreProcessDetach();

STATIC void Win95StoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    );

STATIC BOOL RegWin95StoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    );

//+=========================================================================
// Roaming Store Forward Function References
//==========================================================================
STATIC void RoamingStoreProcessAttach();
STATIC void RoamingStoreProcessDetach();

LPWSTR
ILS_GetRoamingStoreDirectory(
    IN LPCWSTR pwszStoreName
    );

BOOL
ILS_WriteElementToFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       // CERT_STORE_CREATE_NEW_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    );

BOOL
ILS_ReadElementFromFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    );

BOOL
ILS_DeleteElementFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    );

typedef BOOL (*PFN_ILS_OPEN_ELEMENT)(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    );

BOOL
ILS_OpenAllElementsFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    );

//+=========================================================================
// Registry or Roaming Store Change Notify Functions
//==========================================================================
STATIC BOOL RegRegistryStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    );

STATIC void FreeRegistryStoreChange(
    IN PREG_STORE pRegStore
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_RegStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Open the system store provider (unicode version)
//
//  Open the system store specified by its name. For example,
//  L"My".
//
//  pvPara contains the LPCWSTR system store name.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE; 
}

//+-------------------------------------------------------------------------
//  Open the system store provider (ascii version)
//
//  Open the system store specified by its name. For example,
//  "My".
//
//  pvPara contains the LPCSTR system store name.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE; 
}

//+-------------------------------------------------------------------------
//  Open the registry's store by reading its serialized certificates,
//  CRLs and CTLs and adding to the specified certificate store.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//
//  Only return HKEY for success. For a CertOpenStore error the caller
//  will close the HKEY.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenRegStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE; 
}

//+-------------------------------------------------------------------------
//  Open the system registry store provider (unicode version)
//
//  Open the system registry store specified by its name. For example,
//  L"My".
//
//  pvPara contains the LPCWSTR system registry store name.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemRegistryStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE; 
}

//+-------------------------------------------------------------------------
//  Open the system registry store provider (ascii version)
//
//  Open the system registry store specified by its name. For example,
//  "My".
//
//  pvPara contains the LPCSTR system store name.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemRegistryStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE; 
}


//+-------------------------------------------------------------------------
//  Open the physical store provider (unicode version)
//
//  Open the physical store in the specified system store. For example,
//  L"My\.Default".
//
//  pvPara contains the LPCWSTR pwszSystemAndPhysicalName which is the
//  concatenation of the system and physical store names with an
//  intervening "\".
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenPhysicalStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE; 
}


BOOL
ILS_ReadKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE;
}

BOOL
ILS_WriteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE;
}


BOOL
ILS_DeleteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE;
}

BOOL
ILS_OpenAllKeyIdElements(
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN void *pvArg,
    IN PFN_ILS_OPEN_KEYID_ELEMENT pfnOpenKeyId
    )
{
	ASSERT(!"xlogstor.cpp called");
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\api.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       api.cpp
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    28-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>

//
// Globals
//

HMODULE                g_hCryptnet = NULL;
CRITICAL_SECTION       g_CryptnetLock;
CDefaultChainEngineMgr DefaultChainEngineMgr;
//+---------------------------------------------------------------------------
//
//  Function:   ChainDllMain
//
//  Synopsis:   Chaining infrastructure initialization
//
//  Declare as export so that the master DllMain can do a late binding to it.
//
//----------------------------------------------------------------------------


extern "C"
BOOL WINAPI
ChainDllMain (
     IN HMODULE hModule,
     IN ULONG ulReason,
     IN LPVOID pvReserved
     )
{
    BOOL fResult = TRUE;

    switch ( ulReason )
    {
    case DLL_PROCESS_ATTACH:

        InitializeCriticalSection( &g_CryptnetLock );

        fResult = DefaultChainEngineMgr.Initialize();

        break;
    case DLL_PROCESS_DETACH:

        DefaultChainEngineMgr.Uninitialize();

        if ( g_hCryptnet != NULL )
        {
            //Xbox FreeLibrary( g_hCryptnet );
        }

        DeleteCriticalSection( &g_CryptnetLock );
        break;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InternalCertCreateCertificateChainEngine
//
//  Synopsis:   create a chain engine handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
InternalCertCreateCertificateChainEngine (
    IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
    IN BOOL fDefaultEngine,
    OUT HCERTCHAINENGINE* phChainEngine
    )
{
    BOOL                     fResult = TRUE;
    PCCERTCHAINENGINE        pChainEngine = NULL;
    CERT_CHAIN_ENGINE_CONFIG Config;

    if ( pConfig->cbSize != sizeof( CERT_CHAIN_ENGINE_CONFIG ) )
    {
        SetLastError( E_INVALIDARG );
        return( FALSE );
    }

    Config = *pConfig;

    if ( Config.MaximumCachedCertificates == 0 )
    {
        Config.MaximumCachedCertificates = DEFAULT_MAX_INDEX_ENTRIES;
    }

    if ( Config.CycleDetectionModulus == 0 )
    {
        Config.CycleDetectionModulus = CYCLE_DETECTION_MODULUS;
    }

    if ( Config.dwUrlRetrievalTimeout == 0 )
    {
        Config.dwUrlRetrievalTimeout = DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT;
    }

    pChainEngine = new CCertChainEngine( &Config, fDefaultEngine, fResult );
    if ( pChainEngine == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *phChainEngine = (HCERTCHAINENGINE)pChainEngine;
    }
    else
    {
        delete pChainEngine;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertCreateCertificateChainEngine
//
//  Synopsis:   create a certificate chain engine
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertCreateCertificateChainEngine (
    IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
    OUT HCERTCHAINENGINE* phChainEngine
    )
{
    return( InternalCertCreateCertificateChainEngine(
                    pConfig,
                    FALSE,
                    phChainEngine
                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertFreeCertificateChainEngine
//
//  Synopsis:   free the chain engine handle
//
//----------------------------------------------------------------------------
VOID WINAPI
CertFreeCertificateChainEngine (
    IN HCERTCHAINENGINE hChainEngine
    )
{
    if ( ( hChainEngine == HCCE_CURRENT_USER ) ||
         ( hChainEngine == HCCE_LOCAL_MACHINE ) )
    {
        DefaultChainEngineMgr.FlushDefaultEngine( hChainEngine );
        return;
    }

    ( (PCCERTCHAINENGINE)hChainEngine )->Release();
}

#ifndef CE_BUILD
//+---------------------------------------------------------------------------
//
//  Function:   CertResyncCertificateChainEngine
//
//  Synopsis:   resync the chain engine
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertResyncCertificateChainEngine (
    IN HCERTCHAINENGINE hChainEngine
    )
{
    BOOL              fResult;
    PCCERTCHAINENGINE pChainEngine = (PCCERTCHAINENGINE)hChainEngine;

    if ( ( hChainEngine == HCCE_LOCAL_MACHINE ) ||
         ( hChainEngine == HCCE_CURRENT_USER ) )
    {
        if ( DefaultChainEngineMgr.GetDefaultEngine(
                                      hChainEngine,
                                      (HCERTCHAINENGINE *)&pChainEngine
                                      ) == FALSE )
        {
            return( FALSE );
        }
    }
    else
    {
        pChainEngine->AddRef();
    }

    pChainEngine->LockEngine();

    fResult = pChainEngine->Resync( NULL, TRUE );

    pChainEngine->UnlockEngine();

    pChainEngine->Release();

    return( fResult );
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CertGetCertificateChain
//
//  Synopsis:   get the certificate chain for the given end certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertGetCertificateChain (
    IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    BOOL              fResult;
    PCCERTCHAINENGINE pChainEngine = (PCCERTCHAINENGINE)hChainEngine;
    FILETIME          CurrentTime;
    LPVOID            pvImpersonated = NULL;

    if ( ( pChainPara == NULL ) || ( pvReserved != NULL ) )
    {
        SetLastError( E_INVALIDARG );
        return( FALSE );
    }

#ifdef CE_BUILD
	SYSTEMTIME sysTime;
	GetSystemTime(&sysTime);
	SystemTimeToFileTime(&sysTime,&CurrentTime);
#else
    GetSystemTimeAsFileTime( &CurrentTime );
#endif

    if ( pTime == NULL )
    {
        pTime = &CurrentTime;
    }

    if ( ( hChainEngine == HCCE_LOCAL_MACHINE ) ||
         ( hChainEngine == HCCE_CURRENT_USER ) )
    {
        if ( DefaultChainEngineMgr.GetDefaultEngine(
                                      hChainEngine,
                                      (HCERTCHAINENGINE *)&pChainEngine
                                      ) == FALSE )
        {
            return( FALSE );
        }
    }
    else
    {
        pChainEngine->AddRef();
    }

    fResult = pChainEngine->GetChainContext(
                               pCertContext,
                               pTime,
                               &CurrentTime,
                               hAdditionalStore,
                               &pChainPara->RequestedUsage,
                               dwFlags,
                               pvReserved,
                               ppChainContext
                               );

    pChainEngine->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertFreeCertificateChain
//
//  Synopsis:   free a certificate chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
CertFreeCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    ChainReleaseInternalChainContext(
         (PINTERNAL_CERT_CHAIN_CONTEXT)pChainContext
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertDuplicateCertificateChain
//
//  Synopsis:   duplicate (add a reference to) a certificate chain
//
//----------------------------------------------------------------------------
PCCERT_CHAIN_CONTEXT WINAPI
CertDuplicateCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    ChainAddRefInternalChainContext(
         (PINTERNAL_CERT_CHAIN_CONTEXT)pChainContext
         );

    return( pChainContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetCryptnetModule
//
//  Synopsis:   get the cryptnet.dll module handle
//
//----------------------------------------------------------------------------
HMODULE WINAPI
ChainGetCryptnetModule ()
{
    HMODULE hModule;

    EnterCriticalSection( &g_CryptnetLock );

    if ( g_hCryptnet == NULL )
    {
#ifdef UNDER_CE
        //Xbox g_hCryptnet = LoadLibrary( TEXT("cryptnet.dll") );
#else
        g_hCryptnet = LoadLibraryA( "cryptnet.dll" );
#endif        
    }

    hModule = g_hCryptnet;

    LeaveCriticalSection( &g_CryptnetLock );

    return( hModule );
}

#ifndef CE_BUILD
//+---------------------------------------------------------------------------
//
//  Function:   ChainWlxLogoffEvent
//
//  Synopsis:   logoff event processing
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainWlxLogoffEvent (PWLX_NOTIFICATION_INFO pNotificationInfo)
{
    CertFreeCertificateChainEngine( HCCE_CURRENT_USER );
    return( TRUE );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\defce.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       defce.h
//
//  Contents:   Default Chain Engine Manager
//
//  History:    21-Apr-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__DEFCE_H__)
#define __DEFCE_H__

//
// Forward class declarations
//

class CDefaultChainEngineMgr;
class CImpersonationEngine;

//
// Class pointer definitions
//

typedef CDefaultChainEngineMgr* PCDEFAULTCHAINENGINEMGR;
typedef CImpersonationEngine*   PCIMPERSONATIONENGINE;

//
// Some default definitions
//

#define DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT 60000

//
// CDefaultChainEngineMgr.  Manage the default chain engines
//

class CDefaultChainEngineMgr
{
public:

    //
    // Constructor
    //

    CDefaultChainEngineMgr ();
    ~CDefaultChainEngineMgr ();

    //
    // Initialization
    //

    BOOL Initialize ();
    VOID Uninitialize ();

    //
    // Get default chain engines
    //

    BOOL GetDefaultEngine (
            IN HCERTCHAINENGINE hDefaultHandle,
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL GetDefaultLocalMachineEngine (
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL GetDefaultCurrentUserEngine (
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    //
    // Flush default engines
    //

    VOID FlushDefaultEngine (IN HCERTCHAINENGINE hDefaultHandle);

private:

    //
    // Lock
    //

    CRITICAL_SECTION m_Lock;

    //
    // Local Machine Default Engine
    //

    HCERTCHAINENGINE m_hLocalMachineEngine;

    //
    // Process User Default Engine
    //

    HCERTCHAINENGINE m_hProcessUserEngine;

    //
    // Impersonated Users Default Engine Cache
    //

    HLRUCACHE        m_hImpersonationCache;

    //
    // Private methods
    //

    BOOL GetDefaultCurrentImpersonatedUserEngine (
            IN HANDLE hUserToken,
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL IsImpersonatingUser (
           OUT HANDLE* phUserToken
           );

    BOOL GetTokenId (
            IN HANDLE hUserToken,
            OUT PCRYPT_DATA_BLOB pTokenId
            );

    VOID FreeTokenId (
             IN PCRYPT_DATA_BLOB pTokenId
             );

    BOOL FindImpersonationEngine (
             IN PCRYPT_DATA_BLOB pTokenId,
             OUT PCIMPERSONATIONENGINE* ppEngine
             );

    BOOL CreateImpersonationEngine (
               IN PCRYPT_DATA_BLOB pTokenId,
               OUT PCIMPERSONATIONENGINE* ppEngine
               );

    VOID AddToImpersonationCache (
            IN PCIMPERSONATIONENGINE pEngine
            );
};

VOID WINAPI
DefaultChainEngineMgrOnImpersonationEngineRemoval (
       IN LPVOID pv,
       IN LPVOID pvRemovalContext
       );

DWORD WINAPI
DefaultChainEngineMgrHashTokenIdentifier (
       IN PCRYPT_DATA_BLOB pIdentifier
       );

#define DEFAULT_IMPERSONATION_CACHE_BUCKETS 3
#define MAX_IMPERSONATION_CACHE_ENTRIES     3

//
// CImpersonationEngine, simply a ref-counted chain engine handle which
// can be added to the LRU cache
//

class CImpersonationEngine
{
public:

    //
    // Constructor
    //

    CImpersonationEngine (
                  IN HLRUCACHE hCache,
                  IN PCRYPT_DATA_BLOB pTokenId,
                  OUT BOOL& rfResult
                  );

    ~CImpersonationEngine ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Access to the chain engine
    //

    inline HCERTCHAINENGINE ChainEngine ();

    //
    // Access to the LRU entry handle
    //

    inline HLRUENTRY LruEntry ();

private:

    //
    // Reference count
    //

    ULONG            m_cRefs;

    //
    // Chain Engine
    //

    HCERTCHAINENGINE m_hChainEngine;

    //
    // LRU entry handle
    //

    HLRUENTRY        m_hLruEntry;
};

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::AddRef, public
//
//  Synopsis:   add a reference to the object
//
//----------------------------------------------------------------------------
inline VOID
CImpersonationEngine::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::Release, public
//
//  Synopsis:   release a reference on the object
//
//----------------------------------------------------------------------------
inline VOID
CImpersonationEngine::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::ChainEngine, public
//
//  Synopsis:   return the cert chain engine
//
//----------------------------------------------------------------------------
inline HCERTCHAINENGINE
CImpersonationEngine::ChainEngine ()
{
    return( m_hChainEngine );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::LruEntry, public
//
//  Synopsis:   return the LRU entry handle
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CImpersonationEngine::LruEntry ()
{
    return( m_hLruEntry );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\defce.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       defce.cpp
//
//  Contents:   Default Chain Engine Manager
//
//  History:    21-Apr-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::CDefaultChainEngineMgr, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CDefaultChainEngineMgr::CDefaultChainEngineMgr ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::~CDefaultChainEngineMgr, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CDefaultChainEngineMgr::~CDefaultChainEngineMgr ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::Initialize, public
//
//  Synopsis:   initialization routine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::Initialize ()
{
    LRU_CACHE_CONFIG Config;

    InitializeCriticalSection( &m_Lock );

    m_hLocalMachineEngine = NULL;
    m_hProcessUserEngine = NULL;
    m_hImpersonationCache = NULL;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
    Config.cBuckets = DEFAULT_IMPERSONATION_CACHE_BUCKETS;
    Config.MaxEntries = MAX_IMPERSONATION_CACHE_ENTRIES;
    Config.pfnHash = DefaultChainEngineMgrHashTokenIdentifier;
#ifdef CE_BUILD 
    Config.pfnOnRemoval = NULL;
#else
    Config.pfnOnRemoval = DefaultChainEngineMgrOnImpersonationEngineRemoval;
#endif    

    return( I_CryptCreateLruCache( &Config, &m_hImpersonationCache ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::Uninitialize, public
//
//  Synopsis:   uninitialization routine
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::Uninitialize ()
{
    if ( m_hLocalMachineEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hLocalMachineEngine );
    }

    if ( m_hProcessUserEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hProcessUserEngine );
    }

    if ( m_hImpersonationCache != NULL )
    {
        I_CryptFreeLruCache( m_hImpersonationCache, 0, NULL );
    }

    DeleteCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultEngine, public
//
//  Synopsis:   get the default engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultEngine (
                           IN HCERTCHAINENGINE hDefaultHandle,
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    assert( ( hDefaultHandle == HCCE_LOCAL_MACHINE ) ||
            ( hDefaultHandle == HCCE_CURRENT_USER ) );

    if ( hDefaultHandle == HCCE_LOCAL_MACHINE )
    {
        return( GetDefaultLocalMachineEngine( phDefaultEngine ) );
    }
    else if ( hDefaultHandle == HCCE_CURRENT_USER )
    {
        return( GetDefaultCurrentUserEngine( phDefaultEngine ) );
    }

    SetLastError( E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultLocalMachineEngine, public
//
//  Synopsis:   get the default local machine chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultLocalMachineEngine (
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL fResult = TRUE;

    EnterCriticalSection( &m_Lock );

    if ( m_hLocalMachineEngine == NULL )
    {
        HCERTCHAINENGINE         hEngine = NULL;
        CERT_CHAIN_ENGINE_CONFIG Config;

        LeaveCriticalSection( &m_Lock );

        memset( &Config, 0, sizeof( Config ) );

        Config.cbSize = sizeof( Config );
        Config.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;
        Config.dwFlags |= CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE;
        Config.dwUrlRetrievalTimeout = DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT;

        fResult = CertCreateCertificateChainEngine(
                      &Config,
                      &hEngine
                      );

        EnterCriticalSection( &m_Lock );

        if ( ( fResult == TRUE ) && ( m_hLocalMachineEngine == NULL ) )
        {
            m_hLocalMachineEngine = hEngine;
            hEngine = NULL;
        }

        if ( hEngine != NULL )
        {
            ( (PCCERTCHAINENGINE)hEngine )->Release();
        }
    }

    if ( fResult == TRUE )
    {
        ( (PCCERTCHAINENGINE)m_hLocalMachineEngine )->AddRef();
        *phDefaultEngine = m_hLocalMachineEngine;
    }

    LeaveCriticalSection( &m_Lock );

    return( fResult );
}

#ifdef CE_BUILD
// dont support impersonations
BOOL
CDefaultChainEngineMgr::IsImpersonatingUser (
                          OUT HANDLE* phUserToken
                          )
{
    SetLastError( ERROR_NO_TOKEN );
	return FALSE;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultCurrentUserEngine, public
//
//  Synopsis:   get the default current user chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultCurrentUserEngine (
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL   fResult = TRUE;
    HANDLE hUserToken;

    EnterCriticalSection( &m_Lock );

    if ( IsImpersonatingUser( &hUserToken ) == FALSE )
    {
        if ( GetLastError() != ERROR_NO_TOKEN )
        {
            LeaveCriticalSection( &m_Lock );
            return( FALSE );
        }

        if ( m_hProcessUserEngine == NULL )
        {
            HCERTCHAINENGINE         hEngine = NULL;
            CERT_CHAIN_ENGINE_CONFIG Config;

            LeaveCriticalSection( &m_Lock );

            memset( &Config, 0, sizeof( Config ) );

            Config.cbSize = sizeof( Config );
            Config.dwFlags = CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE;
            Config.dwUrlRetrievalTimeout = DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT;

            fResult = CertCreateCertificateChainEngine(
                          &Config,
                          &hEngine
                          );

            EnterCriticalSection( &m_Lock );

            if ( ( fResult == TRUE ) && ( m_hProcessUserEngine == NULL ) )
            {
                m_hProcessUserEngine = hEngine;
                hEngine = NULL;
            }

            if ( hEngine != NULL )
            {
                ( (PCCERTCHAINENGINE)hEngine )->Release();
            }
        }

        if ( fResult == TRUE )
        {
            ( (PCCERTCHAINENGINE)m_hProcessUserEngine )->AddRef();
            *phDefaultEngine = m_hProcessUserEngine;
        }
    }
#ifndef CE_BUILD    
    else
    {
        fResult = GetDefaultCurrentImpersonatedUserEngine(
                     hUserToken,
                     phDefaultEngine
                     );

        CloseHandle( hUserToken );
    }
#endif

    LeaveCriticalSection( &m_Lock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FlushDefaultEngine, public
//
//  Synopsis:   flush default engine
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::FlushDefaultEngine (IN HCERTCHAINENGINE hDefaultHandle)
{
    EnterCriticalSection( &m_Lock );

    if ( hDefaultHandle == HCCE_CURRENT_USER )
    {
        if ( m_hProcessUserEngine != NULL )
        {
            CertFreeCertificateChainEngine( m_hProcessUserEngine );
            m_hProcessUserEngine = NULL;
        }

        assert( m_hImpersonationCache != NULL );

        I_CryptFlushLruCache( m_hImpersonationCache, 0, NULL );
    }
    else if ( hDefaultHandle == HCCE_LOCAL_MACHINE )
    {
        if ( m_hLocalMachineEngine != NULL )
        {
            CertFreeCertificateChainEngine( m_hLocalMachineEngine );
            m_hLocalMachineEngine = NULL;
        }
    }

    LeaveCriticalSection( &m_Lock );
}

#ifndef CE_BUILD
//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultCurrentImpersonatedUserEngine
//
//  Synopsis:   get current impersonated user chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultCurrentImpersonatedUserEngine (
                           IN HANDLE hUserToken,
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL                  fResult;
    CRYPT_DATA_BLOB       TokenId;
    PCIMPERSONATIONENGINE pEngine = NULL;

    fResult = GetTokenId( hUserToken, &TokenId );

    if ( fResult == TRUE )
    {
        if ( FindImpersonationEngine( &TokenId, &pEngine ) == FALSE )
        {
            PCIMPERSONATIONENGINE pCreatedEngine = NULL;

            LeaveCriticalSection( &m_Lock );

            fResult = CreateImpersonationEngine( &TokenId, &pCreatedEngine );

            EnterCriticalSection( &m_Lock );

            if ( fResult == TRUE )
            {
                fResult = FindImpersonationEngine( &TokenId, &pEngine );

                if ( fResult == FALSE )
                {
                    pEngine = pCreatedEngine;
                    pCreatedEngine = NULL;

                    AddToImpersonationCache( pEngine );

                    fResult = TRUE;
                }

                if ( pCreatedEngine != NULL )
                {
                    pCreatedEngine->Release();
                }
            }
        }

        FreeTokenId( &TokenId );
    }

    if ( fResult == TRUE )
    {
        *phDefaultEngine = pEngine->ChainEngine();
        ( (PCCERTCHAINENGINE)*phDefaultEngine )->AddRef();
    }

    if ( pEngine != NULL )
    {
        pEngine->Release();
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::IsImpersonatingUser, public
//
//  Synopsis:   is impersonating user?
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::IsImpersonatingUser (
                          OUT HANDLE* phUserToken
                          )
{
    if ( FIsWinNT() == FALSE )
    {
        SetLastError( ERROR_NO_TOKEN );
        return( FALSE );
    }

    return( OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                phUserToken
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetTokenId, public
//
//  Synopsis:   get the token id which is the ModifiedId LUID inside of
//              the TOKEN_STATISTICS information
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetTokenId (
                           IN HANDLE hUserToken,
                           OUT PCRYPT_DATA_BLOB pTokenId
                           )
{
    BOOL             fResult;
    TOKEN_STATISTICS ts;
    DWORD            Length = 0;

    fResult = GetTokenInformation(
                 hUserToken,
                 TokenStatistics,
                 &ts,
                 sizeof( ts ),
                 &Length
                 );

    if ( fResult == TRUE )
    {
        pTokenId->cbData = sizeof( ts.ModifiedId );
        pTokenId->pbData = new BYTE [ sizeof( ts.ModifiedId ) ];
        if ( pTokenId->pbData != NULL )
        {
            memcpy(
               pTokenId->pbData,
               &ts.ModifiedId,
               sizeof( ts.ModifiedId )
               );
        }
        else
        {
            SetLastError( E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FreeTokenId, public
//
//  Synopsis:   free token id
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::FreeTokenId (
                            IN PCRYPT_DATA_BLOB pTokenId
                            )
{
    delete pTokenId->pbData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FindImpersonationEngine, public
//
//  Synopsis:   find the impersonation engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::FindImpersonationEngine (
                            IN PCRYPT_DATA_BLOB pTokenId,
                            OUT PCIMPERSONATIONENGINE* ppEngine
                            )
{
    BOOL                  fResult = FALSE;
    HLRUENTRY             hFound;
    PCIMPERSONATIONENGINE pEngine = NULL;

    hFound = I_CryptFindLruEntry( m_hImpersonationCache, pTokenId );

    if ( hFound != NULL )
    {
        pEngine = (PCIMPERSONATIONENGINE)I_CryptGetLruEntryData( hFound );
        pEngine->AddRef();

        *ppEngine = pEngine;

        I_CryptReleaseLruEntry( hFound );

        return( TRUE );
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::CreateImpersonationEngine, public
//
//  Synopsis:   create an impersonation engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::CreateImpersonationEngine (
                              IN PCRYPT_DATA_BLOB pTokenId,
                              OUT PCIMPERSONATIONENGINE* ppEngine
                              )
{
    BOOL                  fResult = FALSE;
    PCIMPERSONATIONENGINE pEngine;

    pEngine = new CImpersonationEngine(
                                m_hImpersonationCache,
                                pTokenId,
                                fResult
                                );

    if ( pEngine == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }
    else if ( fResult == FALSE )
    {
        delete pEngine;
        return( FALSE );
    }

    *ppEngine = pEngine;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::AddToImpersonationCache, public
//
//  Synopsis:   add to the cache
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::AddToImpersonationCache(
                           IN PCIMPERSONATIONENGINE pEngine
                           )
{
    pEngine->AddRef();
    I_CryptInsertLruEntry( pEngine->LruEntry(), NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   DefaultChainEngineMgrOnImpersonationEngineRemoval
//
//  Synopsis:   removal notification
//
//----------------------------------------------------------------------------
VOID WINAPI
DefaultChainEngineMgrOnImpersonationEngineRemoval (
       IN LPVOID pv,
       IN LPVOID pvRemovalContext
       )
{
    ( (PCIMPERSONATIONENGINE)pv )->Release();
}

#endif	//CE_BUILD

//+---------------------------------------------------------------------------
//
//  Function:   DefaultChainEngineMgrHashTokenIdentifier
//
//  Synopsis:   hash the token identifier
//
//----------------------------------------------------------------------------
DWORD WINAPI
DefaultChainEngineMgrHashTokenIdentifier (
       IN PCRYPT_DATA_BLOB pIdentifier
       )
{
    DWORD  dwHash = 0;
    DWORD  cb = pIdentifier->cbData;
    LPBYTE pb = pIdentifier->pbData;

    while ( cb-- )
    {
        if ( dwHash & 0x80000000 )
        {
            dwHash = ( dwHash << 1 ) | 1;
        }
        else
        {
            dwHash = dwHash << 1;
        }

        dwHash += *pb++;
    }

    return( dwHash );
}

#ifndef CE_BUILD
//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::CImpersonationEngine, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CImpersonationEngine::CImpersonationEngine (
                                    IN HLRUCACHE hCache,
                                    IN PCRYPT_DATA_BLOB pTokenId,
                                    OUT BOOL& rfResult
                                    )
{
    CERT_CHAIN_ENGINE_CONFIG Config;

    m_cRefs = 1;
    m_hChainEngine = NULL;
    m_hLruEntry = NULL;

    memset( &Config, 0, sizeof( Config ) );

    Config.cbSize = sizeof( Config );
    Config.dwFlags = CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE;
    Config.dwUrlRetrievalTimeout = DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT;

    rfResult = CertCreateCertificateChainEngine( &Config, &m_hChainEngine );

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruEntry(
                          hCache,
                          pTokenId,
                          this,
                          &m_hLruEntry
                          );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::~CImpersonationEngine, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CImpersonationEngine::~CImpersonationEngine ()
{
    if ( m_hLruEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hLruEntry );
    }

    if ( m_hChainEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hChainEngine );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\chain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       chain.cpp
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    15-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <xdbg.h>

#ifdef UNDER_CE
#define CEUNICODE(x)	TEXT(x)
#else
#define CEUNICODE(x)	(x)
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CCertObject, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertObject::CCertObject (
                  IN PCCERTCHAINENGINE pChainEngine,
                  IN PCCHAINCALLCONTEXT pCallContext,
                  IN PCCERT_CONTEXT pCertContext,
                  IN PCRYPT_HASH_BLOB pHashBlob,
                  IN PCERT_TRUST_STATUS pKnownStatus,
                  IN HCERTSTORE hAdditionalStore,
                  OUT BOOL& rfResult
                  )
{
    CRYPT_DATA_BLOB   DataBlob;
    CERT_TRUST_STATUS TrustStatus;

    rfResult = TRUE;

    m_cRefs = 1;
    m_pCertContext = CertDuplicateCertificateContext( pCertContext );
    m_cbKeyIdentifier = 0;
    m_pbKeyIdentifier = NULL;
    m_pUsage = NULL;
    m_pAuthKeyIdentifier = NULL;
    m_pIssuerList = NULL;

    // NOTE: The chain engine is NOT addref'd
    m_pChainEngine = pChainEngine;

    m_hHashEntry = NULL;
    m_hIdentifierEntry = NULL;
    m_hSubjectNameEntry = NULL;
    m_hIssuerNameEntry = NULL;

    memset( &m_TrustStatus, 0, sizeof( m_TrustStatus ) );

    if ( pKnownStatus != NULL )
    {
        ChainOrInStatusBits( &m_TrustStatus, pKnownStatus );
    }

    ChainCreateCertificateObjectIdentifier(
         &pCertContext->pCertInfo->Issuer,
         &pCertContext->pCertInfo->SerialNumber,
         m_ObjectIdentifier
         );

    memcpy( m_CertificateHash, pHashBlob->pbData, pHashBlob->cbData );

    rfResult = CertGetCertificateContextProperty(
                   pCertContext,
                   CERT_KEY_IDENTIFIER_PROP_ID,
                   NULL,
                   &m_cbKeyIdentifier
                   );

    if ( rfResult == TRUE )
    {
        m_pbKeyIdentifier = new BYTE [ m_cbKeyIdentifier ];
        if ( m_pbKeyIdentifier != NULL )
        {
            rfResult = CertGetCertificateContextProperty(
                           pCertContext,
                           CERT_KEY_IDENTIFIER_PROP_ID,
                           m_pbKeyIdentifier,
                           &m_cbKeyIdentifier
                           );
        }
        else
        {
            SetLastError( E_OUTOFMEMORY );
            rfResult = FALSE;
        }
    }

    if ( rfResult == TRUE )
    {
        rfResult = ChainGetCertificateUsage( pCertContext, &m_pUsage );
    }

    if ( rfResult == TRUE )
    {
        rfResult = ChainCreateIssuerList( this, &m_pIssuerList );
    }

    if ( rfResult == TRUE )
    {
        DataBlob.cbData = CertificateHashSize();
        DataBlob.pbData = CertificateHash();

        rfResult = I_CryptCreateLruEntry(
                          pChainEngine->CertObjectCache()->HashIndex(),
                          &DataBlob,
                          this,
                          &m_hHashEntry
                          );
    }

    if ( rfResult == TRUE )
    {
        DataBlob.cbData = sizeof( CERT_OBJECT_IDENTIFIER );
        DataBlob.pbData = m_ObjectIdentifier;

        rfResult = I_CryptCreateLruEntry(
                          pChainEngine->CertObjectCache()->IdentifierIndex(),
                          &DataBlob,
                          this,
                          &m_hIdentifierEntry
                          );
    }

    if ( rfResult == TRUE )
    {
        DataBlob.cbData = pCertContext->pCertInfo->Subject.cbData;
        DataBlob.pbData = pCertContext->pCertInfo->Subject.pbData;

        rfResult = I_CryptCreateLruEntry(
                          pChainEngine->CertObjectCache()->SubjectNameIndex(),
                          &DataBlob,
                          this,
                          &m_hSubjectNameEntry
                          );
    }

    if ( rfResult == TRUE )
    {
        DataBlob.cbData = pCertContext->pCertInfo->Issuer.cbData;
        DataBlob.pbData = pCertContext->pCertInfo->Issuer.pbData;

        rfResult = I_CryptCreateLruEntry(
                          pChainEngine->CertObjectCache()->IssuerNameIndex(),
                          &DataBlob,
                          this,
                          &m_hIssuerNameEntry
                          );
    }

    if ( rfResult == TRUE )
    {
        DataBlob.cbData = m_cbKeyIdentifier;
        DataBlob.pbData = m_pbKeyIdentifier;

        rfResult = I_CryptCreateLruEntry(
                          pChainEngine->CertObjectCache()->KeyIdIndex(),
                          &DataBlob,
                          this,
                          &m_hKeyIdEntry
                          );
    }

    if ( rfResult == FALSE )
    {
        return;
    }

    ChainGetIssuerMatchStatus(
         pCertContext,
         &m_pAuthKeyIdentifier,
         &TrustStatus
         );

    ChainOrInStatusBits( &m_TrustStatus, &TrustStatus );

    ChainGetSelfSignedStatus( this, &TrustStatus );
    ChainOrInStatusBits( &m_TrustStatus, &TrustStatus );

    if ( InfoStatus() & CERT_TRUST_IS_SELF_SIGNED )
    {
        //
        // NOTE: This means that only self-signed roots are supported
        //

        ChainGetRootStoreStatus(
             pChainEngine->RootStore(),
             pChainEngine->RealRootStore(),
             pHashBlob,
             &TrustStatus
             );

        ChainOrInStatusBits( &m_TrustStatus, &TrustStatus );
    }

    rfResult = pCallContext->AddObjectToCreationCache( this );

    if ( rfResult == TRUE )
    {
        rfResult = m_pIssuerList->Restore( pCallContext, TRUE );

        if ( ( rfResult == TRUE ) && ( hAdditionalStore != NULL ) )
        {
            rfResult = m_pIssuerList->GetAdditionalStoreIssuers(
                                         pCallContext,
                                         hAdditionalStore
                                         );
        }
    }

    assert( m_pCertContext != NULL );
    assert( m_pIssuerList != NULL );
    assert( m_pChainEngine == pChainEngine );
    assert( m_hHashEntry != NULL );
    assert( m_hIdentifierEntry != NULL );
    assert( m_hSubjectNameEntry != NULL );
    assert( m_hIssuerNameEntry != NULL );
    assert( m_hKeyIdEntry != NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::~CCertObject, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertObject::~CCertObject ()
{
    if ( m_hKeyIdEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hKeyIdEntry );
    }

    if ( m_hIssuerNameEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hIssuerNameEntry );
    }

    if ( m_hSubjectNameEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hSubjectNameEntry );
    }

    if ( m_hIdentifierEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hIdentifierEntry );
    }

    if ( m_hHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hHashEntry );
    }

    delete m_pbKeyIdentifier;
    ChainFreeIssuerList( m_pIssuerList );
    ChainFreeAuthorityKeyIdentifier( m_pAuthKeyIdentifier );
    ChainFreeCertificateUsage( m_pUsage );
    CertFreeCertificateContext( m_pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CalculateAdditionalStatus, public
//
//  Synopsis:   calculate additional status bits based on time, usage etc
//
//----------------------------------------------------------------------------
VOID
CCertObject::CalculateAdditionalStatus (
                      IN LPFILETIME pTime,
                      IN PCERT_USAGE_MATCH pRequestedUsage,
                      IN DWORD dwFlags,
                      OUT PCERT_TRUST_STATUS pAdditionalStatus
                      )
{
    CERT_TRUST_STATUS TrustStatus;

    memset( &TrustStatus, 0, sizeof( TrustStatus ) );

    ChainGetUsageStatus(
         &pRequestedUsage->Usage,
         m_pUsage,
         pRequestedUsage->dwType,
         &TrustStatus
         );

    if ( ( CompareFileTime(
                  pTime,
                  &m_pCertContext->pCertInfo->NotBefore
                  ) < 0 ) ||
         ( CompareFileTime(
                  pTime,
                  &m_pCertContext->pCertInfo->NotAfter
                  ) > 0 ) )
    {
        TrustStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_TIME_VALID;
    }

    *pAdditionalStatus = TrustStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::ChainErrorStatus, public
//
//  Synopsis:   return the chain error status
//
//----------------------------------------------------------------------------
DWORD
CCertObject::ChainErrorStatus ()
{
    DWORD                dwQualityErrorStatus;
    PCERT_ISSUER_ELEMENT pElement = NULL;
    LONG                 lQualityValue = 0;
    LONG                 lQualityElement = 0;

    if ( InfoStatus() & CERT_TRUST_IS_SELF_SIGNED )
    {
        if ( !( ErrorStatus() & CERT_TRUST_IS_UNTRUSTED_ROOT ) ||
              ( m_pIssuerList->IsEmpty() == TRUE ) )
        {
            return( ErrorStatus() & CERT_TRUST_CHAIN_FULL_ERROR_STATUS );
        }
    }

    dwQualityErrorStatus = CERT_TRUST_CHAIN_FULL_ERROR_STATUS;

    while ( ( pElement = m_pIssuerList->NextElement( pElement ) ) != NULL )
    {
        lQualityValue = ChainGetChainErrorStatusQuality(
                             pElement->ChainStatus.dwErrorStatus
                             );

        if ( lQualityValue > lQualityElement )
        {
            lQualityElement = lQualityValue;
            dwQualityErrorStatus = pElement->ChainStatus.dwErrorStatus;
        }
    }

    return( dwQualityErrorStatus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::GetIssuer, public
//
//  Synopsis:   get the best issuer certificate object given the input
//              parameters
//
//----------------------------------------------------------------------------
BOOL
CCertObject::GetIssuer (
                IN PCCHAINCALLCONTEXT pCallContext,
                IN LPFILETIME pTime,
                IN LPFILETIME pCurrentTime,
                IN HCERTSTORE hStore,
                IN PCERT_USAGE_MATCH pRequestedUsage,
                IN DWORD dwFlags,
                OUT PCCERTOBJECT* ppCertObject,
                OUT PCERT_TRUST_STATUS pSubjectStatus,
                OUT PCERT_TRUST_STATUS pAdditionalStatus,
                OUT PCERT_TRUST_STATUS pCtlStatus,
                OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo,
                OUT PCERT_USAGE_MATCH pTrustListRequestedUsage,
                OUT LPFILETIME pTrustListRequestedTime
                )
{
    BOOL                 fResult = TRUE;
    PCERT_ISSUER_ELEMENT pElement = NULL;
    PCCERTOBJECT         pIssuer = NULL;
    CERT_TRUST_STATUS    AdditionalStatus;
    CERT_TRUST_STATUS    CtlStatus;
    CERT_USAGE_MATCH     CtlSignerRequestedUsage;
    FILETIME             CtlSignerRequestedTime;
    LONG                 lQualityValue = 0;
    LONG                 lQualityElement = CERT_QUALITY_MINIMUM;
    CERT_TRUST_STATUS    QualityAdditionalStatus;
    CERT_TRUST_STATUS    QualityCtlStatus;
    CERT_USAGE_MATCH     QualityCtlSignerRequestedUsage;
    FILETIME             QualityCtlSignerRequestedTime;
    PCERT_ISSUER_ELEMENT pQualityElement = NULL;

    ChainEngine()->CertObjectCache()->DisableLruOfObjects();

    fResult = m_pIssuerList->Restore( pCallContext, FALSE );

    if ( ( fResult == TRUE ) &&
         ( hStore != NULL ) &&
         ( m_pIssuerList->IsAdditionalStoreProcessed() == FALSE ) )
    {
        fResult = m_pIssuerList->GetAdditionalStoreIssuers(
                                    pCallContext,
                                    hStore
                                    );
    }

    if (  ( fResult == TRUE ) &&
          ( m_pIssuerList->IsEmpty() == TRUE ) &&
         !( InfoStatus() & CERT_TRUST_IS_SELF_SIGNED ) )
    {
        // BUGBUG: Inherited chain status is not available
        fResult = ChainEngine()->RetrieveAndStoreMatchingIssuersByUrl(
                                         this,
                                         pCallContext,
                                         dwFlags
                                         );
    }

    if ( fResult == FALSE )
    {
        ChainEngine()->CertObjectCache()->EnableLruOfObjects( pCallContext );
        return( FALSE );
    }

    memset(
       &QualityCtlSignerRequestedUsage,
       0,
       sizeof( QualityCtlSignerRequestedUsage )
       );

    while ( ( pElement = m_pIssuerList->NextElement( pElement ) ) != NULL )
    {
        lQualityValue = ChainGetIssuerQuality(
                             pElement,
                             pTime,
                             pCurrentTime,
                             pRequestedUsage,
                             dwFlags,
                             &AdditionalStatus,
                             &CtlStatus,
                             &CtlSignerRequestedUsage,
                             &CtlSignerRequestedTime
                             );

        if ( lQualityValue > lQualityElement )
        {
            lQualityElement = lQualityValue;
            pQualityElement = pElement;
            QualityAdditionalStatus = AdditionalStatus;
            QualityCtlStatus = CtlStatus;

            ChainFreeRequestedUsage( &QualityCtlSignerRequestedUsage );
            QualityCtlSignerRequestedUsage = CtlSignerRequestedUsage;

            QualityCtlSignerRequestedTime = CtlSignerRequestedTime;
        }
        else
        {
            ChainFreeRequestedUsage( &CtlSignerRequestedUsage );
        }
    }

    if ( ( pQualityElement != NULL ) && ( pQualityElement->pIssuer != NULL ) )
    {
        if ( pQualityElement->fCtlIssuer == FALSE )
        {
            *ppTrustListInfo = NULL;
        }
        else
        {
#ifdef CAPI_INCLUDE_CTL        
            fResult = SSCtlAllocAndCopyTrustListInfo(
                           pQualityElement->pCtlIssuerData->pTrustListInfo,
                           ppTrustListInfo
                           );
#else
			fResult = FALSE;
#endif			
        }

        ChainTouchAllChosenIssuerRelatedObjects( pQualityElement->pIssuer );

        if ( fResult == TRUE )
        {
            pQualityElement->pIssuer->AddRef();
            *ppCertObject = pQualityElement->pIssuer;
            *pSubjectStatus = pQualityElement->SubjectStatus;
            *pAdditionalStatus = QualityAdditionalStatus;
            *pCtlStatus = QualityCtlStatus;
            *pTrustListRequestedUsage = QualityCtlSignerRequestedUsage;
            *pTrustListRequestedTime = QualityCtlSignerRequestedTime;
        }
    }
    else
    {
        SetLastError( CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( hStore != NULL )
    {
        m_pIssuerList->PurgeAdditionalStoreIssuers();
    }

    ChainEngine()->CertObjectCache()->EnableLruOfObjects( pCallContext );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CCertIssuerList, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertIssuerList::CCertIssuerList (IN PCCERTOBJECT pSubject)
{
    m_pSubject = pSubject;
    m_pIssuerPublicKey = NULL;
    m_pHead = NULL;
    m_fFlushed = FALSE;
    m_fCtlIssuerFlushed = FALSE;
    m_fAdditionalStoreProcessed = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::~CCertIssuerList, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertIssuerList::~CCertIssuerList ()
{
    Flush();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddIssuer, public
//
//  Synopsis:   add an issuer to the list
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::AddIssuer (
                    IN PCCHAINCALLCONTEXT pCallContext,
                    IN PCCERTOBJECT pIssuer,
                    IN BOOL fAdditionalStore,
                    IN BOOL fCheckForDuplicate
                    )
{
    PCERT_ISSUER_ELEMENT pElement = NULL;
    CRYPT_HASH_BLOB      HashBlob;

    if ( fCheckForDuplicate == TRUE )
    {
        HashBlob.cbData = pIssuer->CertificateHashSize();
        HashBlob.pbData = pIssuer->CertificateHash();

        if ( CheckForDuplicateElement( &HashBlob, FALSE ) == TRUE )
        {
            SetLastError( CRYPT_E_EXISTS );
            return( FALSE );
        }
    }

    if ( CreateElement(
               pCallContext,
               FALSE,
               pIssuer,
               fAdditionalStore,
               NULL,
               NULL,
               NULL,
               &pElement
               ) == FALSE )
    {
        return( FALSE );
    }

    AddElement( pElement );

    return( TRUE );
}

#ifdef CAPI_INCLUDE_CTL
//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddCtlIssuer, public
//
//  Synopsis:   add a CTL based issuer
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::AddCtlIssuer (
                    IN PCCHAINCALLCONTEXT pCallContext,
                    IN PCSSCTLOBJECT pSSCtlObject,
                    IN BOOL fAdditionalStore,
                    IN HCERTSTORE hAdditionalStore,
                    IN BOOL fCheckForDuplicate
                    )
{
    PCERT_ISSUER_ELEMENT  pElement = NULL;
    CRYPT_HASH_BLOB       HashBlob;
    PCERT_TRUST_LIST_INFO pTrustListInfo = NULL;

    assert( m_pSubject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED );

    if ( fCheckForDuplicate == TRUE )
    {
        HashBlob.cbData = pSSCtlObject->CtlHashSize();
        HashBlob.pbData = pSSCtlObject->CtlHash();

        if ( CheckForDuplicateElement( &HashBlob, TRUE ) == TRUE )
        {
            SetLastError( CRYPT_E_EXISTS );
            return( FALSE );
        }
    }

    if ( pSSCtlObject->GetTrustListInfo(
                          m_pSubject,
                          &pTrustListInfo
                          ) == FALSE )
    {
        return( FALSE );
    }

    if ( CreateElement(
               pCallContext,
               TRUE,
               NULL,
               fAdditionalStore,
               hAdditionalStore,
               pSSCtlObject,
               pTrustListInfo,
               &pElement
               ) == FALSE )
    {
        SSCtlFreeTrustListInfo( pTrustListInfo );
        return( FALSE );
    }

    AddElement( pElement );

    return( TRUE );
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::Flush, public
//
//  Synopsis:   flush the issuer list
//
//----------------------------------------------------------------------------
VOID
CCertIssuerList::Flush ()
{
    PCERT_ISSUER_ELEMENT pElement;

    while ( ( pElement = NextElement( NULL ) ) != NULL  )
    {
        RemoveElement( pElement );
        DeleteElement( pElement );
    }

    m_pIssuerPublicKey = NULL;
    m_fFlushed = TRUE;
    m_fCtlIssuerFlushed = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CtlIssuerFlush, public
//
//  Synopsis:   flush CTL issuers
//
//----------------------------------------------------------------------------
VOID
CCertIssuerList::CtlIssuerFlush (IN PCCERTOBJECT pCtlIssuer)
{
    PCERT_ISSUER_ELEMENT   pElement = NULL;
    CERT_OBJECT_IDENTIFIER CtlIssuerObjectIdentifier;
    CERT_OBJECT_IDENTIFIER IssuerObjectIdentifier;

    assert( m_pSubject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED );

    pCtlIssuer->GetObjectIdentifier( CtlIssuerObjectIdentifier );

    while ( ( pElement = NextElement( pElement ) ) != NULL )
    {
        if ( ( pElement->pIssuer == NULL ) ||
             ( pElement->fCtlIssuer == FALSE ) )
        {
            continue;
        }

        pElement->pIssuer->GetObjectIdentifier( IssuerObjectIdentifier );

        if ( ( pElement->pIssuer == pCtlIssuer ) ||
             ( memcmp(
                  CtlIssuerObjectIdentifier,
                  IssuerObjectIdentifier,
                  MD5DIGESTLEN
                  ) == 0 ) )
        {
            assert( pElement->pCtlIssuerData->fAdditionalStoreSigner == FALSE );

            pElement->pIssuer->Release();
            pElement->pIssuer = NULL;
            pElement->ChainStatus.dwErrorStatus = CERT_TRUST_CHAIN_FULL_ERROR_STATUS;
        }
    }

    m_fCtlIssuerFlushed = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::Restore, public
//
//  Synopsis:   restore issuer elements
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::Restore (IN PCCHAINCALLCONTEXT pCallContext, IN BOOL fForce)
{
    BOOL fResult = TRUE;

    if ( ( IsFlushed() == TRUE ) || ( fForce == TRUE ) )
    {
        assert( IsEmpty() == TRUE );

        fResult = m_pSubject->ChainEngine()->FindAndStoreMatchingIssuers(
                                                 m_pSubject,
                                                 pCallContext
                                                 );

        if ( fResult == TRUE )
        {
            m_fFlushed = FALSE;
            m_fCtlIssuerFlushed = FALSE;
        }
    }
    else if ( IsCtlIssuerFlushed() == TRUE )
    {
        assert( m_pSubject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED );
#ifdef CAPI_INCLUDE_CTL
        ChainFixupCtlIssuers( m_pSubject, pCallContext, NULL );
#endif

        m_fCtlIssuerFlushed = FALSE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::GetAdditionalStoreIssuers, public
//
//  Synopsis:   find issuers in the additional store and put them into the
//              issuer list
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::GetAdditionalStoreIssuers (
                    IN PCCHAINCALLCONTEXT pCallContext,
                    IN HCERTSTORE hAdditionalStore
                    )
{
    BOOL fExact = FALSE;

    m_fAdditionalStoreProcessed = TRUE;

    if ( m_pSubject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED )
    {
#ifdef CAPI_INCLUDE_CTL    
        ChainFixupCtlIssuers( m_pSubject, pCallContext, hAdditionalStore );

        return( ChainFindAndStoreCtlIssuersFromAdditionalStore(
                     m_pSubject,
                     pCallContext,
                     hAdditionalStore
                     ) );
#else
		return TRUE;
#endif		
    }

    // BUGBUG: I think I need to do a "fixupissuers" here

    return( ChainFindAndStoreMatchingIssuersFromCertStore(
                 m_pSubject,
                 pCallContext,
                 hAdditionalStore,
                 TRUE,
                 FALSE
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::PurgeAdditionalStoreIssuers, public
//
//  Synopsis:   removes issuers that have the additional store tag
//
//----------------------------------------------------------------------------
VOID
CCertIssuerList::PurgeAdditionalStoreIssuers ()
{
    PCERT_ISSUER_ELEMENT pElement = NULL;
    PCERT_ISSUER_ELEMENT pTempElement = NULL;

    while ( ( pElement = NextElement( pElement ) ) != NULL  )
    {
        if ( pElement->fAdditionalStore == TRUE )
        {
            pTempElement = pElement;
            pElement = NextElement( pElement );

            RemoveElement( pTempElement );

            if ( m_pIssuerPublicKey == &pTempElement->pIssuer->CertContext()->pCertInfo->SubjectPublicKeyInfo )
            {
                m_pIssuerPublicKey = NULL;
            }

            DeleteElement( pTempElement );
        }
        else if ( ( pElement->fCtlIssuer == TRUE ) &&
                  ( pElement->pCtlIssuerData->fAdditionalStoreSigner == TRUE ) )
        {
            pElement->ChainStatus.dwErrorStatus = CERT_TRUST_CHAIN_FULL_ERROR_STATUS;
            pElement->pIssuer->Release();
            pElement->pIssuer = NULL;
            pElement->pCtlIssuerData->fAdditionalStoreSigner = FALSE;
        }
    }

    m_fAdditionalStoreProcessed = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CreateElement, public
//
//  Synopsis:   create an element
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::CreateElement (
                       IN PCCHAINCALLCONTEXT pCallContext,
                       IN BOOL fCtlIssuer,
                       IN PCCERTOBJECT pIssuer,
                       IN BOOL fAdditionalStore,
                       IN HCERTSTORE hAdditionalStore,
                       IN PCSSCTLOBJECT pSSCtlObject,
                       IN PCERT_TRUST_LIST_INFO pTrustListInfo,
                       OUT PCERT_ISSUER_ELEMENT* ppElement
                       )
{
    BOOL                 fResult = TRUE;
    BOOL                 fCtlSignatureValid = FALSE;
    PCERT_ISSUER_ELEMENT pElement;

    pElement = new CERT_ISSUER_ELEMENT;
    if ( pElement == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    memset( pElement, 0, sizeof( CERT_ISSUER_ELEMENT ) );

    pElement->fCtlIssuer = fCtlIssuer;
    pElement->fAdditionalStore = fAdditionalStore;

    if ( fCtlIssuer == FALSE )
    {
        pElement->pIssuer = pIssuer;
        pElement->pIssuer->AddRef();

        ChainGetSubjectStatus(
             pIssuer,
             m_pIssuerPublicKey,
             m_pSubject,
             &pElement->SubjectStatus
             );

        if (  ( m_pIssuerPublicKey == NULL ) &&
             !( pElement->SubjectStatus.dwErrorStatus &
                CERT_TRUST_IS_NOT_SIGNATURE_VALID ) )
        {
            m_pIssuerPublicKey = &pIssuer->CertContext()->pCertInfo->SubjectPublicKeyInfo;
        }
    }
    else
    {
#ifdef CAPI_INCLUDE_CTL    
        pElement->pCtlIssuerData = new CTL_ISSUER_DATA;
        if ( pElement->pCtlIssuerData != NULL )
        {
            memset( pElement->pCtlIssuerData, 0, sizeof( CTL_ISSUER_DATA ) );

            pSSCtlObject->AddRef();
            pElement->pCtlIssuerData->pSSCtlObject = pSSCtlObject;
            pElement->pCtlIssuerData->pTrustListInfo = pTrustListInfo;

            pSSCtlObject->GetSigner(
                             m_pSubject,
                             pCallContext,
                             hAdditionalStore,
                             &pElement->pIssuer,
                             &pElement->pCtlIssuerData->fAdditionalStoreSigner,
                             &fCtlSignatureValid
                             );
        }
        else
        {
            SetLastError( E_OUTOFMEMORY );
            fResult = FALSE;
        }
#else
		fResult = FALSE;
#endif //CAPI_INCLUDE_CTL		
    }

    if ( fResult == TRUE )
    {
        if ( pElement->pIssuer != NULL )
        {
            pElement->ChainStatus.dwErrorStatus = pElement->pIssuer->ChainErrorStatus();

            if ( fCtlIssuer == FALSE )
            {
                pElement->ChainStatus.dwErrorStatus |= pElement->SubjectStatus.dwErrorStatus;
            }
            else if ( fCtlSignatureValid == FALSE )
            {
                pElement->ChainStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
            }
        }
        else
        {
            assert( fCtlIssuer == TRUE );

            pElement->ChainStatus.dwErrorStatus |= CERT_TRUST_CHAIN_FULL_ERROR_STATUS;
        }

        *ppElement = pElement;
    }
    else
    {
        DeleteElement( pElement );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::DeleteElement, public
//
//  Synopsis:   delete an element
//
//----------------------------------------------------------------------------
VOID
CCertIssuerList::DeleteElement (IN PCERT_ISSUER_ELEMENT pElement)
{
#ifdef CAPI_INCLUDE_CTL
    if ( pElement->fCtlIssuer == TRUE )
    {
        ChainFreeCtlIssuerData( pElement->pCtlIssuerData );
    }
#endif    

    if ( pElement->pIssuer != NULL )
    {
        pElement->pIssuer->Release();
    }

    delete pElement;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CheckForDuplicateElement, public
//
//  Synopsis:   check for a duplicate element
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::CheckForDuplicateElement (
                      IN PCRYPT_HASH_BLOB pHashBlob,
                      IN BOOL fCtlIssuer
                      )
{
    PCERT_ISSUER_ELEMENT pElement = NULL;

    while ( ( pElement = NextElement( pElement ) ) != NULL )
    {
        if ( pElement->fCtlIssuer == fCtlIssuer )
        {
            if ( fCtlIssuer == FALSE )
            {
                if ( memcmp(
                        pHashBlob->pbData,
                        pElement->pIssuer->CertificateHash(),
                        pHashBlob->cbData
                        ) == 0 )
                {
                    return( TRUE );
                }
            }
            else
            {
#ifdef CAPI_INCLUDE_CTL            
                if ( memcmp(
                        pHashBlob->pbData,
                        pElement->pCtlIssuerData->pSSCtlObject->CtlHash(),
                        pHashBlob->cbData
                        ) == 0 )
                {
                    return( TRUE );
                }
#endif                
            }
        }
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::CCertObjectCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertObjectCache::CCertObjectCache (
                       IN DWORD MaxIndexEntries,
                       OUT BOOL& rfResult
                       )
{
    LRU_CACHE_CONFIG Config;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.cBuckets = DEFAULT_CERT_OBJECT_CACHE_BUCKETS;

    m_hHashIndex = NULL;
    m_hIdentifierIndex = NULL;
    m_hKeyIdIndex = NULL;
    m_hSubjectNameIndex = NULL;
    m_hIssuerNameIndex = NULL;

    Config.pfnHash = CertObjectCacheHashNameIdentifier;

    rfResult = I_CryptCreateLruCache( &Config, &m_hSubjectNameIndex );

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hIssuerNameIndex );
    }

    Config.pfnHash = CertObjectCacheHashMd5Identifier;

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hIdentifierIndex );
    }

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hKeyIdIndex );
    }

    Config.MaxEntries = MaxIndexEntries;
    Config.pfnOnRemoval = CertObjectCacheOnRemovalFromPrimaryIndex;

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hHashIndex );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::~CCertObjectCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertObjectCache::~CCertObjectCache ()
{
    I_CryptFreeLruCache(
           m_hHashIndex,
           0,
           NULL
           );

    I_CryptFreeLruCache(
           m_hIssuerNameIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hSubjectNameIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hIdentifierIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hKeyIdIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::AddObject, public
//
//  Synopsis:   add an object to the cache
//
//----------------------------------------------------------------------------
BOOL
CCertObjectCache::AddObject (
                     IN PCCHAINCALLCONTEXT pCallContext,
                     IN PCCERTOBJECT pCertObject,
                     IN BOOL fCheckForDuplicate
                     )
{
    if ( fCheckForDuplicate == TRUE )
    {
        CRYPT_HASH_BLOB HashBlob;
        PCCERTOBJECT    pDuplicate;

        HashBlob.cbData = pCertObject->CertificateHashSize();
        HashBlob.pbData = pCertObject->CertificateHash();

        pDuplicate = FindObjectByHash( &HashBlob );
        if ( pDuplicate != NULL )
        {
            pDuplicate->Release();
            SetLastError( CRYPT_E_EXISTS );
            return( FALSE );
        }
    }

    pCertObject->AddRef();

    I_CryptInsertLruEntry( pCertObject->HashIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->IdentifierIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->SubjectNameIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->IssuerNameIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->KeyIdIndexEntry(), pCallContext );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindObjectByHash, public
//
//  Synopsis:   find object by hash
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindObjectByHash (
                      IN PCRYPT_HASH_BLOB pHash
                      )
{
    return( FindObject( m_hHashIndex, (PCRYPT_DATA_BLOB)pHash ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindObjectByIdentifier, public
//
//  Synopsis:   find object by certificate object identifier
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindObjectByIdentifier (
                      IN CERT_OBJECT_IDENTIFIER ObjectIdentifier
                      )
{
    CRYPT_DATA_BLOB DataBlob;

    DataBlob.cbData = sizeof( CERT_OBJECT_IDENTIFIER );
    DataBlob.pbData = ObjectIdentifier;

    return( FindObject( m_hIdentifierIndex, &DataBlob ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindObjectBySubjectName, public
//
//  Synopsis:   find object by subject name
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindObjectBySubjectName (
                      IN PCERT_NAME_BLOB pSubjectName
                      )
{
    return( FindObject( m_hSubjectNameIndex, (PCRYPT_DATA_BLOB)pSubjectName ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindObjectByIssuerName, public
//
//  Synopsis:   find object by issuer name
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindObjectByIssuerName (
                      IN PCERT_NAME_BLOB pIssuerName
                      )
{
    return( FindObject( m_hIssuerNameIndex, (PCRYPT_DATA_BLOB)pIssuerName ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindObjectByKeyId, public
//
//  Synopsis:   find object by key identifier
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindObjectByKeyId (
                      IN PCRYPT_HASH_BLOB pKeyId
                      )
{
    return( FindObject( m_hKeyIdIndex, (PCRYPT_DATA_BLOB)pKeyId ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::NextMatchingObjectByIdentifier, public
//
//  Synopsis:   next matching object
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::NextMatchingObjectByIdentifier (
                      IN PCCERTOBJECT pCertObject
                      )
{
    return( NextMatchingObject(
                pCertObject->IdentifierIndexEntry(),
                pCertObject
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::NextMatchingObjectBySubjectName, public
//
//  Synopsis:   next matching object
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::NextMatchingObjectBySubjectName (
                      IN PCCERTOBJECT pCertObject
                      )
{
    return( NextMatchingObject(
                pCertObject->SubjectNameIndexEntry(),
                pCertObject
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::NextMatchingObjectByIssuerName, public
//
//  Synopsis:   next matching object
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::NextMatchingObjectByIssuerName (
                      IN PCCERTOBJECT pCertObject
                      )
{
    return( NextMatchingObject(
                pCertObject->IssuerNameIndexEntry(),
                pCertObject
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::NextMatchingObjectByKeyId, public
//
//  Synopsis:   next matching object
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::NextMatchingObjectByKeyId (
                      IN PCCERTOBJECT pCertObject
                      )
{
    return( NextMatchingObject(
                pCertObject->KeyIdIndexEntry(),
                pCertObject
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::EnumObjects, public
//
//  Synopsis:   enumerate all certificate objects in the cache
//
//----------------------------------------------------------------------------
VOID
CCertObjectCache::EnumObjects (
                      IN PFN_ENUM_CERTOBJECTS pfnEnum,
                      IN LPVOID pvParameter
                      )
{
    CHAIN_ENUM_OBJECTS_DATA EnumData;

    EnumData.pfnEnumObjects = pfnEnum;
    EnumData.pvEnumParameter = pvParameter;

    I_CryptWalkAllLruCacheEntries(
           m_hHashIndex,
           ChainEnumObjectsWalkFn,
           &EnumData
           );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindObject, public
//
//  Synopsis:   find object
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindObject (
                      IN HLRUCACHE hIndex,
                      IN PCRYPT_DATA_BLOB pIdentifier
                      )
{
    HLRUENTRY    hFound;
    PCCERTOBJECT pFound = NULL;

    hFound = I_CryptFindLruEntry( hIndex, pIdentifier );
    if ( hFound != NULL )
    {
        pFound = (PCCERTOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::NextMatchingObject, public
//
//  Synopsis:   next matching object
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::NextMatchingObject (
                      IN HLRUENTRY hObjectEntry,
                      IN PCCERTOBJECT pCertObject
                      )
{
    HLRUENTRY    hFound;
    PCCERTOBJECT pFound = NULL;

    I_CryptAddRefLruEntry( hObjectEntry );

    hFound = I_CryptEnumMatchingLruEntries( hObjectEntry );
    if ( hFound != NULL )
    {
        pFound = (PCCERTOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    pCertObject->Release();

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheOnRemovalFromPrimaryIndex
//
//  Synopsis:   removes the cert object from all other indexes and also
//              removes the reference on the cert object.  It also gets rid
//              of all matching subjects and flushes the issuer lists of
//              all cert objects that have it has an issuer
//
//----------------------------------------------------------------------------
VOID WINAPI
CertObjectCacheOnRemovalFromPrimaryIndex (
    IN LPVOID pv,
    IN OPTIONAL LPVOID pvRemovalContext
    )
{
    ChainProcessRemovalNotification(
         (PCCHAINCALLCONTEXT)pvRemovalContext,
         (PCCERTOBJECT)pv,
         TRUE
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheHashMd5Identifier
//
//  Synopsis:   DWORD hash an MD5 identifier.  This is done by taking the
//              first four bytes of the MD5 hash since there is enough
//              randomness already
//
//----------------------------------------------------------------------------
DWORD WINAPI
CertObjectCacheHashMd5Identifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    )
{
    return( *( (LPDWORD)pIdentifier->pbData ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheHashNameIdentifier
//
//  Synopsis:   DWORD hash a subject or issuer name.
//
//----------------------------------------------------------------------------
DWORD WINAPI
CertObjectCacheHashNameIdentifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    )
{
    DWORD  dwHash = 0;
    DWORD  cb = pIdentifier->cbData;
    LPBYTE pb = pIdentifier->pbData;

    while ( cb-- )
    {
        if ( dwHash & 0x80000000 )
        {
            dwHash = ( dwHash << 1 ) | 1;
        }
        else
        {
            dwHash = dwHash << 1;
        }

        dwHash += *pb++;
    }

    return( dwHash );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainEnumObjectsWalkFn
//
//  Synopsis:   enumerate objects walk function
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainEnumObjectsWalkFn (
     IN LPVOID pvParameter,
     IN HLRUENTRY hEntry
     )
{
    PCHAIN_ENUM_OBJECTS_DATA pEnumData = (PCHAIN_ENUM_OBJECTS_DATA)pvParameter;

    return( ( *pEnumData->pfnEnumObjects )(
                             pEnumData->pvEnumParameter,
                             (PCCERTOBJECT)I_CryptGetLruEntryData( hEntry )
                             ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CCertChainEngine, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertChainEngine::CCertChainEngine (
                       IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
                       IN BOOL fDefaultEngine,
                       OUT BOOL& rfResult
                       )
{
    HCERTSTORE hWorld = NULL;
    DWORD      dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;

    assert( pConfig->cbSize == sizeof( CERT_CHAIN_ENGINE_CONFIG ) );

    rfResult = TRUE;

    m_cRefs = 1;
    m_hRootStore = NULL;
    m_hRealRootStore = NULL;
    m_hTrustStore = NULL;
    m_hOtherStore = NULL;
    m_hEngineStore = NULL;
    m_hEngineStoreChangeEvent = NULL;
    m_pCertObjectCache = NULL;
#ifdef CAPI_INCLUDE_CTL    
    m_pSSCtlObjectCache = NULL;
#endif    
    m_dwFlags = pConfig->dwFlags;
    m_dwUrlRetrievalTimeout = pConfig->dwUrlRetrievalTimeout;
    m_CycleDetectionModulus = pConfig->CycleDetectionModulus;

    InitializeCriticalSection( &m_Lock );

    if ( pConfig->dwFlags & CERT_CHAIN_USE_LOCAL_MACHINE_STORE )
    {
        dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }

    m_hRealRootStore = CertOpenStore(
                           CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           NULL,
                           dwStoreFlags | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                           L"root"
                           );

    if ( m_hRealRootStore == NULL )
    {
        rfResult = FALSE;
        return;
    }

    if ( pConfig->hRestrictedRoot != NULL )
    {
        if ( ChainIsProperRestrictedRoot(
                  m_hRealRootStore,
                  pConfig->hRestrictedRoot
                  ) == TRUE )
        {
            m_hRootStore = CertDuplicateStore( pConfig->hRestrictedRoot );
        }
    }
    else
    {
        m_hRootStore = CertDuplicateStore( m_hRealRootStore );
    }

    if ( m_hRootStore == NULL )
    {
        rfResult = FALSE;
        return;
    }

    if ( ( pConfig->hRestrictedTrust == NULL ) ||
         ( pConfig->hRestrictedOther == NULL ) )
    {
        rfResult = ChainCreateWorldStore(
                        m_hRootStore,
                        pConfig->cAdditionalStore,
                        pConfig->rghAdditionalStore,
                        dwStoreFlags,
                        &hWorld
                        );

        if ( rfResult == FALSE )
        {
            return;
        }
    }

    if ( pConfig->hRestrictedTrust != NULL )
    {
        m_hTrustStore = CertDuplicateStore( pConfig->hRestrictedTrust );
    }
    else
    {
        m_hTrustStore = CertDuplicateStore( hWorld );
    }

    m_hOtherStore = CertOpenStore(
                        CERT_STORE_PROV_COLLECTION,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        NULL,
                        CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                        NULL
                        );

    if ( m_hOtherStore != NULL )
    {
        if ( pConfig->hRestrictedOther != NULL )
        {
            rfResult = CertAddStoreToCollection(
                           m_hOtherStore,
                           pConfig->hRestrictedOther,
                           0,
                           0
                           );

            if ( rfResult == TRUE )
            {
                rfResult = CertAddStoreToCollection(
                               m_hOtherStore,
                               m_hRootStore,
                               0,
                               0
                               );
            }
        }
        else
        {
            rfResult = CertAddStoreToCollection(
                           m_hOtherStore,
                           hWorld,
                           0,
                           0
                           );

            if ( ( rfResult == TRUE ) && ( pConfig->hRestrictedTrust != NULL ) )
            {
                rfResult = CertAddStoreToCollection(
                               m_hOtherStore,
                               pConfig->hRestrictedTrust,
                               0,
                               0
                               );
            }
        }
    }
    else
    {
        rfResult = FALSE;
    }

    if ( hWorld != NULL )
    {
        CertCloseStore( hWorld, 0 );
    }

    if ( rfResult == TRUE )
    {
        rfResult = ChainCreateEngineStore(
                        m_hRootStore,
                        m_hTrustStore,
                        m_hOtherStore,
                        fDefaultEngine,
                        pConfig->dwFlags,
                        &m_hEngineStore,
                        &m_hEngineStoreChangeEvent
                        );
    }

    if ( rfResult == TRUE )
    {
        rfResult = ChainCreateCertificateObjectCache(
                        pConfig->MaximumCachedCertificates,
                        &m_pCertObjectCache
                        );
    }
#ifdef CAPI_INCLUDE_CTL
    if ( rfResult == TRUE )
    {
        rfResult = SSCtlCreateObjectCache( &m_pSSCtlObjectCache );
    }

    if ( rfResult == TRUE )
    {
        rfResult = m_pSSCtlObjectCache->PopulateCache( this );
    }
#endif
    assert( m_hRootStore != NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::~CCertChainEngine, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertChainEngine::~CCertChainEngine ()
{
    ChainFreeCertificateObjectCache( m_pCertObjectCache );
#ifdef CAPI_INCLUDE_CTL    
    SSCtlFreeObjectCache( m_pSSCtlObjectCache );
#endif
    if ( m_hRootStore != NULL )
    {
        CertCloseStore( m_hRootStore, 0 );
    }

    if ( m_hRealRootStore != NULL )
    {
        CertCloseStore( m_hRealRootStore, 0 );
    }

    if ( m_hTrustStore != NULL )
    {
        CertCloseStore( m_hTrustStore, 0 );
    }

    if ( m_hOtherStore != NULL )
    {
        CertCloseStore( m_hOtherStore, 0 );
    }

    if ( m_hEngineStore != NULL )
    {
        CertCloseStore( m_hEngineStore, 0 );
    }

    if ( m_hEngineStoreChangeEvent != NULL )
    {
        CloseHandle( m_hEngineStoreChangeEvent );
    }

    DeleteCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetChainContext, public
//
//  Synopsis:   get a certificate chain context
//
//              NOTE: This method acquires the engine lock
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetChainContext (
                     IN PCCERT_CONTEXT pCertContext,
                     IN LPFILETIME pTime,
                     IN LPFILETIME pCurrentTime,
                     IN HCERTSTORE hAdditionalStore,
                     IN PCERT_USAGE_MATCH pRequestedUsage,
                     IN DWORD dwFlags,
                     IN LPVOID pvReserved,
                     OUT PCCERT_CHAIN_CONTEXT* ppChainContext
                     )
{
    BOOL               fResult;
    BYTE               CertificateHash[ MD5DIGESTLEN ];
    CRYPT_HASH_BLOB    HashBlob;
    PCCERTOBJECT       pEndCertObject;
    PCCERTOBJECT       pNextEndCertObject;
    CERT_USAGE_MATCH   RequestedUsage;
    CERT_USAGE_MATCH   NextRequestedUsage;
    FILETIME           RequestedTime;
    FILETIME           NextRequestedTime;
    PCCERTCHAINCONTEXT pCertChainContext = NULL;
    DWORD              SimpleChainIndex = 0;
    BOOL               fEndCertInCache = TRUE;
    CERT_TRUST_STATUS  AdditionalStatus;
    PCCHAINCALLCONTEXT pCallContext;
    BOOL               fFromCallCreationCache = FALSE;

    HashBlob.cbData = MD5DIGESTLEN;
    HashBlob.pbData = CertificateHash;

    RequestedTime = *pTime;

    fResult = CertGetCertificateContextProperty(
                  pCertContext,
                  CERT_MD5_HASH_PROP_ID,
                  HashBlob.pbData,
                  &HashBlob.cbData
                  );

    if ( fResult == TRUE )
    {
        fResult = ChainCreateCertificateChainContext( &pCertChainContext );
    }

    if ( fResult == TRUE )
    {
        fResult = CallContextCreateCallObject( &pCallContext );
    }

    if ( fResult == FALSE )
    {
        ChainFreeCertificateChainContext( pCertChainContext );
        return( fResult );
    }

    LockEngine();

    if ( Resync( pCallContext, FALSE ) == FALSE )
    {
        UnlockEngine();
        return( FALSE );
    }

    CertObjectCache()->DisableLruOfObjects();

    pEndCertObject = m_pCertObjectCache->FindObjectByHash( &HashBlob );
    if ( pEndCertObject == NULL )
    {
        fEndCertInCache = FALSE;

        // NOTE: Currently defer passing the additional store until ::GetIssuer
        //       time.  Might want to revisit this decision.
        fResult = ChainCreateCertificateObject(
                       this,
                       pCallContext,
                       pCertContext,
                       &HashBlob,
                       NULL,
                       NULL,
                       &pEndCertObject,
                       &fFromCallCreationCache
                       );

        assert( fFromCallCreationCache == FALSE );
    }

    if ( fResult == TRUE )
    {
        fResult = ChainCopyRequestedUsage( pRequestedUsage, &RequestedUsage );
    }

    if ( fResult == TRUE )
    {
        assert( pEndCertObject != NULL );

        pEndCertObject->CalculateAdditionalStatus(
                                 &RequestedTime,
                                 &RequestedUsage,
                                 dwFlags,
                                 &AdditionalStatus
                                 );

        do
        {
            fResult = AddSimpleChain(
                         pCallContext,
                         pCertChainContext,
                         SimpleChainIndex,
                         pEndCertObject,
                         &AdditionalStatus,
                         &RequestedTime,
                         pCurrentTime,
                         hAdditionalStore,
                         &RequestedUsage,
                         dwFlags,
                         pvReserved,
                         &pNextEndCertObject,
                         &AdditionalStatus,
                         &NextRequestedUsage,
                         &NextRequestedTime
                         );

            if ( ( fResult == TRUE ) &&
                 ( ( m_dwFlags & CERT_CHAIN_CACHE_END_CERT ) ||
                   ( dwFlags & CERT_CHAIN_CACHE_END_CERT ) ) &&
                 ( fEndCertInCache == FALSE ) )
            {
                fEndCertInCache = TRUE;

                fResult = ChainCacheEndCertificate(
                               pCallContext,
                               pEndCertObject
                               );
            }

            SimpleChainIndex += 1;

            ChainFreeRequestedUsage( &RequestedUsage );
            RequestedUsage = NextRequestedUsage;
            RequestedTime = NextRequestedTime;

            pEndCertObject->Release();
            pEndCertObject = pNextEndCertObject;
        }
        while ( ( pEndCertObject != NULL ) && ( fResult == TRUE ) );
    }
    else if ( pEndCertObject != NULL )
    {
        pEndCertObject->Release();
    }

    CertObjectCache()->EnableLruOfObjects( pCallContext );

    UnlockEngine();

    if ( fResult == TRUE )
    {
#ifdef CAPI_INCLUDE_CRL    
        if ( dwFlags & CERT_CHAIN_REVOCATION_CHECK_ALL )
        {
            ChainPostProcessCheckRevocation(
                 OtherStore(),
                 pTime,
                 pCurrentTime,
                 pCertChainContext->ExposedContext(),
                 dwFlags
                 );
        }
#endif

        pCertChainContext->UpdateSummaryStatus();
        pCertChainContext->UpdateEndEntityCertContext( pCertContext );

        *ppChainContext = CertDuplicateCertificateChain(
                              pCertChainContext->ExposedContext()
                              );
    }

    CallContextFreeCallObject( pCallContext );
    ChainFreeCertificateChainContext( pCertChainContext );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::AddSimpleChain, public
//
//  Synopsis:   add a simple chain to the cert chain context
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::AddSimpleChain (
                     IN PCCHAINCALLCONTEXT pCallContext,
                     IN PCCERTCHAINCONTEXT pCertChainContext,
                     IN DWORD NewSimpleChainIndex,
                     IN PCCERTOBJECT pEndCertObject,
                     IN PCERT_TRUST_STATUS pEndAdditionalStatus,
                     IN LPFILETIME pTime,
                     IN LPFILETIME pCurrentTime,
                     IN HCERTSTORE hAdditionalStore,
                     IN PCERT_USAGE_MATCH pRequestedUsage,
                     IN DWORD dwFlags,
                     IN LPVOID pvReserved,
                     OUT PCCERTOBJECT* ppNextEndCertObject,
                     OUT PCERT_TRUST_STATUS pNextEndAdditionalStatus,
                     OUT PCERT_USAGE_MATCH pNextEndRequestedUsage,
                     OUT LPFILETIME pNextEndRequestedTime
                     )
{
    BOOL                  fResult = TRUE;
    PCCERTOBJECT          pCertObject;
    PCCERTOBJECT          pIssuerCertObject = NULL;
    CERT_TRUST_STATUS     SubjectStatus;
    CERT_TRUST_STATUS     AdditionalStatus;
    CERT_TRUST_STATUS     IssuerAdditionalStatus;
    CERT_TRUST_STATUS     CtlStatus;
    PCERT_TRUST_LIST_INFO pTrustListInfo = NULL;

    pCertObject = pEndCertObject;
    pCertObject->AddRef();

    AdditionalStatus = *pEndAdditionalStatus;

    while ( ( pCertObject != NULL ) && ( fResult == TRUE ) )
    {
        memset( &SubjectStatus, 0, sizeof( SubjectStatus ) );
        memset( &CtlStatus, 0, sizeof( CtlStatus ) );

        if ( !( pCertObject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED ) ||
              ( pCertObject->ErrorStatus() & CERT_TRUST_IS_UNTRUSTED_ROOT ) )
        {
            fResult = pCertObject->GetIssuer(
                                      pCallContext,
                                      pTime,
                                      pCurrentTime,
                                      hAdditionalStore,
                                      pRequestedUsage,
                                      dwFlags,
                                      &pIssuerCertObject,
                                      &SubjectStatus,
                                      &IssuerAdditionalStatus,
                                      &CtlStatus,
                                      &pTrustListInfo,
                                      pNextEndRequestedUsage,
                                      pNextEndRequestedTime
                                      );

            if ( fResult == FALSE )
            {
                fResult = TRUE;
                pIssuerCertObject = NULL;
                pTrustListInfo = NULL;

                memset( pNextEndRequestedUsage, 0, sizeof( CERT_USAGE_MATCH ) );
                memset( pNextEndRequestedTime, 0, sizeof( FILETIME ) );
            }
        }
        else
        {
            pIssuerCertObject = NULL;
        }

        if ( fResult == TRUE )
        {
            fResult = pCertChainContext->AddChainElement(
                                            NewSimpleChainIndex,
                                            pCertObject,
                                            &SubjectStatus,
                                            &AdditionalStatus,
                                            &CtlStatus,
                                            pTrustListInfo
                                            );
        }

        if ( fResult == TRUE )
        {
            if ( pCertObject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED )
            {
                *ppNextEndCertObject = pIssuerCertObject;
                *pNextEndAdditionalStatus = IssuerAdditionalStatus;
                pIssuerCertObject = NULL;
            }
            else if ( pIssuerCertObject == NULL )
            {
                *ppNextEndCertObject = NULL;
            }
            else
            {
                AdditionalStatus = IssuerAdditionalStatus;
            }
        }
        else
        {
            if ( GetLastError() != CERT_E_CHAINING )
            {
#ifdef CAPI_INCLUDE_CTL            
                if ( pTrustListInfo != NULL )
                {
                    SSCtlFreeTrustListInfo( pTrustListInfo );
                }
#else
				assert(!pTrustListInfo);
#endif				
            }

            if ( pIssuerCertObject != NULL )
            {
                pIssuerCertObject->Release();
            }

            ChainFreeRequestedUsage( pNextEndRequestedUsage );
            memset( pNextEndRequestedUsage, 0, sizeof( CERT_USAGE_MATCH ) );
            memset( pNextEndRequestedTime, 0, sizeof( FILETIME ) );
        }

        pCertObject->Release();
        pCertObject = pIssuerCertObject;
    }

    if ( ( fResult == FALSE ) && ( GetLastError() == CERT_E_CHAINING ) )
    {
        *ppNextEndCertObject = NULL;
        fResult = TRUE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::FindAndStoreMatchingIssuers, public
//
//  Synopsis:   find and store matching issuers
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::FindAndStoreMatchingIssuers (
                      IN PCCERTOBJECT pCertObject,
                      IN PCCHAINCALLCONTEXT pCallContext
                      )
{
    DWORD dwInfoStatus = pCertObject->InfoStatus();

    assert( pCertObject->ChainEngine() == this );

    if ( dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED )
    {
        return( FindAndStoreCtlIssuers( pCertObject, pCallContext ) );
    }

    if ( dwInfoStatus & CERT_TRUST_HAS_EXACT_MATCH_ISSUER )
    {
        return( FindAndStoreExactMatchIssuers( pCertObject, pCallContext ) );
    }
    else if ( dwInfoStatus & CERT_TRUST_HAS_KEY_MATCH_ISSUER )
    {
        return( FindAndStoreKeyMatchIssuers( pCertObject, pCallContext ) );
    }
    else if ( dwInfoStatus & CERT_TRUST_HAS_NAME_MATCH_ISSUER )
    {
        return( FindAndStoreNameMatchIssuers( pCertObject, pCallContext ) );
    }
    else
    {
        return( TRUE );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::FindAndStoreExactMatchIssuers, public
//
//  Synopsis:   find and store exact match issuers
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::FindAndStoreExactMatchIssuers (
                      IN PCCERTOBJECT pCertObject,
                      IN PCCHAINCALLCONTEXT pCallContext
                      )
{
    BOOL                        fResult = TRUE;
    PCCERTOBJECT                pIssuer;
    BOOL                        fCheckForDuplicate;
    CERT_OBJECT_IDENTIFIER      ObjectIdentifier;
    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;

    assert( pCertObject->ChainEngine() == this );

    fCheckForDuplicate = !pCertObject->IssuerList()->IsEmpty();
    pAuthKeyIdentifier = pCertObject->AuthorityKeyIdentifier();

    ChainCreateCertificateObjectIdentifier(
         &pAuthKeyIdentifier->CertIssuer,
         &pAuthKeyIdentifier->CertSerialNumber,
         ObjectIdentifier
         );

    pIssuer = CertObjectCache()->FindObjectByIdentifier( ObjectIdentifier );

    while ( pIssuer != NULL )
    {
        pCertObject->IssuerList()->AddIssuer(
                                      pCallContext,
                                      pIssuer,
                                      FALSE,
                                      fCheckForDuplicate
                                      );

        pIssuer = CertObjectCache()->NextMatchingObjectByIdentifier( pIssuer );
    }

    if ( pCertObject->IssuerList()->IsEmpty() == TRUE )
    {
        fResult = ChainFindAndStoreMatchingIssuersFromCertStore(
                       pCertObject,
                       pCallContext,
                       OtherStore(),
                       FALSE,
                       TRUE
                       );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::FindAndStoreNameMatchIssuers, public
//
//  Synopsis:   find and store name match issuers
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::FindAndStoreNameMatchIssuers (
                      IN PCCERTOBJECT pCertObject,
                      IN PCCHAINCALLCONTEXT pCallContext
                      )
{
    BOOL         fResult = TRUE;
    PCCERTOBJECT pIssuer;
    BOOL         fCheckForDuplicate;

    assert( pCertObject->ChainEngine() == this );

    fCheckForDuplicate = !pCertObject->IssuerList()->IsEmpty();

    pIssuer = CertObjectCache()->FindObjectBySubjectName(
                                     &pCertObject->CertContext()->pCertInfo->Issuer
                                     );

    while ( pIssuer != NULL )
    {
        pCertObject->IssuerList()->AddIssuer(
                                      pCallContext,
                                      pIssuer,
                                      FALSE,
                                      fCheckForDuplicate
                                      );

        pIssuer = CertObjectCache()->NextMatchingObjectBySubjectName( pIssuer );
    }

    if ( pCertObject->IssuerList()->IsEmpty() == TRUE )
    {
        fResult = ChainFindAndStoreMatchingIssuersFromCertStore(
                       pCertObject,
                       pCallContext,
                       OtherStore(),
                       FALSE,
                       TRUE
                       );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::FindAndStoreKeyMatchIssuers, public
//
//  Synopsis:   find and store key match based issuers
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::FindAndStoreKeyMatchIssuers (
                      IN PCCERTOBJECT pCertObject,
                      IN PCCHAINCALLCONTEXT pCallContext
                      )
{
    BOOL                        fResult = TRUE;
    PCCERTOBJECT                pIssuer;
    BOOL                        fCheckForDuplicate;
    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;

    assert( pCertObject->ChainEngine() == this );

    fCheckForDuplicate = !pCertObject->IssuerList()->IsEmpty();
    pAuthKeyIdentifier = pCertObject->AuthorityKeyIdentifier();

    pIssuer = CertObjectCache()->FindObjectByKeyId(
                                     &pAuthKeyIdentifier->KeyId
                                     );

    while ( pIssuer != NULL )
    {
        pCertObject->IssuerList()->AddIssuer(
                                      pCallContext,
                                      pIssuer,
                                      FALSE,
                                      fCheckForDuplicate
                                      );

        pIssuer = CertObjectCache()->NextMatchingObjectByKeyId( pIssuer );
    }

    if ( pCertObject->IssuerList()->IsEmpty() == TRUE )
    {
        fResult = ChainFindAndStoreMatchingIssuersFromCertStore(
                       pCertObject,
                       pCallContext,
                       OtherStore(),
                       FALSE,
                       TRUE
                       );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RetrieveAndStoreMatchingIssuersByUrl, public
//
//  Synopsis:   retrieve the issuers using the exact match issuer URL
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::RetrieveAndStoreMatchingIssuersByUrl (
                          IN PCCERTOBJECT pCertObject,
                          IN PCCHAINCALLCONTEXT pCallContext,
                          IN DWORD dwFlags
                          )
{
    BOOL             fResult;
    DWORD            cbUrlArray;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD            cCount;
    HCERTSTORE       hStore;
    DWORD            dwRetrievalFlags = CRYPT_RETRIEVE_MULTIPLE_OBJECTS;
    DWORD            dwCacheResultFlag;

    if ( ( m_dwFlags & CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL ) ||
         ( dwFlags & CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL ) )
    {
        dwRetrievalFlags |= CRYPT_CACHE_ONLY_RETRIEVAL;
    }

    fResult = ChainGetObjectUrl(
                   URL_OID_CERTIFICATE_ISSUER,
                   (LPVOID)pCertObject->CertContext(),
                   CRYPT_GET_URL_FROM_EXTENSION,
                   NULL,
                   &cbUrlArray,
                   NULL,
                   NULL,
                   NULL
                   );

    if ( fResult == TRUE )
    {
        pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
        if ( pUrlArray == NULL )
        {
            SetLastError( E_OUTOFMEMORY );
            return( FALSE );
        }

        fResult = ChainGetObjectUrl(
                       URL_OID_CERTIFICATE_ISSUER,
                       (LPVOID)pCertObject->CertContext(),
                       CRYPT_GET_URL_FROM_EXTENSION,
                       pUrlArray,
                       &cbUrlArray,
                       NULL,
                       NULL,
                       NULL
                       );
    }

    if ( fResult == TRUE )
    {
        for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
        {
            if ( !( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) &&
                  ( ChainIsFileOrLdapUrl( pUrlArray->rgwszUrl[ cCount ] ) == TRUE ) )
            {
                dwCacheResultFlag = CRYPT_DONT_CACHE_RESULT;
            }
            else
            {
                dwCacheResultFlag = 0;
            }

            fResult = ChainRetrieveObjectByUrlW(
                           pUrlArray->rgwszUrl[ cCount ],
                           CONTEXT_OID_CERTIFICATE,
                           dwRetrievalFlags | dwCacheResultFlag,
                           m_dwUrlRetrievalTimeout,
                           (LPVOID *)&hStore,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                           );

            if ( fResult == TRUE )
            {
                fResult = ChainFindAndStoreMatchingIssuersFromCertStore(
                               pCertObject,
                               pCallContext,
                               hStore,
                               FALSE,
                               TRUE
                               );

                CertCloseStore( hStore, 0 );
                break;
            }
        }
    }

    delete (LPBYTE)pUrlArray;

    // NOTE: Need to somehow log that we tried to retrieve the issuer but
    //       it was inaccessible

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::FindAndStoreCtlIssuers, public
//
//  Synopsis:   find and store CTL based issuers from the engine
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::FindAndStoreCtlIssuers (
                      IN PCCERTOBJECT pCertObject,
                      IN PCCHAINCALLCONTEXT pCallContext
                      )
{

    assert( pCertObject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED );

    if ( !( pCertObject->ErrorStatus() & CERT_TRUST_IS_UNTRUSTED_ROOT ) )
    {
        return( TRUE );
    }
#ifdef CAPI_INCLUDE_CTL
    CTL_ISSUERS_ENUM_DATA EnumData;
    EnumData.pCertObject = pCertObject;
    EnumData.pCallContext = pCallContext;

    m_pSSCtlObjectCache->EnumObjects(
                             ChainFindAndStoreCtlIssuersEnumFn,
                             &EnumData
                             );
#endif                             

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::Resync, public
//
//  Synopsis:   resync the store if necessary
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::Resync (IN PCCHAINCALLCONTEXT pCallContext, BOOL fForce)
{
    BOOL fResult;

    if ( fForce == FALSE )
    {
        if ( WaitForSingleObject(
                 m_hEngineStoreChangeEvent,
                 0
                 ) != WAIT_OBJECT_0 )
        {
            return( TRUE );
        }
    }

    // BUGBUG: Should I trap errors from this or just continue with the current
    //         state of the engine store without resync??
    CertControlStore(
        m_hEngineStore,
        0,
        CERT_STORE_CTRL_RESYNC,
        &m_hEngineStoreChangeEvent
        );

    m_pCertObjectCache->FlushObjects( pCallContext );

#ifdef CAPI_INCLUDE_CTL
    fResult = m_pSSCtlObjectCache->Resync( this );
#else
	fResult = TRUE;
#endif	

    assert( fResult == TRUE );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::CCertChainContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertChainContext::CCertChainContext (OUT BOOL& rfResult)
{
    rfResult = TRUE;

    m_pContext = new INTERNAL_CERT_CHAIN_CONTEXT;
    if ( m_pContext != NULL )
    {
        memset( m_pContext, 0, sizeof( INTERNAL_CERT_CHAIN_CONTEXT ) );

        m_pContext->cRefs = 1;
        m_pContext->ChainContext.cbSize = sizeof( CERT_CHAIN_CONTEXT );

        rfResult = GrowSimpleChains( INITIAL_CHAIN_ALLOC );
    }
    else
    {
        SetLastError( E_OUTOFMEMORY );
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::~CCertChainContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertChainContext::~CCertChainContext ()
{
    ChainReleaseInternalChainContext( m_pContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::AddChainElement, public
//
//  Synopsis:   add a chain element to a specified simple chain in the context
//
//----------------------------------------------------------------------------
BOOL
CCertChainContext::AddChainElement (
                      IN DWORD SimpleChain,
                      IN PCCERTOBJECT pCertObject,
                      IN PCERT_TRUST_STATUS pSubjectStatus,
                      IN PCERT_TRUST_STATUS pAdditionalStatus,
                      IN PCERT_TRUST_STATUS pCtlStatus,
                      IN PCERT_TRUST_LIST_INFO pTrustListInfo
                      )
{
    BOOL                fResult = TRUE;
    PCERT_CHAIN_ELEMENT pCurrentElement;
    PCERT_SIMPLE_CHAIN  pChain;

    if ( SimpleChain >= m_pContext->cSimpleChain )
    {
        fResult = GrowSimpleChains(
                      max(
                       GROW_CHAIN_ALLOC,
                       SimpleChain - m_pContext->cSimpleChain + 1
                       )
                      );
    }

    if ( ( fResult == TRUE ) &&
         ( m_pContext->ChainContext.rgpChain[ SimpleChain ]->cElement ==
           m_pContext->rgElementCount[ SimpleChain ] ) )
    {
        fResult = GrowChainElements( SimpleChain, GROW_ELEMENT_ALLOC );
    }

    if ( fResult == FALSE )
    {
        return( fResult );
    }

    pChain = m_pContext->ChainContext.rgpChain[ SimpleChain ];
    pCurrentElement = pChain->rgpElement[ pChain->cElement ];

    pCurrentElement->pCertContext = CertDuplicateCertificateContext(
                                        pCertObject->CertContext()
                                        );

    ChainOrInStatusBits(
         &pCurrentElement->TrustStatus,
         pCertObject->TrustStatus()
         );

    ChainOrInStatusBits( &pCurrentElement->TrustStatus, pAdditionalStatus );
    ChainOrInStatusBits( &pCurrentElement->TrustStatus, pSubjectStatus );

    if ( pCertObject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED )
    {
        pChain->pTrustListInfo = pTrustListInfo;

        ChainOrInStatusBits( &pChain->TrustStatus, pCtlStatus );
    }

    pChain->cElement += 1;
    m_pContext->TotalElements += 1;

    m_pContext->ChainContext.cChain = max(
                                       m_pContext->ChainContext.cChain,
                                       SimpleChain + 1
                                       );

    if ( ( m_pContext->TotalElements % pCertObject->ChainEngine()->CycleDetectionModulus() ) == 0 )
    {
        if ( ChainIsCertificateObjectRepeatedInContext(
                  pCertObject,
                  &m_pContext->ChainContext
                  ) == TRUE )
        {
            ChainFindAndAdjustChainContextToCycle(
                 &m_pContext->ChainContext
                 );

            SetLastError( CERT_E_CHAINING );
            return( FALSE );
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::UpdateEndEntityCertContext, public
//
//  Synopsis:   update the end entity cert context in the chain context
//
//----------------------------------------------------------------------------
VOID
CCertChainContext::UpdateEndEntityCertContext (PCCERT_CONTEXT pEndCertContext)
{
    PCCERT_CONTEXT pCertContext;

    if ( m_pContext->ChainContext.rgpChain[0]->rgpElement[0]->pCertContext ==
         pEndCertContext )
    {
        return;
    }

    pCertContext = m_pContext->ChainContext.rgpChain[0]->rgpElement[0]->pCertContext;
    m_pContext->ChainContext.rgpChain[0]->rgpElement[0]->pCertContext = pEndCertContext;

#ifdef CMS_PKCS7
    {
        DWORD cbData;
        DWORD cbEndData;

        // If the chain context's end context has the public key parameter
        // property and the end context passed in to CertGetCertificateChain
        // doesn't, then copy the public key parameter property.
        if (CertGetCertificateContextProperty(
                pCertContext,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbData) && 0 < cbData &&
            !CertGetCertificateContextProperty(
                pEndCertContext,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbEndData))
        {
            BYTE *pbData;

            __try {
                pbData = (BYTE *) _alloca(cbData);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                pbData = NULL;
            }
            if (pbData)
            {
                if (CertGetCertificateContextProperty(
                        pCertContext,
                        CERT_PUBKEY_ALG_PARA_PROP_ID,
                        pbData,
                        &cbData))
                {
                    CRYPT_DATA_BLOB Para;
                    Para.pbData = pbData;
                    Para.cbData = cbData;
                    CertSetCertificateContextProperty(
                        pEndCertContext,
                        CERT_PUBKEY_ALG_PARA_PROP_ID,
                        CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                        &Para
                        );
                }
            }
        }
    }
#endif

    CertDuplicateCertificateContext( pEndCertContext );
    CertFreeCertificateContext( pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::UpdateSummaryStatus, public
//
//  Synopsis:   update the summary status for simple chains and the context
//
//----------------------------------------------------------------------------
VOID
CCertChainContext::UpdateSummaryStatus ()
{
    PCERT_SIMPLE_CHAIN pChain;
    DWORD              cChain;
    DWORD              cElement;

    ChainFixupUntrustedRootElementStatus( &m_pContext->ChainContext );

    for ( cChain = 0; cChain < m_pContext->ChainContext.cChain; cChain++ )
    {
        pChain = m_pContext->ChainContext.rgpChain[ cChain ];

        assert( pChain->cElement > 0 );

        for ( cElement = 0;
              cElement < pChain->cElement;
              cElement++ )
        {
            ChainUpdateSummaryStatusByTrustStatus(
                 &pChain->TrustStatus,
                 &pChain->rgpElement[ cElement ]->TrustStatus
                 );
        }

        if ( !( pChain->rgpElement[ pChain->cElement - 1 ]->TrustStatus.dwInfoStatus &
                CERT_TRUST_IS_SELF_SIGNED ) )
        {
            pChain->TrustStatus.dwErrorStatus |= CERT_TRUST_IS_PARTIAL_CHAIN;
        }

        ChainUpdateSummaryStatusByTrustStatus(
             &m_pContext->ChainContext.TrustStatus,
             &pChain->TrustStatus
             );
    }

    if ( m_pContext->ChainContext.cChain > 1 )
    {
        m_pContext->ChainContext.TrustStatus.dwInfoStatus |= CERT_TRUST_IS_COMPLEX_CHAIN;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::GrowSimpleChains, private
//
//  Synopsis:   grow the number of simple chains allocated
//
//----------------------------------------------------------------------------
BOOL
CCertChainContext::GrowSimpleChains (IN DWORD cGrowChain)
{
    BOOL                fResult = TRUE;
    DWORD               cSimpleChain;
    PCERT_SIMPLE_CHAIN* rgpChain;
    DWORD*              rgElementCount;
    DWORD               cCount;

    cSimpleChain = m_pContext->cSimpleChain + cGrowChain;
    rgpChain = new PCERT_SIMPLE_CHAIN [ cSimpleChain ];
    rgElementCount = new DWORD [ cSimpleChain ];

    if ( ( rgpChain != NULL ) && ( rgElementCount != NULL ) )
    {
        memset( rgpChain, 0, cSimpleChain * sizeof( PCERT_SIMPLE_CHAIN ) );
        memset( rgElementCount, 0, cSimpleChain * sizeof( DWORD ) );

        for ( cCount = m_pContext->cSimpleChain;
              ( cCount < cSimpleChain ) && ( fResult == TRUE );
              cCount++ )
        {
            rgpChain[ cCount ] = new CERT_SIMPLE_CHAIN;
            if ( rgpChain[ cCount ] != NULL )
            {
                memset( rgpChain[ cCount ], 0, sizeof( CERT_SIMPLE_CHAIN ) );
                rgpChain[ cCount ]->cbSize = sizeof( CERT_SIMPLE_CHAIN );
            }
            else
            {
                fResult = FALSE;
            }
        }
    }
    else
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        if ( m_pContext->ChainContext.rgpChain != NULL )
        {
            memcpy(
               rgpChain,
               m_pContext->ChainContext.rgpChain,
               m_pContext->ChainContext.cChain * sizeof( PCERT_SIMPLE_CHAIN )
               );

            memcpy(
               rgElementCount,
               m_pContext->rgElementCount,
               m_pContext->ChainContext.cChain * sizeof( DWORD )
               );

            delete m_pContext->ChainContext.rgpChain;
            delete m_pContext->rgElementCount;
        }

        m_pContext->cSimpleChain = cSimpleChain;
        m_pContext->ChainContext.rgpChain = rgpChain;
        m_pContext->rgElementCount = rgElementCount;
    }
    else
    {
        for ( cCount = m_pContext->cSimpleChain;
              cCount < cSimpleChain;
              cCount++ )
        {
            delete rgpChain[ cCount ];
        }

        delete rgpChain;
        delete rgElementCount;

        SetLastError( E_OUTOFMEMORY );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::GrowChainElements, public
//
//  Synopsis:   grow the number of chain elements in a particular simple chain
//
//----------------------------------------------------------------------------
BOOL
CCertChainContext::GrowChainElements (
                       IN DWORD SimpleChain,
                       IN DWORD cGrowElement
                       )
{
    BOOL                 fResult = TRUE;
    DWORD                cElement;
    PCERT_CHAIN_ELEMENT* rgpElement;
    DWORD                cCount;

    assert( m_pContext->ChainContext.rgpChain[ SimpleChain ]->cElement ==
            m_pContext->rgElementCount[ SimpleChain ] );

    cElement = m_pContext->rgElementCount[ SimpleChain ] + cGrowElement;
    rgpElement = new PCERT_CHAIN_ELEMENT [ cElement ];
    if ( rgpElement != NULL )
    {
        memset( rgpElement, 0, cElement * sizeof( PCERT_CHAIN_ELEMENT ) );

        for ( cCount = m_pContext->rgElementCount[ SimpleChain ];
              ( cCount < cElement ) && ( fResult == TRUE );
              cCount++ )
        {
            rgpElement[ cCount ] = new CERT_CHAIN_ELEMENT;
            if ( rgpElement[ cCount ] != NULL )
            {
                memset( rgpElement[ cCount ], 0, sizeof( CERT_CHAIN_ELEMENT ) );
                rgpElement[ cCount ]->cbSize = sizeof( CERT_CHAIN_ELEMENT );
            }
            else
            {
                fResult = FALSE;
            }
        }
    }
    else
    {
        cElement = m_pContext->rgElementCount[ SimpleChain ];
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        if ( m_pContext->ChainContext.rgpChain[ SimpleChain ]->rgpElement != NULL )
        {
            memcpy(
               rgpElement,
               m_pContext->ChainContext.rgpChain[ SimpleChain ]->rgpElement,
               m_pContext->ChainContext.rgpChain[ SimpleChain ]->cElement *
               sizeof( PCERT_CHAIN_ELEMENT )
               );

            delete m_pContext->ChainContext.rgpChain[ SimpleChain ]->rgpElement;
        }

        m_pContext->ChainContext.rgpChain[ SimpleChain ]->rgpElement = rgpElement;
        m_pContext->rgElementCount[ SimpleChain ] = cElement;
    }
    else
    {
        for ( cCount = m_pContext->rgElementCount[ SimpleChain ];
              cCount < cElement;
              cCount++ )
        {
            delete rgpElement[ cCount ];
        }

        delete rgpElement;

        SetLastError( E_OUTOFMEMORY );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertificateObjectIdentifier
//
//  Synopsis:   create an object identifier given the issuer name and serial
//              number.  This is done using an MD5 hash over the content
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainCreateCertificateObjectIdentifier (
     IN PCERT_NAME_BLOB pIssuer,
     IN PCRYPT_INTEGER_BLOB pSerialNumber,
     OUT CERT_OBJECT_IDENTIFIER ObjectIdentifier
     )
{
    MD5_CTX md5ctx;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pIssuer->pbData, pIssuer->cbData );
    MD5Update( &md5ctx, pSerialNumber->pbData, pSerialNumber->cbData );

    MD5Final( &md5ctx );

    memcpy( ObjectIdentifier, md5ctx.digest, MD5DIGESTLEN );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetCertificateUsage
//
//  Synopsis:   get the merged enhanced key usage from the certificate context
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetCertificateUsage (
     IN PCCERT_CONTEXT pCertContext,
     OUT PCERT_ENHKEY_USAGE* ppUsage
     )
{
    BOOL               fResult;
    int                cUsage;
    DWORD              cbUsage = 0;
    DWORD              cbStruct;
    PCERT_ENHKEY_USAGE pUsage = NULL;

    fResult = CertGetValidUsages(
                  1,
                  &pCertContext,
                  &cUsage,
                  NULL,
                  &cbUsage
                  );

    if ( fResult == TRUE )
    {
        if ( cUsage == -1 )
        {
            *ppUsage = NULL;
            return( TRUE );
        }

        cbStruct = sizeof( CERT_ENHKEY_USAGE );
        pUsage = (PCERT_ENHKEY_USAGE)new BYTE [ cbUsage + cbStruct ];
        if ( pUsage != NULL )
        {
            pUsage->rgpszUsageIdentifier = (LPSTR*)( (LPBYTE)pUsage + cbStruct );

            fResult =  CertGetValidUsages(
                           1,
                           &pCertContext,
                           &cUsage,
                           pUsage->rgpszUsageIdentifier,
                           &cbUsage
                           );
        }
        else
        {
            SetLastError( E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        pUsage->cUsageIdentifier = (DWORD)cUsage;
        *ppUsage = pUsage;
    }
    else
    {
        delete (LPBYTE)pUsage;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCertificateUsage
//
//  Synopsis:   free the usage retrieved by ChainGetCertificateUsage
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCertificateUsage (
     IN PCERT_ENHKEY_USAGE pUsage
     )
{
    delete (LPBYTE)pUsage;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateIssuerList
//
//  Synopsis:   create the issuer list object for the given subject
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateIssuerList (
     IN PCCERTOBJECT pSubject,
     OUT PCCERTISSUERLIST* ppIssuerList
     )
{
    PCCERTISSUERLIST pIssuerList;

    pIssuerList = new CCertIssuerList( pSubject );
    if ( pIssuerList == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    *ppIssuerList = pIssuerList;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeIssuerList
//
//  Synopsis:   free the issuer list object
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeIssuerList (
     IN PCCERTISSUERLIST pIssuerList
     )
{
    delete pIssuerList;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetSelfSignedStatus
//
//  Synopsis:   return status bits specifying if the certificate is self signed
//              and if so, if it is signature valid
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetSelfSignedStatus (
     IN PCCERTOBJECT pCertObject,
     OUT PCERT_TRUST_STATUS pStatus
     )
{
    assert( ( pCertObject->InfoStatus() & CERT_TRUST_HAS_NAME_MATCH_ISSUER ) ||
            ( pCertObject->InfoStatus() & CERT_TRUST_HAS_EXACT_MATCH_ISSUER ) ||
            ( pCertObject->InfoStatus() & CERT_TRUST_HAS_KEY_MATCH_ISSUER ) );

    memset( pStatus, 0, sizeof( CERT_TRUST_STATUS ) );

    if ( ChainIsMatchingIssuerCertificate(
              pCertObject,
              pCertObject->CertContext()
              ) == TRUE )
    {
        pStatus->dwInfoStatus |= CERT_TRUST_IS_SELF_SIGNED;
    }

    if ( pStatus->dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED )
    {
#ifdef CMS_PKCS7
        if (!CryptVerifyCertificateSignatureEx(
                NULL,                   // hCryptProv
                X509_ASN_ENCODING,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pCertObject->CertContext(),
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pCertObject->CertContext(),
                0,                      // dwFlags
                NULL                    // pvReserved
                ))
#else
        if ( CryptVerifyCertificateSignature(
                  NULL,
                  X509_ASN_ENCODING,
                  pCertObject->CertContext()->pbCertEncoded,
                  pCertObject->CertContext()->cbCertEncoded,
                  &pCertObject->CertContext()->pCertInfo->SubjectPublicKeyInfo
                  ) == FALSE )
#endif
        {
            pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetRootStoreStatus
//
//  Synopsis:   determine if the certificate with the given hash is in the
//              root store
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetRootStoreStatus (
     IN HCERTSTORE hRoot,
     IN HCERTSTORE hRealRoot,
     IN PCRYPT_HASH_BLOB pMd5Hash,
     OUT PCERT_TRUST_STATUS pStatus
     )
{
    PCCERT_CONTEXT pCertContext;

    memset( pStatus, 0, sizeof( CERT_TRUST_STATUS ) );

    // BUGBUG: PhilH needs to optimize this.
    pCertContext = CertFindCertificateInStore(
                       hRoot,
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       0,
                       CERT_FIND_MD5_HASH,
                       (LPVOID)pMd5Hash,
                       NULL
                       );

    if ( pCertContext == NULL )
    {
        pStatus->dwErrorStatus = CERT_TRUST_IS_UNTRUSTED_ROOT;
    }
    else
    {
        CertFreeCertificateContext( pCertContext );

        if ( hRoot == hRealRoot )
        {
            return;
        }

        pCertContext = CertFindCertificateInStore(
                           hRealRoot,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           0,
                           CERT_FIND_MD5_HASH,
                           (LPVOID)pMd5Hash,
                           NULL
                           );

        if ( pCertContext == NULL )
        {
            pStatus->dwErrorStatus = CERT_TRUST_IS_UNTRUSTED_ROOT;
        }
        else
        {
            CertFreeCertificateContext( pCertContext );
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetIssuerMatchStatus
//
//  Synopsis:   return status bits specifying what type of issuer matching
//              will be done for this certificate and if available return the
//              decoded authority key identifier extension
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetIssuerMatchStatus (
     IN PCCERT_CONTEXT pCertContext,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier,
     OUT PCERT_TRUST_STATUS pStatus
     )
{
    BOOL                         fResult = FALSE;
    PCERT_EXTENSION              pExt;
    PCERT_AUTHORITY_KEY_ID_INFO  pAuthKeyIdInfo = NULL;
    PCERT_AUTHORITY_KEY_ID2_INFO pAuthKeyIdInfo2 = NULL;
    DWORD                        cbData = 0;
    LPVOID                       pv = NULL;
    BOOL                         fV1AuthKeyIdInfo = TRUE;

    memset( pStatus, 0, sizeof( CERT_TRUST_STATUS ) );

    pExt = CertFindExtension(
               szOID_AUTHORITY_KEY_IDENTIFIER,
               pCertContext->pCertInfo->cExtension,
               pCertContext->pCertInfo->rgExtension
               );

    if ( pExt == NULL )
    {
        fV1AuthKeyIdInfo = FALSE;

        pExt = CertFindExtension(
                   szOID_AUTHORITY_KEY_IDENTIFIER2,
                   pCertContext->pCertInfo->cExtension,
                   pCertContext->pCertInfo->rgExtension
                   );
    }

    if ( pExt != NULL )
    {
        fResult = CryptDecodeObject(
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       pExt->pszObjId,
                       pExt->Value.pbData,
                       pExt->Value.cbData,
                       0,
                       NULL,
                       &cbData
                       );

        if ( fResult == TRUE )
        {
            pv = (LPVOID)new BYTE [ cbData ];
            if ( pv != NULL )
            {
                fResult = CryptDecodeObject(
                               X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               pExt->pszObjId,
                               pExt->Value.pbData,
                               pExt->Value.cbData,
                               0,
                               pv,
                               &cbData
                               );
            }
            else
            {
                SetLastError( E_OUTOFMEMORY );
                fResult = FALSE;
            }
        }
    }

    if ( fResult == TRUE )
    {
        PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier = NULL;

        if ( fV1AuthKeyIdInfo == FALSE )
        {
            // NOTENOTE: Yes, this is a bit backwards but, right now but the
            //           V1 structure is a bit easier to deal with and we
            //           only support the V1 version of the V2 structure
            //           anyway
            fResult = ChainConvertAuthKeyIdentifierFromV2ToV1(
                           (PCERT_AUTHORITY_KEY_ID2_INFO)pv,
                           &pAuthKeyIdentifier
                           );

            delete (LPBYTE)pv;
        }
        else
        {
            pAuthKeyIdentifier = (PCERT_AUTHORITY_KEY_ID_INFO)pv;
        }

        if ( pAuthKeyIdentifier != NULL )
        {
            if ( ( pAuthKeyIdentifier->CertIssuer.cbData != 0 ) &&
                 ( pAuthKeyIdentifier->CertSerialNumber.cbData != 0 ) )
            {
                pStatus->dwInfoStatus |= CERT_TRUST_HAS_EXACT_MATCH_ISSUER;
                *ppAuthKeyIdentifier = pAuthKeyIdentifier;
            }
            else if ( pAuthKeyIdentifier->KeyId.cbData != 0 )
            {
                pStatus->dwInfoStatus |= CERT_TRUST_HAS_KEY_MATCH_ISSUER;
                *ppAuthKeyIdentifier = pAuthKeyIdentifier;
            }
            else
            {
                pStatus->dwInfoStatus |= CERT_TRUST_HAS_NAME_MATCH_ISSUER;

                delete (LPBYTE)pAuthKeyIdentifier;
                *ppAuthKeyIdentifier = NULL;
            }
        }
    }

    if ( fResult == FALSE )
    {
        pStatus->dwInfoStatus |= CERT_TRUST_HAS_NAME_MATCH_ISSUER;
        *ppAuthKeyIdentifier = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeAuthorityKeyIdentifier
//
//  Synopsis:   free the authority key identifier
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeAuthorityKeyIdentifier (
     IN PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdInfo
     )
{
    delete (LPBYTE)pAuthKeyIdInfo;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetUsageStatus
//
//  Synopsis:   get the usage status
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetUsageStatus (
     IN PCERT_ENHKEY_USAGE pRequestedUsage,
     IN PCERT_ENHKEY_USAGE pAvailableUsage,
     IN DWORD dwMatchType,
     OUT PCERT_TRUST_STATUS pStatus
     )
{
    DWORD cRequested;
    DWORD cAvailable;
    DWORD cFound;
    BOOL  fFound;

    memset( pStatus, 0, sizeof( CERT_TRUST_STATUS ) );

    if ( pAvailableUsage == NULL )
    {
        return;
    }

    if ( ( pRequestedUsage->cUsageIdentifier >
           pAvailableUsage->cUsageIdentifier ) &&
         ( dwMatchType == USAGE_MATCH_TYPE_AND ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
        return;
    }

    for ( cRequested = 0, cFound = 0;
          cRequested < pRequestedUsage->cUsageIdentifier;
          cRequested++ )
    {
        for ( cAvailable = 0, fFound = FALSE;
              ( cAvailable < pAvailableUsage->cUsageIdentifier ) &&
              ( fFound == FALSE );
              cAvailable++ )
        {
            // NOTE: Optimize compares of OIDs.  Perhaps with a different
            //       encoding
            if ( strcmp(
                    pRequestedUsage->rgpszUsageIdentifier[ cRequested ],
                    pAvailableUsage->rgpszUsageIdentifier[ cAvailable ]
                    ) == 0 )
            {
                fFound = TRUE;
            }
        }

        if ( fFound == TRUE )
        {
            cFound += 1;
        }
    }

    if ( ( dwMatchType == USAGE_MATCH_TYPE_AND ) &&
         ( cFound != pRequestedUsage->cUsageIdentifier ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    }
    else if ( ( dwMatchType == USAGE_MATCH_TYPE_OR ) &&
              ( cFound == 0 ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFindAndStoreMatchingIssuersFromCertStore
//
//  Synopsis:   search the given certificate store for issuers of the
//              certificate object.  Store the issuers in the certificate
//              object's issuer list and the certificate object cache as
//              necessary
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFindAndStoreMatchingIssuersFromCertStore (
     IN PCCERTOBJECT pCertObject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN HCERTSTORE hStore,
     IN BOOL fAdditionalStore,
     IN BOOL fCacheIssuers
     )
{
    PCCERT_CONTEXT    pCertContext = NULL;
    PCCERTOBJECT      pIssuer = NULL;
    BYTE              CertificateHash[ MD5DIGESTLEN ];
    CRYPT_HASH_BLOB   HashBlob;
    PCCERTOBJECTCACHE pCertObjectCache;
    BOOL              fObjectInCache;
    BOOL              fMarkAsAdditionalStore;
    HCERTSTORE        hStoreToUse = NULL;
    HCERTSTORE        hCacheIssuersStore = NULL;
    HCERTSTORE        hIssuerListStore = NULL;
    BOOL              fFromCallCreationCache = FALSE;

    HashBlob.cbData = MD5DIGESTLEN;
    HashBlob.pbData = CertificateHash;

    pCertObjectCache = pCertObject->ChainEngine()->CertObjectCache();

    if ( fAdditionalStore == TRUE )
    {
        if ( ChainCreateCollectionIncludingCtlCertificates(
                  hStore,
                  &hStoreToUse
                  ) == FALSE )
        {
            hStoreToUse = CertDuplicateStore( hStore );
        }
    }
    else
    {
        hStoreToUse = CertDuplicateStore( hStore );
    }

    if ( ChainCreateIssuerMatchStores(
              pCertObject,
              hStoreToUse,
              fCacheIssuers,
              &hCacheIssuersStore,
              &hIssuerListStore
              ) == FALSE )
    {
        CertCloseStore( hStoreToUse, 0 );
        return( TRUE );
    }

    pCertObjectCache->DisableLruOfObjects();

    while ( ( pCertContext = CertEnumCertificatesInStore(
                                 hCacheIssuersStore,
                                 pCertContext
                                 ) ) != NULL )
    {
        if ( CertGetCertificateContextProperty(
                 pCertContext,
                 CERT_MD5_HASH_PROP_ID,
                 CertificateHash,
                 &HashBlob.cbData
                 ) == TRUE )
        {
            pIssuer = pCertObjectCache->FindObjectByHash( &HashBlob );
        }

        if ( pIssuer == NULL )
        {
            if ( ChainCreateCertificateObject(
                      pCertObject->ChainEngine(),
                      pCallContext,
                      pCertContext,
                      &HashBlob,
                      NULL,
                      ( fAdditionalStore == TRUE ) ? hStoreToUse : NULL,
                      &pIssuer,
                      &fFromCallCreationCache
                      ) == TRUE )
            {
                if ( fFromCallCreationCache == FALSE )
                {
                    pCertObjectCache->AddObject(
                                         pCallContext,
                                         pIssuer,
                                         FALSE
                                         );
                }

                pIssuer->Release();
            }
        }
        else
        {
            pIssuer->Release();
        }

        pIssuer = NULL;
    }

    assert( pIssuer == NULL );

    while ( ( pCertContext = CertEnumCertificatesInStore(
                                 hIssuerListStore,
                                 pCertContext
                                 ) ) != NULL )
    {
        if ( CertGetCertificateContextProperty(
                 pCertContext,
                 CERT_MD5_HASH_PROP_ID,
                 CertificateHash,
                 &HashBlob.cbData
                 ) == TRUE )
        {
            pIssuer = pCertObjectCache->FindObjectByHash( &HashBlob );
        }

        fObjectInCache = TRUE;
        fFromCallCreationCache = FALSE;

        if ( pIssuer == NULL )
        {
            fObjectInCache = FALSE;

            ChainCreateCertificateObject(
                 pCertObject->ChainEngine(),
                 pCallContext,
                 pCertContext,
                 &HashBlob,
                 NULL,
                 ( fAdditionalStore == TRUE ) ? hStoreToUse : NULL,
                 &pIssuer,
                 &fFromCallCreationCache
                 );
        }

        if ( pIssuer != NULL )
        {
            fMarkAsAdditionalStore = FALSE;

            if ( ( fAdditionalStore == TRUE ) && ( fObjectInCache == FALSE ) )
            {
                fMarkAsAdditionalStore = TRUE;
            }

            pCertObject->IssuerList()->AddIssuer(
                                          pCallContext,
                                          pIssuer,
                                          fMarkAsAdditionalStore,
                                          fFromCallCreationCache
                                          );

            pIssuer->Release();
            pIssuer = NULL;
        }
    }

    pCertObjectCache->EnableLruOfObjects( pCallContext );

    CertCloseStore( hStoreToUse, 0 );
    CertCloseStore( hCacheIssuersStore, 0 );
    CertCloseStore( hIssuerListStore, 0 );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateIssuerMatchStores
//
//  Synopsis:   create stores that contain all related issuers as well as the
//              matching issuers for the cert object's issuer list
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateIssuerMatchStores (
     IN PCCERTOBJECT pCertObject,
     IN HCERTSTORE hStore,
     IN BOOL fCacheIssuers,
     OUT HCERTSTORE* phCacheIssuersStore,
     OUT HCERTSTORE* phIssuerListStore
     )
{
    HCERTSTORE      hCacheIssuersStore = NULL;
    HCERTSTORE      hIssuerListStore = NULL;
    DWORD           dwInfoStatus;
    PCCERT_CONTEXT  pCertContext = NULL;
    PCCERT_CONTEXT  pSampleIssuer = NULL;
    DWORD           cbKeyIdentifier = 0;
    LPBYTE          pbKeyIdentifier = NULL;
    CRYPT_HASH_BLOB HashBlob;

    dwInfoStatus = pCertObject->InfoStatus();

    hCacheIssuersStore = CertOpenStore(
                             CERT_STORE_PROV_MEMORY,
                             X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                             NULL,
                             CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                             NULL
                             );

    if ( hCacheIssuersStore == NULL )
    {
        return( FALSE );
    }

    hIssuerListStore = CertOpenStore(
                           CERT_STORE_PROV_MEMORY,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           NULL,
                           CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                           NULL
                           );

    if ( hIssuerListStore == NULL )
    {
        CertCloseStore( hCacheIssuersStore, 0 );
        return( FALSE );
    }

    while ( ( pCertContext = CertEnumCertificatesInStore(
                                 hStore,
                                 pCertContext
                                 ) ) != NULL )
    {
        if ( ChainIsMatchingIssuerCertificate(
                  pCertObject,
                  pCertContext
                  ) == TRUE )
        {
            CertAddCertificateLinkToStore(
                hIssuerListStore,
                pCertContext,
                CERT_STORE_ADD_NEW,
                NULL
                );

            if ( fCacheIssuers == TRUE )
            {
                CertAddCertificateLinkToStore(
                    hCacheIssuersStore,
                    pCertContext,
                    CERT_STORE_ADD_NEW,
                    NULL
                    );
            }
        }
    }

    assert( pCertContext == NULL );
    assert( pSampleIssuer == NULL );

    if ( fCacheIssuers == TRUE )
    {
        pSampleIssuer = CertEnumCertificatesInStore( hIssuerListStore, NULL );
    }

    if ( pSampleIssuer != NULL )
    {
        if ( !( dwInfoStatus & CERT_TRUST_HAS_NAME_MATCH_ISSUER ) )
        {
            while ( ( pCertContext = CertFindCertificateInStore(
                                         hStore,
                                         X509_ASN_ENCODING |
                                         PKCS_7_ASN_ENCODING,
                                         0,
                                         CERT_FIND_SUBJECT_NAME,
                                         &pSampleIssuer->pCertInfo->Subject,
                                         pCertContext
                                         ) ) != NULL )
            {
                CertAddCertificateLinkToStore(
                    hCacheIssuersStore,
                    pCertContext,
                    CERT_STORE_ADD_NEW,
                    NULL
                    );
            }
        }

        if ( !( dwInfoStatus & CERT_TRUST_HAS_KEY_MATCH_ISSUER ) )
        {
            if ( CertGetCertificateContextProperty(
                     pSampleIssuer,
                     CERT_KEY_IDENTIFIER_PROP_ID,
                     NULL,
                     &cbKeyIdentifier
                     ) == TRUE )
            {
                pbKeyIdentifier = new BYTE [ cbKeyIdentifier ];
                if ( pbKeyIdentifier != NULL )
                {
                    if ( CertGetCertificateContextProperty(
                             pSampleIssuer,
                             CERT_KEY_IDENTIFIER_PROP_ID,
                             NULL,
                             &cbKeyIdentifier
                             ) == TRUE )
                    {
                        HashBlob.cbData = cbKeyIdentifier;
                        HashBlob.pbData = pbKeyIdentifier;

                        while ( ( pCertContext = CertFindCertificateInStore(
                                                     hStore,
                                                     X509_ASN_ENCODING |
                                                     PKCS_7_ASN_ENCODING,
                                                     0,
                                                     CERT_FIND_KEY_IDENTIFIER,
                                                     &HashBlob,
                                                     pCertContext
                                                     ) ) != NULL )
                        {
                            CertAddCertificateLinkToStore(
                                hCacheIssuersStore,
                                pCertContext,
                                CERT_STORE_ADD_NEW,
                                NULL
                                );
                        }
                    }

                    delete pbKeyIdentifier;
                }
            }
        }

        if ( !( dwInfoStatus & CERT_TRUST_HAS_EXACT_MATCH_ISSUER ) )
        {
            while ( ( pCertContext = CertFindCertificateInStore(
                                         hStore,
                                         X509_ASN_ENCODING |
                                         PKCS_7_ASN_ENCODING,
                                         0,
                                         CERT_FIND_ISSUER_NAME,
                                         &pSampleIssuer->pCertInfo->Issuer,
                                         pCertContext
                                         ) ) != NULL )
            {
                if ( ( pSampleIssuer->pCertInfo->SerialNumber.cbData ==
                       pCertContext->pCertInfo->SerialNumber.cbData ) &&
                     ( memcmp(
                          pSampleIssuer->pCertInfo->SerialNumber.pbData,
                          pCertContext->pCertInfo->SerialNumber.pbData,
                          pCertContext->pCertInfo->SerialNumber.cbData
                          ) == 0 ) )
                {
                    CertAddCertificateLinkToStore(
                        hCacheIssuersStore,
                        pCertContext,
                        CERT_STORE_ADD_NEW,
                        NULL
                        );
                }
            }
        }

        CertFreeCertificateContext( pSampleIssuer );
    }

    *phCacheIssuersStore = hCacheIssuersStore;
    *phIssuerListStore = hIssuerListStore;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsMatchingIssuerCertificate
//
//  Synopsis:   is this a matching issuer certificate for the given subject
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsMatchingIssuerCertificate (
     IN PCCERTOBJECT pSubject,
     IN PCCERT_CONTEXT pIssuer
     )
{
    BOOL       fResult;
    PCERT_INFO pSubjectInfo = pSubject->CertContext()->pCertInfo;
    PCERT_INFO pIssuerInfo = pIssuer->pCertInfo;
    DWORD      cbSubjectAuthKeyIdentifier = 0;
    LPBYTE     pbSubjectAuthKeyIdentifier = NULL;
    DWORD      cbIssuerKeyIdentifier = 0;
    LPBYTE     pbIssuerKeyIdentifier = NULL;
    DWORD      cbSubjectAuthIssuerName = 0;
    LPBYTE     pbSubjectAuthIssuerName = NULL;
    DWORD      cbSubjectAuthSerialNumber = 0;
    LPBYTE     pbSubjectAuthSerialNumber = NULL;
    DWORD      dwMatchScheme;

    dwMatchScheme = pSubject->InfoStatus();

    if ( dwMatchScheme & CERT_TRUST_HAS_NAME_MATCH_ISSUER )
    {
        if ( ( pSubjectInfo->Issuer.cbData == pIssuerInfo->Subject.cbData ) &&
             ( memcmp(
                  pSubjectInfo->Issuer.pbData,
                  pIssuerInfo->Subject.pbData,
                  pIssuerInfo->Subject.cbData
                  ) == 0 ) )
        {
            return( TRUE );
        }
        else
        {
            return( FALSE );
        }
    }

    if ( dwMatchScheme & CERT_TRUST_HAS_KEY_MATCH_ISSUER )
    {
        cbSubjectAuthKeyIdentifier = pSubject->AuthorityKeyIdentifier()->KeyId.cbData;
        pbSubjectAuthKeyIdentifier = pSubject->AuthorityKeyIdentifier()->KeyId.pbData;

        if ( CertGetCertificateContextProperty(
                 pIssuer,
                 CERT_KEY_IDENTIFIER_PROP_ID,
                 NULL,
                 &cbIssuerKeyIdentifier
                 ) == FALSE )
        {
            return( FALSE );
        }

        if ( cbSubjectAuthKeyIdentifier != cbIssuerKeyIdentifier )
        {
            return( FALSE );
        }

        pbIssuerKeyIdentifier = new BYTE [ cbIssuerKeyIdentifier ];
        if ( pbIssuerKeyIdentifier != NULL )
        {
            fResult = CertGetCertificateContextProperty(
                          pIssuer,
                          CERT_KEY_IDENTIFIER_PROP_ID,
                          pbIssuerKeyIdentifier,
                          &cbIssuerKeyIdentifier
                          );

            if ( ( fResult == TRUE ) &&
                 ( memcmp(
                      pbIssuerKeyIdentifier,
                      pbSubjectAuthKeyIdentifier,
                      cbSubjectAuthKeyIdentifier
                      ) != 0 ) )
            {
                fResult = FALSE;
            }

            delete pbIssuerKeyIdentifier;

            return( fResult );
        }
        else
        {
            return( FALSE );
        }
    }

    if ( dwMatchScheme & CERT_TRUST_HAS_EXACT_MATCH_ISSUER )
    {
        cbSubjectAuthIssuerName = pSubject->AuthorityKeyIdentifier()->CertIssuer.cbData;
        pbSubjectAuthIssuerName = pSubject->AuthorityKeyIdentifier()->CertIssuer.pbData;
        cbSubjectAuthSerialNumber = pSubject->AuthorityKeyIdentifier()->CertSerialNumber.cbData;
        pbSubjectAuthSerialNumber = pSubject->AuthorityKeyIdentifier()->CertSerialNumber.pbData;

        if ( ( cbSubjectAuthIssuerName == pIssuerInfo->Issuer.cbData ) &&
             ( memcmp(
                  pbSubjectAuthIssuerName,
                  pIssuerInfo->Issuer.pbData,
                  pIssuerInfo->Issuer.cbData
                  ) == 0 ) &&
             ( cbSubjectAuthSerialNumber == pIssuerInfo->SerialNumber.cbData ) &&
             ( memcmp(
                  pbSubjectAuthSerialNumber,
                  pIssuerInfo->SerialNumber.pbData,
                  pIssuerInfo->SerialNumber.cbData
                  ) == 0 ) )
        {
            return( TRUE );
        }
        else
        {
            return( FALSE );
        }
    }

    assert( FALSE && "Should not get here!" );

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsInSameIssuerGrouping
//
//  Synopsis:   an issuer group comprises all issuing certificates that would
//              match some subject certificate by name, exact or key match.
//              This means that given a group member, a possible group member
//              is a match if it either has the same subject name, same issuer
//              name and serial number or same key identifier
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsInSameIssuerGrouping (
     IN PCCERTOBJECT pGroupMember,
     IN PCCERT_CONTEXT pPossibleGroupMember
     )
{
    DWORD          cbKeyIdentifier;
    LPBYTE         pbKeyIdentifier;
    PCCERT_CONTEXT pGroupContext;

    pGroupContext = pGroupMember->CertContext();

    if ( ( pGroupContext->pCertInfo->Subject.cbData ==
           pPossibleGroupMember->pCertInfo->Subject.cbData ) &&
         ( memcmp(
              pGroupContext->pCertInfo->Subject.pbData,
              pPossibleGroupMember->pCertInfo->Subject.pbData,
              pPossibleGroupMember->pCertInfo->Subject.cbData
              ) == 0 ) )
    {
        return( TRUE );
    }

    if ( ( pGroupContext->pCertInfo->Issuer.cbData ==
           pPossibleGroupMember->pCertInfo->Issuer.cbData ) &&
         ( memcmp(
              pGroupContext->pCertInfo->Issuer.pbData,
              pPossibleGroupMember->pCertInfo->Issuer.pbData,
              pPossibleGroupMember->pCertInfo->Issuer.cbData
              ) == 0 ) &&
         ( pGroupContext->pCertInfo->SerialNumber.cbData ==
           pPossibleGroupMember->pCertInfo->SerialNumber.cbData ) &&
         ( memcmp(
              pGroupContext->pCertInfo->SerialNumber.pbData,
              pPossibleGroupMember->pCertInfo->SerialNumber.pbData,
              pPossibleGroupMember->pCertInfo->SerialNumber.cbData
              ) == 0 ) )
    {
        return( TRUE );
    }

    if ( CertGetCertificateContextProperty(
             pPossibleGroupMember,
             CERT_KEY_IDENTIFIER_PROP_ID,
             NULL,
             &cbKeyIdentifier
             ) == TRUE )
    {
        if ( cbKeyIdentifier != pGroupMember->KeyIdentifierSize() )
        {
            return( FALSE );
        }

        pbKeyIdentifier = new BYTE [ cbKeyIdentifier ];
        if ( pbKeyIdentifier != NULL )
        {
            if ( CertGetCertificateContextProperty(
                     pPossibleGroupMember,
                     CERT_KEY_IDENTIFIER_PROP_ID,
                     pbKeyIdentifier,
                     &cbKeyIdentifier
                     ) == TRUE )
            {
                if ( memcmp(
                        pGroupMember->KeyIdentifier(),
                        pbKeyIdentifier,
                        cbKeyIdentifier
                        ) == 0 )
                {
                    delete pbKeyIdentifier;
                    return( TRUE );
                }
            }

            delete pbKeyIdentifier;
        }
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertificateObject
//
//  Synopsis:   create a certificate object, note since it is a ref-counted
//              object, freeing occurs by doing a pCertObject->Release
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCertificateObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERT_CONTEXT pCertContext,
     IN PCRYPT_HASH_BLOB pHashBlob,
     IN OPTIONAL PCERT_TRUST_STATUS pKnownStatus,
     IN OPTIONAL HCERTSTORE hAdditionalStore,
     OUT PCCERTOBJECT* ppCertObject,
     OUT BOOL* pfFromCallCreationCache
     )
{
    BOOL         fResult = TRUE;
    PCCERTOBJECT pCertObject;

    pCertObject = pCallContext->FindObjectInCreationCache( pHashBlob );
    if ( pCertObject != NULL )
    {
        *ppCertObject = pCertObject;
        *pfFromCallCreationCache = TRUE;
        return( TRUE );
    }

    pCertObject = new CCertObject(
                           pChainEngine,
                           pCallContext,
                           pCertContext,
                           pHashBlob,
                           pKnownStatus,
                           hAdditionalStore,
                           fResult
                           );

    if ( pCertObject != NULL )
    {
        if ( fResult == TRUE )
        {
            *ppCertObject = pCertObject;
            *pfFromCallCreationCache = FALSE;
        }
        else
        {
            pCertObject->Release();
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetIssuerQuality
//
//  Synopsis:   get the quality of the given issuer
//
//----------------------------------------------------------------------------
LONG WINAPI
ChainGetIssuerQuality (
     IN PCERT_ISSUER_ELEMENT pElement,
     IN LPFILETIME pTime,
     IN LPFILETIME pCurrentTime,
     IN PCERT_USAGE_MATCH pRequestedUsage,
     IN DWORD dwFlags,
     OUT PCERT_TRUST_STATUS pAdditionalStatus,
     OUT PCERT_TRUST_STATUS pCtlStatus,
     OUT PCERT_USAGE_MATCH pCtlSignerRequestedUsage,
     OUT LPFILETIME pCtlSignerRequestedTime
     )
{
    LONG               lQuality = 0;
    PCCERTOBJECT       pIssuer;
    CERT_TRUST_STATUS  Status;
    PCERT_TRUST_STATUS pSubjectStatus;
    DWORD              dwIssuerChainErrorStatus;

    memset( pAdditionalStatus, 0, sizeof( CERT_TRUST_STATUS ) );
    memset( pCtlStatus, 0, sizeof( CERT_TRUST_STATUS ) );
    memset( pCtlSignerRequestedUsage, 0, sizeof( CERT_USAGE_MATCH ) );
    memset( pCtlSignerRequestedTime, 0, sizeof( FILETIME ) );

    if ( pElement->pIssuer == NULL )
    {
        return( 0 );
    }

    if ( pElement->fCtlIssuer == TRUE )
    {
#ifdef CAPI_INCLUDE_CTL    
        if ( pElement->pCtlIssuerData->pSSCtlObject->GetSignerRequestedUsageAndTime(
                                             pCurrentTime,
                                             pCtlSignerRequestedUsage,
                                             pCtlSignerRequestedTime
                                             ) == FALSE )
#endif                                             
        {
            // NOTE: This causes a skip
            return( CERT_QUALITY_MINIMUM );
        }
    }

    pIssuer = pElement->pIssuer;
    Status.dwErrorStatus = pIssuer->ErrorStatus();
    Status.dwInfoStatus = pIssuer->InfoStatus();
    dwIssuerChainErrorStatus = pIssuer->ChainErrorStatus();

    pSubjectStatus = &pElement->SubjectStatus;

    pIssuer->CalculateAdditionalStatus(
                      ( pElement->fCtlIssuer == FALSE ) ? pTime :
                      pCtlSignerRequestedTime,
                      ( pElement->fCtlIssuer == FALSE ) ? pRequestedUsage :
                      pCtlSignerRequestedUsage,
                      dwFlags,
                      pAdditionalStatus
                      );

    ChainOrInStatusBits( &Status, pAdditionalStatus );

    // BUGBUG: Need to take list identifier into consideration

#ifdef CAPI_INCLUDE_CTL
    if ( pElement->fCtlIssuer == TRUE )
    {
        pElement->pCtlIssuerData->pSSCtlObject->CalculateStatus(
                                                         pCurrentTime,
                                                         pRequestedUsage,
                                                         dwFlags,
                                                         pCtlStatus
                                                         );
    }
#endif    

    if ( !( pSubjectStatus->dwErrorStatus & CERT_TRUST_IS_NOT_TIME_NESTED ) )
    {
        lQuality += CERT_QUALITY_ISSUER_TIME_NESTED;
    }

    if ( !( dwIssuerChainErrorStatus & CERT_TRUST_IS_NOT_TIME_NESTED ) )
    {
        lQuality += CERT_QUALITY_CHAIN_TIME_NESTED;
    }

    if ( !( Status.dwErrorStatus & CERT_TRUST_IS_NOT_TIME_VALID ) &&
         !( pCtlStatus->dwErrorStatus & CERT_TRUST_CTL_IS_NOT_TIME_VALID ) )
    {
        lQuality += CERT_QUALITY_ISSUER_TIME_VALID;
    }

    if ( !( Status.dwErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE ) &&
         !( pCtlStatus->dwErrorStatus & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE ) )
    {
        lQuality += CERT_QUALITY_MEETS_USAGE_CRITERIA;
    }

    if ( !( dwIssuerChainErrorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT ) )
    {
        lQuality += CERT_QUALITY_HAS_PROTECTED_ROOT;
    }

    if ( !( pSubjectStatus->dwErrorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) &&
         !( pCtlStatus->dwErrorStatus & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ) )
    {
        lQuality += CERT_QUALITY_ISSUER_SIGNATURE_VALID;
    }

    if ( !( dwIssuerChainErrorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) )
    {
        lQuality += CERT_QUALITY_CHAIN_SIGNATURE_VALID;
    }

    return( lQuality );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetSubjectStatus
//
//  Synopsis:   get the subject status bits by checking the time nesting and
//              signature validity
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetSubjectStatus (
     IN PCCERTOBJECT pIssuer,
     IN OPTIONAL PCERT_PUBLIC_KEY_INFO pIssuerPublicKey,
     IN PCCERTOBJECT pSubject,
     OUT PCERT_TRUST_STATUS pStatus
     )
{
    memset( pStatus, 0, sizeof( CERT_TRUST_STATUS ) );

    if ( ( CompareFileTime(
                  &pIssuer->CertContext()->pCertInfo->NotBefore,
                  &pSubject->CertContext()->pCertInfo->NotBefore
                  ) > 0 ) ||
         ( CompareFileTime(
                  &pIssuer->CertContext()->pCertInfo->NotAfter,
                  &pSubject->CertContext()->pCertInfo->NotAfter
                  ) < 0 ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_TIME_NESTED;
    }

    if ( pIssuerPublicKey == NULL )
    {
#ifdef CMS_PKCS7
        if (!CryptVerifyCertificateSignatureEx(
                NULL,                   // hCryptProv
                X509_ASN_ENCODING,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pSubject->CertContext(),
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pIssuer->CertContext(),
                0,                      // dwFlags
                NULL                    // pvReserved
                ))
#else
        if ( CryptVerifyCertificateSignature(
                  NULL,
                  X509_ASN_ENCODING,
                  pSubject->CertContext()->pbCertEncoded,
                  pSubject->CertContext()->cbCertEncoded,
                  &pIssuer->CertContext()->pCertInfo->SubjectPublicKeyInfo
                  ) == FALSE )
#endif
        {
            pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
        }
    }
    else
    {
        if ( CertComparePublicKeyInfo(
                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                 &pIssuer->CertContext()->pCertInfo->SubjectPublicKeyInfo,
                 pIssuerPublicKey
                 ) == FALSE )
        {
            pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainTouchAllChosenIssuerRelatedObjects
//
//  Synopsis:   touch the chosen issuer and all its buddies
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainTouchAllChosenIssuerRelatedObjects (
     IN PCCERTOBJECT pChosenIssuer
     )
{
    CRYPT_HASH_BLOB        HashBlob;
    CERT_OBJECT_IDENTIFIER ObjectIdentifier;

    I_CryptTouchLruEntry( pChosenIssuer->HashIndexEntry(), 0 );

    ChainTouchAllMatchingSubjectNames(
         pChosenIssuer->ChainEngine()->CertObjectCache(),
         &pChosenIssuer->CertContext()->pCertInfo->Subject,
         LRU_SUPPRESS_CLOCK_UPDATE
         );

    pChosenIssuer->GetObjectIdentifier( ObjectIdentifier );

    ChainTouchAllMatchingObjectIds(
         pChosenIssuer->ChainEngine()->CertObjectCache(),
         ObjectIdentifier,
         LRU_SUPPRESS_CLOCK_UPDATE
         );

    HashBlob.cbData = pChosenIssuer->KeyIdentifierSize();
    HashBlob.pbData = pChosenIssuer->KeyIdentifier();

    ChainTouchAllMatchingKeyIds(
         pChosenIssuer->ChainEngine()->CertObjectCache(),
         &HashBlob,
         LRU_SUPPRESS_CLOCK_UPDATE
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainTouchAllMatchingSubjectNames
//
//  Synopsis:   touch all matching subject names
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainTouchAllMatchingSubjectNames (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCERT_NAME_BLOB pSubjectName,
     IN DWORD dwTouchFlags
     )
{
    ChainTouchAllMatchingEntries(
         pCertObjectCache->SubjectNameIndex(),
         pSubjectName,
         dwTouchFlags
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainTouchAllMatchingObjectIds
//
//  Synopsis:   touch all matching object ids
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainTouchAllMatchingObjectIds (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN CERT_OBJECT_IDENTIFIER ObjectIdentifier,
     IN DWORD dwTouchFlags
     )
{
    CRYPT_DATA_BLOB DataBlob;

    DataBlob.cbData = MD5DIGESTLEN;
    DataBlob.pbData = ObjectIdentifier;

    ChainTouchAllMatchingEntries(
         pCertObjectCache->IdentifierIndex(),
         &DataBlob,
         dwTouchFlags
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainTouchAllMatchingKeyIds
//
//  Synopsis:   touch all matching key id objects
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainTouchAllMatchingKeyIds (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCRYPT_HASH_BLOB pKeyId,
     IN DWORD dwTouchFlags
     )
{
    ChainTouchAllMatchingEntries(
         pCertObjectCache->KeyIdIndex(),
         pKeyId,
         dwTouchFlags
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainTouchAllMatchingEntries
//
//  Synopsis:   touch all matching entries
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainTouchAllMatchingEntries (
     IN HLRUCACHE hIndex,
     IN PCRYPT_DATA_BLOB pIdentifier,
     IN DWORD dwTouchFlags
     )
{
    HLRUENTRY    hEntry;
    PCCERTOBJECT pCertObject;

    hEntry = I_CryptFindLruEntry( hIndex, pIdentifier );

    if ( hEntry != NULL )
    {
        pCertObject = (PCCERTOBJECT)I_CryptGetLruEntryData( hEntry );

        I_CryptTouchLruEntry( pCertObject->HashIndexEntry(), dwTouchFlags );

        while ( ( hEntry = I_CryptEnumMatchingLruEntries( hEntry ) ) != NULL )
        {
            pCertObject = (PCCERTOBJECT)I_CryptGetLruEntryData( hEntry );

            I_CryptTouchLruEntry( pCertObject->HashIndexEntry(), dwTouchFlags );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveCertificateObjectFromSecondaryCacheIndexes
//
//  Synopsis:   removes certificate object from the identifier, subject name
//              and issuer name indexes in the certificate object cache
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveCertificateObjectFromSecondaryCacheIndexes (
     IN PCCERTOBJECT pCertObject
     )
{
    I_CryptRemoveLruEntry(
           pCertObject->IdentifierIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->SubjectNameIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->IssuerNameIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->KeyIdIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveObjectsRelatedToThisIssuer
//
//  Synopsis:   remove objects related to this issuer
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveObjectsRelatedToThisIssuer (
     IN PCCERTOBJECT pRemovedIssuer
     )
{
    CRYPT_HASH_BLOB        HashBlob;
    CERT_OBJECT_IDENTIFIER ObjectIdentifier;

    ChainRemoveAllMatchingSubjectNames(
         pRemovedIssuer->ChainEngine()->CertObjectCache(),
         &pRemovedIssuer->CertContext()->pCertInfo->Subject,
         LRU_SUPPRESS_REMOVAL_NOTIFICATION
         );

    pRemovedIssuer->GetObjectIdentifier( ObjectIdentifier );

    ChainRemoveAllMatchingObjectIds(
         pRemovedIssuer->ChainEngine()->CertObjectCache(),
         ObjectIdentifier,
         LRU_SUPPRESS_REMOVAL_NOTIFICATION
         );

    HashBlob.cbData = pRemovedIssuer->KeyIdentifierSize();
    HashBlob.pbData = pRemovedIssuer->KeyIdentifier();

    ChainRemoveAllMatchingKeyIds(
         pRemovedIssuer->ChainEngine()->CertObjectCache(),
         &HashBlob,
         LRU_SUPPRESS_REMOVAL_NOTIFICATION
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveAllMatchingSubjectNames
//
//  Synopsis:   remove all matching subject name entries
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveAllMatchingSubjectNames (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCERT_NAME_BLOB pSubjectName,
     IN DWORD dwRemovalFlags
     )
{
    ChainRemoveAllMatchingEntries(
         pCertObjectCache->SubjectNameIndex(),
         pSubjectName,
         dwRemovalFlags
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveAllMatchingObjectIds
//
//  Synopsis:   remove all matching object identifier entries
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveAllMatchingObjectIds (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN CERT_OBJECT_IDENTIFIER ObjectIdentifier,
     IN DWORD dwRemovalFlags
     )
{
    CRYPT_DATA_BLOB DataBlob;

    DataBlob.cbData = MD5DIGESTLEN;
    DataBlob.pbData = ObjectIdentifier;

    ChainRemoveAllMatchingEntries(
         pCertObjectCache->IdentifierIndex(),
         &DataBlob,
         dwRemovalFlags
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveAllMatchingKeyIds
//
//  Synopsis:   remove matching key identifier entries
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveAllMatchingKeyIds (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCRYPT_HASH_BLOB pKeyId,
     IN DWORD dwRemovalFlags
     )
{
    ChainRemoveAllMatchingEntries(
         pCertObjectCache->KeyIdIndex(),
         pKeyId,
         dwRemovalFlags
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveAllMatchingEntries
//
//  Synopsis:   remove matching index entries by removing them from the
//              appropriate primary index
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveAllMatchingEntries (
     IN HLRUCACHE hIndex,
     IN PCRYPT_DATA_BLOB pIdentifier,
     IN DWORD dwRemovalFlags
     )
{
    HLRUENTRY    hRemove;
    HLRUENTRY    hEntry;
    PCCERTOBJECT pCertObject;

    hEntry = I_CryptFindLruEntry( hIndex, pIdentifier );

    while ( hEntry != NULL )
    {
        I_CryptAddRefLruEntry( ( hRemove = hEntry ) );

        hEntry = I_CryptEnumMatchingLruEntries( hEntry );
        pCertObject = (PCCERTOBJECT)I_CryptGetLruEntryData( hRemove );

        I_CryptRemoveLruEntry(
               pCertObject->HashIndexEntry(),
               dwRemovalFlags,
               NULL
               );

        ChainProcessRemovalNotification( NULL, pCertObject, FALSE );

        I_CryptReleaseLruEntry( hRemove );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFlushIssuerListsWithThisIssuer
//
//  Synopsis:   flush issuer lists with this issuer
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFlushIssuerListsWithThisIssuer (
     IN PCCERTOBJECT pIssuer
     )
{
    ChainFlushIssuerListsWithThisIssuerByName( pIssuer );
    ChainFlushIssuerListsWithThisIssuerByObjectOrKeyId( pIssuer );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFlushIssuerListsWithThisIssuerByName
//
//  Synopsis:   flush issuer lists with this issuer by name
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFlushIssuerListsWithThisIssuerByName (
     IN PCCERTOBJECT pIssuer
     )
{
    HLRUENTRY    hEntry;
    PCCERTOBJECT pCertObject;

    hEntry = I_CryptFindLruEntry(
                    pIssuer->ChainEngine()->CertObjectCache()->IssuerNameIndex(),
                    &pIssuer->CertContext()->pCertInfo->Subject
                    );

    while ( hEntry != NULL )
    {
        pCertObject = (PCCERTOBJECT)I_CryptGetLruEntryData( hEntry );
        pCertObject->IssuerList()->Flush();

        hEntry = I_CryptEnumMatchingLruEntries( hEntry );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFlushIssuerListsWithThisIssuerByObjectOrKeyId
//
//  Synopsis:   flush issuer lists
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFlushIssuerListsWithThisIssuerByObjectOrKeyId (
     IN PCCERTOBJECT pIssuer
     )
{
    pIssuer->ChainEngine()->CertObjectCache()->EnumObjects(
                  ChainFlushIssuerListsWithThisIssuerByObjectOrKeyIdEnumFn,
                  pIssuer
                  );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFlushIssuerListsWithThisIssuerByObjectOrKeyIdEnumFn
//
//  Synopsis:   check to see if this issuer ( pvParameter ) is an exact
//              match or key match for the cert object and if so, flush
//              it's issuer list
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFlushIssuerListsWithThisIssuerByObjectOrKeyIdEnumFn (
     IN LPVOID pvParameter,
     IN PCCERTOBJECT pCertObject
     )
{
    PCCERTOBJECT pIssuer = (PCCERTOBJECT)pvParameter;

    if ( pCertObject->InfoStatus() & CERT_TRUST_HAS_NAME_MATCH_ISSUER )
    {
        return( TRUE );
    }

    if ( ChainIsMatchingIssuerCertificate(
              pCertObject,
              pIssuer->CertContext()
              ) == TRUE )
    {
        pCertObject->IssuerList()->Flush();
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFlushMatchingCtlIssuerLists
//
//  Synopsis:   flush matching lists
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFlushMatchingCtlIssuerLists (
     IN PCCERTOBJECT pCertObject
     )
{
    FLUSH_CTL_ISSUERS_ENUM_DATA EnumData;

    if ( ChainIsCertificateObjectCtlSigner( pCertObject ) == FALSE )
    {
        return;
    }

    EnumData.pCtlIssuer = pCertObject;

    pCertObject->ChainEngine()->CertObjectCache()->EnumObjects(
                                    ChainFlushMatchingCtlIssuerListsEnumFn,
                                    &EnumData
                                    );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsCertificateObjectCtlSigner
//
//  Synopsis:   does the certificate have the CTL signer EKU
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsCertificateObjectCtlSigner (
     IN PCCERTOBJECT pCertObject
     )
{
    CERT_TRUST_STATUS TrustStatus;
    LPSTR             pszUsage = szOID_KP_CTL_USAGE_SIGNING;
    CERT_ENHKEY_USAGE Usage;

    Usage.cUsageIdentifier = 1;
    Usage.rgpszUsageIdentifier = &pszUsage;

    ChainGetUsageStatus(
         &Usage,
         pCertObject->Usage(),
         0,
         &TrustStatus
         );

    if ( TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE )
    {
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFlushMatchingCtlIssuerListsEnumFn
//
//  Synopsis:   flush matching CTL issuer list enumerator function
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFlushMatchingCtlIssuerListsEnumFn (
     IN LPVOID pvParameter,
     IN PCCERTOBJECT pCertObject
     )
{
    PFLUSH_CTL_ISSUERS_ENUM_DATA pEnumData;

    if ( !( pCertObject->InfoStatus() & CERT_TRUST_IS_SELF_SIGNED ) )
    {
        return( TRUE );
    }

    pEnumData = (PFLUSH_CTL_ISSUERS_ENUM_DATA)pvParameter;
    pCertObject->IssuerList()->CtlIssuerFlush( pEnumData->pCtlIssuer );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainProcessRemovalNotification
//
//  Synopsis:   process removal notification
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainProcessRemovalNotification (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERTOBJECT pCertObject,
     IN BOOL fProcessMatchingObjects
     )
{

    ChainRemoveCertificateObjectFromSecondaryCacheIndexes( pCertObject );

    if ( fProcessMatchingObjects == TRUE )
    {
        ChainFlushIssuerListsWithThisIssuer( pCertObject );
        ChainFlushMatchingCtlIssuerLists( pCertObject );
        ChainRemoveObjectsRelatedToThisIssuer( pCertObject );
    }

    pCertObject->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertificateObjectCache
//
//  Synopsis:   create certificate object cache object
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCertificateObjectCache (
     IN DWORD MaxIndexEntries,
     OUT PCCERTOBJECTCACHE* ppCertObjectCache
     )
{
    BOOL              fResult = FALSE;
    PCCERTOBJECTCACHE pCertObjectCache = NULL;

    pCertObjectCache = new CCertObjectCache( MaxIndexEntries, fResult );
    if ( pCertObjectCache != NULL )
    {
        if ( fResult == TRUE )
        {
            *ppCertObjectCache = pCertObjectCache;
        }
        else
        {
            delete pCertObjectCache;
        }
    }
    else
    {
        SetLastError( E_OUTOFMEMORY );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCertificateObjectCache
//
//  Synopsis:   free the certificate object cache object
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCertificateObjectCache (
     IN PCCERTOBJECTCACHE pCertObjectCache
     )
{
    delete pCertObjectCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertificateChainContext
//
//  Synopsis:   create certificate chain context object
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCertificateChainContext (
     OUT PCCERTCHAINCONTEXT* ppCertChainContext
     )
{
    BOOL               fResult = FALSE;
    PCCERTCHAINCONTEXT pCertChainContext;

    pCertChainContext = new CCertChainContext( fResult );
    if ( pCertChainContext != NULL )
    {
        if ( fResult == TRUE )
        {
            *ppCertChainContext = pCertChainContext;
        }
        else
        {
            ChainFreeCertificateChainContext( pCertChainContext );
        }
    }
    else
    {
        SetLastError( E_OUTOFMEMORY );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCertificateChainContext
//
//  Synopsis:   free the certificate chain context object
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCertificateChainContext (
     IN PCCERTCHAINCONTEXT pCertChainContext
     )
{
    delete pCertChainContext;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainAddRefInternalChainContext
//
//  Synopsis:   addref the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainAddRefInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     )
{
    InterlockedIncrement( (LONG *)&pChainContext->cRefs );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainReleaseInternalChainContext
//
//  Synopsis:   release the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainReleaseInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     )
{
    if ( InterlockedDecrement( (LONG *)&pChainContext->cRefs ) == 0 )
    {
        ChainFreeInternalChainContext( pChainContext );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeInternalChainContext
//
//  Synopsis:   free the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     )
{
    DWORD                cChain;
    DWORD                cElement;
    PCERT_SIMPLE_CHAIN*  rgpChain;
    PCERT_CHAIN_ELEMENT* rgpElement;

    if ( pChainContext->rgElementCount == NULL )
    {
        return;
    }

    rgpChain = pChainContext->ChainContext.rgpChain;

    for ( cChain = 0; cChain < pChainContext->cSimpleChain; cChain++ )
    {
        if ( rgpChain[ cChain ] == NULL )
        {
            continue;
        }

        rgpElement = rgpChain[ cChain ]->rgpElement;

        for ( cElement = 0;
              cElement < pChainContext->rgElementCount[ cChain ];
              cElement++ )
        {
            if ( rgpElement[ cElement ] != NULL )
            {
                if ( rgpElement[ cElement ]->pCertContext != NULL )
                {
                    CertFreeCertificateContext(
                        rgpElement[ cElement ]->pCertContext
                        );
                }

                ChainFreeRevocationInfo(
                     rgpElement[ cElement ]->pRevocationInfo
                     );
            }

            delete rgpElement[ cElement ];
        }
#ifdef CAPI_INCLUDE_CTL
        if ( rgpChain[ cChain ]->pTrustListInfo != NULL )
        {
            SSCtlFreeTrustListInfo( rgpChain[ cChain ]->pTrustListInfo );
        }
#else
		assert(!rgpChain[ cChain ]->pTrustListInfo);
#endif		

        delete rgpElement;
        delete rgpChain[ cChain ];
    }

    delete rgpChain;
    delete pChainContext->rgElementCount;
    delete pChainContext;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainUpdateSummaryStatusByTrustStatus
//
//  Synopsis:   update the summary status bits given new trust status bits
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainUpdateSummaryStatusByTrustStatus (
     IN PCERT_TRUST_STATUS pSummaryStatus,
     IN PCERT_TRUST_STATUS pTrustStatus
     )
{
    pSummaryStatus->dwErrorStatus |= pTrustStatus->dwErrorStatus;
    pSummaryStatus->dwInfoStatus |= pTrustStatus->dwInfoStatus;
    pSummaryStatus->dwInfoStatus &= ~CERT_TRUST_CERTIFICATE_ONLY_INFO_STATUS;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainOrInStatusBits
//
//  Synopsis:   bit or in the status bits from the source into the destination
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainOrInStatusBits (
     IN PCERT_TRUST_STATUS pDestStatus,
     IN PCERT_TRUST_STATUS pSourceStatus
     )
{
    pDestStatus->dwErrorStatus |= pSourceStatus->dwErrorStatus;
    pDestStatus->dwInfoStatus |= pSourceStatus->dwInfoStatus;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetChainErrorStatusQuality
//
//  Synopsis:   get the quality of a chain error status
//
//----------------------------------------------------------------------------
LONG WINAPI
ChainGetChainErrorStatusQuality (
     IN DWORD dwChainErrorStatus
     )
{
    LONG lQuality = 0;

    if ( !( dwChainErrorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) )
    {
        lQuality += CERT_QUALITY_CHAIN_SIGNATURE_VALID;
    }

    if ( !( dwChainErrorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT ) )
    {
        lQuality += CERT_QUALITY_HAS_PROTECTED_ROOT;
    }

    if ( !( dwChainErrorStatus & CERT_TRUST_IS_NOT_TIME_NESTED ) )
    {
        lQuality += CERT_QUALITY_CHAIN_TIME_NESTED;
    }

    return( lQuality );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCacheEndCertificate
//
//  Synopsis:   cache an end certificate in the cert object cache
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCacheEndCertificate (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERTOBJECT pEndCertObject
     )
{
    BOOL               fResult;
    BOOL               fIssuerOfCertificates;
    PCCERT_CONTEXT     pCertContext = NULL;
    BYTE               CertificateHash[ MD5DIGESTLEN ];
    DWORD              cbData = MD5DIGESTLEN;
    PCCERTOBJECT       pCertObject;
    PCCERTOBJECTCACHE  pCertObjectCache;
    CRYPT_HASH_BLOB    HashBlob;
    BOOL               fFromCallCreationCache;

    fIssuerOfCertificates = ChainIsIssuerOfCertificates( pEndCertObject );
    pCertObjectCache = pEndCertObject->ChainEngine()->CertObjectCache();

    if ( fIssuerOfCertificates == TRUE )
    {
        pCertObjectCache->DisableLruOfObjects();
    }

    pCertObjectCache->AddObject( pCallContext, pEndCertObject, TRUE );

    if ( fIssuerOfCertificates == FALSE )
    {
        return( TRUE );
    }

    while ( ( pCertContext = CertEnumCertificatesInStore(
                                 pEndCertObject->ChainEngine()->OtherStore(),
                                 pCertContext
                                 ) ) != NULL )
    {
        if ( ChainIsInSameIssuerGrouping(
                  pEndCertObject,
                  pCertContext
                  ) == FALSE )
        {
            continue;
        }

        fResult = CertGetCertificateContextProperty(
                      pCertContext,
                      CERT_MD5_HASH_PROP_ID,
                      CertificateHash,
                      &cbData
                      );

        if ( fResult == TRUE )
        {
            HashBlob.cbData = cbData;
            HashBlob.pbData = CertificateHash;

            pCertObject = pCertObjectCache->FindObjectByHash( &HashBlob );
            if ( pCertObject == NULL )
            {
                fResult = ChainCreateCertificateObject(
                               pEndCertObject->ChainEngine(),
                               pCallContext,
                               pCertContext,
                               &HashBlob,
                               NULL,
                               NULL,
                               &pCertObject,
                               &fFromCallCreationCache
                               );

                if ( fResult == TRUE )
                {
                    pCertObjectCache->AddObject(
                                         NULL,
                                         pCertObject,
                                         fFromCallCreationCache
                                         );
                }
            }

            if ( pCertObject != NULL )
            {
                pCertObject->Release();
            }
        }
    }

    pCertObjectCache->EnableLruOfObjects( pCallContext );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsIssuerOfCertificates
//
//  Synopsis:   returns TRUE if this certificate can issuer other certificates
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsIssuerOfCertificates (
     IN PCCERTOBJECT pCertObject
     )
{
    BOOL                          fResult = FALSE;
    BOOL                          fIssuerOfCertificates = TRUE;
    PCERT_EXTENSION               pExt;
    DWORD                         cb;
    PCERT_BASIC_CONSTRAINTS2_INFO pBasicConstraints;

    pExt = CertFindExtension(
               szOID_BASIC_CONSTRAINTS2,
               pCertObject->CertContext()->pCertInfo->cExtension,
               pCertObject->CertContext()->pCertInfo->rgExtension
               );

    if ( pExt != NULL )
    {
        fResult = CryptDecodeObject(
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       pExt->pszObjId,
                       pExt->Value.pbData,
                       pExt->Value.cbData,
                       0,
                       NULL,
                       &cb
                       );

        if ( fResult == TRUE )
        {
            pBasicConstraints = (PCERT_BASIC_CONSTRAINTS2_INFO)new BYTE [ cb ];
            if ( pBasicConstraints != NULL )
            {
                pBasicConstraints->fCA = TRUE;

                fResult = CryptDecodeObject(
                               X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               pExt->pszObjId,
                               pExt->Value.pbData,
                               pExt->Value.cbData,
                               0,
                               pBasicConstraints,
                               &cb
                               );

                fIssuerOfCertificates = pBasicConstraints->fCA;

                delete pBasicConstraints;
            }
        }
    }

    return( fIssuerOfCertificates );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainConvertAuthKeyIdentifierFromV2ToV1
//
//  Synopsis:   convert authority key identifier from V2 to V1
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainConvertAuthKeyIdentifierFromV2ToV1 (
     IN PCERT_AUTHORITY_KEY_ID2_INFO pAuthKeyIdentifier2,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     )
{
    DWORD                       cb;
    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;
    BOOL                        fExactMatchAvailable = FALSE;

    if ( ( pAuthKeyIdentifier2->AuthorityCertIssuer.cAltEntry == 1 ) &&
         ( pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].dwAltNameChoice ==
           CERT_ALT_NAME_DIRECTORY_NAME ) )
    {
        fExactMatchAvailable = TRUE;
    }

    cb = sizeof( CERT_AUTHORITY_KEY_ID_INFO );
    cb += pAuthKeyIdentifier2->KeyId.cbData;

    if ( fExactMatchAvailable == TRUE )
    {
        cb += pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.cbData;
        cb += pAuthKeyIdentifier2->AuthorityCertSerialNumber.cbData;
    }

    pAuthKeyIdentifier = (PCERT_AUTHORITY_KEY_ID_INFO)new BYTE [ cb ];
    if ( pAuthKeyIdentifier == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    memset( pAuthKeyIdentifier, 0, cb );

    pAuthKeyIdentifier->KeyId.cbData = pAuthKeyIdentifier2->KeyId.cbData;
    pAuthKeyIdentifier->KeyId.pbData = (LPBYTE)pAuthKeyIdentifier + sizeof( CERT_AUTHORITY_KEY_ID_INFO );

    memcpy(
       pAuthKeyIdentifier->KeyId.pbData,
       pAuthKeyIdentifier2->KeyId.pbData,
       pAuthKeyIdentifier->KeyId.cbData
       );

    if ( fExactMatchAvailable == TRUE )
    {
        pAuthKeyIdentifier->CertIssuer.cbData = pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.cbData;
        pAuthKeyIdentifier->CertIssuer.pbData = pAuthKeyIdentifier->KeyId.pbData + pAuthKeyIdentifier->KeyId.cbData;

        memcpy(
           pAuthKeyIdentifier->CertIssuer.pbData,
           pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.pbData,
           pAuthKeyIdentifier->CertIssuer.cbData
           );

        pAuthKeyIdentifier->CertSerialNumber.cbData = pAuthKeyIdentifier2->AuthorityCertSerialNumber.cbData;
        pAuthKeyIdentifier->CertSerialNumber.pbData = pAuthKeyIdentifier->CertIssuer.pbData + pAuthKeyIdentifier->CertIssuer.cbData;

        memcpy(
           pAuthKeyIdentifier->CertSerialNumber.pbData,
           pAuthKeyIdentifier2->AuthorityCertSerialNumber.pbData,
           pAuthKeyIdentifier->CertSerialNumber.cbData
           );
    }

    *ppAuthKeyIdentifier = pAuthKeyIdentifier;

    return( TRUE );
}

#ifdef CAPI_INCLUDE_CTL
//+---------------------------------------------------------------------------
//
//  Function:   ChainFindAndStoreCtlIssuersEnumFn
//
//  Synopsis:   find and store CTL based issuers in engine
//
//----------------------------------------------------------------------------
BOOL
ChainFindAndStoreCtlIssuersEnumFn (
     IN LPVOID pvParameter,
     IN PCSSCTLOBJECT pSSCtlObject
     )
{
    BOOL                   fResult;
    PCTL_ISSUERS_ENUM_DATA pEnumData;

    pEnumData = (PCTL_ISSUERS_ENUM_DATA)pvParameter;

    fResult = pEnumData->pCertObject->IssuerList()->AddCtlIssuer(
                                                       pEnumData->pCallContext,
                                                       pSSCtlObject,
                                                       FALSE,
                                                       NULL,
                                                       FALSE
                                                       );

    // NOTE: If we get an error due to not finding the subject in the CTL then
    //       we are ok.  However, we want to always continue enumerating so
    //       I'm not sure what to do on other types of errors.

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCtlIssuerData
//
//  Synopsis:   free CTL issuer data
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCtlIssuerData (
     IN PCTL_ISSUER_DATA pCtlIssuerData
     )
{
    if ( pCtlIssuerData->pTrustListInfo != NULL )
    {
        SSCtlFreeTrustListInfo( pCtlIssuerData->pTrustListInfo );
    }

    if ( pCtlIssuerData->pSSCtlObject != NULL )
    {
        pCtlIssuerData->pSSCtlObject->Release();
    }

    delete pCtlIssuerData;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFixupCtlIssuers
//
//  Synopsis:   fixup the CTL issuers
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFixupCtlIssuers (
     IN PCCERTOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN HCERTSTORE hAdditionalStore
     )
{
    PCCERTISSUERLIST     pIssuerList;
    PCERT_ISSUER_ELEMENT pElement = NULL;
    PCSSCTLOBJECT        pSSCtlObject;
    BOOL                 fCtlSignatureValid;

    pIssuerList = pSubject->IssuerList();

    while ( ( pElement = pIssuerList->NextElement( pElement ) ) != NULL )
    {
        if ( ( pElement->fCtlIssuer == TRUE ) && ( pElement->pIssuer == NULL ) )
        {
            pSSCtlObject = pElement->pCtlIssuerData->pSSCtlObject;

            if ( pSSCtlObject->GetSigner(
                                  pSubject,
                                  pCallContext,
                                  hAdditionalStore,
                                  &pElement->pIssuer,
                                  &pElement->pCtlIssuerData->fAdditionalStoreSigner,
                                  &fCtlSignatureValid
                                  ) == TRUE )
            {
                pElement->ChainStatus.dwErrorStatus = pElement->pIssuer->ChainErrorStatus();

                if ( fCtlSignatureValid == FALSE )
                {
                    pElement->ChainStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
                }
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFindAndStoreCtlIssuersFromAdditionalStore
//
//  Synopsis:   find and store CTL based issuers from additional store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFindAndStoreCtlIssuersFromAdditionalStore (
     IN PCCERTOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN HCERTSTORE hAdditionalStore
     )
{
    BOOL          fResult;
    PCCTL_CONTEXT pCtlContext = NULL;
    PCSSCTLOBJECT pSSCtlObject;

    while ( ( pCtlContext = CertEnumCTLsInStore(
                                hAdditionalStore,
                                pCtlContext
                                ) ) != NULL )
    {
        fResult = SSCtlCreateCtlObject(
                       pSubject->ChainEngine(),
                       pCtlContext,
                       &pSSCtlObject
                       );

        if ( fResult == TRUE )
        {
            fResult = pSubject->IssuerList()->AddCtlIssuer(
                                                 pCallContext,
                                                 pSSCtlObject,
                                                 TRUE,
                                                 hAdditionalStore,
                                                 TRUE
                                                 );

            pSSCtlObject->Release();
        }
    }

    return( TRUE );
}
#endif
//+---------------------------------------------------------------------------
//
//  Function:   ChainFixupUntrustedRootElementStatus
//
//  Synopsis:   fixup untrusted root element status
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFixupUntrustedRootElementStatus (
     IN PCERT_CHAIN_CONTEXT pContext
     )
{
    DWORD cChain;
    DWORD cElement;
    PCERT_CHAIN_ELEMENT pElement;

    for ( cChain = 0; cChain < pContext->cChain - 1; cChain++ )
    {
        cElement = pContext->rgpChain[ cChain ]->cElement;
        pElement = pContext->rgpChain[ cChain ]->rgpElement[ cElement - 1 ];
        pElement->TrustStatus.dwErrorStatus &= ~CERT_TRUST_IS_UNTRUSTED_ROOT;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateWorldStore
//
//  Synopsis:   create the world store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     IN DWORD dwStoreFlags,
     OUT HCERTSTORE* phWorld
     )
{
    BOOL       fResult;
    HCERTSTORE hWorld;
    HCERTSTORE hStore;
    DWORD      cCount;

    hWorld = CertOpenStore(
                 CERT_STORE_PROV_COLLECTION,
                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                 NULL,
                 CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                 NULL
                 );

    if ( hWorld == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hWorld, hRoot, 0, 0 );

    for ( cCount = 0;
          ( cCount < cAdditionalStore ) && ( fResult == TRUE );
          cCount++ )
    {
        fResult = CertAddStoreToCollection(
                      hWorld,
                      rghAdditionalStore[ cCount ],
                      0,
                      0
                      );
    }

    dwStoreFlags |= CERT_STORE_MAXIMUM_ALLOWED_FLAG;

    if ( fResult == TRUE )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags,
                     L"trust"
                     );

        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags,
                     L"ca"
                     );

        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags,
                     L"my"
                     );

        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        *phWorld = hWorld;
    }
    else
    {
        CertCloseStore( hWorld, 0 );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateEngineStore
//
//  Synopsis:   create the engine store and the change event handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateEngineStore (
     IN HCERTSTORE hRootStore,
     IN HCERTSTORE hTrustStore,
     IN HCERTSTORE hOtherStore,
     IN BOOL fDefaultEngine,
     IN DWORD dwFlags,
     OUT HCERTSTORE* phEngineStore,
     OUT HANDLE* phEngineStoreChangeEvent
     )
{
    BOOL       fResult = TRUE;
    HCERTSTORE hEngineStore;
    HANDLE     hEvent;

    hEngineStore = CertOpenStore(
                       CERT_STORE_PROV_COLLECTION,
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       NULL,
                       CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                       NULL
                       );

    hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( ( hEngineStore == NULL ) || ( hEvent == NULL ) )
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hRootStore, 0, 0 );
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hTrustStore, 0, 0 );
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hOtherStore, 0, 0 );
    }

    if ( ( fResult == TRUE ) &&
         ( dwFlags & CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE ) )
    {
        // BUGBUG: Someday support a let me know about errors flag
        CertControlStore(
            hEngineStore,
            0,
            CERT_STORE_CTRL_NOTIFY_CHANGE,
            &hEvent
            );
    }

    if ( fResult == TRUE )
    {
        *phEngineStore = hEngineStore;
        *phEngineStoreChangeEvent = hEvent;
    }
    else
    {
        if ( hEngineStore != NULL )
        {
            CertCloseStore( hEngineStore, 0 );
        }

        if ( hEvent != NULL )
        {
            CloseHandle( hEvent );
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsProperRestrictedRoot
//
//  Synopsis:   check to see if this restricted root store is a proper subset
//              of the real root store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsProperRestrictedRoot (
     IN HCERTSTORE hRealRoot,
     IN HCERTSTORE hRestrictedRoot
     )
{
    PCCERT_CONTEXT  pCertContext = NULL;
    PCCERT_CONTEXT  pFound = NULL;
    DWORD           cbData = MD5DIGESTLEN;
    BYTE            CertificateHash[ MD5DIGESTLEN ];
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = cbData;
    HashBlob.pbData = CertificateHash;

    while ( ( pCertContext = CertEnumCertificatesInStore(
                                 hRestrictedRoot,
                                 pCertContext
                                 ) ) != NULL )
    {
        if ( CertGetCertificateContextProperty(
                 pCertContext,
                 CERT_MD5_HASH_PROP_ID,
                 CertificateHash,
                 &cbData
                 ) == TRUE )
        {
            pFound = CertFindCertificateInStore(
                         hRealRoot,
                         X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                         0,
                         CERT_FIND_MD5_HASH,
                         &HashBlob,
                         NULL
                         );

            if ( pFound == NULL )
            {
                CertFreeCertificateContext( pCertContext );
                return( FALSE );
            }
            else
            {
                CertFreeCertificateContext( pFound );
            }
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCopyRequestedUsage
//
//  Synopsis:   copy the requested usage
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCopyRequestedUsage (
     IN PCERT_USAGE_MATCH pSource,
     OUT PCERT_USAGE_MATCH pDest
     )
{
    BOOL  fResult = TRUE;
    DWORD cCount;
    DWORD cch;

    pDest->dwType = pSource->dwType;
    pDest->Usage.cUsageIdentifier = 0;

    pDest->Usage.rgpszUsageIdentifier = new LPSTR [ pSource->Usage.cUsageIdentifier ];
    if ( pDest->Usage.rgpszUsageIdentifier != NULL )
    {
        memset(
           pDest->Usage.rgpszUsageIdentifier,
           0,
           pSource->Usage.cUsageIdentifier * sizeof( LPSTR )
           );

        for ( cCount = 0;
              ( cCount < pSource->Usage.cUsageIdentifier ) &&
              ( fResult == TRUE );
              cCount++ )
        {
            cch = strlen( pSource->Usage.rgpszUsageIdentifier[ cCount ] ) + 1;

            pDest->Usage.rgpszUsageIdentifier[ cCount ] = new CHAR [ cch ];
            if ( pDest->Usage.rgpszUsageIdentifier[ cCount ] != NULL )
            {
                pDest->Usage.cUsageIdentifier += 1;

                memcpy(
                   pDest->Usage.rgpszUsageIdentifier[ cCount ],
                   pSource->Usage.rgpszUsageIdentifier[ cCount ],
                   cch
                   );
            }
            else
            {
                fResult = FALSE;
            }
        }
    }
    else
    {
        fResult = FALSE;
    }

    if ( fResult == FALSE )
    {
        ChainFreeRequestedUsage( pDest );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeRequestedUsage
//
//  Synopsis:   free the usage structure
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeRequestedUsage (
     IN PCERT_USAGE_MATCH pRequestedUsage
     )
{
    DWORD cCount;

    for ( cCount = 0;
          cCount < pRequestedUsage->Usage.cUsageIdentifier;
          cCount++ )
    {
        delete pRequestedUsage->Usage.rgpszUsageIdentifier[ cCount ];
    }

    delete pRequestedUsage->Usage.rgpszUsageIdentifier;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsCertificateObjectRepeatedInContext
//
//  Synopsis:   check if the certificate object appears multiple times in the
//              chain context using the hash of the certificate context
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsCertificateObjectRepeatedInContext (
     IN PCCERTOBJECT pCertObject,
     IN PCERT_CHAIN_CONTEXT pContext
     )
{
    DWORD              cChain;
    DWORD              cElement;
    PCERT_SIMPLE_CHAIN pChain;
    BYTE               CertificateHash[ MD5DIGESTLEN ];
    DWORD              cbData = MD5DIGESTLEN;
    DWORD              cFound = 0;

    for ( cChain = 0; cChain < pContext->cChain; cChain++ )
    {
        pChain = pContext->rgpChain[ cChain ];

        for ( cElement = 0; cElement < pChain->cElement; cElement++ )
        {
            if ( CertGetCertificateContextProperty(
                     pChain->rgpElement[ cElement ]->pCertContext,
                     CERT_MD5_HASH_PROP_ID,
                     CertificateHash,
                     &cbData
                     ) == TRUE )
            {
                if ( memcmp(
                        pCertObject->CertificateHash(),
                        CertificateHash,
                        cbData
                        ) == 0 )
                {
                    cFound += 1;
                }
            }
        }
    }

    if ( cFound > 1 )
    {
        return( TRUE );
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFindAndAdjustChainContextToCycle
//
//  Synopsis:   find and adjust the chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFindAndAdjustChainContextToCycle (
     IN PCERT_CHAIN_CONTEXT pContext
     )
{
    DWORD iChain;
    DWORD iElement;
    DWORD iFoundChain = 0;
    DWORD iFoundElement = 0;

    for ( iChain = 0; iChain < pContext->cChain; iChain++ )
    {
        for ( iElement = 0;
              iElement < pContext->rgpChain[ iChain ]->cElement;
              iElement++ )
        {
            if ( ChainIsElementRepeatedInContext(
                      pContext,
                      iChain,
                      iElement,
                      &iFoundChain,
                      &iFoundElement
                      ) == TRUE )
            {
                pContext->cChain = iFoundChain + 1;

                if ( iFoundElement < ( pContext->rgpChain[ iFoundChain ]->cElement - 1 ) )
                {
#ifdef CAPI_INCLUDE_CTL                
                    if ( pContext->rgpChain[ iFoundChain ]->pTrustListInfo != NULL )
                    {
                        SSCtlFreeTrustListInfo(
                             pContext->rgpChain[ iFoundChain ]->pTrustListInfo
                             );

                        pContext->rgpChain[ iFoundChain ]->pTrustListInfo = NULL;
                    }
#else
					assert(!pContext->rgpChain[ iFoundChain ]->pTrustListInfo);
#endif					
                }

                pContext->rgpChain[ iFoundChain ]->cElement = iFoundElement + 1;

                pContext->rgpChain[ iFoundChain ]->rgpElement[
                           iFoundElement
                           ]->TrustStatus.dwErrorStatus |= CERT_TRUST_IS_CYCLIC;

                return;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsElementRepeatedInContext
//
//  Synopsis:   is the element repeated in the context
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsElementRepeatedInContext (
     IN PCERT_CHAIN_CONTEXT pContext,
     IN DWORD iChain,
     IN DWORD iElement,
     OUT DWORD* piFoundChain,
     OUT DWORD* piFoundElement
     )
{
    DWORD cChain;
    DWORD cElement;
    DWORD cbHash = MD5DIGESTLEN;
    BYTE  ElementHash[ MD5DIGESTLEN ];
    BYTE  FoundHash[ MD5DIGESTLEN ];

    if ( CertGetCertificateContextProperty(
             pContext->rgpChain[ iChain ]->rgpElement[ iElement ]->pCertContext,
             CERT_MD5_HASH_PROP_ID,
             ElementHash,
             &cbHash
             ) == FALSE )
    {
        return( FALSE );
    }

    for ( cChain = iChain; cChain < pContext->cChain; cChain++ )
    {
        for ( cElement = ( cChain == iChain ) ? iElement + 1 : 0;
              cElement < pContext->rgpChain[ cChain ]->cElement;
              cElement++ )
        {
            if ( CertGetCertificateContextProperty(
                     pContext->rgpChain[ cChain ]->rgpElement[ cElement ]->pCertContext,
                     CERT_MD5_HASH_PROP_ID,
                     FoundHash,
                     &cbHash
                     ) == TRUE )
            {
                if ( memcmp( ElementHash, FoundHash, cbHash ) == 0 )
                {
                    *piFoundChain = cChain;
                    *piFoundElement = cElement;
                    return( TRUE );
                }
            }
        }
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCollectionIncludingCtlCertificates
//
//  Synopsis:   create a collection which includes the source store hStore and
//              any CTL certificates from it
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCollectionIncludingCtlCertificates (
     IN HCERTSTORE hStore,
     OUT HCERTSTORE* phCollection
     )
{
    BOOL          fResult = FALSE;
    HCERTSTORE    hCollection;
    PCCTL_CONTEXT pCtlContext = NULL;

    hCollection = CertOpenStore(
                      CERT_STORE_PROV_COLLECTION,
                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                      NULL,
                      CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                      NULL
                      );

    if ( hCollection == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hCollection, hStore, 0, 0 );

#ifdef CAPI_INCLUDE_CTL
    HCERTSTORE    hCtlStore;
    while ( ( fResult == TRUE ) &&
            ( ( pCtlContext = CertEnumCTLsInStore(
                                  hStore,
                                  pCtlContext
                                  ) ) != NULL ) )
    {
        hCtlStore = CertOpenStore(
                        CERT_STORE_PROV_MSG,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        NULL,
                        0,
                        pCtlContext->hCryptMsg
                        );

        if ( hCtlStore != NULL )
        {
            fResult = CertAddStoreToCollection(
                          hCollection,
                          hCtlStore,
                          0,
                          0
                          );

            CertCloseStore( hCtlStore, 0 );
        }
    }
#endif

    if ( fResult == TRUE )
    {
        *phCollection = hCollection;
    }
    else
    {
        CertCloseStore( hCollection, 0 );
    }

    return( fResult );
}

#ifdef CAPI_INCLUDE_CRL
//+---------------------------------------------------------------------------
//
//  Function:   ChainPostProcessCheckRevocation
//
//  Synopsis:   check revocation
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainPostProcessCheckRevocation (
     IN HCERTSTORE hCrlStore,
     IN LPFILETIME pftTimeToUse,
     IN LPFILETIME pftCurrentTime,
     IN PCERT_CHAIN_CONTEXT pContext,
     IN DWORD dwFlags
     )
{
    DWORD                  cChain;
    DWORD                  cElement;
    DWORD                  cChainEnd;
    DWORD                  cLastChainElementEnd;
    DWORD                  cElementEnd;
    CERT_REVOCATION_PARA   RevPara;
    CERT_REVOCATION_STATUS RevStatus;
    BOOL                   fDoVerifyRevocation;

    memset( &RevPara, 0, sizeof( RevPara ) );
    memset( &RevStatus, 0, sizeof( RevStatus ) );

    RevPara.cbSize = sizeof( RevPara );
    RevStatus.cbSize = sizeof( RevStatus );

    assert( dwFlags & CERT_CHAIN_REVOCATION_CHECK_ALL );

    if ( dwFlags & CERT_CHAIN_REVOCATION_CHECK_END_CERT )
    {
        cChainEnd = 1;
        cLastChainElementEnd = 1;
    }
    else if ( ( dwFlags & CERT_CHAIN_REVOCATION_CHECK_CHAIN ) ||
              ( dwFlags & CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT ) )
    {
        cChainEnd = pContext->cChain;
        cLastChainElementEnd = pContext->rgpChain[ cChainEnd - 1 ]->cElement;
    }

    for ( cChain = 0; cChain < cChainEnd; cChain++ )
    {
        if ( cChain == ( cChainEnd - 1 ) )
        {
            cElementEnd = cLastChainElementEnd;
        }
        else
        {
            cElementEnd = pContext->rgpChain[ cChain ]->cElement;
        }

        for ( cElement = 0; cElement < cElementEnd; cElement++ )
        {
            fDoVerifyRevocation = TRUE;

            if ( cElement == ( pContext->rgpChain[ cChain ]->cElement - 1 ) )
            {
                if ( pContext->rgpChain[ cChain ]->rgpElement[ cElement ]->TrustStatus.dwInfoStatus &
                     CERT_TRUST_IS_SELF_SIGNED )
                {
                    if ( dwFlags & CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT )
                    {
                        RevStatus.dwError = 0;
                        RevStatus.dwIndex = 0;
                        RevStatus.dwReason = 0;

                        fDoVerifyRevocation = FALSE;
                    }
                    else
                    {
                        RevPara.pIssuerCert = pContext->rgpChain[ cChain ]->rgpElement[ cElement ]->pCertContext;
                    }
                }
                else
                {
                    RevStatus.dwError = CRYPT_E_NO_REVOCATION_CHECK;
                    RevStatus.dwIndex = 0;
                    RevStatus.dwReason = 0;

                    fDoVerifyRevocation = FALSE;
                }
            }
            else
            {
                RevPara.pIssuerCert = pContext->rgpChain[ cChain ]->rgpElement[ cElement + 1 ]->pCertContext;
            }

            if ( fDoVerifyRevocation == TRUE )
            {
                RevPara.hCrlStore = hCrlStore;

                if ( cChain > 0 )
                {
                    RevPara.pftTimeToUse = pftCurrentTime;
                }
                else
                {
                    RevPara.pftTimeToUse = pftTimeToUse;
                }

                if ( CertVerifyRevocation(
                         X509_ASN_ENCODING,
                         CERT_CONTEXT_REVOCATION_TYPE,
                         1,
                         (LPVOID *)&pContext->rgpChain[ cChain ]->rgpElement[ cElement ]->pCertContext,
                         ( dwFlags & CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY ) ?
                         CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION : 0,
                         &RevPara,
                         &RevStatus
                         ) == TRUE )
                {
                    RevStatus.dwError = 0;
                    RevStatus.dwIndex = 0;
                    RevStatus.dwReason = 0;
                }
            }

            ChainSetRevocationInfo( pContext, &RevStatus, cChain, cElement );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainSetRevocationInfo
//
//  Synopsis:   set the revocation information on the element
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainSetRevocationInfo (
     IN PCERT_CHAIN_CONTEXT pContext,
     IN PCERT_REVOCATION_STATUS pRevStatus,
     IN DWORD iChain,
     IN DWORD iElement
     )
{
    PCERT_CHAIN_ELEMENT pElement;

    if ( pRevStatus->dwError == ERROR_SUCCESS )
    {
        return;
    }

    pElement = pContext->rgpChain[ iChain ]->rgpElement[ iElement ];

    if ( pRevStatus->dwError == CRYPT_E_REVOKED )
    {
        pElement->TrustStatus.dwErrorStatus |= CERT_TRUST_IS_REVOKED;
    }
    else
    {
        pElement->TrustStatus.dwErrorStatus |= CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
    }

    pElement->pRevocationInfo = new CERT_REVOCATION_INFO;
    if ( pElement->pRevocationInfo == NULL )
    {
        return;
    }

    memset( pElement->pRevocationInfo, 0, sizeof( CERT_REVOCATION_INFO ) );

    pElement->pRevocationInfo->cbSize = sizeof( CERT_REVOCATION_INFO );
    pElement->pRevocationInfo->dwRevocationResult = pRevStatus->dwError;
}
#endif	//CAPI_INCLUDE_CRL

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeRevocationInfo
//
//  Synopsis:   free the revocation info data
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeRevocationInfo (
     IN PCERT_REVOCATION_INFO pRevocationInfo
     )
{
    delete pRevocationInfo;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetObjectUrl
//
//  Synopsis:   thunk to CryptGetObjectUrl in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetObjectUrl (
     IN LPCSTR pszUrlOid,
     IN LPVOID pvPara,
     IN DWORD dwFlags,
     OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
     IN OUT DWORD* pcbUrlArray,
     OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
     IN OUT OPTIONAL DWORD* pcbUrlInfo,
     IN OPTIONAL LPVOID pvReserved
     )
{
#ifndef _XBOX
    BOOL             fResult = FALSE;
    HMODULE          hModule;
    PFN_GETOBJECTURL pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_GETOBJECTURL)GetProcAddress( hModule, CEUNICODE("CryptGetObjectUrl") );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )(
                      pszUrlOid,
                      pvPara,
                      dwFlags,
                      pUrlArray,
                      pcbUrlArray,
                      pUrlInfo,
                      pcbUrlInfo,
                      pvReserved
                      );
    }

    return( fResult );
#else
	ASSERT(!"chain.cpp called");
	return TRUE;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRetrieveObjectByUrlW
//
//  Synopsis:   thunk to CryptRetrieveObjectByUrlW in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainRetrieveObjectByUrlW (
     IN LPCWSTR pszUrl,
     IN LPCSTR pszObjectOid,
     IN DWORD dwRetrievalFlags,
     IN DWORD dwTimeout,
     OUT LPVOID* ppvObject,
     IN HCRYPTASYNC hAsyncRetrieve,
     IN PCRYPT_CREDENTIALS pCredentials,
     IN LPVOID pvVerify,
     IN LPVOID pvReserved
     )
{
#ifndef _XBOX
    BOOL                     fResult = FALSE;
    HMODULE                  hModule;
    PFN_RETRIEVEOBJECTBYURLW pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_RETRIEVEOBJECTBYURLW)GetProcAddress(
                                          hModule,
                                          CEUNICODE("CryptRetrieveObjectByUrlW")
                                          );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )(
                      pszUrl,
                      pszObjectOid,
                      dwRetrievalFlags,
                      dwTimeout,
                      ppvObject,
                      hAsyncRetrieve,
                      pCredentials,
                      pvVerify,
                      pvReserved
                      );
    }

    return( fResult );
#else
	ASSERT(!"chain.cpp called");
	return TRUE;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsFileOrLdapUrl
//
//  Synopsis:   check if the URL given is a file or ldap one
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsFileOrLdapUrl (
     IN LPCWSTR pwszUrl
     )
{
    LPWSTR pwsz;

    pwsz = wcschr( pwszUrl, L':' );
    if ( pwsz != NULL )
    {
        if ( ( _wcsnicmp( pwszUrl, L"file", 4 ) == 0 ) ||
             ( _wcsnicmp( pwszUrl, L"ldap", 4 ) == 0 ) )
        {
            return( TRUE );
        }
        else
        {
            return( FALSE );
        }
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\callctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       callctx.h
//
//  Contents:   Certificate Chaining Infrastructure Call Context
//
//  History:    02-Mar-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CALLCTX_H__)
#define __CALLCTX_H__

#include <chain.h>

#define CYCLE_DETECTION_MODULUS        25
#define DEFAULT_CREATION_CACHE_BUCKETS 13

//
// The call context object provides a mechanism for packaging and passing
// around per-call data in the certificate chaining infrastructure.
//

class CChainCallContext
{
public:

    //
    // Construction
    //

    CChainCallContext (
          OUT BOOL& rfResult
          );

    ~CChainCallContext ();

    //
    // Cert Object Creation Cache
    //
    // This caches all certificate objects created in the context of this
    // call.
    //

    BOOL AddObjectToCreationCache (
            IN PCCERTOBJECT pCertObject
            );

    PCCERTOBJECT FindObjectInCreationCache (
                     IN PCRYPT_DATA_BLOB pIdentifier
                     );

    inline HLRUCACHE CreationCache ();

private:

    //
    // Cert Object Creation cache
    //
    // NOTE: LRU is turned off
    //

    HLRUCACHE m_hObjectCreationCache;
};

//
// Call Context Utility Functions
//

BOOL WINAPI
CallContextCreateCallObject (
    OUT PCCHAINCALLCONTEXT* ppCallContext
    );

VOID WINAPI
CallContextFreeCallObject (
    IN PCCHAINCALLCONTEXT pCallContext
    );

VOID WINAPI
CallContextOnCreationCacheObjectRemoval (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    );

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CreationCache, public
//
//  Synopsis:   creation cache
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CChainCallContext::CreationCache ()
{
    return( m_hObjectCreationCache );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\chain.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       chain.h
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    13-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CHAIN_H__)
#define __CHAIN_H__

#include <windows.h>
#include <wincrypt.h>
#include <lrucache.h>
#include <msr_md5.h>

//
// Certificate Object Forward class declarations
//

class CCertObject;
class CCertIssuerList;
class CCertObjectCache;
class CCertChainEngine;
class CCertChainContext;

//
// Certificate Object Class pointer typedefs
//

typedef CCertObject*       PCCERTOBJECT;
typedef CCertIssuerList*   PCCERTISSUERLIST;
typedef CCertObjectCache*  PCCERTOBJECTCACHE;
typedef CCertChainEngine*  PCCERTCHAINENGINE;
typedef CCertChainContext* PCCERTCHAINCONTEXT;

//
// SSCTL Forward class declarations
//

class CSSCtlObject;
class CSSCtlObjectCache;

//
// SSCTL Class pointer typedefs
//

typedef class CSSCtlObject*      PCSSCTLOBJECT;
typedef class CSSCtlObjectCache* PCSSCTLOBJECTCACHE;

//
// Call Context Forward class declarations
//

class CChainCallContext;
class CChainPathObject;

//
// Call Context class pointer typedefs
//

typedef CChainCallContext* PCCHAINCALLCONTEXT;
typedef CChainPathObject*  PCCHAINPATHOBJECT;

//
// Certificate Object Identifier.  This is a unique identifier for a certificate
// object and is the MD5 hash of the issuer and serial no.
//

typedef BYTE CERT_OBJECT_IDENTIFIER[ MD5DIGESTLEN ];

//
// CCertObject.  This is the main object used for caching trust information
// about a certificate
//

class CCertObject
{
public:

    //
    // Construction
    //

    CCertObject (
         IN PCCERTCHAINENGINE pChainEngine,
         IN PCCHAINCALLCONTEXT pCallContext,
         IN PCCERT_CONTEXT pCertContext,
         IN PCRYPT_HASH_BLOB pCertHash,
         IN PCERT_TRUST_STATUS pKnownStatus,
         IN HCERTSTORE hAdditionalStore,
         OUT BOOL& rfResult
         );

    ~CCertObject ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Identifier access
    //

    inline VOID GetObjectIdentifier (
                   OUT CERT_OBJECT_IDENTIFIER ObjectIdentifier
                   );

    //
    // Trust information access
    //

    inline PCCERT_CONTEXT CertContext ();

    inline PCERT_ENHKEY_USAGE Usage ();

    inline DWORD ErrorStatus ();

    inline DWORD InfoStatus ();

    inline PCERT_TRUST_STATUS TrustStatus ();

    VOID CalculateAdditionalStatus (
                  IN LPFILETIME pTime,
                  IN PCERT_USAGE_MATCH pRequestedUsage,
                  IN DWORD dwFlags,
                  OUT PCERT_TRUST_STATUS pAdditionalStatus
                  );

    DWORD ChainErrorStatus ();

    //
    // Hash access
    //

    inline DWORD CertificateHashSize ();
    inline LPBYTE CertificateHash ();

    //
    // Key identifier access
    //

    inline DWORD KeyIdentifierSize ();
    inline LPBYTE KeyIdentifier ();

    //
    // Issuer access
    //

    inline PCERT_AUTHORITY_KEY_ID_INFO AuthorityKeyIdentifier ();

    inline PCCERTISSUERLIST IssuerList ();

    BOOL GetIssuer (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN LPFILETIME pTime,
            IN LPFILETIME pCurrentTime,
            IN HCERTSTORE hStore,
            IN PCERT_USAGE_MATCH pRequestedUsage,
            IN DWORD dwFlags,
            OUT PCCERTOBJECT* ppCertObject,
            OUT PCERT_TRUST_STATUS pSubjectStatus,
            OUT PCERT_TRUST_STATUS pAdditionalStatus,
            OUT PCERT_TRUST_STATUS pCtlStatus,
            OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo,
            OUT PCERT_USAGE_MATCH pTrustListRequestedUsage,
            OUT LPFILETIME pTrustListRequestedTime
            );

    //
    // The index entry handles for the Certificate Object Cache are maintained
    // on the object itself.  The primary index entry is the hash index entry
    //

    inline HLRUENTRY HashIndexEntry ();

    inline HLRUENTRY IdentifierIndexEntry ();

    inline HLRUENTRY SubjectNameIndexEntry ();

    inline HLRUENTRY IssuerNameIndexEntry ();

    inline HLRUENTRY KeyIdIndexEntry ();

    //
    // Chain engine access
    //

    inline PCCERTCHAINENGINE ChainEngine ();

private:

    //
    // Reference count
    //

    ULONG                       m_cRefs;

    //
    // Certificate Object Identifier
    //

    CERT_OBJECT_IDENTIFIER      m_ObjectIdentifier;

    //
    // Certificate context
    //

    PCCERT_CONTEXT              m_pCertContext;

    //
    // MD5 Hash of the certificate
    //

    BYTE                        m_CertificateHash[ MD5DIGESTLEN ];

    //
    // Key Identifier of the certificate
    //

    DWORD                       m_cbKeyIdentifier;
    LPBYTE                      m_pbKeyIdentifier;

    //
    // Trust Status.  This does not represent the full trust status
    // for the object.  Some of the bits are calculated on demand and placed
    // into the ending chain context.  The following are the trust status
    // bits which can appear here
    //
    // CERT_TRUST_IS_SELF_SIGNED
    // CERT_TRUST_HAS_EXACT_MATCH_ISSUER
    // CERT_TRUST_HAS_NAME_MATCH_ISSUER
    // CERT_TRUST_HAS_KEY_MATCH_ISSUER
    //
    // CERT_TRUST_IS_NOT_SIGNATURE_VALID (if the certificate is self-signed)
    // CERT_TRUST_IS_UNTRUSTED_ROOT (if the certificate is self-signed)
    //

    CERT_TRUST_STATUS           m_TrustStatus;

    //
    // Usage.  This usage has been merged and sorted based on extensions and
    // properties on the certificate context.
    //

    PCERT_ENHKEY_USAGE          m_pUsage;

    //
    // Authority Key Identifier.  This contains the issuer and serial number
    // of the issuing certificate for this certificate object if the trust
    // status includes CERT_TRUST_HAS_EXACT_MATCH_ISSUER
    //

    PCERT_AUTHORITY_KEY_ID_INFO m_pAuthKeyIdentifier;

    //
    // Issuer Certificate Objects.  The list of issuers of this
    // certificate object along with information about those issuers
    // relevant to this subject.
    //

    PCCERTISSUERLIST            m_pIssuerList;

    //
    // Certificate Chain Engine which owns this certificate object
    //

    PCCERTCHAINENGINE           m_pChainEngine;

    //
    // Certificate Object Cache Index entries
    //

    HLRUENTRY                   m_hHashEntry;
    HLRUENTRY                   m_hIdentifierEntry;
    HLRUENTRY                   m_hSubjectNameEntry;
    HLRUENTRY                   m_hIssuerNameEntry;
    HLRUENTRY                   m_hKeyIdEntry;
};

//
// CCertIssuerList.  List of issuer certificate objects along with related
// issuer information.  This is used by the certificate object to cache
// its possible set of issuers
//

// Currently in a self signed certificate object, the issuer elements will
// have CTL issuer data set and pIssuer may be NULL if we haven't yet gotten
// the CTL signer

typedef struct _CTL_ISSUER_DATA {

    PCSSCTLOBJECT         pSSCtlObject;
    PCERT_TRUST_LIST_INFO pTrustListInfo;
    BOOL                  fAdditionalStoreSigner;

} CTL_ISSUER_DATA, *PCTL_ISSUER_DATA;

typedef struct _CERT_ISSUER_ELEMENT {

    BOOL                         fCtlIssuer;
    PCCERTOBJECT                 pIssuer;
    CERT_TRUST_STATUS            SubjectStatus;
    CERT_TRUST_STATUS            ChainStatus;
    BOOL                         fAdditionalStore;
    PCTL_ISSUER_DATA             pCtlIssuerData;
    struct _CERT_ISSUER_ELEMENT* pPrevElement;
    struct _CERT_ISSUER_ELEMENT* pNextElement;

} CERT_ISSUER_ELEMENT, *PCERT_ISSUER_ELEMENT;

class CCertIssuerList
{
public:

    //
    // Construction
    //

    CCertIssuerList (
         IN PCCERTOBJECT pSubject
         );

    ~CCertIssuerList ();

    //
    // Issuer management
    //

    inline BOOL IsEmpty ();

    BOOL AddIssuer (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERTOBJECT pIssuer,
            IN BOOL fAdditionalStore,
            IN BOOL fCheckForDuplicate
            );

    BOOL AddCtlIssuer (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCSSCTLOBJECT pSSCtlObject,
            IN BOOL fAdditionalStore,
            IN HCERTSTORE hAdditionalStore,
            IN BOOL fCheckForDuplicate
            );

    //
    // List Flushing and Restoration
    //

    inline BOOL IsFlushed ();

    inline BOOL IsCtlIssuerFlushed ();

    VOID Flush ();

    VOID CtlIssuerFlush (IN PCCERTOBJECT pCtlIssuer);

    BOOL Restore (IN PCCHAINCALLCONTEXT pCallContext, IN BOOL fForce);

    //
    // Additional store element retrieval and purging
    //

    inline BOOL IsAdditionalStoreProcessed ();

    BOOL GetAdditionalStoreIssuers (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN HCERTSTORE hAdditionalStore
            );

    VOID PurgeAdditionalStoreIssuers ();

    //
    // Element management
    //

    BOOL CreateElement (
               IN PCCHAINCALLCONTEXT pCallContext,
               IN BOOL fCtlIssuer,
               IN PCCERTOBJECT pIssuer,
               IN BOOL fAdditionalStore,
               IN HCERTSTORE hAdditionalStore,
               IN PCSSCTLOBJECT pSSCtlObject,
               IN PCERT_TRUST_LIST_INFO pTrustListInfo,
               OUT PCERT_ISSUER_ELEMENT* ppElement
               );

    VOID DeleteElement (
               IN PCERT_ISSUER_ELEMENT pElement
               );

    inline VOID AddElement (
                   IN PCERT_ISSUER_ELEMENT pElement
                   );

    inline VOID RemoveElement (
                      IN PCERT_ISSUER_ELEMENT pElement
                      );

    BOOL CheckForDuplicateElement (
              IN PCRYPT_HASH_BLOB pHashBlob,
              IN BOOL fCtlIssuer
              );

    //
    // Enumerate the issuers
    //

    inline PCERT_ISSUER_ELEMENT PrevElement (
                                    IN PCERT_ISSUER_ELEMENT pElement
                                    );

    inline PCERT_ISSUER_ELEMENT NextElement (
                                    IN PCERT_ISSUER_ELEMENT pElement
                                    );

private:

    //
    // Subject Certificate Object
    //
    // NOTE: This is NOT ref-counted
    //

    PCCERTOBJECT          m_pSubject;

    //
    // Signature Valid Issuer public key
    //

    PCERT_PUBLIC_KEY_INFO m_pIssuerPublicKey;

    //
    // Issuer List
    //

    PCERT_ISSUER_ELEMENT  m_pHead;

    //
    // Flush flag
    //

    BOOL                  m_fFlushed;
    BOOL                  m_fCtlIssuerFlushed;

    //
    // Processed additional store
    //

    BOOL                  m_fAdditionalStoreProcessed;
};

//
// The implementation of CCertObject::GetIssuer will choose the issuer with
// the highest quality from the issuer list.  Quality Values are as follows:
//
// BUGBUG: Consider minimum quality level configuration for chain engine
//

#define CERT_QUALITY_ISSUER_TIME_NESTED     0x00000001
#define CERT_QUALITY_CHAIN_TIME_NESTED      0x00000002
#define CERT_QUALITY_ISSUER_TIME_VALID      0x00000004
#define CERT_QUALITY_MEETS_USAGE_CRITERIA   0x00000008
#define CERT_QUALITY_HAS_PROTECTED_ROOT     0x00000010
#define CERT_QUALITY_ISSUER_SIGNATURE_VALID 0x00000020
#define CERT_QUALITY_CHAIN_SIGNATURE_VALID  0x00000040

// Large negative value for minimum quality
#define CERT_QUALITY_MINIMUM                0xFFFFFFFF

//
// CCertObjectCache.  Cache of certificate object references indexed by the
// following keys:
//
//      Certificate Hash
//      Certificate Object Identifier
//      Subject Name
//      Issuer Name
//
// The indexes are built upon hash tables of which the primary index (The
// Certificate Hash) is LRU maintained.  Touching a cache entry therefore
// means touching the LRU entry on the primary index which is actually
// maintained on the certificate object itself.
//

#define DEFAULT_CERT_OBJECT_CACHE_BUCKETS 127
#define DEFAULT_MAX_INDEX_ENTRIES         256

typedef BOOL (WINAPI *PFN_ENUM_CERTOBJECTS) (
                          IN LPVOID pvParameter,
                          IN PCCERTOBJECT pCertObject
                          );

class CCertObjectCache
{
public:

    //
    // Construction
    //

    CCertObjectCache (
         IN DWORD MaxIndexEntries,
         OUT BOOL& rfResult
         );

    ~CCertObjectCache ();

    //
    // Certificate Object Management
    //

    BOOL AddObject (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERTOBJECT pCertObject,
            IN BOOL fCheckForDuplicate
            );

    //
    // Access the indexes
    //

    inline HLRUCACHE HashIndex ();

    inline HLRUCACHE IdentifierIndex ();

    inline HLRUCACHE SubjectNameIndex ();

    inline HLRUCACHE IssuerNameIndex ();

    inline HLRUCACHE KeyIdIndex ();

    //
    // Certificate Object Searching
    //

    PCCERTOBJECT FindObjectByHash (
                     IN PCRYPT_HASH_BLOB pHash
                     );

    PCCERTOBJECT FindObjectByIdentifier (
                     IN CERT_OBJECT_IDENTIFIER ObjectIdentifier
                     );

    PCCERTOBJECT FindObjectBySubjectName (
                     IN PCERT_NAME_BLOB pSubjectName
                     );

    PCCERTOBJECT FindObjectByIssuerName (
                     IN PCERT_NAME_BLOB pIssuerName
                     );

    PCCERTOBJECT FindObjectByKeyId (
                     IN PCRYPT_HASH_BLOB pKeyId
                     );

    //
    // Certificate Object Enumeration
    //

    PCCERTOBJECT NextMatchingObjectByIdentifier (
                     IN PCCERTOBJECT pCertObject
                     );

    PCCERTOBJECT NextMatchingObjectBySubjectName (
                     IN PCCERTOBJECT pCertObject
                     );

    PCCERTOBJECT NextMatchingObjectByIssuerName (
                     IN PCCERTOBJECT pCertObject
                     );

    PCCERTOBJECT NextMatchingObjectByKeyId (
                     IN PCCERTOBJECT pCertObject
                     );

    VOID EnumObjects (
             IN PFN_ENUM_CERTOBJECTS pfnEnum,
             IN LPVOID pvParameter
             );

    //
    // LRU control
    //

    inline VOID EnableLruOfObjects (IN PCCHAINCALLCONTEXT pCallContext);

    inline VOID DisableLruOfObjects ();

    //
    // Cache flushing
    //

    inline VOID FlushObjects (IN PCCHAINCALLCONTEXT pCallContext);

private:

    //
    // Certificate Hash Index
    //

    HLRUCACHE m_hHashIndex;

    //
    // Certificate Object Identifier Index
    //

    HLRUCACHE m_hIdentifierIndex;

    //
    // Subject Name Index
    //

    HLRUCACHE m_hSubjectNameIndex;

    //
    // Issuer Name Index
    //

    HLRUCACHE m_hIssuerNameIndex;

    //
    // Key Identifier Index
    //

    HLRUCACHE m_hKeyIdIndex;

    //
    // Private methods
    //

    PCCERTOBJECT FindObject (
                     IN HLRUCACHE hIndex,
                     IN PCRYPT_DATA_BLOB pIdentifier
                     );

    PCCERTOBJECT NextMatchingObject (
                     IN HLRUENTRY hObjectEntry,
                     IN PCCERTOBJECT pCertObject
                     );
};

//
// Certificate Object Cache Primary Index Entry Removal Notification
//
// Free entry data from certificate object cache when LRU'd from the primary
// index ( the certificate hash ).  This should remove the relevant entries
// from the other indexes and release the reference on the certificate object
// maintained by the primary index.
//

VOID WINAPI
CertObjectCacheOnRemovalFromPrimaryIndex (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    );

//
// Certificate Object Cache Identifier Hashing Functions
//

DWORD WINAPI
CertObjectCacheHashMd5Identifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    );

DWORD WINAPI
CertObjectCacheHashNameIdentifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    );

//
// Certificate Object Cache Enumerator Function
//

typedef struct _CHAIN_ENUM_OBJECTS_DATA {

    PFN_ENUM_CERTOBJECTS pfnEnumObjects;
    LPVOID               pvEnumParameter;

} CHAIN_ENUM_OBJECTS_DATA, *PCHAIN_ENUM_OBJECTS_DATA;

BOOL WINAPI
ChainEnumObjectsWalkFn (
     IN LPVOID pvParameter,
     IN HLRUENTRY hEntry
     );

//
// CCertChainEngine.  The chaining engine satisfies requests for chain contexts
// given some set of parameters.  In order to make the building of these
// contexts efficient, the chain engine caches trust and chain information
// for certificates
//

class CCertChainEngine
{
public:

    //
    // Construction
    //

    CCertChainEngine (
         IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
         IN BOOL fDefaultEngine,
         OUT BOOL& rfResult
         );

    ~CCertChainEngine ();

    //
    // Chain Engine Locking
    //

    inline VOID LockEngine ();
    inline VOID UnlockEngine ();

    //
    // Chain Engine reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Cache access
    //

    inline PCCERTOBJECTCACHE CertObjectCache ();
#ifdef CAPI_INCLUDE_CTL    
    inline PCSSCTLOBJECTCACHE SSCtlObjectCache ();
#endif    

    //
    // Store access
    //

    inline HCERTSTORE RootStore ();
    inline HCERTSTORE RealRootStore ();
    inline HCERTSTORE TrustStore ();
    inline HCERTSTORE OtherStore ();

    //
    // Cycle detection modulus access
    //

    inline DWORD CycleDetectionModulus ();

    //
    // Chain Context Retrieval
    //

    BOOL GetChainContext (
            IN PCCERT_CONTEXT pCertContext,
            IN LPFILETIME pTime,
            IN LPFILETIME pCurrentTime,
            IN HCERTSTORE hAdditionalStore,
            IN PCERT_USAGE_MATCH pRequestedUsage,
            IN DWORD dwFlags,
            IN LPVOID pvReserved,
            OUT PCCERT_CHAIN_CONTEXT* ppChainContext
            );

    //
    // Simple Chain Retrieval
    //

    BOOL AddSimpleChain (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERTCHAINCONTEXT pCertChainContext,
            IN DWORD NewSimpleChainIndex,
            IN PCCERTOBJECT pEndCertObject,
            IN PCERT_TRUST_STATUS pEndAdditionalStatus,
            IN LPFILETIME pTime,
            IN LPFILETIME pCurrentTime,
            IN HCERTSTORE hAdditionalStore,
            IN PCERT_USAGE_MATCH pRequestedUsage,
            IN DWORD dwFlags,
            IN LPVOID pvReserved,
            OUT PCCERTOBJECT* ppNextEndCertObject,
            OUT PCERT_TRUST_STATUS pNextEndAdditionalStatus,
            OUT PCERT_USAGE_MATCH pNextEndRequestedUsage,
            OUT LPFILETIME pNextEndRequestedTime
            );

    //
    // Find and store issuers for a particular certificate either exact match
    // or name match algorithms
    //

    BOOL FindAndStoreMatchingIssuers (
             IN PCCERTOBJECT pCertObject,
             IN PCCHAINCALLCONTEXT pCallContext
             );

    BOOL FindAndStoreExactMatchIssuers (
             IN PCCERTOBJECT pCertObject,
             IN PCCHAINCALLCONTEXT pCallContext
             );

    BOOL FindAndStoreNameMatchIssuers (
             IN PCCERTOBJECT pCertObject,
             IN PCCHAINCALLCONTEXT pCallContext
             );

    BOOL FindAndStoreKeyMatchIssuers (
             IN PCCERTOBJECT pCertObject,
             IN PCCHAINCALLCONTEXT pCallContext
             );

    BOOL RetrieveAndStoreMatchingIssuersByUrl (
                 IN PCCERTOBJECT pCertObject,
                 IN PCCHAINCALLCONTEXT pCallContext,
                 IN DWORD dwFlags
                 );

    BOOL FindAndStoreCtlIssuers (
             IN PCCERTOBJECT pCertObject,
             IN PCCHAINCALLCONTEXT pCallContext
             );

    //
    // Resync the engine
    //

    BOOL Resync (IN PCCHAINCALLCONTEXT pCallContext, BOOL fForce);

private:

    //
    // Reference count
    //

    ULONG                    m_cRefs;

    //
    // Engine Lock
    //

    CRITICAL_SECTION         m_Lock;

    //
    // Root store ( Certs )
    //

    HCERTSTORE               m_hRealRootStore;
    HCERTSTORE               m_hRootStore;

    //
    // Trust Store Collection ( CTLs )
    //

    HCERTSTORE               m_hTrustStore;

    //
    // Other store collection ( Certs and CRLs )
    //

    HCERTSTORE               m_hOtherStore;

    //
    // Engine Store ( Collection of Root, Trust and Other )
    //

    HCERTSTORE               m_hEngineStore;

    //
    // Engine Store Change Notification Event
    //

    HANDLE                   m_hEngineStoreChangeEvent;

    //
    // Engine flags
    //

    DWORD                    m_dwFlags;

    //
    // Retrieval timeout
    //

    DWORD                    m_dwUrlRetrievalTimeout;

    //
    // Cycle detection modulus
    //

    DWORD                    m_CycleDetectionModulus;

    //
    // Certificate Object Cache
    //

    PCCERTOBJECTCACHE        m_pCertObjectCache;

#ifdef CAPI_INCLUDE_CTL
    //
    // Self Signed Certificate Trust List Object Cache
    //

    PCSSCTLOBJECTCACHE       m_pSSCtlObjectCache;
#endif    
};

//
// CCertChainContext.  The chain context object is used to manage the creation
// of the chain context data structure which is exported to clients of this
// infrastructure.
//

#define INITIAL_CHAIN_ALLOC                1
#define GROW_CHAIN_ALLOC                   2
#define GROW_ELEMENT_ALLOC                 5

typedef struct _INTERNAL_CERT_CHAIN_CONTEXT {

    CERT_CHAIN_CONTEXT ChainContext;
    ULONG              cRefs;
    DWORD              cSimpleChain;
    DWORD*             rgElementCount;
    DWORD              TotalElements;

} INTERNAL_CERT_CHAIN_CONTEXT, *PINTERNAL_CERT_CHAIN_CONTEXT;

class CCertChainContext
{
public:

    //
    // Construction
    //

    CCertChainContext (OUT BOOL& rfResult);

    ~CCertChainContext ();

    //
    // Context management
    //

    BOOL AddChainElement (
            IN DWORD SimpleChain,
            IN PCCERTOBJECT pCertObject,
            IN PCERT_TRUST_STATUS pSubjectStatus,
            IN PCERT_TRUST_STATUS pAdditionalStatus,
            IN PCERT_TRUST_STATUS pCtlStatus,
            IN PCERT_TRUST_LIST_INFO pTrustListInfo
            );

    inline DWORD ElementCount (
                        IN DWORD SimpleChain
                        );

    VOID UpdateSummaryStatus ();

    VOID UpdateEndEntityCertContext (PCCERT_CONTEXT pEndCertContext);

    //
    // Access the context
    //

    inline PINTERNAL_CERT_CHAIN_CONTEXT InternalContext ();
    inline PCERT_CHAIN_CONTEXT ExposedContext ();

private:

    //
    // Chain Context
    //

    PINTERNAL_CERT_CHAIN_CONTEXT m_pContext;

    //
    // Private methods
    //

    BOOL GrowSimpleChains (IN DWORD cGrowChain);

    BOOL GrowChainElements (IN DWORD SimpleChain, IN DWORD cGrowElement);
};

//
// Chain Infrastructure Utility Function Prototypes
//

VOID WINAPI
ChainCreateCertificateObjectIdentifier (
     IN PCERT_NAME_BLOB pIssuer,
     IN PCRYPT_INTEGER_BLOB pSerialNumber,
     OUT CERT_OBJECT_IDENTIFIER ObjectIdentifier
     );

BOOL WINAPI
ChainGetCertificateUsage (
     IN PCCERT_CONTEXT pCertContext,
     OUT PCERT_ENHKEY_USAGE* ppUsage
     );

VOID WINAPI
ChainFreeCertificateUsage (
     IN PCERT_ENHKEY_USAGE pUsage
     );

BOOL WINAPI
ChainCreateIssuerList (
     IN PCCERTOBJECT pSubject,
     OUT PCCERTISSUERLIST* ppIssuerList
     );

VOID WINAPI
ChainFreeIssuerList (
     IN PCCERTISSUERLIST pIssuerList
     );

VOID WINAPI
ChainGetSelfSignedStatus (
     IN PCCERTOBJECT pCertObject,
     OUT PCERT_TRUST_STATUS pStatus
     );

VOID WINAPI
ChainGetRootStoreStatus (
     IN HCERTSTORE hRoot,
     IN HCERTSTORE hRealRoot,
     IN PCRYPT_HASH_BLOB pMd5Hash,
     OUT PCERT_TRUST_STATUS pStatus
     );

VOID WINAPI
ChainGetIssuerMatchStatus (
     IN PCCERT_CONTEXT pCertContext,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdInfo,
     OUT PCERT_TRUST_STATUS pStatus
     );

VOID WINAPI
ChainFreeAuthorityKeyIdentifier (
     IN PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdInfo
     );

VOID WINAPI
ChainGetUsageStatus (
     IN PCERT_ENHKEY_USAGE pRequestedUsage,
     IN PCERT_ENHKEY_USAGE pAvailableUsage,
     IN DWORD dwMatchType,
     OUT PCERT_TRUST_STATUS pStatus
     );

BOOL WINAPI
ChainFindAndStoreMatchingIssuersFromCertStore (
     IN PCCERTOBJECT pCertObject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN HCERTSTORE hStore,
     IN BOOL fAdditionalStore,
     IN BOOL fCacheIssuers
     );

BOOL WINAPI
ChainCreateIssuerMatchStores (
     IN PCCERTOBJECT pCertObject,
     IN HCERTSTORE hStore,
     IN BOOL fCacheIssuers,
     OUT HCERTSTORE* phCacheIssuersStore,
     OUT HCERTSTORE* phIssuerListStore
     );

BOOL WINAPI
ChainIsMatchingIssuerCertificate (
     IN PCCERTOBJECT pSubject,
     IN PCCERT_CONTEXT pIssuer
     );

BOOL WINAPI
ChainIsInSameIssuerGrouping (
     IN PCCERTOBJECT pGroupMember,
     IN PCCERT_CONTEXT pPossibleGroupMember
     );

BOOL WINAPI
ChainCreateCertificateObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERT_CONTEXT pCertContext,
     IN PCRYPT_HASH_BLOB pHashBlob,
     IN OPTIONAL PCERT_TRUST_STATUS pKnownStatus,
     IN OPTIONAL HCERTSTORE hAdditionalStore,
     OUT PCCERTOBJECT* ppCertObject,
     OUT BOOL* pfFromCallCreationCache
     );

LONG WINAPI
ChainGetIssuerQuality (
     IN PCERT_ISSUER_ELEMENT pElement,
     IN LPFILETIME pTime,
     IN LPFILETIME pCurrentTime,
     IN PCERT_USAGE_MATCH pRequestedUsage,
     IN DWORD dwFlags,
     OUT PCERT_TRUST_STATUS pAdditionalStatus,
     OUT PCERT_TRUST_STATUS pCtlStatus,
     OUT PCERT_USAGE_MATCH pCtlSignerRequestedUsage,
     OUT LPFILETIME pCtlSignerRequestedTime
     );

VOID WINAPI
ChainGetSubjectStatus (
     IN PCCERTOBJECT pIssuer,
     IN OPTIONAL PCERT_PUBLIC_KEY_INFO pIssuerPublicKey,
     IN PCCERTOBJECT pSubject,
     OUT PCERT_TRUST_STATUS pStatus
     );

VOID WINAPI
ChainTouchAllChosenIssuerRelatedObjects (
     IN PCCERTOBJECT pChosenIssuer
     );

VOID WINAPI
ChainTouchAllMatchingSubjectNames (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCERT_NAME_BLOB pSubjectName,
     IN DWORD dwTouchFlags
     );

VOID WINAPI
ChainTouchAllMatchingObjectIds (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN CERT_OBJECT_IDENTIFIER ObjectIdentifier,
     IN DWORD dwTouchFlags
     );

VOID WINAPI
ChainTouchAllMatchingKeyIds (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCRYPT_HASH_BLOB pKeyId,
     IN DWORD dwTouchFlags
     );

VOID WINAPI
ChainTouchAllMatchingEntries (
     IN HLRUCACHE hIndex,
     IN PCRYPT_DATA_BLOB pIdentifier,
     IN DWORD dwTouchFlags
     );

VOID WINAPI
ChainRemoveCertificateObjectFromSecondaryCacheIndexes (
     IN PCCERTOBJECT pCertObject
     );

VOID WINAPI
ChainRemoveObjectsRelatedToThisIssuer (
     IN PCCERTOBJECT pRemovedIssuer
     );

VOID WINAPI
ChainRemoveAllMatchingSubjectNames (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCERT_NAME_BLOB pSubjectName,
     IN DWORD dwRemovalFlags
     );

VOID WINAPI
ChainRemoveAllMatchingObjectIds (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN CERT_OBJECT_IDENTIFIER ObjectIdentifier,
     IN DWORD dwRemovalFlags
     );

VOID WINAPI
ChainRemoveAllMatchingKeyIds (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCRYPT_HASH_BLOB pKeyId,
     IN DWORD dwRemovalFlags
     );

VOID WINAPI
ChainRemoveAllMatchingEntries (
     IN HLRUCACHE hIndex,
     IN PCRYPT_DATA_BLOB pIdentifier,
     IN DWORD dwRemovalFlags
     );

VOID WINAPI
ChainFlushMatchingIssuerLists (
     IN PCCERTOBJECTCACHE pCertObjectCache,
     IN PCERT_NAME_BLOB pIssuerName
     );

VOID WINAPI
ChainFlushIssuerListsWithThisIssuer (
     IN PCCERTOBJECT pIssuer
     );

VOID WINAPI
ChainFlushIssuerListsWithThisIssuerByName (
     IN PCCERTOBJECT pIssuer
     );

VOID WINAPI
ChainFlushIssuerListsWithThisIssuerByObjectOrKeyId (
     IN PCCERTOBJECT pIssuer
     );

BOOL WINAPI
ChainFlushIssuerListsWithThisIssuerByObjectOrKeyIdEnumFn (
     IN LPVOID pvParameter,
     IN PCCERTOBJECT pCertObject
     );

VOID WINAPI
ChainFlushMatchingCtlIssuerLists (
     IN PCCERTOBJECT pCertObject
     );

BOOL WINAPI
ChainIsCertificateObjectCtlSigner (
     IN PCCERTOBJECT pCertObject
     );

typedef struct _FLUSH_CTL_ISSUERS_ENUM_DATA {

    PCCERTOBJECT pCtlIssuer;

} FLUSH_CTL_ISSUERS_ENUM_DATA, *PFLUSH_CTL_ISSUERS_ENUM_DATA;

BOOL WINAPI
ChainFlushMatchingCtlIssuerListsEnumFn (
     IN LPVOID pvParameter,
     IN PCCERTOBJECT pCertObject
     );

VOID WINAPI
ChainProcessRemovalNotification (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERTOBJECT pCertObject,
     IN BOOL fProcessMatchingObjects
     );

BOOL WINAPI
ChainCreateCertificateObjectCache (
     IN DWORD MaxIndexEntries,
     OUT PCCERTOBJECTCACHE* ppCertObjectCache
     );

VOID WINAPI
ChainFreeCertificateObjectCache (
     IN PCCERTOBJECTCACHE pCertObjectCache
     );

BOOL WINAPI
ChainCreateCertificateChainContext (
     OUT PCCERTCHAINCONTEXT* ppCertChainContext
     );

VOID WINAPI
ChainFreeCertificateChainContext (
     IN PCCERTCHAINCONTEXT pCertChainContext
     );

VOID WINAPI
ChainAddRefInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     );

VOID WINAPI
ChainReleaseInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     );

VOID WINAPI
ChainFreeInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     );

#define CERT_TRUST_CERTIFICATE_ONLY_INFO_STATUS ( CERT_TRUST_IS_SELF_SIGNED |\
                                                  CERT_TRUST_HAS_EXACT_MATCH_ISSUER |\
                                                  CERT_TRUST_HAS_NAME_MATCH_ISSUER |\
                                                  CERT_TRUST_HAS_KEY_MATCH_ISSUER )

#define CERT_TRUST_CHAIN_FULL_ERROR_STATUS ( CERT_TRUST_IS_UNTRUSTED_ROOT |\
                                             CERT_TRUST_IS_NOT_SIGNATURE_VALID |\
                                             CERT_TRUST_IS_NOT_TIME_NESTED )

VOID WINAPI
ChainUpdateSummaryStatusByTrustStatus (
     IN PCERT_TRUST_STATUS pSummaryStatus,
     IN PCERT_TRUST_STATUS pTrustStatus
     );

VOID WINAPI
ChainOrInStatusBits (
     IN PCERT_TRUST_STATUS pDestStatus,
     IN PCERT_TRUST_STATUS pSourceStatus
     );

LONG WINAPI
ChainGetChainErrorStatusQuality (
     IN DWORD dwChainErrorStatus
     );

BOOL WINAPI
ChainCacheEndCertificate (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERTOBJECT pEndCertObject
     );

BOOL WINAPI
ChainIsIssuerOfCertificates (
     IN PCCERTOBJECT pCertObject
     );

BOOL WINAPI
ChainConvertAuthKeyIdentifierFromV2ToV1 (
     IN PCERT_AUTHORITY_KEY_ID2_INFO pAuthKeyIdentifier2,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     );

typedef struct _CTL_ISSUERS_ENUM_DATA {

    PCCERTOBJECT       pCertObject;
    PCCHAINCALLCONTEXT pCallContext;

} CTL_ISSUERS_ENUM_DATA, *PCTL_ISSUERS_ENUM_DATA;

BOOL WINAPI
ChainFindAndStoreCtlIssuersEnumFn (
     IN LPVOID pvParameter,
     IN PCSSCTLOBJECT pSSCtlObject
     );

VOID WINAPI
ChainFreeCtlIssuerData (
     IN PCTL_ISSUER_DATA pCtlIssuerData
     );

VOID WINAPI
ChainFixupCtlIssuers (
     IN PCCERTOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN HCERTSTORE hAdditionalStore
     );

BOOL WINAPI
ChainFindAndStoreCtlIssuersFromAdditionalStore (
     IN PCCERTOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN HCERTSTORE hAdditionalStore
     );

VOID WINAPI
ChainFixupUntrustedRootElementStatus (
     IN PCERT_CHAIN_CONTEXT pContext
     );

BOOL WINAPI
ChainCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     IN DWORD dwStoreFlags,
     OUT HCERTSTORE* phWorld
     );

BOOL WINAPI
ChainCreateEngineStore (
     IN HCERTSTORE hRootStore,
     IN HCERTSTORE hTrustStore,
     IN HCERTSTORE hOtherStore,
     IN BOOL fDefaultEngine,
     IN DWORD dwFlags,
     OUT HCERTSTORE* phEngineStore,
     OUT HANDLE* phEngineStoreChangeEvent
     );

BOOL WINAPI
ChainIsProperRestrictedRoot (
     IN HCERTSTORE hRealRoot,
     IN HCERTSTORE hRestrictedRoot
     );

BOOL WINAPI
ChainCopyRequestedUsage (
     IN PCERT_USAGE_MATCH pSource,
     OUT PCERT_USAGE_MATCH pDest
     );

VOID WINAPI
ChainFreeRequestedUsage (
     IN PCERT_USAGE_MATCH pRequestedUsage
     );

BOOL WINAPI
ChainIsCertificateObjectRepeatedInContext (
     IN PCCERTOBJECT pCertObject,
     IN PCERT_CHAIN_CONTEXT pContext
     );

VOID WINAPI
ChainFindAndAdjustChainContextToCycle (
     IN PCERT_CHAIN_CONTEXT pContext
     );

BOOL WINAPI
ChainIsElementRepeatedInContext (
     IN PCERT_CHAIN_CONTEXT pContext,
     IN DWORD iChain,
     IN DWORD iElement,
     OUT DWORD* piFoundChain,
     OUT DWORD* piFoundElement
     );

BOOL WINAPI
ChainCreateCollectionIncludingCtlCertificates (
     IN HCERTSTORE hStore,
     OUT HCERTSTORE* phCollection
     );

//
// Post processing revocation check
//
// BUGBUG: This WILL change!
//

#define CERT_CHAIN_REVOCATION_CHECK_ALL ( CERT_CHAIN_REVOCATION_CHECK_END_CERT | \
                                          CERT_CHAIN_REVOCATION_CHECK_CHAIN | \
                                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT | \
                                          CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY )

VOID WINAPI
ChainPostProcessCheckRevocation (
     IN HCERTSTORE hCrlStore,
     IN LPFILETIME pftTimeToUse,
     IN LPFILETIME pftCurrentTime,
     IN PCERT_CHAIN_CONTEXT pContext,
     IN DWORD dwFlags
     );

VOID WINAPI
ChainSetRevocationInfo (
     IN PCERT_CHAIN_CONTEXT pContext,
     IN PCERT_REVOCATION_STATUS pRevStatus,
     IN DWORD iChain,
     IN DWORD iElement
     );

VOID WINAPI
ChainFreeRevocationInfo (
     IN PCERT_REVOCATION_INFO pRevocationInfo
     );

//
// Cryptnet Thunk Helper API
//

typedef BOOL (WINAPI *PFN_GETOBJECTURL) (
                          IN LPCSTR pszUrlOid,
                          IN LPVOID pvPara,
                          IN DWORD dwFlags,
                          OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
                          IN OUT DWORD* pcbUrlArray,
                          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
                          IN OUT OPTIONAL DWORD* pcbUrlInfo,
                          IN OPTIONAL LPVOID pvReserved
                          );

BOOL WINAPI
ChainGetObjectUrl (
     IN LPCSTR pszUrlOid,
     IN LPVOID pvPara,
     IN DWORD dwFlags,
     OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
     IN OUT DWORD* pcbUrlArray,
     OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
     IN OUT OPTIONAL DWORD* pcbUrlInfo,
     IN OPTIONAL LPVOID pvReserved
     );

typedef BOOL (WINAPI *PFN_RETRIEVEOBJECTBYURLW) (
                          IN LPCWSTR pszUrl,
                          IN LPCSTR pszObjectOid,
                          IN DWORD dwRetrievalFlags,
                          IN DWORD dwTimeout,
                          OUT LPVOID* ppvObject,
                          IN HCRYPTASYNC hAsyncRetrieve,
                          IN PCRYPT_CREDENTIALS pCredentials,
                          IN LPVOID pvVerify,
                          IN LPVOID pvReserved
                          );

BOOL WINAPI
ChainRetrieveObjectByUrlW (
     IN LPCWSTR pszUrl,
     IN LPCSTR pszObjectOid,
     IN DWORD dwRetrievalFlags,
     IN DWORD dwTimeout,
     OUT LPVOID* ppvObject,
     IN HCRYPTASYNC hAsyncRetrieve,
     IN PCRYPT_CREDENTIALS pCredentials,
     IN LPVOID pvVerify,
     IN LPVOID pvReserved
     );

HMODULE WINAPI
ChainGetCryptnetModule ();

//
// URL helper
//

BOOL WINAPI
ChainIsFileOrLdapUrl (
     IN LPCWSTR pwszUrl
     );

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::AddRef, public
//
//  Synopsis:   add a reference to the certificate object
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::Release, public
//
//  Synopsis:   remove a reference from the certificate object
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::ObjectIdentifier, public
//
//  Synopsis:   returns the CERT_OBJECT_IDENTIFIER
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::GetObjectIdentifier (CERT_OBJECT_IDENTIFIER ObjectIdentifier)
{
    memcpy(
       ObjectIdentifier,
       m_ObjectIdentifier,
       sizeof( CERT_OBJECT_IDENTIFIER )
       );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CertContext, public
//
//  Synopsis:   return the certificate context
//
//----------------------------------------------------------------------------
inline PCCERT_CONTEXT
CCertObject::CertContext ()
{
    return( m_pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::Usage, public
//
//  Synopsis:   return the usage
//
//----------------------------------------------------------------------------
inline PCERT_ENHKEY_USAGE
CCertObject::Usage ()
{
    return( m_pUsage );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::ErrorStatus, public
//
//  Synopsis:   return the error status bits
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::ErrorStatus ()
{
    return( m_TrustStatus.dwErrorStatus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::InfoStatus, public
//
//  Synopsis:   return the info status bits
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::InfoStatus ()
{
    return( m_TrustStatus.dwInfoStatus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::TrustStatus, public
//
//  Synopsis:   return a pointer to the trust status structure
//
//----------------------------------------------------------------------------
inline PCERT_TRUST_STATUS
CCertObject::TrustStatus ()
{
    return( &m_TrustStatus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CertificateHashSize, public
//
//  Synopsis:   return the certificate hash size
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::CertificateHashSize ()
{
    return( sizeof( m_CertificateHash ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CertificateHash, public
//
//  Synopsis:   return the certificate hash
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::CertificateHash ()
{
    return( m_CertificateHash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdentifierSize, public
//
//  Synopsis:   return the key identifier blob size
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::KeyIdentifierSize ()
{
    return( m_cbKeyIdentifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdentifier, public
//
//  Synopsis:   return the key identifier
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::KeyIdentifier ()
{
    return( m_pbKeyIdentifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::AuthorityKeyIdentifier, public
//
//  Synopsis:   return the issuer authority key identifier information
//
//----------------------------------------------------------------------------
inline PCERT_AUTHORITY_KEY_ID_INFO
CCertObject::AuthorityKeyIdentifier ()
{
    return( m_pAuthKeyIdentifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerList, public
//
//  Synopsis:   return the issuer list object
//
//----------------------------------------------------------------------------
inline PCCERTISSUERLIST
CCertObject::IssuerList ()
{
    return( m_pIssuerList );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::HashIndexEntry, public
//
//  Synopsis:   return the hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::HashIndexEntry ()
{
    return( m_hHashEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IdentifierIndexEntry, public
//
//  Synopsis:   return the identifier index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::IdentifierIndexEntry ()
{
    return( m_hIdentifierEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::SubjectNameIndexEntry, public
//
//  Synopsis:   return the subject name index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::SubjectNameIndexEntry ()
{
    return( m_hSubjectNameEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerNameIndexEntry, public
//
//  Synopsis:   return the issuer name index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::IssuerNameIndexEntry ()
{
    return( m_hIssuerNameEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdIndexEntry, public
//
//  Synopsis:   return the key identifier index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::KeyIdIndexEntry ()
{
    return( m_hKeyIdEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::ChainEngine, public
//
//  Synopsis:   return the chain engine object
//
//----------------------------------------------------------------------------
inline PCCERTCHAINENGINE
CCertObject::ChainEngine ()
{
    return( m_pChainEngine );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::IsEmpty, public
//
//  Synopsis:   is the issuer list empty
//
//----------------------------------------------------------------------------
inline BOOL
CCertIssuerList::IsEmpty ()
{
    return( m_pHead == NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::IsFlushed, public
//
//  Synopsis:   is the issuer list flushed
//
//----------------------------------------------------------------------------
inline BOOL
CCertIssuerList::IsFlushed ()
{
    return( m_fFlushed );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::IsCtlIssuerFlushed, public
//
//  Synopsis:   are the CTL issuers flushed
//
//----------------------------------------------------------------------------
inline BOOL
CCertIssuerList::IsCtlIssuerFlushed ()
{
    return( m_fCtlIssuerFlushed );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::IsAdditionalStoreProcessed, public
//
//  Synopsis:   has an additional store been processed
//
//----------------------------------------------------------------------------
inline BOOL
CCertIssuerList::IsAdditionalStoreProcessed ()
{
    return( m_fAdditionalStoreProcessed );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddElement, public
//
//  Synopsis:   add an element to the list
//
//----------------------------------------------------------------------------
inline VOID
CCertIssuerList::AddElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    pElement->pNextElement = m_pHead;
    pElement->pPrevElement = NULL;

    if ( m_pHead != NULL )
    {
        m_pHead->pPrevElement = pElement;
    }

    m_pHead = pElement;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::RemoveElement, public
//
//  Synopsis:   remove an element from the list
//
//----------------------------------------------------------------------------
inline VOID
CCertIssuerList::RemoveElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    if ( pElement->pPrevElement != NULL )
    {
        pElement->pPrevElement->pNextElement = pElement->pNextElement;
    }

    if ( pElement->pNextElement != NULL )
    {
        pElement->pNextElement->pPrevElement = pElement->pPrevElement;
    }

    if ( pElement == m_pHead )
    {
        m_pHead = pElement->pNextElement;
    }

#if DBG
    pElement->pPrevElement = NULL;
    pElement->pNextElement = NULL;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::PrevElement, public
//
//  Synopsis:   return the previous element
//
//----------------------------------------------------------------------------
inline PCERT_ISSUER_ELEMENT
CCertIssuerList::PrevElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    return( pElement->pPrevElement );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::NextElement, public
//
//  Synopsis:   return the next element, if pElement == NULL the first element
//              is returned
//
//----------------------------------------------------------------------------
inline PCERT_ISSUER_ELEMENT
CCertIssuerList::NextElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    if ( pElement == NULL )
    {
        return( m_pHead );
    }

    return( pElement->pNextElement );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::HashIndex, public
//
//  Synopsis:   return the hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::HashIndex ()
{
    return( m_hHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::IdentifierIndex, public
//
//  Synopsis:   return the identifier index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::IdentifierIndex ()
{
    return( m_hIdentifierIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::SubjectNameIndex, public
//
//  Synopsis:   return the subject name index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::SubjectNameIndex ()
{
    return( m_hSubjectNameIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::IssuerNameIndex, public
//
//  Synopsis:   return the issuer name index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::IssuerNameIndex ()
{
    return( m_hIssuerNameIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::KeyIdIndex, public
//
//  Synopsis:   return the key identifier index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::KeyIdIndex ()
{
    return( m_hKeyIdIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::EnableLruOfObjects, public
//
//  Synopsis:   enable LRU of entries on the primary index
//
//----------------------------------------------------------------------------
inline VOID
CCertObjectCache::EnableLruOfObjects (IN PCCHAINCALLCONTEXT pCallContext)
{
    I_CryptEnableLruOfEntries( m_hHashIndex, pCallContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::DisableLruOfObjects, public
//
//  Synopsis:   disable LRU of entries on the primary index
//
//----------------------------------------------------------------------------
inline VOID
CCertObjectCache::DisableLruOfObjects ()
{
    I_CryptDisableLruOfEntries( m_hHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FlushObjects, public
//
//  Synopsis:   flush the cache of objects
//
//----------------------------------------------------------------------------
inline VOID
CCertObjectCache::FlushObjects (IN PCCHAINCALLCONTEXT pCallContext)
{
    I_CryptFlushLruCache( m_hHashIndex, 0, pCallContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::LockEngine, public
//
//  Synopsis:   acquire the engine lock
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::LockEngine ()
{
    EnterCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::UnlockEngine, public
//
//  Synopsis:   release the engine lock
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::UnlockEngine ()
{
    LeaveCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::AddRef, public
//
//  Synopsis:   increment the reference count
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::Release, public
//
//  Synopsis:   decrement the reference count
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CertObjectCache, public
//
//  Synopsis:   return the certificate object cache
//
//----------------------------------------------------------------------------
inline PCCERTOBJECTCACHE
CCertChainEngine::CertObjectCache ()
{
    return( m_pCertObjectCache );
}

#ifdef CAPI_INCLUDE_CTL
//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::SSCtlObjectCache, public
//
//  Synopsis:   return the self signed certificate trust list object cache
//
//----------------------------------------------------------------------------
inline PCSSCTLOBJECTCACHE
CCertChainEngine::SSCtlObjectCache ()
{
    return( m_pSSCtlObjectCache );
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RootStore, public
//
//  Synopsis:   return the configured root store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::RootStore ()
{
    return( m_hRootStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RealRootStore, public
//
//  Synopsis:   return the real root store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::RealRootStore ()
{
    return( m_hRealRootStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::TrustStore, public
//
//  Synopsis:   return the configured trust store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::TrustStore ()
{
    return( m_hTrustStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::OtherStore, public
//
//  Synopsis:   return the configured other store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::OtherStore ()
{
    return( m_hOtherStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CycleDetectionModulus, public
//
//  Synopsis:   return the cycle detection modulus
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::CycleDetectionModulus ()
{
    return( m_CycleDetectionModulus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::ElementCount, public
//
//  Synopsis:   return the element count for a given simple chain
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainContext::ElementCount (IN DWORD SimpleChain)
{
    return( m_pContext->ChainContext.rgpChain[ SimpleChain ]->cElement );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::InternalContext, public
//
//  Synopsis:   return the internal chain context
//
//----------------------------------------------------------------------------
inline PINTERNAL_CERT_CHAIN_CONTEXT
CCertChainContext::InternalContext ()
{
    return( m_pContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainContext::ExposedContext, public
//
//  Synopsis:   return the exposed chain context
//
//----------------------------------------------------------------------------
inline PCERT_CHAIN_CONTEXT
CCertChainContext::ExposedContext ()
{
    return( &m_pContext->ChainContext );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\lru.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       lru.cpp
//
//  Contents:   LRU cache implementation
//
//  History:    24-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::CLruEntry, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLruEntry::CLruEntry (
               IN PCLRUCACHE pCache,
               IN PCRYPT_DATA_BLOB pIdentifier,
               IN LPVOID pvData,
               OUT BOOL& rfResult
               )
{
    rfResult = TRUE;

    m_cRefs = 1;
    m_pPrevEntry = NULL;
    m_pNextEntry = NULL;
    m_Usage = 0;

    m_pCache = pCache;
    m_pvData = pvData;
    m_pBucket = pCache->BucketFromIdentifier( pIdentifier );

    if ( pCache->Flags() & LRU_CACHE_NO_COPY_IDENTIFIER )
    {
        m_Identifier = *pIdentifier;
    }
    else
    {
        m_Identifier.cbData = pIdentifier->cbData;
        m_Identifier.pbData = new BYTE [ pIdentifier->cbData ];
        if ( m_Identifier.pbData != NULL )
        {
            memcpy(
               m_Identifier.pbData,
               pIdentifier->pbData,
               pIdentifier->cbData
               );
        }
        else
        {
            rfResult = FALSE;
            SetLastError( E_OUTOFMEMORY );
            return;
        }
    }

    assert( m_pBucket != NULL );
    assert( m_Identifier.pbData != NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::~CLruEntry, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLruEntry::~CLruEntry ()
{
    m_pCache->FreeEntryData( m_pvData );

    if ( !( m_pCache->Flags() & LRU_CACHE_NO_COPY_IDENTIFIER ) )
    {
        delete m_Identifier.pbData;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::CLruCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLruCache::CLruCache (
               IN PLRU_CACHE_CONFIG pConfig,
               OUT BOOL& rfResult
               )
{
    rfResult = TRUE;

    m_cEntries = 0;
    m_aBucket = new LRU_CACHE_BUCKET [ pConfig->cBuckets ];
    if ( m_aBucket == NULL )
    {
        rfResult = FALSE;
        SetLastError( E_OUTOFMEMORY );
        return;
    }

    memset( m_aBucket, 0, sizeof( LRU_CACHE_BUCKET ) * pConfig->cBuckets );

    if ( !( pConfig->dwFlags & LRU_CACHE_NO_SERIALIZE ) )
    {
        InitializeCriticalSection( &m_Lock );
    }

    m_Config = *pConfig;
    m_UsageClock = 0;
    m_cLruDisabled = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::~CLruCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLruCache::~CLruCache ()
{
    if ( m_cEntries > 0 )
    {
        PurgeAllEntries( 0, NULL );
    }

    if ( !( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE ) )
    {
        DeleteCriticalSection( &m_Lock );
    }

    delete m_aBucket;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::EnableLruOfEntries, public
//
//  Synopsis:   enable LRU of entries and purge anything over the watermark
//
//----------------------------------------------------------------------------
VOID
CLruCache::EnableLruOfEntries (IN OPTIONAL LPVOID pvLruRemovalContext)
{
    LockCache();

    assert( m_cLruDisabled > 0 );

    if ( m_cLruDisabled == 0 )
    {
        return;
    }

    m_cLruDisabled -= 1;

    if ( m_cLruDisabled == 0 )
    {
        while ( m_cEntries > m_Config.MaxEntries )
        {
            PurgeLeastRecentlyUsed( pvLruRemovalContext );
        }
    }

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::DisableLruOfEntries, public
//
//  Synopsis:   disable LRU of entries
//
//----------------------------------------------------------------------------
VOID
CLruCache::DisableLruOfEntries ()
{
    LockCache();

    m_cLruDisabled += 1;

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::InsertEntry, public
//
//  Synopsis:   insert an entry into the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::InsertEntry (
                 IN PCLRUENTRY pEntry,
                 IN OPTIONAL LPVOID pvLruRemovalContext
                 )
{
    assert( pEntry->PrevPointer() == NULL );
    assert( pEntry->NextPointer() == NULL );

    pEntry->AddRef();

    LockCache();

    if ( ( m_cEntries == m_Config.MaxEntries ) &&
         ( m_Config.MaxEntries != 0 ) &&
         ( m_cLruDisabled == 0 ) )
    {
        PurgeLeastRecentlyUsed( pvLruRemovalContext );
    }

    assert( ( m_cEntries < m_Config.MaxEntries ) ||
            ( m_Config.MaxEntries == 0 ) ||
            ( m_cLruDisabled > 0 ) );

    pEntry->SetNextPointer( pEntry->Bucket()->pList );

    if ( pEntry->Bucket()->pList != NULL )
    {
        pEntry->Bucket()->pList->SetPrevPointer( pEntry );
    }

    pEntry->Bucket()->pList = pEntry;

    m_cEntries += 1;

    TouchEntryNoLock( pEntry, 0 );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::RemoveEntry, public
//
//  Synopsis:   remove an entry from the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::RemoveEntry (
                 IN PCLRUENTRY pEntry,
                 IN DWORD dwFlags,
                 IN OPTIONAL LPVOID pvRemovalContext
                 )
{
    LockCache();

    RemoveEntryFromBucket(
          pEntry->Bucket(),
          pEntry,
          dwFlags,
          pvRemovalContext
          );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::TouchEntry, public
//
//  Synopsis:   touch the entry
//
//----------------------------------------------------------------------------
VOID
CLruCache::TouchEntry (IN PCLRUENTRY pEntry, IN DWORD dwFlags)
{
    LockCache();

    TouchEntryNoLock( pEntry, dwFlags );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FindEntry, public
//
//  Synopsis:   find the entry matching the given identifier
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::FindEntry (IN PCRYPT_DATA_BLOB pIdentifier, IN BOOL fTouchEntry)
{
    PCLRUENTRY        pFound = NULL;
    PLRU_CACHE_BUCKET pBucket;

    pBucket = BucketFromIdentifier( pIdentifier );

    assert( pBucket != NULL );

    return( FindNextMatchingEntryInBucket(
                pBucket,
                NULL,
                pIdentifier,
                fTouchEntry
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::NextMatchingEntry, public
//
//  Synopsis:   find the next matching entry to pPrevEntry
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::NextMatchingEntry (IN PCLRUENTRY pPrevEntry, IN BOOL fTouchEntry)
{
    PCLRUENTRY pNextEntry;

    pNextEntry = FindNextMatchingEntryInBucket(
                     NULL,
                     pPrevEntry,
                     NULL,
                     fTouchEntry
                     );

    pPrevEntry->Release();

    return( pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::WalkEntries, public
//
//  Synopsis:   walk the entries
//
//----------------------------------------------------------------------------
VOID
CLruCache::WalkEntries (IN PFN_WALK_ENTRIES pfnWalk, IN LPVOID pvParameter)
{
    DWORD      cCount;
    PCLRUENTRY pEntry;
    PCLRUENTRY pNextEntry;

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        pEntry = m_aBucket[ cCount ].pList;

        while ( pEntry != NULL )
        {
            pNextEntry = pEntry->NextPointer();

            if ( ( *pfnWalk )( pvParameter, pEntry ) == FALSE )
            {
                return;
            }

            pEntry = pNextEntry;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::RemoveEntryFromBucket, public
//
//  Synopsis:   remove entry from bucket
//
//----------------------------------------------------------------------------
VOID
CLruCache::RemoveEntryFromBucket (
                 IN PLRU_CACHE_BUCKET pBucket,
                 IN PCLRUENTRY pEntry,
                 IN DWORD dwFlags,
                 IN OPTIONAL LPVOID pvRemovalContext
                 )
{
    if ( pEntry->PrevPointer() != NULL )
    {
        pEntry->PrevPointer()->SetNextPointer( pEntry->NextPointer() );
    }
    else
    {
        assert( pBucket->pList == pEntry );

        pBucket->pList = pEntry->NextPointer();
    }

    if ( pEntry->NextPointer() != NULL )
    {
        pEntry->NextPointer()->SetPrevPointer( pEntry->PrevPointer() );
    }

    pEntry->SetPrevPointer( NULL );
    pEntry->SetNextPointer( NULL );

    m_cEntries -= 1;

    if (  ( m_Config.pfnOnRemoval != NULL ) &&
         !( dwFlags & LRU_SUPPRESS_REMOVAL_NOTIFICATION ) )
    {
        ( *m_Config.pfnOnRemoval )( pEntry->Data(), pvRemovalContext );
    }

    pEntry->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FindNextMatchingEntryInBucket, public
//
//  Synopsis:   find the next matching entry in the given bucket.  If pCurrent
//              is non NULL then start from there, the bucket is not needed and
//              pIdentifier is ignored. If pCurrent is NULL then pIdentifier
//              and the bucket must both be non NULL
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::FindNextMatchingEntryInBucket (
               IN PLRU_CACHE_BUCKET pBucket,
               IN PCLRUENTRY pCurrent,
               IN PCRYPT_DATA_BLOB pIdentifier,
               IN BOOL fTouchEntry
               )
{
    LockCache();

    if ( pCurrent == NULL )
    {
        pCurrent = pBucket->pList;
    }
    else
    {
        pIdentifier = pCurrent->Identifier();
        pCurrent = pCurrent->NextPointer();
    }

    while ( pCurrent != NULL )
    {
        if ( ( pIdentifier->cbData == pCurrent->Identifier()->cbData ) &&
             ( memcmp(
                  pIdentifier->pbData,
                  pCurrent->Identifier()->pbData,
                  pIdentifier->cbData
                  ) == 0 ) )
        {
            break;
        }

        pCurrent = pCurrent->NextPointer();
    }

    if ( pCurrent != NULL )
    {
        pCurrent->AddRef();

        if ( fTouchEntry == TRUE )
        {
            TouchEntryNoLock( pCurrent, 0 );
        }
    }

    UnlockCache();

    return( pCurrent );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::PurgeLeastRecentlyUsed, public
//
//  Synopsis:   find and remove the least recently used entry
//
//----------------------------------------------------------------------------
VOID
CLruCache::PurgeLeastRecentlyUsed (IN OPTIONAL LPVOID pvLruRemovalContext)
{
    DWORD             cCount;
    PLRU_CACHE_BUCKET pBucket;
    PCLRUENTRY        pEntry;
    PCLRUENTRY        pLRU;

    assert( m_cEntries > 0 );

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        if ( m_aBucket[cCount].pList != NULL )
        {
            break;
        }
    }

    pBucket = &m_aBucket[cCount];
    cCount += 1;
    for ( ; cCount < m_Config.cBuckets; cCount++ )
    {
        if ( ( m_aBucket[cCount].pList != NULL ) &&
             ( m_aBucket[cCount].Usage < pBucket->Usage ) )
        {
            pBucket = &m_aBucket[cCount];
        }
    }

    assert( pBucket != NULL );
    assert( pBucket->pList != NULL );

    pLRU = pBucket->pList;
    pEntry = pLRU->NextPointer();

    while ( pEntry != NULL )
    {
        if ( pEntry->Usage() < pLRU->Usage() )
        {
            pLRU = pEntry;
        }

        pEntry = pEntry->NextPointer();
    }

    RemoveEntryFromBucket( pBucket, pLRU, 0, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::PurgeAllEntries, public
//
//  Synopsis:   remove all entries from the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::PurgeAllEntries (
                IN DWORD dwFlags,
                IN OPTIONAL LPVOID pvRemovalContext
                )
{
    DWORD cCount;

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        while ( m_aBucket[cCount].pList != NULL )
        {
            RemoveEntryFromBucket(
                  &m_aBucket[cCount],
                  m_aBucket[cCount].pList,
                  dwFlags,
                  pvRemovalContext
                  );
        }
    }

    assert( m_cEntries == 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptCreateLruCache
//
//  Synopsis:   create an LRU cache area
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptCreateLruCache (
       IN PLRU_CACHE_CONFIG pConfig,
       OUT HLRUCACHE* phCache
       )
{
    BOOL       fResult;
    PCLRUCACHE pCache;

    pCache = new CLruCache( pConfig, fResult );
    if ( pCache == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == FALSE )
    {
        delete pCache;
        return( FALSE );
    }

    *phCache = (HLRUCACHE)pCache;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFlushLruCache
//
//  Synopsis:   flush the cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptFlushLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       )
{
    ( (PCLRUCACHE)hCache )->LockCache();

    ( (PCLRUCACHE)hCache )->PurgeAllEntries( dwFlags, pvRemovalContext );

    ( (PCLRUCACHE)hCache )->UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFreeLruCache
//
//  Synopsis:   free the LRU cache area
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptFreeLruCache (
       IN HLRUCACHE hCache,
       IN DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       )
{
    if ( hCache == NULL )
    {
        return;
    }

    if ( dwFlags != 0 )
    {
        ( (PCLRUCACHE)hCache )->PurgeAllEntries( dwFlags, pvRemovalContext );
    }

    delete (PCLRUCACHE)hCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptCreateLruEntry
//
//  Synopsis:   create an LRU entry
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptCreateLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       IN LPVOID pvData,
       OUT HLRUENTRY* phEntry
       )
{
    BOOL       fResult;
    PCLRUENTRY pEntry;

    pEntry = new CLruEntry(
                     (PCLRUCACHE)hCache,
                     pIdentifier,
                     pvData,
                     fResult
                     );

    if ( pEntry == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == FALSE )
    {
        delete pEntry;
        return( FALSE );
    }

    *phEntry = (HLRUENTRY)pEntry;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptGetLruEntryIdentifier
//
//  Synopsis:   return the identifier for the entry
//
//----------------------------------------------------------------------------
PCRYPT_DATA_BLOB WINAPI
I_CryptGetLruEntryIdentifier (
       IN HLRUENTRY hEntry
       )
{
    return( ( (PCLRUENTRY)hEntry )->Identifier() );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptGetLruEntryData
//
//  Synopsis:   get the data associated with the entry
//
//----------------------------------------------------------------------------
LPVOID WINAPI
I_CryptGetLruEntryData (
       IN HLRUENTRY hEntry
       )
{
    return( ( (PCLRUENTRY)hEntry )->Data() );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptAddRefLruEntry
//
//  Synopsis:   add a reference to the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptAddRefLruEntry (
       IN HLRUENTRY hEntry
       )
{
    ( (PCLRUENTRY)hEntry )->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptReleaseLruEntry
//
//  Synopsis:   remove a reference from the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptReleaseLruEntry (
       IN HLRUENTRY hEntry
       )
{
    ( (PCLRUENTRY)hEntry )->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptInsertLruEntry
//
//  Synopsis:   insert the entry into its associated cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptInsertLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL LPVOID pvLruRemovalContext
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->InsertEntry( pEntry, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptRemoveLruEntry
//
//  Synopsis:   remove the entry from its associated cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptRemoveLruEntry (
       IN HLRUENTRY hEntry,
       IN DWORD dwFlags,
       IN LPVOID pvLruRemovalContext
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->RemoveEntry( pEntry, dwFlags, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptTouchLruEntry
//
//  Synopsis:   touch the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptTouchLruEntry (
       IN HLRUENTRY hEntry,
       IN DWORD dwFlags
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->TouchEntry( pEntry, dwFlags );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindLruEntry
//
//  Synopsis:   find the entry with the given identifier
//
//----------------------------------------------------------------------------
HLRUENTRY WINAPI
I_CryptFindLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier
       )
{
    PCLRUCACHE pCache = (PCLRUCACHE)hCache;

    return( pCache->FindEntry( pIdentifier, FALSE ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindLruEntryData
//
//  Synopsis:   find the entry with the given identifier
//
//----------------------------------------------------------------------------
LPVOID WINAPI
I_CryptFindLruEntryData (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       OUT HLRUENTRY* phEntry
       )
{
    PCLRUCACHE pCache = (PCLRUCACHE)hCache;
    PCLRUENTRY pEntry;

    pEntry = pCache->FindEntry( pIdentifier, TRUE );
    *phEntry = (HLRUENTRY)pEntry;

    if ( pEntry != NULL )
    {
        return( pEntry->Data() );
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptEnumMatchingLruEntries
//
//  Synopsis:   get the next matching entry
//
//----------------------------------------------------------------------------
HLRUENTRY WINAPI
I_CryptEnumMatchingLruEntries (
       IN HLRUENTRY hPrevEntry
       )
{
    PCLRUCACHE pCache = ( (PCLRUENTRY)hPrevEntry )->Cache();
    PCLRUENTRY pNextEntry;

    pNextEntry = pCache->NextMatchingEntry( (PCLRUENTRY)hPrevEntry, FALSE );

    return( (HLRUENTRY)pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptEnableLruOfEntries
//
//  Synopsis:   enable LRU of entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptEnableLruOfEntries (
       IN HLRUCACHE hCache,
       IN OPTIONAL LPVOID pvLruRemovalContext
       )
{
    ( (PCLRUCACHE)hCache )->EnableLruOfEntries( pvLruRemovalContext);
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptDisableLruOfEntries
//
//  Synopsis:   disable LRU of entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptDisableLruOfEntries (
       IN HLRUCACHE hCache
       )
{
    ( (PCLRUCACHE)hCache )->DisableLruOfEntries();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptWalkAllLruCacheEntries
//
//  Synopsis:   walk the LRU cache entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptWalkAllLruCacheEntries (
       IN HLRUCACHE hCache,
       IN PFN_WALK_ENTRIES pfnWalk,
       IN LPVOID pvParameter
       )
{
    ( (PCLRUCACHE)hCache )->WalkEntries( pfnWalk, pvParameter );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\lru.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       lru.h
//
//  Contents:   LRU cache class definitions
//
//  History:    22-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LRU_H__)
#define __LRU_H__

#include <lrucache.h>

//
// Forward declaration of LRU cache classes
//

class CLruCache;
class CLruEntry;

typedef CLruCache* PCLRUCACHE;
typedef CLruEntry* PCLRUENTRY;

//
// LRU cache bucket structure
//

typedef struct _LRU_CACHE_BUCKET {

    DWORD      Usage;
    PCLRUENTRY pList;

} LRU_CACHE_BUCKET, *PLRU_CACHE_BUCKET;

//
// CLruEntry class definition
//

class CLruEntry
{
public:

    //
    // Construction
    //

    CLruEntry (
        IN PCLRUCACHE pCache,
        IN PCRYPT_DATA_BLOB pIdentifier,
        IN LPVOID pvData,
        OUT BOOL& rfResult
        );

    ~CLruEntry ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Cache and Bucket access
    //

    inline PCLRUCACHE Cache ();
    inline PLRU_CACHE_BUCKET Bucket ();

    //
    // Data access
    //

    inline PCRYPT_DATA_BLOB Identifier ();
    inline LPVOID Data ();

    //
    // Link access
    //

    inline VOID SetPrevPointer (IN PCLRUENTRY pPrevEntry);
    inline VOID SetNextPointer (IN PCLRUENTRY pNextEntry);

    inline PCLRUENTRY PrevPointer ();
    inline PCLRUENTRY NextPointer ();

    //
    // LRU usage access
    //

    inline VOID SetUsage (DWORD Usage);
    inline DWORD Usage ();

    //
    // Cache Destruction notification
    //

    inline VOID OnCacheDestruction ();

private:

    //
    // Reference count
    //

    ULONG             m_cRefs;

    //
    // Cache pointer
    //

    PCLRUCACHE        m_pCache;

    //
    // Entry information
    //

    CRYPT_DATA_BLOB   m_Identifier;
    LPVOID            m_pvData;

    //
    // Links
    //

    PCLRUENTRY        m_pPrevEntry;
    PCLRUENTRY        m_pNextEntry;
    PLRU_CACHE_BUCKET m_pBucket;

    //
    // Usage
    //

    DWORD             m_Usage;
};

//
// CLruCache class definition
//

class CLruCache
{
public:

    //
    // Construction
    //

    CLruCache (
        IN PLRU_CACHE_CONFIG pConfig,
        OUT BOOL& rfResult
        );

    ~CLruCache ();

    //
    // Clearing the cache
    //

    VOID PurgeAllEntries (
              IN DWORD dwFlags,
              IN OPTIONAL LPVOID pvRemovalContext
              );

    //
    // Cache locking
    //

    inline VOID LockCache ();
    inline VOID UnlockCache ();

    //
    // LRU enable and disable
    //

    VOID EnableLruOfEntries (IN OPTIONAL LPVOID pvLruRemovalContext);

    VOID DisableLruOfEntries ();

    //
    // Cache entry manipulation
    //

    VOID InsertEntry (
               IN PCLRUENTRY pEntry,
               IN OPTIONAL LPVOID pvLruRemovalContext
               );

    VOID RemoveEntry (
               IN PCLRUENTRY pEntry,
               IN DWORD dwFlags,
               IN OPTIONAL LPVOID pvRemovalContext
               );

    VOID TouchEntry (IN PCLRUENTRY pEntry, IN DWORD dwFlags);

    //
    // Cache entry retrieval
    //

    PCLRUENTRY FindEntry (IN PCRYPT_DATA_BLOB pIdentifier, IN BOOL fTouchEntry);

    PCLRUENTRY NextMatchingEntry (
                   IN PCLRUENTRY pPrevEntry,
                   IN BOOL fTouchEntry
                   );

    //
    // Cache bucket retrieval
    //

    inline PLRU_CACHE_BUCKET BucketFromIdentifier (
                                   IN PCRYPT_DATA_BLOB pIdentifier
                                   );

    //
    // Configuration access
    //

    //
    // Use the configured free function to release the
    // pvData in an entry
    //
    // MOTE: This is called from the CLruEntry destructor
    //

    inline VOID FreeEntryData (IN LPVOID pvData);

    //
    // Access the configuration flags
    //

    inline DWORD Flags ();

    //
    // Usage clock access
    //

    inline VOID IncrementUsageClock ();
    inline DWORD UsageClock ();

    //
    // Walk all cache entries
    //

    VOID WalkEntries (IN PFN_WALK_ENTRIES pfnWalk, IN LPVOID pvParameter);

private:

    //
    // Cache configuration
    //

    LRU_CACHE_CONFIG  m_Config;

    //
    // Cache lock
    //

    CRITICAL_SECTION  m_Lock;

    //
    // Entry count
    //

    DWORD             m_cEntries;

    //
    // Cache Buckets
    //

    PLRU_CACHE_BUCKET m_aBucket;

    //
    // Usage clock
    //

    DWORD             m_UsageClock;

    //
    // LRU disabled count
    //

    DWORD             m_cLruDisabled;

    //
    // Private methods
    //

    VOID RemoveEntryFromBucket (
               IN PLRU_CACHE_BUCKET pBucket,
               IN PCLRUENTRY pEntry,
               IN DWORD dwFlags,
               IN OPTIONAL LPVOID pvRemovalContext
               );

    PCLRUENTRY FindNextMatchingEntryInBucket (
                   IN PLRU_CACHE_BUCKET pBucket,
                   IN PCLRUENTRY pCurrent,
                   IN PCRYPT_DATA_BLOB pIdentifier,
                   IN BOOL fTouchEntry
                   );

    VOID PurgeLeastRecentlyUsed (IN OPTIONAL LPVOID pvLruRemovalContext);

    inline VOID TouchEntryNoLock (IN PCLRUENTRY pEntry, IN DWORD dwFlags);
};

//
// Inline functions
//

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::AddRef, public
//
//  Synopsis:   increment entry reference count
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Release, public
//
//  Synopsis:   decrement entry reference count and if count goes to zero
//              free the entry
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Cache, public
//
//  Synopsis:   return the internal cache pointer
//
//----------------------------------------------------------------------------
inline PCLRUCACHE
CLruEntry::Cache ()
{
    return( m_pCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Bucket, public
//
//  Synopsis:   return the internal cache bucket pointer
//
//----------------------------------------------------------------------------
inline PLRU_CACHE_BUCKET
CLruEntry::Bucket ()
{
    return( m_pBucket );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Identifier, public
//
//  Synopsis:   return the internal entry identifier
//
//----------------------------------------------------------------------------
inline PCRYPT_DATA_BLOB
CLruEntry::Identifier ()
{
    return( &m_Identifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Data, public
//
//  Synopsis:   return the internal entry data
//
//----------------------------------------------------------------------------
inline LPVOID
CLruEntry::Data ()
{
    return( m_pvData );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetPrevPointer, public
//
//  Synopsis:   set the previous entry pointer
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetPrevPointer (IN PCLRUENTRY pPrevEntry)
{
    m_pPrevEntry = pPrevEntry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetNextPointer, public
//
//  Synopsis:   set the next entry pointer
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetNextPointer (IN PCLRUENTRY pNextEntry)
{
    m_pNextEntry = pNextEntry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::PrevPointer, public
//
//  Synopsis:   return the previous entry pointer
//
//----------------------------------------------------------------------------
inline PCLRUENTRY
CLruEntry::PrevPointer ()
{
    return( m_pPrevEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::NextPointer, public
//
//  Synopsis:   return the next entry pointer
//
//----------------------------------------------------------------------------
inline PCLRUENTRY
CLruEntry::NextPointer ()
{
    return( m_pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetUsage, public
//
//  Synopsis:   set the usage on the entry object and on
//              the corresponding cache bucket
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetUsage (IN DWORD Usage)
{
    m_Usage = Usage;
    m_pBucket->Usage = Usage;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Usage, public
//
//  Synopsis:   return the internal entry usage
//
//----------------------------------------------------------------------------
inline DWORD
CLruEntry::Usage ()
{
    return( m_Usage );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::OnCacheDestruction, public
//
//  Synopsis:   cleanup reference to cache that is being destroyed
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::OnCacheDestruction ()
{
    m_pCache = NULL;
    m_pBucket = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::LockCache, public
//
//  Synopsis:   acquire the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::LockCache ()
{
    if ( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE )
    {
        return;
    }

    EnterCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::UnlockCache, public
//
//  Synopsis:   release the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::UnlockCache ()
{
    if ( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE )
    {
        return;
    }

    LeaveCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::BucketFromIdentifier, public
//
//  Synopsis:   retrieve the associated cache bucket given the entry identifier
//
//----------------------------------------------------------------------------
inline PLRU_CACHE_BUCKET
CLruCache::BucketFromIdentifier (
                 IN PCRYPT_DATA_BLOB pIdentifier
                 )
{
    DWORD Hash = ( *m_Config.pfnHash )( pIdentifier );

    return( &m_aBucket[ Hash % m_Config.cBuckets ] );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FreeEntryData, public
//
//  Synopsis:   free the data using the configured free function
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::FreeEntryData (IN LPVOID pvData)
{
    if ( m_Config.pfnFree != NULL )
    {
        ( *m_Config.pfnFree )( pvData );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::Flags, public
//
//  Synopsis:   access the configured flags
//
//----------------------------------------------------------------------------
inline DWORD
CLruCache::Flags ()
{
    return( m_Config.dwFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::IncrementUsageClock, public
//
//  Synopsis:   increment the usage clock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::IncrementUsageClock ()
{
    m_UsageClock += 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::UsageClock, public
//
//  Synopsis:   return the usage clock value
//
//----------------------------------------------------------------------------
inline DWORD
CLruCache::UsageClock ()
{
    return( m_UsageClock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::TouchEntryNoLock, public
//
//  Synopsis:   touch entry without taking the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::TouchEntryNoLock (IN PCLRUENTRY pEntry, IN DWORD dwFlags)
{
    if ( !( dwFlags & LRU_SUPPRESS_CLOCK_UPDATE ) )
    {
        IncrementUsageClock();
    }

    pEntry->SetUsage( UsageClock() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\ssctl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ssctl.h
//
//  Contents:   Self Signed Certificate Trust List Subsystem used by the
//              Certificate Chaining Infrastructure for building complex
//              chains
//
//  History:    02-Feb-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SSCTL_H__)
#define __SSCTL_H__

#include <chain.h>

//
// CSSCtlObject.  This is the main object for caching trust information about
// a self signed certificate trust list
//

typedef struct _SSCTL_SIGNER_INFO {

    PCMSG_SIGNER_INFO      pMessageSignerInfo;
    CERT_OBJECT_IDENTIFIER SignerCertObjectIdentifier;
    BOOL                   fSignerHashAvailable;
    DWORD                  SignerCertificateHashSize;
    BYTE                   SignerCertificateHash[ MD5DIGESTLEN ];

} SSCTL_SIGNER_INFO, *PSSCTL_SIGNER_INFO;

class CSSCtlObject
{
public:

    //
    // Construction
    //

    CSSCtlObject (
          IN PCCERTCHAINENGINE pChainEngine,
          IN PCCTL_CONTEXT pCtlContext,
          OUT BOOL& rfResult
          );

    ~CSSCtlObject ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Trust information access
    //

    inline PCCTL_CONTEXT CtlContext ();

    BOOL GetSigner (
            IN PCCERTOBJECT pSubject,
            IN PCCHAINCALLCONTEXT pCallContext,
            IN HCERTSTORE hAdditionalStore,
            OUT PCCERTOBJECT* ppSigner,
            OUT BOOL* pfAdditionalStoreSigner,
            OUT BOOL* pfCtlSignatureValid
            );

    BOOL GetTrustListInfo (
            IN PCCERTOBJECT pCertObject,
            OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
            );

    VOID CalculateStatus (
                  IN LPFILETIME pTime,
                  IN PCERT_USAGE_MATCH pRequestedUsage,
                  IN DWORD dwFlags,
                  OUT PCERT_TRUST_STATUS pStatus
                  );

    BOOL GetSignerRequestedUsageAndTime (
            IN LPFILETIME pCurrentTime,
            OUT PCERT_USAGE_MATCH pSignerRequestedUsage,
            OUT LPFILETIME pSignerRequestedTime
            );

    //
    // Hash access
    //

    inline DWORD CtlHashSize ();
    inline LPBYTE CtlHash ();

    //
    // Index entry handles
    //

    inline HLRUENTRY HashIndexEntry ();

private:

    //
    // Reference count
    //

    ULONG                  m_cRefs;

    //
    // Self Signed Certificate Trust List Context
    //

    PCCTL_CONTEXT          m_pCtlContext;

    //
    // MD5 Hash of CTL
    //

    BYTE                   m_CtlHash[ MD5DIGESTLEN ];

    //
    // Signer information
    //

    SSCTL_SIGNER_INFO      m_SignerInfo;
    BOOL                   m_fHasSignatureBeenVerified;
    BOOL                   m_fSignatureValid;

    //
    // Message Store
    //

    HCERTSTORE             m_hMessageStore;

    //
    // Hash Index Entry
    //

    HLRUENTRY              m_hHashEntry;

    //
    // Chain engine
    //

    PCCERTCHAINENGINE      m_pChainEngine;
};

//
// CSSCtlObjectCache.  Cache of self signed certificate trust list objects
// indexed by hash. Note that this cache is NOT LRU maintained.  We expect
// the number of these objects to be small
//

typedef BOOL (WINAPI *PFN_ENUM_SSCTLOBJECTS) (
                          IN LPVOID pvParameter,
                          IN PCSSCTLOBJECT pSSCtlObject
                          );

class CSSCtlObjectCache
{
public:

    //
    // Construction
    //

    CSSCtlObjectCache (
          OUT BOOL& rfResult
          );

    ~CSSCtlObjectCache ();

    //
    // Object Management
    //

    BOOL PopulateCache (
                 IN PCCERTCHAINENGINE pChainEngine
                 );

    BOOL AddObject (
            IN PCSSCTLOBJECT pSSCtlObject,
            IN BOOL fCheckForDuplicate
            );

    VOID RemoveObject (
               IN PCSSCTLOBJECT pSSCtlObject
               );

    //
    // Access the indexes
    //

    inline HLRUCACHE HashIndex ();

    //
    // Searching and Enumeration
    //

    PCSSCTLOBJECT FindObjectByHash (
                      IN PCRYPT_HASH_BLOB pHash
                      );

    VOID EnumObjects (
             IN PFN_ENUM_SSCTLOBJECTS pfnEnum,
             IN LPVOID pvParameter
             );

    //
    // Resync
    //

    BOOL Resync (IN PCCERTCHAINENGINE pChainEngine);

private:

    //
    // Hash Index
    //

    HLRUCACHE m_hHashIndex;
};

//
// Object removal notification function
//

VOID WINAPI
SSCtlOnRemovalFromCache (
     IN LPVOID pv,
     IN OPTIONAL LPVOID pvRemovalContext
     );

//
// SSCtl Subsystem Utility Function Prototypes
//

BOOL WINAPI
SSCtlGetSignerInfo (
     IN PCCTL_CONTEXT pCtlContext,
     OUT PSSCTL_SIGNER_INFO pSignerInfo
     );

VOID WINAPI
SSCtlFreeSignerInfo (
     IN PSSCTL_SIGNER_INFO pSignerInfo
     );

BOOL WINAPI
SSCtlGetSignerCertificateObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCERTOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PSSCTL_SIGNER_INFO pSignerInfo,
     IN HCERTSTORE hAdditionalStore,
     OUT PCCERTOBJECT* ppCertObject,
     OUT BOOL* pfAdditionalStoreSigner
     );

PCCERT_CONTEXT WINAPI
SSCtlFindCertificateInStoreByIssuerAndSerialNumber (
     IN HCERTSTORE hStore,
     IN PCCERT_CONTEXT pCertContext,
     IN PCERT_NAME_BLOB pIssuer,
     IN PCRYPT_INTEGER_BLOB pSerialNumber
     );

PCCERT_CONTEXT WINAPI
SSCtlFindCertificateInStoreByHash (
     IN HCERTSTORE hStore,
     IN PCRYPT_HASH_BLOB pHashBlob
     );

VOID WINAPI
SSCtlGetCtlTrustStatus (
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fSignatureValid,
     IN LPFILETIME pTime,
     IN PCERT_USAGE_MATCH pRequestedUsage,
     IN DWORD dwFlags,
     OUT PCERT_TRUST_STATUS pStatus
     );

BOOL WINAPI
SSCtlPopulateCacheFromCertStore (
     IN PCCERTCHAINENGINE pChainEngine,
     IN OPTIONAL HCERTSTORE hStore
     );

BOOL WINAPI
SSCtlCreateCtlObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCTL_CONTEXT pCtlContext,
     OUT PCSSCTLOBJECT* ppSSCtlObject
     );

typedef struct _SSCTL_ENUM_OBJECTS_DATA {

    PFN_ENUM_SSCTLOBJECTS pfnEnumObjects;
    LPVOID                pvEnumParameter;

} SSCTL_ENUM_OBJECTS_DATA, *PSSCTL_ENUM_OBJECTS_DATA;

BOOL WINAPI
SSCtlEnumObjectsWalkFn (
     IN LPVOID pvParameter,
     IN HLRUENTRY hEntry
     );

BOOL WINAPI
SSCtlCreateObjectCache (
     OUT PCSSCTLOBJECTCACHE* ppSSCtlObjectCache
     );

VOID WINAPI
SSCtlFreeObjectCache (
     IN PCSSCTLOBJECTCACHE pSSCtlObjectCache
     );

VOID WINAPI
SSCtlFreeTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo
     );

BOOL WINAPI
SSCtlAllocAndCopyTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo,
     OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
     );

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::AddRef, public
//
//  Synopsis:   add a reference
//
//----------------------------------------------------------------------------
inline VOID
CSSCtlObject::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::Release, public
//
//  Synopsis:   release a reference
//
//----------------------------------------------------------------------------
inline VOID
CSSCtlObject::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CtlContext, public
//
//  Synopsis:   return the CTL context
//
//----------------------------------------------------------------------------
inline PCCTL_CONTEXT
CSSCtlObject::CtlContext ()
{
    return( m_pCtlContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CtlHashSize, public
//
//  Synopsis:   return the hash size
//
//----------------------------------------------------------------------------
inline DWORD
CSSCtlObject::CtlHashSize ()
{
    return( MD5DIGESTLEN );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CtlHash, public
//
//  Synopsis:   return the hash
//
//----------------------------------------------------------------------------
inline LPBYTE
CSSCtlObject::CtlHash ()
{
    return( m_CtlHash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::HashIndexEntry, public
//
//  Synopsis:   return the hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CSSCtlObject::HashIndexEntry ()
{
    return( m_hHashEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::HashIndex, public
//
//  Synopsis:   return the hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CSSCtlObjectCache::HashIndex ()
{
    return( m_hHashIndex );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\base64.h ===
#ifndef __BASE64_H__
#define __BASE64_H__

#ifdef __cplusplus
extern "C" {
#endif


#ifdef UNICODE
#define Base64Decode  Base64DecodeW
#else
#define Base64Decode  Base64DecodeA
#endif // !UNICODE

DWORD			// ERROR_*
Base64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD			// ERROR_*
Base64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

    
#ifdef UNICODE
#define Base64Encode  Base64EncodeW
#else
#define Base64Encode  Base64EncodeA
#endif // !UNICODE

DWORD			// ERROR_*
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut);

DWORD			// ERROR_*
Base64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR *pchOut,
    OUT DWORD *pcchOut);

    
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // BASE64
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\cryptapi\cryptapi.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : cryptapi.c                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  6 1994 larrys  New                                            //
//      Jan 16 1995 larrys  Added key verify                               //
//      Jan 25 1995 larrys  Added thread safe                              //
//      Jan 27 1995 larrys  Added Unicode support                          //
//      Feb 21 1995 larrys  Added Unicode support for CryptAcquireContext  //
//      Feb 21 1995 larrys  Fixed Unicode problem in CryptAcquireContext   //
//      Mar 08 1995 larrys  Removed CryptGetLastError                      //
//      Mar 20 1995 larrys  Removed Certificate APIs                       //
//      Mar 22 1995 larrys  #ifdef in WIN95 code                           //
//      Apr 06 1995 larrys  Increased signature key to 1024 bits           //
//      Apr 07 1995 larrys  Removed CryptConfigure                         //
//      Jun 14 1995 larrys  Removed pointer from RSA key struct            //
//      Jun 29 1995 larrys  Changed AcquireContext                         //
//      Jul 17 1995 larrys  Worked on AcquireContext                       //
//      Aug 01 1995 larrys  Removed CryptTranslate                         //
//                          And CryptDeinstallProvider                     //
//                          Changed CryptInstallProvider to                //
//                          CryptSetProvider                               //
//      Aug 03 1995 larrys  Cleanup                                        //
//      Aug 10 1995 larrys  CryptAcquireContext returns error              //
//                          NTE_BAD_KEYSEY_PARAM now                       //
//      Aug 14 1995 larrys  Removed key exchange stuff                     //
//      Aug 17 1995 larrys  Changed registry entry to decimcal             //
//      Aug 23 1995 larrys  Changed CryptFinishHash to CryptGetHashValue   //
//      Aug 28 1995 larrys  Removed parameter from CryptVerifySignature    //
//      Aug 31 1995 larrys  Remove GenRandom                               //
//      Sep 14 1995 larrys  Code review changes                            //
//      Sep 26 1995 larrys  Added Microsoft's signing key                  //
//      Sep 27 1995 larrys  Updated with more review changes               //
//      Oct 06 1995 larrys  Added more APIs Get/SetHash/ProvParam          //
//      Oct 12 1995 larrys  Remove CryptGetHashValue                       //
//      Oct 20 1995 larrys  Changed test key                               //
//      Oct 24 1995 larrys  Removed return of KeySet name                  //
//      Oct 30 1995 larrys  Removed WIN95                                  //
//      Nov  9 1995 larrys  Disable BUILD1057                              //
//      Nov 10 1995 larrys  Fix a problem in EnterHashCritSec              //
//      May 30 1996 larrys  Added hWnd support                             //
//      Oct 10 1996 jeffspel Reordered SetLastErrors and save error on     //
//                           AcquireContext failure                        //
//      Mar 21 1997 jeffspel Added second tier signatures, new APIs        //
//      Apr 11 1997 jeffspel Replace critical sections with interlocked    //
//                           inc/dec                                       //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <xdbg.h>

#include <wincrypt.h>   // Include here, since not included by LEAN_AND_MEAN
#include <rsa.h>
#include <msr_md5.h>
#include <rc4.h>
#include "scp.h"

#define EMULATE_RC4
#define EMULATE_BSAFE
#include "xcrypt.h"

// #define _HRESULT_TYPEDEF_ (unsigned long)

#ifndef RC4_KEYSIZE
#define RC4_KEYSIZE 5
#endif

#define IDR_PUBKEY1                     102


typedef struct _VTableStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncAcquireContext;
    FARPROC FuncReleaseContext;
    FARPROC FuncGenKey;
    FARPROC FuncDeriveKey;
    FARPROC FuncDestroyKey;
    FARPROC FuncSetKeyParam;
    FARPROC FuncGetKeyParam;
    FARPROC FuncExportKey;
    FARPROC FuncImportKey;
    FARPROC FuncEncrypt;
    FARPROC FuncDecrypt;
    FARPROC FuncCreateHash;
    FARPROC FuncHashData;
    FARPROC FuncHashSessionKey;
    FARPROC FuncDestroyHash;
    FARPROC FuncSignHash;
    FARPROC FuncVerifySignature;
    FARPROC FuncGenRandom;
    FARPROC FuncGetUserKey;
    FARPROC FuncSetProvParam;
    FARPROC FuncGetProvParam;
    FARPROC FuncSetHashParam;
    FARPROC FuncGetHashParam;
    FARPROC FuncNULL;

    FARPROC OptionalFuncDuplicateKey;
    FARPROC OptionalFuncDuplicateHash;
    FARPROC OptionalFuncNULL;

    HANDLE      DllHandle;                     // Handle to open DLL
    HCRYPTPROV  hProv;                         // Handle to provider
    DWORD       Version;
    DWORD       Inuse;
    LONG        RefCnt;
} VTableStruc, *PVTableStruc;

typedef struct _VKeyStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncGenKey;
    FARPROC FuncDeriveKey;
    FARPROC FuncDestroyKey;
    FARPROC FuncSetKeyParam;
    FARPROC FuncGetKeyParam;
    FARPROC FuncExportKey;
    FARPROC FuncImportKey;
    FARPROC FuncEncrypt;
    FARPROC FuncDecrypt;

    FARPROC OptionalFuncDuplicateKey;

    HCRYPTPROV  hProv;                         // Handle to provider
    HCRYPTKEY   hKey;                          // Handle to key
    DWORD       Version;
    DWORD       Inuse;
} VKeyStruc, *PVKeyStruc;

typedef struct _VHashStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncCreateHash;
    FARPROC FuncHashData;
    FARPROC FuncHashSessionKey;
    FARPROC FuncDestroyHash;
    FARPROC FuncSignHash;
    FARPROC FuncVerifySignature;
    FARPROC FuncSetHashParam;
    FARPROC FuncGetHashParam;

    FARPROC OptionalFuncDuplicateHash;

    HCRYPTPROV  hProv;                         // Handle to provider
    HCRYPTHASH  hHash;                         // Handle to hash
    DWORD       Version;
    DWORD       Inuse;
} VHashStruc, *PVHashStruc;

//
// Crypto providers have to have the following entry points:
//
LPCTSTR FunctionNames[] = {
    TEXT("CPAcquireContext"),
    TEXT("CPReleaseContext"),
    TEXT("CPGenKey"),
    TEXT("CPDeriveKey"),
    TEXT("CPDestroyKey"),
    TEXT("CPSetKeyParam"),
    TEXT("CPGetKeyParam"),
    TEXT("CPExportKey"),
    TEXT("CPImportKey"),
    TEXT("CPEncrypt"),
    TEXT("CPDecrypt"),
    TEXT("CPCreateHash"),
    TEXT("CPHashData"),
    TEXT("CPHashSessionKey"),
    TEXT("CPDestroyHash"),
    TEXT("CPSignHash"),
    TEXT("CPVerifySignature"),
    TEXT("CPGenRandom"),
    TEXT("CPGetUserKey"),
    TEXT("CPSetProvParam"),
    TEXT("CPGetProvParam"),
    TEXT("CPSetHashParam"),
    TEXT("CPGetHashParam"),
    NULL
    };

LPCTSTR OptionalFunctionNames[] = {
    TEXT("CPDuplicateKey"),
    TEXT("CPDuplicateHash"),
    NULL
    };

BOOL KeyDecrypted = FALSE;

DWORD hWnd = 0;
BYTE *pbContextInfo = NULL;
DWORD cbContextInfo = 0;

#define KEYSIZE512 0x48
#define KEYSIZE1024 0x88

typedef struct _SECONDTIER_SIG
{
    DWORD           dwMagic;
    DWORD           cbSig;
    BSAFE_PUB_KEY   Pub;
} SECOND_TIER_SIG, *PSECOND_TIER_SIG;

#ifdef TEST_BUILD_EXPONENT
#pragma message("WARNING: building advapai32.dll with TESTKEY enabled!")
struct _TESTKEY {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE512];
} TESTKEY = {
    {
	0x66b8443b,
	0x6f5fc900,
	0xa12132fe,
	0xff1b06cf,
	0x2f4826eb,
    },
    {
	0x3e, 0x69, 0x4f, 0x45, 0x31, 0x95, 0x60, 0x6c,
	0x80, 0xa5, 0x41, 0x99, 0x3e, 0xfc, 0x92, 0x2c,
	0x93, 0xf9, 0x86, 0x23, 0x3d, 0x48, 0x35, 0x81,
	0x19, 0xb6, 0x7c, 0x04, 0x43, 0xe6, 0x3e, 0xd4,
	0xd5, 0x43, 0xaf, 0x52, 0xdd, 0x51, 0x20, 0xac,
	0xc3, 0xca, 0xee, 0x21, 0x9b, 0x4a, 0x2d, 0xf7,
	0xd8, 0x5f, 0x32, 0xeb, 0x49, 0x72, 0xb9, 0x8d,
	0x2e, 0x1a, 0x76, 0x7f, 0xde, 0xc6, 0x75, 0xab,
	0xaf, 0x67, 0xe0, 0xf0, 0x8b, 0x30, 0x20, 0x92,
    }
};
#endif


#ifdef MS_INTERNAL_KEY
struct _mskey {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
	0x2bad85ae,
	0x883adacc,
	0xb32ebd68,
	0xa7ec8b06,
	0x58dbeb81,
    },
    {
	0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
	0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
	0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
	0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
	0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
	0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
	0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
	0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
	0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
	0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
	0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
	0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
	0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
	0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
	0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
	0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
	0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};
#endif


struct _key {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY = {
    {
	0x3fcbf1a9,
	0x08f597db,
	0xe4aecab4,
	0x75360f90,
	0x9d6c0f00,
    },
    {
	0x85, 0xdd, 0x9b, 0xf4, 0x4d, 0x0b, 0xc4, 0x96,
	0x3e, 0x79, 0x86, 0x30, 0x6d, 0x27, 0x31, 0xee,
	0x4a, 0x85, 0xf5, 0xff, 0xbb, 0xa9, 0xbd, 0x81,
	0x86, 0xf2, 0x4f, 0x87, 0x6c, 0x57, 0x55, 0x19,
	0xe4, 0xf4, 0x49, 0xa3, 0x19, 0x27, 0x08, 0x82,
	0x9e, 0xf9, 0x8a, 0x8e, 0x41, 0xd6, 0x91, 0x71,
	0x47, 0x48, 0xee, 0xd6, 0x24, 0x2d, 0xdd, 0x22,
	0x72, 0x08, 0xc6, 0xa7, 0x34, 0x6f, 0x93, 0xd2,
	0xe7, 0x72, 0x57, 0x78, 0x7a, 0x96, 0xc1, 0xe1,
	0x47, 0x38, 0x78, 0x43, 0x53, 0xea, 0xf3, 0x88,
	0x82, 0x66, 0x41, 0x43, 0xd4, 0x62, 0x44, 0x01,
	0x7d, 0xb2, 0x16, 0xb3, 0x50, 0x89, 0xdb, 0x0a,
	0x93, 0x17, 0x02, 0x02, 0x46, 0x49, 0x79, 0x76,
	0x59, 0xb6, 0xb1, 0x2b, 0xfc, 0xb0, 0x9a, 0x21,
	0xe6, 0xfa, 0x2d, 0x56, 0x07, 0x36, 0xbc, 0x13,
	0x7f, 0x1c, 0xde, 0x55, 0xfb, 0x0d, 0x67, 0x0f,
	0xc2, 0x17, 0x45, 0x8a, 0x14, 0x2b, 0xba, 0x55,
    }
};


struct _key2 {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY2 =  {
    {
	0x685fc690,
	0x97d49b6b,
	0x1dccd9d2,
	0xa5ec9b52,
	0x64fd29d7,
    },
    {
	0x03, 0x8c, 0xa3, 0x9e, 0xfb, 0x93, 0xb6, 0x72,
	0x2a, 0xda, 0x6f, 0xa5, 0xec, 0x26, 0x39, 0x58,
	0x41, 0xcd, 0x3f, 0x49, 0x10, 0x4c, 0xcc, 0x7e,
	0x23, 0x94, 0xf9, 0x5d, 0x9b, 0x2b, 0xa3, 0x6b,
	0xe8, 0xec, 0x52, 0xd9, 0x56, 0x64, 0x74, 0x7c,
	0x44, 0x6f, 0x36, 0xb7, 0x14, 0x9d, 0x02, 0x3c,
	0x0e, 0x32, 0xb6, 0x38, 0x20, 0x25, 0xbd, 0x8c,
	0x9b, 0xd1, 0x46, 0xa7, 0xb3, 0x58, 0x4a, 0xb7,
	0xdd, 0x0e, 0x38, 0xb6, 0x16, 0x44, 0xbf, 0xc1,
	0xca, 0x4d, 0x6a, 0x9f, 0xcb, 0x6f, 0x3c, 0x5f,
	0x03, 0xab, 0x7a, 0xb8, 0x16, 0x70, 0xcf, 0x98,
	0xd0, 0xca, 0x8d, 0x25, 0x57, 0x3a, 0x22, 0x8b,
	0x44, 0x96, 0x37, 0x51, 0x30, 0x00, 0x92, 0x1b,
	0x03, 0xb9, 0xf9, 0x0d, 0xb3, 0x1a, 0xe2, 0xb4,
	0xc5, 0x7b, 0xc9, 0x4b, 0xe2, 0x42, 0x25, 0xfe,
	0x3d, 0x42, 0xfa, 0x45, 0xc6, 0x94, 0xc9, 0x8e,
	0x87, 0x7e, 0xf6, 0x68, 0x90, 0x30, 0x65, 0x10,
    }
};


#define TABLEPROV       0x11111111
#define TABLEKEY        0x22222222
#define TABLEHASH       0x33333333

WCHAR szusertypeW[] = L"Comm\\Security\\Crypto\\Providers\\Type ";
WCHAR szmachinetypeW[] = L"Comm\\Security\\Crypto\\Defaults\\Provider Types\\Type ";
WCHAR szproviderW[] = L"Comm\\Security\\Crypto\\Defaults\\Provider\\";
WCHAR szenumprovidersW[] = L"Comm\\Security\\Crypto\\Defaults\\Provider";
WCHAR szprovidertypesW[] = L"Comm\\Security\\Crypto\\Defaults\\Provider Types";

BOOL EnterProviderCritSec(IN PVTableStruc pVTable);
void LeaveProviderCritSec(IN PVTableStruc pVTable);
BOOL EnterKeyCritSec(IN PVKeyStruc pVKey);
void LeaveKeyCritSec(IN PVKeyStruc pVKey);
BOOL EnterHashCritSec(IN PVHashStruc pVHash);
void LeaveHashCritSec(IN PVHashStruc pVHash);

BOOL CProvVerifyImage(LPCWSTR lpszImage,
		              BYTE *pSigData);

BOOL NewVerifyImage(LPCWSTR lpszImage,
		            BYTE *pSigData,
                    DWORD cbData,
                    BOOL fUnknownLen);

BOOL BuildVKey(IN PVKeyStruc *ppVKey,
               IN PVTableStruc pVTable);

BOOL BuildVHash(
                IN PVHashStruc *ppVKey,
                IN PVTableStruc pVTable
                );

BOOL CPReturnhWnd(DWORD *phWnd);

static void __ltoaW(DWORD val, WCHAR *buf);


DWORD StrToLW(WCHAR *InStr)
{
    DWORD dwVal = 0;

    while(*InStr)
    {
        dwVal = (10 * dwVal) + (*InStr - L'0');
        InStr++;
    }

    return dwVal;
}

/*
extern FARPROC CPAcquireContext;
extern FARPROC CPReleaseContext;
extern FARPROC CPGenKey;
extern FARPROC CPDeriveKey;
extern FARPROC CPDestroyKey;
extern FARPROC CPSetKeyParam;
extern FARPROC CPGetKeyParam;
extern FARPROC CPExportKey;
extern FARPROC CPImportKey;
extern FARPROC CPEncrypt;
extern FARPROC CPDecrypt;
extern FARPROC CPCreateHash;
extern FARPROC CPHashData;
extern FARPROC CPHashSessionKey;
extern FARPROC CPDestroyHash;
extern FARPROC CPSignHash;
extern FARPROC CPVerifySignature;
extern FARPROC CPGenRandom;
extern FARPROC CPGetUserKey;
extern FARPROC CPSetProvParam;
extern FARPROC CPGetProvParam;
extern FARPROC CPSetHashParam;
extern FARPROC CPGetHashParam;

extern FARPROC CPDuplicateKey;
extern FARPROC CPDuplicateHash;
*/


/*
 -      CryptAcquireContextW
 -
 *      Purpose:
 *               The CryptAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *      Parameters:
 *               OUT    phProv         -  Handle to a CSP
 *               IN OUT pszIdentity    -  Pointer to the name of the context's
 *                                        keyset.
 *               IN OUT pszProvName    -  Pointer to the name of the provider.
 *               IN     dwReqProvider  -  Requested CSP type
 *               IN     dwFlags        -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptAcquireContextW(OUT    HCRYPTPROV *phProv,
                IN     LPCWSTR pszIdentity,
                IN     LPCWSTR pszProvName,
                IN     DWORD dwReqProvider,
                IN     DWORD dwFlags)
{
    HANDLE          handle = 0;
    DWORD           bufsize;
    DWORD           *pTable;
    PVTableStruc    pVTable = NULL;
    WCHAR           *pszTmpProvName = NULL;
    DWORD           i;
    HKEY            hKey = 0;
    DWORD           cbValue;
    DWORD           cbTemp;
    WCHAR           *pszValue = NULL;
    BYTE            *SignatureBuf = NULL;
    DWORD           provtype;
    BOOL            rt = CRYPT_FAILED;
    DWORD           dwType;
    LONG            err;
    DWORD           dwErr;
    WCHAR            typebuf[9]; // sfield = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    VTableProvStruc VTableProv;
    
    bufsize = sizeof(VTableStruc);

    if ((pVTable = (PVTableStruc) LocalAlloc(LMEM_ZEROINIT,
                                             (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    
    pVTable->FuncAcquireContext = CPAcquireContext;
    pVTable->FuncReleaseContext = CPReleaseContext;
    pVTable->FuncGenKey = CPGenKey;
    pVTable->FuncDeriveKey = CPDeriveKey;
    pVTable->FuncDestroyKey = CPDestroyKey;
    pVTable->FuncSetKeyParam = CPSetKeyParam;
    pVTable->FuncGetKeyParam = CPGetKeyParam;
    pVTable->FuncExportKey = CPExportKey;
    pVTable->FuncImportKey = CPImportKey;
    pVTable->FuncEncrypt = CPEncrypt;
    pVTable->FuncDecrypt = CPDecrypt;
    pVTable->FuncCreateHash = CPCreateHash;
    pVTable->FuncHashData = CPHashData;
    pVTable->FuncHashSessionKey = CPHashSessionKey;
    pVTable->FuncDestroyHash = CPDestroyHash;
    pVTable->FuncSignHash = CPSignHash;
    pVTable->FuncVerifySignature = CPVerifySignature;
    pVTable->FuncGenRandom = CPGenRandom;
    pVTable->FuncGetUserKey = CPGetUserKey;
    pVTable->FuncSetProvParam = CPSetProvParam;
    pVTable->FuncGetProvParam = CPGetProvParam;
    pVTable->FuncSetHashParam = CPSetHashParam;
    pVTable->FuncGetHashParam = CPGetHashParam;

    pVTable->OptionalFuncDuplicateKey = CPDuplicateKey;
    pVTable->OptionalFuncDuplicateHash = CPDuplicateHash;
    
    pVTable->DllHandle = handle;

    memset(&VTableProv, 0, sizeof(VTableProv));
    VTableProv.Version = 3;
    VTableProv.FuncVerifyImage = CProvVerifyImage;
    VTableProv.FuncReturnhWnd = CPReturnhWnd;
    VTableProv.dwProvType = dwReqProvider;
    VTableProv.pszProvName = "RSA";
    VTableProv.pbContextInfo = pbContextInfo;
    VTableProv.cbContextInfo = cbContextInfo;

    try
    {
        rt = pVTable->FuncAcquireContext(phProv, pszIdentity, dwFlags,
                                         &VTableProv);
        if (RCRYPT_SUCCEEDED(rt) &&
            ((dwFlags & CRYPT_DELETEKEYSET) != CRYPT_DELETEKEYSET))
        {
            pVTable->hProv = *phProv;
            *phProv = (HCRYPTPROV) pVTable;

            pVTable->Version = TABLEPROV;
            pVTable->Inuse = 1;
            pVTable->RefCnt = 1;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        rt = CRYPT_FAILED;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }


Ret:
    dwErr = GetLastError();
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    if (pszValue)
        LocalFree(pszValue);
    //if (hKey)
    //    RegCloseKey(hKey);
    if (SignatureBuf)
        LocalFree(SignatureBuf);
    if ((CRYPT_SUCCEED != rt) || (dwFlags & CRYPT_DELETEKEYSET))
    {
        //if (handle)
        //    FreeLibrary(handle);
        if (pVTable)
            LocalFree(pVTable);
        SetLastError(dwErr);
    }
    return rt;
}

/*
 -      CryptContextAddRef
 -
 *      Purpose:
 *               Increments the reference counter on the provider handle.
 *
 *      Parameters:
 *               IN  hProv         -  Handle to a CSP
 *               IN  pdwReserved   -  Reserved parameter
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptContextAddRef(
                          IN HCRYPTPROV hProv,
                          IN DWORD *pdwReserved,
			              IN DWORD dwFlags
                          )
{
    PVTableStruc    pVTable;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        if ((NULL != pdwReserved) || (0 != dwFlags))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (InterlockedIncrement(&pVTable->RefCnt) <= 0)
            SetLastError(ERROR_INVALID_PARAMETER);
        else
            fRet = CRYPT_SUCCEED;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

Ret:
    return fRet;
}

/*
 -      CryptReleaseContext
 -
 *      Purpose:
 *               The CryptReleaseContext function is used to release a
 *               context created by CryptAcquireContext.
 *
 *     Parameters:
 *               IN  hProv         -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptReleaseContext(IN HCRYPTPROV hProv,
                           IN DWORD dwFlags)
{
#ifndef _XBOX
    PVTableStruc    pVTable;
    BOOL            rt;
    BOOL            fRet = CRYPT_FAILED;
    DWORD           dwErr = ERROR_INVALID_PARAMETER;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (pVTable->RefCnt <= 0)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 == InterlockedDecrement(&pVTable->RefCnt))
        {
            if (0 < InterlockedDecrement(&pVTable->Inuse))
            {
                InterlockedIncrement(&pVTable->Inuse);
                SetLastError(ERROR_BUSY);
                goto Ret;
            }
            InterlockedIncrement(&pVTable->Inuse);

            if (FALSE == (rt = pVTable->FuncReleaseContext(pVTable->hProv, dwFlags)))
            {
                dwErr = GetLastError();
            }
            pVTable->Version = 0;
            FreeLibrary(pVTable->DllHandle);
            LocalFree(pVTable);
            if (!rt)
            {
                SetLastError(dwErr);
                goto Ret;
            }
        }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    return fRet;
#else
	return TRUE;
#endif
}

/*
 -      CryptGenKey
 -
 *      Purpose:
 *                Generate cryptographic keys
 *
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGenKey(IN HCRYPTPROV hProv,
            IN ALG_ID Algid,
            IN DWORD dwFlags,
            OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = NULL;
    BOOL            fProvCritSec = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncGenKey(pVTable->hProv, Algid, dwFlags,
                            phKey)))
        {
            goto Ret;
        }

        pVKey->hKey = *phKey;

        *phKey = (HCRYPTKEY) pVKey;

        pVKey->Version = TABLEKEY;

        pVKey->hProv = hProv;

        pVKey->Inuse = 1;

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
    {
        if (pVKey)
            LocalFree(pVKey);
        SetLastError(dwErr);
    }
    return fRet;
}

/*
 -      CryptDuplicateKey
 -
 *      Purpose:
 *                Duplicate a cryptographic key
 *
 *
 *      Parameters:
 *               IN      hKey           -  Handle to the key to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phKey          -  Handle to the new duplicate key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDuplicateKey(
                         IN HCRYPTKEY hKey,
		                 IN DWORD *pdwReserved,
		                 IN DWORD dwFlags,
		                 OUT HCRYPTKEY * phKey
                         )
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    PVKeyStruc      pVNewKey = NULL;
    HCRYPTKEY       hNewKey;
    BOOL            fProvCritSecSet = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pVKey->OptionalFuncDuplicateKey)
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        fProvCritSecSet = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVNewKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVKey->OptionalFuncDuplicateKey(pVTable->hProv, pVKey->hKey,
                                                          pdwReserved, dwFlags, &hNewKey)))
        {
            goto Ret;
        }

        pVNewKey->hKey = hNewKey;

        pVNewKey->Version = TABLEKEY;

        pVNewKey->hProv = pVKey->hProv;

        pVKey->Inuse = 1;

        *phKey = (HCRYPTKEY) pVNewKey;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    dwErr = GetLastError();
    if (fProvCritSecSet)
        LeaveProviderCritSec(pVTable);
    if (fRet == CRYPT_FAILED)
    {
        if (NULL != pVNewKey)
            LocalFree(pVNewKey);
        SetLastError(dwErr);
    }

    return fRet;
}

/*
 -      CryptDeriveKey
 -
 *      Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hHash      -  Handle to hash of base data
 *               IN      dwFlags    -  Flags values
 *               IN OUT  phKey      -  Handle to a generated key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDeriveKey(IN HCRYPTPROV hProv,
                IN ALG_ID Algid,
                IN HCRYPTHASH hHash,
                IN DWORD dwFlags,
                IN OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            fUpdate = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        if (dwFlags & CRYPT_UPDATE_KEY)
        {
            fUpdate = TRUE;
            pVKey = (PVKeyStruc) phKey;

            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }
        else
        {
            if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
            {
                goto Ret;
            }
        }

        if (RCRYPT_FAILED(pVTable->FuncDeriveKey(pVTable->hProv, Algid,
                        pVHash->hHash, dwFlags, phKey)))
        {
            goto Ret;
        }

        if ((dwFlags & CRYPT_UPDATE_KEY) != CRYPT_UPDATE_KEY)
        {
            pVKey->hKey = *phKey;

            *phKey = (HCRYPTKEY)pVKey;

            pVKey->hProv = hProv;

            pVKey->Version = TABLEKEY;

            pVKey->Inuse = 1;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (CRYPT_SUCCEED != fRet)
    {
        if (pVKey && (!fUpdate))
            LocalFree(pVKey);
        SetLastError(dwErr);
    }
    return fRet;
}


/*
 -      CryptDestroyKey
 -
 *      Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *      Parameters:
 *               IN      hKey   -  Handle to a key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDestroyKey(IN HCRYPTKEY hKey)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVKey->Inuse))
        {
            InterlockedIncrement(&pVKey->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVKey->Inuse);

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (FALSE == (rt = pVKey->FuncDestroyKey(pVTable->hProv, pVKey->hKey)))
            dwErr = GetLastError();

        pVKey->Version = 0;
        LocalFree(pVKey);

        if (!rt)
        {
            SetLastError(dwErr);
            goto Ret;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);
    return fRet;
}


/*
 -      CryptSetKeyParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetKeyParam(IN HCRYPTKEY hKey,
            IN DWORD dwParam,
            IN BYTE *pbData,
            IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    BOOL            rt = CRYPT_FAILED;
    BOOL            fCritSec = FALSE;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVKey->Inuse))
        {
            InterlockedIncrement(&pVKey->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVKey->Inuse);

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fCritSec = TRUE;

        rt = pVKey->FuncSetKeyParam(pVTable->hProv, pVKey->hKey,
                                    dwParam, pbData, dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);
}


/*
 -      CryptGetKeyParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetKeyParam(IN HCRYPTKEY hKey,
			IN DWORD dwParam,
			IN BYTE *pbData,
			IN DWORD *pdwDataLen,
			IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    BOOL            rt = CRYPT_FAILED;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        rt = pVKey->FuncGetKeyParam(pVTable->hProv, pVKey->hKey,
                                    dwParam, pbData, pdwDataLen,
                                    dwFlags);

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);
}


/*
 -      CryptGenRandom
 -
 *      Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               OUT pbBuffer   -  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGenRandom(IN HCRYPTPROV hProv,
		      IN DWORD dwLen,
		      OUT BYTE *pbBuffer)

{
    PVTableStruc    pVTable;
    BOOL            fTableCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;
    
	    rt = pVTable->FuncGenRandom(pVTable->hProv, dwLen, pbBuffer);

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);
}

/*
 -      CryptGetUserKey
 -
 *      Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetUserKey(IN HCRYPTPROV hProv,
                       IN DWORD dwKeySpec,
                       OUT HCRYPTKEY *phUserKey)
{

    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncGetUserKey(pVTable->hProv, dwKeySpec,
                                                  phUserKey)))
        {
            goto Ret;
        }

        pVKey->hKey = *phUserKey;

        pVKey->hProv = hProv;

        *phUserKey = (HCRYPTKEY)pVKey;

        pVKey->Version = TABLEKEY;

        pVKey->Inuse = 1;

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if ((CRYPT_SUCCEED != fRet) && pVKey)
        LocalFree(pVKey);
    return fRet;
}



/*
 -      CryptExportKey
 -
 *      Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *      Parameters:
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               OUT pdwDataLen - Length of key blob in bytes
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptExportKey(IN HCRYPTKEY hKey,
                IN HCRYPTKEY hPubKey,
                IN DWORD dwBlobType,
                IN DWORD dwFlags,
                OUT BYTE *pbData,
                OUT DWORD *pdwDataLen)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    PVKeyStruc      pVPublicKey;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fPubKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVPublicKey = (PVKeyStruc) hPubKey;

        if (pVPublicKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVPublicKey)))
            {
                goto Ret;
            }
            fPubKeyCritSec = TRUE;
        }

        rt = pVKey->FuncExportKey(pVTable->hProv, pVKey->hKey,
                                  (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                                  dwBlobType, dwFlags, pbData,
                                  pdwDataLen);

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVPublicKey != NULL)
    {
        if (fPubKeyCritSec)
            LeaveKeyCritSec(pVPublicKey);
    }
    return(rt);
}


/*
 -      CryptImportKey
 -
 *      Purpose:
 *                Import cryptographic keys
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptImportKey(IN HCRYPTPROV hProv,
		      IN CONST BYTE *pbData,
		      IN DWORD dwDataLen,
		      IN HCRYPTKEY hPubKey,
		      IN DWORD dwFlags,
		      OUT HCRYPTKEY *phKey)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = NULL;
    PVKeyStruc      pVPublicKey;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fPubKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fBuiltKey = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVPublicKey = (PVKeyStruc)hPubKey;

        if (pVPublicKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVPublicKey)))
            {
                goto Ret;
            }
            fPubKeyCritSec = TRUE;
        }

        if (dwFlags & CRYPT_UPDATE_KEY)
        {
            pVKey = (PVKeyStruc) phKey;

            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }
        else
        {
            if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
            {
                goto Ret;
            }
            fBuiltKey = TRUE;
        }

        if (RCRYPT_FAILED(pVTable->FuncImportKey(pVTable->hProv, pbData,
                                                 dwDataLen,
                                                 (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                                                 dwFlags, phKey)))
        {
            goto Ret;
	    }

	    if ((dwFlags & CRYPT_UPDATE_KEY) != CRYPT_UPDATE_KEY)
	    {
            pVKey->hKey = *phKey;

            *phKey = (HCRYPTKEY) pVKey;

            pVKey->hProv = hProv;

            pVKey->Version = TABLEKEY;
        }
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVPublicKey != NULL)
    {
        if (fPubKeyCritSec)
            LeaveKeyCritSec(pVPublicKey);
    }
    if ((dwFlags & CRYPT_UPDATE_KEY) && fKeyCritSec)
    {
        LeaveKeyCritSec(pVKey);
    }
    else if ((CRYPT_SUCCEED != fRet) && fBuiltKey && pVKey)
    {
        LocalFree(pVKey);
    }

    return fRet;
}


/*
 -      CryptEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptEncrypt(IN HCRYPTKEY hKey,
            IN HCRYPTHASH hHash,
		    IN BOOL Final,
		    IN DWORD dwFlags,
		    IN OUT BYTE *pbData,
		    IN OUT DWORD *pdwDataLen,
		    IN DWORD dwBufLen)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    PVHashStruc     pVHash;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (pVHash != NULL)
        {
            if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
            {
                goto Ret;
            }
            fHashCritSec = TRUE;
        }

        rt = pVKey->FuncEncrypt(pVTable->hProv, pVKey->hKey,
                                (pVHash == NULL ? 0 : pVHash->hHash),
                                Final, dwFlags, pbData,
                                pdwDataLen, dwBufLen);

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (pVHash != NULL)
    {
        if (fHashCritSec)
            LeaveHashCritSec(pVHash);
    }
    return rt;
}


/*
 -      CryptDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDecrypt(IN HCRYPTKEY hKey,
		    IN HCRYPTHASH hHash,
		    IN BOOL Final,
		    IN DWORD dwFlags,
		    IN OUT BYTE *pbData,
		    IN OUT DWORD *pdwDataLen)

{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    PVHashStruc     pVHash;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (pVHash != NULL)
        {
            if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
            {
                goto Ret;
            }
            fHashCritSec = TRUE;
        }
    
        rt = pVKey->FuncDecrypt(pVTable->hProv, pVKey->hKey,
                                (pVHash == NULL ? 0 : pVHash->hHash),
                                Final, dwFlags, pbData, pdwDataLen);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
	if (pVHash != NULL)
    {
        if (fHashCritSec)
            LeaveHashCritSec(pVHash);
    }
    return(rt);
}


/*
 -      CryptCreateHash
 -
 *      Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *      Parameters:
 *               IN  hProv   -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptCreateHash(IN HCRYPTPROV hProv,
		       IN ALG_ID Algid,
		       IN HCRYPTKEY hKey,
		       IN DWORD dwFlags,
		       OUT HCRYPTHASH *phHash)
{
    PVTableStruc    pVTable;
    DWORD           bufsize;
    PVKeyStruc      pVKey;
    PVHashStruc     pVHash = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVKey = (PVKeyStruc) hKey;

        if (pVKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }

        bufsize = sizeof(VHashStruc);

        if (!BuildVHash(&pVHash, pVTable))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncCreateHash(pVTable->hProv, Algid,
                                                  (pVKey == NULL ? 0 : pVKey->hKey),
                                                  dwFlags, phHash)))
	    {
            goto Ret;
	    }

        pVHash->hHash = *phHash;

        *phHash = (HCRYPTHASH) pVHash;

        pVHash->Version = TABLEHASH;

        pVHash->Inuse = 1;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVKey != NULL)
    {
        if (fKeyCritSec)
            LeaveKeyCritSec(pVKey);
    }
    if ((CRYPT_SUCCEED != fRet) && pVHash)
        LocalFree(pVHash);
    return fRet;
}

/*
 -      CryptDuplicateHash
 -
 *      Purpose:
 *                Duplicate a cryptographic hash
 *
 *
 *      Parameters:
 *               IN      hHash          -  Handle to the hash to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phHash         -  Handle to the new duplicate hash
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDuplicateHash(
                         IN HCRYPTHASH hHash,
		                 IN DWORD *pdwReserved,
		                 IN DWORD dwFlags,
		                 OUT HCRYPTHASH * phHash
                         )
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    PVHashStruc     pVNewHash = NULL;
    HCRYPTHASH      hNewHash;
    BOOL            fProvCritSecSet = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pVHash->OptionalFuncDuplicateHash)
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        fProvCritSecSet = TRUE;


        if (RCRYPT_FAILED(BuildVHash(&pVNewHash, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVHash->OptionalFuncDuplicateHash(pVTable->hProv, pVHash->hHash,
                                                          pdwReserved, dwFlags, &hNewHash)))
        {
            goto Ret;
        }

        pVNewHash->hHash = hNewHash;

        pVNewHash->Version = TABLEHASH;

        pVNewHash->hProv = pVHash->hProv;

        pVHash->Inuse = 1;

        *phHash = (HCRYPTHASH) pVNewHash;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if ((fRet == CRYPT_FAILED) && (NULL != pVNewHash))
        LocalFree(pVNewHash);
    if (fProvCritSecSet)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);

    return fRet;
}

/*
 -      CryptHashData
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptHashData(IN HCRYPTHASH hHash,
		     IN CONST BYTE *pbData,
		     IN DWORD dwDataLen,
		     IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (!pVHash->FuncHashData(pVTable->hProv,
                                  pVHash->hHash,
                                  pbData, dwDataLen, dwFlags))
            goto Ret;

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);

    return fRet;

}

/*
 -      CryptHashSessionKey
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a key object
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *      Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */
WINADVAPI
BOOL
WINAPI CryptHashSessionKey(IN HCRYPTHASH hHash,
			   IN  HCRYPTKEY hKey,
			   IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    PVKeyStruc      pVKey;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVKey = (PVKeyStruc) hKey;

        if (pVKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }

        rt = pVHash->FuncHashSessionKey(pVTable->hProv,
                                        pVHash->hHash,
                                        pVKey->hKey,
                                        dwFlags);

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVKey != NULL)
    {
        if (fKeyCritSec)
            LeaveKeyCritSec(pVKey);
    }
    return rt;
}


/*
 -      CryptDestoryHash
 -
 *      Purpose:
 *                Destory the hash object
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDestroyHash(IN HCRYPTHASH hHash)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVHash->Inuse))
        {
            InterlockedIncrement(&pVHash->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVHash->Inuse);

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVHash->FuncDestroyHash(pVTable->hProv, pVHash->hHash);

        pVHash->Version = 0;
        LocalFree(pVHash);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}

WINADVAPI
BOOL
WINAPI LocalSignHashW(IN  HCRYPTHASH hHash,
		      IN  DWORD dwKeySpec,
		      IN  LPCWSTR sDescription,
		      IN  DWORD dwFlags,
		      OUT BYTE *pbSignature,
		      OUT DWORD *pdwSigLen)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVHash->FuncSignHash(pVTable->hProv, pVHash->hHash,
                                  dwKeySpec,
                                  sDescription, dwFlags,
                                  pbSignature, pdwSigLen);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptSignHashW
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT pdwSigLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */
#ifndef WIN95
WINADVAPI
BOOL
WINAPI CryptSignHashW(IN  HCRYPTHASH hHash,
		      IN  DWORD dwKeySpec,
		      IN  LPCWSTR sDescription,
		      IN  DWORD dwFlags,
		      OUT BYTE *pbSignature,
		      OUT DWORD *pdwSigLen)
{
    return LocalSignHashW(hHash, dwKeySpec, sDescription,
                          dwFlags, pbSignature, pdwSigLen);
}
#else
WINADVAPI
BOOL
WINAPI CryptSignHashW(IN  HCRYPTHASH hHash,
		      IN  DWORD dwKeySpec,
		      IN  LPCWSTR sDescription,
		      IN  DWORD dwFlags,
		      OUT BYTE *pbSignature,
		      OUT DWORD *pdwSigLen)
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif



WINADVAPI
BOOL
WINAPI LocalVerifySignatureW(IN HCRYPTHASH hHash,
			     IN CONST BYTE *pbSignature,
			     IN DWORD dwSigLen,
			     IN HCRYPTKEY hPubKey,
			     IN LPCWSTR sDescription,
			     IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    PVKeyStruc      pVKey;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVKey = (PVKeyStruc) hPubKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        rt = pVHash->FuncVerifySignature(pVTable->hProv,
                        pVHash->hHash, pbSignature,
                        dwSigLen,
                        (pVKey == NULL ? 0 : pVKey->hKey),
                        sDescription, dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    return rt;
}

/*
 -      CryptVerifySignatureW
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
#ifndef WIN95
WINADVAPI
BOOL
WINAPI CryptVerifySignatureW(IN HCRYPTHASH hHash,
			     IN CONST BYTE *pbSignature,
			     IN DWORD dwSigLen,
			     IN HCRYPTKEY hPubKey,
			     IN LPCWSTR sDescription,
			     IN DWORD dwFlags)
{
    return LocalVerifySignatureW(hHash, pbSignature, dwSigLen,
			                     hPubKey, sDescription, dwFlags);
}
#else
WINADVAPI
BOOL
WINAPI CryptVerifySignatureW(IN HCRYPTHASH hHash,
			     IN CONST BYTE *pbSignature,
			     IN DWORD dwSigLen,
			     IN HCRYPTKEY hPubKey,
			     IN LPCWSTR sDescription,
			     IN DWORD dwFlags)
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif



/*
 -      CryptSetProvParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a provider
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetProvParam(IN HCRYPTPROV hProv,
			 IN DWORD dwParam,
			 IN BYTE *pbData,
			 IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BYTE            *pbTmp;
    CRYPT_DATA_BLOB *pBlob;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        if (dwParam == PP_CLIENT_HWND)
        {
            hWnd = *((DWORD *) pbData);
            rt = CRYPT_SUCCEED;
            goto Ret;
        }
        else if (dwParam == PP_CONTEXT_INFO)
        {
            pBlob = (CRYPT_DATA_BLOB*)pbData;

            // allocate space for the new context info
            if (NULL == (pbTmp = (BYTE*)LocalAlloc(LMEM_ZEROINIT, pBlob->cbData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
            memcpy(pbTmp, pBlob->pbData, pBlob->cbData);

            // free any previously allocated context info
            if (NULL != pbContextInfo)
            {
                LocalFree(pbContextInfo);
            }
            cbContextInfo = pBlob->cbData;
            pbContextInfo = pbTmp;

            rt = CRYPT_SUCCEED;
            goto Ret;
        }

        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVTable->Inuse))
        {
            InterlockedIncrement(&pVTable->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVTable->Inuse);

        rt = pVTable->FuncSetProvParam(pVTable->hProv, dwParam, pbData,
                                       dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return(rt);
}


/*
 -      CryptGetProvParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a proivder
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetProvParam(IN HCRYPTPROV hProv,
			 IN DWORD dwParam,
			 IN BYTE *pbData,
			 IN DWORD *pdwDataLen,
			 IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVTable->FuncGetProvParam(pVTable->hProv, dwParam, pbData,
                                       pdwDataLen, dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptSetHashParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetHashParam(IN HCRYPTHASH hHash,
			 IN DWORD dwParam,
			 IN BYTE *pbData,
			 IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVHash->Inuse))
        {
            InterlockedIncrement(&pVHash->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVHash->Inuse);

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVHash->FuncSetHashParam(pVTable->hProv, pVHash->hHash,
                                      dwParam, pbData, dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptGetHashParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetHashParam(IN HCRYPTKEY hHash,
			 IN DWORD dwParam,
			 IN BYTE *pbData,
			 IN DWORD *pdwDataLen,
			 IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVHash->FuncGetHashParam(pVTable->hProv, pVHash->hHash,
                                      dwParam, pbData, pdwDataLen,
                                      dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}



/*
 -      CryptSetProviderW
 -
 *      Purpose:
 *                Set a cryptography provider
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderW(IN LPCWSTR pszProvName,
			 IN DWORD  dwProvType)
{
#ifndef _XBOX
    HKEY        hKey = 0;
    LONG        err;
    DWORD       dwIgn;
    DWORD       cbValue;
    WCHAR        *pszValue = NULL;
    WCHAR       typebuf[9]; // sfield = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    BOOL        fRet = CRYPT_FAILED;

    try
    {
        if (dwProvType == 0 || dwProvType > 999 || pszProvName == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        cbValue = (lstrlenW(pszProvName) + 1 ) * sizeof(WCHAR);

        if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                        sizeof(szusertypeW) + ((5 + 1) * sizeof(WCHAR))
                        )) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        lstrcpyW(pszValue, szusertypeW);
        __ltoaW(dwProvType, typebuf);
        lstrcatW(pszValue, &typebuf[5]);

        if ((err = RegCreateKeyExW(HKEY_CURRENT_USER,
                        (const WCHAR *) pszValue,
                        0L, L"", REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwIgn)) != ERROR_SUCCESS)
        {
            SetLastError(err);
            goto Ret;
        }

        RegCloseKey(HKEY_CURRENT_USER);

        if ((err = RegSetValueExW(hKey, L"Name", 0L, REG_SZ,
                        (const LPBYTE) pszProvName,
                        cbValue)) != ERROR_SUCCESS)
        {
            SetLastError(err);
            goto Ret;
        }

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszValue)
        LocalFree(pszValue);
    if (hKey)
        RegCloseKey(hKey);

    return fRet;
#else
	return TRUE;
#endif
}


/*
 -      CryptSetProviderExW
 -
 *      Purpose:
 *                Set the cryptographic provider as the default
 *                either for machine or for user.
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderExW(
                           IN LPCWSTR pszProvName,
                           IN DWORD dwProvType,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags
                           )
{
#ifndef _XBOX
    HKEY        hRegKey = 0;
    LONG        err;
    DWORD       dwDisp;
    DWORD       cbValue;
    WCHAR        *pszValue = NULL;
    WCHAR        *pszFullName = NULL;
    DWORD       cbFullName;
    WCHAR        typebuf[9]; // sfield: = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    DWORD       dwKeyType;
    DWORD       dw;
    DWORD       cbProvType;
    BOOL        fRet = CRYPT_FAILED;

    try
    {
        if ((dwProvType == 0) || (dwProvType > 999) ||
            (pszProvName == NULL) || (pdwReserved != NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((dwFlags & ~(CRYPT_MACHINE_DEFAULT | CRYPT_USER_DEFAULT | CRYPT_DELETE_DEFAULT)) ||
            ((dwFlags & CRYPT_MACHINE_DEFAULT) && (dwFlags & CRYPT_USER_DEFAULT)))
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        cbValue = (lstrlenW(pszProvName) + 1) * sizeof(WCHAR);

        // check if the CSP has been installed
        cbFullName = cbValue + sizeof(szenumprovidersW) + sizeof(WCHAR);

        if (NULL == (pszFullName = (WCHAR *) LocalAlloc(LMEM_ZEROINIT, cbFullName)))
	    {
		    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		    goto Ret;
	    }

        lstrcpyW(pszFullName, szenumprovidersW);
        pszFullName[(sizeof(szenumprovidersW) / sizeof(WCHAR)) - 1] = L'\\';
        lstrcpyW((LPWSTR)((LPBYTE)pszFullName + sizeof(szenumprovidersW)), pszProvName);

        if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        (const WCHAR *) pszFullName,
                        0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        cbProvType = sizeof(dw);
        if (ERROR_SUCCESS != (err = RegQueryValueExW(hRegKey,
                                                    (const WCHAR *) L"Type",
                                                    NULL, &dwKeyType, (BYTE*)&dw,
                                                    &cbProvType)))
        {
            SetLastError(err);
            goto Ret;
        }
        if (dwProvType != dw)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegCloseKey(hRegKey)))
        {
            SetLastError(err);
            goto Ret;
        }

	    if (dwFlags & CRYPT_MACHINE_DEFAULT)
	    {
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                            (lstrlenW(szmachinetypeW) + 5 + 1) * sizeof(WCHAR) )) == NULL)
		    {
			    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			    goto Ret;
		    }

            lstrcpyW(pszValue, szmachinetypeW);
            __ltoaW(dwProvType, typebuf);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                            (const WCHAR *) pszValue,
                            0L, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hRegKey, &dwDisp)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            // check the delete flag
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if (ERROR_SUCCESS != (err = RegDeleteKeyW(HKEY_LOCAL_MACHINE,
                                                         (const WCHAR *)pszValue)))
                {
                    SetLastError(err);
                    goto Ret;
                }
                fRet = CRYPT_SUCCEED;
                goto Ret;
            }
	    }
	    else if (dwFlags & CRYPT_USER_DEFAULT)
	    {
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                            (lstrlenW(szusertypeW) + 5 + 1) * sizeof(WCHAR) )) == NULL)
		    {
			    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			    goto Ret;
		    }

            lstrcpyW(pszValue, szusertypeW);
            __ltoaW(dwProvType, typebuf);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegCreateKeyExW(HKEY_CURRENT_USER,
                            (const WCHAR *) pszValue,
                            0L, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hRegKey, &dwDisp)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }


            // check the delete flag
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if (ERROR_SUCCESS != (err = RegDeleteKeyW(HKEY_CURRENT_USER,
                                                         (const WCHAR *)pszValue)))
                {
                    RegCloseKey(HKEY_CURRENT_USER);
                    SetLastError(err);
                    goto Ret;
                }
                fRet = CRYPT_SUCCEED;
                RegCloseKey(HKEY_CURRENT_USER);
                goto Ret;
            }
            RegCloseKey(HKEY_CURRENT_USER);
	    }

        if (ERROR_SUCCESS != (err = RegSetValueExW(hRegKey, L"Name", 0L, REG_SZ,
                                                  (const LPBYTE) pszProvName, cbValue)))
	    {
		    SetLastError(err);
		    goto Ret;
	    }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

	fRet = CRYPT_SUCCEED;
Ret:
    if (pszFullName)
        LocalFree(pszFullName);
    if (pszValue)
        LocalFree(pszValue);
    if (hRegKey)
        RegCloseKey(hRegKey);
    return fRet;
#else
	return TRUE;
#endif
}

/*
 -      CryptGetDefaultProviderW
 -
 *      Purpose:
 *                Get the default cryptographic provider of the specified
 *                type for either the machine or for the user.
 *
 *
 *      Parameters:
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *                OUT pszProvName    - Name of the default provider
 *                IN OUT pcbProvName - Length in bytes of the provider name
 *                                     including the NULL terminator
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINAPI CryptGetDefaultProviderW(
                                IN DWORD dwProvType,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                OUT LPWSTR pszProvName,
                                IN OUT DWORD *pcbProvName
                                )
{
#ifndef _XBOX
    HKEY        hRegKey = 0;
    LONG        err;
    WCHAR        *pszValue = NULL;
    DWORD       dwValType;
    WCHAR        typebuf[9]; // sfield = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    DWORD       cbProvName = 0;
    BOOL        fRet = CRYPT_FAILED;

    try
    {
        if (dwProvType == 0 || dwProvType > 999 || pdwReserved != NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((dwFlags & ~(CRYPT_MACHINE_DEFAULT | CRYPT_USER_DEFAULT)) ||
            ((dwFlags & CRYPT_MACHINE_DEFAULT) && (dwFlags & CRYPT_USER_DEFAULT)))
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (dwFlags & CRYPT_MACHINE_DEFAULT)
        {
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                            sizeof(szmachinetypeW) + ((5 + 1) * sizeof(WCHAR)))) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            lstrcpyW(pszValue, szmachinetypeW);
            __ltoaW(dwProvType, typebuf);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            (const WCHAR *) pszValue,
                            0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
        }
        else
        {
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                            sizeof(szusertypeW) + ((5 + 1) * sizeof(WCHAR)))) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            lstrcpyW(pszValue, szusertypeW);
            __ltoaW(dwProvType, typebuf);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegOpenKeyExW(HKEY_CURRENT_USER,
                            (const WCHAR *) pszValue,
                            0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            RegCloseKey(HKEY_CURRENT_USER);
        }

        if ((err = RegQueryValueExW(hRegKey, L"Name", 0L, &dwValType,
                        NULL,
                        &cbProvName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pszProvName)
        {
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (cbProvName > *pcbProvName)
        {
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        if ((err = RegQueryValueExW(hRegKey, L"Name", 0L, &dwValType,
                        (BYTE*)pszProvName,
                        &cbProvName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;

Ret:
    *pcbProvName = cbProvName;
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (pszValue)
        LocalFree(pszValue);
    return fRet;
#else
	return TRUE;
#endif
}


/*
 -      CryptEnumProviderTypesW
 -
 *      Purpose:
 *                Enumerate the provider types.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the provider types to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - Pointer to the provider type
 *                OUT pszTypeName    - Name of the enumerated provider type
 *                IN OUT pcbTypeName - Length of the enumerated provider type
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProviderTypesW(
                               IN DWORD dwIndex,
                               IN DWORD *pdwReserved,
                               IN DWORD dwFlags,
                               OUT DWORD *pdwProvType,
                               OUT LPWSTR pszTypeName,
                               IN OUT DWORD *pcbTypeName
                               )
{
#ifndef _XBOX
    HKEY        hRegKey = 0;
    LONG        err;
    WCHAR        *pszRegKeyName = NULL;
    DWORD       cbClass;
    FILETIME    ft;
    WCHAR        rgcType[] = {L'T', L'y', L'p', L'e', L' '};
    LPWSTR       pszValue;
    long        Type;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    BOOL        fRet = CRYPT_FAILED;

    try
    {
        if (0 != dwFlags)
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (NULL != pdwReserved)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL != pcbTypeName)
        {
            *pcbTypeName = 0;   // we never return type names
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                                 (const WCHAR *) szprovidertypesW,
                                                 0L,
                                                 KEY_READ,
                                                 &hRegKey)))
        {
            SetLastError(err);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegQueryInfoKeyW(hRegKey,
                                                    NULL,
                                                    &cbClass,
                                                    NULL,
                                                    &cSubKeys,
                                                    &cbMaxKeyName,
                                                    &cbMaxClass,
                                                    &cValues,
                                                    &cbMaxValName,
                                                    &cbMaxValData,
                                                    NULL,
                                                    &ft)))
        {
            SetLastError(err);
            goto Ret;
        }
        ++cbMaxKeyName;     // allow for trailing NULL
        if (NULL == (pszRegKeyName = LocalAlloc(LMEM_ZEROINIT, cbMaxKeyName*sizeof(WCHAR))))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegEnumKeyExW(hRegKey,
                                                 dwIndex, pszRegKeyName, &cbMaxKeyName, NULL,
                                                 NULL, NULL, &ft)))
        {
            SetLastError(err);
            goto Ret;
        }

        if (memcmp(pszRegKeyName, rgcType, sizeof(rgcType)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        pszValue = pszRegKeyName + sizeof(rgcType)/sizeof(TCHAR);

        if (0 == (Type = StrToLW(pszValue)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        *pdwProvType = (DWORD)Type;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (pszRegKeyName)
        LocalFree(pszRegKeyName);
    return fRet;
#else
	return TRUE;
#endif
}


/*
 -      CryptEnumProvidersW
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProvidersW(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
#ifndef _XBOX
    HKEY        hRegKey = 0;
    HKEY        hProvRegKey = 0;
    LONG        err;
    DWORD       cbClass;
    FILETIME    ft;
    DWORD       dwKeyType;
    DWORD       cbProvType;
    DWORD       dw;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    LPWSTR       pszTmpProvName = NULL;
    DWORD       cbTmpProvName;
    BOOL        fRet = CRYPT_FAILED;

    try
    {
        if (0 != dwFlags)
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                                 (const WCHAR *) szenumprovidersW,
                                                 0L, KEY_READ, &hRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegQueryInfoKeyW(hRegKey,
                                                    NULL,
                                                    &cbClass,
                                                    NULL,
                                                    &cSubKeys,
                                                    &cbMaxKeyName,
                                                    &cbMaxClass,
                                                    &cValues,
                                                    &cbMaxValName,
                                                    &cbMaxValData,
                                                    NULL,
                                                    &ft)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        ++cbMaxKeyName;

        if (NULL == (pszTmpProvName = LocalAlloc(LMEM_ZEROINIT, cbMaxKeyName*sizeof(WCHAR))))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegEnumKeyExW(hRegKey, dwIndex, pszTmpProvName,
                                                 &cbMaxKeyName, NULL,
                                                 NULL, NULL, &ft)))
        {
            SetLastError(err);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyExW(hRegKey,
                                                 (const WCHAR *) pszTmpProvName,
                                                 0L, KEY_READ, &hProvRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        cbProvType = sizeof(dw);
        if (ERROR_SUCCESS != (err = RegQueryValueExW(hProvRegKey,
                                                    (const WCHAR *) L"Type",
                                                    NULL, &dwKeyType, (BYTE*)&dw,
                                                    &cbProvType)))
        {
            SetLastError(err);
            goto Ret;
        }
        *pdwProvType = dw;

        // SFIELD: review if cbProvname should be number of chars rather
        // than bytes.
        cbTmpProvName = (lstrlenW(pszTmpProvName) + 1) * sizeof(WCHAR);

        if (NULL != pszProvName)
        {
            if (*pcbProvName < cbTmpProvName)
            {
                *pcbProvName = cbTmpProvName;
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            lstrcpyW(pszProvName, pszTmpProvName);
        }

        *pcbProvName = cbTmpProvName;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hProvRegKey)
        RegCloseKey(hProvRegKey);
    return fRet;
#else
	return TRUE;
#endif
}

BOOL EnterProviderCritSec(IN PVTableStruc pVTable)
{
    try
    {
        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement(&pVTable->Inuse);

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);
Try_Error_Return:
    return(CRYPT_FAILED);
}


void LeaveProviderCritSec(IN PVTableStruc pVTable)
{
    InterlockedDecrement(&pVTable->Inuse);
}

BOOL EnterKeyCritSec(IN PVKeyStruc pVKey)
{

    try
    {
        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement(&pVKey->Inuse);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);
Try_Error_Return:
    return(CRYPT_FAILED);

}


void LeaveKeyCritSec(IN PVKeyStruc pVKey)
{
    InterlockedDecrement(&pVKey->Inuse);
}

BOOL EnterHashCritSec(IN PVHashStruc pVHash)
{

    try
    {
        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement(&pVHash->Inuse);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);

Try_Error_Return:
    return(CRYPT_FAILED);

}


void LeaveHashCritSec(IN PVHashStruc pVHash)
{
    InterlockedDecrement(&pVHash->Inuse);
}


BOOL BuildVKey(IN PVKeyStruc *ppVKey,
               IN PVTableStruc pVTable)
{
    DWORD           bufsize;
    PVKeyStruc pVKey;

    bufsize = sizeof(VKeyStruc);

    if ((pVKey = (PVKeyStruc) LocalAlloc(LMEM_ZEROINIT,
                                         (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    pVKey->FuncGenKey = pVTable->FuncGenKey;
    pVKey->FuncDeriveKey = pVTable->FuncDeriveKey;
    pVKey->FuncDestroyKey = pVTable->FuncDestroyKey;
    pVKey->FuncSetKeyParam = pVTable->FuncSetKeyParam;
    pVKey->FuncGetKeyParam = pVTable->FuncGetKeyParam;
    pVKey->FuncExportKey = pVTable->FuncExportKey;
    pVKey->FuncImportKey = pVTable->FuncImportKey;
    pVKey->FuncEncrypt = pVTable->FuncEncrypt;
    pVKey->FuncDecrypt = pVTable->FuncDecrypt;

    pVKey->OptionalFuncDuplicateKey = pVTable->OptionalFuncDuplicateKey;

    pVKey->hProv = pVTable->hProv;

    *ppVKey = pVKey;

    return(CRYPT_SUCCEED);
}

BOOL BuildVHash(
                IN PVHashStruc *ppVHash,
                IN PVTableStruc pVTable
                )
{
    DWORD           bufsize;
    PVHashStruc     pVHash;


    bufsize = sizeof(VHashStruc);

    if ((pVHash = (PVHashStruc) LocalAlloc(LMEM_ZEROINIT, (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    pVHash->FuncCreateHash = pVTable->FuncCreateHash;
    pVHash->FuncHashData = pVTable->FuncHashData;
    pVHash->FuncHashSessionKey = pVTable->FuncHashSessionKey;
    pVHash->FuncDestroyHash = pVTable->FuncDestroyHash;
    pVHash->FuncSignHash = pVTable->FuncSignHash;
    pVHash->FuncVerifySignature = pVTable->FuncVerifySignature;
    pVHash->FuncGetHashParam = pVTable->FuncGetHashParam;
    pVHash->FuncSetHashParam = pVTable->FuncSetHashParam;

    pVHash->OptionalFuncDuplicateHash = pVTable->OptionalFuncDuplicateHash;

    pVHash->hProv = (HCRYPTPROV)pVTable;

    *ppVHash = pVHash;

    return(CRYPT_SUCCEED);
}

void EncryptKey(BYTE *pdata, DWORD size, BYTE val)
{
    RC4_KEYSTRUCT key;
    BYTE          RealKey[RC4_KEYSIZE] = {0xa2, 0x17, 0x9c, 0x98, 0xca};
    DWORD         index;

    for (index = 0; index < RC4_KEYSIZE; index++)
    {
        RealKey[index] = RealKey[index] ^ val;
    }

    rc4_key(&key, RC4_KEYSIZE, RealKey);

    rc4(&key, size, pdata);

}

void MD5HashData(
                 BYTE *pb,
                 DWORD cb,
                 BYTE *pbHash
                 )
{
    MD5_CTX     HashState;

    MD5Init(&HashState);

    try
    {
        MD5Update(&HashState, pb, cb);
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        return;
    }

    // Finish the hash
    MD5Final(&HashState);

    memcpy(pbHash, HashState.digest, 16);
}


BOOL CheckSignature(
                    BYTE *pbKey,
                    DWORD cbKey,
                    BYTE *pbSig,
                    DWORD cbSig,
                    BYTE *pbHash,
                    BOOL fUnknownLen)
{
    BYTE                rgbResult[KEYSIZE1024];
    BYTE                rgbSig[KEYSIZE1024];
    BYTE                rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE                rgbKeyHash[16];
    BYTE                *pbSecondKey;
    DWORD               cbSecondKey;
    BYTE                *pbKeySig;
    PSECOND_TIER_SIG    pSecondTierSig;
    LPBSAFE_PUB_KEY     pTmp;
    BOOL                fRet = FALSE;

    memset(rgbResult, 0, KEYSIZE1024);
    memset(rgbSig, 0, KEYSIZE1024);

    // just check the straight signature if version is 1
    pTmp = (LPBSAFE_PUB_KEY)pbKey;

    // check if sig length is the same as the key length
    if (fUnknownLen || (cbSig == pTmp->keylen))
    {
        memcpy(rgbSig, pbSig, pTmp->keylen);
        BSafeEncPublic(pTmp, rgbSig, rgbResult);

        if (RtlEqualMemory(pbHash, rgbResult, 16) &&
            rgbResult[cbKey-1] == 0 &&
            rgbResult[cbKey-2] == 1 &&
            rgbResult[16] == 0)
        {
            fRet = TRUE;
            goto Ret;
        }
    }

    // check the the second tier signature if the magic equals 2
    pSecondTierSig = (PSECOND_TIER_SIG)pbSig;
    if (0x00000002 != pSecondTierSig->dwMagic)
        goto Ret;

    if (0x31415352 != pSecondTierSig->Pub.magic)
        goto Ret;

    // assign the pointers
    cbSecondKey = sizeof(BSAFE_PUB_KEY) + pSecondTierSig->Pub.keylen;
    pbSecondKey = pbSig + (sizeof(SECOND_TIER_SIG) - sizeof(BSAFE_PUB_KEY));
    pbKeySig = pbSecondKey + cbSecondKey;

    // hash the second tier key
    MD5HashData(pbSecondKey, cbSecondKey, rgbKeyHash);

    // Decrypt the signature data on the second tier key
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memcpy(rgbSig, pbKeySig, pSecondTierSig->cbSig);
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if ((FALSE == RtlEqualMemory(rgbKeyHash, rgbResult, 16)) ||
        rgbResult[cbKey-1] != 0 ||
        rgbResult[cbKey-2] != 1 ||
        rgbResult[16] != 0)
    {
        goto Ret;
    }

    // Decrypt the signature data on the CSP
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memset(rgbKey, 0, sizeof(rgbKey));
    memcpy(rgbSig, pbKeySig + pSecondTierSig->cbSig, pSecondTierSig->cbSig);
    memcpy(rgbKey, pbSecondKey, cbSecondKey);
    pTmp = (LPBSAFE_PUB_KEY)rgbKey;
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if (RtlEqualMemory(pbHash, rgbResult, 16) &&
        rgbResult[pTmp->keylen-1] == 0 &&
        rgbResult[pTmp->keylen-2] == 1 &&
        rgbResult[16] == 0)
    {
        fRet = TRUE;
    }
Ret:
    return fRet;
}

/*
 -      NewVerifyImage
 -
 *      Purpose:
 *                Check signature of file
 *
 *
 *      Parameters:
 *                IN lpszImage      - address of file
 *                IN pSigData       - address of signature data
 *                IN cbSig          - length of signature data
 *                IN fUnknownLen    - BOOL to tell if length is not passed in
 *
 *      Returns:
 *                BOOL
 */
BOOL NewVerifyImage(LPCWSTR lpszImage,
		            BYTE *pSigData,
                    DWORD cbSig,
                    BOOL fUnknownLen)
{
#ifndef _XBOX

    HANDLE      hFileProv = INVALID_HANDLE_VALUE;
    DWORD       NumBytes;
    DWORD       lpdwFileSizeHigh;
    LPVOID      lpvAddress = NULL;
    DWORD       NumBytesRead;
    BYTE        rgbHash[16];
    BYTE        rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE        rgbKey2[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#ifdef MS_INTERNAL_KEY
    BYTE        rgbMSKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#endif

#ifdef TEST_BUILD_EXPONENT
    BYTE        rgbTestKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE512];
#endif

    BOOL        fRet = CRYPT_FAILED;

    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFileW(
    			lpszImage,
    			GENERIC_READ,
    			FILE_SHARE_READ,
    			NULL,
    			OPEN_EXISTING,
    			0,
    			NULL)))
    {
        SetLastError((DWORD) NTE_PROV_DLL_NOT_FOUND);
        goto Ret;
    }

    if (0xffffffff == (NumBytes = GetFileSize(hFileProv,
                                              &lpdwFileSizeHigh)))
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        goto Ret;
    }

    if (NULL == (lpvAddress = VirtualAlloc(NULL, NumBytes, MEM_RESERVE | MEM_COMMIT,
                                           PAGE_READWRITE)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (!ReadFile((HANDLE) hFileProv, lpvAddress, NumBytes, &NumBytesRead, 0))
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        goto Ret;
    }

    MD5HashData(lpvAddress, NumBytes, rgbHash);

    // decrypt the keys once for each process
    memcpy(rgbKey, (BYTE*)&KEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 0);

#ifdef MS_INTERNAL_KEY
    memcpy(rgbMSKey, (BYTE*)&MSKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbMSKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 1);
#endif
    memcpy(rgbKey2, (BYTE*)&KEY2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 2);

#ifdef TEST_BUILD_EXPONENT
    memcpy(rgbTestKey, (BYTE*)&TESTKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE512);
    EncryptKey(rgbTestKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE512, 3);
#endif // TEST_BUILD_EXPONENT

    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbKey, 128, pSigData,
                                                cbSig, rgbHash, fUnknownLen)))
        goto Ret;

#ifdef MS_INTERNAL_KEY
    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbMSKey, 128, pSigData,
                                                cbSig, rgbHash, fUnknownLen)))
        goto Ret;
#endif

    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbKey2, 128, pSigData,
                                                cbSig, rgbHash, fUnknownLen)))
        goto Ret;

#ifdef TEST_BUILD_EXPONENT
    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbTestKey, 64, pSigData,
                                                cbSig, rgbHash, fUnknownLen)))
        goto Ret;
#endif // TEST_BUILD_EXPONENT

    SetLastError((DWORD) NTE_BAD_SIGNATURE);
Ret:
    if (NULL != lpvAddress)
        VirtualFree(lpvAddress, 0, MEM_RELEASE);
    if (INVALID_HANDLE_VALUE != hFileProv)
        CloseHandle(hFileProv);

    return fRet;
#else
	ASSERT(!"cryptapi.c called");
	return TRUE;
#endif
}

/*
 -      CProvVerifyImage
 -
 *      Purpose:
 *                Check signature of file
 *
 *
 *      Parameters:
 *                IN lpszImage      - address of file
 *                IN lpSigData      - address of signature data
 *
 *      Returns:
 *                BOOL
 */
BOOL CProvVerifyImage(LPCWSTR lpszImage,
		              BYTE *pSigData)
{
    return NewVerifyImage(lpszImage, pSigData, 0, TRUE);
}


/*
 -      CPReturnhWnd
 -
 *      Purpose:
 *                Return a window handle back to a CSP
 *
 *
 *      Parameters:
 *                OUT phWnd      - pointer to a hWnd to return
 *
 *      Returns:
 *                BOOL
 */
BOOL CPReturnhWnd(DWORD *phWnd)
{
    try
    {

        *phWnd = hWnd;

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);

Try_Error_Return:
    return(CRYPT_FAILED);

}

static void __ltoaW(DWORD val, WCHAR *buf)
{
    WCHAR *p;            /* pointer to traverse string */
    WCHAR *firstdig;     /* pointer to first digit */
    WCHAR temp;          /* temp char */
    unsigned digval;    /* value of digit */
    int  i;

    p = buf;

    firstdig = p;       /* save pointer to first digit */

    for (i = 0; i < 8; i++) {
        digval = (unsigned) (val % 10);
        val /= 10;      /* get next digit */

        /* convert to ascii and store */
        *p++ = (WCHAR) (digval + L'0');    /* a digit */
    }

    /* We now have the digit of the number in the buffer, but in reverse
       order.  Thus we reverse them now. */

    *p-- = L'\0';                /* terminate string; p points to last digit */

    do {
        temp = *p;
        *p = *firstdig;
        *firstdig = temp;       /* swap *p and *firstdig */
        --p;
        ++firstdig;             /* advance to next two digits */
    } while (firstdig < p); /* repeat until halfway */
}

#define FRENCHCHECKKEY  L"Comm\\Security\\Crypto\\Defaults\\CheckInfo"
#define FRENCHCHECKVALUE  L"Mask"

#define DH_PROV_ENABLED     1
#define RSA_PROV_ENABLED    2
#define DH_SCH_ENABLED      4
#define RSA_SCH_ENABLED     8

BOOL WINAPI
IsEncryptionPermitted(
                           IN DWORD dwProvType
                           )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
#define NO_FRANCE_CHECK // encryption permitted in France as of 2/4/2000
#ifndef NO_FRANCE_CHECK
    LCID    DefaultLcid;
    WCHAR CountryCode[10];
    LPCWSTR CountryFrance = L"33"; // CTRY_FRANCE converted to Unicode string
    HKEY    hKey = 0;
    DWORD   cb = sizeof(DWORD);
    DWORD   dw = 0;
    DWORD   dwType;
    BOOL    fRet = FALSE;

    //*pfInFrance = FALSE;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    // or if the users's country is set to FRANCE
    //

    if (GetLocaleInfoW(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0)
    {
        goto Ret;
    }
    if ((memcmp(CountryCode, CountryFrance, sizeof(CountryFrance)) == 0)
        || (LANGIDFROMLCID(DefaultLcid) == 0x40c))
    {
        // this is a check to see if a registry key to enable encryption is
        // available, do not remove, use or publicize this check without
        // thorough discussions with Microsoft Legal handling French Import
        // issues (tomalb and/or irar)
	    if (ERROR_SUCCESS != RegOpenKeyExW(HKEY_LOCAL_MACHINE,
		                                  FRENCHCHECKKEY,
		                                  0,		// dwOptions
		                                  KEY_READ,
		                                  &hKey))
        {
            hKey = 0;
            goto Ret;
        }

        // get the mask value from the registry indicating which crypto
        // services are to be allowed
	    if (ERROR_SUCCESS != RegQueryValueExW(hKey,
		                                  FRENCHCHECKVALUE,
		                                  NULL, &dwType,		// dwOptions
		                                  (BYTE*)&dw,
		                                  &cb))
        {
            goto Ret;
        }

        switch(dwProvType)
        {
            case PROV_RSA_FULL:
            case PROV_RSA_SIG:
            {
                if (dw & RSA_PROV_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

            case PROV_RSA_SCHANNEL:
            {
                if (dw & RSA_SCH_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

            case PROV_DSS:
            case PROV_DSS_DH:
            {
                if (dw & DH_PROV_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

#ifdef PROV_DH_SCHANNEL
            case PROV_DH_SCHANNEL:
            {
                if (dw & DH_SCH_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }
#endif
            default:
                goto Ret;
        }
    }
    else
    {
        fRet = TRUE;
    }
Ret:
    if (hKey)
        RegCloseKey(hKey);
    return fRet;
#else
    //*pfInFrance = FALSE;
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\chain\ssctl.cpp ===
/+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ssctl.cpp
//
//  Contents:   Self Signed Certificate Trust List Subsystem used by the
//              Certificate Chaining Infrastructure for building complex
//              chains
//
//  History:    11-Feb-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CSSCtlObject, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSSCtlObject::CSSCtlObject (
                    IN PCCERTCHAINENGINE pChainEngine,
                    IN PCCTL_CONTEXT pCtlContext,
                    OUT BOOL& rfResult
                    )
{
    DWORD           cbData = MD5DIGESTLEN;
    CRYPT_DATA_BLOB DataBlob;

    rfResult = TRUE;

    m_cRefs = 1;
    m_pCtlContext = CertDuplicateCTLContext( pCtlContext );
    m_fHasSignatureBeenVerified = FALSE;
    m_fSignatureValid = FALSE;
    m_hMessageStore = NULL;
    m_hHashEntry = NULL;
    m_pChainEngine = pChainEngine;

    memset( &m_SignerInfo, 0, sizeof( m_SignerInfo ) );

    rfResult = CertGetCTLContextProperty(
                   pCtlContext,
                   CERT_MD5_HASH_PROP_ID,
                   m_CtlHash,
                   &cbData
                   );

    if ( rfResult == TRUE )
    {
        DataBlob.cbData = CtlHashSize();
        DataBlob.pbData = CtlHash();

        rfResult = I_CryptCreateLruEntry(
                          pChainEngine->SSCtlObjectCache()->HashIndex(),
                          &DataBlob,
                          this,
                          &m_hHashEntry
                          );
    }

    if ( rfResult == TRUE )
    {
        m_hMessageStore = CertOpenStore(
                              CERT_STORE_PROV_MSG,
                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              NULL,
                              0,
                              pCtlContext->hCryptMsg
                              );

        if ( m_hMessageStore != NULL )
        {
            rfResult = CertAddStoreToCollection(
                           pChainEngine->OtherStore(),
                           m_hMessageStore,
                           0,
                           0
                           );
        }
        else
        {
            rfResult = FALSE;
        }
    }

    if ( rfResult == TRUE )
    {
        rfResult = SSCtlGetSignerInfo( pCtlContext, &m_SignerInfo );
    }

    assert( m_pChainEngine != NULL );
    assert( m_pCtlContext != NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::~CSSCtlObject, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSSCtlObject::~CSSCtlObject ()
{
    SSCtlFreeSignerInfo( &m_SignerInfo );

    if ( m_hMessageStore != NULL )
    {
        CertRemoveStoreFromCollection(
            m_pChainEngine->OtherStore(),
            m_hMessageStore
            );

        CertCloseStore( m_hMessageStore, 0 );
    }

    if ( m_hHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hHashEntry );
    }

    CertFreeCTLContext( m_pCtlContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::GetSigner, public
//
//  Synopsis:   get the certificate object of the signer
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObject::GetSigner (
                 IN PCCERTOBJECT pSubject,
                 IN PCCHAINCALLCONTEXT pCallContext,
                 IN HCERTSTORE hAdditionalStore,
                 OUT PCCERTOBJECT* ppSigner,
                 OUT BOOL* pfAdditionalStoreSigner,
                 OUT BOOL* pfCtlSignatureValid
                 )
{
    BOOL         fResult;
    PCCERTOBJECT pSigner = NULL;

    assert( m_pChainEngine == pSubject->ChainEngine() );

    fResult = SSCtlGetSignerCertificateObject(
                   m_pChainEngine,
                   pSubject,
                   pCallContext,
                   &m_SignerInfo,
                   hAdditionalStore,
                   &pSigner,
                   pfAdditionalStoreSigner
                   );

    if ( fResult == TRUE )
    {
        if ( m_fHasSignatureBeenVerified == FALSE )
        {
#ifdef CMS_PKCS7
            CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

            memset(&CtrlPara, 0, sizeof(CtrlPara));
            CtrlPara.cbSize = sizeof(CtrlPara);
            // CtrlPara.hCryptProv =

            // BUGBUG this needs to be updated when chain building
            // supports CTLs with more than one signer.
            CtrlPara.dwSignerIndex = 0;
            CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
            CtrlPara.pvSigner = (void *) pSigner->CertContext();

            m_fSignatureValid = CryptMsgControl(
                                     m_pCtlContext->hCryptMsg,
                                     0,
                                     CMSG_CTRL_VERIFY_SIGNATURE_EX,
                                     &CtrlPara
                                     );
#else
            m_fSignatureValid = CryptMsgControl(
                                     m_pCtlContext->hCryptMsg,
                                     0,
                                     CMSG_CTRL_VERIFY_SIGNATURE,
                                     pSigner->CertContext()->pCertInfo
                                     );
#endif  // CMS_PKCS7

            m_fHasSignatureBeenVerified = TRUE;
        }

        *ppSigner = pSigner;
        *pfCtlSignatureValid = m_fSignatureValid;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::GetTrustListInfo, public
//
//  Synopsis:   get the trust list information relative to a particular cert
//              object
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObject::GetTrustListInfo (
                 IN PCCERTOBJECT pCertObject,
                 OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
                 )
{
    PCTL_ENTRY            pCtlEntry;
    PCERT_TRUST_LIST_INFO pTrustListInfo;

    pCtlEntry = CertFindSubjectInCTL(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CTL_CERT_SUBJECT_TYPE,
                    (LPVOID)pCertObject->CertContext(),
                    m_pCtlContext,
                    0
                    );

    if ( pCtlEntry == NULL )
    {
        SetLastError( CRYPT_E_NOT_FOUND );
        return( FALSE );
    }

    pTrustListInfo = new CERT_TRUST_LIST_INFO;
    if ( pTrustListInfo == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    pTrustListInfo->cbSize = sizeof( CERT_TRUST_LIST_INFO );
    pTrustListInfo->pCtlEntry = pCtlEntry;
    pTrustListInfo->pCtlContext = CertDuplicateCTLContext( m_pCtlContext );

    *ppTrustListInfo = pTrustListInfo;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CalculateStatus, public
//
//  Synopsis:   calculate the status
//
//----------------------------------------------------------------------------
VOID
CSSCtlObject::CalculateStatus (
                       IN LPFILETIME pTime,
                       IN PCERT_USAGE_MATCH pRequestedUsage,
                       IN DWORD dwFlags,
                       OUT PCERT_TRUST_STATUS pStatus
                       )
{
    assert( m_fHasSignatureBeenVerified == TRUE );

    SSCtlGetCtlTrustStatus(
         m_pCtlContext,
         m_fSignatureValid,
         pTime,
         pRequestedUsage,
         dwFlags,
         pStatus
         );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::GetSignerRequestedUsage, public
//
//  Synopsis:   get the signer requested usage and time
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObject::GetSignerRequestedUsageAndTime (
                 IN LPFILETIME pCurrentTime,
                 OUT PCERT_USAGE_MATCH pSignerRequestedUsage,
                 OUT LPFILETIME pSignerRequestedTime
                 )
{
    LPSTR            pszUsage = szOID_KP_CTL_USAGE_SIGNING;
    CERT_USAGE_MATCH SignerRequestedUsage;

    *pSignerRequestedTime = *pCurrentTime;

    memset( &SignerRequestedUsage, 0, sizeof( SignerRequestedUsage ) );

    SignerRequestedUsage.Usage.cUsageIdentifier = 1;
    SignerRequestedUsage.Usage.rgpszUsageIdentifier = &pszUsage;

    return( ChainCopyRequestedUsage(
                 &SignerRequestedUsage,
                 pSignerRequestedUsage
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::CSSCtlObjectCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSSCtlObjectCache::CSSCtlObjectCache (
                         OUT BOOL& rfResult
                         )
{
    LRU_CACHE_CONFIG Config;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.pfnHash = CertObjectCacheHashMd5Identifier;
    Config.cBuckets = DEFAULT_CERT_OBJECT_CACHE_BUCKETS;
    Config.pfnOnRemoval = SSCtlOnRemovalFromCache;

    m_hHashIndex = NULL;

    rfResult = I_CryptCreateLruCache( &Config, &m_hHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::~CSSCtlObjectCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSSCtlObjectCache::~CSSCtlObjectCache ()
{
    I_CryptFreeLruCache( m_hHashIndex, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::PopulateCache, public
//
//  Synopsis:   populate the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::PopulateCache (
                           IN PCCERTCHAINENGINE pChainEngine
                           )
{
    assert( pChainEngine->SSCtlObjectCache() == this );

    return( SSCtlPopulateCacheFromCertStore( pChainEngine, NULL ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::AddObject, public
//
//  Synopsis:   add an object to the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::AddObject (
                      IN PCSSCTLOBJECT pSSCtlObject,
                      IN BOOL fCheckForDuplicate
                      )
{
    if ( fCheckForDuplicate == TRUE )
    {
        CRYPT_HASH_BLOB HashBlob;
        PCSSCTLOBJECT   pDuplicate;

        HashBlob.cbData = pSSCtlObject->CtlHashSize();
        HashBlob.pbData = pSSCtlObject->CtlHash();

        pDuplicate = FindObjectByHash( &HashBlob );
        if ( pDuplicate != NULL )
        {
            pDuplicate->Release();
            SetLastError( CRYPT_E_EXISTS );
            return( FALSE );
        }
    }

    pSSCtlObject->AddRef();

    I_CryptInsertLruEntry( pSSCtlObject->HashIndexEntry(), NULL );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::RemoveObject, public
//
//  Synopsis:   remove object from cache
//
//----------------------------------------------------------------------------
VOID
CSSCtlObjectCache::RemoveObject (
                         IN PCSSCTLOBJECT pSSCtlObject
                         )
{
    I_CryptRemoveLruEntry( pSSCtlObject->HashIndexEntry(), 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::FindObjectByHash, public
//
//  Synopsis:   find object with given hash
//
//----------------------------------------------------------------------------
PCSSCTLOBJECT
CSSCtlObjectCache::FindObjectByHash (
                       IN PCRYPT_HASH_BLOB pHashBlob
                       )
{
    HLRUENTRY     hFound;
    PCSSCTLOBJECT pFound = NULL;

    hFound = I_CryptFindLruEntry( m_hHashIndex, (PCRYPT_DATA_BLOB)pHashBlob );
    if ( hFound != NULL )
    {
        pFound = (PCSSCTLOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::EnumObjects, public
//
//  Synopsis:   enumerate objects
//
//----------------------------------------------------------------------------
VOID
CSSCtlObjectCache::EnumObjects (
                       IN PFN_ENUM_SSCTLOBJECTS pfnEnum,
                       IN LPVOID pvParameter
                       )
{
    SSCTL_ENUM_OBJECTS_DATA EnumData;

    EnumData.pfnEnumObjects = pfnEnum;
    EnumData.pvEnumParameter = pvParameter;

    I_CryptWalkAllLruCacheEntries(
           m_hHashIndex,
           SSCtlEnumObjectsWalkFn,
           &EnumData
           );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::Resync, public
//
//  Synopsis:   resync the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::Resync (IN PCCERTCHAINENGINE pChainEngine)
{
    I_CryptFlushLruCache( m_hHashIndex, 0, NULL );

    return( PopulateCache( pChainEngine ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlOnRemovalFromCache
//
//  Synopsis:   SS CTL removal notification used when the cache is destroyed
//              or an object is explicitly removed.  Note that this cache
//              does not LRU remove objects
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlOnRemovalFromCache (
     IN LPVOID pv,
     IN OPTIONAL LPVOID pvRemovalContext
     )
{
    assert( pvRemovalContext == NULL );

    ( (PCSSCTLOBJECT)pv )->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetSignerInfo
//
//  Synopsis:   get the signer info
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlGetSignerInfo (
     IN PCCTL_CONTEXT pCtlContext,
     OUT PSSCTL_SIGNER_INFO pSignerInfo
     )
{
    BOOL              fResult;
    PCMSG_SIGNER_INFO pMessageSignerInfo = NULL;
    DWORD             cbData = 0;

    fResult = CryptMsgGetParam(
                   pCtlContext->hCryptMsg,
                   CMSG_SIGNER_INFO_PARAM,
                   0,
                   NULL,
                   &cbData
                   );

    if ( fResult == TRUE )
    {
        pMessageSignerInfo = (PCMSG_SIGNER_INFO)new BYTE [ cbData ];
        if ( pMessageSignerInfo != NULL )
        {
            fResult = CryptMsgGetParam(
                           pCtlContext->hCryptMsg,
                           CMSG_SIGNER_INFO_PARAM,
                           0,
                           pMessageSignerInfo,
                           &cbData
                           );
        }
        else
        {
            SetLastError( E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        pSignerInfo->pMessageSignerInfo = pMessageSignerInfo;
        pSignerInfo->fSignerHashAvailable = FALSE;
        pSignerInfo->SignerCertificateHashSize = MD5DIGESTLEN;

        ChainCreateCertificateObjectIdentifier(
             &pMessageSignerInfo->Issuer,
             &pMessageSignerInfo->SerialNumber,
             pSignerInfo->SignerCertObjectIdentifier
             );
    }
    else
    {
        delete pMessageSignerInfo;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeSignerInfo
//
//  Synopsis:   free the data in the signer info
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeSignerInfo (
     IN PSSCTL_SIGNER_INFO pSignerInfo
     )
{
    delete (LPBYTE)pSignerInfo->pMessageSignerInfo;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetSignerCertificateObject
//
//  Synopsis:   get the signer certificate object
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlGetSignerCertificateObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCERTOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PSSCTL_SIGNER_INFO pSignerInfo,
     IN HCERTSTORE hAdditionalStore,
     OUT PCCERTOBJECT* ppCertObject,
     OUT BOOL* pfAdditionalStoreSigner
     )
{
    BOOL              fResult = TRUE;
    PCCERTOBJECT      pCertObject;
    PCCERTOBJECTCACHE pCertObjectCache;
    PCCERT_CONTEXT    pCertContext = NULL;
    CRYPT_HASH_BLOB   HashBlob;
    BOOL              fAdditionalStoreUsed = FALSE;
    DWORD             cbData = pSignerInfo->SignerCertificateHashSize;
    BYTE              CertificateHash[ MD5DIGESTLEN ];
    BOOL              fFromCallCreationCache = FALSE;

    assert( pSignerInfo->SignerCertificateHashSize == MD5DIGESTLEN );

    pCertObjectCache = pChainEngine->CertObjectCache();

    if ( pSignerInfo->fSignerHashAvailable == TRUE )
    {
        HashBlob.cbData = MD5DIGESTLEN;
        HashBlob.pbData = pSignerInfo->SignerCertificateHash;

        pCertObject = pCertObjectCache->FindObjectByHash( &HashBlob );
    }
    else
    {
        pCertObject = pCertObjectCache->FindObjectByIdentifier(
                                            pSignerInfo->SignerCertObjectIdentifier
                                            );
    }

    if ( pCertObject == NULL )
    {
        if ( pSignerInfo->fSignerHashAvailable == TRUE )
        {
            pCertContext = SSCtlFindCertificateInStoreByHash(
                                pChainEngine->OtherStore(),
                                &HashBlob
                                );

            if ( ( pCertContext == NULL ) && ( hAdditionalStore != NULL ) )
            {
                fAdditionalStoreUsed = TRUE;

                pCertContext = SSCtlFindCertificateInStoreByHash(
                                    hAdditionalStore,
                                    &HashBlob
                                    );
            }
        }

        if ( pCertContext == NULL )
        {
            fAdditionalStoreUsed = FALSE;

            pCertContext = SSCtlFindCertificateInStoreByIssuerAndSerialNumber(
                                pChainEngine->OtherStore(),
                                NULL,
                                &pSignerInfo->pMessageSignerInfo->Issuer,
                                &pSignerInfo->pMessageSignerInfo->SerialNumber
                                );
        }

        if ( ( pCertContext == NULL ) && ( hAdditionalStore != NULL ) )
        {
            fAdditionalStoreUsed = TRUE;

            pCertContext = SSCtlFindCertificateInStoreByIssuerAndSerialNumber(
                                hAdditionalStore,
                                NULL,
                                &pSignerInfo->pMessageSignerInfo->Issuer,
                                &pSignerInfo->pMessageSignerInfo->SerialNumber
                                );
        }

        if ( pCertContext != NULL )
        {
            fResult = CertGetCertificateContextProperty(
                          pCertContext,
                          CERT_MD5_HASH_PROP_ID,
                          CertificateHash,
                          &cbData
                          );

            if ( fResult == TRUE )
            {
                HashBlob.cbData = cbData;
                HashBlob.pbData = CertificateHash;

                fResult = ChainCreateCertificateObject(
                               pChainEngine,
                               pCallContext,
                               pCertContext,
                               &HashBlob,
                               NULL,
                               hAdditionalStore,
                               &pCertObject,
                               &fFromCallCreationCache
                               );
            }

            CertFreeCertificateContext( pCertContext );
        }
        else
        {
            fResult = FALSE;
        }

        if ( ( fResult == TRUE ) && ( fAdditionalStoreUsed == FALSE ) &&
             ( pCertObject != NULL ) )
        {
            fResult = ChainCacheEndCertificate( pCallContext, pCertObject );
        }
    }

    if ( fResult == TRUE )
    {
        if ( pSignerInfo->fSignerHashAvailable == FALSE )
        {
            memcpy(
               pSignerInfo->SignerCertificateHash,
               CertificateHash,
               pSignerInfo->SignerCertificateHashSize
               );

            pSignerInfo->fSignerHashAvailable = TRUE;
        }

        *ppCertObject = pCertObject;
        *pfAdditionalStoreSigner = fAdditionalStoreUsed;
    }
    else if ( pCertObject != NULL )
    {
        pCertObject->Release();
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFindCertificateInStoreByIssuerAndSerialNumber
//
//  Synopsis:   find certificate in store given the issuer and serial number
//
//----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI
SSCtlFindCertificateInStoreByIssuerAndSerialNumber (
     IN HCERTSTORE hStore,
     IN PCCERT_CONTEXT pCertContext,
     IN PCERT_NAME_BLOB pIssuer,
     IN PCRYPT_INTEGER_BLOB pSerialNumber
     )
{
    while ( ( pCertContext = CertFindCertificateInStore(
                                 hStore,
                                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                 0,
                                 CERT_FIND_ISSUER_NAME,
                                 pIssuer,
                                 pCertContext
                                 ) ) != NULL )
    {
        if ( ( pCertContext->pCertInfo->SerialNumber.cbData ==
               pSerialNumber->cbData ) &&
             ( memcmp(
                  pCertContext->pCertInfo->SerialNumber.pbData,
                  pSerialNumber->pbData,
                  pCertContext->pCertInfo->SerialNumber.cbData
                  ) == 0 ) )
        {
            break;
        }
    }

    return( pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFindCertificateInStoreByHash
//
//  Synopsis:   find certificate in store by hash
//
//----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI
SSCtlFindCertificateInStoreByHash (
     IN HCERTSTORE hStore,
     IN PCRYPT_HASH_BLOB pHashBlob
     )
{
    return( CertFindCertificateInStore(
                hStore,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                0,
                CERT_FIND_MD5_HASH,
                pHashBlob,
                NULL
                ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetCtlTrustStatus
//
//  Synopsis:   get the trust status for the CTL
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlGetCtlTrustStatus (
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fSignatureValid,
     IN LPFILETIME pTime,
     IN PCERT_USAGE_MATCH pRequestedUsage,
     IN DWORD dwFlags,
     OUT PCERT_TRUST_STATUS pStatus
     )
{
    FILETIME          NoTime;
    CERT_TRUST_STATUS UsageStatus;

    memset( pStatus, 0, sizeof( CERT_TRUST_STATUS ) );
    memset( &NoTime, 0, sizeof( NoTime ) );

    if ( fSignatureValid == FALSE )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
    }

    if ( ( CompareFileTime(
                  pTime,
                  &pCtlContext->pCtlInfo->ThisUpdate
                  ) < 0 ) ||
         ( ( ( CompareFileTime(
                      &NoTime,
                      &pCtlContext->pCtlInfo->NextUpdate
                      ) != 0 ) &&
             ( CompareFileTime(
                      pTime,
                      &pCtlContext->pCtlInfo->NextUpdate
                      ) > 0 ) ) ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_TIME_VALID;
    }

    ChainGetUsageStatus(
         (PCERT_ENHKEY_USAGE)&pRequestedUsage->Usage,
         (PCERT_ENHKEY_USAGE)&pCtlContext->pCtlInfo->SubjectUsage,
         pRequestedUsage->dwType,
         &UsageStatus
         );

    if ( UsageStatus.dwErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlPopulateCacheFromCertStore
//
//  Synopsis:   populate the SS CTL object cache from certificate store CTLs
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlPopulateCacheFromCertStore (
     IN PCCERTCHAINENGINE pChainEngine,
     IN OPTIONAL HCERTSTORE hStore
     )
{
    BOOL               fResult;
    BOOL               fAdditionalStore = TRUE;
    PCCTL_CONTEXT      pCtlContext = NULL;
    DWORD              cbData = MD5DIGESTLEN;
    BYTE               CtlHash[ MD5DIGESTLEN ];
    CRYPT_HASH_BLOB    HashBlob;
    PCSSCTLOBJECT      pSSCtlObject;
    PCSSCTLOBJECTCACHE pSSCtlObjectCache;

    pSSCtlObjectCache = pChainEngine->SSCtlObjectCache();

    if ( hStore == NULL )
    {
        hStore = pChainEngine->TrustStore();
        fAdditionalStore = FALSE;
    }

    while ( ( pCtlContext = CertEnumCTLsInStore(
                                hStore,
                                pCtlContext
                                ) ) != NULL )
    {
        fResult = CertGetCTLContextProperty(
                      pCtlContext,
                      CERT_MD5_HASH_PROP_ID,
                      CtlHash,
                      &cbData
                      );

        if ( fResult == TRUE )
        {
            HashBlob.cbData = cbData;
            HashBlob.pbData = CtlHash;

            pSSCtlObject = pSSCtlObjectCache->FindObjectByHash( &HashBlob );
            if ( pSSCtlObject == NULL )
            {
                fResult = SSCtlCreateCtlObject(
                               pChainEngine,
                               pCtlContext,
                               &pSSCtlObject
                               );
            }
            else
            {
                pSSCtlObject->Release();
                fResult = FALSE;
            }

            if ( fResult == TRUE )
            {
                fResult = pSSCtlObjectCache->AddObject( pSSCtlObject, FALSE );

                // NOTE: Since fDuplicate == FALSE this should never fail
                assert( fResult == TRUE );

                pSSCtlObject->Release();
            }
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlCreateCtlObject
//
//  Synopsis:   create an SS CTL Object
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlCreateCtlObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCTL_CONTEXT pCtlContext,
     OUT PCSSCTLOBJECT* ppSSCtlObject
     )
{
    BOOL          fResult = TRUE;
    PCSSCTLOBJECT pSSCtlObject;

    pSSCtlObject = new CSSCtlObject( pChainEngine, pCtlContext, fResult );
    if ( pSSCtlObject == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        fResult = FALSE;
    }
    else if ( fResult == TRUE )
    {
        *ppSSCtlObject = pSSCtlObject;
    }
    else
    {
        delete pSSCtlObject;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlEnumObjectsWalkFn
//
//  Synopsis:   object enumerator walk function
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlEnumObjectsWalkFn (
     IN LPVOID pvParameter,
     IN HLRUENTRY hEntry
     )
{
    PSSCTL_ENUM_OBJECTS_DATA pEnumData = (PSSCTL_ENUM_OBJECTS_DATA)pvParameter;

    return( ( *pEnumData->pfnEnumObjects )(
                             pEnumData->pvEnumParameter,
                             (PCSSCTLOBJECT)I_CryptGetLruEntryData( hEntry )
                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlCreateObjectCache
//
//  Synopsis:   create the SS CTL object cache
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlCreateObjectCache (
     OUT PCSSCTLOBJECTCACHE* ppSSCtlObjectCache
     )
{
    BOOL               fResult = TRUE;
    PCSSCTLOBJECTCACHE pSSCtlObjectCache;

    pSSCtlObjectCache = new CSSCtlObjectCache( fResult );

    if ( pSSCtlObjectCache == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        fResult = FALSE;
    }
    else if ( fResult == TRUE )
    {
        *ppSSCtlObjectCache = pSSCtlObjectCache;
    }
    else
    {
        delete pSSCtlObjectCache;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeObjectCache
//
//  Synopsis:   free the object cache
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeObjectCache (
     IN PCSSCTLOBJECTCACHE pSSCtlObjectCache
     )
{
    delete pSSCtlObjectCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeTrustListInfo
//
//  Synopsis:   free the trust list info
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo
     )
{
    CertFreeCTLContext( pTrustListInfo->pCtlContext );

    delete pTrustListInfo;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlAllocAndCopyTrustListInfo
//
//  Synopsis:   allocate and copy the trust list info
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlAllocAndCopyTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo,
     OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
     )
{
    PCERT_TRUST_LIST_INFO pCopyTrustListInfo;

    pCopyTrustListInfo = new CERT_TRUST_LIST_INFO;
    if ( pCopyTrustListInfo == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    pCopyTrustListInfo->cbSize = sizeof( CERT_TRUST_LIST_INFO );

    pCopyTrustListInfo->pCtlContext = CertDuplicateCTLContext(
                                          pTrustListInfo->pCtlContext
                                          );

    pCopyTrustListInfo->pCtlEntry = pTrustListInfo->pCtlEntry;

    *ppTrustListInfo = pCopyTrustListInfo;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\asn1util.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       asn1util.h
//
//  Contents:   ASN.1 utility functions.
//
//  APIs: 
//              Asn1UtilDecodeLength
//              Asn1UtilExtractContent
//              Asn1UtilIsPKCS7WithoutContentType
//              Asn1UtilAdjustEncodedLength
//              Asn1UtilExtractValues
//              Asn1UtilExtractPKCS7SignedDataContent
//              Asn1UtilExtractCertificateToBeSignedContent
//              Asn1UtilExtractCertificatePublicKeyInfo
//
//  History:    06-Dec-96    philh   created from kevinr's wincrmsg version
//--------------------------------------------------------------------------

#ifndef __ASN1UTIL_H__
#define __ASN1UTIL_H__

#ifdef __cplusplus
extern "C" {
#endif

#define ASN1UTIL_INSUFFICIENT_DATA  -2

//+-------------------------------------------------------------------------
//  ASN.1 Tag Defines
//--------------------------------------------------------------------------
#define ASN1UTIL_TAG_NULL                   0x00
#define ASN1UTIL_TAG_BOOLEAN                0x01
#define ASN1UTIL_TAG_INTEGER                0x02
#define ASN1UTIL_TAG_BITSTRING              0x03
#define ASN1UTIL_TAG_OCTETSTRING            0x04
#define ASN1UTIL_TAG_OID                    0x06
#define ASN1UTIL_TAG_UTC_TIME               0x17
#define ASN1UTIL_TAG_GENERALIZED_TIME       0x18
#define ASN1UTIL_TAG_CONSTRUCTED            0x20
#define ASN1UTIL_TAG_SEQ                    0x30
#define ASN1UTIL_TAG_SET                    0x31
#define ASN1UTIL_TAG_CONTEXT_0              0x80
#define ASN1UTIL_TAG_CONTEXT_1              0x81

#define ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0  \
                        (ASN1UTIL_TAG_CONSTRUCTED | ASN1UTIL_TAG_CONTEXT_0)
#define ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_1  \
                        (ASN1UTIL_TAG_CONSTRUCTED | ASN1UTIL_TAG_CONTEXT_1)

//+-------------------------------------------------------------------------
//  ASN.1 Length Defines for indefinite length encooding
//--------------------------------------------------------------------------
#define ASN1UTIL_LENGTH_INDEFINITE          0x80
#define ASN1UTIL_LENGTH_NULL                0x00

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbDER      - number of bytes remaining in the DER encoding
//
//  Returns:
//          success - the number of bytes in the length field, >=0
//          failure - <0
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilDecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbDER);

//+-------------------------------------------------------------------------
//  Point to the content octets in a DER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, >=0
//          failure - <0
//
// BUGBUG Assume pbData points to a definite-length BER-encoded blob.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractContent(
    IN const BYTE *pbDER,
    IN DWORD cbDER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent);

//+-------------------------------------------------------------------------
//  Returns TRUE if we believe this is a Bob special that has ommitted the
//  PKCS #7 ContentType.
//
//  For PKCS #7: an Object Identifier tag (0x06) immediately follows the
//  identifier and length octets. For a Bob special: an integer tag (0x02)
//  follows the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilIsPKCS7WithoutContentType(
    IN const BYTE *pbDER,
    IN DWORD cbDER);

//+-------------------------------------------------------------------------
//  Decode the Asn1 length bytes to possibly downward adjust the length.
//
//  The returned length is always <= cbDER.
//--------------------------------------------------------------------------
DWORD
WINAPI
Asn1UtilAdjustEncodedLength(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    );



typedef struct _ASN1UTIL_EXTRACT_VALUE_PARA {
    // See below for list of operations and optional return blobs.
    DWORD           dwFlags;

    // The following 0 terminated array of tags is optional. If ommited, the
    // value may contain any tag. Note, for OPTIONAL_STEP_OVER, not optional.
    const BYTE      *rgbTag;
} ASN1UTIL_EXTRACT_VALUE_PARA, *PASN1UTIL_EXTRACT_VALUE_PARA;

// The lower 8 bits of dwFlags is set to one of the following operations
#define ASN1UTIL_MASK_VALUE_OP                  0xFF
#define ASN1UTIL_STEP_INTO_VALUE_OP             1
#define ASN1UTIL_STEP_OVER_VALUE_OP             2
#define ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP    3

#define ASN1UTIL_RETURN_VALUE_BLOB_FLAG         0x80000000
#define ASN1UTIL_RETURN_CONTENT_BLOB_FLAG       0x40000000


//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (ASN1UTIL_STEP_INTO_VALUE_OP)
//  or steps over the value's tag, length and content octets 
//  (ASN1UTIL_STEP_OVER_VALUE_OP or ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  For tag matching, only supports single byte tags.  STEP_OVER values
//  must be definite-length encoded.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all values successfully extracted. For
//                        STEP_INTO, only the tag and length octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        LastError is updated with the error.
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. For OPTIONAL_STEP_OVER, if tag isn't
//  found, pbData and cbData are set to 0.  If a STEP_INTO value is
//  indefinite-length encoded, cbData is set to CMSG_INDEFINITE_LENGTH.
//  If ASN1UTIL_DEFINITE_LENGTH_FLAG is set, then, all returned lengths
//  are definite-length, ie, CMSG_INDEFINITE_LENGTH is never returned.
//
//  If ASN1UTIL_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If ASN1UTIL_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OUT DWORD *pcValue,
    IN const ASN1UTIL_EXTRACT_VALUE_PARA *rgValuePara,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    );

#define ASN1UTIL_DEFINITE_LENGTH_FLAG           0x1


//+-------------------------------------------------------------------------
//  Skips past PKCS7 ASN.1 encoded values to get to the SignedData content.
//
//  Checks that the outer ContentType has the SignedData OID and optionally
//  checks the inner SignedData content's ContentType.
//
//  Returns:
//      success - the number of bytes skipped, >=0
//      failure - <0
//
//  If the SignedData content is indefinite-length encoded,
//  *pcbContent is set to CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractPKCS7SignedDataContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OPTIONAL const CRYPT_DER_BLOB *pEncodedInnerOID,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );

//+-------------------------------------------------------------------------
//  Verifies this is a certificate ASN.1 encoded signed content.
//  Returns the pointer to and length of the ToBeSigned content.
//
//  Returns an error if the ToBeSigned content isn't definite length
//  encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificateToBeSignedContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );

//+-------------------------------------------------------------------------
//  Returns the pointer to and length of the SubjectPublicKeyInfo value in
//  a signed and encoded X.509 certificate.
//
//  Returns an error if the value isn't definite length encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificatePublicKeyInfo(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbPublicKeyInfo,
    OUT const BYTE **ppbPublicKeyInfo
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#include "xdbg.h"

#ifdef __cplusplus
    extern "C" 
    {
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#ifndef _XBOX
#define DBG_SS_CRYPT32                      0x00000001
#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000
#define DBG_SS_APP                          0x10000000
#else
#define DBG_SS_CRYPT32                      "CRYPT32"
#define DBG_SS_TRUSTCOMMON                "PKITRST"
#define DBG_SS_TRUST                        "WINTRST"
#define DBG_SS_TRUSTPROV                   "SOFTPUB"
#define DBG_SS_CATALOG                     "MSCAT32"
#define DBG_SS_SIP                          "MSSIP32"
#define DBG_SS_SIGNING                     "MSSGN32"
#define DBG_SS_OFFSIGN                     "OFFSIGN"
#define DBG_SS_APP                         "CONAPPL"
#endif

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG

#   define DBG_TRACE_EX(argFmt) XDBGTRC argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)


#ifdef __cplusplus
    }       // balance of extern "C"
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\cryptver.h ===
/*+-------------------------------------------------------------------------
 *
 *  Microsoft Windows
 *
 *  Copyright (C) Microsoft Corporation, 1996 - 1997
 *
 *  File:       cryptver.h
 *
 *  Contents:   Microsoft Internet Security versioning
 *
 *  History:    14-Aug-1997 pberkman   created
 *
 *--------------------------------------------------------------------------*/

#include <ntverp.h>

#define VER_FILEDESCRIPTION_STR_TRUST   "Microsoft Trust "

#undef VER_PRODUCTMINOR

#ifdef _ISPUCAB
/* x86fre IE BUILD */
#   define VER_PRODUCTMINOR         101
#else
/* REAL NT BUILD */
#   define VER_PRODUCTMINOR         131
#endif

#undef VER_PRODUCTVERSION_STRING
#define VER_PRODUCTVERSION_STRING   "5"

#undef VER_PRODUCTVERSION
#define VER_PRODUCTVERSION          5,VER_PRODUCTMINOR,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#undef VER_BPAD
#if 	(VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif	(VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif	(VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#if 	(VER_PRODUCTMINOR < 10)
#define VERM_BPAD "00"
#elif	(VER_PRODUCTMINOR < 100)
#define VERM_BPAD "0"
#else
#define VERM_BPAD
#endif


#define VER_PRODUCTVERSION_STR2x(w,x,y) VER_PRODUCTVERSION_STRING "." VERM_BPAD #w "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1x(w,x,y) VER_PRODUCTVERSION_STR2x(w, x, y)

#undef VER_PRODUCTVERSION_STR
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1x(VER_PRODUCTMINOR, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\crypthlp.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       crypthlp.h
//
//  Contents:   Misc internal crypt/certificate helper APIs
//
//  APIs:       I_CryptGetDefaultCryptProv
//              I_CryptGetDefaultCryptProvForEncrypt
//              I_CryptGetFileVersion
//              I_CertSyncStore
//
//  History:    01-Jun-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTHLP_H__
#define __CRYPTHLP_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm supported
//  by the provider type. The provider is acquired with only
//  CRYPT_VERIFYCONTEXT.
//
//  Setting aiPubKey to 0, gets the default provider for RSA_FULL.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  HCRYPTPROVs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProv(
    IN ALG_ID aiPubKey
    );

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm, encrypt
//  key algorithm and encrypt key length supported by the provider type.
//
//  dwBitLen = 0, assumes the aiEncrypt's default bit length. For example,
//  CALG_RC2 has a default bit length of 40.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProvForEncrypt(
    IN ALG_ID aiPubKey,
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    );

//+-------------------------------------------------------------------------
//  crypt32.dll release version numbers
//--------------------------------------------------------------------------
#define IE4_CRYPT32_DLL_VER_MS          ((    5 << 16) | 101 )
#define IE4_CRYPT32_DLL_VER_LS          (( 1670 << 16) |   1 )

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptGetFileVersion(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    );

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\lrucache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       lrucache.h
//
//  Contents:   LRU Cache API
//
//  History:    16-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LRUCACHE_H__)
#define __LRUCACHE_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// These API allow creation and manipulation of an LRU based cache area.  The
// identifier used for the cache area is a stream of bytes of which some set
// of bytes are used for the hash index.  In order to get optimal caching
// the identifiers used should be unique and the bytes sufficiently random.
//

typedef HANDLE HLRUCACHE;
typedef HANDLE HLRUENTRY;

//
// Configuration flags
//

#define LRU_CACHE_NO_SERIALIZE            0x00000001
#define LRU_CACHE_NO_COPY_IDENTIFIER      0x00000002

//
// Entry removal and cache freeing flags
//

#define LRU_SUPPRESS_REMOVAL_NOTIFICATION 0x00000004

//
// Entry touching flags
//

#define LRU_SUPPRESS_CLOCK_UPDATE         0x00000008

typedef VOID (WINAPI *LRU_DATA_FREE_FN) (LPVOID pvData);
typedef DWORD (WINAPI *LRU_HASH_IDENTIFIER_FN) (PCRYPT_DATA_BLOB pIdentifier);
typedef VOID (WINAPI *LRU_ON_REMOVAL_NOTIFY_FN) (LPVOID pvData, LPVOID pvRemovalContext);

//
// Configuration NOTE: If MaxEntries is zero then no LRU is applied to the
//                     cache entries, i.e. the cache is not bounded.
//

typedef struct _LRU_CACHE_CONFIG {

    DWORD                    dwFlags;
    LRU_DATA_FREE_FN         pfnFree;
    LRU_HASH_IDENTIFIER_FN   pfnHash;
    LRU_ON_REMOVAL_NOTIFY_FN pfnOnRemoval;
    DWORD                    cBuckets;
    DWORD                    MaxEntries;

} LRU_CACHE_CONFIG, *PLRU_CACHE_CONFIG;

BOOL
WINAPI
I_CryptCreateLruCache (
       IN PLRU_CACHE_CONFIG pConfig,
       OUT HLRUCACHE* phCache
       );

VOID
WINAPI
I_CryptFlushLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

VOID
WINAPI
I_CryptFreeLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

BOOL
WINAPI
I_CryptCreateLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       IN LPVOID pvData,
       OUT HLRUENTRY* phEntry
       );

PCRYPT_DATA_BLOB
WINAPI
I_CryptGetLruEntryIdentifier (
       IN HLRUENTRY hEntry
       );

LPVOID
WINAPI
I_CryptGetLruEntryData (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptAddRefLruEntry (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptReleaseLruEntry (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptInsertLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL LPVOID pvLruRemovalContext
       );

VOID
WINAPI
I_CryptRemoveLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

VOID
WINAPI
I_CryptTouchLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL DWORD dwFlags
       );

// NOTE: The following find does NOT touch the cache entry

HLRUENTRY
WINAPI
I_CryptFindLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier
       );

// NOTE: The following find touches the cache entry

LPVOID
WINAPI
I_CryptFindLruEntryData (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       OUT HLRUENTRY* phEntry
       );

//
// If you cache contains multiple entries with the same identifier, then
// this function can be used to enumerate them after finding the first with
// I_CryptFindLruEntry
//
// NOTE: hPrevEntry is released
//
// NOTE: This does NOT touch the cache entries
//
// NOTE: The only way to safely use this function is if the serialization
//       is done outside of the cache handle and you use the
//       LRU_CACHE_NO_SERIALIZE flag.  If not, then you will get undefined
//       results if hPrevEntry is removed or inserted (after removal) in
//       between calls
//

HLRUENTRY
WINAPI
I_CryptEnumMatchingLruEntries (
       IN HLRUENTRY hPrevEntry
       );

//
// Temporary disabling of LRU behavior.  When it is re-enabled then entries
// are purged until the watermark is again met
//

VOID
WINAPI
I_CryptEnableLruOfEntries (
       IN HLRUCACHE hCache,
       IN OPTIONAL LPVOID pvLruRemovalContext
       );

VOID
WINAPI
I_CryptDisableLruOfEntries (
       IN HLRUCACHE hCache
       );

//
// Walk all entries function
//

typedef BOOL (WINAPI *PFN_WALK_ENTRIES) (
                          IN LPVOID pvParameter,
                          IN HLRUENTRY hEntry
                          );

VOID
WINAPI
I_CryptWalkAllLruCacheEntries (
       IN HLRUCACHE hCache,
       IN PFN_WALK_ENTRIES pfnWalk,
       IN LPVOID pvParameter
       );

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\certprot.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       certprot.h
//
//  Contents:   Certificate Protection APIs
//
//  APIs:       I_CertProtectFunction
//              I_CertCltProtectFunction
//              I_CertSrvProtectFunction
//
//  History:    27-Nov-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CERTPROT_H__
#define __CERTPROT_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Calls the services process to do a protected certificate function,
//  such as, add or delete a protected root certificate.
//
//  CryptMemFree must be called to free the returned *ppbOut.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    );

#define CERT_PROT_INIT_ROOTS_FUNC_ID            1
#define CERT_PROT_PURGE_LM_ROOTS_FUNC_ID        2
#define CERT_PROT_ADD_ROOT_FUNC_ID              3
#define CERT_PROT_DELETE_ROOT_FUNC_ID           4
#define CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID  5


//+-------------------------------------------------------------------------
//  CERT_PROT_INIT_ROOTS_FUNC_ID
//
//  Initialize the protected list of CurrentUser roots. Note, no UI.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_PURGE_LM_ROOTS_FUNC_ID
//  
//  Purge all CurrentUser roots from the protected list that also exist
//  in the LocalMachine SystemRegistry "Root" store. Also removes duplicated
//  certificates from the CurrentUser SystemRegistry "Root" store.
//
//  Note, no UI. Purging can be disabled by setting the
//  CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG in the registry's ProtectedRootFlags
//  value.
//
//  No IN/OUT parameters.
//
//  Even if purging is disabled, the protected list of roots is still
//  initialized.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ADD_ROOT_FUNC_ID
//  
//  Add the specified certificate to the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the add.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized certificate context to be added. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_ROOT_FUNC_ID
//  
//  Delete the specified certificate from the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the delete.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  certificate's SHA1 hash property. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID
//  
//  Delete all CurrentUser roots from the protected list that don't also
//  exist in the CurrentUser SystemRegistry "Root" store. The user is
//  prompted before doing the delete.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Called from the client process to do the RPC to the server process.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCltProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    );



typedef void __RPC_FAR * (__RPC_USER *PFN_CERT_PROT_MIDL_USER_ALLOC)(
    IN size_t cb
    );
typedef void (__RPC_USER *PFN_CERT_PROT_MIDL_USER_FREE)(
    IN void __RPC_FAR *pv
    );

//+-------------------------------------------------------------------------
//  Called from the services process to process a protected certificate 
//  function.
//
//  Returns the error status, ie, not returned in LastError.
//--------------------------------------------------------------------------
DWORD
WINAPI
I_CertSrvProtectFunction(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

typedef DWORD (WINAPI *PFN_CERT_SRV_PROTECT_FUNCTION)(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\crtem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crtem.h
//
//  Contents:   'C' Run Time Emulation Definitions
//
//  History:	03-Jun-96   philh   created
//--------------------------------------------------------------------------

#ifndef __CRTEM_H__
#define __CRTEM_H__


///////////////////////////////////////////////////////////////////////
//
// Definitions that help reduce our dependence on the C runtimes
//
#ifndef UNDER_CE
#define wcslen(sz)      lstrlenW(sz)            // yes it IS implemented by Win95

#define strlen(sz)      lstrlenA(sz)
#define strcpy(s1,s2)   lstrcpyA(s1,s2)
#define strcmp(s1,s2)   lstrcmpA(s1,s2)
#define _stricmp(s1,s2)  lstrcmpiA(s1,s2)
#define strcat(s1,s2)   lstrcatA(s1,s2)
#endif

///////////////////////////////////////////////////////////////////////
//
// C runtime excluders that we only use in non-debug builds
//

////////////////////////////////////////////
//
// enable intrinsics that we can (NOT on WinCE)
/////////////////////////////////

////////////////////////////////////////////
//
// memory management
//
#define malloc(cb)          ((void*)LocalAlloc(LPTR, cb))
#define free(pv)            (LocalFree((HLOCAL)pv))
#define realloc(pv, cb)     ((void*)LocalReAlloc((HLOCAL)pv, cb, LMEM_MOVEABLE))

#ifndef _XBOX

#ifdef CE_BUILD

#ifdef UNDER_CE
#define MODULE_NAME TEXT("WINCRYPT")
#define assert(x) DBGCHK(MODULE_NAME,(x))
// assume called with bAlertable == FALSE
#define WaitForSingleObjectEx(x, y, bAlertable) WaitForSingleObject(x, y)
#define WaitForMultipleObjectsEx(cWait,rghWait,f,t,bAlertable) WaitForMultipleObjects(cWait,rghWait,f,t)
// grossly simplified implementation of CompareStringA - only correctly returns 2 for equality
#define CompareStringA(lcid, flags, cs1, len1, cs2, len2) ((len1 == len2 && !_strnicmp(cs1,cs2,len1)) ? 2 : 1)
LONG RegEnumKeyA(  HKEY hKey,     // handle to key to query
  DWORD dwIndex, // index of subkey to query
  LPSTR lpName, // address of buffer for subkey name
  DWORD cbName   // size of subkey buffer
  );
LONG
APIENTRY
CERegCreateKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    );
LONG
APIENTRY
CERegOpenKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    );
LONG
APIENTRY
CERegDeleteKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey
    );
LONG
APIENTRY
CERegSetValueExA (
    IN HKEY hKey,
    IN LPCSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    );
#define RegCreateKeyExA CERegCreateKeyExA
#define RegOpenKeyExA CERegOpenKeyExA
#define RegDeleteKeyA CERegDeleteKeyA
#define RegSetValueExA CERegSetValueExA
#endif

#endif // CE_BUILD

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptUninstallOssGlobal
//              I_CryptGetOssGlobal
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "msasn1.h"
#ifdef OSS_CRYPT_ASN1
#include "ossglobl.h"
#endif
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed OssGlobal table
typedef DWORD HCRYPTOSSGLOBAL;



// Handle to an installed Asn1 module
typedef DWORD HCRYPTASN1MODULE;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

#ifdef OSS_CRYPT_ASN1

// Pointer to OssGlobal. Returned by I_CryptGetOssGlobal()
typedef  OssGlobal  *POssGlobal;

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an OssGlobal entry. Iterate
//  through the threads and frees their allocated copy of OssGlobal.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

#endif


//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    return (HCRYPTASN1MODULE) I_CryptInstallOssGlobal(
        pvCtlTbl, dwFlags, pvReserved);
}
#else

HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return I_CryptUninstallOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1encoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1decoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\mscat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       mscat.h
//
//  Contents:   Microsoft Internet Security Catalog API
//
//  History:    29-Apr-1997 pberkman    created
//              09-Sep-1997 pberkman    add CATAdmin functions
//
//--------------------------------------------------------------------------


#ifndef MSCAT_H
#define MSCAT_H

#include    "mssip.h"

#ifdef __cplusplus
    extern "C" 
    {
#endif

/////////////////////////////////////////////////////////////////////////////
//
//  defines:
//  
/////////////////////////////////////////////////////////////////////////////

#define     szOID_CATALOG_LIST                  "1.3.6.1.4.1.311.12.1.1"
#define     szOID_CATALOG_LIST_MEMBER           "1.3.6.1.4.1.311.12.1.2"

#define     CRYPTCAT_FILEEXT                    L"CAT"

#define     CRYPTCAT_MAX_MEMBERTAG              64

        //
        //  fdwOpenFlags
        //
#define     CRYPTCAT_OPEN_CREATENEW             0x00000001  // creates/overwrites
#define     CRYPTCAT_OPEN_ALWAYS                0x00000002  // opens/creates
#define     CRYPTCAT_OPEN_EXISTING              0x00000004  // opens only

#define     CRYPTCAT_OPEN_VERIFYSIGHASH         0x10000000  // verifies the signature (not the certs!)

        //
        //  fdwMemberFlags  (used internal -- do not fill)
        //

        //
        //  dwAttrTypeAndAction
        //
#define     CRYPTCAT_ATTR_AUTHENTICATED         0x10000000
#define     CRYPTCAT_ATTR_UNAUTHENTICATED       0x20000000

#define     CRYPTCAT_ATTR_NAMEASCII             0x00000001  // ascii string
#define     CRYPTCAT_ATTR_NAMEOBJID             0x00000002  // crypt obj id

#define     CRYPTCAT_ATTR_DATAASCII             0x00010000  // do not decode simple ascii chars
#define     CRYPTCAT_ATTR_DATABASE64            0x00020000  // base 64 

        //
        //  dwLocalError - CDF Parse
        //
#define     CRYPTCAT_E_AREA_HEADER              0x00000000
#define     CRYPTCAT_E_AREA_MEMBER              0x00010000
#define     CRYPTCAT_E_AREA_ATTRIBUTE           0x00020000

#define     CRYPTCAT_E_CDF_UNSUPPORTED          0x00000001
#define     CRYPTCAT_E_CDF_DUPLICATE            0x00000002
#define     CRYPTCAT_E_CDF_TAGNOTFOUND          0x00000004

#define     CRYPTCAT_E_CDF_MEMBER_FILE_PATH     0x00010001
#define     CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA  0x00010002
#define     CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND  0x00010004

#define     CRYPTCAT_E_CDF_BAD_GUID_CONV        0x00020001
#define     CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES    0x00020002
#define     CRYPTCAT_E_CDF_ATTR_TYPECOMBO       0x00020004




/////////////////////////////////////////////////////////////////////////////
//
//  structures:
//  
/////////////////////////////////////////////////////////////////////////////

#pragma pack(8)

typedef struct CRYPTCATSTORE_
{
    DWORD                       cbStruct;       // = sizeof(CRYPTCATSTORE)
    DWORD                       dwPublicVersion;
    LPWSTR                      pwszP7File;
    HCRYPTPROV                  hProv;
    DWORD                       dwEncodingType;
    DWORD                       fdwStoreFlags;
    HANDLE                      hReserved;      // pStack(members) (null if init/pbData) INTERNAL!

    // 18-Sep-1997 pberkman: added
    HANDLE                      hAttrs;         // pStack(Catalog attrs) INTERNAL!

} CRYPTCATSTORE;

typedef struct CRYPTCATMEMBER_
{
    DWORD                       cbStruct;           // = sizeof(CRYPTCATMEMBER)
    LPWSTR                      pwszReferenceTag;
    LPWSTR                      pwszFileName;       // used only by the CDF APIs
    GUID                        gSubjectType;       // may be zeros -- see sEncodedMemberInfo
    DWORD                       fdwMemberFlags;
    struct SIP_INDIRECT_DATA_   *pIndirectData;     // may be null -- see sEncodedIndirectData
    DWORD                       dwCertVersion;      // may be zero -- see sEncodedMemberInfo
    DWORD                       dwReserved;         // used by enum -- DO NOT USE!
    HANDLE                      hReserved;          // pStack(attrs) (null if init) INTERNAL!

    // 30-Sep-1997 pberkman: added
    CRYPT_ATTR_BLOB             sEncodedIndirectData;   // lazy decode
    CRYPT_ATTR_BLOB             sEncodedMemberInfo;     // lazy decode

} CRYPTCATMEMBER;

typedef struct CRYPTCATATTRIBUTE_
{
    DWORD                       cbStruct;           // = sizeof(CRYPTCATATTRIBUTE)
    LPWSTR                      pwszReferenceTag;
    DWORD                       dwAttrTypeAndAction;
    DWORD                       cbValue;
    BYTE                        *pbValue;           // encoded CAT_NAMEVALUE struct
    DWORD                       dwReserved;         // used by enum -- DO NOT USE!

} CRYPTCATATTRIBUTE;

typedef struct CRYPTCATCDF_
{
    DWORD                       cbStruct;           // = sizeof(CRYPTCATCDF)
    HANDLE                      hFile;
    DWORD                       dwCurFilePos;
    DWORD                       dwLastMemberOffset;
    BOOL                        fEOF;
    LPWSTR                      pwszResultDir;
    HANDLE                      hCATStore;

} CRYPTCATCDF;

typedef struct CATALOG_INFO_
{
    DWORD                       cbStruct;   // set to sizeof(CATALOG_INFO)

    WCHAR                       wszCatalogFile[MAX_PATH];

} CATALOG_INFO;

typedef HANDLE          HCATADMIN;
typedef HANDLE          HCATINFO;

#pragma pack()

typedef void (WINAPI *PFN_CDF_PARSE_ERROR_CALLBACK)(IN DWORD dwErrorArea,
                                                    IN DWORD dwLocalError,
                                                    IN WCHAR *pwszLine);

/////////////////////////////////////////////////////////////////////////////
//
//  Prototypes:
//  
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
//  Open:
// --------------------------------------------------------------------------
//  Usage:
//      open the catalog for Get/Put operations.
//
//  Return:
//      INVALID_HANDLE_VALUE:           an error occured while opening Catalog
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern HANDLE WINAPI CryptCATOpen(IN          LPWSTR pwszFileName, 
                                  IN          DWORD fdwOpenFlags,
                                  IN OPTIONAL HCRYPTPROV hProv,
                                  IN OPTIONAL DWORD dwPublicVersion,
                                  IN OPTIONAL DWORD dwEncodingType);

/////////////////////////////////////////////////////////////////////////////
//
//  Close:
// --------------------------------------------------------------------------
//  Usage:
//      close the catalog handle.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern BOOL WINAPI CryptCATClose(IN HANDLE hCatalog);

/////////////////////////////////////////////////////////////////////////////
//
//  StoreFromHandle:
// --------------------------------------------------------------------------
//  Usage:
//      retrieve the CRYPTCATSTORE from the store handle.
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATSTORE * WINAPI CryptCATStoreFromHandle(IN HANDLE hCatalog);

/////////////////////////////////////////////////////////////////////////////
//
// HandleFromStore:
// --------------------------------------------------------------------------
//  Usage:
//      retrieve the handle from a CRYPTCATSTORE pointer.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern HANDLE WINAPI CryptCATHandleFromStore(IN CRYPTCATSTORE *pCatStore);


/////////////////////////////////////////////////////////////////////////////
//
//  PersistStore
// --------------------------------------------------------------------------
//  Usage:
//      Persist the information in the current Catalog Store to an unsigned
//      Catalog File. It is REQUIRED to fill in the pwszP7File member
//      of CRYPTCATSTORE prior to this call!
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern BOOL WINAPI CryptCATPersistStore(IN HANDLE hCatalog);


/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATGetCatAttrInfo
// --------------------------------------------------------------------------
//  Usage:
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATATTRIBUTE * WINAPI CryptCATGetCatAttrInfo(IN HANDLE hCatalog,
                                                         IN LPWSTR pwszReferenceTag);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATPutCatAttrInfo
// --------------------------------------------------------------------------
//  Usage:
//      Allocates and adds the attribute to the catalog.  Returns a pointer
//      to the allocated attribute.
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATATTRIBUTE * WINAPI CryptCATPutCatAttrInfo(IN HANDLE hCatalog,
                                                         IN LPWSTR pwszReferenceTag,
                                                         IN DWORD dwAttrTypeAndAction,
                                                         IN DWORD cbData,
                                                         IN BYTE *pbData);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATEnumerateCatAttr
// --------------------------------------------------------------------------
//  Usage:
//      Enumerates through the list of attributes associated with the catalog.
//      Returns a pointer to the attribute. This return should be passed in 
//      as the 'PrevAttr' to continue the enumeration.  On the first call, 
//      the 'PrevAttr' should be set to NULL.
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATATTRIBUTE * WINAPI CryptCATEnumerateCatAttr(IN HANDLE hCatalog,
                                                           IN CRYPTCATATTRIBUTE *pPrevAttr);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATGetMemberInfo
// --------------------------------------------------------------------------
//  Usage:
//      Retrieve the Tag info (member info) structure from the catalog
//      PKCS#7, fill the CRYPTCATMEMBER structure, and return. -- Opens a
//      member context.
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATMEMBER * WINAPI CryptCATGetMemberInfo(IN HANDLE hCatalog, 
                                                     IN LPWSTR pwszReferenceTag);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATGetAttr:
// --------------------------------------------------------------------------
//  Usage:
//      get pwszReferenceTag attribute information for a member.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATATTRIBUTE * WINAPI CryptCATGetAttrInfo(IN HANDLE hCatalog,
                                                      IN CRYPTCATMEMBER *pCatMember,
                                                      IN LPWSTR pwszReferenceTag);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATPutMemberInfo
// --------------------------------------------------------------------------
//  Usage:
//      Allocates and adds the member to the catalog.  Returns a pointer
//      to the allocated member.
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//      CRYPT_E_EXISTS:                 the reference tag already exists
//      CRYPT_E_NOT_FOUND:              the attr was not found
//
extern CRYPTCATMEMBER * WINAPI CryptCATPutMemberInfo(IN HANDLE hCatalog,
                                                     IN OPTIONAL LPWSTR pwszFileName,
                                                     IN          LPWSTR pwszReferenceTag,
                                                     IN          GUID *pgSubjectType,
                                                     IN          DWORD dwCertVersion,
                                                     IN          DWORD cbSIPIndirectData,
                                                     IN          BYTE *pbSIPIndirectData);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATPutAttrInfo
// --------------------------------------------------------------------------
//  Usage:
//      Allocates and adds the attribute to the member.  Returns a pointer
//      to the allocated attribute.
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATATTRIBUTE * WINAPI CryptCATPutAttrInfo(IN HANDLE hCatalog,
                                                      IN CRYPTCATMEMBER *pCatMember,
                                                      IN LPWSTR pwszReferenceTag,
                                                      IN DWORD dwAttrTypeAndAction,
                                                      IN DWORD cbData,
                                                      IN BYTE *pbData);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATEnumerateMember
// --------------------------------------------------------------------------
//  Usage:
//      Enumerates through the list of members in the store.  Returns a pointer
//      to the member. This return should be passed in as the 'PrevMember' to
//      continue the enumeration.  On the first call, the 'PrevMember' should
//      be set to NULL.
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATMEMBER * WINAPI CryptCATEnumerateMember(IN HANDLE hCatalog,
                                                       IN CRYPTCATMEMBER *pPrevMember);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATEnumerateAttr
// --------------------------------------------------------------------------
//  Usage:
//      Enumerates through the list of attributes associated with the member.
//      Returns a pointer to the attribute. This return should be passed in 
//      as the 'PrevAttr' to continue the enumeration.  On the first call, 
//      the 'PrevAttr' should be set to NULL.
//
//          *** DO NOT FREE THE POINTER OR ANY OF ITS MEMBERS! ***
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATATTRIBUTE * WINAPI CryptCATEnumerateAttr(IN HANDLE hCatalog,
                                                        IN CRYPTCATMEMBER *pCatMember,
                                                        IN CRYPTCATATTRIBUTE *pPrevAttr);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATCDFOpen
// --------------------------------------------------------------------------
//  Usage:
//      Opens the specified CDF file and initialized the structure
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//      ERROR_FILE_NOT_FOUND:           the CDF file was not found
//
extern CRYPTCATCDF * WINAPI CryptCATCDFOpen(IN LPWSTR pwszFilePath,
                                            IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);


/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATCDFClose
// --------------------------------------------------------------------------
//  Usage:
//      Closes the CDF file and deallocates the structure
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern BOOL WINAPI CryptCATCDFClose(IN CRYPTCATCDF *pCDF);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATCDFEnumCatAttributes
// --------------------------------------------------------------------------
//  Usage:
//      Enumerates Catalog level attributes within the "[CatalogFiles]" 
//      section of the CDF.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATATTRIBUTE * WINAPI CryptCATCDFEnumCatAttributes(CRYPTCATCDF *pCDF, 
                                                               CRYPTCATATTRIBUTE *pPrevAttr,
                                                                PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATCDFEnumMembers
// --------------------------------------------------------------------------
//  Usage:
//      Enumerates files within the "[CatalogFiles]" section of the CDF.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATMEMBER * WINAPI CryptCATCDFEnumMembers(IN          CRYPTCATCDF *pCDF,
                                                      IN          CRYPTCATMEMBER *pPrevMember,
                                                      IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

/////////////////////////////////////////////////////////////////////////////
//
//  CryptCATCDFEnumAttributes
// --------------------------------------------------------------------------
//  Usage:
//      Enumerates the files attributes within the "[CatalogFiles]" section 
//      of the CDF.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
extern CRYPTCATATTRIBUTE *WINAPI CryptCATCDFEnumAttributes(IN          CRYPTCATCDF *pCDF, 
                                                           IN          CRYPTCATMEMBER *pMember,
                                                           IN          CRYPTCATATTRIBUTE *pPrevAttr,
                                                           IN OPTIONAL PFN_CDF_PARSE_ERROR_CALLBACK pfnParseError);

//////////////////////////////////////////////////////////////////////////
//
//  IsCatalogFile
// --------------------------------------------------------------------------
//  Usage:
//      Call this function to determine if the file is a Catalog File.  Both
//      parameters are optional.  HOWEVER, one of them MUST be passed!
//
//  Return:
//      TRUE if it is.
//      FALSE if it isn't or an error occured.
//
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//      ERROR_NOT_ENOUGH_MEMORY:        a memory allocation failed
//      {file errors}                   a file error occured
//
extern BOOL WINAPI      IsCatalogFile(IN OPTIONAL HANDLE hFile,
                                      IN OPTIONAL WCHAR *pwszFileName);


//////////////////////////////////////////////////////////////////////////
//
//  CryptCATAdminAcquireContext
// --------------------------------------------------------------------------
//  Usage:
//      Opens a new Admin Context based on the pgSubsystem Id.
//
//      the Guid passed in will be converted to a string and used as the 
//      sub-directory under %SystemRoot%\CatRoot to store all Catalog files
//      for this app/sub-system.
//
//      if a NULL is passed in to the pgSubsystem parameter, all finds will be
//      "global" and any Adds will be under the "default" Subsystem.
//
//  Return:
//      TRUE if phCatAdmin points to a valid context.
//      FALSE if an error occurs.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//      ERROR_NOT_ENOUGH_MEMORY:        a memory allocation failed
//      ERROR_DATABASE_FAILURE:         an error occured while processing
//                                      the database.
//
//  Comments:
//          The dwFlags parameter is reserved for future use.  Must
//          be set to NULL.
//
//
extern BOOL WINAPI      CryptCATAdminAcquireContext(OUT HCATADMIN *phCatAdmin, 
                                                    IN const GUID *pgSubsystem, 
                                                    IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////
//
//  CryptCATAdminReleaseContext
// --------------------------------------------------------------------------
//  Usage:
//      Releases (frees) all information related to the Admin Context
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
//  Comments:
//          The dwFlags parameter is reserved for future use.  Must
//          be set to NULL.
//
extern BOOL WINAPI      CryptCATAdminReleaseContext(IN HCATADMIN hCatAdmin,
                                                    IN DWORD dwFlags);


//////////////////////////////////////////////////////////////////////////
//
//  CryptCATAdminReleaseCatalogContext
// -----------------------------------------------------------------------
//  Usage:
//      Call this function to release memory associated with the Catalog
//      Info Context.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
//  Comments:
//      the dwFlags parameter is reserved for future use and must be assigned
//      to NULL.
//
extern BOOL WINAPI CryptCATAdminReleaseCatalogContext(IN HCATADMIN hCatAdmin,
                                                      IN HCATINFO hCatInfo,
                                                      IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////
//
//  CryptCATAdminEnumCatalogFromHash
// --------------------------------------------------------------------------
//  Usage:
//      Call this function to retrieve the Catalog Info handle of the Catalog
//      file that currently "points" to the specified Member Hash.
//
//      if hCatInfo is NULL, the first catalog found that contains the
//      hash will be returned.
//
//      if hCatInfo is not NULL, the content must be initialized to NULL prior
//      to going into the enum loop -- this starts the first/next search.  
//      This function uses this parameter to determine the last catalog returned.  
//
//      if hCatInfo is not NULL, and the loop is terminated prior to this 
//      function returning NULL, the application must call
//      CryptCATAdminReleaseCatalogContext to free all memory associated with
//      ppPrevContext.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//      ERROR_NOT_ENOUGH_MEMORY:        a memory allocation failed
//      ERROR_DATABASE_FAILURE:         an error occurred while processing
//                                      the database.
//
extern HCATINFO WINAPI CryptCATAdminEnumCatalogFromHash(IN HCATADMIN hCatAdmin,
                                                        IN BYTE *pbHash,
                                                        IN DWORD cbHash,
                                                        IN DWORD dwFlags,
                                                        IN OUT HCATINFO *phPrevCatInfo);

//////////////////////////////////////////////////////////////////////////
//
//  CryptCATAdminCalcHashFromFileHandle
// --------------------------------------------------------------------------
//  Usage:
//      Call this function to calculate the has based on an open file handle.
//      
//  Return:
//      TRUE if the pbHash was filled with the calculated hash.
//      FALSE if an error occured
//
//      To obtain the size required for pbHash, set pbHash to NULL.  The
//      correct size will be returned in pcbHash, the return value will
//      be TRUE and a call to GetLastError() will equal ERROR_INSUFFICIENT_BUFFER.
//
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//      ERROR_INSUFFICIENT_BUFFER:      the *pbHash was not big enough.
//      ERROR_NOT_ENOUGH_MEMORY:        a memory allocation failed
//
//  Comments:
//      the dwFlags parameter is reserved for future use and must be assigned
//      to NULL.
//
extern BOOL WINAPI CryptCATAdminCalcHashFromFileHandle(IN HANDLE hFile, 
                                                       IN OUT DWORD *pcbHash, 
                                                       OUT OPTIONAL BYTE *pbHash,
                                                       IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////
//
//  CryptCATAdminAddCatalog
// --------------------------------------------------------------------------
//  Usage:
//      Call this function to add a catalog file to the CAT Maintenance
//      subsystem.
//
//      if the pwszSelectedBaseName is NULL, the Catalog Admin system will
//      generate a file base name for you.  Otherwise, this parameter is 
//      used as the file name (base & extension only) of the copied Catalog
//      file.
//
//      Call CryptCATAdminReleaseCatalogContext to free the memory associated
//      with the Catalog Context returned if not NULL.
//
//  Return:
//      On success, TRUE is returned and ppContext is filled with the new Catalog
//      info context.
//      FALSE if an error occurs.
//      
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//      ERROR_NOT_ENOUGH_MEMORY:        a memory allocation failed
//      ERROR_BAD_FORMAT:               the file is not a catalog file.
//      ERROR_DATABASE_FAILURE:         an error occurred while processing
//                                      the database.
//
//  Comments:
//      the dwFlags parameter is reserved for future use and must be assigned
//      to NULL.
//
extern HCATINFO WINAPI CryptCATAdminAddCatalog(IN HCATADMIN hCatAdmin, 
                                               IN WCHAR *pwszCatalogFile,
                                               IN OPTIONAL WCHAR *pwszSelectBaseName, 
                                               IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////
//
//  CryptCATCatalogInfoFromContext
// --------------------------------------------------------------------------
//  Usage:
//      call this function to retrieve information relating to the
//      Catalog info handle passed from the Add Catalog function.
//
//  Return:
//      On success, TRUE is returned and the CATALOG_INFO structure
//      is filled in.
//      FALSE if an error occurs.
//      
//  Errors:
//      ERROR_INVALID_PARAMETER:        an input parameter is incorrect
//
//  Comments:
//      the dwFlags parameter is reserved for future use and must be assigned
//      to NULL.
//
extern BOOL WINAPI CryptCATCatalogInfoFromContext(IN HCATINFO hCatInfo,
                                                  IN OUT CATALOG_INFO *psCatInfo,
                                                  IN DWORD dwFlags);


#ifdef __cplusplus
}
#endif

#endif // MSCAT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\ossconv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ossconv.h
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  APIs:       OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//
//--------------------------------------------------------------------------

#ifndef __OSSCONV_H__
#define __OSSCONV_H__

#include "asn1hdr.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    );

#define OSS_UTC_TIME_CHOICE             1
#define OSS_GENERALIZED_TIME_CHOICE     2

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\pvkhlpr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       pvkhlpr.h
//
//  Contents:   Private Key Helper API Prototypes and Definitions
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  APIs:       PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContext
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//              PrivateKeyLoadA
//              PrivateKeySaveA
//              PrivateKeyLoadFromMemoryA
//              PrivateKeySaveToMemoryA
//              PrivateKeyAcquireContextA
//              PrivateKeyAcquireContextFromMemoryA
//              PrivateKeyReleaseContextA
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __PVKHLPR_H__
#define __PVKHLPR_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PRIVATEKEYBLOB
#define PRIVATEKEYBLOB  0x7
#endif


    //+-------------------------------------------------------------------------
    //  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  from the file into the cryptographic provider.
    //
    //  If the private key was password encrypted, then, the user is first
    //  presented with a dialog box to enter the password.
    //
    //  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
    //  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
    //  a mismatch. *pdwKeySpec is updated with the key type.
    //
    //  dwFlags is passed through to CryptImportKey.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyLoad(IN HCRYPTPROV hCryptProv,
                       IN HANDLE hFile,
                       IN HWND hwndOwner,
                       IN LPCWSTR pwszKeyName,     // name used in dialog
                       IN DWORD dwFlags,
                       IN OUT OPTIONAL DWORD *pdwKeySpec);

    BOOL WINAPI
        PvkPrivateKeyLoadA(IN HCRYPTPROV hCryptProv,
                        IN HANDLE hFile,
                        IN HWND hwndOwner,
                        IN LPCTSTR pwszKeyName,     // name used in dialog
                        IN DWORD dwFlags,
                        IN OUT OPTIONAL DWORD *pdwKeySpec);

    //+-------------------------------------------------------------------------
    //  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  to the specified file.
    //
    //  The user is presented with a dialog box to enter an optional password to
    //  encrypt the private key.
    //
    //  dwFlags is passed through to CryptExportKey.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeySave(IN HCRYPTPROV hCryptProv,
                       IN HANDLE hFile,
                       IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                       IN HWND hwndOwner,
                       IN LPCWSTR pwszKeyName,     // name used in dialog
                       IN DWORD dwFlags);

    BOOL WINAPI
        PvkPrivateKeySaveA(IN HCRYPTPROV hCryptProv,
                        IN HANDLE hFile,
                        IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                        IN HWND hwndOwner,
                        IN LPCTSTR pwszKeyName,     // name used in dialog
                        IN DWORD dwFlags);
    //+-------------------------------------------------------------------------
    //  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  from memory into the cryptographic provider.
    //
    //  Except for the key being loaded from memory, identical to PrivateKeyLoad.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyLoadFromMemory(IN HCRYPTPROV hCryptProv,
                                 IN BYTE *pbData,
                                 IN DWORD cbData,
                                 IN HWND hwndOwner,
                                 IN LPCWSTR pwszKeyName,     // name used in dialog
                                 IN DWORD dwFlags,
                                 IN OUT OPTIONAL DWORD *pdwKeySpec);

    BOOL WINAPI
        PvkPrivateKeyLoadFromMemoryA(IN HCRYPTPROV hCryptProv,
                                  IN BYTE *pbData,
                                  IN DWORD cbData,
                                  IN HWND hwndOwner,
                                  IN LPCTSTR pwszKeyName,     // name used in dialog
                                  IN DWORD dwFlags,
                                  IN OUT OPTIONAL DWORD *pdwKeySpec);
    
    //+-------------------------------------------------------------------------
    //  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  to memory.
    //
    //  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
    //  return an error (also, the user isn't prompted for a password).
    //
    //  Except for the key being saved to memory, identical to PrivateKeySave.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeySaveToMemory(IN HCRYPTPROV hCryptProv,
                               IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                               IN HWND hwndOwner,
                               IN LPCWSTR pwszKeyName,     // name used in dialog
                               IN DWORD dwFlags,
                               OUT BYTE *pbData,
                               IN OUT DWORD *pcbData);

    BOOL WINAPI
        PvkPrivateKeySaveToMemoryA(IN HCRYPTPROV hCryptProv,
                                IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                                IN HWND hwndOwner,
                                IN LPCTSTR pwszKeyName,     // name used in dialog
                                IN DWORD dwFlags,
                                OUT BYTE *pbData,
                                IN OUT DWORD *pcbData);

    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from the specified file.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoad is called to load the private key into the temporary
    //  container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContext(IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN HANDLE hFile,
                                 IN HWND hwndOwner,
                                 IN LPCWSTR pwszKeyName,     // name used in dialog
                                 IN OUT OPTIONAL DWORD *pdwKeySpec,
                                 OUT HCRYPTPROV *phCryptProv,
                                 OUT LPWSTR *ppwszTmpContainer
                                 );

    BOOL WINAPI
        PvkPrivateKeyAcquireContextA(IN LPCTSTR pwszProvName,
                                  IN DWORD dwProvType,
                                  IN HANDLE hFile,
                                  IN HWND hwndOwner,
                                  IN LPCTSTR pwszKeyName,     // name used in dialog
                                  IN OUT OPTIONAL DWORD *pdwKeySpec,
                                  OUT HCRYPTPROV *phCryptProv,
                                  OUT LPTSTR *ppwszTmpContainer);
    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from memory.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoadFromMemory is called to load the private key into the
    //  temporary container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemory(IN LPCWSTR pwszProvName,
                                           IN DWORD dwProvType,
                                           IN BYTE *pbData,
                                           IN DWORD cbData,
                                           IN HWND hwndOwner,
                                           IN LPCWSTR pwszKeyName,     // name used in dialog
                                           IN OUT OPTIONAL DWORD *pdwKeySpec,
                                           OUT HCRYPTPROV *phCryptProv,
                                           OUT LPWSTR *ppwszTmpContainer);

    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemoryA(IN LPCTSTR pwszProvName,
                                            IN DWORD dwProvType,
                                            IN BYTE *pbData,
                                            IN DWORD cbData,
                                            IN HWND hwndOwner,
                                            IN LPCTSTR pwszKeyName,     // name used in dialog
                                            IN OUT OPTIONAL DWORD *pdwKeySpec,
                                            OUT HCRYPTPROV *phCryptProv,
                                            OUT LPTSTR *ppwszTmpContainer);

    //+-------------------------------------------------------------------------
    //  Releases the cryptographic provider and deletes the temporary container
    //  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyReleaseContext(IN HCRYPTPROV hCryptProv,
                                 IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN LPWSTR pwszTmpContainer);

    BOOL WINAPI
        PvkPrivateKeyReleaseContextA(IN HCRYPTPROV hCryptProv,
                                  IN LPCTSTR pwszProvName,
                                  IN DWORD dwProvType,
                                  IN LPTSTR pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Acquiring hprovs, Trys the file first and then the KeyContainer. Use
//  PvkFreeCryptProv to release HCRYPTPROV and resources.
//--------------------------------------------------------------------------
    HCRYPTPROV WINAPI 
        PvkGetCryptProvA(IN HWND hwnd,
                         IN LPCSTR pszCaption,
                         IN LPCSTR pszCapiProvider,
                         IN DWORD  dwProviderType,
                         IN LPCSTR pszPrivKey,
                         OUT LPSTR *ppszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvA(IN HCRYPTPROV hProv,
                          IN LPCSTR  pszCapiProvider,
                          IN DWORD   dwProviderType,
                          IN LPSTR   pszTmpContainer);

    HCRYPTPROV WINAPI 
        PvkGetCryptProvU(IN HWND hwnd,
                         IN LPCWSTR pwszCaption,
                         IN LPCWSTR pwszCapiProvider,
                         IN DWORD   dwProviderType,
                         IN LPCWSTR pwszPrivKey,
                         OUT LPWSTR *ppwszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvU(IN HCRYPTPROV hProv,
                          IN LPCWSTR  pwszCapiProvider,
                          IN DWORD    dwProviderType,
                          IN LPWSTR   pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Private Key helper  error codes
//--------------------------------------------------------------------------
#define PVK_HELPER_BAD_PARAMETER        0x80097001
#define PVK_HELPER_BAD_PVK_FILE         0x80097002
#define PVK_HELPER_WRONG_KEY_TYPE       0x80097003
#define PVK_HELPER_PASSWORD_CANCEL      0x80097004

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\pkiasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkiasn1.h
//
//  Contents:   PKI ASN.1 support functions.
//
//  APIs:       PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1FreeEncoded
//              PkiAsn1Encode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//              PkiAsn1FreeDecoded
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//              PkiAsn1EncodedOidToDotVal
//              PkiAsn1FreeDotVal
//              PkiAsn1DotValToEncodedOid
//              PkiAsn1FreeEncodedOid
//
//              PkiAsn1Alloc
//              PkiAsn1Free
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1FreeHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1SetBitStringWithoutTrailingZeroes
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1FreeInfo
//              PkiAsn1EncodeInfoEx
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIASN1_H__
#define __PKIASN1_H__

#include <msber.h>
#include <msasn1.h>
#include <winerror.h>
#include <pkialloc.h>

#ifdef OSS_CRYPT_ASN1
#include "asn1hdr.h"
#include "asn1code.h"
#include "ossglobl.h"
#include "pkioss.h"
#include "ossutil.h"
#include "ossconv.h"
#endif  // OSS_CRYPT_ASN1


#ifdef __cplusplus
extern "C" {
#endif



#ifndef OSS_CRYPT_ASN1

#ifndef CRYPT_E_ASN1_ERROR
#define CRYPT_E_ASN1_ERROR 0x80093100   // from NT5 winerror.h
#endif

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 > Asn1Err)
        return CRYPT_E_ASN1_ERROR + (-Asn1Err -1000);
    else
        return CRYPT_E_ASN1_ERROR + 0x100 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ASN1_FreeEncoded(pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rule functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    );

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    );

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    LPSTR pszDotVal = NULL;
    if (ASN1BEREoid2DotVal(pDec, pEncodedOid, &pszDotVal))
        return pszDotVal;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ASN1Free(pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    return ASN1BERDotVal2Eoid(pEnc, pszDotVal, pEncodedOid);
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ASN1_FreeEncoded(pEnc, pEncodedOid->value);
}

//+-------------------------------------------------------------------------
//  PkiAsn1 allocation and free functions
//--------------------------------------------------------------------------
#define PkiAsn1Alloc    PkiNonzeroAlloc
#define PkiAsn1Free     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  PkiAsn1FreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        );

void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        );

#define PkiAsn1FreeHugeUINT     PkiAsn1FreeHugeInteger

void
WINAPI
PkiAsn1GetHugeUINT(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        );

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        );

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        );

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    );

#define PKI_ASN1_UTC_TIME_CHOICE            1
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    2

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    );

#else 

//+=========================================================================
// The following map to the OSS ASN1 routines
//==========================================================================

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 <= Asn1Err && 1000 > Asn1Err)
        return CRYPT_E_OSS_ERROR + Asn1Err;
    else if (0 > Asn1Err)
        return CRYPT_E_ASN1_ERROR + (-Asn1Err -1000);
    else
        return CRYPT_E_ASN1_ERROR + 0x100 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT OPTIONAL DWORD *pcbEncoded = NULL
    )
{
    return (ASN1error_e) PkiOssEncode(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ossFreeBuf((OssGlobal *) pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssEncode2(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        pbEncoded,
        cbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode2(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ossFreePDU((OssGlobal *) pDec, (int) id, pvAsn1Info);
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ossEncodingRules ossRules;
    if (ASN1_BER_RULE_BER == eRule)
        ossRules = OSS_BER;
    else
        ossRules = OSS_DER;

    return (ASN1error_e) ossSetEncodingRules((OssGlobal *) pEnc, ossRules);
}

__inline
ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ossEncodingRules ossRules;
    ossRules = ossGetEncodingRules((OssGlobal *) pEnc);
    if (OSS_BER == ossRules)
        return ASN1_BER_RULE_BER;
    else
        return ASN1_BER_RULE_DER;
}

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID OssEncodedOid;
    OssBuf dotOid;
    memset(&dotOid, 0, sizeof(dotOid));

    OssEncodedOid.length = pEncodedOid->length;
    OssEncodedOid.value = pEncodedOid->value;
    if (0 == ossEncodedOidToDotVal((OssGlobal *) pDec, &OssEncodedOid,
            &dotOid))
        return (LPSTR) dotOid.value;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ossFreeBuf((OssGlobal *) pDec, pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID eoid;
    memset(&eoid, 0, sizeof(eoid));
    if (0 == ossDotValToEncodedOid((OssGlobal *) pEnc, pszDotVal, &eoid)) {
        pEncodedOid->length = eoid.length;
        pEncodedOid->value = eoid.value;
        return 1;
    } else {
        pEncodedOid->length = 0;
        pEncodedOid->value = NULL;
        return 0;
    }
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ossFreeBuf((OssGlobal *) pEnc, pEncodedOid->value);
}

#define PkiAsn1Alloc OssUtilAlloc
#define PkiAsn1Free OssUtilFree
#define PkiAsn1ReverseBytes OssUtilReverseBytes
#define PkiAsn1AllocAndReverseBytes OssUtilAllocAndReverseBytes
#define PkiAsn1GetOctetString OssUtilGetOctetString
#define PkiAsn1SetHugeInteger OssUtilSetHugeInteger
#define PkiAsn1FreeHugeInteger OssUtilFreeHugeInteger
#define PkiAsn1GetHugeInteger OssUtilGetHugeInteger
#define PkiAsn1SetHugeUINT OssUtilSetHugeUINT
#define PkiAsn1FreeHugeUINT OssUtilFreeHugeInteger
#define PkiAsn1GetHugeUINT OssUtilGetHugeUINT
#define PkiAsn1SetBitString OssUtilSetBitString
#define PkiAsn1GetBitString OssUtilGetBitString
#define PkiAsn1SetBitStringWithoutTrailingZeroes OssUtilSetBitStringWithoutTrailingZeroes
#define PkiAsn1GetIA5String OssUtilGetIA5String
#define PkiAsn1SetUnicodeConvertedToIA5String OssUtilSetUnicodeConvertedToIA5String
#define PkiAsn1FreeUnicodeConvertedToIA5String OssUtilFreeUnicodeConvertedToIA5String
#define PkiAsn1GetIA5StringConvertedToUnicode OssUtilGetIA5StringConvertedToUnicode
#define PkiAsn1GetBMPString OssUtilGetBMPString
#define PkiAsn1SetAny OssUtilSetAny
#define PkiAsn1GetAny OssUtilGetAny

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfo(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    return OssUtilDecodeAndAllocInfo(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        ppvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    OssUtilFreeInfo(
        (OssGlobal *) pDec,
        (int) id,
        pvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilAllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilDecodeAndAllocInfoEx(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

#define PkiAsn1ToObjectIdentifier OssConvToObjectIdentifier
#define PkiAsn1FromObjectIdentifier OssConvFromObjectIdentifier
#define PkiAsn1ToUTCTime OssConvToUTCTime
#define PkiAsn1FromUTCTime OssConvFromUTCTime
#define PkiAsn1ToGeneralizedTime OssConvToGeneralizedTime
#define PkiAsn1FromGeneralizedTime OssConvFromGeneralizedTime


__inline
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pGeneralTime,
    OUT UTCTime *pUtcTime
    )
{
    return OssConvToChoiceOfTime(
        pFileTime,
        pwChoice,
        pGeneralTime
        );
}

#define PKI_ASN1_UTC_TIME_CHOICE            OSS_UTC_TIME_CHOICE
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    OSS_GENERALIZED_TIME_CHOICE

__inline
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pGeneralTime,
    IN UTCTime *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    return OssConvFromChoiceOfTime(
        wChoice,
        pGeneralTime,
        pFileTime
        );
}

#endif  // OSS_CRYPT_ASN1

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\ossutil.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ossutil.h
//
//  Contents:   OSS ASN.1 compiler utility functions.
//
//  APIs: 
//              OssUtilAlloc
//              OssUtilFree
//              OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilFreeHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilGetBitString
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilEncodeInfoEx
//              OssUtilDecodeAndAllocInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __OSSUTIL_H__
#define __OSSUTIL_H__

#include <wincrypt.h>
#include <pkialloc.h>

#include "asn1hdr.h"
#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  OssUtil allocation and free functions
//--------------------------------------------------------------------------
#define OssUtilAlloc    PkiNonzeroAlloc
#define OssUtilFree     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BUGBUG: BYTE reversal::
//   - this only needs to be done for little endian
//   - this needs to be fixed in the OSS compiler
//
//  OssUtilFreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        );

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

#define OssUtilFreeHugeUINT     OssUtilFreeHugeInteger

void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        );

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        );

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        );

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        );

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_OSS_UTIL_DECODE_EX_CALLBACK)(
    IN void *pvOssInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\pfx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       pfx.h
//
//  Contents:   PFX (PKCS #12) function defintions and types
//
//----------------------------------------------------------------------------
#ifndef PFX_H
#define PFX_H

// Flag definitions for PFXExportCertStore
#define REPORT_NO_PRIVATE_KEY                   0x0001
#define REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY   0x0002
#define EXPORT_PRIVATE_KEYS                     0x0004
#define PKCS12_IMPORT_RESERVED_MASK             0xffff0000


//+-------------------------------------------------------------------------
//      PFXExportCertStore
//
//  Export the certificates and private keys referenced in the passed-in store 
//
//  This is an old API kept for compatibility with IE4 clients. New applications
//  should call PfxExportCertStoreEx for enhanced security.
//
//  The value passed in the password parameter will be used to encrypt and 
//  verify the integrity of the PFX packet. If any problems encoding the store
//  are encountered, the function will return FALSE and the error code can 
//  be found from GetLastError(). 
//
//  The dwFlags parameter may be set to any combination of 
//      EXPORT_PRIVATE_KEYS
//      REPORT_NO_PRIVATE_KEY
//      REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//  These flags are as documented in the CertExportSafeContents Crypt32 API
//--------------------------------------------------------------------------
BOOL
WINAPI
PFXExportCertStore(
    HCERTSTORE hStore,
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD   dwFlags);


// Flag definitions for PFXImportCertStore
//#define CRYPT_EXPORTABLE        0x00000001  // reserved by wincrypt.h; can't reuse
//#define CRYPT_USER_PROTECTED    0x00000002  // reserved by wincrypt.h; can't reuse
//#define CRYPT_MACHINE_KEYSET    0x00000020  // reserved by wincrypt.h; can't reuse
#define CRYPT_USER_KEYSET         0x00001000     

#define PKCS12_IMPORT_RESERVED_MASK    0xffff0000 

//+-------------------------------------------------------------------------
//      PFXImportCertStore
//
//  Import the PFX blob and return a store containing certificates
//
//  if the password parameter is incorrect or any other problems decoding
//  the PFX blob are encountered, the function will return NULL and the
//      error code can be found from GetLastError(). 
//
//  The dwFlags parameter may be set to the following:
//  CRYPT_EXPORTABLE - specify that any imported keys should be marked as 
//                     exportable (see documentation on CryptImportKey)
//  CRYPT_USER_PROTECTED - (see documentation on CryptImportKey)
//  CRYPT_MACHINE_KEYSET - used to force the private key to be stored in the
//                        the local machine and not the current user.
//  CRYPT_USER_KEYSET - used to force the private key to be stored in the
//                      the current user and not the local machine, even if
//                      the pfx blob specifies that it should go into local machine.
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
PFXImportCertStore(
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD   dwFlags);


//+-------------------------------------------------------------------------
//      IsPFXBlob
//
//  This function will try to decode the outer layer of the blob as a pfx 
//  blob, and if that works it will return TRUE, it will return FALSE otherwise
//
//--------------------------------------------------------------------------
BOOL
WINAPI
PFXIsPFXBlob(
    CRYPT_DATA_BLOB* pPFX);



////////////////////////////////
// New interfaces are c-style

#if defined(__cplusplus)
extern "C" {
#endif

//+-------------------------------------------------------------------------
//      VerifyPassword
//
//  This function will attempt to decode the outer layer of the blob as a pfx 
//  blob and decrypt with the given password. No data from the blob will be imported.
//  Return value is TRUE if password appears correct, FALSE otherwise.
//
//--------------------------------------------------------------------------
BOOL 
WINAPI
PFXVerifyPassword(
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD dwFlags);


//+-------------------------------------------------------------------------
//      PFXExportCertStoreEx
//
//  Export the certificates and private keys referenced in the passed-in store 
//
//  This API encodes the blob under a stronger algorithm. The resulting
//  PKCS12 blobs are incompatible with the earlier APIs.
//
//  The value passed in the password parameter will be used to encrypt and 
//  verify the integrity of the PFX packet. If any problems encoding the store
//  are encountered, the function will return FALSE and the error code can 
//  be found from GetLastError(). 
//
//  The dwFlags parameter may be set to any combination of 
//      EXPORT_PRIVATE_KEYS
//      REPORT_NO_PRIVATE_KEY
//      REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//  These flags are as documented in the CertExportSafeContents Crypt32 API
//--------------------------------------------------------------------------
BOOL
WINAPI
PFXExportCertStoreEx(
    HCERTSTORE hStore,
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    void*   pvReserved,
    DWORD   dwFlags);



#if defined(__cplusplus)
}
#endif

#endif // PFX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs: 
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN UINT cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN UINT cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\scrdcert.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       scrdcert.h
//
//  Contents:   Smart Card Certificate Helper API
//
//  History:    21-Nov-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SCRDCERT_H__)
#define __SCRDCERT_H__

#if defined(__cplusplus)
extern "C" {
#endif 

//
// Register and Unregister a smart card certificate store.  These stores
// appear as physical stores under the Smart Card Logical Store in the 
// Current User location.  When registering a card store, the caller must
// provide the following information:
//
// Card Friendly Name
// Provider Name ( NULL means use the Microsoft Base Smart Card Provider )
// Container Name ( NULL means use the Card Friendly Name )
//
// If a card store of the given name already exists the registration will
// return an error (ERROR_ALREADY_EXISTS) unless the 
// SMART_CARD_STORE_REPLACE_EXISTING flag is used
//

#define SMART_CARD_STORE_REPLACE_EXISTING 0x00000001
         
BOOL WINAPI
I_CryptRegisterSmartCardStore (
       IN LPCWSTR pwszCardName,
       IN OPTIONAL LPCWSTR pwszProvider,
       IN OPTIONAL DWORD dwProviderType,
       IN OPTIONAL LPCWSTR pwszContainer,
       IN DWORD dwFlags
       );

BOOL WINAPI
I_CryptUnregisterSmartCardStore (
       IN LPCWSTR pwszCardName
       );  

//
// Find a smart card certificate in a store
//
// For a certificate to be considered a smart card certificate.  It must have
// the CERT_SMART_CARD_DATA_PROP_ID.  The SMART_CARD_CERT_FIND_DATA can be used
// to place additional filtering on the returned smart card certificates. 
// Optionally, the CERT_SMART_CARD_DATA_PROP_ID value can be returned as well.
// The value can be freed using LocalFree or if the *ppSmartCardData is non NULL 
// will be freed for the caller
//

typedef struct _SMART_CARD_CERT_FIND_DATA {

    DWORD  cbSize;                        
    LPWSTR pwszProvider;
    DWORD  dwProviderType;
    LPWSTR pwszContainer;
    DWORD  dwKeySpec;
    
} SMART_CARD_CERT_FIND_DATA, *PSMART_CARD_CERT_FIND_DATA;

PCCERT_CONTEXT WINAPI
I_CryptFindSmartCardCertInStore (
       IN HCERTSTORE hStore,
       IN PCCERT_CONTEXT pPrevCert,
       IN OPTIONAL PSMART_CARD_CERT_FIND_DATA pFindData,
       IN OUT OPTIONAL PCRYPT_DATA_BLOB* ppSmartCardData
       );
       
//
// Add a smart card certificate to a store and add the specified properties
// to it.
//

BOOL WINAPI
I_CryptAddSmartCardCertToStore (
       IN HCERTSTORE hStore,
       IN PCRYPT_DATA_BLOB pEncodedCert,
       IN OPTIONAL LPWSTR pwszCertFriendlyName,
       IN PCRYPT_DATA_BLOB pSmartCardData,
       IN PCRYPT_KEY_PROV_INFO pKeyProvInfo
       );      
       
//
// Definitions
//

#define MS_BASE_PROVIDER         L"Microsoft Base Cryptographic Provider"
#define MAX_PROVIDER_TYPE_STRLEN 13
#define SMART_CARD_SYSTEM_STORE  L"SmartCard"
                          
#if defined(__cplusplus)
}
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\setcert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       setcert.h
//
//  Contents:   SET X509 Certificate Extension Definitions
//              
//
//  History:    22-Nov-96   philh   created
//--------------------------------------------------------------------------

#ifndef __SETCERT_H__
#define __SETCERT_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Predefined X509 SET certificate extension data structures that can be
//  encoded / decoded.
//--------------------------------------------------------------------------
#define X509_SET_ACCOUNT_ALIAS              ((LPCSTR) 1000)
#define X509_SET_HASHED_ROOT_KEY            ((LPCSTR) 1001)
#define X509_SET_CERTIFICATE_TYPE           ((LPCSTR) 1002)
#define X509_SET_MERCHANT_DATA              ((LPCSTR) 1003)

//+-------------------------------------------------------------------------
//  SET Private Extension Object Identifiers
//--------------------------------------------------------------------------
#define szOID_SET_ACCOUNT_ALIAS         "2.99999.1"
#define szOID_SET_HASHED_ROOT_KEY       "2.99999.2"
#define szOID_SET_CERTIFICATE_TYPE      "2.99999.3"
#define szOID_SET_MERCHANT_DATA         "2.99999.4"

#define SET_ACCOUNT_ALIAS_OBJID         szOID_SET_ACCOUNT_ALIAS
#define SET_HASHED_ROOT_KEY_OBJID       szOID_SET_HASHED_ROOT_KEY
#define SET_CERTIFICATE_TYPE_OBJID      szOID_SET_CERTIFICATE_TYPE
#define SET_MERCHANT_DATA_OBJID         szOID_SET_MERCHANT_DATA

//+-------------------------------------------------------------------------
//  szOID_SET_ACCOUNT_ALIAS private extension
//
//  pvStructInfo points to BOOL.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_SET_HASHED_ROOT_KEY private extension
//
//  pvStructInfo points to: BYTE rgbInfo[SET_HASHED_ROOT_LEN].
//--------------------------------------------------------------------------
#define SET_HASHED_ROOT_LEN 20


//+-------------------------------------------------------------------------
//  szOID_SET_CERTIFICATE_TYPE private extension
//
//  pvStructInfo points to CRYPT_BIT_BLOB.
//--------------------------------------------------------------------------
// BYTE 0
#define SET_CERT_CARD_FLAG          0x80
#define SET_CERT_MER_FLAG           0x40
#define SET_CERT_PGWY_FLAG          0x20
#define SET_CERT_CCA_FLAG           0x10
#define SET_CERT_MCA_FLAG           0x08
#define SET_CERT_PCA_FLAG           0x04
#define SET_CERT_GCA_FLAG           0x02
#define SET_CERT_BCA_FLAG           0x01
// BYTE 1
#define SET_CERT_RCA_FLAG           0x80
#define SET_CERT_ACQ_FLAG           0x40

//+-------------------------------------------------------------------------
//  szOID_SET_MERCHANT_DATA private extension
//
//  pvStructInfo points to following SET_MERCHANT_DATA_INFO
//--------------------------------------------------------------------------
typedef struct _SET_MERCHANT_DATA_INFO {
    LPSTR       pszMerID;
    LPSTR       pszMerAcquirerBIN;
    LPSTR       pszMerTermID;
    LPSTR       pszMerName;
    LPSTR       pszMerCity;
    LPSTR       pszMerStateProvince;
    LPSTR       pszMerPostalCode;
    LPSTR       pszMerCountry;
    LPSTR       pszMerPhone;
    BOOL        fMerPhoneRelease;
    BOOL        fMerAuthFlag;
} SET_MERCHANT_DATA_INFO, *PSET_MERCHANT_DATA_INFO;

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\utf8.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       utf8.h
//
//  Contents:   WideChar (UNICODE) to/from UTF8 APIs
//
//  APIs:       WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

#ifndef __UTF8_H__
#define __UTF8_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    );

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\scp.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : scp.h                                                  //
//  DESCRIPTION   : Crypto Provider prototypes                             //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//	Jan 25 1995 larrys  Changed from Nametag                           //
//      Apr  9 1995 larrys  Removed some APIs                              //
//      Apr 19 1995 larrys  Cleanup                                        //
//      May 10 1995 larrys  added private api calls                        //
//      May 16 1995 larrys  updated to spec                                //
//      Aug 30 1995 larrys  Changed a parameter to IN OUT                  //
//      Oct 06 1995 larrys  Added more APIs                                //
//      OCt 13 1995 larrys  Removed CryptGetHashValue                      //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <time.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

// type definition of a NameTag error
typedef unsigned int NTAG_ERROR;

#define	NTF_FAILED		FALSE
#define	NTF_SUCCEED		TRUE

#define	NTAG_SUCCEEDED(ntag_error)	((ntag_error) == NTF_SUCCEED)
#define	NTAG_FAILED(ntag_error)		((ntag_error) == NTF_FAILED)

#define NASCENT			0x00000002

#define	NTAG_MAXPADSIZE		8
#define	MAXSIGLEN		64

// definitions max length of logon pszUserID parameter
#define	MAXUIDLEN		64

// udp type flag
#define KEP_UDP			1

// Flags for NTagGetPubKey
#define	SIGPUBKEY		0x1000
#define	EXCHPUBKEY		0x2000

/*
 -	CPAcquireContext
 -
 *	Purpose:
 *               The CPAcquireContext function is used to acquire a context
 *               handle to a cryptographic service provider (CSP).
 *
 *
 *	Parameters:
 *               OUT phProv         -  Handle to a CSP
 *               IN  pszContainer   -  Pointer to a string which is the
 *                                     identity of the logged on user
 *               IN  dwFlags        -  Flags values
 *               IN  pVTable        -  Pointer to table of function pointers
 *
 *	Returns:
 */
extern BOOL CPAcquireContext(OUT HCRYPTPROV *phProv,
                      IN CHAR *pszContainer,
                      IN DWORD dwFlags,
                      IN PVTableProvStruc pVTable);

/*
 -      CPReleaseContext
 -
 *      Purpose:
 *               The CPReleaseContext function is used to release a
 *               context created by CryptAcquireContext.
 *
 *     Parameters:
 *               IN  phProv        -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *	Returns:
 */
extern BOOL CPReleaseContext(IN HCRYPTPROV hProv,
                      IN DWORD dwFlags);


/*
 -	CPGenKey
 -
 *	Purpose:
 *                Generate cryptographic keys
 *
 *
 *	Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *	Returns:
 */
extern BOOL CPGenKey(IN HCRYPTPROV hProv,
              IN ALG_ID Algid,
              IN DWORD dwFlags,
              OUT HCRYPTKEY * phKey);

/*
 -  CPDuplicateKey
 -
 *  Purpose:
 *                Duplicates the state of a key and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hKey           -  Handle to a key
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phKey          -  Handle to the new key
 *
 *  Returns:
 */
extern BOOL CPDuplicateKey(IN HCRYPTPROV hUID,
                    IN HCRYPTKEY hKey,
                    IN DWORD *pdwReserved,
                    IN DWORD dwFlags,
                    IN HCRYPTKEY *phKey);

/*
 -	CPDeriveKey
 -
 *	Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *	Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hBaseData -   Handle to base data
 *               IN      dwFlags    -  Flags values
 *               OUT     phKey      -  Handle to a generated key
 *
 *	Returns:
 */
extern BOOL CPDeriveKey(IN HCRYPTPROV hProv,
                 IN ALG_ID Algid,
                 IN HCRYPTHASH hBaseData,
                 IN DWORD dwFlags,
                 OUT HCRYPTKEY * phKey);


/*
 -	CPDestroyKey
 -
 *	Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *	Parameters:
 *               IN      hProv  -  Handle to a CSP
 *               IN      hKey   -  Handle to a key
 *
 *	Returns:
 */
extern BOOL CPDestroyKey(IN HCRYPTPROV hProv,
                  IN HCRYPTKEY hKey);



/*
 -	CPSetKeyParam
 -
 *	Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *	Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *	Returns:
 */
extern BOOL CPSetKeyParam(IN HCRYPTPROV hProv,
                   IN HCRYPTKEY hKey,
                   IN DWORD dwParam,
                   IN BYTE *pbData,
                   IN DWORD dwFlags);



/*
 -	CPGetKeyParam
 -
 *	Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *	Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *	Returns:
 */
extern BOOL CPGetKeyParam(IN HCRYPTPROV hProv,
                   IN HCRYPTKEY hKey,
                   IN DWORD dwParam,
                   OUT BYTE *pbData,
                   IN DWORD *pdwDataLen,
                   IN DWORD dwFlags);


/*
 -	CPSetProvParam
 -
 *	Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *	Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *	Returns:
 */
extern BOOL CPSetProvParam(IN HCRYPTPROV hProv,
                    IN DWORD dwParam,
                    IN BYTE *pbData,
                    IN DWORD dwFlags);



/*
 -	CPGetProvParam
 -
 *	Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *	Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN OUT  pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *	Returns:
 */
extern BOOL CPGetProvParam(IN HCRYPTPROV hProv,
                    IN DWORD dwParam,
                    OUT BYTE *pbData,
                    IN OUT DWORD *pdwDataLen,
                    IN DWORD dwFlags);


/*
 -	CPSetHashParam
 -
 *	Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *	Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *	Returns:
 */
extern BOOL CPSetHashParam(IN HCRYPTPROV hProv,
                    IN HCRYPTHASH hHash,
                    IN DWORD dwParam,
                    IN BYTE *pbData,
                    IN DWORD dwFlags);



/*
 -	CPGetHashParam
 -
 *	Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *	Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *	Returns:
 */
extern BOOL CPGetHashParam(IN HCRYPTPROV hProv,
                    IN HCRYPTHASH hHash,
                    IN DWORD dwParam,
                    OUT BYTE *pbData,
                    IN DWORD *pdwDataLen,
                    IN DWORD dwFlags);



/*
 -	CPExportKey
 -
 *	Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *	Parameters:
 *               IN  hProv         - Handle to the CSP user
 *               IN  hKey          - Handle to the key to export
 *               IN  hPubKey       - Handle to exchange public key value of
 *                                   the destination user
 *               IN  dwBlobType    - Type of key blob to be exported
 *               IN  dwFlags       - Flags values
 *               OUT pbData        -     Key blob data
 *               IN OUT pdwDataLen - Length of key blob in bytes
 *
 *	Returns:
 */
extern BOOL CPExportKey(IN HCRYPTPROV hProv,
                 IN HCRYPTKEY hKey,
                 IN HCRYPTKEY hPubKey,
                 IN DWORD dwBlobType,
                 IN DWORD dwFlags,
                 OUT BYTE *pbData,
                 IN OUT DWORD *pdwDataLen);



/*
 -	CPImportKey
 -
 *	Purpose:
 *                Import cryptographic keys
 *
 *
 *	Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *	Returns:
 */
extern BOOL CPImportKey(IN HCRYPTPROV hProv,
                 IN CONST BYTE *pbData,
                 IN DWORD dwDataLen,
                 IN HCRYPTKEY hPubKey,
                 IN DWORD dwFlags,
                 OUT HCRYPTKEY *phKey);



/*
 -	CPEncrypt
 -
 *	Purpose:
 *                Encrypt data
 *
 *
 *	Parameters:
 *               IN  hProv         -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *	Returns:
 */
extern BOOL CPEncrypt(IN HCRYPTPROV hProv,
               IN HCRYPTKEY hKey,
               IN HCRYPTHASH hHash,
               IN BOOL Final,
               IN DWORD dwFlags,
               IN OUT BYTE *pbData,
               IN OUT DWORD *pdwDataLen,
               IN DWORD dwBufLen);



/*
 -	CPDecrypt
 -
 *	Purpose:
 *                Decrypt data
 *
 *
 *	Parameters:
 *               IN  hProv         -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *	Returns:
 */
extern BOOL CPDecrypt(IN HCRYPTPROV hProv,
               IN HCRYPTKEY hKey,
               IN HCRYPTHASH hHash,
               IN BOOL Final,
               IN DWORD dwFlags,
               IN OUT BYTE *pbData,
               IN OUT DWORD *pdwDataLen);


/*
 -	CPCreateHash
 -
 *	Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *	Parameters:
 *               IN  hUID    -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey   -   Optional handle to a key
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *	Returns:
 */
extern BOOL CPCreateHash(IN HCRYPTPROV hProv,
                  IN ALG_ID Algid,
                  IN HCRYPTKEY hKey,
                  IN DWORD dwFlags,
                  OUT HCRYPTHASH *phHash);

/*
 -  CPDuplicateHash
 -
 *  Purpose:
 *                Duplicates the state of a hash and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hHash          -  Handle to a hash
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phHash         -  Handle to the new hash
 *
 *  Returns:
 */
extern BOOL CPDuplicateHash(IN HCRYPTPROV hUID,
                    IN HCRYPTHASH hHash,
                    IN DWORD *pdwReserved,
                    IN DWORD dwFlags,
                    IN HCRYPTHASH *phHash);


/*
 -	CPHashData
 -
 *	Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *	Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *	Returns:
 */
extern BOOL CPHashData(IN  HCRYPTPROV hProv,
                IN  HCRYPTHASH hHash,
                IN  CONST BYTE *pbData,
                IN  DWORD dwDataLen,
                IN  DWORD dwFlags);


/*
 -	CPHashSessionKey
 -
 *	Purpose:
 *                Compute the cryptograghic hash on a key object.
 *
 *
 *	Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *	Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */
extern BOOL CPHashSessionKey(IN HCRYPTPROV hProv,
                      IN HCRYPTHASH hHash,
                      IN  HCRYPTKEY hKey,
                      IN DWORD dwFlags);


/*
 -	CPDestroyHash
 -
 *	Purpose:
 *                Destroy the hash object
 *
 *
 *	Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *
 *	Returns:
 */
extern BOOL CPDestroyHash(IN HCRYPTPROV hProv,
                   IN HCRYPTHASH hHash);



/*
 -	CPSignHash
 -
 *	Purpose:
 *                Create a digital signature from a hash
 *
 *
 *	Parameters:
 *               IN  hProv        -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair to that is used to sign with
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignature  -  Pointer to signature data
 *               IN OUT dwHashLen -  Pointer to the len of the signature data
 *
 *	Returns:
 */
extern BOOL CPSignHash(IN     HCRYPTPROV hProv,
                IN     HCRYPTHASH hHash,
                IN     DWORD dwKeySpec,
                IN     LPCWSTR sDescription,
                IN     DWORD dwFlags,
                OUT    BYTE *pbSignature,
                IN OUT DWORD *pdwSigLen);

/*
 -	CPVerifySignature
 -
 *	Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *	Parameters:
 *               IN  hProv        -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *	Returns:
 */
extern BOOL CPVerifySignature(IN HCRYPTPROV hProv,
                       IN HCRYPTHASH hHash,
                       IN CONST BYTE *pbSignature,
                       IN DWORD dwSigLen,
                       IN HCRYPTKEY hPubKey,
                       IN LPCWSTR sDescription,
                       IN DWORD dwFlags);


/*
 -	CPGenRandom
 -
 *	Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *	Parameters:
 *               IN  hProv         -  Handle to the user identifcation
 *               IN  dwLen         -  Number of bytes of random data requested
 *               IN OUT pbBuffer   -  Pointer to the buffer where the random
 *                                    bytes are to be placed
 *
 *	Returns:
 */
extern BOOL CPGenRandom(IN HCRYPTPROV hProv,
                 IN DWORD dwLen,
                 IN OUT BYTE *pbBuffer);


/*
 -	CPGetUserKey
 -
 *	Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *	Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *	Returns:
 */
extern BOOL CPGetUserKey(IN HCRYPTPROV hProv,
                  IN DWORD dwKeySpec,
                  OUT HCRYPTKEY *phUserKey);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\wintrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996-1998
//
//  File:       wintrust.h
//
//  Contents:   Microsoft Internet Security Trust Provider Model
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WINTRUST_H
#define WINTRUST_H

#include    <wincrypt.h>

#ifdef __cplusplus
extern "C"
{
#endif


#ifndef WIN_CERT_REVISION_1_0   // there were duplicate definitions in winbase.h
#   define  WT_DEFINE_ALL_APIS
#else
#   undef   WT_DEFINE_ALL_APIS
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//      Client definitions, typedefs, and prototypes
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_DATA Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust to pass necessary information into
//  the Providers.
//
typedef struct _WINTRUST_DATA
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)

    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.

    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
#                       define      WTD_UI_ALL              1
#                       define      WTD_UI_NONE             2
#                       define      WTD_UI_NOBAD            3
#                       define      WTD_UI_NOGOOD           4

    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
#                       define      WTD_REVOKE_NONE         0x00000000
#                       define      WTD_REVOKE_WHOLECHAIN   0x00000001

    DWORD           dwUnionChoice;              // required: which structure is being passed in?
#                       define      WTD_CHOICE_FILE         1
#                       define      WTD_CHOICE_CATALOG      2
#                       define      WTD_CHOICE_BLOB         3
#                       define      WTD_CHOICE_SIGNER       4
#                       define      WTD_CHOICE_CERT         5
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };

    DWORD           dwStateAction;                      // optional (Catalog File Processing)
#                       define      WTD_STATEACTION_IGNORE           0x00000000
#                       define      WTD_STATEACTION_VERIFY           0x00000001
#                       define      WTD_STATEACTION_CLOSE            0x00000002
#                       define      WTD_STATEACTION_AUTO_CACHE       0x00000003
#                       define      WTD_STATEACTION_AUTO_CACHE_FLUSH 0x00000004

    HANDLE          hWVTStateData;                      // optional (Catalog File Processing)

    WCHAR           *pwszURLReference;          // optional: (future) used to determine zone.

    // 17-Feb-1998 philh: added
    DWORD           dwProvFlags;
#       define WTD_PROV_FLAGS_MASK                      0x0000FFFF
#       define WTD_USE_IE4_TRUST_FLAG                   0x00000001
#       define WTD_NO_IE4_CHAIN_FLAG                    0x00000002
#       define WTD_NO_POLICY_USAGE_FLAG                 0x00000004
#       define WTD_REVOCATION_CHECK_NONE                0x00000010
#       define WTD_REVOCATION_CHECK_END_CERT            0x00000020
#       define WTD_REVOCATION_CHECK_CHAIN               0x00000040
#       define WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT  0x00000080
} WINTRUST_DATA, *PWINTRUST_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_FILE_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against an individual file.
//
typedef struct WINTRUST_FILE_INFO_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)

    LPCWSTR         pcwszFilePath;              // required, file name to be verified
    HANDLE          hFile;                      // optional, open handle to pcwszFilePath

    // 09-Dec-1997 pberkman: added
    GUID            *pgKnownSubject;            // optional: fill if the subject type is known.

} WINTRUST_FILE_INFO, *PWINTRUST_FILE_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CATALOG_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a member of a Microsoft Catalog
//  file.
//
typedef struct WINTRUST_CATALOG_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_CATALOG_INFO)

    DWORD           dwCatalogVersion;       // optional: Catalog version number
    LPCWSTR         pcwszCatalogFilePath;   // required: path/name to Catalog file

    LPCWSTR         pcwszMemberTag;         // required: tag to member in Catalog
    LPCWSTR         pcwszMemberFilePath;    // required: path/name to member file
    HANDLE          hMemberFile;            // optional: open handle to pcwszMemberFilePath

    // 30-Oct-1997 pberkman: added
    BYTE            *pbCalculatedFileHash;  // optional: pass in the calculated hash
    DWORD           cbCalculatedFileHash;   // optional: pass in the count bytes of the calc hash

    // 15-Jan-1998 pberkman: added
    PCCTL_CONTEXT   pcCatalogContext;       // optional: pass in to use instead of CatalogFilePath.

} WINTRUST_CATALOG_INFO, *PWINTRUST_CATALOG_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_BLOB_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a memory blob.
//
typedef struct WINTRUST_BLOB_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_BLOB_INFO)

    GUID            gSubject;               // SIP to load

    LPCWSTR         pcwszDisplayName;       // display name of object

    DWORD           cbMemObject;
    BYTE            *pbMemObject;

    DWORD           cbMemSignedMsg;
    BYTE            *pbMemSignedMsg;

} WINTRUST_BLOB_INFO, *PWINTRUST_BLOB_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_SGNR_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CMSG_SIGNER_INFO Structure
//
typedef struct WINTRUST_SGNR_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_SGNR_INFO)

    LPCWSTR         pcwszDisplayName;       // name of the "thing" the pbMem is pointing to.

    CMSG_SIGNER_INFO *psSignerInfo;

    DWORD           chStores;               // number of stores in pahStores
    HCERTSTORE      *pahStores;             // array of stores to add to internal list

} WINTRUST_SGNR_INFO, *PWINTRUST_SGNR_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CERT_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CERT_CONTEXT Structure
//
typedef struct WINTRUST_CERT_INFO_
{
    DWORD           cbStruct;               // = sizeof(WINTRUST_CERT_INFO)

    LPCWSTR         pcwszDisplayName;       // display name

    CERT_CONTEXT    *psCertContext;

    DWORD           chStores;               // number of stores in pahStores
    HCERTSTORE      *pahStores;             // array of stores to add to internal list

    // 17-Nov-1997 pberkman: added
    DWORD           dwFlags;
#                       define      WTCI_DONT_OPEN_STORES   0x00000001  // only open dummy "root" all other are in pahStores.
#                       define      WTCI_OPEN_ONLY_ROOT     0x00000002

    // 26-Nov-1997 pberkman: added
    FILETIME        *psftVerifyAsOf;        // if not null, each cert will be validated as of this time.

} WINTRUST_CERT_INFO, *PWINTRUST_CERT_INFO;

#include <poppack.h>


//////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrust
//----------------------------------------------------------------------------
//  Exported from WINTRUST.DLL.
//  Call this function to verify the trust based on a digital signer.
//
//  Returns:
//          ERROR_SUCCESS               If the trust is authenticated or
//                                      if the user accepted the risk.
//
//          TRUST_E_PROVIDER_UNKNOWN    there was an error loading one of the
//                                      required Providers.
//
//          all error codes passed back are based on the Policy Provider used.
//
extern LONG WINAPI WinVerifyTrust(HWND hwnd, GUID *pgActionID,
                                  LPVOID pWVTData);


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//      Trust, Policy, and UI Provider definitions, typedefs, and prototypes
//
//  Model:
//      A client wishing to validate trust through WinVerifyTrust will
//      select an appropriate Action ID guid for the call.
//      This guid is defined by each Policy Provider and represents the
//      functions called based on the policy for the given object.
//
//      In this model, the Policy Provider determines which style of UI
//      will be shown to the user (this only applies to style, the
//      determination of whether UI is displayed is set by the calling client
//      in the UI flags member of WINTRUST_DATA).
//
//      Since the function entry points are common (same return value and
//      parameters), it allows Policy Provider developers to take advantage
//      of existing, generic, code to fill the CRYPT_PROVIDER_DATA structure.
//
//      This also allows the developer to simply add the specific policy they
//      need, then, call the generic Policy Provider - if appropriate.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Wintrust Policy Flags
//----------------------------------------------------------------------------
//  These are set during install and can be modified by the user
//  through various means.  The SETREG.EXE utility (found in the Authenticode
//  Tools Pack) will select/deselect each of them.
//
#define WTPF_TRUSTTEST              0x00000020  // trust any "TEST" certificate
#define WTPF_TESTCANBEVALID         0x00000080
#define WTPF_IGNOREEXPIRATION       0x00000100  // Use expiration date
#define WTPF_IGNOREREVOKATION       0x00000200  // Do revocation check
#define WTPF_OFFLINEOK_IND          0x00000400  // off-line is ok individual certs
#define WTPF_OFFLINEOK_COM          0x00000800  // off-line is ok commercial certs
#define WTPF_OFFLINEOKNBU_IND       0x00001000  // off-line is ok individual certs, no bad ui
#define WTPF_OFFLINEOKNBU_COM       0x00002000  // off-line is ok commercial certs, no bad ui
#define WTPF_VERIFY_V1_OFF          0x00010000  // turn verify of v1 certs off
#define WTPF_IGNOREREVOCATIONONTS   0x00020000  // ignore TimeStamp revocation checks
#define WTPF_ALLOWONLYPERTRUST      0x00040000  // allow only items in personal trust db.

//////////////////////////////////////////////////////////////////////////////
//
// WintrustGetRegPolicyFlags
//----------------------------------------------------------------------------
//  This API call is exported from WINTRUST.DLL and is the recommended method
//  of retrieving the DWORD representing the Policy Flags.
//
extern void WINAPI      WintrustGetRegPolicyFlags(DWORD *pdwPolicyFlags);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustSetRegPolicyFlags
//----------------------------------------------------------------------------
//  This API call is exported from WINTRUST.DLL and is the recommended method
//  of setting the DWORD representing the Policy Flags.  MAKE SURE to call
//  WintrustGetRegPolicyFlags to get the current value and or/and the value
//  you need then call the set the flags.
//
extern BOOL WINAPI      WintrustSetRegPolicyFlags(DWORD dwPolicyFlags);



//////////////////////////////////////////////////////////////////////////////
//
// Trust Provider "Step" Error defines
//----------------------------------------------------------------------------
//  Each "step" of the Trust process has an error "slot" associated with it.
//  If an error occurs, the "step" will assign its result to this "slot".  These
//  errors can be any valid WINERROR.H HRESULT code.
//

    //
    //  step errors 0 through 20 are reserved for Authenticode specific.  If
    //  you are not calling any of the SOFTPUB.DLL (Authenticode) providers, you
    //  may use these as needed.
    //
#define TRUSTERROR_STEP_WVTPARAMS                   0
#define TRUSTERROR_STEP_FILEIO                      2
#define TRUSTERROR_STEP_SIP                         3
#define TRUSTERROR_STEP_SIPSUBJINFO                 5
#define TRUSTERROR_STEP_CATALOGFILE                 6
#define TRUSTERROR_STEP_CERTSTORE                   7
#define TRUSTERROR_STEP_MESSAGE                     8
#define TRUSTERROR_STEP_MSG_SIGNERCOUNT             9
#define TRUSTERROR_STEP_MSG_INNERCNTTYPE            10
#define TRUSTERROR_STEP_MSG_INNERCNT                11
#define TRUSTERROR_STEP_MSG_STORE                   12
#define TRUSTERROR_STEP_MSG_SIGNERINFO              13
#define TRUSTERROR_STEP_MSG_SIGNERCERT              14
#define TRUSTERROR_STEP_MSG_CERTCHAIN               15
#define TRUSTERROR_STEP_MSG_COUNTERSIGINFO          16
#define TRUSTERROR_STEP_MSG_COUNTERSIGCERT          17
#define TRUSTERROR_STEP_VERIFY_MSGHASH              18
#define TRUSTERROR_STEP_VERIFY_MSGINDIRECTDATA      19

    //
    //  step errors 30 through 37 are reserved for the ending error code for each
    //  entry point in the Trust Model.
    //
#define TRUSTERROR_STEP_FINAL_WVTINIT               30
#define TRUSTERROR_STEP_FINAL_INITPROV              31
#define TRUSTERROR_STEP_FINAL_OBJPROV               32
#define TRUSTERROR_STEP_FINAL_SIGPROV               33
#define TRUSTERROR_STEP_FINAL_CERTPROV              34
#define TRUSTERROR_STEP_FINAL_CERTCHKPROV           35
#define TRUSTERROR_STEP_FINAL_POLICYPROV            36
#define TRUSTERROR_STEP_FINAL_UIPROV                37

#define TRUSTERROR_MAX_STEPS                        38

//////////////////////////////////////////////////////////////////////////////
//
//  allocation and free function prototypes
//----------------------------------------------------------------------------
//
typedef void        *(*PFN_CPD_MEM_ALLOC)(IN DWORD cbSize);
typedef void        (*PFN_CPD_MEM_FREE)(IN void *pvMem2Free);

typedef BOOL        (*PFN_CPD_ADD_STORE)(IN struct _CRYPT_PROVIDER_DATA *pProvData,
                                         IN HCERTSTORE hStore2Add);

typedef BOOL        (*PFN_CPD_ADD_SGNR)(IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                        IN          BOOL fCounterSigner,
                                        IN OPTIONAL DWORD idxSigner,
                                        IN          struct _CRYPT_PROVIDER_SGNR *pSgnr2Add);

typedef BOOL        (*PFN_CPD_ADD_CERT)(IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                        IN          DWORD idxSigner,
                                        IN          BOOL fCounterSigner,
                                        IN OPTIONAL DWORD idxCounterSigner,
                                        IN          PCCERT_CONTEXT pCert2Add);

typedef BOOL        (*PFN_CPD_ADD_PRIVDATA)(IN struct _CRYPT_PROVIDER_DATA *pProvData,
                                            IN struct _CRYPT_PROVIDER_PRIVDATA *pPrivData2Add);

//////////////////////////////////////////////////////////////////////////////
//
//  Provider function prototypes
//----------------------------------------------------------------------------
//

//
//  entry point for the object provider
//
typedef HRESULT     (*PFN_PROVIDER_INIT_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the object provider
//
typedef HRESULT     (*PFN_PROVIDER_OBJTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Signature Provider
//
typedef HRESULT     (*PFN_PROVIDER_SIGTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Certificate Provider
//
typedef HRESULT     (*PFN_PROVIDER_CERTTRUST_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's final call (from the trust provider)
//
typedef HRESULT     (*PFN_PROVIDER_FINALPOLICY_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's "dump structure" call
//
typedef HRESULT     (*PFN_PROVIDER_TESTFINALPOLICY_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's clean up routine for any PRIVDATA allocated
//
typedef HRESULT     (*PFN_PROVIDER_CLEANUP_CALL)(IN OUT struct _CRYPT_PROVIDER_DATA *pProvData);

//
//  entry point for the Policy Provider's Cert Check call.  This will return
//  true if the Trust Provider is to continue building the certificate chain.
//  If the PP returns FALSE, it is assumed that we have reached a "TRUSTED",
//  self-signed, root.  it is also the CertCheck's responsibility to set the
//  fTrustedRoot flag in the certificate structure.
//
typedef BOOL        (*PFN_PROVIDER_CERTCHKPOLICY_CALL)( IN          struct _CRYPT_PROVIDER_DATA *pProvData,
                                                        IN          DWORD idxSigner,
                                                        IN          BOOL fCounterSignerChain,
                                                        IN OPTIONAL DWORD idxCounterSigner);


#define WVT_OFFSETOF(t,f)   ((ULONG)((ULONG_PTR)(&((t*)0)->f)))

#define WVT_ISINSTRUCT(structtypedef, structpassedsize, member) \
                    ((WVT_OFFSETOF(structtypedef, member) < structpassedsize) ? TRUE : FALSE)


#define WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(structtypedef, structpassedsize, member) \
                    WVT_ISINSTRUCT(structtypedef, structpassedsize, member)

#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_DATA Structure
//----------------------------------------------------------------------------
//  Used to pass information between WinVerifyTrust and all of the Provider
//  calls.
//
//  IMPORTANT:  1.  All dynamically allocated members MUST use the allocation
//                  and Add2 functions provided.
//
typedef struct _CRYPT_PROVIDER_DATA
{
    DWORD                               cbStruct;               // = sizeof(TRUST_PROVIDER_DATA) (set in WVT)

    WINTRUST_DATA                       *pWintrustData;         // NOT verified (set in WVT)
    BOOL                                fOpenedFile;            // the provider opened the file handle (if applicable)
    HWND                                hWndParent;             // if passed in, else, Desktop hWnd (set in WVT).
    GUID                                *pgActionID;            // represents the Provider combination (set in WVT).

    HCRYPTPROV                          hProv;                  // set to NULL to let CryptoAPI to assign.

    DWORD                               dwError;                // error if a low-level, system error was encountered

    DWORD                               dwRegSecuritySettings;  // ie security settings (set in WVT)
    DWORD                               dwRegPolicySettings;    // setreg settings (set in WVT)

    struct _CRYPT_PROVIDER_FUNCTIONS    *psPfns;                // set in WVT.

    DWORD                               cdwTrustStepErrors;     // set in WVT.
    DWORD                               *padwTrustStepErrors;   // allocated in WVT.  filled in WVT & Trust Provider

    DWORD                               chStores;               // number of stores in pahStores (root set in WVT)
    HCERTSTORE                          *pahStores;             // array of known stores (root set in WVT) root is ALWAYS #0!!!

    DWORD                               dwEncoding;             // message encoding type (set in WVT and Signature Prov)
    HCRYPTMSG                           hMsg;                   // set in Signature Prov.

    DWORD                               csSigners;              // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_SGNR         *pasSigners;            // use Add2 and Get functions!

    DWORD                               csProvPrivData;         // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_PRIVDATA     *pasProvPrivData;       // use Add2 and Get functions!

    DWORD                               dwSubjectChoice;
#                       define              CPD_CHOICE_SIP          1

    union
    {
        struct _PROVDATA_SIP            *pPDSip;
    };

    char                                *pszUsageOID;           // set in Init Provider

    // 03-Oct-1997 pberkman: added
    BOOL                                fRecallWithState;       // state was maintained for Catalog Files.

    // 10-Nov-1997 pberkman: added
    FILETIME                            sftSystemTime;

    // 16-Jan-1998 pberkman: added
    char                                *pszCTLSignerUsageOID;

    // 17-Feb-1998 philh: added
    // LOWORD intialized from WINTRUST_DATA's dwProvFlags.
    //
    // Debug version reads "DEBUG_TRUST_PROV_FLAGS" environment variable
    // and OR's with WINTRUST_DATA's dwProvFlags to initialize the LOWORD.
    DWORD                               dwProvFlags;
#       define CPD_USE_NT5_CHAIN_FLAG                   0x80000000
#       define CPD_REVOCATION_CHECK_NONE                0x00010000
#       define CPD_REVOCATION_CHECK_END_CERT            0x00020000
#       define CPD_REVOCATION_CHECK_CHAIN               0x00040000
#       define CPD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT  0x00080000

    // 24-Feb-1998 philh: added
    DWORD                               dwFinalError;

    // 20-May-1998 KeithV: added
    PCERT_USAGE_MATCH					pRequestUsage;

} CRYPT_PROVIDER_DATA, *PCRYPT_PROVIDER_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_FUNCTIONS structure
//----------------------------------------------------------------------------
//
typedef struct _CRYPT_PROVIDER_FUNCTIONS
{
    DWORD                               cbStruct;

    PFN_CPD_MEM_ALLOC                   pfnAlloc;               // set in WVT
    PFN_CPD_MEM_FREE                    pfnFree;                // set in WVT

    PFN_CPD_ADD_STORE                   pfnAddStore2Chain;      // call to add a store to the chain.
    PFN_CPD_ADD_SGNR                    pfnAddSgnr2Chain;       // call to add a sgnr struct to a msg struct sgnr chain
    PFN_CPD_ADD_CERT                    pfnAddCert2Chain;       // call to add a cert struct to a sgnr struct cert chain
    PFN_CPD_ADD_PRIVDATA                pfnAddPrivData2Chain;   // call to add provider private data to struct.

    PFN_PROVIDER_INIT_CALL              pfnInitialize;          // initialize Policy data.
    PFN_PROVIDER_OBJTRUST_CALL          pfnObjectTrust;         // build info up to the signer info(s).
    PFN_PROVIDER_SIGTRUST_CALL          pfnSignatureTrust;      // build info to the signing cert
    PFN_PROVIDER_CERTTRUST_CALL         pfnCertificateTrust;    // build the chain
    PFN_PROVIDER_FINALPOLICY_CALL       pfnFinalPolicy;         // final call to policy
    PFN_PROVIDER_CERTCHKPOLICY_CALL     pfnCertCheckPolicy;     // check each cert will building chain
    PFN_PROVIDER_TESTFINALPOLICY_CALL   pfnTestFinalPolicy;     // dump structures to a file (or whatever the policy chooses)

    struct _CRYPT_PROVUI_FUNCS          *psUIpfns;

                    // 23-Jul-1997 pberkman: added
    PFN_PROVIDER_CLEANUP_CALL           pfnCleanupPolicy;       // PRIVDATA cleanup routine.

} CRYPT_PROVIDER_FUNCTIONS, *PCRYPT_PROVIDER_FUNCTIONS;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVUI_FUNCS structure
//----------------------------------------------------------------------------
//

typedef BOOL        (*PFN_PROVUI_CALL)(IN HWND hWndSecurityDialog, IN struct _CRYPT_PROVIDER_DATA *pProvData);

typedef struct _CRYPT_PROVUI_FUNCS
{
    DWORD                               cbStruct;

    struct _CRYPT_PROVUI_DATA           *psUIData;

    PFN_PROVUI_CALL                     pfnOnMoreInfoClick;
    PFN_PROVUI_CALL                     pfnOnMoreInfoClickDefault;

    PFN_PROVUI_CALL                     pfnOnAdvancedClick;
    PFN_PROVUI_CALL                     pfnOnAdvancedClickDefault;

} CRYPT_PROVUI_FUNCS, *PCRYPT_PROVUI_FUNCS;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVUI_DATA
//----------------------------------------------------------------------------
//
typedef struct _CRYPT_PROVUI_DATA
{
    DWORD                               cbStruct;

    DWORD                               dwFinalError;

    WCHAR                               *pYesButtonText;        // default: "&Yes"
    WCHAR                               *pNoButtonText;         // default: "&No"
    WCHAR                               *pMoreInfoButtonText;   // default: "&More Info"
    WCHAR                               *pAdvancedLinkText;     // default: <none>

    // 15-Sep-1997 pberkman: added
        // good: default:
                // "Do you want to install and run ""%1"" signed on %2 and distributed by:"
    WCHAR                               *pCopyActionText;
        // good no time stamp: default:
                // "Do you want to install and run ""%1"" signed on an unknown date/time and distributed by:"
    WCHAR                               *pCopyActionTextNoTS;
        // bad: default:
                // "Do you want to install and run ""%1""?"
    WCHAR                               *pCopyActionTextNotSigned;


} CRYPT_PROVUI_DATA, *PCRYPT_PROVUI_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_SGNR structure
//----------------------------------------------------------------------------
//  After the Signature Provider is finished there will be zero to many of these
//  filled out.  One for each signer of the message.  Also, there will be zero
//  to many of these filled out inside this structure.  One for each counter
//  signer of the signer.
//
//  IMPORTANT:  1.  All dynamically allocated members MUST use allocation
//                  and Add2 functions provided.
//
typedef struct _CRYPT_PROVIDER_SGNR
{
    DWORD                               cbStruct;

    FILETIME                            sftVerifyAsOf;      // either today's filetime or the timestamps

    DWORD                               csCertChain;        // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_CERT         *pasCertChain;      // use Add2 and Get functions!

    DWORD                               dwSignerType;       // set if known by policy
#                                           define  SGNR_TYPE_TIMESTAMP     0x00000010

    CMSG_SIGNER_INFO                    *psSigner;          // must use the pfnAlloc allocator!

    DWORD                               dwError;            // error encounted while building/verifying the signer.

    DWORD                               csCounterSigners;   // use Add2 and Get functions!
    struct _CRYPT_PROVIDER_SGNR         *pasCounterSigners; // use Add2 and Get functions!

    // 11-Feb-1998 philh: added
    PCCERT_CHAIN_CONTEXT                pChainContext;

} CRYPT_PROVIDER_SGNR, *PCRYPT_PROVIDER_SGNR;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_CERT structure
//----------------------------------------------------------------------------
//  After the Signature and Certificate Providers are finished there will
//  be zero to many of these filled out in the CRYPT_PROVIDER_SGNR
//  structure.  One for each certificate in the chain.
//
//
typedef struct _CRYPT_PROVIDER_CERT
{
    DWORD                               cbStruct;

    PCCERT_CONTEXT                      pCert;              // must have its own ref-count!

    BOOL                                fCommercial;
    BOOL                                fTrustedRoot;       // certchk policy should set this.
    BOOL                                fSelfSigned;        // set in cert provider

    BOOL                                fTestCert;          // certchk policy will set

    DWORD                               dwRevokedReason;

    DWORD                               dwConfidence;       // set in the Certificate Provider
#                                           define  CERT_CONFIDENCE_SIG             0x10000000  // this cert
#                                           define  CERT_CONFIDENCE_TIME            0x01000000  // issuer cert
#                                           define  CERT_CONFIDENCE_TIMENEST        0x00100000  // this cert
#                                           define  CERT_CONFIDENCE_AUTHIDEXT       0x00010000  // this cert
#                                           define  CERT_CONFIDENCE_HYGIENE         0x00001000  // this cert
#                                           define  CERT_CONFIDENCE_HIGHEST         0x11111000

    DWORD                               dwError;

    CTL_CONTEXT                         *pTrustListContext;

    // 16-Jan-1998 pberkman: added
    BOOL                                fTrustListSignerCert;

    // 25-Feb-1998 philh: added
    //
    // The following two are only applicable to Self Signed certificates
    // residing in a CTL.
    PCCTL_CONTEXT                       pCtlContext;
    DWORD                               dwCtlError;

    // 12-Mar-1998 philh: added
    BOOL                                fIsCyclic;

} CRYPT_PROVIDER_CERT, *PCRYPT_PROVIDER_CERT;

//////////////////////////////////////////////////////////////////////////////
//
// CRYPT_PROVIDER_PRIVDATA structure
//----------------------------------------------------------------------------
//  This structure is to allow Policy Provider functions to share
//  POLICY SPECIFIC data between Policy Functions.
//  The Policy must use the pfnAddPrivateData2Chain function and
//  must free any data within the member before the Final Policy returns
//  to WVT.
//  To allow multiple providers to use this feature, each provider that
//  uses this member must set the provider ID to it's Action ID so that
//  the provider can find its data and ignore any other.
//
typedef struct _CRYPT_PROVIDER_PRIVDATA
{
    DWORD                               cbStruct;

    GUID                                gProviderID;

    DWORD                               cbProvData;
    void                                *pvProvData;

} CRYPT_PROVIDER_PRIVDATA, *PCRYPT_PROVIDER_PRIVDATA;

//////////////////////////////////////////////////////////////////////////////
//
// PROVDATA_SIP
//----------------------------------------------------------------------------
//
typedef struct _PROVDATA_SIP
{
    DWORD                               cbStruct;               // = sizeof(PROVDATA_SIP)

    GUID                                gSubject;               // subject guid of file/member file. (set in Sig Prov)

    struct SIP_DISPATCH_INFO_           *pSip;                  // set in Sig Prov - defined in sipbase.h
    struct SIP_DISPATCH_INFO_           *pCATSip;               // set in Sig Prov - defined in sipbase.h
    struct SIP_SUBJECTINFO_             *psSipSubjectInfo;      // set in Sig Prov - defined in sipbase.h
    struct SIP_SUBJECTINFO_             *psSipCATSubjectInfo;   // set in Sig Prov - defined in sipbase.h
    struct SIP_INDIRECT_DATA_           *psIndirectData;        // set in Sig Prov - defined in sipbase.h

} PROVDATA_SIP, *PPROVDATA_SIP;

//////////////////////////////////////////////////////////////////////////////
//
// structures used to register action IDs
//----------------------------------------------------------------------------
//
#define WT_CURRENT_VERSION                  0x00000200

typedef struct _CRYPT_TRUST_REG_ENTRY
{
    DWORD                               cbStruct;

    WCHAR                               *pwszDLLName;
    WCHAR                               *pwszFunctionName;  // no more than WT_MAX_FUNC_NAME!

} CRYPT_TRUST_REG_ENTRY, *PCRYPT_TRUST_REG_ENTRY;

typedef struct _CRYPT_REGISTER_ACTIONID
{
    DWORD                               cbStruct;

    CRYPT_TRUST_REG_ENTRY               sInitProvider;
    CRYPT_TRUST_REG_ENTRY               sObjectProvider;
    CRYPT_TRUST_REG_ENTRY               sSignatureProvider;
    CRYPT_TRUST_REG_ENTRY               sCertificateProvider;
    CRYPT_TRUST_REG_ENTRY               sCertificatePolicyProvider;
    CRYPT_TRUST_REG_ENTRY               sFinalPolicyProvider;
    CRYPT_TRUST_REG_ENTRY               sTestPolicyProvider;

                    // 23-Jul-1997 pberkman: added
    CRYPT_TRUST_REG_ENTRY               sCleanupProvider;

} CRYPT_REGISTER_ACTIONID, *PCRYPT_REGISTER_ACTIONID;

typedef BOOL (*PFN_ALLOCANDFILLDEFUSAGE)(IN const char *pszUsageOID,
                                         IN struct _CRYPT_PROVIDER_DEFUSAGE *psDefUsage);
typedef BOOL (*PFN_FREEDEFUSAGE)(IN const char *pszUsageOID,
                                 IN struct _CRYPT_PROVIDER_DEFUSAGE *psDefUsage);

typedef struct _CRYPT_PROVIDER_REGDEFUSAGE
{
    DWORD                   cbStruct;   // = sizeof CRYPT_PROVIDER_REGDEFUSAGE

    GUID                    *pgActionID;

    WCHAR                   *pwszDllName;
    char                    *pwszLoadCallbackDataFunctionName;
    char                    *pwszFreeCallbackDataFunctionName;

} CRYPT_PROVIDER_REGDEFUSAGE, *PCRYPT_PROVIDER_REGDEFUSAGE;

typedef struct _CRYPT_PROVIDER_DEFUSAGE
{
    DWORD                   cbStruct;               // = sizeof CRYPT_PROVIDER_DEFUSAGE

    GUID                    gActionID;            // ActionID of provider

    LPVOID                  pDefPolicyCallbackData; // normally filled in WINTRUST_DATA
    LPVOID                  pDefSIPClientData;      // normally filled in WINTRUST_DATA

} CRYPT_PROVIDER_DEFUSAGE, *PCRYPT_PROVIDER_DEFUSAGE;

#include <poppack.h>

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST.DLL Provider defines
//----------------------------------------------------------------------------
//  The following are definitions of the Microsoft Generic Cert Provider
//
#define WT_PROVIDER_DLL_NAME                L"WINTRUST.DLL"
#define WT_PROVIDER_CERTTRUST_FUNCTION      L"WintrustCertificateTrust"

//////////////////////////////////////////////////////////////////////////////
//
// WintrustAddActionID
//----------------------------------------------------------------------------
//  Adds a new Provider combination to the users'
//  system.  Creates all necessary registry entries, etc.  This should be done
//  during the Policy Provider's DllRegisterServer.
//
//  *** THE ONLY ONE WHO SHOULD CALL THIS IS THE POLICY PROVIDER ***
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
extern BOOL WINAPI  WintrustAddActionID(IN GUID *pgActionID,
                                        IN DWORD fdwReserved,    // future use.
                                        IN CRYPT_REGISTER_ACTIONID *psProvInfo);


//////////////////////////////////////////////////////////////////////////////
//
// WintrustRemoveActionID
//----------------------------------------------------------------------------
//  Removes the Provider action combination from the users'
//  system.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
extern BOOL WINAPI  WintrustRemoveActionID(IN GUID *pgActionID);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustLoadFunctionPointers
//----------------------------------------------------------------------------
//  Retrieves the function entry points based on the Action ID given.
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
extern BOOL WINAPI WintrustLoadFunctionPointers(GUID *pgActionID, CRYPT_PROVIDER_FUNCTIONS *pPfns);


//////////////////////////////////////////////////////////////////////////////
//
// WintrustAddDefaultForUsage
//----------------------------------------------------------------------------
//  Sets the default Action ID for the usage.  If the provider uses this
//  function, and the provider requires any of the "callback" data in
//  WINTRUST_DATA to be filled out, it MUST completely fill out the
//  CRYPT_PROVIDER_REGDEFUSAGE structure.
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
extern BOOL WINAPI              WintrustAddDefaultForUsage(IN const char *pszUsageOID,
                                                           IN CRYPT_PROVIDER_REGDEFUSAGE *psDefUsage);

//////////////////////////////////////////////////////////////////////////////
//
// WintrustGetDefaultForUsage
//----------------------------------------------------------------------------
//  Retrieves the Action ID and default callback data for the specified usage
//
//  this function must be called again with dwAction set to FREE to deallocate
//
//
// Returns:
//      TRUE                            success.
//      FALSE                           fail.
//
#define                             DWACTION_ALLOCANDFILL           1
#define                             DWACTION_FREE                   2
extern BOOL WINAPI              WintrustGetDefaultForUsage(IN DWORD dwAction,
                                                           IN const char *pszUsageOID,
                                                           IN OUT CRYPT_PROVIDER_DEFUSAGE *psUsage);

extern CRYPT_PROVIDER_SGNR * WINAPI     WTHelperGetProvSignerFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                       DWORD idxSigner,
                                                                       BOOL fCounterSigner,
                                                                       DWORD idxCounterSigner);
extern CRYPT_PROVIDER_CERT * WINAPI     WTHelperGetProvCertFromChain(CRYPT_PROVIDER_SGNR *pSgnr,
                                                                     DWORD idxCert);

extern CRYPT_PROVIDER_DATA * WINAPI     WTHelperProvDataFromStateData(HANDLE hStateData);

extern CRYPT_PROVIDER_PRIVDATA * WINAPI WTHelperGetProvPrivateDataFromChain(CRYPT_PROVIDER_DATA *pProvData,
                                                                            GUID *pgProviderID);
extern BOOL WINAPI                      WTHelperCertIsSelfSigned(DWORD dwEncoding, CERT_INFO *pCert);

//////////////////////////////////////////////////////////////////////////////
//
// Supported ASN structures contained in WINTRUST.DLL
//----------------------------------------------------------------------------
//
#include <pshpack8.h>

//
//  CTL Trusted CA Lists
//
#define szOID_TRUSTED_CODESIGNING_CA_LIST   "1.3.6.1.4.1.311.2.2.1"
#define szOID_TRUSTED_CLIENT_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.2"
#define szOID_TRUSTED_SERVER_AUTH_CA_LIST   "1.3.6.1.4.1.311.2.2.3"

//
//  encode/decode OID defines
//
#define SPC_COMMON_NAME_OBJID               szOID_COMMON_NAME
#define SPC_TIME_STAMP_REQUEST_OBJID        "1.3.6.1.4.1.311.3.2.1"
#define SPC_INDIRECT_DATA_OBJID             "1.3.6.1.4.1.311.2.1.4"
#define SPC_SP_AGENCY_INFO_OBJID            "1.3.6.1.4.1.311.2.1.10"
#define SPC_STATEMENT_TYPE_OBJID            "1.3.6.1.4.1.311.2.1.11"
#define SPC_SP_OPUS_INFO_OBJID              "1.3.6.1.4.1.311.2.1.12"
#define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#define SPC_PE_IMAGE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.15"
#define SPC_RAW_FILE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.18"
#define SPC_STRUCTURED_STORAGE_DATA_OBJID   "1.3.6.1.4.1.311.2.1.19"
#define SPC_JAVA_CLASS_DATA_OBJID           "1.3.6.1.4.1.311.2.1.20"
#define SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.21"
#define SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.22"
#define SPC_CAB_DATA_OBJID                  "1.3.6.1.4.1.311.2.1.25"
#define SPC_GLUE_RDN_OBJID                  "1.3.6.1.4.1.311.2.1.25"    // obsolete!
#define SPC_MINIMAL_CRITERIA_OBJID          "1.3.6.1.4.1.311.2.1.26"
#define SPC_FINANCIAL_CRITERIA_OBJID        "1.3.6.1.4.1.311.2.1.27"
#define SPC_LINK_OBJID                      "1.3.6.1.4.1.311.2.1.28"
#define SPC_SIGINFO_OBJID                   "1.3.6.1.4.1.311.2.1.30"

#define CAT_NAMEVALUE_OBJID                 "1.3.6.1.4.1.311.12.2.1"
#define CAT_MEMBERINFO_OBJID                "1.3.6.1.4.1.311.12.2.2"


//
//  encode/decode internal defines
//
#define SPC_SP_AGENCY_INFO_STRUCT           ((LPCSTR) 2000)
#define SPC_MINIMAL_CRITERIA_STRUCT         ((LPCSTR) 2001)
#define SPC_FINANCIAL_CRITERIA_STRUCT       ((LPCSTR) 2002)
#define SPC_INDIRECT_DATA_CONTENT_STRUCT    ((LPCSTR) 2003)
#define SPC_PE_IMAGE_DATA_STRUCT            ((LPCSTR) 2004)
#define SPC_LINK_STRUCT                     ((LPCSTR) 2005)
#define SPC_STATEMENT_TYPE_STRUCT           ((LPCSTR) 2006)
#define SPC_SP_OPUS_INFO_STRUCT             ((LPCSTR) 2007)
#define SPC_CAB_DATA_STRUCT                 ((LPCSTR) 2008)
#define SPC_JAVA_CLASS_DATA_STRUCT          ((LPCSTR) 2009)

#define SPC_SIGINFO_STRUCT                  ((LPCSTR) 2130)

#define CAT_NAMEVALUE_STRUCT                ((LPCSTR) 2221)
#define CAT_MEMBERINFO_STRUCT               ((LPCSTR) 2222)


#define SPC_UUID_LENGTH     16
typedef BYTE SPC_UUID[SPC_UUID_LENGTH];

typedef struct _SPC_SERIALIZED_OBJECT
{
    SPC_UUID            ClassId;
    CRYPT_DATA_BLOB     SerializedData;

} SPC_SERIALIZED_OBJECT, *PSPC_SERIALIZED_OBJECT;

typedef struct SPC_SIGINFO_
{
    DWORD       dwSipVersion;
    GUID        gSIPGuid;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
    DWORD       dwReserved5;

} SPC_SIGINFO, *PSPC_SIGINFO;

typedef struct SPC_LINK_
{
    DWORD dwLinkChoice;
#               define          SPC_URL_LINK_CHOICE         1
#               define          SPC_MONIKER_LINK_CHOICE     2
#               define          SPC_FILE_LINK_CHOICE        3

    union
    {
        LPWSTR                  pwszUrl;
        SPC_SERIALIZED_OBJECT   Moniker;
        LPWSTR                  pwszFile;
    };

} SPC_LINK, *PSPC_LINK;

typedef struct _SPC_PE_IMAGE_DATA
{
    CRYPT_BIT_BLOB            Flags;
    PSPC_LINK                 pFile;

} SPC_PE_IMAGE_DATA, *PSPC_PE_IMAGE_DATA;

typedef struct _SPC_INDIRECT_DATA_CONTENT
{
    CRYPT_ATTRIBUTE_TYPE_VALUE  Data;
    CRYPT_ALGORITHM_IDENTIFIER  DigestAlgorithm;
    CRYPT_HASH_BLOB             Digest;

} SPC_INDIRECT_DATA_CONTENT, *PSPC_INDIRECT_DATA_CONTENT;

typedef struct _SPC_FINANCIAL_CRITERIA
{
    BOOL                        fFinancialInfoAvailable;
    BOOL                        fMeetsCriteria;

} SPC_FINANCIAL_CRITERIA, *PSPC_FINANCIAL_CRITERIA;

typedef struct _SPC_IMAGE
{
    struct SPC_LINK_            *pImageLink;
    CRYPT_DATA_BLOB             Bitmap;
    CRYPT_DATA_BLOB             Metafile;
    CRYPT_DATA_BLOB             EnhancedMetafile;
    CRYPT_DATA_BLOB             GifFile;

} SPC_IMAGE, *PSPC_IMAGE;

typedef struct _SPC_SP_AGENCY_INFO
{
    struct SPC_LINK_            *pPolicyInformation;
    LPWSTR                      pwszPolicyDisplayText;
    PSPC_IMAGE                  pLogoImage;
    struct SPC_LINK_            *pLogoLink;

} SPC_SP_AGENCY_INFO, *PSPC_SP_AGENCY_INFO;

typedef struct _SPC_STATEMENT_TYPE
{
    DWORD                       cKeyPurposeId;
    LPSTR                       *rgpszKeyPurposeId;     // pszObjId

} SPC_STATEMENT_TYPE, *PSPC_STATEMENT_TYPE;

typedef struct _SPC_SP_OPUS_INFO
{
    LPCWSTR                     pwszProgramName;
    struct SPC_LINK_            *pMoreInfo;
    struct SPC_LINK_            *pPublisherInfo;

} SPC_SP_OPUS_INFO, *PSPC_SP_OPUS_INFO;

typedef struct _CAT_NAMEVALUE
{
    LPWSTR          pwszTag;
    DWORD           fdwFlags;
    CRYPT_DATA_BLOB Value;

} CAT_NAMEVALUE, *PCAT_NAMEVALUE;

typedef struct _CAT_MEMBERINFO
{
    LPWSTR          pwszSubjGuid;
    DWORD           dwCertVersion;

} CAT_MEMBERINFO, *PCAT_MEMBERINFO;

#include <poppack.h>



//////////////////////////////////////////////////////////////////////////////////
//
//  support for old calling convention: *** DO NOT USE ***
//
#ifdef WT_DEFINE_ALL_APIS

typedef struct _WIN_CERTIFICATE
{
    DWORD       dwLength;
    WORD        wRevision;
    WORD        wCertificateType;   // WIN_CERT_TYPE_xxx
    BYTE        bCertificate[ANYSIZE_ARRAY];

} WIN_CERTIFICATE, *LPWIN_CERTIFICATE;

#define WIN_CERT_REVISION_1_0               (0x0100)
#define WIN_CERT_REVISION_2_0               (0x0200)

#define WIN_CERT_TYPE_X509                  (0x0001)   // bCertificate contains an X.509 Certificate
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA      (0x0002)   // bCertificate contains a PKCS SignedData structure
#define WIN_CERT_TYPE_RESERVED_1            (0x0003)   // Reserved


typedef LPVOID WIN_TRUST_SUBJECT;

typedef struct _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
{
    HANDLE            hClientToken;
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT, *LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ;


typedef struct _WIN_TRUST_ACTDATA_SUBJECT_ONLY
{
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} WIN_TRUST_ACTDATA_SUBJECT_ONLY, *LPWIN_TRUST_ACTDATA_SUBJECT_ONLY;

/* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_RAW_FILE                              \
            { 0x959dc450,                                        \
              0x8d9e,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_PE_IMAGE                              \
            { 0x43c9a1e0,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }


/* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_JAVA_CLASS                            \
            { 0x08ad3990,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
/* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 */
#define WIN_TRUST_SUBJTYPE_CABINET                               \
            { 0xd17c5374,                                        \
              0xa392,                                            \
              0x11cf,                                            \
              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
            }

typedef struct _WIN_TRUST_SUBJECT_FILE
{
    HANDLE  hFile;
    LPCWSTR lpPath;

} WIN_TRUST_SUBJECT_FILE, *LPWIN_TRUST_SUBJECT_FILE;

#define WIN_TRUST_SUBJTYPE_RAW_FILEEX                            \
            { 0x6f458110,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_PE_IMAGEEX                            \
            { 0x6f458111,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_JAVA_CLASSEX                          \
            { 0x6f458113,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_CABINETEX                             \
            { 0x6f458114,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

typedef struct _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY
{
    HANDLE  hFile;              // handle to the open file if you got it
    LPCWSTR lpPath;             // the path to open if you don't
    LPCWSTR lpDisplayName;      // (optional) display name to show to user

} WIN_TRUST_SUBJECT_FILE_AND_DISPLAY, *LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY;

/* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb */
#define WIN_TRUST_SUBJTYPE_OLE_STORAGE                           \
            { 0xc257e740,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }


/* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_TRUSTED_PUBLISHER                        \
            { 0x66426730,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb */
#define     WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE                    \
            { 0x8bc96b00,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

/* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE                       \
            { 0x64b9d180,                                        \
              0x8da2,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

typedef struct _WIN_SPUB_TRUSTED_PUBLISHER_DATA
{
    HANDLE            hClientToken;
    LPWIN_CERTIFICATE lpCertificate;

} WIN_SPUB_TRUSTED_PUBLISHER_DATA, *LPWIN_SPUB_TRUSTED_PUBLISHER_DATA;

#endif



#ifdef __cplusplus
}
#endif

#endif // WINTRUST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\xwinreg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    Winreg.h

Abstract:

    This module contains the function prototypes and constant, type and
    structure definitions for the Windows 32-Bit Registry API.

--*/

#ifndef _WINREG_
#define _WINREG_

#ifdef _MAC
#include <macwin32.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINVER
#define WINVER 0x0500   // version 5.0
#endif /* !WINVER */

#include <xdbg.h>

//
// Requested Key access mask type.
//

typedef ACCESS_MASK REGSAM;

//
// Reserved Key Handles.
//

#define HKEY_CLASSES_ROOT           (( HKEY ) (ULONG_PTR)((LONG)0x80000000) )
#define HKEY_CURRENT_USER           (( HKEY ) (ULONG_PTR)((LONG)0x80000001) )
#define HKEY_LOCAL_MACHINE          (( HKEY ) (ULONG_PTR)((LONG)0x80000002) )
#define HKEY_USERS                  (( HKEY ) (ULONG_PTR)((LONG)0x80000003) )
#define HKEY_PERFORMANCE_DATA       (( HKEY ) (ULONG_PTR)((LONG)0x80000004) )
#if(WINVER >= 0x0400)
#define HKEY_CURRENT_CONFIG         (( HKEY ) (ULONG_PTR)((LONG)0x80000005) )
#define HKEY_DYN_DATA               (( HKEY ) (ULONG_PTR)((LONG)0x80000006) )

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

#define PROVIDER_KEEPS_VALUE_LENGTH 0x1
struct val_context {
    int valuelen;       // the total length of this value
    LPVOID value_context;   // provider's context
    LPVOID val_buff_ptr;    // where in the ouput buffer the value is.
};

typedef struct val_context FAR *PVALCONTEXT;

typedef struct pvalueA {           // Provider supplied value/context.
    LPSTR   pv_valuename;          // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA, FAR *PPVALUEA;
typedef struct pvalueW {           // Provider supplied value/context.
    LPWSTR  pv_valuename;          // The value name pointer
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW, FAR *PPVALUEW;
#ifdef UNICODE
typedef PVALUEW PVALUE;
typedef PPVALUEW PPVALUE;
#else
typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
#endif // UNICODE

typedef
DWORD _cdecl
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD FAR *total_outlen, DWORD input_blen);

typedef QUERYHANDLER FAR *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    // capability flags (none defined yet).
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info FAR *PPROVIDER;

typedef struct value_entA {
    LPSTR   ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTA, FAR *PVALENTA;
typedef struct value_entW {
    LPWSTR  ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTW, FAR *PVALENTW;
#ifdef UNICODE
typedef VALENTW VALENT;
typedef PVALENTW PVALENT;
#else
typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
#endif // UNICODE

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#endif /* WINVER >= 0x0400 */

//
// Default values for parameters that do not exist in the Win 3.1
// compatible APIs.
//

#define WIN31_CLASS                 NULL

//
// API Prototypes.
//

__inline
WINADVAPI
LONG
APIENTRY
RegCloseKey (
    IN HKEY hKey
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

WINADVAPI
LONG
APIENTRY
RegOverridePredefKey (
    IN HKEY hKey,
    IN HKEY hNewHKey
    );

WINADVAPI
LONG
APIENTRY
RegOpenUserClassesRoot(
    HANDLE hToken,
    DWORD  dwOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    );

WINADVAPI
LONG
APIENTRY
RegOpenCurrentUser(
    REGSAM samDesired,
    PHKEY phkResult
    );

WINADVAPI
LONG
APIENTRY
RegDisablePredefinedCache(
    );

WINADVAPI
LONG
APIENTRY
RegConnectRegistryA (
    IN LPCSTR lpMachineName,
    IN HKEY hKey,
    OUT PHKEY phkResult
    );
WINADVAPI
LONG
APIENTRY
RegConnectRegistryW (
    IN LPCWSTR lpMachineName,
    IN HKEY hKey,
    OUT PHKEY phkResult
    );
#ifdef UNICODE
#define RegConnectRegistry  RegConnectRegistryW
#else
#define RegConnectRegistry  RegConnectRegistryA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegCreateKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    );
WINADVAPI
LONG
APIENTRY
RegCreateKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    );
#ifdef UNICODE
#define RegCreateKey  RegCreateKeyW
#else
#define RegCreateKey  RegCreateKeyA
#endif // !UNICODE

__inline
WINADVAPI
LONG
APIENTRY
RegCreateKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

__inline
WINADVAPI
LONG
APIENTRY
RegCreateKeyExW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD Reserved,
    IN LPWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}
#ifdef UNICODE
#define RegCreateKeyEx  RegCreateKeyExW
#else
#define RegCreateKeyEx  RegCreateKeyExA
#endif // !UNICODE

__inline
WINADVAPI
LONG
APIENTRY
RegDeleteKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

__inline
WINADVAPI
LONG
APIENTRY
RegDeleteKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}
#ifdef UNICODE
#define RegDeleteKey  RegDeleteKeyW
#else
#define RegDeleteKey  RegDeleteKeyA
#endif // !UNICODE

__inline
WINADVAPI
LONG
APIENTRY
RegDeleteValueA (
    IN HKEY hKey,
    IN LPCSTR lpValueName
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}
__inline
WINADVAPI
LONG
APIENTRY
RegDeleteValueW (
    IN HKEY hKey,
    IN LPCWSTR lpValueName
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}
#ifdef UNICODE
#define RegDeleteValue  RegDeleteValueW
#else
#define RegDeleteValue  RegDeleteValueA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegEnumKeyA (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPSTR lpName,
    IN DWORD cbName
    );
WINADVAPI
LONG
APIENTRY
RegEnumKeyW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN DWORD cbName
    );
#ifdef UNICODE
#define RegEnumKey  RegEnumKeyW
#else
#define RegEnumKey  RegEnumKeyA
#endif // !UNICODE

__inline
WINADVAPI
LONG
APIENTRY
RegEnumKeyExA (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPSTR lpName,
    IN OUT LPDWORD lpcbName,
    IN LPDWORD lpReserved,
    IN OUT LPSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    OUT PFILETIME lpftLastWriteTime
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

WINADVAPI
LONG
APIENTRY
RegEnumKeyExW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN OUT LPDWORD lpcbName,
    IN LPDWORD lpReserved,
    IN OUT LPWSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    OUT PFILETIME lpftLastWriteTime
    );
#ifdef UNICODE
#define RegEnumKeyEx  RegEnumKeyExW
#else
#define RegEnumKeyEx  RegEnumKeyExA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegEnumValueA (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );
WINADVAPI
LONG
APIENTRY
RegEnumValueW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );
#ifdef UNICODE
#define RegEnumValue  RegEnumValueW
#else
#define RegEnumValue  RegEnumValueA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegFlushKey (
    IN HKEY hKey
    );

__inline
WINADVAPI
LONG
APIENTRY
RegGetKeySecurity (
    IN HKEY hKey,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT LPDWORD lpcbSecurityDescriptor
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

WINADVAPI
LONG
APIENTRY
RegLoadKeyA (
    IN HKEY    hKey,
    IN LPCSTR  lpSubKey,
    IN LPCSTR  lpFile
    );
WINADVAPI
LONG
APIENTRY
RegLoadKeyW (
    IN HKEY    hKey,
    IN LPCWSTR  lpSubKey,
    IN LPCWSTR  lpFile
    );
#ifdef UNICODE
#define RegLoadKey  RegLoadKeyW
#else
#define RegLoadKey  RegLoadKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegNotifyChangeKeyValue (
    IN HKEY hKey,
    IN BOOL bWatchSubtree,
    IN DWORD dwNotifyFilter,
    IN HANDLE hEvent,
    IN BOOL fAsynchronus
    );

__inline
WINADVAPI
LONG
APIENTRY
RegOpenKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

__inline
WINADVAPI
LONG
APIENTRY
RegOpenKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}
#ifdef UNICODE
#define RegOpenKey  RegOpenKeyW
#else
#define RegOpenKey  RegOpenKeyA
#endif // !UNICODE

__inline
WINADVAPI
LONG
APIENTRY
RegOpenKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

__inline
WINADVAPI
LONG
APIENTRY
RegOpenKeyExW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

#ifdef UNICODE
#define RegOpenKeyEx  RegOpenKeyExW
#else
#define RegOpenKeyEx  RegOpenKeyExA
#endif // !UNICODE

__inline
WINADVAPI
LONG
APIENTRY
RegQueryInfoKeyA (
    IN HKEY hKey,
    OUT LPSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

__inline
WINADVAPI
LONG
APIENTRY
RegQueryInfoKeyW (
    IN HKEY hKey,
    OUT LPWSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

#ifdef UNICODE
#define RegQueryInfoKey  RegQueryInfoKeyW
#else
#define RegQueryInfoKey  RegQueryInfoKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegQueryValueA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT LPSTR lpValue,
    IN OUT PLONG   lpcbValue
    );
WINADVAPI
LONG
APIENTRY
RegQueryValueW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT LPWSTR lpValue,
    IN OUT PLONG   lpcbValue
    );
#ifdef UNICODE
#define RegQueryValue  RegQueryValueW
#else
#define RegQueryValue  RegQueryValueA
#endif // !UNICODE

#if(WINVER >= 0x0400)
WINADVAPI
LONG
APIENTRY
RegQueryMultipleValuesA (
    IN HKEY hKey,
    OUT PVALENTA val_list,
    IN DWORD num_vals,
    OUT LPSTR lpValueBuf,
    IN OUT LPDWORD ldwTotsize
    );
WINADVAPI
LONG
APIENTRY
RegQueryMultipleValuesW (
    IN HKEY hKey,
    OUT PVALENTW val_list,
    IN DWORD num_vals,
    OUT LPWSTR lpValueBuf,
    IN OUT LPDWORD ldwTotsize
    );
#ifdef UNICODE
#define RegQueryMultipleValues  RegQueryMultipleValuesW
#else
#define RegQueryMultipleValues  RegQueryMultipleValuesA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

__inline
WINADVAPI
LONG
APIENTRY
RegQueryValueExA (
    IN HKEY hKey,
    IN LPCSTR lpValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}

WINADVAPI
LONG
APIENTRY
RegQueryValueExW (
    IN HKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );
#ifdef UNICODE
#define RegQueryValueEx  RegQueryValueExW
#else
#define RegQueryValueEx  RegQueryValueExA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegReplaceKeyA (
    IN HKEY     hKey,
    IN LPCSTR  lpSubKey,
    IN LPCSTR  lpNewFile,
    IN LPCSTR  lpOldFile
    );
WINADVAPI
LONG
APIENTRY
RegReplaceKeyW (
    IN HKEY     hKey,
    IN LPCWSTR  lpSubKey,
    IN LPCWSTR  lpNewFile,
    IN LPCWSTR  lpOldFile
    );
#ifdef UNICODE
#define RegReplaceKey  RegReplaceKeyW
#else
#define RegReplaceKey  RegReplaceKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegRestoreKeyA (
    IN HKEY hKey,
    IN LPCSTR lpFile,
    IN DWORD   dwFlags
    );
WINADVAPI
LONG
APIENTRY
RegRestoreKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpFile,
    IN DWORD   dwFlags
    );
#ifdef UNICODE
#define RegRestoreKey  RegRestoreKeyW
#else
#define RegRestoreKey  RegRestoreKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegSaveKeyA (
    IN HKEY hKey,
    IN LPCSTR lpFile,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINADVAPI
LONG
APIENTRY
RegSaveKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpFile,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define RegSaveKey  RegSaveKeyW
#else
#define RegSaveKey  RegSaveKeyA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegSetKeySecurity (
    IN HKEY hKey,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

WINADVAPI
LONG
APIENTRY
RegSetValueA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD dwType,
    IN LPCSTR lpData,
    IN DWORD cbData
    );
WINADVAPI
LONG
APIENTRY
RegSetValueW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwType,
    IN LPCWSTR lpData,
    IN DWORD cbData
    );
#ifdef UNICODE
#define RegSetValue  RegSetValueW
#else
#define RegSetValue  RegSetValueA
#endif // !UNICODE

__inline
WINADVAPI
LONG
APIENTRY
RegSetValueExA (
    IN HKEY hKey,
    IN LPCSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}
__inline
WINADVAPI
LONG
APIENTRY
RegSetValueExW (
    IN HKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )
{
    ASSERT(!"xwinreg.h called");
    return 0;
}
#ifdef UNICODE
#define RegSetValueEx  RegSetValueExW
#else
#define RegSetValueEx  RegSetValueExA
#endif // !UNICODE

WINADVAPI
LONG
APIENTRY
RegUnLoadKeyA (
    IN HKEY    hKey,
    IN LPCSTR lpSubKey
    );
WINADVAPI
LONG
APIENTRY
RegUnLoadKeyW (
    IN HKEY    hKey,
    IN LPCWSTR lpSubKey
    );
#ifdef UNICODE
#define RegUnLoadKey  RegUnLoadKeyW
#else
#define RegUnLoadKey  RegUnLoadKeyA
#endif // !UNICODE

//
// Remoteable System Shutdown APIs
//

WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownA(
    IN LPSTR lpMachineName,
    IN LPSTR lpMessage,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown
    );
WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownW(
    IN LPWSTR lpMachineName,
    IN LPWSTR lpMessage,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown
    );
#ifdef UNICODE
#define InitiateSystemShutdown  InitiateSystemShutdownW
#else
#define InitiateSystemShutdown  InitiateSystemShutdownA
#endif // !UNICODE


WINADVAPI
BOOL
APIENTRY
AbortSystemShutdownA(
    IN LPSTR lpMachineName
    );
WINADVAPI
BOOL
APIENTRY
AbortSystemShutdownW(
    IN LPWSTR lpMachineName
    );
#ifdef UNICODE
#define AbortSystemShutdown  AbortSystemShutdownW
#else
#define AbortSystemShutdown  AbortSystemShutdownA
#endif // !UNICODE

//
// defines for InitiateSystemShutdownEx reason codes
//

#define REASON_SWINSTALL    0
#define REASON_HWINSTALL    1
#define REASON_SERVICEHANG  2
#define REASON_UNSTABLE     3
#define REASON_SWHWRECONF   4
#define REASON_OTHER        5
#define REASON_UNKNOWN      255
#define REASON_PLANNED_FLAG 0x80000000

WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownExA(
    IN LPSTR lpMachineName,
    IN LPSTR lpMessage,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown,
    IN DWORD dwReason
    );
WINADVAPI
BOOL
APIENTRY
InitiateSystemShutdownExW(
    IN LPWSTR lpMachineName,
    IN LPWSTR lpMessage,
    IN DWORD dwTimeout,
    IN BOOL bForceAppsClosed,
    IN BOOL bRebootAfterShutdown,
    IN DWORD dwReason
    );
#ifdef UNICODE
#define InitiateSystemShutdownEx  InitiateSystemShutdownExW
#else
#define InitiateSystemShutdownEx  InitiateSystemShutdownExA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif


#endif // _WINREG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\include\xsecapi.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntsecapi.h

Abstract:

    This module defines the Local Security Authority APIs.

Revision History:

--*/

#ifndef _NTSECAPI_
#define _NTSECAPI_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif

#ifndef _NTLSA_IFS_
// begin_ntifs


//
// Security operation mode of the system is held in a control
// longword.
//

typedef ULONG  LSA_OPERATIONAL_MODE, *PLSA_OPERATIONAL_MODE;

// end_ntifs
#endif // _NTLSA_IFS_

//
// The flags in the security operational mode are defined
// as:
//
//    PasswordProtected - Some level of authentication (such as
//        a password) must be provided by users before they are
//        allowed to use the system.  Once set, this value will
//        not be cleared without re-booting the system.
//
//    IndividualAccounts - Each user must identify an account to
//        logon to.  This flag is only meaningful if the
//        PasswordProtected flag is also set.  If this flag is
//        not set and the PasswordProtected flag is set, then all
//        users may logon to the same account.  Once set, this value
//        will not be cleared without re-booting the system.
//
//    MandatoryAccess - Indicates the system is running in a mandatory
//        access control mode (e.g., B-level as defined by the U.S.A's
//        Department of Defense's "Orange Book").  This is not utilized
//        in the current release of NT.  This flag is only meaningful
//        if both the PasswordProtected and IndividualAccounts flags are
//        set.  Once set, this value will not be cleared without
//        re-booting the system.
//
//    LogFull - Indicates the system has been brought up in a mode in
//        which if must perform security auditing, but its audit log
//        is full.  This may (should) restrict the operations that
//        can occur until the audit log is made not-full again.  THIS
//        VALUE MAY BE CLEARED WHILE THE SYSTEM IS RUNNING (I.E., WITHOUT
//        REBOOTING).
//
// If the PasswordProtected flag is not set, then the system is running
// without security, and user interface should be adjusted appropriately.
//

#define LSA_MODE_PASSWORD_PROTECTED     (0x00000001L)
#define LSA_MODE_INDIVIDUAL_ACCOUNTS    (0x00000002L)
#define LSA_MODE_MANDATORY_ACCESS       (0x00000004L)
#define LSA_MODE_LOG_FULL               (0x00000008L)

#ifndef _NTLSA_IFS_
// begin_ntifs
//
// Used by a logon process to indicate what type of logon is being
// requested.
//

typedef enum _SECURITY_LOGON_TYPE {
    Interactive = 2,    // Interactively logged on (locally or remotely)
    Network,            // Accessing system via network
    Batch,              // Started via a batch queue
    Service,            // Service started by service controller
    Proxy,              // Proxy logon
    Unlock,             // Unlock workstation
    NetworkCleartext,   // Network logon with cleartext credentials
    NewCredentials      // Clone caller, new default credentials
} SECURITY_LOGON_TYPE, *PSECURITY_LOGON_TYPE;

// end_ntifs
#endif // _NTLSA_IFS_


//
// Audit Event Categories
//
// The following are the built-in types or Categories of audit event.
// WARNING!  This structure is subject to expansion.  The user should not
// compute the number of elements of this type directly, but instead
// should obtain the count of elements by calling LsaQueryInformationPolicy()
// for the PolicyAuditEventsInformation class and extracting the count from
// the MaximumAuditEventCount field of the returned structure.
//

typedef enum _POLICY_AUDIT_EVENT_TYPE {

    AuditCategorySystem,
    AuditCategoryLogon,
    AuditCategoryObjectAccess,
    AuditCategoryPrivilegeUse,
    AuditCategoryDetailedTracking,
    AuditCategoryPolicyChange,
    AuditCategoryAccountManagement,
    AuditCategoryDirectoryServiceAccess,
    AuditCategoryAccountLogon

} POLICY_AUDIT_EVENT_TYPE, *PPOLICY_AUDIT_EVENT_TYPE;


//
// The following defines describe the auditing options for each
// event type
//

// Leave options specified for this event unchanged

#define POLICY_AUDIT_EVENT_UNCHANGED       (0x00000000L)

// Audit successful occurrences of events of this type

#define POLICY_AUDIT_EVENT_SUCCESS         (0x00000001L)

// Audit failed attempts to cause an event of this type to occur

#define POLICY_AUDIT_EVENT_FAILURE         (0x00000002L)

#define POLICY_AUDIT_EVENT_NONE            (0x00000004L)

// Mask of valid event auditing options

#define POLICY_AUDIT_EVENT_MASK \
    (POLICY_AUDIT_EVENT_SUCCESS | \
     POLICY_AUDIT_EVENT_FAILURE | \
     POLICY_AUDIT_EVENT_UNCHANGED | \
     POLICY_AUDIT_EVENT_NONE)


#ifdef _NTDEF_
// begin_ntifs
typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;
// end_ntifs
#else // _NTDEF_

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif


typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PLSA_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;



#endif // _NTDEF_

//
// Macro for determining whether an API succeeded.
//

#define LSA_SUCCESS(Error) ((LONG)(Error) >= 0)

#ifndef _NTLSA_IFS_
// begin_ntifs

NTSTATUS
NTAPI
LsaRegisterLogonProcess (
    IN PLSA_STRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    );

// end_ntifs
// begin_ntsrv

NTSTATUS
NTAPI
LsaLogonUser (
    IN HANDLE LsaHandle,
    IN PLSA_STRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    );


// end_ntsrv

NTSTATUS
NTAPI
LsaLookupAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN PLSA_STRING PackageName,
    OUT PULONG AuthenticationPackage
    );

// begin_ntifs

NTSTATUS
NTAPI
LsaFreeReturnBuffer (
    IN PVOID Buffer
    );

// end_ntifs

NTSTATUS
NTAPI
LsaCallAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNT