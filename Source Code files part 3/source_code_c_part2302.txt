NFO;

BOOL
APIENTRY
GetCharWidthInfo(
    HDC            hdc,
    PCHWIDTHINFO   pChWidthInfo
);


/**************************************************************************\
*
*   tmdiff struc, contains the fields that are possibly different
*   between ansi and unicode versions of TEXTMETRICA and TEXTMETRICW
*
*   ONLY independent quantities are put into the strucure. Dependent ones,
*   such as tmDescent and maybe tmOverhang should be computed on the fly
*
*   tmDesc = tmHt - tmAsc
*   tmOverhang = tt ? 0 : ((tmHt - 1)/2 + (BOLD ? 1 : 0))
*
\**************************************************************************/

// this is a font with nonnegative a and c spaces, good for console

#if (_WIN32_WINNT >= 0x0500)

typedef struct _TMDIFF
{
    ULONG       cjotma;     // size of OUTLINETEXTMETRICSA
    BYTE        chFirst;
    BYTE        chLast;
    BYTE        chDefault;
    BYTE        chBreak;
} TMDIFF; // DIFF between TEXTMETRICA and TEXTMETRICW

#else

typedef struct _TMDIFF
{
    ULONG       cjotma;     // size of OUTLINETEXTMETRICSA
    FLONG       fl;         // flags, for now only TMD_NONNEGATIVE_AC
    BYTE        chFirst;
    BYTE        chLast;
    BYTE        chDefault;
    BYTE        chBreak;
} TMDIFF; // DIFF between TEXTMETRICA and TEXTMETRICW

#endif // (_WIN32_WINNT >= 0x0500)

// used to return correct GetTextMetricsA/W

typedef struct _TMW_INTERNAL
{
    TEXTMETRICW tmw;
    TMDIFF      tmdTmw;
} TMW_INTERNAL;

#if (_WIN32_WINNT >= 0x0500)

// this one is only used in enumeration,
// new textmetricsex returned by EnumFontFamiliesEx, fontsignature is returned

typedef struct _NTMW_INTERNAL
{
    TMDIFF           tmdNtmw;
    ENUMTEXTMETRICW  entmw;
} NTMW_INTERNAL;

#else

#define TMD_NONNEGATIVE_AC 1

typedef struct _NTMW_INTERNAL
{
    NEWTEXTMETRICEXW ntmw;
    TMDIFF           tmd;
} NTMW_INTERNAL;

#endif // (_WIN32_WINNT >= 0x0500)

// flags for AddFontResourceW
// AFRW_ADD_LOCAL_FONT : add ONLY if it is a local font
// AFRW_ADD_REMOTE_FONT: add ONLY if it is NOT local font
// if neither one LOCAL or REMOTE bit is set, just add the font

#define AFRW_ADD_LOCAL_FONT  0X01
#define AFRW_ADD_REMOTE_FONT 0X02
#define FRW_EMB_TID        0x04
#define FRW_EMB_PID        0x08
#define FRW_PVT_CLEANUP    0x80

#if (_WIN32_WINNT >= 0x0500)
int GdiAddFontResourceW( LPWSTR, DWORD, DESIGNVECTOR *);
#endif

#define TCI_SRCLOCALE   0x1000

// Win31 compatibility stuff
// GetAppCompatFlags flag values

#define GACF_IGNORENODISCARD        0x00000001
#define GACF_FORCETEXTBAND          0x00000002
#define GACF_ONELANDGRXBAND         0x00000004
#define GACF_IGNORETOPMOST          0x00000008
#define GACF_CALLTTDEVICE           0x00000010
#define GACF_MULTIPLEBANDS          0x00000020
#define GACF_ALWAYSSENDNCPAINT      0x00000040
#define GACF_EDITSETTEXTMUNGE       0x00000080
#define GACF_MOREEXTRAWNDWORDS      0x00000100
#define GACF_TTIGNORERASTERDUPE     0x00000200
#define GACF_HACKWINFLAGS           0x00000400
#define GACF_DELAYHWHNDSHAKECHK     0x00000800
#define GACF_ENUMHELVNTMSRMN        0x00001000
#define GACF_ENUMTTNOTDEVICE        0x00002000
#define GACF_SUBTRACTCLIPSIBS       0x00004000
#define GACF_FORCETTGRAPHICS        0x00008000
#define GACF_NOHRGN1                0x00010000
#define GACF_NCCALCSIZEONMOVE       0x00020000
#define GACF_SENDMENUDBLCLK         0x00040000
#define GACF_30AVGWIDTH             0x00080000
#define GACF_GETDEVCAPSNUMLIE       0x00100000

#define GACF_WINVER31               0x00200000      //
#define GACF_INCREASESTACK          0x00400000      //
#define GACF_HEAPSLACK              0x00400000      //
#define GACF_FORCEWIN31DEVMODESIZE  0x00800000      // (replaces PEEKMESSAGEIDLE)
#define GACF_31VALIDMASK            0xFFE4800C      //
#define GACF_DISABLEFONTASSOC       0x01000000      // Used in FE only
#define GACF_JAPANESCAPEMENT        0x01000000      // Used in FE only
#define GACF_IGNOREFAULTS           0x02000000      //
#define GACF_NOEMFSPOOLING          0x04000000      //
#define GACF_RANDOM3XUI             0x08000000      //
#define GACF_USEPRINTINGESCAPES     0x00000004      // re-use GACF_ONELANDGRXBAND
#define GACF_FORCERASTERMODE        0x00008000      // re-use GACF_FORCETTGRAPHICS
#define GACF_DONTJOURNALATTACH      0x10000000      //
#define GACF_DISABLEDBCSPROPTT      0x20000000      // Used in FE only
#define GACF_NOBRUSHCACHE           0x20000000      // re-use GACF_DISABLEDBCSPROPTT
#define GACF_MIRRORREGFONTS         0x40000000      //
#define GACF_NOSMOOTHSCROLLING      0x40000000      // re-use GACF_MIRRORREGFONTS
#define GACF_TTIGNOREDDEVICE        0x80000000      // Used in Word97-J only
#define GACF_NOSCROLLBARCTXMENU     0x80000000      // re-use GACF_TTIGNOREDDEVICE #119380


LPDEVMODEW
WINAPI
GdiConvertToDevmodeW(
    LPDEVMODEA pdma
    );




typedef struct _UNIVERSAL_FONT_ID {
    ULONG   CheckSum;
    ULONG   Index;
} UNIVERSAL_FONT_ID, *PUNIVERSAL_FONT_ID;

WINGDIAPI
INT
WINAPI
GdiQueryFonts(
    PUNIVERSAL_FONT_ID,
    ULONG,
    PLARGE_INTEGER
    );


WINGDIAPI
BOOL
WINAPI
GdiConsoleTextOut(
    HDC hdc,
    POLYTEXTW *lpto,
    UINT nStrings,
    RECTL *prclBounds
    );

typedef enum _FULLSCREENCONTROL {
    FullscreenControlEnable,               // 0
    FullscreenControlDisable,              // 1
    FullscreenControlSetCursorPosition,    // 2
    FullscreenControlSetCursorAttributes,  // 3
    FullscreenControlRegisterVdm,          // 4
    FullscreenControlSetPalette,           // 5
    FullscreenControlSetColors,            // 6
    FullscreenControlLoadFont,             // 7
    FullscreenControlRestoreHardwareState, // 8
    FullscreenControlSaveHardwareState,    // 9
    FullscreenControlCopyFrameBuffer,      // a
    FullscreenControlReadFromFrameBuffer,  // b
    FullscreenControlWriteToFrameBuffer,   // c
    FullscreenControlReverseMousePointer,  // d
    FullscreenControlSetMode,              // e
    FullscreenControlSetScreenInformation, // f
    FullscreenControlSpecificVideoControl, // 10 (for specific NEC PC-98)
    FullscreenControlCopyFrameBufferDB,    // 11
    FullscreenControlWriteToFrameBufferDB, // 12
    FullscreenControlReverseMousePointerDB // 13
} FULLSCREENCONTROL;

WINGDIAPI
BOOL
WINAPI
GdiFullscreenControl(
    FULLSCREENCONTROL FullscreenCommand,
    PVOID  FullscreenInuut,
    DWORD  FullscreenInputLength,
    PVOID  FullscreenOutput,
    PULONG FullscreenOutputLength
    );



#define IS_ANY_DBCS_CHARSET( CharSet )                              \
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )


typedef struct _UMTHDR {
    ULONG cjSize;
    ULONG ulType;
    ULONG ulReserved1;
    ULONG ulReserved2;
} UMTHDR;

WINGDIAPI
ULONG
WINAPI
GdiPrinterThunk(
    UMTHDR *pumth,
    PVOID pvOut,
    ULONG cjOut
    );

#define GPT_ERROR   0xffffffff

#endif /* _WINGDIP_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\winbasep.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985-2001, Microsoft Corporation

Module Name:

    winbasep.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the Base
    component.

--*/
#ifndef _WINBASEP_
#define _WINBASEP_
#ifdef __cplusplus
extern "C" {
#endif
WINBASEAPI
DWORD
WINAPI
HeapCreateTagsW(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPCWSTR lpTagPrefix,
    IN LPCWSTR lpTagNames
    );

typedef struct _HEAP_TAG_INFO {
    DWORD dwNumberOfAllocations;
    DWORD dwNumberOfFrees;
    DWORD dwBytesAllocated;
} HEAP_TAG_INFO, *PHEAP_TAG_INFO;
typedef PHEAP_TAG_INFO LPHEAP_TAG_INFO;

WINBASEAPI
LPCWSTR
WINAPI
HeapQueryTagW(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN WORD wTagIndex,
    IN BOOL bResetCounters,
    OUT LPHEAP_TAG_INFO TagInfo
    );

typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;

BOOL
WINAPI
HeapSummary(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    OUT LPHEAP_SUMMARY lpSummary
    );

BOOL
WINAPI
HeapExtend(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN LPVOID lpBase,
    IN DWORD dwBytes
    );

typedef struct _HEAP_USAGE_ENTRY {
    struct _HEAP_USAGE_ENTRY *lpNext;
    PVOID lpAddress;
    DWORD dwBytes;
    DWORD dwReserved;
} HEAP_USAGE_ENTRY, *PHEAP_USAGE_ENTRY;

typedef struct _HEAP_USAGE {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
    PHEAP_USAGE_ENTRY lpEntries;
    PHEAP_USAGE_ENTRY lpAddedEntries;
    PHEAP_USAGE_ENTRY lpRemovedEntries;
    DWORD Reserved[ 8 ];
} HEAP_USAGE, *PHEAP_USAGE;

BOOL
WINAPI
HeapUsage(
    IN HANDLE hHeap,
    IN DWORD dwFlags,
    IN BOOL bFirstCall,
    IN BOOL bLastCall,
    OUT PHEAP_USAGE lpUsage
    );




//
// filefind stucture shared with ntvdm, jonle
// see mvdm\dos\dem\demsrch.c
//
typedef struct _FINDFILE_HANDLE {
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;
    PVOID FindBufferNext;
    ULONG FindBufferLength;
    ULONG FindBufferValidLength;
    RTL_CRITICAL_SECTION FindBufferLock;
} FINDFILE_HANDLE, *PFINDFILE_HANDLE;

#define BASE_FIND_FIRST_DEVICE_HANDLE (HANDLE)1


/* Max number of characters. Doesn't include termination character */
#define WSPRINTF_LIMIT 1024
#ifdef __cplusplus
}
#endif
#endif  // ndef _WINBASEP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\winfont.h ===
/******************************Module*Header*******************************\
* Module Name: winfont.h
*
* font file headers for 2.0 and 3.0 windows *.fnt files
*
* Created: 25-Oct-1990 11:08:08
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
*
\**************************************************************************/


/******************************Public*Macro********************************\
* WRITE_WORD
*
* Writes a word to the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define WRITE_WORD(pv, word)                                        \
{                                                                   \
    *(PBYTE) (pv)       = (BYTE) ((word) & 0x00ff);                 \
    *((PBYTE) (pv) + 1) = (BYTE) (((word) & 0xff00) >> 8);          \
}


/******************************Public*Macro********************************\
* READ_WORD
*
* Reads a word from the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define READ_WORD(pv)                                               \
( (WORD)                                                            \
    ( ((WORD)*(PBYTE) (pv)) & (WORD)0x00ff ) |                      \
    ( ((WORD)*((PBYTE) (pv) + (WORD)1) & (WORD)0x00ff) << 8 )       \
)



/******************************Public*Macro********************************\
* WRITE_DWORD
*
* Writes a dword to the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


#define WRITE_DWORD(pv, dword)                                      \
{                                                                   \
    *(PBYTE) (pv)       = (BYTE) ((dword) & 0x000000ff);            \
    *((PBYTE) (pv) + 1) = (BYTE) (((dword) & 0x0000ff00) >> 8 );    \
    *((PBYTE) (pv) + 2) = (BYTE) (((dword) & 0x00ff0000) >> 16);    \
    *((PBYTE) (pv) + 3) = (BYTE) (((dword) & 0xff000000) >> 24);    \
}


/******************************Public*Macro********************************\
* READ_DWORD
*
* Reads a DWORD from the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define READ_DWORD(pv)                                              \
( (DWORD)                                                           \
    ( (*(PBYTE) (pv)) & 0x000000ff ) |                              \
    ( (*((PBYTE) (pv) + 1) & 0x000000ff) << 8 ) |                   \
    ( (*((PBYTE) (pv) + 2) & 0x000000ff) << 16) |                   \
    ( (*((PBYTE) (pv) + 3) & 0x000000ff) << 24)                     \
)


// font file header (2.0 ddk adaptation guide, 7.7.3.
// and 3.0 ddk,  Adaptation Guide section 13.3)

// CAUTION: These structures, as they are defined in the Adaptation Guide are
//          out of allignment.(Not even WORD alligned,let alone DWORD alligned.)
//          Here we make our own structures, so that when
//          disk files are read in the data is copied in correctly, and so that
//          the data can be accessed in memory regardless of the architecture.

/**************************************************************************\

// the original structure was

typedef struct {
    WORD    Version;          // Always 17985 for the Nonce
    DWORD   Size;             // Size of whole file
    char    Copyright[60];
    WORD    Type;             // Raster Font if Type & 1 == 0
    WORD    Points;           // Nominal Point size
    WORD    VertRes;          // Nominal Vertical resolution
    WORD    HorizRes;         // Nominal Horizontal resolution
    WORD    Ascent;           // Height of Ascent
    WORD    IntLeading;       // Internal (Microsoft) Leading
    WORD    ExtLeading;       // External (Microsoft) Leading
    BYTE    Italic;           // Italic font if set
    BYTE    Underline;        // Etc.
    BYTE    StrikeOut;        // Etc.
    WORD    Weight;           // Weight: 200 = regular
    BYTE    CharSet;          // ANSI=0. other=255
    WORD    PixWidth;         // Fixed width. 0 ==> Variable
    WORD    PixHeight;        // Fixed Height
    BYTE    Family;           // Pitch and Family
    WORD    AvgWidth;         // Width of character 'X'
    WORD    MaxWidth;         // Maximum width
    BYTE    FirstChar;        // First character defined in font
    BYTE    LastChar;         // Last character defined in font
    BYTE    DefaultChar;          // Sub. for out of range chars.
    BYTE    BreakChar;        // Word Break Character
    WORD    WidthBytes;       // No.Bytes/row of Bitmap
    DWORD   Device;           // Pointer to Device Name string
    DWORD   Face;           // Pointer to Face Name String
    DWORD   BitsPointer;        // Pointer to Bit Map
    DWORD   BitsOffset;     // Offset to Bit Map
    } FontHeaderType;       // Above pointers all rel. to start of file

// the original 3.0 header:

typedef struct {
    WORD    fsVersion;
    DWORD   fsSize;
    char    fsCopyright[60];
    WORD    fsType;           // Type field for the font
    WORD    fsPoints;         // Point size of font
    WORD    fsVertRes;        // Vertical digitization
    WORD    fsHorizRes;       // Horizontal digitization
    WORD    fsAscent;         // Baseline offset from char cell top
    WORD    fsInternalLeading;    // Internal leading included in font
    WORD    fsExternalLeading;    // Prefered extra space between lines
    BYTE    fsItalic;         // Flag specifying if italic
    BYTE    fsUnderline;          // Flag specifying if underlined
    BYTE    fsStrikeOut;          // Flag specifying if struck out
    WORD    fsWeight;         // Weight of font
    BYTE    fsCharSet;        // Character set of font
    WORD    fsPixWidth;       // Width field for the font
    WORD    fsPixHeight;          // Height field for the font
    BYTE    fsPitchAndFamily;     // Flag specifying pitch and family
    WORD    fsAvgWidth;       // Average character width
    WORD    fsMaxWidth;       // Maximum character width
    BYTE    fsFirstChar;          // First character in the font
    BYTE    fsLastChar;       // Last character in the font
    BYTE    fsDefaultChar;        // Default character for out of range
    BYTE    fsBreakChar;          // Character to define wordbreaks
    WORD    fsWidthBytes;         // Number of bytes in each row
    DWORD   fsDevice;         // Offset to device name
    DWORD   fsFace;           // Offset to face name
    DWORD   fsBitsPointer;        // Bits pointer
    DWORD   fsBitsOffset;         // Offset to the begining of the bitmap
    BYTE    fsDBfiller;       // Word alignment for the offset table

    DWORD   fsFlags;          // Bit flags
    WORD    fsAspace;         // Global A space, if any
    WORD    fsBspace;         // Global B space, if any
    WORD    fsCspace;         // Global C space, if any
    DWORD   fsColorPointer;       // offset to color table, if any
    DWORD   fsReserved[4];        //
    BYTE    fsCharOffset;         // Area for storing the char. offsets

    } FontHeader30;

typedef struct tagFFH {
    WORD        fhVersion        ;
    DWORD       fhSize           ;
    char        fhCopyright[60]  ;
    WORD        fhType           ;
    WORD        fhPoints         ;
    WORD        fhVertRes        ;
    WORD        fhHorizRes       ;
    WORD        fhAscent         ;
    WORD        fhInternalLeading;
    WORD        fhExternalLeading;
    BYTE        fhItalic         ;
    BYTE        fhUnderline      ;
    BYTE        fhStrikeOut      ;
    WORD        fhWeight         ;
    BYTE        fhCharSet        ;
    WORD        fhPixWidth       ;
    WORD        fhPixHeight      ;
    BYTE        fhPitchAndFamily ;
    WORD        fhAvgWidth       ;
    WORD        fhMaxWidth       ;
    BYTE        fhFirstChar      ;
    BYTE        fhLastChar       ;
    BYTE        fhDefaultChar    ;
    BYTE        fhBreakChar      ;
    WORD        fhWidthBytes     ;
    DWORD       fhDevice         ;
    DWORD       fhFace           ;
    DWORD       fhBitsPointer    ;
    } FFH;

\**************************************************************************/


// type of the font file

#define TYPE_RASTER                     0x0000
#define TYPE_VECTOR                     0x0001
#define TYPE_BITS_IN_ROM                0x0004
#define TYPE_REALIZED_BY_DEVICE         0x0080

// reserved fields in the fsType field, used are 0-th,2-nd, and 7-th bit

#define BITS_RESERVED (~(TYPE_VECTOR|TYPE_BITS_IN_ROM|TYPE_REALIZED_BY_DEVICE))

// supported in win 3.0

#define DFF_FIXED                0x01    // fixed font
#define DFF_PROPORTIONAL         0x02    // proportional font

// not supported in win 3.0, except maybe if someone has
// custom created such a font, using font editor or a similar tool

#define DFF_ABCFIXED             0x04    // ABC fixed font
#define DFF_ABCPROPORTIONAL      0x08    // ABC proportional font
#define DFF_1COLOR               0x10
#define DFF_16COLOR              0x20
#define DFF_256COLOR             0x40
#define DFF_RGBCOLOR             0x80


// here we list offsets of all fields of the original  structures
// as they are computed under the assumption that the C compiler does not
// insert any paddings between fields

#define  OFF_Version          0L   //   WORD     Always 17985 for the Nonce
#define  OFF_Size             2L   //   DWORD    Size of whole file
#define  OFF_Copyright        6L   //   char[60]

// Note: Win 3.1 hack.  The LSB of Type is used by Win 3.1 as an engine type
//       and font embedding flag.  Font embedding is a form of a "hidden
//       font file".  The MSB of Type is the same as the fsSelection from
//       IFIMETRICS.  (Strictly speaking, the MSB of Type is equal to the
//       LSB of IFIMETRICS.fsSelection).

#define  OFF_Type            66L   //   WORD     Raster Font if Type & 1 == 0
#define  OFF_Points          68L   //   WORD     Nominal Point size
#define  OFF_VertRes         70L   //   WORD     Nominal Vertical resolution
#define  OFF_HorizRes        72L   //   WORD     Nominal Horizontal resolution
#define  OFF_Ascent          74L   //   WORD     Height of Ascent
#define  OFF_IntLeading      76L   //   WORD     Internal (Microsoft) Leading
#define  OFF_ExtLeading      78L   //   WORD     External (Microsoft) Leading
#define  OFF_Italic          80L   //   BYTE     Italic font if set
#define  OFF_Underline       81L   //   BYTE     Etc.
#define  OFF_StrikeOut       82L   //   BYTE     Etc.
#define  OFF_Weight          83L   //   WORD     Weight: 200 = regular
#define  OFF_CharSet         85L   //   BYTE     ANSI=0. other=255
#define  OFF_PixWidth        86L   //   WORD     Fixed width. 0 ==> Variable
#define  OFF_PixHeight       88L   //   WORD     Fixed Height
#define  OFF_Family          90L   //   BYTE     Pitch and Family
#define  OFF_AvgWidth        91L   //   WORD     Width of character 'X'
#define  OFF_MaxWidth        93L   //   WORD     Maximum width
#define  OFF_FirstChar       95L   //   BYTE     First character defined in font
#define  OFF_LastChar        96L   //   BYTE     Last character defined in font
#define  OFF_DefaultChar     97L   //   BYTE     Sub. for out of range chars.
#define  OFF_BreakChar       98L   //   BYTE     Word Break Character
#define  OFF_WidthBytes      99L   //   WORD     No.Bytes/row of Bitmap
#define  OFF_Device         101L   //   DWORD    Pointer to Device Name string
#define  OFF_Face           105L   //   DWORD    Pointer to Face Name String
#define  OFF_BitsPointer    109L   //   DWORD    Pointer to Bit Map
#define  OFF_BitsOffset     113L   //   DWORD    Offset to Bit Map
#define  OFF_jUnused20      117L   //   BYTE     byte filler
#define  OFF_OffTable20     118L   //   WORD     here begins char table for 2.0

// 3.0 addition

#define  OFF_jUnused30      117L       //  BYTE      enforces word allignment
#define  OFF_Flags      118L       //  DWORD     Bit flags
#define  OFF_Aspace     122L       //  WORD      Global A space, if any
#define  OFF_Bspace     124L       //  WORD      Global B space, if any
#define  OFF_Cspace     126L       //  WORD      Global C space, if any
#define  OFF_ColorPointer   128L       //  DWORD     offset to color table, if any
#define  OFF_Reserved       132L       //  DWORD[4]
#define  OFF_OffTable30     148L       //  WORD      Area for storing the char. offsets in 3.0

// latest offset for pscript device font pfm files [bodind]

#if 0

// This is from win31 sources \drivers\printers\pstt\utils\pfm.c [bodind]
........

WORD dfWidthBytes;
DWORD dfDevice;
DWORD dfFace;
DWORD dfBitsPointer;
DWORD dfBitsOffset;  // up to here the offsets are the same as in *.fon files

WORD  dfSizeFields;
DWORD dfExtMetricsOffset;
DWORD dfExtentTable;
DWORD dfOriginTable;
DWORD dfPairKernTable;
DWORD dfTrackKernTable;
DWORD dfDriverInfo;
DWORD dfReserved;

#endif

#define  OFF_SizeFields         117L
#define  OFF_ExtMetricsOffset   119L
#define  OFF_ExtentTable        123L
#define  OFF_OriginTable        127L
#define  OFF_PairKernTable      131L
#define  OFF_TrackKernTable     135L
#define  OFF_DriverInfo         139L
#define  OFF_ReservedPscript    143L


// FFH offsets

#define  OFF_FFH_Version          0L   //   WORD     Always 17985 for the Nonce
#define  OFF_FFH_Size             2L   //   DWORD    Size of whole file
#define  OFF_FFH_Copyright        6L   //   char[60]
#define  OFF_FFH_Type            66L   //   WORD     Raster Font if Type & 1 == 0
#define  OFF_FFH_Points          68L   //   WORD     Nominal Point size
#define  OFF_FFH_VertRes         70L   //   WORD     Nominal Vertical resolution
#define  OFF_FFH_HorizRes        72L   //   WORD     Nominal Horizontal resolution
#define  OFF_FFH_Ascent          74L   //   WORD     Height of Ascent
#define  OFF_FFH_IntLeading      76L   //   WORD     Internal (Microsoft) Leading
#define  OFF_FFH_ExtLeading      78L   //   WORD     External (Microsoft) Leading
#define  OFF_FFH_Italic          80L   //   BYTE     Italic font if set
#define  OFF_FFH_Underline       81L   //   BYTE     Etc.
#define  OFF_FFH_StrikeOut       82L   //   BYTE     Etc.
#define  OFF_FFH_Weight          83L   //   WORD     Weight: 200 = regular
#define  OFF_FFH_CharSet         85L   //   BYTE     ANSI=0. other=255
#define  OFF_FFH_PixWidth        86L   //   WORD     Fixed width. 0 ==> Variable
#define  OFF_FFH_PixHeight       88L   //   WORD     Fixed Height
#define  OFF_FFH_Family          90L   //   BYTE     Pitch and Family
#define  OFF_FFH_AvgWidth        91L   //   WORD     Width of character 'X'
#define  OFF_FFH_MaxWidth        93L   //   WORD     Maximum width
#define  OFF_FFH_FirstChar       95L   //   BYTE     First character defined in font
#define  OFF_FFH_LastChar        96L   //   BYTE     Last character defined in font
#define  OFF_FFH_DefaultChar     97L   //   BYTE     Sub. for out of range chars.
#define  OFF_FFH_BreakChar       98L   //   BYTE     Word Break Character
#define  OFF_FFH_WidthBytes      99L   //   WORD     No.Bytes/row of Bitmap
#define  OFF_FFH_Device         101L   //   DWORD    Pointer to Device Name string
#define  OFF_FFH_Face           105L   //   DWORD    Pointer to Face Name String
#define  OFF_FFH_BitsPointer    109L   //   DWORD    Pointer to Bit Map

#define SIZEFFH (OFF_FFH_BitsPointer + 4)


// This is used in NtGdiMakeFontDir

#define CJ_FONTDIR (SIZEFFH + LF_FACESIZE + LF_FULLFACESIZE + LF_FACESIZE + 10)




// header sizes in bytes of the original headers

#define  HDRSIZE20         117L   //   or 113L ?
#define  HDRSIZE30         148L   //   CharOffset is not counted as header

#define  HDRSIZEDIFF       (HDRSIZE30 - HDRSIZE20)   // 31 byte



// ranges for some quantities

#define MAX_PT_SIZE         999     // max size in points

// weight range

#define MIN_WEIGHT             1    // adaptation guide
#define MAX_WEIGHT          1000    // adaptation guide

// maximal size of bitmap font in pixels, (bound on cx and cy)

#define  MAX_PEL_SIZE  64

// 2.0 fonts have offsets that fit into 64k

#define SEGMENT_SIZE 65536L     // IN bytes

// offset limit for 2.0 font files

#define MAX_20_OFFSET      65534   // 64K - 2

// sizes of the offset table entries for the 2.0 and 3.0 fonts respectively

#define CJ_ENTRY_20  4   // two bytes for cx + two bytes for the offset
#define CJ_ENTRY_30  6   // two bytes for cx + four bytes for the offset


#define WINWT_TO_PANWT(x) ((x)/100 + 1)

// From [Windows 3.1] gdifeng.inc

#define WIN_VERSION 0x0310
#define GDI_VERSION 0x0101


// From [Windows 3.1] gdipfont.inc

#define PF_ENGINE_TYPE  0x03
#define PF_ENCAPSULATED 0x80        // used in FFH.fhType to identify hidden (embedded) font
#define PANDFTYPESHIFT  1

// for embeded fonts

#define PF_TID          0x40    // if set use TID ( WOW apps )
                                // otherwise use PID ( NT apps )


// From [Windows 3.1] fonteng2.asm
#define DEF_BRK_CHARACTER   0x0201  // default char for all TT fonts


// BITMAP size related macros

// number of bytes in a scan of a monobitmap that actually contain some info
// Note that this is the same as ((((cx) + 7) & ~7) >> 3), the last two bits
// are lost anyway because of >> 3

#define CJ_SCAN(cx) (((cx) + 7) >> 3)

// move this to a common place so we don't have it in multiple places
// given a byte count, compute the minimum 4 byte (DWORD) aligned size (in bytes)

#define ALIGN4(X) (((X) + 3) & ~3)

// size of the whole  bimtap, only dword pad the last scan

#define CJ_BMP(cx,cy) ALIGN4(CJ_SCAN(cx) * (cy))

// get the size of GLYPHDATA  structure that at the bottom has appended
// a dib format bitmap for the glyph
// Add  offsetof(GLYPHDATA,aulBMData[2]) to cjDIB to account for cx and cy
// are stored in aulBMData[0] and aulBMData[1] respectively

#define CJ_GLYPHDATA(cx,cy) (offsetof(GLYPHBITS,aj) + CJ_BMP(cx,cy))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\winsockp.h ===
#ifndef _WINSOCKP_H
#define _WINSOCKP_H

#ifdef __cplusplus
extern "C" {
#endif


#ifdef __cplusplus
}
#endif


// ---------------------------------------------------------------------------------------
// XNet Configuration
// ---------------------------------------------------------------------------------------

#define XNET_STARTUP_MANUAL_CONFIG      0x80    // XNetStartup won't configure to defaults

#include <pshpack1.h>

typedef struct {
    BYTE        abSeed[20];                     // Last random seed
    IN_ADDR     ina;                            // Static IP address (0 for DHCP)
    IN_ADDR     inaMask;                        // Static IP subnet mask
    IN_ADDR     inaGateway;                     // Static gateway IP address
    IN_ADDR     inaDnsPrimary;                  // Static primary DNS server IP address
    IN_ADDR     inaDnsSecondary;                // Static secondary DNS server IP address
    char        achDhcpHostName[64];            // Host name for DHCP ("" means no host name)
    char        achPppUserName[64];             // User name for PPPoE ("" means no PPPoE)
    char        achPppPassword[64];             // User password for PPPoE
    char        achPppServer[64];               // Server name for PPPoE ("" ok)
    BYTE        abReserved[192];                // Reserved (makes structure 492 bytes)
    DWORD       dwSigEnd;                       // XNET_CONFIG_PARAMS_SIGEND
} XNetConfigParams;

typedef int __farf__XNetConfigParams[sizeof(XNetConfigParams) == 492];

#define XNET_CONFIG_PARAMS_SIGEND               'XBCP'

#define XNET_CONFIG_NORMAL              0x0000  // Configure normally
#define XNET_CONFIG_TROUBLESHOOT        0x0001  // Configure for troubleshooter in DASH
#define XNET_CONFIG_TROUBLESHOOT_PPPOE  0x0002  // Attempt to discover PPPoE concentrators

typedef struct {
    DWORD       dwFlags;                        // See XNET_STATUS_* below
    IN_ADDR     ina;                            // IP address
    IN_ADDR     inaMask;                        // IP subnet mask
    IN_ADDR     inaGateway;                     // Gateway IP address
    IN_ADDR     inaDnsPrimary;                  // Primary DNS server IP address
    IN_ADDR     inaDnsSecondary;                // Secondary DNS server IP address
    IN_ADDR     inaDhcpServer;                  // IP address of DHCP server
    char        achPppServer[64][4];            // PPPoE concentrators discovered
} XNetConfigStatus;

#define XNET_STATUS_PENDING             0x0001  // XNet configuration is not yet complete
#define XNET_STATUS_PPPOE_DISCOVERED    0x0002  // One or more PPPoE concentrators found
#define XNET_STATUS_PPPOE_CONFIGURED    0x0004  // Credentials accepted by PPPoE concentrator
#define XNET_STATUS_PPPOE_REJECTED      0x0008  // Credentials rejected by PPPoE concentrator
#define XNET_STATUS_PPPOE_NORESPONSE    0x0010  // PPPoE concentrator did not respond
#define XNET_STATUS_DHCP_CONFIGURED     0x0020  // DHCP server provided IP configuration
#define XNET_STATUS_DHCP_REJECTED       0x0040  // DHCP server rejected request
#define XNET_STATUS_DHCP_GATEWAY        0x0080  // DHCP server provided default gateway
#define XNET_STATUS_DHCP_DNS            0x0100  // DHCP server provided DNS servers
#define XNET_STATUS_DHCP_NORESPONSE     0x0200  // DHCP server did not respond
#define XNET_STATUS_DNS_CONFIGURED      0x0400  // DNS server successfully resolved test lookup
#define XNET_STATUS_DNS_FAILED          0x0800  // DNS server failed to resolve test lookup
#define XNET_STATUS_DNS_NORESPONSE      0x1000  // DNS server did not respond to test lookup
#define XNET_STATUS_PING_SUCCESSFUL     0x2000  // ICMP echo to Internet test server successful
#define XNET_STATUS_PING_NORESPONSE     0x4000  // ICMP echo to Internet test server did not respond

#include <poppack.h>

#ifdef __cplusplus
extern "C" {
#endif

INT     WSAAPI XnInit(void ** ppXn, char * pchXbox, const XNetStartupParams * pxnsp, BOOL fWsa, WORD wVersionRequired, LPWSADATA lpWSAData);
INT     WSAAPI XnTerm(void ** ppXn, BOOL fWsa);

INT     WSAAPI XNetConfig(const XNetConfigParams * pxncp, DWORD dwFlags);
INT     WSAAPI XNetGetConfigStatus(XNetConfigStatus * pxncs);

HANDLE  WSAAPI XNetOpenConfigVolume();
BOOL    WSAAPI XNetLoadConfigSector(HANDLE hVolume, UINT iSector, BYTE * pbData, UINT cbData);
BOOL    WSAAPI XNetSaveConfigSector(HANDLE hVolume, UINT iSector, const BYTE * pbData, UINT cbData);
BOOL    WSAAPI XNetCloseConfigVolume(HANDLE hVolume);

BOOL    WSAAPI XNetLoadConfigParams(XNetConfigParams * pxncp);
BOOL    WSAAPI XNetSaveConfigParams(const XNetConfigParams * pxncp);

#ifdef __cplusplus
}
#endif

// ---------------------------------------------------------------------------------------
// Hal Api List
// ---------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#ifdef NT_INCLUDED
    NTSTATUS HalNtOpenFile(char * pszXbox, PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
    NTSTATUS HalNtCreateFile(char * pszXbox, PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions);
    NTSTATUS HalNtReadFile(char * pszXbox, HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset);
    NTSTATUS HalNtWriteFile(char * pszXbox, HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset);
    NTSTATUS HalNtClose(char * pszXbox, HANDLE Handle);

    #define HALNTAPILIST() \
        HALAPI(NTSTATUS, NtOpenFile, (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions), (HALXBOX FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions)) \
        HALAPI(NTSTATUS, NtCreateFile, (PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions), (HALXBOX FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions)) \
        HALAPI(NTSTATUS, NtReadFile, (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset), (HALXBOX FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset)) \
        HALAPI(NTSTATUS, NtWriteFile, (HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset), (HALXBOX FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, ByteOffset)) \
        HALAPI(NTSTATUS, NtClose, (HANDLE Handle), (HALXBOX Handle))
#else
    #define HALNTAPILIST()
    typedef LONG NTSTATUS;
#endif

HANDLE   HalCreateFile(char * pszXbox, LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
NTSTATUS HalExQueryNonVolatileSetting(char * pszXbox, ULONG ValueIndex, ULONG * Type, VOID * Value, ULONG ValueLength, ULONG * ResultLength);
NTSTATUS HalExSaveNonVolatileSetting(char * pszXbox, ULONG ValueIndex, ULONG Type, const VOID * Value, ULONG ValueLength);
NTSTATUS ExQueryNonVolatileSetting(ULONG ValueIndex, ULONG * Type, VOID * Value, ULONG ValueLength, ULONG * ResultLength);
NTSTATUS ExSaveNonVolatileSetting(ULONG ValueIndex, ULONG Type, const VOID * Value, ULONG ValueLength);

#define HALAPILIST() \
    HALAPI(HANDLE,   CreateFile, (LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile), (HALXBOX lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile)) \
    HALAPI(NTSTATUS, ExQueryNonVolatileSetting, (ULONG ValueIndex, ULONG * Type, VOID * Value, ULONG ValueLength, ULONG * ResultLength), (HALXBOX ValueIndex, Type, Value, ValueLength, ResultLength)) \
    HALAPI(NTSTATUS, ExSaveNonVolatileSetting, (ULONG ValueIndex, ULONG Type, const VOID * Value, ULONG ValueLength), (HALXBOX ValueIndex, Type, Value, ValueLength)) \
    HALNTAPILIST()

#ifdef _XBOX
    #define HALXBOX
#else
    #define HALXBOX _achXbox,
#endif

#ifdef __cplusplus
}
#endif

// ---------------------------------------------------------------------------------------
// XNet Api List
// ---------------------------------------------------------------------------------------

#define XNETAPILIST() \
    XNETAPI_(INT,       XnInit, (void ** ppXn, char * pchXbox, const XNetStartupParams * pxnsp, BOOL fWsa, WORD wVersionRequired, LPWSADATA lpWSAData), (ppXn, pchXbox, pxnsp, fWsa, wVersionRequired, lpWSAData)) \
    XNETAPI_(INT,       XnTerm, (void ** ppXn, BOOL fWsa), (ppXn, fWsa)) \
    XNETAPI_(INT,       XNetStartup, (const XNetStartupParams * pxnsp), (pxnsp)) \
    XNETAPI_(INT,       XNetCleanup, (), ()) \
    XNETAPI_(HANDLE,    XNetOpenConfigVolume, (), ()) \
    XNETAPI_(BOOL,      XNetLoadConfigSector, (HANDLE hVolume, UINT iSector, BYTE * pbData, UINT cbData), (hVolume, iSector, pbData, cbData)) \
    XNETAPI_(BOOL,      XNetSaveConfigSector, (HANDLE hVolume, UINT iSector, const BYTE * pbData, UINT cbData), (hVolume, iSector, pbData, cbData)) \
    XNETAPI_(BOOL,      XNetCloseConfigVolume, (HANDLE hVolume), (hVolume)) \
    XNETAPI_(BOOL,      XNetLoadConfigParams, (XNetConfigParams * pxncp), (pxncp)) \
    XNETAPI_(BOOL,      XNetSaveConfigParams, (const XNetConfigParams * pxncp), (pxncp)) \
    XNETAPI (INT,       XNetConfig, (const XNetConfigParams * pxncp, DWORD dwFlags), (pxncp, dwFlags)) \
    XNETAPI (INT,       XNetGetConfigStatus, (XNetConfigStatus * pxncs), (pxncs)) \
    XNETAPI (INT,       XNetRandom, (BYTE * pb, UINT cb), (pb, cb)) \
    XNETAPI (INT,       XNetCreateKey, (XNKID * pxnkid, XNKEY * pxnkey), (pxnkid, pxnkey)) \
    XNETAPI (INT,       XNetRegisterKey, (const XNKID * pxnkid, const XNKEY * pxnkey), (pxnkid, pxnkey)) \
    XNETAPI (INT,       XNetUnregisterKey, (const XNKID * pxnkid), (pxnkid)) \
    XNETAPI (INT,       XNetXnAddrToInAddr, (const XNADDR * pxna, const XNKID * pxnkid, IN_ADDR * pina), (pxna, pxnkid, pina)) \
    XNETAPI (INT,       XNetServerToInAddr, (const IN_ADDR ina, DWORD dwServiceId, IN_ADDR * pina), (ina, dwServiceId, pina)) \
    XNETAPI (INT,       XNetInAddrToXnAddr, (const IN_ADDR ina, XNADDR * pxna, XNKID * pxnkid), (ina, pxna, pxnkid)) \
    XNETAPI (INT,       XNetInAddrToString, (const IN_ADDR ina, char * pchBuf, INT cchBuf), (ina, pchBuf, cchBuf)) \
    XNETAPI (INT,       XNetUnregisterInAddr, (const IN_ADDR ina), (ina)) \
    XNETAPI (INT,       XNetDnsLookup, (const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns), (pszHost, hEvent, ppxndns)) \
    XNETAPI (INT,       XNetDnsRelease, (XNDNS * pxndns), (pxndns)) \
    XNETAPI (INT,       XNetQosListen, (const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags), (pxnkid, pb, cb, dwBitsPerSec, dwFlags)) \
    XNETAPI (INT,       XNetQosXnAddr, (UINT cxnqos, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos), (cxnqos, apxna, apxnkid, apxnkey, dwFlags, hEvent, ppxnqos)) \
    XNETAPI (INT,       XNetQosServer, (UINT cxnqos, const IN_ADDR aina[], const DWORD adwServiceId[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos), (cxnqos, aina, adwServiceId, dwFlags, hEvent, ppxnqos)) \
    XNETAPI (INT,       XNetQosRelease, (XNQOS * pxnqos), (pxnqos)) \
    XNETAPI (DWORD,     XNetGetTitleXnAddr, (XNADDR * pxna), (pxna)) \
    XNETAPI (DWORD,     XNetGetDebugXnAddr, (XNADDR * pxna), (pxna)) \
    XNETAPI_(DWORD,     XNetGetEthernetLinkStatus, (), ()) \

#define SOCKAPILIST() \
    XNETAPI_(INT,       WSAStartup, (WORD wVersionRequired, LPWSADATA lpWSAData), (wVersionRequired, lpWSAData)) \
    XNETAPI_(INT,       WSACleanup, (), ()) \
    XNETAPI (SOCKET,    socket, (IN int af, IN int type, IN int protocol), (af, type, protocol)) \
    XNETAPI (int,       closesocket, (IN SOCKET s), (s)) \
    XNETAPI (int,       shutdown, (IN SOCKET s, IN int how), (s, how)) \
    XNETAPI (int,       ioctlsocket, (SOCKET s, long cmd, u_long* argp), (s, cmd, argp)) \
    XNETAPI (int,       setsockopt, (SOCKET s, int level, int optname, const char* optval, int optlen), (s, level, optname, optval, optlen)) \
    XNETAPI (int,       getsockopt, (SOCKET s, int level, int optname, char * optval, int * optlen), (s, level, optname, optval, optlen)) \
    XNETAPI (int,       getsockname, (SOCKET s, struct sockaddr * name, int * namelen), (s, name, namelen)) \
    XNETAPI (int,       getpeername, (SOCKET s, struct sockaddr * name, int * namelen), (s, name, namelen)) \
    XNETAPI (int,       bind, (SOCKET s, const struct sockaddr * name, int namelen), (s, name, namelen)) \
    XNETAPI (int,       connect, (SOCKET s, const struct sockaddr * name, int namelen), (s, name, namelen)) \
    XNETAPI (int,       listen, (SOCKET s, int backlog), (s, backlog)) \
    XNETAPI (SOCKET,    accept, (SOCKET s, struct sockaddr * addr, int * addrlen), (s, addr, addrlen)) \
    XNETAPI (int,       select, (int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const struct timeval* timeout), (nfds, readfds, writefds, exceptfds, timeout)) \
    XNETAPI (BOOL,      WSAGetOverlappedResult, (SOCKET s, LPWSAOVERLAPPED overlapped, LPDWORD byteCount, BOOL fWait, LPDWORD flags), (s, overlapped, byteCount, fWait, flags)) \
    XNETAPI (INT,       WSACancelOverlappedIO, (SOCKET s), (s)) \
    XNETAPI (int,       recv, (SOCKET s, char* buf, int len, int flags), (s, buf, len, flags)) \
    XNETAPI (int,       WSARecv, (SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesRecv, LPDWORD flags, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc), (s, bufs, bufcnt, bytesRecv, flags, overlapped, completionproc)) \
    XNETAPI (int,       recvfrom, (SOCKET s, char FAR * buf, int len, int flags, struct sockaddr * from, int * fromlen), (s, buf, len, flags, from, fromlen)) \
    XNETAPI (int,       WSARecvFrom, (SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesRecv, LPDWORD flags, struct sockaddr * fromaddr, LPINT fromlen, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc), (s, bufs, bufcnt, bytesRecv, flags, fromaddr, fromlen, overlapped, completionproc)) \
    XNETAPI (int,       send, (SOCKET s, const char* buf, int len, int flags), (s, buf, len, flags)) \
    XNETAPI (int,       WSASend, (SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesSent, DWORD flags, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc), (s, bufs, bufcnt, bytesSent, flags, overlapped, completionproc)) \
    XNETAPI (int,       sendto, (SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen), (s, buf, len, flags, to, tolen)) \
    XNETAPI (int,       WSASendTo, (SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesSent, DWORD flags, const struct sockaddr* toaddr, int tolen, LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc), (s, bufs, bufcnt, bytesSent, flags, toaddr, tolen, overlapped, completionproc)) \
    XNETAPI_(ULONG,     inet_addr, (const char * pch), (pch)) \
    XNETAPI_(u_long,    htonl, (u_long hostlong), (hostlong)) \
    XNETAPI_(u_short,   htons, (u_short hostshort), (hostshort)) \
    XNETAPI_(u_long,    ntohl, (u_long netlong), (netlong)) \
    XNETAPI_(u_short,   ntohs, (u_short netshort), (netshort)) \
    XNETAPI_(int,       WSAGetLastError, (), ()) \
    XNETAPI_(void,      WSASetLastError, (int error), (error)) \
    XNETAPI_(WSAEVENT,  WSACreateEvent, (), ()) \
    XNETAPI_(BOOL,      WSACloseEvent, (WSAEVENT hEvent), (hEvent)) \
    XNETAPI_(BOOL,      WSASetEvent, (WSAEVENT hEvent), (hEvent)) \
    XNETAPI_(BOOL,      WSAResetEvent, (WSAEVENT hEvent), (hEvent)) \
    XNETAPI_(DWORD,     WSAWaitForMultipleEvents, (DWORD cEvents, const WSAEVENT * lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable), (cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable)) \
    XNETAPI_(int,       __WSAFDIsSet, (SOCKET fd, fd_set * set), (fd, set)) \

// If the compiler chokes on the following macro expansion, it means that one or more
// of the prototypes defined in this file is out of sync with the prototype in XNETAPILIST
// or SOCKAPILIST.

#ifdef __cplusplus
extern "C" {
#endif

#undef  XNETAPI
#define XNETAPI(ret, fname, arglist, paramlist) XBOXAPI ret WSAAPI fname arglist;
#undef  XNETAPI_
#define XNETAPI_(ret, fname, arglist, paramlist) XBOXAPI ret WSAAPI fname arglist;

#ifdef __cplusplus
}
#endif

// ---------------------------------------------------------------------------------------
// CXNet
// ---------------------------------------------------------------------------------------

#ifdef __cplusplus

class CXNet
{
    friend class CXn;

public:

    // Constructor -----------------------------------------------------------------------

    #ifdef _XBOX
        __forceinline CXNet(char * pszXbox = NULL) {}
        #define GetAchXbox() NULL
        #define _WSAAPI_ WSAAPI
    #else
        __forceinline CXNet(char * pszXbox = NULL) { _pXn = NULL; SetAchXbox(pszXbox); }
        __forceinline char *    GetAchXbox() { return(_achXbox); }
        __forceinline void      SetAchXbox(char * pszXbox) { _achXbox[sizeof(_achXbox) - 1] = 0; strncpy(_achXbox, pszXbox ? pszXbox : "xb1@Lan", sizeof(_achXbox) - 1); }
        __forceinline CXn *     GetXn() { return(_pXn); }
        __forceinline CXn **    GetXnRef() { return(&_pXn); }
        __forceinline void      SetXn(CXn * pXn) { _pXn = pXn; }
        #define _WSAAPI_ CXNet::
    #endif

    // API -------------------------------------------------------------------------------

    #undef  XNETAPI
    #undef  XNETAPI_
    #undef  HALAPI

    #ifdef _XBOX
        #define XNETAPI(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
        #define XNETAPI_(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
        #define HALAPI(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
    #else
        #define XNETAPI(ret, fname, arglist, paramlist) ret fname arglist;
        #define XNETAPI_(ret, fname, arglist, paramlist) ret fname arglist;
        #define HALAPI(ret, fname, arglist, paramlist)  __forceinline ret fname arglist { return(Hal##fname paramlist); }
    #endif

    XNETAPILIST()
    SOCKAPILIST()
    HALAPILIST()

    // Data ------------------------------------------------------------------------------

private:

    #ifndef _XBOX
        CXn *   _pXn;                       // Pointer to CXn instance of this stack
        char    _achXbox[64];               // Name of this virtual xbox
    #endif

};

#endif

// ---------------------------------------------------------------------------------------
// Simulated Network Address Translator
// ---------------------------------------------------------------------------------------

#if defined(__cplusplus) && !defined(_XBOX)

#define NAT_ASSIGN_MINIMAL          0x00
#define NAT_ASSIGN_AGGRESSIVE       0x01

#define NAT_FILTER_NONE             0x00
#define NAT_FILTER_ADDRESS          0x01
#define NAT_FILTER_PORT             0x02
#define NAT_FILTER_ADDRESS_PORT     0x03

#define NAT_RECV_OUTER_TO_INNER     0x01    // Packet from outer going to inner
#define NAT_RECV_INNER_TO_OUTER     0x02    // Packet from inner going to outer
#define NAT_RECV_INNER_TO_INNER     0x03    // Packet from inner going to inner

typedef void (* PFNNATRECV)(void * pvNat, void * pvPkt, UINT cbPkt, DWORD dwFlags, IN_ADDR inaOrig, WORD wPortOrig);

struct NATCREATE
{
    XNetStartupParams * _pxnsp;             // Pointer to startup params (or NULL)
    XNetConfigParams    _xncpInner;         // Inner network configuration
    XNetConfigParams    _xncpOuter;         // Outer network configuration
    char                _achXboxInner[64];  // Inner virtual xbox name
    char                _achXboxOuter[64];  // Outer virtual xbox name
    IN_ADDR             _inaBase;           // Base IP address to give to DHCP clients
    IN_ADDR             _inaLast;           // Last IP address to give to DHCP clients
    DWORD               _dwLeaseTime;       // Default DHCP lease time in seconds
    UINT                _iAssign;           // One of NAT_ASSIGN_* constants
    UINT                _iFilter;           // One of NAT_FILTER_* constants
    UINT                _iTimeout;          // Inactivity timeout in seconds
    UINT                _iNatPortBase;      // Base NAT port to assign
    UINT                _cNatPort;          // Number of NAT ports to assign
    PFNNATRECV          _pfnNatRecv;        // Hook function to intercept packets
};

#ifdef __cplusplus
extern "C" {
#endif

void *  WSAAPI XNetNatCreate(NATCREATE * pNatCreate);
void    WSAAPI XNetNatDelete(void * pvNat);
void    WSAAPI XNetNatXmit(void * pvNat, void * pvPkt, BOOL fDiscard);

#ifdef __cplusplus
}
#endif

#endif

#endif  /* _WINSOCKP_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xbdmp.h ===
//
//
// Xbox debug interface functions -- internal version
// Copyright Microsoft Corporation 2000 - 2001. All Rights Reserved.
//
//
#ifndef _XBDMP_H
#define _XBDMP_H

#define DMN_MODFLAG_PEHEADER 0x8000
#define DMCOUNT_SYNCCD    0x00100000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\wsockntp.h ===
#ifndef _WSOCKPNT_H
#define _WSOCKPNT_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    IN_ADDR     ina;                            // IP address (zero if not static/DHCP)
    IN_ADDR     inaOnline;                      // Online IP address (zero if not online)
    WORD        wPortOnline;                    // Online port
    BYTE        abEnet[6];                      // Ethernet MAC address
    BYTE        abOnline[20];                   // Online identification
} XNADDR;

typedef struct {
    BYTE        ab[8];                          // xbox to xbox key identifier
} XNKID;

#define XNET_XNKID_MASK             0xF0        // Mask of flag bits in first byte of XNKID
#define XNET_XNKID_SYSTEM_LINK      0x00        // Peer to peer system link session
#define XNET_XNKID_ONLINE_PEER      0x80        // Peer to peer online session
#define XNET_XNKID_ONLINE_SERVER    0xC0        // Client to server online session

#define XNetXnKidIsSystemLink(pxnkid)           (((pxnkid)->ab[0] & 0xC0) == XNET_XNKID_SYSTEM_LINK)
#define XNetXnKidIsOnlinePeer(pxnkid)           (((pxnkid)->ab[0] & 0xC0) == XNET_XNKID_ONLINE_PEER)
#define XNetXnKidIsOnlineServer(pxnkid)         (((pxnkid)->ab[0] & 0xC0) == XNET_XNKID_ONLINE_SERVER)

typedef struct {
    BYTE        ab[16];                         // xbox to xbox key exchange key
} XNKEY;


#ifdef __cplusplus
}
#endif

#endif  /* _WSOCKPNT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\winuserp.h ===
/*++
Copyright (c) 1985-1999, Microsoft Corporation

Module Name:

    winuserp.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the User
    component.

--*/
#ifndef _WINUSERP_
#define _WINUSERP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#ifdef STRICT
#else /* !STRICT */
#endif /* !STRICT */
#ifdef STRICT
#else /* !STRICT */
#endif /* !STRICT */
#ifdef UNICODE
#else  /* !UNICODE */
#endif /* UNICODE */
#define RT_MENUEX       MAKEINTRESOURCE(13)     // RT_MENU subtype
#define RT_NAMETABLE    MAKEINTRESOURCE(15)     // removed in 3.1
#define RT_DIALOGEX     MAKEINTRESOURCE(18)     // RT_DIALOG subtype
#define RT_LAST         MAKEINTRESOURCE(23)
#define RT_AFXFIRST     MAKEINTRESOURCE(0xF0)   // reserved: AFX
#define RT_AFXLAST      MAKEINTRESOURCE(0xFF)   // reserved: AFX
/* Max number of characters. Doesn't include termination character */
#define WSPRINTF_LIMIT 1024
#define SETWALLPAPER_METRICS    ((LPWSTR)-2)
#define SB_MAX              3
#define SB_CMD_MAX          8
#define AW_VALID                    (AW_HOR_POSITIVE |\
                                     AW_HOR_NEGATIVE |\
                                     AW_VER_POSITIVE |\
                                     AW_VER_NEGATIVE |\
                                     AW_CENTER       |\
                                     AW_HIDE         |\
                                     AW_ACTIVATE     |\
                                     AW_BLEND        |\
                                     AW_SLIDE)
/*
 * GetAppCompatFlags2 flags
 */
#define GACF2_ANIMATIONOFF        0x00000001  // do not animate menus and listboxes
#define GACF2_KCOFF               0x00000002  // do not send Keyboard Cues messages
#define GACF2_NO50EXSTYLEBITS     0x00000004  // mask out post-4.0 extended style bits for SetWindowLong
#define GACF2_NODRAWPATRECT       0x00000008  // disable DRAWPATTERNRECT accel via ExtEscape()
#define GACF2_MSSHELLDLG          0x00000010  // if there is a request for MS Shell Dlg (which
                                              // usually maps to MS Sans Serif (bitmap) on NT 4 and
                                              // Microsoft Sans Serif (TrueType) on NT 5), then
                                              // behave as though we are using the bitmap
                                              // font (MS Sans Serif).
#define GACF2_NODDETRKDYING       0x00000020  // Be like Win9x: don't post WM_DDE_TERMINATE if
                                              // the window is destroyed while in a conversation
#define GACF2_GIVEUPFOREGROUND    0x00000040  // In W2k, we have changed foreground semantics to stop
                                              // foreground focus stealing by one app if another app
                                              // is active. However, this has caused  a few app compat
                                              // bugs. This appcompat flag is used to enable the old foreground
                                              // focus behaviour for these bugs.
#define GACF2_ACTIVEMENUS         0x00000080  // In W2k, we set the inactive look on menus that belong
                                              // to non-rofeground windows.  Some applications get in trouble
                                              // see #58227
#define GACF2_EDITNOMOUSEHIDE     0x00000100  // Typing in edit controls hides the cursor.
                                              // Some apps are surprised by that: #307615
#define GACF2_NOBATCHING          0X00000200  // Turn GDI batching off
#define GACF2_FONTSUB             0X00000400  // Only for Notes R5
#define GACF2_NO50EXSTYLEBITSCW   0x00000800  // mask out post-4.0 extended style bits for CreateWindow
#define GACF2_NOCUSTOMPAPERSIZES  0x00001000  // PostScript driver bit for Harvard Graphics
#define GACF2_DDE                 0x00002000  // all the DDE hacks
#define GACF2_DEFAULTCHARSET      0x00004000  // LOGFONT bit for QuickBook OCR-A font
#define GACF2_NOCHAR_DEADKEY      0x00008000  // No character composition on dead key on dead key (NT4 behavior)
#define GACF2_NO_TRYEXCEPT_CALLWNDPROC \
                                  0x00010000  // No try ~ except clause around WndProc call, let the app's handler
                                              // handle it even though it skips some API stacks.
                                              // See #359866

/*
 * Version macros
 */
#define VERMAX          0x9900  // ignore the version

#define VER50           0x0500
#define VER40           0x0400
#define VER31           0x030A
#define VER30           0x0300

#define Is500Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER50)
#define Is400Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER40)
#define Is310Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER31)
#define Is300Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER30)

#define VK_NONE           0x00
/*
 * NEC PC-9800 Series definitions
 */
#define VK_OEM_NEC_SEPARATE 0x6C
#define VK_APPCOMMAND_FIRST    0xA6
#define VK_APPCOMMAND_LAST     0xB7
/*
 * Fujitsu/OASYS definitions - clash with SpeedRacer etc.
 */
#define VK_OEM_OAS_1      0xB4
#define VK_OEM_OAS_2      0xB5
#define VK_OEM_OAS_3      0xB6
#define VK_OEM_OAS_4      0xB7
#define VK_OEM_OAS_5      0xB8
#define VK_OEM_OAS_6      0xB9
#define VK_OEM_OAS_7      0xC1
#define VK_OEM_OAS_8      0xC2
#define VK_OEM_OAS_9      0xC3
#define VK_OEM_OAS_10     0xC4
#define VK_OEM_OAS_11     0xC5
#define VK_OEM_OAS_12     0xC6
#define VK_OEM_OAS_13     0xC7
#define VK_OEM_OAS_14     0xC8
#define VK_OEM_OAS_15     0xC9
#define VK_OEM_OAS_16     0xCA
#define VK_OEM_OAS_17     0xCB
#define VK_OEM_OAS_18     0xCC
#define VK_OEM_OAS_19     0xCD
#define VK_OEM_OAS_20     0xCE
#define VK_OEM_OAS_21     0xCF
#define VK_OEM_OAS_22     0xD0
#define VK_OEM_OAS_23     0xD1
#define VK_OEM_OAS_24     0xD2
#define VK_OEM_OAS_25     0xD3
#define VK_OEM_OAS_26     0xD4
#define VK_OEM_OAS_27     0xD5
#define VK_OEM_OAS_28     0xD6
#define VK_OEM_OAS_29     0xD7
#define VK_OEM_FJ_DUMMY   0xEF
/*
 * Additional modifier keys.
 * Used for ISO9995 "Information technology - Keyboard layouts for text and
 * office systems" (French Canadian keyboard,
 */
#define VK_GROUPSHIFT     0xE5
#define VK_RGROUPSHIFT    0xE6
#if !defined(_WIN32_WINDOWS)
#define WH_HARDWARE         8
#endif
#define WH_CHOOKS          (WH_MAXHOOK - WH_MINHOOK + 1)
#define MSGF_MOVE           3
#define MSGF_SIZE           4
#define MSGF_CBTHOSEBAGSUSEDTHIS  7
#define MSGF_MAINLOOP       8
#define HSHELL_SYSMENU              9
#define HSHELL_ENDTASK              10
#define HSHELL_HIGHBIT            0x8000
#define HSHELL_FLASH              (HSHELL_REDRAW|HSHELL_HIGHBIT)
#define HSHELL_RUDEAPPACTIVATED   (HSHELL_WINDOWACTIVATED|HSHELL_HIGHBIT)
#define APPCOMMAND_FIRST                  1
#define APPCOMMAND_LAST                   23
// This needs to be internal until the shell catches up
typedef struct
{
    HWND    hwnd;
    RECT    rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;
#define KLF_UNLOADPREVIOUS  0x00000004
#define KLF_FAILSAFE        0x00000200

/*
 * Keyboard Layout Attributes
 * These are specified in the layout DLL itself, or in the registry under
 * MACHINE\System\CurrentControlSet\Control\Keyboard Layouts\*\Attributes
 * as KLF_ values between 0x00010000 and 0x00800000.  Any attributes specified
 * by the layout DLL are ORed with the attributes obtained from the registry.
 */
#define KLF_LRM_RLM         0x00020000
#define KLF_ATTRIBUTE2      0x00040000
#define KLF_ATTRIBUTE3      0x00080000
#define KLF_ATTRIBUTE4      0x00100000
#define KLF_ATTRIBUTE5      0x00200000
#define KLF_ATTRIBUTE6      0x00400000
#define KLF_ATTRIBUTE7      0x00800000
#define KLF_ATTRMASK        0x00FF0000
#define KLF_INITTIME        0x80000000
#define KLF_VALID           0xC000019F | KLF_ATTRMASK

WINUSERAPI
HKL
WINAPI
LoadKeyboardLayoutEx(
    IN HKL hkl,
    IN LPCWSTR pwszKLID,
    IN UINT Flags);

#ifndef NOWINDOWSTATION
#endif  /* !NOWINDOWSTATION */

/*
 *    Private API, originally for Cairo Shell, which calls FHungApp
 *    based on the hwnd supplied.  Used for fake system menus on the
 *    shell tray.
 */

BOOL IsHungAppWindow( IN HWND hwnd);

BOOL WowWaitForMsgAndEvent( IN HANDLE hevent);

WINUSERAPI VOID WINAPI RegisterSystemThread( IN DWORD flags, IN DWORD reserved);
#define RST_DONTATTACHQUEUE       0x00000001
#define RST_DONTJOURNALATTACH     0x00000002
#define RST_ALWAYSFOREGROUNDABLE  0x00000004
#define RST_FAULTTHREAD           0x00000008
#define GWL_WOWWORDS        (-1)
#ifdef _WIN64
#undef GWL_WOWWORDS
#endif /* _WIN64 */
#define GWLP_WOWWORDS       (-1)
#define GCL_WOWWORDS        (-27)
#define GCL_WOWMENUNAME     (-29)
#ifdef _WIN64
#undef GCL_WOWWORDS
#endif /* _WIN64 */
#define GCLP_WOWWORDS       (-27)
#define WM_SIZEWAIT                     0x0004
#define WM_SETVISIBLE                   0x0009
#define WM_SYSTEMERROR                  0x0017
/*
 * This is used by DefWindowProc() and DefDlgProc(), it's the 16-bit version
 * of the WM_CTLCOLORBTN, WM_CTLCOLORDLG, ... messages.
 */
#define WM_CTLCOLOR                     0x0019
#define WM_LOGOFF                       0x0025
#define WM_ALTTABACTIVE                 0x0029
#define WM_FILESYSCHANGE                0x0034

#define WM_SHELLNOTIFY                  0x0034
#define SHELLNOTIFY_DISKFULL            0x0001
#define SHELLNOTIFY_OLELOADED           0x0002
#define SHELLNOTIFY_OLEUNLOADED         0x0003
#define SHELLNOTIFY_WALLPAPERCHANGED    0x0004

#define WM_ISACTIVEICON                 0x0035
#define WM_QUERYPARKICON                0x0036
#define WM_WINHELP                      0x0038
#define WM_FULLSCREEN                   0x003A
#define WM_CLIENTSHUTDOWN               0x003B
#define WM_DDEMLEVENT                   0x003C
#define MM_CALCSCROLL                   0x003F
#define WM_TESTING                      0x0040
#define WM_OTHERWINDOWCREATED           0x0042
#define WM_OTHERWINDOWDESTROYED         0x0043
#define WM_COPYGLOBALDATA               0x0049
#define WM_LOGONNOTIFY                  0x004C
#define WM_KEYF1                        0x004D
#define WM_ACCESS_WINDOW                0x004F
#define WM_FINALDESTROY                 0x0070  /* really destroy (window not locked) */
#define WM_MEASUREITEM_CLIENTDATA       0x0071  /* WM_MEASUREITEM bug clientdata thunked already */
#define WM_SYNCTASK                     0x0089

#define WM_KLUDGEMINRECT                0x008B
#define WM_LPKDRAWSWITCHWND             0x008C
#define WM_NCMOUSEFIRST                 0x00A0

/*
 * Skip value 0x00AA, which would correspond to the non-client
 * mouse wheel message if there were such a message.
 * We do that in order to maintain a constant value for
 * the difference between the client and nonclient version of
 * a mouse message, e.g.
 *     WM_LBUTTONDOWN - WM_NCLBUTTONDOWN == WM_XBUTTONDOWN - WM_NCXBUTTONDOWN
 */

#define WM_NCXBUTTONFIRST               0x00AB
#define WM_NCXBUTTONLAST                0X00AD
#define WM_NCMOUSELAST                  0x00AD
#define WM_CONVERTREQUESTEX             0x0108
#define WM_YOMICHAR                     0x0108
#define WM_CONVERTREQUEST               0x010A
#define WM_CONVERTRESULT                0x010B
#define WM_INTERIM                      0x010C
#define WM_SYSTIMER                     0x0118
#define UIS_LASTVALID   UIS_INITIALIZE
#define UISF_VALID   (UISF_HIDEFOCUS | UISF_HIDEACCEL)
#define WM_LBTRACKPOINT                 0x0131
#define MN_FIRST                        0x01E0
#define MN_SETHMENU                     (MN_FIRST + 0)
#define MN_GETHMENU                     (MN_FIRST + 1)
#define MN_SIZEWINDOW                   (MN_FIRST + 2)
#define MN_OPENHIERARCHY                (MN_FIRST + 3)
#define MN_CLOSEHIERARCHY               (MN_FIRST + 4)
#define MN_SELECTITEM                   (MN_FIRST + 5)
#define MN_CANCELMENUS                  (MN_FIRST + 6)
#define MN_SELECTFIRSTVALIDITEM         (MN_FIRST + 7)

#define MN_GETPPOPUPMENU                (MN_FIRST + 10)
#define MN_FINDMENUWINDOWFROMPOINT      (MN_FIRST + 11)
#define MN_SHOWPOPUPWINDOW              (MN_FIRST + 12)
#define MN_BUTTONDOWN                   (MN_FIRST + 13)
#define MN_MOUSEMOVE                    (MN_FIRST + 14)
#define MN_BUTTONUP                     (MN_FIRST + 15)
#define MN_SETTIMERTOOPENHIERARCHY      (MN_FIRST + 16)
#define MN_DBLCLK                       (MN_FIRST + 17)
#define MN_ACTIVATEPOPUP                (MN_FIRST + 18)
#define MN_ENDMENU                      (MN_FIRST + 19)
#define MN_DODRAGDROP                   (MN_FIRST + 20)
#define MN_LASTPOSSIBLE                 (MN_FIRST + 31)
#define WM_XBUTTONFIRST                 0x020B
#define WM_XBUTTONLAST                  0X020D
#define XBUTTON_MASK  (XBUTTON1 | XBUTTON2)
#define WM_DROPOBJECT                   0x022A
#define WM_QUERYDROPOBJECT              0x022B

#define WM_BEGINDRAG                    0x022C
#define WM_DRAGLOOP                     0x022D
#define WM_DRAGSELECT                   0x022E
#define WM_DRAGMOVE                     0x022F
#define WM_KANJIFIRST                   0x0280
#define WM_IME_SYSTEM                   0x0287
#define WM_KANJILAST                    0x029F

#define WM_TRACKMOUSEEVENT_FIRST        0x02A0
#define WM_TRACKMOUSEEVENT_LAST         0x02AF
#define WM_PALETTEGONNACHANGE           0x0310
#define WM_CHANGEPALETTE                0x0311
#define WM_SYSMENU                      0x0313
#define WM_HOOKMSG                      0x0314
#define WM_EXITPROCESS                  0x0315
#define WM_WAKETHREAD                   0x0316
#define WM_NOTIFYWOW                    0x0340
#define WM_COALESCE_FIRST               0x0390
#define WM_COALESCE_LAST                0x039F

#define WM_INTERNAL_DDE_FIRST           0x03E0
#define WM_INTERNAL_DDE_LAST            0x03EF
#define WM_COALESCE_FIRST               0x0390
#define WM_COALESCE_LAST                0x039F

#define WM_MM_RESERVED_FIRST            0x03A0
#define WM_MM_RESERVED_LAST             0x03DF

#define WM_CBT_RESERVED_FIRST           0x03F0
#define WM_CBT_RESERVED_LAST            0x03FF
/* wParam for WM_NOTIFYWOW message  */
#define WMNW_UPDATEFINDREPLACE  0
#define WMSZ_KEYSIZE        0
#define WMSZ_MOVE           9
#define WMSZ_KEYMOVE        10
#define WMSZ_SIZEFIRST      WMSZ_LEFT
#define SMTO_BROADCAST      0x0004
#define SMTO_VALID          0x000F
#define ICON_RECREATE       2
#define WVR_MINVALID        WVR_ALIGNTOP
#define WVR_MAXVALID        WVR_VALIDRECTS
#if(WINVER >= 0x0500)
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_NONCLIENT | TME_QUERY | TME_CANCEL)
#else
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_QUERY | TME_CANCEL)
#endif
#define WS_VALID            (WS_OVERLAPPED     | \
                             WS_POPUP          | \
                             WS_CHILD          | \
                             WS_MINIMIZE       | \
                             WS_VISIBLE        | \
                             WS_DISABLED       | \
                             WS_CLIPSIBLINGS   | \
                             WS_CLIPCHILDREN   | \
                             WS_MAXIMIZE       | \
                             WS_CAPTION        | \
                             WS_BORDER         | \
                             WS_DLGFRAME       | \
                             WS_VSCROLL        | \
                             WS_HSCROLL        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_GROUP          | \
                             WS_TABSTOP        | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)
#define WS_EX_DRAGOBJECT        0x00000002L
#define WS_EX_ANSICREATOR       0x80000000L
/*
 * These are not extended styles but rather state bits.
 * We use these bit positions to delay the addition of a new
 * state DWORD in the window structure.
 */
#define WS_EXP_FOCUSHIDDEN      0x80000000
#define WS_EXP_ACCELHIDDEN      0x40000000
/*
 * RTL Mirroring Extended Styles (RTL_MIRRORING)
 */
#define WS_EX_LAYOUTVBHRESERVED 0x00200000L
#define WS_EX_LAYOUTBTTRESERVED 0x00800000L
#define WS_EX_ALLEXSTYLES    (WS_EX_TRANSPARENT | WS_EX_DLGMODALFRAME | WS_EX_DRAGOBJECT | WS_EX_NOPARENTNOTIFY | WS_EX_TOPMOST | WS_EX_ACCEPTFILES)

#define WS_EX_VALID          (WS_EX_DLGMODALFRAME  | \
                              WS_EX_DRAGOBJECT     | \
                              WS_EX_NOPARENTNOTIFY | \
                              WS_EX_TOPMOST        | \
                              WS_EX_ACCEPTFILES    | \
                              WS_EX_TRANSPARENT    | \
                              WS_EX_ALLEXSTYLES)

#define WS_EX_VALID40        (WS_EX_VALID          | \
                              WS_EX_MDICHILD       | \
                              WS_EX_WINDOWEDGE     | \
                              WS_EX_CLIENTEDGE     | \
                              WS_EX_CONTEXTHELP    | \
                              WS_EX_TOOLWINDOW     | \
                              WS_EX_RIGHT          | \
                              WS_EX_LEFT           | \
                              WS_EX_RTLREADING     | \
                              WS_EX_LEFTSCROLLBAR  | \
                              WS_EX_CONTROLPARENT  | \
                              WS_EX_STATICEDGE     | \
                              WS_EX_APPWINDOW)

#define WS_EX_VALID50        (WS_EX_VALID40        | \
                              WS_EX_LAYERED        | \
                              WS_EX_NOINHERITLAYOUT| \
                              WS_EX_LAYOUTRTL      | \
                              WS_EX_NOACTIVATE)

#define WS_EX_INTERNAL       (WS_EX_DRAGOBJECT     | \
                              WS_EX_ANSICREATOR)

/*
 * We currently return to applications only the valid Ex_Style bits.
 * If declaring another macro i.e. WS_EX_VALID60, make sure to change WS_EX_ALLVALID
 */
#define WS_EX_ALLVALID        WS_EX_VALID50


#define WF_DIALOG_WINDOW      0x00010000     // used in WOW32 -- this is a state flag, not a style flag
#define CS_KEYCVTWINDOW     0x0004
#define CS_OEMCHARS         0x0010  /* reserved (see user\server\usersrv.h) */
#define CS_NOKEYCVT         0x0100
#define CS_LVB              0x0400
#define CS_SYSTEM           0x8000
#define CS_VALID            (CS_VREDRAW           | \
                             CS_HREDRAW           | \
                             CS_KEYCVTWINDOW      | \
                             CS_DBLCLKS           | \
                             0x0010               | \
                             CS_OWNDC             | \
                             CS_CLASSDC           | \
                             CS_PARENTDC          | \
                             CS_NOKEYCVT          | \
                             CS_NOCLOSE           | \
                             CS_SAVEBITS          | \
                             CS_BYTEALIGNCLIENT   | \
                             CS_BYTEALIGNWINDOW   | \
                             CS_GLOBALCLASS       | \
                             CS_IME)
#define CS_VALID31            0x0800ffef
#define CS_VALID40            0x0801feeb
#define BDR_VALID       0x000F
#define BF_VALID       (BF_MIDDLE |  \
                        BF_SOFT   |  \
                        BF_ADJUST |  \
                        BF_FLAT   |  \
                        BF_MONO   |  \
                        BF_LEFT   |  \
                        BF_TOP    |  \
                        BF_RIGHT  |  \
                        BF_BOTTOM |  \
                        BF_DIAGONAL)
#define DFC_CACHE               0xFFFF
#define DFCS_CAPTIONALL         0x000F
#define DFCS_INMENU             0x0040
#define DFCS_INSMALL            0x0080
#define DFCS_MENUARROWUP        0x0008
#define DFCS_MENUARROWDOWN      0x0010

#define DFCS_SCROLLMIN          0x0000
#define DFCS_SCROLLVERT         0x0000
#define DFCS_SCROLLMAX          0x0001
#define DFCS_SCROLLHORZ         0x0002
#define DFCS_SCROLLLINE         0x0004

#define DFCS_CACHEICON          0x0000
#define DFCS_CACHEBUTTONS       0x0001

#define DC_NOVISIBLE        0x0800
#define DC_BUTTONS          0x1000
#define DC_NOSENDMSG        0x2000
#define DC_CENTER           0x4000
#define DC_FRAME            0x8000
#define DC_CAPTION          (DC_ICON | DC_TEXT | DC_BUTTONS)
#define DC_NC               (DC_CAPTION | DC_FRAME)
WINUSERAPI
BOOL
WINAPI
DrawCaptionTempA(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HFONT,
    IN HICON,
    IN LPCSTR,
    IN UINT);
WINUSERAPI
BOOL
WINAPI
DrawCaptionTempW(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HFONT,
    IN HICON,
    IN LPCWSTR,
    IN UINT);
#ifdef UNICODE
#define DrawCaptionTemp  DrawCaptionTempW
#else
#define DrawCaptionTemp  DrawCaptionTempA
#endif // !UNICODE
#define IDANI_CLOSE         2
#define IDANI_CAPTION       3
#define CF_FIRST            0
#define WPF_VALID              (WPF_SETMINPOSITION     | \
                                WPF_RESTORETOMAXIMIZED)
/*
 * MEASUREITEMSTRUCT_EX for ownerdraw
 * used when server initiates a WM_MEASUREITEM and adds the additional info
 * of whether the itemData needs to be thunked when the message is sent to
 * the client (see also WM_MEASUREITEM_CLIENTDATA
 */
typedef struct tagMEASUREITEMSTRUCT_EX {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    ULONG_PTR  itemData;
    BOOL       bThunkClientData;
} MEASUREITEMSTRUCT_EX, NEAR *PMEASUREITEMSTRUCT_EX, FAR *LPMEASUREITEMSTRUCT_EX;
#define PM_VALID           (PM_NOREMOVE | \
                            PM_REMOVE   | \
                            PM_NOYIELD  | \
                            PM_QS_INPUT | \
                            PM_QS_POSTMESSAGE | \
                            PM_QS_PAINT | \
                            PM_QS_SENDMESSAGE)
#define MOD_SAS         0x8000

#define MOD_VALID           (MOD_ALT|MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_SAS)
#define EW_RESTARTWINDOWS    0x0042L
#define EW_REBOOTSYSTEM      0x0043L
#define EWX_REALLYLOGOFF     ENDSESSION_LOGOFF

#define EWX_CANCELED                0x00000080
#define EWX_SYSTEM_CALLER           0x00000100
#define EWX_WINLOGON_CALLER         0x00000200
#define EWX_WINLOGON_OLD_SYSTEM     0x00000400
#define EWX_WINLOGON_OLD_SHUTDOWN   0x00000800
#define EWX_WINLOGON_OLD_REBOOT     0x00001000
#define EWX_WINLOGON_API_SHUTDOWN   0x00002000
#define EWX_WINLOGON_OLD_POWEROFF   0x00004000
#define EWX_NOTIFY                  0x00008000
#define EWX_NONOTIFY                0x00010000
#define EWX_VALID                  (0x0000801F)
#define BSM_COMPONENTS          0x0000000F
#define BSM_VALID               0x0000001F
#define BSF_QUEUENOTIFYMESSAGE  0x20000000
#define BSF_SYSTEMSHUTDOWN      0x40000000
#define BSF_MSGSRV32OK          0x80000000
#define BSF_VALID               0x000001FF
#define BSF_ASYNC               (BSF_POSTMESSAGE | BSF_SENDNOTIFYMESSAGE)
//
// BUGBUG--do we still need to support completion port-based notification.
//
#define DEVICE_NOTIFY_COMPLETION_HANDLE 0x00000002

WINUSERAPI
ULONG
WINAPI
DeviceEventWorker(
    IN HWND    hWnd,
    IN WPARAM  wParam,
    IN LPARAM  lParam,
    IN DWORD   dwFlags,
    OUT PDWORD pdwResult
    );
#define LWA_VALID              (LWA_COLORKEY            | \
                                LWA_ALPHA)
#define ULW_VALID              (ULW_COLORKEY            | \
                                ULW_ALPHA               | \
                                ULW_OPAQUE)
#define FLASHW_FLASHNOFG    0x00000008
#define FLASHW_TIMERCALL    0x00000400
#define FLASHW_DONE         0x00000800
#define FLASHW_STARTON      0x00001000
#define FLASHW_COUNTING     0x00002000
#define FLASHW_KILLTIMER    0x00004000
#define FLASHW_ON           0x00008000
#define FLASHW_VALID        (FLASHW_ALL | FLASHW_TIMERNOFG)
#define FLASHW_COUNTMASK    0xFFFF0000
#define FLASHW_CALLERBITS   (FLASHW_VALID | FLASHW_COUNTMASK)
#define SWP_STATECHANGE     0x8000  /* force size, move messages */
#define SWP_NOCLIENTSIZE    0x0800  /* Client didn't resize */
#define SWP_NOCLIENTMOVE    0x1000  /* Client didn't move   */

#define SWP_DEFERDRAWING    0x2000
#define SWP_CREATESPB       0x4000

#define SWP_CHANGEMASK      (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)

#define SWP_NOCHANGE        (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)

#define SWP_VALID1          (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE | SWP_FRAMECHANGED)
#define SWP_VALID2          (SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCOPYBITS | SWP_NOOWNERZORDER | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE | SWP_NOSENDCHANGING | SWP_ASYNCWINDOWPOS | SWP_DEFERDRAWING | SWP_CREATESPB)
#define SWP_VALID           (SWP_VALID1 | SWP_VALID2)
#define SWP_NOTIFYCREATE    0x10000000
#define SWP_NOTIFYDESTROY   0x20000000
#define SWP_NOTIFYACTIVATE  0x40000000
#define SWP_NOTIFYFS        0x80000000
#define SWP_NOTIFYALL       (SWP_NOTIFYCREATE | SWP_NOTIFYDESTROY | SWP_NOTIFYACTIVATE | SWP_NOTIFYFS)

#undef SWP_VALID
#define SWP_VALID           (SWP_DEFERERASE      | \
                             SWP_ASYNCWINDOWPOS  | \
                             SWP_NOCOPYBITS      | \
                             SWP_NOOWNERZORDER   | \
                             SWP_NOSENDCHANGING  | \
                             SWP_NOSIZE          | \
                             SWP_NOMOVE          | \
                             SWP_NOZORDER        | \
                             SWP_NOREDRAW        | \
                             SWP_NOACTIVATE      | \
                             SWP_FRAMECHANGED    | \
                             SWP_SHOWWINDOW      | \
                             SWP_HIDEWINDOW)
#define HWND_GROUPTOTOP HWND_TOPMOST
/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
#include <pshpack2.h>

/*
 * Chicago dialog template
 */
typedef struct {
    WORD wDlgVer;
    WORD wSignature;
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE2;
typedef DLGTEMPLATE2 *LPDLGTEMPLATE2A;
typedef DLGTEMPLATE2 *LPDLGTEMPLATE2W;
#ifdef UNICODE
typedef LPDLGTEMPLATE2W LPDLGTEMPLATE2;
#else
typedef LPDLGTEMPLATE2A LPDLGTEMPLATE2;
#endif // UNICODE
typedef CONST DLGTEMPLATE2 *LPCDLGTEMPLATE2A;
typedef CONST DLGTEMPLATE2 *LPCDLGTEMPLATE2W;
#ifdef UNICODE
typedef LPCDLGTEMPLATE2W LPCDLGTEMPLATE2;
#else
typedef LPCDLGTEMPLATE2A LPCDLGTEMPLATE2;
#endif // UNICODE
/*
 * Dialog item template for NT 1.0a/Chicago (dit2)
 */
typedef struct {
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    short x;
    short y;
    short cx;
    short cy;
    DWORD dwID;
} DLGITEMTEMPLATE2;
typedef DLGITEMTEMPLATE2 *PDLGITEMTEMPLATE2A;
typedef DLGITEMTEMPLATE2 *PDLGITEMTEMPLATE2W;
#ifdef UNICODE
typedef PDLGITEMTEMPLATE2W PDLGITEMTEMPLATE2;
#else
typedef PDLGITEMTEMPLATE2A PDLGITEMTEMPLATE2;
#endif // UNICODE
typedef DLGITEMTEMPLATE2 *LPDLGITEMTEMPLATE2A;
typedef DLGITEMTEMPLATE2 *LPDLGITEMTEMPLATE2W;
#ifdef UNICODE
typedef LPDLGITEMTEMPLATE2W LPDLGITEMTEMPLATE2;
#else
typedef LPDLGITEMTEMPLATE2A LPDLGITEMTEMPLATE2;
#endif // UNICODE

#include <poppack.h> /* Resume normal packing */

/*
 * The driver flags corresponding to these mouse events are
 * shifted to the right by one, e.g.
 *     MOUSEEVENTF_LEFTDOWN >> 1 == MOUSE_LEFT_BUTTON_DOWN
 *
 * The mouse driver sends the fourth and fifth buttons corresponding
 * as button flags, so we define MOUSEEVENTF_ flags INTERNALLY for
 * mimicking the input sent by the driver.
 */

#define MOUSEEVENTF_DRIVER_X1DOWN   0x0080 /* x1 button down */
#define MOUSEEVENTF_DRIVER_X1UP     0x0100 /* x1 button up */
#define MOUSEEVENTF_DRIVER_X2DOWN   0x0200 /* x2 button down */
#define MOUSEEVENTF_DRIVER_X2UP     0x0400 /* x2 button up */
/* Legal MOUSEEVENTF_ flags that indicate a button has been pressed or the wheel moved */
#define MOUSEEVENTF_BUTTONMASK           \
            (MOUSEEVENTF_LEFTDOWN |      \
            MOUSEEVENTF_LEFTUP |         \
            MOUSEEVENTF_RIGHTDOWN |      \
            MOUSEEVENTF_RIGHTUP |        \
            MOUSEEVENTF_MIDDLEDOWN |     \
            MOUSEEVENTF_MIDDLEUP |       \
            MOUSEEVENTF_XDOWN |          \
            MOUSEEVENTF_XUP |            \
            MOUSEEVENTF_WHEEL)

/* MOUSEEVENTF_ flags that indicate useful data in the mouseData field */
#define MOUSEEVENTF_MOUSEDATAMASK         \
            (MOUSEEVENTF_XDOWN |          \
            MOUSEEVENTF_XUP |             \
            MOUSEEVENTF_WHEEL)

#define MWMO_VALID          0x0007
#define QS_SMSREPLY         0x0200
//                          0x0400      // unused (used to be QS_SYSEXPUNGE)
#define QS_THREADATTACHED   0x0800
#define QS_EXCLUSIVE        0x1000      // wait for these events only!!
#define QS_EVENT            0x2000      // signifies event message
#define QS_TRANSFER         0x4000      // Input was transfered from another thread
#define QS_VALID           (QS_KEY           | \
                            QS_MOUSEMOVE     | \
                            QS_MOUSEBUTTON   | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_SENDMESSAGE   | \
                            QS_TRANSFER      | \
                            QS_HOTKEY        | \
                            QS_ALLPOSTMESSAGE)

/*
 * QS_EVENT is used to clear the QS_EVENT bit, QS_EVENTSET is used to
 * set the bit.
 *
 * Include QS_SENDMESSAGE because the queue events
 * match what a win3.1 app would see as the QS_SENDMESSAGE bit. Plus 16 bit
 * apps don't even know about QS_EVENT.
 */
#define QS_EVENTSET        (QS_EVENT | QS_SENDMESSAGE)
/*
 * When you add a system metric, be sure to
 * add it to userexts.c in the function Idsi.
 */
#define SM_UNUSED_64            64
#define SM_UNUSED_65            65
#define SM_UNUSED_66            66
/*
 * add here system metrics that don't take space from the 'aiSysMet' array
 * in the SERVERINFO structure.
 */
/*
 * When you add a system metric, be sure to
 * add it to userexts.c in the function Idsi.
 */
WINUSERAPI
int
WINAPI
DrawMenuBarTemp(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HMENU,
    IN HFONT);
WINUSERAPI BOOL WINAPI SetSystemMenu( IN HWND, IN HMENU);
/*
 * MNS_ values are stored in pMenu->fFlags.
 * Low order bits are used for internal MF* flags defined in user.h
 */
#define MNS_LAST            0x04000000
#define MNS_VALID           0xFC000000
#define MIM_MASK                    0x8000001F
#define MNGOF_GAP            0x00000003
#define MNGOF_CROSSBOUNDARY  0x00000004
#define MIIM_MASK        0x000001FF
#define HBMMENU_MIN                 ((HBITMAP)  0)
#define HBMMENU_MBARFIRST           ((HBITMAP)  2)
#define HBMMENU_UNUSED              ((HBITMAP)  4)
#define HBMMENU_MBARLAST            ((HBITMAP)  7)
#define HBMMENU_POPUPFIRST          ((HBITMAP)  8)
#define HBMMENU_POPUPLAST           ((HBITMAP) 11)
#define HBMMENU_MAX                 ((HBITMAP) 12)
/*
 * Make sure to keep this in synch with the MENUITEMINFO structure. It should
 * be equal to the size of the structure pre NT5.
 */
#define SIZEOFMENUITEMINFO95 FIELD_OFFSET(MENUITEMINFO, hbmpItem)
#define TPM_SYSMENU         0x0200L
#define TPM_FIRSTANIBITPOS  10
#define TPM_ANIMATIONBITS   0x3C00L
#if (WINVER >= 0x0500)
#define TPM_VALID      (TPM_LEFTBUTTON   | \
                        TPM_RIGHTBUTTON  | \
                        TPM_LEFTALIGN    | \
                        TPM_CENTERALIGN  | \
                        TPM_RIGHTALIGN   | \
                        TPM_TOPALIGN     | \
                        TPM_VCENTERALIGN | \
                        TPM_BOTTOMALIGN  | \
                        TPM_HORIZONTAL   | \
                        TPM_VERTICAL     | \
                        TPM_NONOTIFY     | \
                        TPM_RECURSE      | \
                        TPM_RETURNCMD    | \
                        TPM_HORPOSANIMATION | \
                        TPM_HORNEGANIMATION | \
                        TPM_VERPOSANIMATION | \
                        TPM_VERNEGANIMATION | \
                        TPM_NOANIMATION)
#else /* (WINVER >= 0x0500) */
#define TPM_VALID      (TPM_LEFTBUTTON   | \
                        TPM_RIGHTBUTTON  | \
                        TPM_LEFTALIGN    | \
                        TPM_CENTERALIGN  | \
                        TPM_RIGHTALIGN   | \
                        TPM_TOPALIGN     | \
                        TPM_VCENTERALIGN | \
                        TPM_BOTTOMALIGN  | \
                        TPM_HORIZONTAL   | \
                        TPM_VERTICAL     | \
                        TPM_NONOTIFY     | \
                        TPM_RETURNCMD)

#endif /* (WINVER >= 0x0500) */
typedef struct _dropfilestruct {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point
   BOOL fNC;                           // is it on NonClient area
   BOOL fWide;                         // WIDE character switch
} DROPFILESTRUCT, FAR * LPDROPFILESTRUCT;
#define DT_VALID                    0x0007ffff  /* union of all others */
#undef DT_VALID
#define DT_VALID           (DT_CENTER          | \
                            DT_RIGHT           | \
                            DT_VCENTER         | \
                            DT_BOTTOM          | \
                            DT_WORDBREAK       | \
                            DT_SINGLELINE      | \
                            DT_EXPANDTABS      | \
                            DT_TABSTOP         | \
                            DT_NOCLIP          | \
                            DT_EXTERNALLEADING | \
                            DT_CALCRECT        | \
                            DT_NOPREFIX        | \
                            DT_INTERNAL        | \
                            DT_EDITCONTROL     | \
                            DT_PATH_ELLIPSIS   | \
                            DT_END_ELLIPSIS    | \
                            DT_MODIFYSTRING    | \
                            DT_RTLREADING      | \
                            DT_WORD_ELLIPSIS   | \
                            DT_NOFULLWIDTHCHARBREAK |\
                            DT_HIDEPREFIX      | \
                            DT_PREFIXONLY      )

#define DST_TEXTMAX     0x0002
#define DST_GLYPH       0x0005
#define DST_TYPEMASK    0x0007
#define DST_GRAYSTRING  0x0008
#define DSS_DEFAULT     0x0040
#define DSS_INACTIVE    0x0100
WINUSERAPI VOID WINAPI SwitchToThisWindow( IN HWND hwnd, IN BOOL fUnknown);
#define DCX_INVALID          0x00000800L
#define DCX_INUSE            0x00001000L
#define DCX_SAVEDRGNINVALID  0x00002000L
#define DCX_LAYERED          0x00004000L
#define DCX_OWNDC            0x00008000L

#define DCX_USESTYLE         0x00010000L
#define DCX_NEEDFONT         0x00020000L
#define DCX_NODELETERGN      0x00040000L
#define DCX_NOCLIPCHILDREN   0x00080000L

#define DCX_NORECOMPUTE      0x00100000L
#define DCX_DESTROYTHIS      0x00400000L
#define DCX_CREATEDC         0x00800000L

#define DCX_PWNDORGINVISIBLE 0x10000000L
#define DCX_NOMIRROR         0x40000000L // Don't RTL Mirror DC (RTL_MIRRORING)
#define DCX_DONTRIPONDESTROY 0x80000000L


#define DCX_MATCHMASK       (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_LAYERED          | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_NORESETATTRS     | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_CREATEDC)

#define DCX_VALID           (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_NORESETATTRS     | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_PARENTCLIP       | \
                             DCX_EXCLUDERGN       | \
                             DCX_INTERSECTRGN     | \
                             DCX_EXCLUDEUPDATE    | \
                             DCX_INTERSECTUPDATE  | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_INVALID          | \
                             DCX_INUSE            | \
                             DCX_SAVEDRGNINVALID  | \
                             DCX_OWNDC            | \
                             DCX_USESTYLE         | \
                             DCX_NEEDFONT         | \
                             DCX_NODELETERGN      | \
                             DCX_NOCLIPCHILDREN   | \
                             DCX_NORECOMPUTE      | \
                             DCX_VALIDATE         | \
                             DCX_DESTROYTHIS      | \
                             DCX_CREATEDC)

WINUSERAPI
BOOL
WINAPI
AlignRects(
    IN OUT LPRECT arc,
    IN DWORD cCount,
    IN DWORD iPrimary,
    IN DWORD dwFlags);

//
// AlignRects flags
//

#define CUDR_NORMAL             0x0000
#define CUDR_NOSNAPTOGRID       0x0001
#define CUDR_NORESOLVEPOSITIONS 0x0002
#define CUDR_NOCLOSEGAPS        0x0004
#define CUDR_NOPRIMARY          0x0010
#define RDW_REDRAWWINDOW        0x1000  /* Called from RedrawWindow()*/
#define RDW_SUBTRACTSELF        0x2000  /* Subtract self from hrgn   */

#define RDW_COPYRGN             0x4000  /* Copy the passed-in region */
#define RDW_IGNOREUPDATEDIRTY   0x8000  /* Ignore WFUPDATEDIRTY      */
#define RDW_INVALIDATELAYERS    0x00010000 /* Allow layered windows invalidation */

#define RDW_VALIDMASK          (RDW_INVALIDATE      | \
                                RDW_INTERNALPAINT   | \
                                RDW_ERASE           | \
                                RDW_VALIDATE        | \
                                RDW_NOINTERNALPAINT | \
                                RDW_NOERASE         | \
                                RDW_NOCHILDREN      | \
                                RDW_ALLCHILDREN     | \
                                RDW_UPDATENOW       | \
                                RDW_ERASENOW        | \
                                RDW_FRAME           | \
                                RDW_NOFRAME)
#define SW_EXACTTIME        0x0020
#define SW_SCROLLWINDOW     0x8000  /* Called from ScrollWindow() */

#define SW_VALIDFLAGS      (SW_SCROLLWINDOW     | \
                            SW_SCROLLCHILDREN   | \
                            SW_INVALIDATE       | \
                            SW_SMOOTHSCROLL     | \
                            SW_EXACTTIME        | \
                            SW_ERASE)
#define ESB_MAX             0x0003
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH

/*
 * Help Engine stuff
 *
 * Note: for Chicago this is in winhelp.h and called WINHLP
 */
typedef struct {
    WORD cbData;              /* Size of data                     */
    WORD usCommand;           /* Command to execute               */
    ULONG_PTR ulTopic;        /* Topic/context number (if needed) */
    DWORD ulReserved;         /* Reserved (internal use)          */
    WORD offszHelpFile;       /* Offset to help file in block     */
    WORD offabData;           /* Offset to other data in block    */
} HLP, *LPHLP;

#if(WINVER >= 0x0500)
#define MB_LASTVALIDTYPE MB_CANCELTRYCONTINUE
#else
#define MB_LASTVALIDTYPE MB_RETRYCANCEL
#endif
#define MBEX_VALIDL                 0xf3f7
#define MBEX_VALIDH                 1
#define MB_VALID                   (MB_OK                   | \
                                    MB_OKCANCEL             | \
                                    MB_ABORTRETRYIGNORE     | \
                                    MB_YESNOCANCEL          | \
                                    MB_YESNO                | \
                                    MB_RETRYCANCEL          | \
                                    MB_ICONHAND             | \
                                    MB_ICONQUESTION         | \
                                    MB_ICONEXCLAMATION      | \
                                    MB_ICONASTERISK         | \
                                    MB_DEFBUTTON1           | \
                                    MB_DEFBUTTON2           | \
                                    MB_DEFBUTTON3           | \
                                    MB_DEFBUTTON4           | \
                                    MB_APPLMODAL            | \
                                    MB_SYSTEMMODAL          | \
                                    MB_TASKMODAL            | \
                                    MB_HELP                 | \
                                    MB_TOPMOST              | \
                                    MB_RIGHT                | \
                                    MB_RTLREADING           | \
                                    MB_NOFOCUS              | \
                                    MB_SETFOREGROUND        | \
                                    MB_DEFAULT_DESKTOP_ONLY | \
                                    MB_SERVICE_NOTIFICATION | \
                                    MB_TYPEMASK             | \
                                    MB_USERICON             | \
                                    MB_ICONMASK             | \
                                    MB_DEFMASK              | \
                                    MB_MODEMASK             | \
                                    MB_MISCMASK)
#define CWP_VALID           (CWP_SKIPINVISIBLE | CWP_SKIPDISABLED | CWP_SKIPTRANSPARENT)
#define COLOR_3DALTFACE         25
#if(WINVER >= 0x0500)
#define COLOR_ENDCOLORS         COLOR_GRADIENTINACTIVECAPTION
#else
#define COLOR_ENDCOLORS         COLOR_INFOBK
#endif
#define COLOR_MAX               (COLOR_ENDCOLORS+1)
WINUSERAPI
HANDLE
WINAPI
SetSysColorsTemp(
    IN CONST COLORREF *,
    IN CONST HBRUSH *,
    IN UINT_PTR wCnt);
/*
 * RTL Mirroring APIs (RTL_MIRRORING)
 */

WINUSERAPI
BOOL
WINAPI
SetDeskWallpaper(
    IN LPCSTR lpString);

WINUSERAPI
HWND
WINAPI
CreateDialogIndirectParamAorW(
    IN HANDLE hmod,
    IN LPCDLGTEMPLATE lpDlgTemplate,
    IN HWND hwndOwner,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam,
    IN UINT fAnsi);

WINUSERAPI
INT_PTR
WINAPI
DialogBoxIndirectParamAorW(
    IN HINSTANCE hmod,
    IN LPCDLGTEMPLATEW lpDlgTemplate,
    IN HWND hwndOwner,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam,
    IN UINT fAnsiFlags);

WINUSERAPI
void
WINAPI
LoadLocalFonts(void);

WINUSERAPI
UINT
WINAPI
UserRealizePalette(IN HDC hdc);

WINUSERAPI HWND    WINAPI  GetShellWindow(void);
WINUSERAPI BOOL    WINAPI  SetShellWindow( IN HWND);
WINUSERAPI BOOL    WINAPI  SetShellWindowEx( IN HWND, IN HWND);
WINUSERAPI HWND    WINAPI  GetProgmanWindow(void);
WINUSERAPI BOOL    WINAPI  SetProgmanWindow( IN HWND);
WINUSERAPI HWND    WINAPI  GetTaskmanWindow(void);
WINUSERAPI BOOL    WINAPI  SetTaskmanWindow( IN HWND);
WINUSERAPI BOOL    WINAPI  RegisterShellHookWindow( IN HWND);
WINUSERAPI BOOL    WINAPI  DeregisterShellHookWindow( IN HWND);

WINUSERAPI HWND WINAPI GetNextQueueWindow ( IN HWND hWnd, IN INT nCmd);
#define MF_CHANGE_VALID   (MF_INSERT          | \
                           MF_CHANGE          | \
                           MF_APPEND          | \
                           MF_DELETE          | \
                           MF_REMOVE          | \
                           MF_BYCOMMAND       | \
                           MF_BYPOSITION      | \
                           MF_SEPARATOR       | \
                           MF_ENABLED         | \
                           MF_GRAYED          | \
                           MF_DISABLED        | \
                           MF_UNCHECKED       | \
                           MF_CHECKED         | \
                           MF_USECHECKBITMAPS | \
                           MF_STRING          | \
                           MF_BITMAP          | \
                           MF_OWNERDRAW       | \
                           MF_POPUP           | \
                           MF_MENUBARBREAK    | \
                           MF_MENUBREAK       | \
                           MF_UNHILITE        | \
                           MF_HILITE          | \
                           MF_SYSMENU)

#define MF_VALID          (MF_CHANGE_VALID    | \
                           MF_HELP            | \
                           MF_MOUSESELECT)

#define MFT_MASK            0x00036B64L
#define MFS_HOTTRACK        MF_APPEND
#define MFS_MASK            0x0000108BL
#define MFS_HOTTRACKDRAWN   0x10000000L
#define MFS_CACHEDBMP       0x20000000L
#define MFS_BOTTOMGAPDROP   0x40000000L
#define MFS_TOPGAPDROP      0x80000000L
#define MFS_GAPDROP         0xC0000000L

#define MFR_POPUP           0x01
#define MFR_END             0x80

#define MFT_OLDAPI_MASK     0x00006B64L
#define MFS_OLDAPI_MASK     0x0000008BL
#define MFT_NONSTRING       0x00000904L
#define MFT_BREAK           0x00000060L
typedef struct {        // version 1
    DWORD dwHelpID;
    DWORD fType;
    DWORD fState;
    DWORD menuId;
    WORD  wResInfo;
    WCHAR mtString[1];
} MENUITEMTEMPLATE2, *PMENUITEMTEMPLATE2;
#define IDC_NWPEN           MAKEINTRESOURCE(32531)
#define IDC_HUNG            MAKEINTRESOURCE(32632)
WINUSERAPI UINT PrivateExtractIconExA(
    IN LPCSTR szFileName,
    IN int      nIconIndex,
    OUT HICON   *phiconLarge,
    OUT HICON   *phiconSmall,
    IN UINT     nIcons);
WINUSERAPI UINT PrivateExtractIconExW(
    IN LPCWSTR szFileName,
    IN int      nIconIndex,
    OUT HICON   *phiconLarge,
    OUT HICON   *phiconSmall,
    IN UINT     nIcons);
#ifdef UNICODE
#define PrivateExtractIconEx  PrivateExtractIconExW
#else
#define PrivateExtractIconEx  PrivateExtractIconExA
#endif // !UNICODE


WINUSERAPI UINT PrivateExtractIconsA(
    IN LPCSTR szFileName,
    IN int      nIconIndex,
    IN int      cxIcon,
    IN int      cyIcon,
    OUT HICON   *phicon,
    OUT UINT    *piconid,
    IN UINT     nIcons,
    IN UINT     flags);
WINUSERAPI UINT PrivateExtractIconsW(
    IN LPCWSTR szFileName,
    IN int      nIconIndex,
    IN int      cxIcon,
    IN int      cyIcon,
    OUT HICON   *phicon,
    OUT UINT    *piconid,
    IN UINT     nIcons,
    IN UINT     flags);
#ifdef UNICODE
#define PrivateExtractIcons  PrivateExtractIconsW
#else
#define PrivateExtractIcons  PrivateExtractIconsA
#endif // !UNICODE
#define LR_GLOBAL           0x0100
#define LR_ENVSUBST         0x0200
#define LR_ACONFRAME        0x0400
#define LR_CREATEREALDIB    0x0800
#define LR_VALID            0xF8FF
#define DI_VALID       (DI_MASK | DI_IMAGE | DI_COMPAT | DI_DEFAULTSIZE)
#define OBM_STARTUP         32733
#define OBM_TRUETYPE        32732
#define OBM_HELP            32731
#define OBM_HELPD           32730
#define OBM_RDRVERT         32559
#define OBM_RDRHORZ         32660
#define OBM_RDR2DIM         32661
#define OCR_NWPEN           32631
#define OCR_HELP            32651


#define OCR_RDRVERT         32652
#define OCR_RDRHORZ         32653
#define OCR_RDR2DIM         32654
#define OCR_RDRNORTH        32655
#define OCR_RDRSOUTH        32656
#define OCR_RDRWEST         32657
#define OCR_RDREAST         32658
#define OCR_RDRNORTHWEST    32659
#define OCR_RDRNORTHEAST    32660
#define OCR_RDRSOUTHWEST    32661
#define OCR_RDRSOUTHEAST    32662

/*
 * Default Cursor IDs to get original image from User
 */
#define OCR_FIRST_DEFAULT           100
#define OCR_ARROW_DEFAULT           100
#define OCR_IBEAM_DEFAULT           101
#define OCR_WAIT_DEFAULT            102
#define OCR_CROSS_DEFAULT           103
#define OCR_UPARROW_DEFAULT         104
#define OCR_SIZENWSE_DEFAULT        105
#define OCR_SIZENESW_DEFAULT        106
#define OCR_SIZEWE_DEFAULT          107
#define OCR_SIZENS_DEFAULT          108
#define OCR_SIZEALL_DEFAULT         109
#define OCR_NO_DEFAULT              110
#define OCR_APPSTARTING_DEFAULT     111
#define OCR_HELP_DEFAULT            112
#define OCR_NWPEN_DEFAULT           113
#define OCR_HAND_DEFAULT            114
#define OCR_ICON_DEFAULT            115
#define COCR_CONFIGURABLE           (OCR_ICON_DEFAULT - OCR_FIRST_DEFAULT + 1)
/* Default IDs for original User images */
#define OIC_FIRST_DEFAULT           100
#define OIC_APPLICATION_DEFAULT     100
#define OIC_HAND_DEFAULT            101
#define OIC_WARNING_DEFAULT         101
#define OIC_QUESTION_DEFAULT        102
#define OIC_EXCLAMATION_DEFAULT     103
#define OIC_ERROR_DEFAULT           103
#define OIC_ASTERISK_DEFAULT        104
#define OIC_INFORMATION_DEFAULT     104
#define OIC_WINLOGO_DEFAULT         105
#define COIC_CONFIGURABLE           (OIC_WINLOGO_DEFAULT - OIC_FIRST_DEFAULT + 1)
#define IDUSERICON      20
#define ES_FMTMASK          0x0003L
#define ES_COMBOBOX         0x0200L
#define EM_SETFONT              0x00C3 /* no longer suported */
#define EM_SETWORDBREAK         0x00CA /* no longer suported */
#define EM_MSGMAX               0x00DA
#define BS_PUSHBOX          0x0000000AL
#define BS_TYPEMASK         0x0000000FL
#define BS_IMAGEMASK        0x000000C0L
#define BS_HORZMASK         0x00000300L
#define BS_VERTMASK         0x00000C00L
#define BS_ALIGNMASK        0x00000F00L
#define SS_TEXTMAX0         0x00000002L
#define SS_TEXTMIN1         0x0000000BL
#define SS_TEXTMAX1         0x0000000DL
#define SS_EDITCONTROL      0x00002000L
#define ISSSTEXTOROD(bType) (((bType) <= SS_TEXTMAX0) \
                                || (((bType) >= SS_TEXTMIN1) && ((bType) <= SS_TEXTMAX1)))
#define DDL_NOFILES         0x1000
#define DDL_VALID          (DDL_READWRITE  | \
                            DDL_READONLY   | \
                            DDL_HIDDEN     | \
                            DDL_SYSTEM     | \
                            DDL_DIRECTORY  | \
                            DDL_ARCHIVE    | \
                            DDL_POSTMSGS   | \
                            DDL_DRIVES     | \
                            DDL_EXCLUSIVE)
/*
 * Valid dialog style bits for Chicago compatibility.
 */
//#define DS_VALID_FLAGS (DS_ABSALIGN|DS_SYSMODAL|DS_LOCALEDIT|DS_SETFONT|DS_MODALFRAME|DS_NOIDLEMSG | DS_SETFOREGROUND)
#define DS_VALID_FLAGS   0x1FFF

#define SCDLG_CLIENT            0x0001
#define SCDLG_ANSI              0x0002
#define SCDLG_NOREVALIDATE      0x0004
#define SCDLG_16BIT             0x0008      // Created for a 16 bit thread; common dialogs

#define DS_VALID31          0x01e3L
#define DS_VALID40          0x7FFFL
#define DS_RECURSE      DS_CONTROL  /* BOGUS GOING AWAY */
#define DS_COMMONDIALOG     0x4000L

#define DS_NONBOLD  DS_3DLOOK   /* BOGUS GOING AWAY */
#define LBCB_CARETON            0x01A3
#define LBCB_CARETOFF           0x01A4
#define LB_INSERTSTRINGUPPER    0x01AA
#define LB_INSERTSTRINGLOWER    0x01AB
#define LB_ADDSTRINGUPPER       0x01AC
#define LB_ADDSTRINGLOWER       0x01AD
#define LBCB_STARTTRACK         0x01AE
#define LBCB_ENDTRACK           0x01AF
#define CBEC_SETCOMBOFOCUS          (CB_MSGMAX+1)
#define CBEC_KILLCOMBOFOCUS         (CB_MSGMAX+2)
#define SIF_RETURNOLDPOS    0x1000
#define SIF_NOSCROLL        0x2000
#define SIF_MASK            0x701F
#define HELP_HB_NORMAL    0x0000L
#define HELP_HB_STRING    0x0100L
#define HELP_HB_STRUCT    0x0200L
#define GR_MAXOBJECT      1
#if(_WIN32_WINNT >= 0x0500)
/*
 * Query win32k statistics -internal
 * QUERYUSER_CS         Query critical section usage
 * QUERYUSER_HANDLES    Query user per-process user handle count
 */

#define QUC_PID_TOTAL           0xffffffff
#define QUERYUSER_HANDLES       0x1
#if defined (USER_PERFORMANCE)
#define QUERYUSER_CS            0x2

/*
 *  The counters in CSSTATISTICS refer to the USER critical section:
 *      cExclusive counts how many times the CS was aquired exclusive
 *      cShared counts how many times the CS was aquired shared
 *      i64TimeExclusive counts the time (NtQueryPerformanceCounter() units)
 *      spent in the resource since the last query.
 */
typedef struct _tagCSStatistics {
        DWORD   cExclusive;
        DWORD   cShared;
        __int64 i64TimeExclusive;
} CSSTATISTICS;
#endif // USER_PERFORMANCE

BOOL
WINAPI
QueryUserCounters(
    IN  DWORD   dwQueryType,
    IN  LPVOID  pvIn,
    IN  DWORD   dwInSize,
    OUT LPVOID  pvResult,
    IN  DWORD   dwOutSize
);
#endif /* _WIN32_WINNT >= 0x0500 */
#define SPI_TIMEOUTS                7
#define SPI_KANJIMENU               8
#define SPI_UNUSED39               39
#define SPI_UNUSED40               40
#define SPI_UNUSED108             108
#define SPI_UNUSED109             109
#define SPI_MAX                   116

/*
 * ADDING NEW SPI_* VALUES
 * If the value is a BOOL, it should be added after SPI_STARTBOOLRANGE
 * If the value is a DWORD, it should be added after SPI_STARTDWORDRANGE
 * If the value is a structure or a string, go ahead and setup SPI_START*RANGE....
 */

/*
 * If adding a new SPI value in the following ranges:
 * -You must define both SPI_GET* and SPI_SET* using consecutive numbers
 * -The low order bit of SPI_GET* must be 0
 * -The low order bit of SPI_SET* must be 1
 * -Properly update SPI_MAX*RANGE
 * -Add the default value to kernel\globals.c in the proper *CPUserPreferences* variable
 * -Add the default value to the proper registry hives.
 * -If your value requires some special validation, do so in kernel\ntstubs.c
 * -If you find something wrong in this documentation, FIX IT!.
 */
#define SPIF_SET                  0x0001
#define SPIF_BOOL                 0x1000
#define SPIF_DWORD                0x2000
#define SPIF_RANGETYPEMASK        0x3000
/*
 * BOOLeans range.
 * For GET, pvParam is a pointer to a BOOL
 * For SET, pvParam is the value
 */
#define SPI_STARTBOOLRANGE                  0x1000
#define SPI_UNUSED1010                      0x1010
#define SPI_UNUSED1011                      0x1011
/*
 * All SPI_s for UI effects must be < SPI_GETUIEFFECTS
 */
#define SPI_MAXBOOLRANGE                    0x1040
#define SPI_BOOLRANGECOUNT ((SPI_MAXBOOLRANGE - SPI_STARTBOOLRANGE) / 2)
#define SPI_BOOLMASKDWORDSIZE (((SPI_BOOLRANGECOUNT - 1) / 32) + 1)

/*
 * DWORDs range.
 * For GET, pvParam is a pointer to a DWORD
 * For SET, pvParam is the value
 */
#define SPI_STARTDWORDRANGE                 0x2000
#define SPI_MAXDWORDRANGE                   0x2008
#define SPI_DWORDRANGECOUNT ((SPI_MAXDWORDRANGE - SPI_STARTDWORDRANGE) / 2)
#define SPIF_VALID            (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE)
#define ARW_VALID                   0x000FL
#define MAX_SCHEME_NAME_SIZE 128
#define CDS_RAWMODE         0x00000040
#define CDS_TRYCLOSEST      0x00000080
#define CDS_EXCLUSIVE       0x80000000
#define CDS_VALID           0xD00000FF
#define EDS_SHOW_DUPLICATES           0x00000001
#define EDS_SHOW_MONITOR_NOT_CAPABLE  0x00000002
void LoadRemoteFonts(void);
#define FKF_VALID           0x0000007F
#define SKF_VALID           0x000001FF
#define SKF_STATEINFO         0xffff0000
#define MKF_VALID           0x000000FF
#define MKF_STATEINFO       0xB3000000
#define ATF_VALID           0x00000003
#define SSF_VALID           0x00000007
#define TKF_VALID           0x0000003F

WINUSERAPI VOID WINAPI RegisterNetworkCapabilities( IN DWORD dwBitsToSet, IN DWORD dwValues);
#define RNC_NETWORKS              0x00000001
#define RNC_LOGON                 0x00000002

#if !defined(WINNT)     // Win95 version of EndTask
WINUSERAPI DWORD WINAPI EndTask( IN HWND hwnd, IN DWORD idProcess, IN LPSTR lpszCaption, IN DWORD dwFlags);
#define ET_ALLOWFORWAIT     0x00000001
#define ET_TRYTOKILLNICELY  0x00000002
#define ET_NOUI             0x00000004
#define ET_NOWAIT           0x00000008
#define ET_VALID           (ET_ALLOWFORWAIT | ET_TRYTOKILLNICELY | ET_NOUI | ET_NOWAIT)
#endif

#define LOGON_LOGOFF          0
#define LOGON_INPUT_TIMEOUT   1
#define LOGON_RESTARTSHELL    2


#if (_WIN32_WINNT >= 0x0500)
#define LOGON_ACCESSNOTIFY    3
#define LOGON_POWERSTATE      4
#define LOGON_LOCKWORKSTATION 5

#define SESSION_RECONNECTED   6
#define SESSION_DISCONNECTED  7
#define SESSION_LOGOFF        8
#define LOGON_PLAYEVENTSOUND  9
#define LOGON_PLAYPOWERSOUND  10
#define LOGON_LOGOFFCANCELED  11

#define    ACCESS_STICKYKEYS            0x0001
#define    ACCESS_FILTERKEYS            0x0002
#define    ACCESS_MOUSEKEYS             0x0003
#define    ACCESS_TOGGLEKEYS            0x0004
#define    ACCESS_HIGHCONTRAST          0x0005  // notification dlg
#define    ACCESS_UTILITYMANAGER        0x0006
#define    ACCESS_HIGHCONTRASTON        0x0008
#define    ACCESS_HIGHCONTRASTOFF       0x0009
#define    ACCESS_HIGHCONTRASTCHANGE    0x000A
#define    ACCESS_HIGHCONTRASTONNOREG   0x000C
#define    ACCESS_HIGHCONTRASTOFFNOREG  0x000D
#define    ACCESS_HIGHCONTRASTCHANGENOREG 0x000E
#define    ACCESS_HIGHCONTRASTNOREG  0x0004


#define USER_SOUND_DEFAULT                0      // default MB sound
#define USER_SOUND_SYSTEMHAND             1      // MB_ICONHAND shifted
#define USER_SOUND_SYSTEMQUESTION         2      // MB_ICONQUESTION shifted
#define USER_SOUND_SYSTEMEXCLAMATION      3      // MB_ICONEXCLAMATION shifted
#define USER_SOUND_SYSTEMASTERISK         4      // MB_ICONASTERISK shifted
#define USER_SOUND_MENUPOPUP              5
#define USER_SOUND_MENUCOMMAND            6
#define USER_SOUND_OPEN                   7
#define USER_SOUND_CLOSE                  8
#define USER_SOUND_RESTOREUP              9
#define USER_SOUND_RESTOREDOWN            10
#define USER_SOUND_MINIMIZE               11
#define USER_SOUND_MAXIMIZE               12
#define USER_SOUND_SNAPSHOT               13
#define USER_SOUND_MAX                    14


#ifdef _NTPOAPI_
typedef struct tagPOWERSTATEPARAMS {
    POWER_ACTION        SystemAction;
    SYSTEM_POWER_STATE  MinSystemState;
    ULONG               Flags;
    BOOL                FullScreenMode;
} POWERSTATEPARAMS, *PPOWERSTATEPARAMS;
#endif

#endif

#define LOGON_FLG_MASK      0xF0000000
#define LOGON_FLG_SHIFT     28

#define STARTF_DESKTOPINHERIT   0x40000000
#define STARTF_SCREENSAVER      0x80000000

#define WSS_ERROR       0
#define WSS_BUSY        1
#define WSS_IDLE        2

#define DTF_CENTER    0x00   /* Center the bitmap (default)                  */
#define DTF_TILE      0x01   /* Tile the bitmap                              */
#define DTF_STRETCH   0x02   /* Stretch bitmap to cover screen.              */
#if 0 /* the following have not been used anywhere in NT since at least 1992 */
#define DTF_NOPALETTE 0x04   /* Realize palette, otherwise match to default. */
#define DTF_RETAIN    0x08   /* Retain bitmap, ignore win.ini changes        */
#define DTF_FIT       0x10   /* Fit the bitmap to the screen (scaled).       */
#endif

#ifdef _INC_DDEMLH
BOOL DdeIsDataHandleReadOnly(
    IN HDDEDATA hData);

int DdeGetDataHandleFormat(
    IN HDDEDATA hData);

DWORD DdeGetCallbackInstance(VOID);
#endif /* defined _INC_DDEMLH */

#define LPK_TABBED_TEXT_OUT 0
#define LPK_PSM_TEXT_OUT    1
#define LPK_DRAW_TEXT_EX    2
#define LPK_EDIT_CONTROL    3

VOID
WINAPI
InitializeLpkHooks(
    IN CONST FARPROC *lpfpLpkHooks
);

WINUSERAPI
HWND
WINAPI
WOWFindWindow(
    IN LPCSTR lpClassName,
    IN LPCSTR lpWindowName);

int
WINAPI
InternalDoEndTaskDlg(
    IN TCHAR* pszTitle);

DWORD
WINAPI
InternalWaitCancel(
    IN HANDLE handle,
    IN DWORD dwMilliseconds);

HANDLE
WINAPI
InternalCreateCallbackThread(
    IN HANDLE hProcess,
    IN ULONG_PTR lpfn,
    IN ULONG_PTR dwData);

WINUSERAPI
UINT
WINAPI
GetInternalWindowPos(
    IN HWND hWnd,
    OUT LPRECT lpRect,
    IN LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
SetInternalWindowPos(
    IN HWND hWnd,
    IN UINT cmdShow,
    IN LPRECT lpRect,
    IN LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
CalcChildScroll(
    IN HWND hWnd,
    IN UINT sb);

WINUSERAPI
BOOL
WINAPI
RegisterTasklist(
    IN HWND hWndTasklist);

WINUSERAPI
BOOL
WINAPI
CascadeChildWindows(
    IN HWND hWndParent,
    IN UINT flags);

WINUSERAPI
BOOL
WINAPI
TileChildWindows(
    IN HWND hWndParent,
    IN UINT flags);

WINUSERAPI
int
WINAPI
InternalGetWindowText(
    IN HWND hWnd,
    OUT LPWSTR lpString,
    IN int nMaxCount);


/*
 * Services support routines
 */
WINUSERAPI
BOOL
WINAPI
RegisterServicesProcess(
    IN DWORD dwProcessId);

/*
 * Logon support routines
 */
WINUSERAPI
BOOL
WINAPI
RegisterLogonProcess(
    IN DWORD dwProcessId,
    IN BOOL fSecure);

WINUSERAPI
UINT
WINAPI
LockWindowStation(
    IN HWINSTA hWindowStation);

WINUSERAPI
BOOL
WINAPI
UnlockWindowStation(
    IN HWINSTA hWindowStation);

WINUSERAPI
BOOL
WINAPI
SetWindowStationUser(
    IN HWINSTA hWindowStation,
    IN PLUID pLuidUser,
    IN PSID pSidUser,
    IN DWORD cbSidUser);

WINUSERAPI
BOOL
WINAPI
SetDesktopBitmap(
    IN HDESK hdesk,
    IN HBITMAP hbmWallpaper,
    IN DWORD dwStyle);

WINUSERAPI
BOOL
WINAPI
SetLogonNotifyWindow(
    IN HWND    hWndNotify);

WINUSERAPI
UINT
WINAPI
GetIconId(
    IN HANDLE hRes,
    IN LPSTR lpszType);

WINUSERAPI
int
WINAPI
CriticalNullCall(
    VOID);

WINUSERAPI
int
WINAPI
NullCall(
    VOID);

WINUSERAPI
VOID
WINAPI
UserNotifyConsoleApplication(
    IN DWORD dwProcessId);

WINUSERAPI
HBRUSH
WINAPI
GetConsoleWindowBrush(
    IN PVOID pWnd);

/*
 * Reserved console space.
 *
 * This was moved from the console code so that we can localize it
 * in one place.  This was necessary for dealing with the background
 * color, which we need to have for the hungapp drawing.  These are
 * stored in the extra-window-bytes of each console.
 */
#define GWL_CONSOLE_WNDALLOC  (3 * sizeof(DWORD))
#define GWL_CONSOLE_PID       0
#define GWL_CONSOLE_TID       4
#define GWL_CONSOLE_BKCOLOR   8


VOID vFontSweep();
VOID vLoadLocalT1Fonts();
VOID vLoadRemoteT1Fonts();


#ifndef NOMSG

#define TM_INMENUMODE     0x0001
#define TM_POSTCHARBREAKS 0x0002

WINUSERAPI
BOOL
WINAPI
TranslateMessageEx(
    IN CONST MSG *lpMsg,
    IN UINT flags);

#endif /* !NOMSG */

/*
 * Those values can be specified as nAnsiChar for MBToWCSEx
 * USER_AWCONV_COUNTSTRING:      Count the length of the string including trailing \0
 * USER_AWCONV_COUNTSTRINGSZ:    Count the length of the string excluding trailing \0
 *
 * Note: The result includes trailing \0 if USER_AWCONV_COUNTSTRING is specified.
 *  USER_AWCONV_COUNTSTRINGSZ will not null-terminate the restult string. It may return
 * 0 if the source strlen() == 0.
 */
#define USER_AWCONV_COUNTSTRING          (-1)
#define USER_AWCONV_COUNTSTRINGSZ        (-2)


WINUSERAPI
int
WINAPI
WCSToMBEx(
    IN WORD wCodePage,
    IN LPCWSTR pUnicodeString,
    IN int cbUnicodeChar,
    OUT LPSTR *ppAnsiString,
    IN int nAnsiChar,
    IN BOOL bAllocateMem);

WINUSERAPI
int
WINAPI
MBToWCSEx(
    IN WORD wCodePage,
    IN LPCSTR pAnsiString,
    IN int nAnsiChar,
    OUT LPWSTR *ppUnicodeString,
    IN int cbUnicodeChar,
    IN BOOL bAllocateMem);

#if defined(WINNT)      // NT version of EndTask
WINUSERAPI
BOOL
WINAPI
EndTask(
    IN HWND hWnd,
    IN BOOL fShutDown,
    IN BOOL fForce);
#endif

WINUSERAPI
BOOL
WINAPI
UpdatePerUserSystemParameters(
    IN HANDLE hToken,
    IN BOOL   bUserLoggedOn);

typedef VOID  (APIENTRY *PFNW32ET)(VOID);

WINUSERAPI
BOOL
WINAPI
RegisterUserHungAppHandlers(
    IN PFNW32ET pfnW32EndTask,
    IN HANDLE   hEventWowExec);

WINUSERAPI
ATOM
WINAPI
RegisterClassWOWA(
    IN PVOID   lpWndClass,
    IN LPDWORD pdwWOWstuff);

WINUSERAPI
LONG
WINAPI
GetClassWOWWords(
    IN HINSTANCE hInstance,
    OUT LPCTSTR pString);

WINUSERAPI
DWORD
WINAPI
CurrentTaskLock(
    IN DWORD hlck);

WINUSERAPI
HDESK
WINAPI
GetInputDesktop(
    VOID);

#define WINDOWED       0
#define FULLSCREEN     1
#define GDIFULLSCREEN  2
#define FULLSCREENMIN  4


#define WCSToMB(pUnicodeString, cbUnicodeChar, ppAnsiString, nAnsiChar,\
bAllocateMem)\
WCSToMBEx(0, pUnicodeString, cbUnicodeChar, ppAnsiString, nAnsiChar, bAllocateMem)

#define MBToWCS(pAnsiString, nAnsiChar, ppUnicodeString, cbUnicodeChar,\
bAllocateMem)\
MBToWCSEx(0, pAnsiString, nAnsiChar, ppUnicodeString, cbUnicodeChar, bAllocateMem)

#define ID(string) (((ULONG_PTR)string & ~0x0000ffff) == 0)

/*
 * For setting RIT timers and such.  GDI uses this for the cursor-restore
 * timer.
 */
#define TMRF_READY      0x0001
#define TMRF_SYSTEM     0x0002
#define TMRF_RIT        0x0004
#define TMRF_INIT       0x0008
#define TMRF_ONESHOT    0x0010
#define TMRF_WAITING    0x0020
#define TMRF_PTIWINDOW  0x0040


/*
 * For GDI SetAbortProc support.
 */

WINUSERAPI
int
WINAPI
CsDrawTextA(
    IN HDC hDC,
    IN LPCSTR lpString,
    IN int nCount,
    IN LPRECT lpRect,
    IN UINT uFormat);
WINUSERAPI
int
WINAPI
CsDrawTextW(
    IN HDC hDC,
    IN LPCWSTR lpString,
    IN int nCount,
    IN LPRECT lpRect,
    IN UINT uFormat);
#ifdef UNICODE
#define CsDrawText  CsDrawTextW
#else
#define CsDrawText  CsDrawTextA
#endif // !UNICODE

WINUSERAPI
LONG
WINAPI
CsTabbedTextOutA(
    IN HDC hDC,
    IN int X,
    IN int Y,
    IN LPCSTR lpString,
    IN int nCount,
    IN int nTabPositions,
    IN LPINT lpnTabStopPositions,
    IN int nTabOrigin);
WINUSERAPI
LONG
WINAPI
CsTabbedTextOutW(
    IN HDC hDC,
    IN int X,
    IN int Y,
    IN LPCWSTR lpString,
    IN int nCount,
    IN int nTabPositions,
    IN LPINT lpnTabStopPositions,
    IN int nTabOrigin);
#ifdef UNICODE
#define CsTabbedTextOut  CsTabbedTextOutW
#else
#define CsTabbedTextOut  CsTabbedTextOutA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
CsFrameRect(
    IN HDC hDC,
    IN CONST RECT *lprc,
    IN HBRUSH hbr);

#ifdef UNICODE
#define CsDrawText      CsDrawTextW
#define CsTabbedTextOut CsTabbedTextOutW
#else /* !UNICODE */
#define CsDrawText      CsDrawTextA
#define CsTabbedTextOut CsTabbedTextOutA
#endif /* !UNICODE */

/*
 * Custom Cursor action.
 */
WINUSERAPI
HCURSOR
WINAPI
GetCursorFrameInfo( // Obsolete? - IanJa
    IN HCURSOR hcur,
    OUT LPWSTR id,
    IN int iFrame,
    OUT LPDWORD pjifRate,
    OUT LPINT pccur);


/*
 * WOW: replace cursor/icon handle
 */

WINUSERAPI
BOOL
WINAPI
SetCursorContents( IN HCURSOR hCursor, IN HCURSOR hCursorNew);


#ifdef WX86

/*
 *  Wx86
 *  export from wx86.dll to convert an x86 hook proc to risc address.
 */
typedef
PVOID
(*PFNWX86HOOKCALLBACK)(
    SHORT HookType,
    PVOID HookProc
    );

typedef
HMODULE
(*PFNWX86LOADX86DLL)(
    LPCWSTR lpLibFileName,
    DWORD   dwFlags
    );


typedef
BOOL
(*PFNWX86FREEX86DLL)(
    HMODULE hMod
    );

#endif







typedef struct _TAG {
    DWORD type;
    DWORD style;
    DWORD len;
} TAG, *PTAG;

#define MAKETAG(a, b, c, d) (DWORD)(a | (b<<8) | ((DWORD)c<<16) | ((DWORD)d<<24))


/* Valid TAG types. */

/* 'ASDF' (CONT) - Advanced Systems Data Format */

#define TAGT_ASDF MAKETAG('A', 'S', 'D', 'F')


/* 'RAD ' (CONT) - ?R Animation ?Definition (an aggregate type) */

#define TAGT_RAD  MAKETAG('R', 'A', 'D', ' ')


/* 'ANIH' (DATA) - ANImation Header */
/* Contains an ANIHEADER structure. */

#define TAGT_ANIH MAKETAG('A', 'N', 'I', 'H')


/*
 * 'RATE' (DATA) - RATE table (array of jiffies)
 * Contains an array of JIFs.  Each JIF specifies how long the corresponding
 * animation frame is to be displayed before advancing to the next frame.
 * If the AF_SEQUENCE flag is set then the count of JIFs == anih.cSteps,
 * otherwise the count == anih.cFrames.
 */
#define TAGT_RATE MAKETAG('R', 'A', 'T', 'E')

/*
 * 'SEQ ' (DATA) - SEQuence table (array of frame index values)
 * Countains an array of DWORD frame indices.  anih.cSteps specifies how
 * many.
 */
#define TAGT_SEQ  MAKETAG('S', 'E', 'Q', ' ')


/* 'ICON' (DATA) - Windows ICON format image (replaces MPTR) */

#define TAGT_ICON MAKETAG('I', 'C', 'O', 'N')


/* 'TITL' (DATA) - TITLe string (can be inside or outside aggregates) */
/* Contains a single ASCIIZ string that titles the file. */

#define TAGT_TITL MAKETAG('T', 'I', 'T', 'L')


/* 'AUTH' (DATA) - AUTHor string (can be inside or outside aggregates) */
/* Contains a single ASCIIZ string that indicates the author of the file. */

#define TAGT_AUTH MAKETAG('A', 'U', 'T', 'H')



#define TAGT_AXOR MAKETAG('A', 'X', 'O', 'R')


/* Valid TAG styles. */

/* 'CONT' - CONTainer chunk (contains other DATA and CONT chunks) */

#define TAGS_CONT MAKETAG('C', 'O', 'N', 'T')


/* 'DATA' - DATA chunk */

#define TAGS_DATA MAKETAG('D', 'A', 'T', 'A')

typedef DWORD JIF, *PJIF;

typedef struct _ANIHEADER {     /* anih */
    DWORD cbSizeof;
    DWORD cFrames;
    DWORD cSteps;
    DWORD cx, cy;
    DWORD cBitCount, cPlanes;
    JIF   jifRate;
    DWORD fl;
} ANIHEADER, *PANIHEADER;

/* If the AF_ICON flag is specified the fields cx, cy, cBitCount, and */
/* cPlanes are all unused.  Each frame will be of type ICON and will */
/* contain its own dimensional information. */

#define AF_ICON     0x0001L     /* Windows format icon/cursor animation */
#define AF_SEQUENCE 0x0002L     /* Animation is sequenced */
#define WINEVENT_32BITCALLER    0x8000  //  - unused in NT
#define WINEVENT_VALID          0x0007  //
// Output from DISPID_ACC_STATE (IanJa: taken from oleacc.h)
/*
 * CONSTANTS
 */

/*
 * Object constants (these are NOT public).  OBJID are public IDs for
 * standard frame elements.  But the indeces for their elements are not.
 */

// TITLEBAR
#define INDEX_TITLEBAR_SELF             0
#define INDEX_TITLEBAR_IMEBUTTON        1
#define INDEX_TITLEBAR_MINBUTTON        2
#define INDEX_TITLEBAR_MAXBUTTON        3
#define INDEX_TITLEBAR_HELPBUTTON       4
#define INDEX_TITLEBAR_CLOSEBUTTON      5

#define INDEX_TITLEBAR_MIC              1
#define INDEX_TITLEBAR_MAC              5

#define INDEX_TITLEBAR_RESTOREBUTTON    6 // The min/max buttons turn into this


// SCROLLBAR
#define INDEX_SCROLLBAR_SELF            0
#define INDEX_SCROLLBAR_UP              1
#define INDEX_SCROLLBAR_UPPAGE          2
#define INDEX_SCROLLBAR_THUMB           3
#define INDEX_SCROLLBAR_DOWNPAGE        4
#define INDEX_SCROLLBAR_DOWN            5

#define INDEX_SCROLLBAR_MIC             1
#define INDEX_SCROLLBAR_MAC             5

#define INDEX_SCROLLBAR_LEFT            7
#define INDEX_SCROLLBAR_LEFTPAGE        8
#define INDEX_SCROLLBAR_HORZTHUMB       9
#define INDEX_SCROLLBAR_RIGHTPAGE       10
#define INDEX_SCROLLBAR_RIGHT           11

#define INDEX_SCROLLBAR_HORIZONTAL      6
#define INDEX_SCROLLBAR_GRIP            12


// COMBOBOXES
#define INDEX_COMBOBOX                  0
#define INDEX_COMBOBOX_ITEM             1
#define INDEX_COMBOBOX_BUTTON           2
#define INDEX_COMBOBOX_LIST             3

#define CCHILDREN_COMBOBOX              3


#define CBLISTBOXID 1000
#define CBEDITID    1001
#define CBBUTTONID  1002


// CURSORS
#define CURSOR_SYSTEM_NOTHING           -1
#define CURSOR_SYSTEM_UNKNOWN           0
#define CURSOR_SYSTEM_ARROW             1
#define CURSOR_SYSTEM_IBEAM             2
#define CURSOR_SYSTEM_WAIT              3
#define CURSOR_SYSTEM_CROSS             4
#define CURSOR_SYSTEM_UPARROW           5
#define CURSOR_SYSTEM_SIZENWSE          6
#define CURSOR_SYSTEM_SIZENESW          7
#define CURSOR_SYSTEM_SIZEWE            8
#define CURSOR_SYSTEM_SIZENS            9
#define CURSOR_SYSTEM_SIZEALL           10
#define CURSOR_SYSTEM_NO                11
#define CURSOR_SYSTEM_APPSTARTING       12
#define CURSOR_SYSTEM_HELP              13
#define CURSOR_SYSTEM_NWPEN             14
#define CURSOR_SYSTEM_HAND              15
#define CCURSOR_SYSTEM                  15

#define     GA_MIN          1
#define     GA_MAX          3
#if(_WIN32_WINNT >= 0x0500)

/*
 * The max number of tags to fail that can be
 * specified to Win32PoolAllocationStats. If tagsCount is more than
 * this value then all the pool allocations will fail.
 */
#define MAX_TAGS_TO_FAIL        256

BOOL
WINAPI
Win32PoolAllocationStats(
    IN  LPDWORD parrTags,
    IN  SIZE_T  tagCount,
    OUT SIZE_T* lpdwMaxMem,
    OUT SIZE_T* lpdwCrtMem,
    OUT LPDWORD lpdwMaxAlloc,
    OUT LPDWORD lpdwCrtAlloc);

#define WHF_DESKTOP             0x00000001
#define WHF_SHAREDHEAP          0x00000002
#define WHF_CSRSS               0x00000004
#define WHF_ALL                 (WHF_DESKTOP | WHF_SHAREDHEAP | WHF_CSRSS)

#define WHF_VALID               WHF_ALL

VOID
WINAPI
DbgWin32HeapFail(
    DWORD    dwFlags,
    BOOL     bFail
);

typedef struct tagDBGHEAPSTAT {
    DWORD   dwTag;
    DWORD   dwSize;
    DWORD   dwCount;
} DBGHEAPSTAT, *PDBGHEAPSTAT;

DWORD
WINAPI
DbgWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD    dwLen,
    DWORD    dwFlags
);

#define WPROTOCOLNAME_LENGTH    10
#define WAUDIONAME_LENGTH       10

typedef struct tagWSINFO {
    WCHAR ProtocolName[WPROTOCOLNAME_LENGTH];
    WCHAR AudioDriverName[WAUDIONAME_LENGTH];
} WSINFO, *PWSINFO;

BOOL
GetWinStationInfo(
    WSINFO* pWsInfo);

#endif /* _WIN32_WINNT >= 0x0500 */

/*
 * vkey table counts, macros, etc. input synchonized key state tables have
 * 2 bits per vkey: fDown, fToggled. Async key state tables have 3 bits:
 * fDown, fToggled, fDownSinceLastRead.
 *
 * Important! The array gafAsyncKeyState matches the bit positions of the
 * afKeyState array in each thread info block. The fDownSinceLastRead bit
 * for the async state is stored in a separate bit array, called
 * gafAsyncKeyStateRecentDown.
 *
 * It is important that the bit positions of gafAsyncKeyState and
 * pti->afKeyState match because we copy from one to the other to maintain
 * key state synchronization between threads.
 *
 * These macros below MUST be used when setting / querying key state.
 */
#define CVKKEYSTATE                 256
#define CBKEYSTATE                  (CVKKEYSTATE >> 2)
#define CBKEYSTATERECENTDOWN        (CVKKEYSTATE >> 3)
#define KEYSTATE_TOGGLE_BYTEMASK    0xAA    // 10101010
#define KEYSTATE_DOWN_BYTEMASK      0x55    // 01010101

/*
 * Two bits per VK (down & toggle) so we can pack 4 VK keystates into 1 byte:
 *
 *              Byte 0                           Byte 1
 * .---.---.---.---.---.---.---.---. .---.---.---.---.---.---.---.---. .-- -
 * | T | D | T | D | T | D | T | D | | T | D | T | D | T | D | T | D | |
 * `---'---'---'---'---'---'---'---' `---'---'---'---'---'---'---'---' `-- -
 * : VK 3  : VK 2  : VK 1  : VK 0  : : VK 7  : VK 6  : VK 5  : VK 4  : :
 *
 * KEY_BYTE(pb, vk)   identifies the byte containing the VK's state
 * KEY_DOWN_BIT(vk)   identifies the VK's down bit within a byte
 * KEY_TOGGLE_BIT(vk) identifies the VK's toggle bit within a byte
 */
#define KEY_BYTE(pb, vk)   pb[((BYTE)(vk)) >> 2]
#define KEY_DOWN_BIT(vk)   (1 << ((((BYTE)(vk)) & 3) << 1))
#define KEY_TOGGLE_BIT(vk) (1 << (((((BYTE)(vk)) & 3) << 1) + 1))

#define TestKeyDownBit(pb, vk)     (KEY_BYTE(pb,vk) &   KEY_DOWN_BIT(vk))
#define SetKeyDownBit(pb, vk)      (KEY_BYTE(pb,vk) |=  KEY_DOWN_BIT(vk))
#define ClearKeyDownBit(pb, vk)    (KEY_BYTE(pb,vk) &= ~KEY_DOWN_BIT(vk))
#define TestKeyToggleBit(pb, vk)   (KEY_BYTE(pb,vk) &   KEY_TOGGLE_BIT(vk))
#define SetKeyToggleBit(pb, vk)    (KEY_BYTE(pb,vk) |=  KEY_TOGGLE_BIT(vk))
#define ClearKeyToggleBit(pb, vk)  (KEY_BYTE(pb,vk) &= ~KEY_TOGGLE_BIT(vk))
#define ToggleKeyToggleBit(pb, vk) (KEY_BYTE(pb,vk) ^=  KEY_TOGGLE_BIT(vk))

/*
 * Similar to the above, but here we need only one bit per VK (down)
 * so we can pack 8 VK down states into 1 byte.
 */
#define RKEY_BYTE(pb, vk) pb[((BYTE)(vk)) >> 3]
#define RKEY_BIT(vk)      (1 << ((BYTE)(vk) & 7))

#define TestKeyRecentDownBit(pb, vk)  (RKEY_BYTE(pb,vk) &   RKEY_BIT(vk))
#define SetKeyRecentDownBit(pb, vk)   (RKEY_BYTE(pb,vk) |=  RKEY_BIT(vk))
#define ClearKeyRecentDownBit(pb, vk) (RKEY_BYTE(pb,vk) &= ~RKEY_BIT(vk))

#define TestKeyStateDown(pq, vk)\
        TestKeyDownBit(pq->afKeyState, vk)
#define SetKeyStateDown(pq, vk)\
        SetKeyDownBit(pq->afKeyState, vk)
#define ClearKeyStateDown(pq, vk)\
        ClearKeyDownBit(pq->afKeyState, vk)
#define TestKeyStateToggle(pq, vk)\
        TestKeyToggleBit(pq->afKeyState, vk)
#define SetKeyStateToggle(pq, vk)\
        SetKeyToggleBit(pq->afKeyState, vk)
#define ClearKeyStateToggle(pq, vk)\
        ClearKeyToggleBit(pq->afKeyState, vk)

#define TestAsyncKeyStateDown(vk)\
        TestKeyDownBit(gafAsyncKeyState, vk)
#define SetAsyncKeyStateDown(vk)\
        SetKeyDownBit(gafAsyncKeyState, vk)
#define ClearAsyncKeyStateDown(vk)\
        ClearKeyDownBit(gafAsyncKeyState, vk)
#define TestAsyncKeyStateToggle(vk)\
        TestKeyToggleBit(gafAsyncKeyState, vk)
#define SetAsyncKeyStateToggle(vk)\
        SetKeyToggleBit(gafAsyncKeyState, vk)
#define ClearAsyncKeyStateToggle(vk)\
        ClearKeyToggleBit(gafAsyncKeyState, vk)
#define TestAsyncKeyStateRecentDown(vk)\
        TestKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)
#define SetAsyncKeyStateRecentDown(vk)\
        SetKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)
#define ClearAsyncKeyStateRecentDown(vk)\
        ClearKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)

#ifdef __cplusplus
}
#endif  /* __cplusplus */
#endif  /* !_WINUSERP_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xbdm.h ===
//
//
// Xbox debug interface functions
// Copyright Microsoft Corporation 2000 - 2001. All Rights Reserved.
//
//
#ifndef _XBDM_H
#define _XBDM_H


#ifdef __cplusplus
extern "C" {
#endif

#ifdef XBDBGS
#define DMAPI
#endif

#ifndef DMAPI
#ifdef _XBDM_
#define DMAPI
#else
#define DMAPI __declspec(dllimport)
#endif
#endif

#define DMHRAPI DMAPI HRESULT __stdcall

// Notification types
#define DM_NONE 0
#define DM_BREAK 1
#define DM_DEBUGSTR 2
#define DM_EXEC 3
#define DM_SINGLESTEP 4
#define DM_MODLOAD 5
#define DM_MODUNLOAD 6
#define DM_CREATETHREAD 7
#define DM_DESTROYTHREAD 8
#define DM_EXCEPTION 9
#define DM_CLOCKINT 10
#define DM_ASSERT 12
#define DM_DATABREAK 13
#define DM_RIP 14
#define DM_THREADSWITCH 15
#define DM_SECTIONLOAD 16
#define DM_SECTIONUNLOAD 17
#define DM_FIBER 18
#define DM_NOTIFYMAX 18

#define DM_NOTIFICATIONMASK 0xffffff
#define DM_STOPTHREAD 0x80000000

typedef DWORD (__stdcall *PDM_NOTIFY_FUNCTION)(ULONG dwNotification, DWORD dwParam);

// Break notification structure
typedef struct _DMN_BREAK {
    PVOID Address;
    DWORD ThreadId;
} DMN_BREAK, *PDMN_BREAK;

// Data breakpoint notification structure {
typedef struct _DMN_DATABREAK {
    PVOID Address;
    DWORD ThreadId;
    DWORD BreakType;
    PVOID DataAddress;
} DMN_DATABREAK, *PDMN_DATABREAK;

// Debugstr notification structure
typedef struct _DMN_DEBUGSTR {
    DWORD ThreadId;
    DWORD Length;
    LPCSTR String;
} DMN_DEBUGSTR, *PDMN_DEBUGSTR;

// execution notification values
#define DMN_EXEC_STOP 0
#define DMN_EXEC_START 1
#define DMN_EXEC_REBOOT 2
#define DMN_EXEC_PENDING 3

// Module load notification structure
typedef struct _DMN_MODLOAD {
    char Name[MAX_PATH];
    PVOID BaseAddress;
    ULONG Size;
    ULONG TimeStamp;
    ULONG CheckSum;
    ULONG Flags;
} DMN_MODLOAD, *PDMN_MODLOAD;

#define DMN_MODFLAG_XBE     0x0001
#define DMN_MODFLAG_TLS     0x0002

// Section load/unload notification structure
typedef struct _DMN_SECTIONLOAD {
    char Name[MAX_PATH];
    PVOID BaseAddress;
    ULONG Size;
    USHORT Index;
    USHORT Flags;
} DMN_SECTIONLOAD, *PDMN_SECTIONLOAD;

#define DMN_SECFLAG_LOADED  0x0001

// thread create notification structure
typedef struct _DMN_CREATETHREAD {
    DWORD ThreadId;
    PVOID StartAddress;
} DMN_CREATETHREAD, *PDMN_CREATETHREAD;

// fiber create/delete notification structure
typedef struct _DMN_FIBER {
    DWORD FiberId;
    BOOL Create;
    PVOID StartAddress;
} DMN_FIBER, *PDMN_FIBER;

// thread switch notification structure
typedef struct _DMN_THREADSWITCH {
    DWORD OldThreadId;
    DWORD NewThreadId;
} DMN_THREADSWITCH, *PDMN_THREADSWITCH;

// exception notification
typedef struct _DMN_EXCEPTION {
    DWORD ThreadId;
    DWORD Code;
    PVOID Address;
    DWORD Flags;
    DWORD Information[2];
} DMN_EXCEPTION, *PDMN_EXCEPTION;

#define DM_EXCEPT_NONCONTINUABLE 1
#define DM_EXCEPT_FIRSTCHANCE 2

// profiling
typedef struct _DMN_PROFINT {
    DWORD Eip;
    DWORD EFlags;
    DWORD SegCs;
} DMN_PROFINT, *PDMN_PROFINT;

// Notification
#define DM_PERSISTENT 1
#define DM_DEBUGSESSION 2
#define DM_ASYNCSESSION 4
typedef struct _DMN_SESSION *PDMN_SESSION;
DMHRAPI DmOpenNotificationSession(DWORD dwFlags, PDMN_SESSION *pSession);
DMHRAPI DmCloseNotificationSession(PDMN_SESSION Session);
DMHRAPI DmNotify(PDMN_SESSION Session, DWORD dwNotification,
    PDM_NOTIFY_FUNCTION pfnHandler);

// notification extensions
typedef DWORD (__stdcall *PDM_EXT_NOTIFY_FUNCTION)(LPCSTR szNotification);
DMHRAPI DmRegisterNotificationProcessor(PDMN_SESSION Session, LPCSTR szType,
    PDM_EXT_NOTIFY_FUNCTION pfn);

// protocol
#define DEBUGGER_PORT 0x2db

// breakpoint types
#define DMBREAK_NONE 0
#define DMBREAK_WRITE 1
#define DMBREAK_READWRITE 2
#define DMBREAK_EXECUTE 3
#define DMBREAK_FIXED 4

// breakpoint routines
DMHRAPI DmSetBreakpoint(PVOID addr);
DMHRAPI DmRemoveBreakpoint(PVOID addr);
DMHRAPI DmSetInitialBreakpoint(void);
DMHRAPI DmSetDataBreakpoint(PVOID addr, DWORD dwType, DWORD dwSize);
DMHRAPI DmIsBreakpoint(PVOID addr, LPDWORD dwType);

// execution start and stop
DMHRAPI DmStop(void);
DMHRAPI DmGo(void);
DMHRAPI DmHaltThread(DWORD dwThreadId);
DMHRAPI DmContinueThread(DWORD dwThreadId, BOOL fException);
DMHRAPI DmSetupFunctionCall(DWORD dwThreadId);

// debugger
DMAPI BOOL __stdcall DmIsDebuggerPresent(void);

// event stop control
#define DMSTOP_CREATETHREAD 1
#define DMSTOP_FCE 2
#define DMSTOP_DEBUGSTR 4
DMHRAPI DmStopOn(DWORD dwStopFlags, BOOL fStop);

// reboot
#define DMBOOT_WAIT 1
#define DMBOOT_WARM 2
#define DMBOOT_NODEBUG 4
#define DMBOOT_STOP 8
DMHRAPI DmReboot(DWORD dwFlags);

// memory
DMHRAPI DmGetMemory(LPCVOID lpbAddr, DWORD cb, LPVOID lpbBuf,
    LPDWORD pcbRet);
DMHRAPI DmSetMemory(LPVOID lpbAddr, DWORD cb, LPCVOID lpbBuf,
    LPDWORD pcbRet);

// pool memory
DMAPI PVOID __stdcall DmAllocatePool(ULONG cb);
DMAPI PVOID __stdcall DmAllocatePoolWithTag(ULONG cb, ULONG tag);
DMAPI VOID __stdcall DmFreePool(PVOID p);

// profile interrupts
typedef void (__stdcall *PDMPROFILE_HANDLER)(PDMN_PROFINT);
DMHRAPI DmStartProfile(PHANDLE, ULONG, PDMPROFILE_HANDLER);
DMHRAPI DmStopProfile(HANDLE);

// thread stopped info
typedef struct _DM_THREADSTOP {
    DWORD NotifiedReason;
    union {
        DMN_BREAK Break;
        DMN_DATABREAK DataBreak;
        DMN_EXCEPTION Exception;
        DMN_DEBUGSTR DebugStr;
    } u;
} DM_THREADSTOP, *PDM_THREADSTOP;

// thread general info
typedef struct _DM_THREADINFO {
    DWORD SuspendCount;
    DWORD Priority;
    LPVOID TlsBase;
} DM_THREADINFO, *PDM_THREADINFO;

// thread routines
DMHRAPI DmGetThreadList(LPDWORD rgdwThreads, LPDWORD pcThreads);
DMHRAPI DmGetThreadContext(DWORD dwThreadId, PCONTEXT pdmcr);
DMHRAPI DmSetThreadContext(DWORD dwThreadId, PCONTEXT pdmcr);
DMHRAPI DmIsThreadStopped(DWORD dwThreadId, PDM_THREADSTOP pdmts);
DMHRAPI DmGetThreadInfo(DWORD dwThreadId, PDM_THREADINFO pdmti);
DMHRAPI DmSuspendThread(DWORD dwThreadId);
DMHRAPI DmResumeThread(DWORD dwThreadId);

// XTL data
typedef struct _DM_XTLDATA {
    DWORD LastErrorOffset;
} DM_XTLDATA, *PDM_XTLDATA;

DMHRAPI DmGetXtlData(PDM_XTLDATA);

// loaded modules and sections
typedef struct _DM_WALK_MODULES *PDM_WALK_MODULES;
DMHRAPI DmWalkLoadedModules(PDM_WALK_MODULES *, PDMN_MODLOAD);
DMHRAPI DmCloseLoadedModules(PDM_WALK_MODULES);
typedef struct _DM_WALK_MODSECT *PDM_WALK_MODSECT;
DMHRAPI DmWalkModuleSections(PDM_WALK_MODSECT *, LPCSTR, PDMN_SECTIONLOAD);
DMHRAPI DmCloseModuleSections(PDM_WALK_MODSECT);
DMHRAPI DmGetModuleLongName(LPCSTR szShortName, LPSTR szLongName, LPDWORD pcch);

// XBE info
typedef struct _DM_XBE {
    char LaunchPath[MAX_PATH+1];
    DWORD TimeStamp;
    DWORD CheckSum;
    DWORD StackSize;
} DM_XBE, *PDM_XBE;
DMHRAPI DmGetXbeInfo(LPCSTR szName, PDM_XBE);

// command extension
typedef ULONG (__stdcall *PDM_ENTRYPROC)(ULONG, ULONG, ULONG);

typedef struct _DM_CMDCONT *PDM_CMDCONT;
typedef HRESULT (__stdcall *PDM_CMDCONTPROC)(PDM_CMDCONT pdmcc, LPSTR
    szResponse, DWORD cchResponse);
typedef struct _DM_CMDCONT {
    PDM_CMDCONTPROC HandlingFunction;
    DWORD DataSize;
    PVOID Buffer;
    DWORD BufferSize;
    PVOID CustomData;
    DWORD BytesRemaining;
} DM_CMDCONT;

typedef HRESULT (__stdcall *PDM_CMDPROC)(LPCSTR szCommand, LPSTR szResponse,
    DWORD cchResponse, PDM_CMDCONT pdmcc);
DMHRAPI DmRegisterCommandProcessor(LPCSTR szProcessor, PDM_CMDPROC pfn);
DMHRAPI DmRegisterCommandProcessorEx(LPCSTR szProcessor, PDM_CMDPROC pfn,
    PVOID pfnCreateThread);

#define DmRegisterThreadedCommandProcessor(sz, pfn) \
    DmRegisterCommandProcessorEx(sz, pfn, CreateThread)

DMHRAPI DmSendNotificationString(LPCSTR sz);

// per-thread data
DMHRAPI DmThreadUserData(DWORD tid, LPDWORD *ppdwData);
#define DM_CURRENT_THREAD -1

// Dynamic loading of debugger extensions
DMHRAPI DmLoadExtension(LPCSTR szName, PHANDLE phModule, PVOID *pvBase);
DMHRAPI DmUnloadExtension(HANDLE hModule);
DMHRAPI DmGetProcAddress(HANDLE hModule, LPCSTR szProcName, PVOID *ppvRet);

// name functions
DMHRAPI DmGetXboxName(LPSTR, LPDWORD);
DMHRAPI DmSetXboxName(LPCSTR);

// management functions
typedef struct _DM_USER {
    char UserName[256];
    DWORD AccessPrivileges;
} DM_USER, *PDM_USER;

#define DMPL_PRIV_READ           0x0001
#define DMPL_PRIV_WRITE          0x0002
#define DMPL_PRIV_CONTROL        0x0004
#define DMPL_PRIV_CONFIGURE      0x0008
#define DMPL_PRIV_MANAGE         0x0010

DMHRAPI DmAddUser(LPCSTR szUserName, DWORD dwAccess);
DMHRAPI DmRemoveUser(LPCSTR szUserName);
DMHRAPI DmSetUserAccess(LPCSTR szUserName, DWORD dwAccess);
DMHRAPI DmGetUserAccess(LPCSTR szUserName, LPDWORD lpdwAccess);
typedef struct _DM_WALK_USERS *PDM_WALK_USERS;
DMHRAPI DmWalkUserList(PDM_WALK_USERS *, PDM_USER);
DMHRAPI DmCloseUserList(PDM_WALK_USERS);
DMHRAPI DmEnableSecurity(BOOL fEnable);
DMHRAPI DmIsSecurityEnabled(LPBOOL pfEnabled);

// title to launch
DMHRAPI DmSetTitle(LPCSTR szDir, LPCSTR szTitle, LPCSTR szCmdLine);


// start / stop profile data collection
DMHRAPI DmCAPControl(LPCSTR action);

// performance counters
#define DMCOUNT_FREQUENCY   0x000F
#define DMCOUNT_FREQ100MS   0x0001
#define DMCOUNT_FREQ1SEC    0x000A

#define DMCOUNT_COUNTTYPE   0x0030
#define DMCOUNT_EVENT       0x0010
#define DMCOUNT_VALUE       0x0000
#define DMCOUNT_PRATIO      0x0020
#define DMCOUNT_COUNTSUBTYPE 0x0FC0

// event rates
#define DMCOUNT_PERSEC      0x0040
#define DMCOUNT_PERMSEC     0x0080
#define DMCOUNT_PERFRAME    0x0100
#define DMCOUNT_PERTICK     0x0200

// value types
#define DMCOUNT_AVERAGE     0x0040

typedef struct _DM_COUNTDATA {
    LARGE_INTEGER CountValue;
    LARGE_INTEGER RateValue;
    DWORD CountType;
} DM_COUNTDATA, *PDM_COUNTDATA;

typedef struct _DM_COUNTINFO {
    char Name[256];
    DWORD Type;
} DM_COUNTINFO, *PDM_COUNTINFO;

DMHRAPI DmOpenPerformanceCounter(LPCSTR szName, HANDLE *phCounter);
DMHRAPI DmQueryPerformanceCounterHandle(HANDLE hCounter, DWORD dwType, PDM_COUNTDATA);
DMHRAPI DmClosePerformanceCounter(HANDLE hCounter);
typedef struct _DM_WALK_COUNTERS *PDM_WALK_COUNTERS;
DMHRAPI DmWalkPerformanceCounters(PDM_WALK_COUNTERS *, PDM_COUNTINFO);
DMHRAPI DmCloseCounters(PDM_WALK_COUNTERS);
DMHRAPI DmEnableGPUCounter(BOOL);


typedef HRESULT (__stdcall *PDM_COUNTPROC)(PLARGE_INTEGER, PLARGE_INTEGER);
#define DMCOUNT_SYNC      0x00010000
#define DMCOUNT_ASYNC32   0x00020000
#define DMCOUNT_ASYNC64   0x00040000
#define DMCOUNT_ASYNC     0x00080000
DMHRAPI DmRegisterPerformanceCounter(LPCSTR szName, DWORD dwType, PVOID);
DMHRAPI DmUnregisterPerformanceCounter(LPCSTR szName);

// error codes
#define FACILITY_XBDM 0x2db
#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT)(((unsigned long)sev<<31)|((unsigned long)fac<<16)|((unsigned long)code)))
#endif
#define XBDM_HRESERR(code) MAKE_HRESULT(1, FACILITY_XBDM, code)
#define XBDM_HRESSUCC(code) MAKE_HRESULT(0, FACILITY_XBDM, code)

#define XBDM_NOERR XBDM_HRESSUCC(0)

#define XBDM_UNDEFINED XBDM_HRESERR(0)
#define XBDM_MAXCONNECT XBDM_HRESERR(1)
#define XBDM_NOSUCHFILE XBDM_HRESERR(2)
#define XBDM_NOMODULE XBDM_HRESERR(3)
#define XBDM_MEMUNMAPPED XBDM_HRESERR(4)
#define XBDM_NOTHREAD XBDM_HRESERR(5)
#define XBDM_CLOCKNOTSET XBDM_HRESERR(6)
#define XBDM_INVALIDCMD XBDM_HRESERR(7)
#define XBDM_NOTSTOPPED XBDM_HRESERR(8)
#define XBDM_MUSTCOPY XBDM_HRESERR(9)
#define XBDM_ALREADYEXISTS XBDM_HRESERR(10)
#define XBDM_DIRNOTEMPTY XBDM_HRESERR(11)
#define XBDM_BADFILENAME XBDM_HRESERR(12)
#define XBDM_CANNOTCREATE XBDM_HRESERR(13)
#define XBDM_CANNOTACCESS XBDM_HRESERR(14)
#define XBDM_DEVICEFULL XBDM_HRESERR(15)
#define XBDM_NOTDEBUGGABLE XBDM_HRESERR(16)
#define XBDM_BADCOUNTTYPE XBDM_HRESERR(17)
#define XBDM_COUNTUNAVAILABLE XBDM_HRESERR(18)
#define XBDM_NOTLOCKED XBDM_HRESERR(20)
#define XBDM_KEYXCHG XBDM_HRESERR(21)
#define XBDM_MUSTBEDEDICATED XBDM_HRESERR(22)
#define XBDM_CANNOTCONNECT XBDM_HRESERR(0x100)
#define XBDM_CONNECTIONLOST XBDM_HRESERR(0x101)
#define XBDM_FILEERROR XBDM_HRESERR(0x103)
#define XBDM_ENDOFLIST XBDM_HRESERR(0x104)
#define XBDM_BUFFER_TOO_SMALL XBDM_HRESERR(0x105)
#define XBDM_NOTXBEFILE XBDM_HRESERR(0x106)
#define XBDM_MEMSETINCOMPLETE XBDM_HRESERR(0x107)
#define XBDM_NOXBOXNAME XBDM_HRESERR(0x108)
#define XBDM_NOERRORSTRING XBDM_HRESERR(0x109)

#define XBDM_CONNECTED XBDM_HRESSUCC(1)
#define XBDM_MULTIRESPONSE XBDM_HRESSUCC(2)
#define XBDM_BINRESPONSE XBDM_HRESSUCC(3)
#define XBDM_READYFORBIN XBDM_HRESSUCC(4)
#define XBDM_DEDICATED XBDM_HRESSUCC(5)

// Call Attributes Profiler Support Function
#define DM_PROFILE_START    1
#define DM_PROFILE_STOP     2

DWORD WINAPI DmProfileControl(DWORD Action, DWORD Parameter);



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xboxdbg.h ===
//
//
// Xbox debug interface functions
// Copyright Microsoft Corporation 2000 - 2001. All Rights Reserved.
//
//
#ifndef _XBOXDBG_H
#define _XBOXDBG_H


#ifdef __cplusplus
extern "C" {
#endif

#ifdef XBDBGS
#define DMAPI
#endif

#ifndef DMAPI
#ifdef _XBDM_
#define DMAPI
#else
#define DMAPI __declspec(dllimport)
#endif
#endif

#define DMHRAPI DMAPI HRESULT __stdcall

// Notification types
#define DM_NONE 0
#define DM_BREAK 1
#define DM_DEBUGSTR 2
#define DM_EXEC 3
#define DM_SINGLESTEP 4
#define DM_MODLOAD 5
#define DM_MODUNLOAD 6
#define DM_CREATETHREAD 7
#define DM_DESTROYTHREAD 8
#define DM_EXCEPTION 9
#define DM_ASSERT 12
#define DM_DATABREAK 13
#define DM_RIP 14
#define DM_SECTIONLOAD 16
#define DM_SECTIONUNLOAD 17
#define DM_FIBER 18
#define DM_NOTIFYMAX 18

#define DM_NOTIFICATIONMASK 0xffffff
#define DM_STOPTHREAD 0x80000000

typedef DWORD (__stdcall *PDM_NOTIFY_FUNCTION)(ULONG dwNotification, DWORD dwParam);

// Break notification structure
typedef struct _DMN_BREAK {
    PVOID Address;
    DWORD ThreadId;
} DMN_BREAK, *PDMN_BREAK;

// Data breakpoint notification structure {
typedef struct _DMN_DATABREAK {
    PVOID Address;
    DWORD ThreadId;
    DWORD BreakType;
    PVOID DataAddress;
} DMN_DATABREAK, *PDMN_DATABREAK;

// Debugstr notification structure
typedef struct _DMN_DEBUGSTR {
    DWORD ThreadId;
    DWORD Length;
    LPCSTR String;
} DMN_DEBUGSTR, *PDMN_DEBUGSTR;

// execution notification values
#define DMN_EXEC_STOP 0
#define DMN_EXEC_START 1
#define DMN_EXEC_REBOOT 2
#define DMN_EXEC_PENDING 3

// Module load notification structure
typedef struct _DMN_MODLOAD {
    char Name[MAX_PATH];
    PVOID BaseAddress;
    ULONG Size;
    ULONG TimeStamp;
    ULONG CheckSum;
    ULONG Flags;
} DMN_MODLOAD, *PDMN_MODLOAD;

#define DMN_MODFLAG_XBE     0x0001
#define DMN_MODFLAG_TLS     0x0002

// Section load/unload notification structure
typedef struct _DMN_SECTIONLOAD {
    char Name[MAX_PATH];
    PVOID BaseAddress;
    ULONG Size;
    USHORT Index;
    USHORT Flags;
} DMN_SECTIONLOAD, *PDMN_SECTIONLOAD;

#define DMN_SECFLAG_LOADED  0x0001

// thread create notification structure
typedef struct _DMN_CREATETHREAD {
    DWORD ThreadId;
    PVOID StartAddress;
} DMN_CREATETHREAD, *PDMN_CREATETHREAD;

// fiber create/delete notification structure
typedef struct _DMN_FIBER {
    DWORD FiberId;
    BOOL Create;
    PVOID StartAddress;
} DMN_FIBER, *PDMN_FIBER;


// exception notification
typedef struct _DMN_EXCEPTION {
    DWORD ThreadId;
    DWORD Code;
    PVOID Address;
    DWORD Flags;
    DWORD Information[2];
} DMN_EXCEPTION, *PDMN_EXCEPTION;

#define DM_EXCEPT_NONCONTINUABLE 1
#define DM_EXCEPT_FIRSTCHANCE 2


// Notification
#define DM_PERSISTENT 1
#define DM_DEBUGSESSION 2
#define DM_ASYNCSESSION 4
typedef struct _DMN_SESSION *PDMN_SESSION;
DMHRAPI DmOpenNotificationSession(DWORD dwFlags, PDMN_SESSION *pSession);
DMHRAPI DmCloseNotificationSession(PDMN_SESSION Session);
DMHRAPI DmNotify(PDMN_SESSION Session, DWORD dwNotification,
    PDM_NOTIFY_FUNCTION pfnHandler);

// notification extensions
typedef DWORD (__stdcall *PDM_EXT_NOTIFY_FUNCTION)(LPCSTR szNotification);
DMHRAPI DmRegisterNotificationProcessor(PDMN_SESSION Session, LPCSTR szType,
    PDM_EXT_NOTIFY_FUNCTION pfn);

// protocol
#define DEBUGGER_PORT 0x2db

// breakpoint types
#define DMBREAK_NONE 0
#define DMBREAK_WRITE 1
#define DMBREAK_READWRITE 2
#define DMBREAK_EXECUTE 3
#define DMBREAK_FIXED 4

// breakpoint routines
DMHRAPI DmSetBreakpoint(PVOID addr);
DMHRAPI DmRemoveBreakpoint(PVOID addr);
DMHRAPI DmSetInitialBreakpoint(void);
DMHRAPI DmSetDataBreakpoint(PVOID addr, DWORD dwType, DWORD dwSize);
DMHRAPI DmIsBreakpoint(PVOID addr, LPDWORD dwType);

// execution start and stop
DMHRAPI DmStop(void);
DMHRAPI DmGo(void);
DMHRAPI DmHaltThread(DWORD dwThreadId);
DMHRAPI DmContinueThread(DWORD dwThreadId, BOOL fException);
DMHRAPI DmSetupFunctionCall(DWORD dwThreadId);

// debugger
DMHRAPI DmConnectDebugger(BOOL fConnect);

// event stop control
#define DMSTOP_CREATETHREAD 1
#define DMSTOP_FCE 2
#define DMSTOP_DEBUGSTR 4
DMHRAPI DmStopOn(DWORD dwStopFlags, BOOL fStop);

// reboot
#define DMBOOT_WAIT 1
#define DMBOOT_WARM 2
#define DMBOOT_NODEBUG 4
#define DMBOOT_STOP 8
DMHRAPI DmReboot(DWORD dwFlags);

// memory
DMHRAPI DmGetMemory(LPCVOID lpbAddr, DWORD cb, LPVOID lpbBuf,
    LPDWORD pcbRet);
DMHRAPI DmSetMemory(LPVOID lpbAddr, DWORD cb, LPCVOID lpbBuf,
    LPDWORD pcbRet);


// thread stopped info
typedef struct _DM_THREADSTOP {
    DWORD NotifiedReason;
    union {
        DMN_BREAK Break;
        DMN_DATABREAK DataBreak;
        DMN_EXCEPTION Exception;
        DMN_DEBUGSTR DebugStr;
    } u;
} DM_THREADSTOP, *PDM_THREADSTOP;

// thread general info
typedef struct _DM_THREADINFO {
    DWORD SuspendCount;
    DWORD Priority;
    LPVOID TlsBase;
} DM_THREADINFO, *PDM_THREADINFO;

// thread routines
DMHRAPI DmGetThreadList(LPDWORD rgdwThreads, LPDWORD pcThreads);
DMHRAPI DmGetThreadContext(DWORD dwThreadId, PCONTEXT pdmcr);
DMHRAPI DmSetThreadContext(DWORD dwThreadId, PCONTEXT pdmcr);
DMHRAPI DmIsThreadStopped(DWORD dwThreadId, PDM_THREADSTOP pdmts);
DMHRAPI DmGetThreadInfo(DWORD dwThreadId, PDM_THREADINFO pdmti);
DMHRAPI DmSuspendThread(DWORD dwThreadId);
DMHRAPI DmResumeThread(DWORD dwThreadId);

// XTL data
typedef struct _DM_XTLDATA {
    DWORD LastErrorOffset;
} DM_XTLDATA, *PDM_XTLDATA;

DMHRAPI DmGetXtlData(PDM_XTLDATA);

// loaded modules and sections
typedef struct _DM_WALK_MODULES *PDM_WALK_MODULES;
DMHRAPI DmWalkLoadedModules(PDM_WALK_MODULES *, PDMN_MODLOAD);
DMHRAPI DmCloseLoadedModules(PDM_WALK_MODULES);
typedef struct _DM_WALK_MODSECT *PDM_WALK_MODSECT;
DMHRAPI DmWalkModuleSections(PDM_WALK_MODSECT *, LPCSTR, PDMN_SECTIONLOAD);
DMHRAPI DmCloseModuleSections(PDM_WALK_MODSECT);
DMHRAPI DmGetModuleLongName(LPCSTR szShortName, LPSTR szLongName, LPDWORD pcch);

// XBE info
typedef struct _DM_XBE {
    char LaunchPath[MAX_PATH+1];
    DWORD TimeStamp;
    DWORD CheckSum;
    DWORD StackSize;
} DM_XBE, *PDM_XBE;
DMHRAPI DmGetXbeInfo(LPCSTR szName, PDM_XBE);

// socket-level commands
typedef struct _DM_CONNECTION *PDM_CONNECTION;
DMHRAPI DmSetConnectionTimeout(DWORD dwConnectTimeout, DWORD dwConversationTimeout);
DMHRAPI DmOpenConnection(PDM_CONNECTION *);
DMHRAPI DmOpenSecureConnection(PDM_CONNECTION *, LPCSTR szPassword);
DMHRAPI DmCloseConnection(PDM_CONNECTION);
DMHRAPI DmSendCommand(PDM_CONNECTION, LPCSTR szCommand, LPSTR szResponse,
    LPDWORD lpdwResponseSize);
DMHRAPI DmReceiveStatusResponse(PDM_CONNECTION, LPSTR szResponse,
    LPDWORD lpdwResponseSize);
DMHRAPI DmReceiveSocketLine(PDM_CONNECTION, LPSTR szResponse,
    LPDWORD lpdwResponseSize);
DMHRAPI DmDedicateConnection(PDM_CONNECTION, LPCSTR szHandler);
DMHRAPI DmSendBinary(PDM_CONNECTION, LPCVOID pv, DWORD cb);
DMHRAPI DmReceiveBinary(PDM_CONNECTION, LPCVOID pv, DWORD cb, LPDWORD pcbRet);
DMHRAPI DmResolveXboxName(LPDWORD lpdwAddress);
DMHRAPI DmGetNameOfXbox(LPSTR szName, LPDWORD lpdwSize, BOOL fResolvable);
DMHRAPI DmGetAltAddress(LPDWORD lpdwAddress);

// protocol commands
DMHRAPI DmUseSharedConnection(BOOL);

// file attributes
typedef struct _DM_FILE_ATTRIBUTES {
    char Name[256];
    FILETIME CreationTime;
    FILETIME ChangeTime;
    DWORD SizeHigh;
    DWORD SizeLow;
    DWORD Attributes;
} DM_FILE_ATTRIBUTES, *PDM_FILE_ATTRIBUTES;

// filesystem
DMHRAPI DmSendFileA(LPCSTR szLocalName, LPCSTR szRemoteName);
// filesystem
DMHRAPI DmSendFileW(LPCWSTR szLocalName, LPCSTR szRemoteName);
#ifdef UNICODE
#define DmSendFile  DmSendFileW
#else
#define DmSendFile  DmSendFileA
#endif // !UNICODE

DMHRAPI DmReceiveFileA(LPCSTR szLocalName, LPCSTR szRemoteName);
DMHRAPI DmReceiveFileW(LPCWSTR szLocalName, LPCSTR szRemoteName);
#ifdef UNICODE
#define DmReceiveFile  DmReceiveFileW
#else
#define DmReceiveFile  DmReceiveFileA
#endif // !UNICODE

DMHRAPI DmGetFileAttributes(LPCSTR szFileName, PDM_FILE_ATTRIBUTES);
DMHRAPI DmSetFileAttributes(LPCSTR szFileName, PDM_FILE_ATTRIBUTES);
DMHRAPI DmMkdir(LPCSTR szDirectoryName);
DMHRAPI DmRenameFile(LPCSTR szOldName, LPCSTR szNewName);
DMHRAPI DmDeleteFile(LPCSTR szFileName, BOOL fIsDirectory);

// directory walking
typedef struct _DM_WALK_DIR *PDM_WALK_DIR;
DMHRAPI DmWalkDir(PDM_WALK_DIR *, LPCSTR szDir, PDM_FILE_ATTRIBUTES);
DMHRAPI DmCloseDir(PDM_WALK_DIR);

// time
DMHRAPI DmGetSystemTime(LPSYSTEMTIME lpSysTime);

// config functions
DMHRAPI DmSetConfigValue(ULONG ulValueIndex, ULONG ulType, PVOID pValue, ULONG cbValueLength);

// name functions
DMHRAPI DmGetXboxName(LPSTR, LPDWORD);
DMHRAPI DmSetXboxName(LPCSTR);
DMHRAPI DmSetXboxNameNoRegister(LPCSTR);

// management functions
typedef struct _DM_USER {
    char UserName[256];
    DWORD AccessPrivileges;
} DM_USER, *PDM_USER;

#define DMPL_PRIV_READ           0x0001
#define DMPL_PRIV_WRITE          0x0002
#define DMPL_PRIV_CONTROL        0x0004
#define DMPL_PRIV_CONFIGURE      0x0008
#define DMPL_PRIV_MANAGE         0x0010

DMHRAPI DmAddUser(LPCSTR szUserName, DWORD dwAccess);
DMHRAPI DmRemoveUser(LPCSTR szUserName);
DMHRAPI DmSetUserAccess(LPCSTR szUserName, DWORD dwAccess);
DMHRAPI DmGetUserAccess(LPCSTR szUserName, LPDWORD lpdwAccess);
typedef struct _DM_WALK_USERS *PDM_WALK_USERS;
DMHRAPI DmWalkUserList(PDM_WALK_USERS *, PDM_USER);
DMHRAPI DmCloseUserList(PDM_WALK_USERS);
DMHRAPI DmEnableSecurity(BOOL fEnable);
DMHRAPI DmIsSecurityEnabled(LPBOOL pfEnabled);
DMHRAPI DmSetAdminPassword(LPCSTR szPassword);

// title to launch
DMHRAPI DmSetTitle(LPCSTR szDir, LPCSTR szTitle, LPCSTR szCmdLine);

// Screenshot functionality
DMHRAPI DmScreenShot(LPCSTR filename);
// Pixel shader snapshot
DMHRAPI DmPixelShaderSnapshot(DWORD dwX, DWORD dwY, DWORD dwFlags, DWORD dwMarker, BYTE *pBuf);
// Vertex shader snapshot
DMHRAPI DmVertexShaderSnapshot(DWORD dwFirst, DWORD dwLast, DWORD dwFlags, DWORD dwMarker, BYTE *pBuf);

// start / stop profile data collection
DMHRAPI DmCAPControl(LPCSTR action);

// performance counters
#define DMCOUNT_FREQUENCY   0x000F
#define DMCOUNT_FREQ100MS   0x0001
#define DMCOUNT_FREQ1SEC    0x000A

#define DMCOUNT_COUNTTYPE   0x0030
#define DMCOUNT_EVENT       0x0010
#define DMCOUNT_VALUE       0x0000
#define DMCOUNT_PRATIO      0x0020
#define DMCOUNT_COUNTSUBTYPE 0x0FC0

// event rates
#define DMCOUNT_PERSEC      0x0040
#define DMCOUNT_PERMSEC     0x0080
#define DMCOUNT_PERFRAME    0x0100
#define DMCOUNT_PERTICK     0x0200

// value types
#define DMCOUNT_AVERAGE     0x0040

typedef struct _DM_COUNTDATA {
    LARGE_INTEGER CountValue;
    LARGE_INTEGER RateValue;
    DWORD CountType;
} DM_COUNTDATA, *PDM_COUNTDATA;

typedef struct _DM_COUNTINFO {
    char Name[256];
    DWORD Type;
} DM_COUNTINFO, *PDM_COUNTINFO;

DMHRAPI DmQueryPerformanceCounter(LPCSTR szName, DWORD dwType, PDM_COUNTDATA);
typedef struct _DM_WALK_COUNTERS *PDM_WALK_COUNTERS;
DMHRAPI DmWalkPerformanceCounters(PDM_WALK_COUNTERS *, PDM_COUNTINFO);
DMHRAPI DmCloseCounters(PDM_WALK_COUNTERS);
DMHRAPI DmEnableGPUCounter(BOOL);

DMHRAPI DmGetDriveList(LPSTR rgchDrives, DWORD *pcDrives);
DMHRAPI DmGetDiskFreeSpace(char *szDrive,
                           PULARGE_INTEGER pnFreeBytesAvailableToCaller,
                           PULARGE_INTEGER pnTotalNumberOfBytes,
                           PULARGE_INTEGER pnTotalNumberOfFreeBytes);


// error codes
#define FACILITY_XBDM 0x2db
#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT)(((unsigned long)sev<<31)|((unsigned long)fac<<16)|((unsigned long)code)))
#endif
#define XBDM_HRESERR(code) MAKE_HRESULT(1, FACILITY_XBDM, code)
#define XBDM_HRESSUCC(code) MAKE_HRESULT(0, FACILITY_XBDM, code)

#define XBDM_NOERR XBDM_HRESSUCC(0)

#define XBDM_UNDEFINED XBDM_HRESERR(0)
#define XBDM_MAXCONNECT XBDM_HRESERR(1)
#define XBDM_NOSUCHFILE XBDM_HRESERR(2)
#define XBDM_NOMODULE XBDM_HRESERR(3)
#define XBDM_MEMUNMAPPED XBDM_HRESERR(4)
#define XBDM_NOTHREAD XBDM_HRESERR(5)
#define XBDM_CLOCKNOTSET XBDM_HRESERR(6)
#define XBDM_INVALIDCMD XBDM_HRESERR(7)
#define XBDM_NOTSTOPPED XBDM_HRESERR(8)
#define XBDM_MUSTCOPY XBDM_HRESERR(9)
#define XBDM_ALREADYEXISTS XBDM_HRESERR(10)
#define XBDM_DIRNOTEMPTY XBDM_HRESERR(11)
#define XBDM_BADFILENAME XBDM_HRESERR(12)
#define XBDM_CANNOTCREATE XBDM_HRESERR(13)
#define XBDM_CANNOTACCESS XBDM_HRESERR(14)
#define XBDM_DEVICEFULL XBDM_HRESERR(15)
#define XBDM_NOTDEBUGGABLE XBDM_HRESERR(16)
#define XBDM_BADCOUNTTYPE XBDM_HRESERR(17)
#define XBDM_COUNTUNAVAILABLE XBDM_HRESERR(18)
#define XBDM_NOTLOCKED XBDM_HRESERR(20)
#define XBDM_KEYXCHG XBDM_HRESERR(21)
#define XBDM_MUSTBEDEDICATED XBDM_HRESERR(22)
#define XBDM_CANNOTCONNECT XBDM_HRESERR(0x100)
#define XBDM_CONNECTIONLOST XBDM_HRESERR(0x101)
#define XBDM_FILEERROR XBDM_HRESERR(0x103)
#define XBDM_ENDOFLIST XBDM_HRESERR(0x104)
#define XBDM_BUFFER_TOO_SMALL XBDM_HRESERR(0x105)
#define XBDM_NOTXBEFILE XBDM_HRESERR(0x106)
#define XBDM_MEMSETINCOMPLETE XBDM_HRESERR(0x107)
#define XBDM_NOXBOXNAME XBDM_HRESERR(0x108)
#define XBDM_NOERRORSTRING XBDM_HRESERR(0x109)

#define XBDM_CONNECTED XBDM_HRESSUCC(1)
#define XBDM_MULTIRESPONSE XBDM_HRESSUCC(2)
#define XBDM_BINRESPONSE XBDM_HRESSUCC(3)
#define XBDM_READYFORBIN XBDM_HRESSUCC(4)
#define XBDM_DEDICATED XBDM_HRESSUCC(5)


#ifndef XBDBGS
DMHRAPI DmTranslateErrorA(HRESULT hr, LPSTR lpBuffer, int nBufferMax);
DMHRAPI DmTranslateErrorW(HRESULT hr, LPWSTR lpBuffer, int nBufferMax);
#ifdef UNICODE
#define DmTranslateError  DmTranslateErrorW
#else
#define DmTranslateError  DmTranslateErrorA
#endif // !UNICODE
#endif

// Image file routines
DMHRAPI XbeGetLocalModulePathA(LPCSTR szXbe, LPCSTR szModule, LPSTR szPath,
    DWORD cchPath);
// Image file routines
DMHRAPI XbeGetLocalModulePathW(LPCWSTR szXbe, LPCSTR szModule, LPSTR szPath,
    DWORD cchPath);
#ifdef UNICODE
#define XbeGetLocalModulePath  XbeGetLocalModulePathW
#else
#define XbeGetLocalModulePath  XbeGetLocalModulePathA
#endif // !UNICODE
DMHRAPI XbeGetXbeInfoA(LPCSTR szXbe, PDM_XBE pXbe);
DMHRAPI XbeGetXbeInfoW(LPCWSTR szXbe, PDM_XBE pXbe);
#ifdef UNICODE
#define XbeGetXbeInfo  XbeGetXbeInfoW
#else
#define XbeGetXbeInfo  XbeGetXbeInfoA
#endif // !UNICODE
DMHRAPI XbeGetBuilderArgsA(LPCSTR szXbe, LPSTR szArgs, LPDWORD pcch);
DMHRAPI XbeGetBuilderArgsW(LPCWSTR szXbe, LPSTR szArgs, LPDWORD pcch);
#ifdef UNICODE
#define XbeGetBuilderArgs  XbeGetBuilderArgsW
#else
#define XbeGetBuilderArgs  XbeGetBuilderArgsA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xbeimage.h ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    xbeimage.h

Abstract:

    This module contains the structures that describe the Xbox Executable (XBE)
    format.

--*/

#ifndef _XBEIMAGE_
#define _XBEIMAGE_

#include <crypto\xcrypt.h>

#include <pshpack1.h>

//
// Define the signature bytes for the XBE image header.  This corresponds to the
// string "XBEH".
//

#define XBEIMAGE_SIGNATURE                      0x48454258

//
// Define the standard base address for an XBE image.
//

#define XBEIMAGE_STANDARD_BASE_ADDRESS          0x00010000

//
// Define the entry point signature for an XBE image.
//

typedef
VOID
(__cdecl *PXBEIMAGE_ENTRY_POINT)(
    VOID
    );

//
// Define the maximum length in characters of a title name in the XBE image
// certificate.
//

#define XBEIMAGE_TITLE_NAME_LENGTH              40

//
// Define the number of alternate title identifiers that can be stored in the
// XBE image certificate.
//

#define XBEIMAGE_ALTERNATE_TITLE_ID_COUNT       16

//
// Define the length of the keys stored in the XBE image certificate.
//

#define XBEIMAGE_CERTIFICATE_KEY_LENGTH         16

//
// Define the structure of the XBE certificate raw data key.
//

typedef UCHAR XBEIMAGE_CERTIFICATE_KEY[XBEIMAGE_CERTIFICATE_KEY_LENGTH];

//
// Define the game region flags for the XBE image certificate.
//

#define XBEIMAGE_GAME_REGION_NA                 0x00000001
#define XBEIMAGE_GAME_REGION_JAPAN              0x00000002
#define XBEIMAGE_GAME_REGION_RESTOFWORLD        0x00000004
#define XBEIMAGE_GAME_REGION_MANUFACTURING      0x80000000

//
// Define the media type flags for the XBE image certificate.
//

#define XBEIMAGE_MEDIA_TYPE_HARD_DISK           0x00000001
#define XBEIMAGE_MEDIA_TYPE_DVD_X2              0x00000002
#define XBEIMAGE_MEDIA_TYPE_DVD_CD              0x00000004
#define XBEIMAGE_MEDIA_TYPE_CD                  0x00000008
#define XBEIMAGE_MEDIA_TYPE_DVD_5_RO            0x00000010
#define XBEIMAGE_MEDIA_TYPE_DVD_9_RO            0x00000020
#define XBEIMAGE_MEDIA_TYPE_DVD_5_RW            0x00000040
#define XBEIMAGE_MEDIA_TYPE_DVD_9_RW            0x00000080
#define XBEIMAGE_MEDIA_TYPE_DONGLE              0x00000100
#define XBEIMAGE_MEDIA_TYPE_MEDIA_BOARD         0x00000200
#define XBEIMAGE_MEDIA_TYPE_NONSECURE_HARD_DISK 0x40000000
#define XBEIMAGE_MEDIA_TYPE_NONSECURE_MODE      0x80000000
#define XBEIMAGE_MEDIA_TYPE_MEDIA_MASK          0x00FFFFFF

//
// Define the structure of the XBE certificate.
//

typedef struct _XBEIMAGE_CERTIFICATE {

    //
    // Specifies the number of bytes stored in this certificate structure.
    //
    ULONG SizeOfCertificate;

    //
    // Specifies the time that the certificate was last modified expressed as
    // the number of seconds elapsed since midnight (00:00:000), January 1,
    // 1970, coordinated universal time.
    //
    ULONG TimeDateStamp;

    //
    // Specifies the identifier of the title that this XBE image belongs to.
    //
    ULONG TitleID;

    //
    // Specifies the null-terminated name of the title.
    //
    WCHAR TitleName[XBEIMAGE_TITLE_NAME_LENGTH];

    //
    // Specifies the identifiers of other titles that this XBE image is allowed
    // to access via the XTL storage APIs.
    //
    ULONG AlternateTitleIDs[XBEIMAGE_ALTERNATE_TITLE_ID_COUNT];

    //
    // Specifies the types of media that the XBE image is allowed to run off of.
    //
    ULONG AllowedMediaTypes;

    //
    // Specifies the regions that this XBE image is allowed to run in.
    //
    ULONG GameRegion;

    //
    // Specifies the rating of this XBE image.
    //
    ULONG GameRatings;

    //
    // Specifies the zero-based disk number of the title for a multi-disc game.
    //
    ULONG DiskNumber;

    //
    // Specifies the version of the title as tracked by the certification
    // process.
    //
    ULONG Version;

    //
    // Specifies the raw data used for generating the LAN key.  The LAN key is a
    // shared key used for network play.
    //
    XBEIMAGE_CERTIFICATE_KEY LANKey;

    //
    // Specifies the raw data used for generating the signature key.  The
    // signature key is used for signing the title's saved games.
    //
    XBEIMAGE_CERTIFICATE_KEY SignatureKey;

    //
    // Specifies the signature keys corresponding to the alternate title
    // identifiers.
    //
    XBEIMAGE_CERTIFICATE_KEY AlternateSignatureKeys[XBEIMAGE_ALTERNATE_TITLE_ID_COUNT];

    //
    // Specifies the original size of this certificate when the image was
    // first built
    //
    ULONG OriginalSizeOfCertificate;

    //
    // Specifies the online service to contact for online games.
    //
    ULONG OnlineServiceName;

} XBEIMAGE_CERTIFICATE, *PXBEIMAGE_CERTIFICATE;

//
// Define the size of the certificate structure in the first release of the XBE
// loader.
//

#define XBEIMAGE_CERTIFICATE_BASE_SIZEOF \
    (FIELD_OFFSET(XBEIMAGE_CERTIFICATE, AlternateSignatureKeys) + \
    (sizeof(XBEIMAGE_CERTIFICATE_KEY) * XBEIMAGE_ALTERNATE_TITLE_ID_COUNT))

//
// Define the structure of the XBE import directory.  A directory entry exists
// for each image that the XBE image imports from.
//

typedef struct _XBEIMAGE_IMPORT_DESCRIPTOR {

    //
    // Specifies the pointer to the array of import thunks.  All import thunks
    // are specified by ordinal.
    //
    PIMAGE_THUNK_DATA ImageThunkData;

    //
    // Specifies the null-terminated name of the image to import from.
    //
    PWCHAR ImageName;

} XBEIMAGE_IMPORT_DESCRIPTOR, *PXBEIMAGE_IMPORT_DESCRIPTOR;

//
// Defines the flags that apply to XBE image sections.
//

#define XBEIMAGE_SECTION_WRITEABLE              0x00000001
#define XBEIMAGE_SECTION_PRELOAD                0x00000002
#define XBEIMAGE_SECTION_EXECUTABLE             0x00000004
#define XBEIMAGE_SECTION_INSERTFILE             0x00000008
#define XBEIMAGE_SECTION_HEAD_PAGE_READONLY     0x00000010
#define XBEIMAGE_SECTION_TAIL_PAGE_READONLY     0x00000020

//
// Define the structure of the XBE image section.
//

typedef struct _XBEIMAGE_SECTION {

    //
    // Specifies attributes about the section.
    //
    ULONG SectionFlags;

    //
    // Specifies the base virtual address of the section.
    //
    ULONG VirtualAddress;

    //
    // Specifies the number of bytes this section occupies in memory.
    //
    ULONG VirtualSize;

    //
    // Specifies the starting file byte offset of the section.
    //
    ULONG PointerToRawData;

    //
    // Specifies the number of bytes that the section occupies in the file.  The
    // difference between the virtual size and this field is filled with zeroes.
    //
    ULONG SizeOfRawData;

    //
    // Specifies the name of the section.
    //
    PUCHAR SectionName;

    //
    // Specifies at run time, the number of times that this section has been
    // loaded.  A section is unloaded when the reference count is decremented to
    // zero.
    //
    ULONG SectionReferenceCount;

    //
    // Specifies pointers to integers used to track the shared page reference
    // count for the head and tail portions of the section.  A page is
    // decommitted when the shared reference count is decremented to zero.
    //
    PUSHORT HeadSharedPageReferenceCount;
    PUSHORT TailSharedPageReferenceCount;

    //
    // Specifies the SHA1 digest of the section.
    //
    UCHAR SectionDigest[XC_DIGEST_LEN];

} XBEIMAGE_SECTION, *PXBEIMAGE_SECTION;

//
// Define the length of the library name stored in a library version structure.
//

#define XBEIMAGE_LIBRARY_VERSION_NAME_LENGTH    8

//
// Define the structure of a XBE library version descriptor.
//

typedef struct _XBEIMAGE_LIBRARY_VERSION {

    //
    // Specifies ASCII text padded with nulls to identify the library.
    //
    UCHAR LibraryName[XBEIMAGE_LIBRARY_VERSION_NAME_LENGTH];

    //
    // Specifies the major version number of the library.
    //
    USHORT MajorVersion;

    //
    // Specifies the minor version number of the library.
    //
    USHORT MinorVersion;

    //
    // Specifies the build version number of the library.
    //
    USHORT BuildVersion;

    //
    // Specifies the QFE version number of the library.
    //
    USHORT QFEVersion : 13;

    //
    // Specifies the approved status of this library
    // 0 = unapproved
    // 1 = conditionally approved
    // 2 = approved
    USHORT ApprovedLibrary : 2;

    //
    // Specifies TRUE if this is a debug build of the library, else FALSE.
    //
    USHORT DebugBuild : 1;

} XBEIMAGE_LIBRARY_VERSION, *PXBEIMAGE_LIBRARY_VERSION;

//
// Define the structure of the XBE image header.  All XBE images contain this
// structure at file byte offset zero.
//

typedef struct _XBEIMAGE_HEADER {

    //
    // Contains XBEIMAGE_SIGNATURE.
    //
    ULONG Signature;

    //
    // Specifies the encrypted digest of the image headers starting at the
    // field following this field.
    //
    UCHAR EncryptedDigest[XC_ENC_SIGNATURE_SIZE];

    //
    // Specifies the base address for the image, which is the pointer to the
    // XBEIMAGE_HEADER structure.
    //
    PVOID BaseAddress;

    //
    // Specifies the number of bytes that are used to store the image headers.
    //
    ULONG SizeOfHeaders;

    //
    // Specifies the number of bytes required to map the entire image.
    //
    ULONG SizeOfImage;

    //
    // Specifies the number of bytes stored in this image header structure.
    //
    ULONG SizeOfImageHeader;

    //
    // Specifies the time that the image was created expressed as the number of
    // seconds elapsed since midnight (00:00:000), January 1, 1970, coordinated
    // universal time.
    //
    ULONG TimeDateStamp;

    //
    // Specifies the virtual address of the XBE certificate.
    //
    PXBEIMAGE_CERTIFICATE Certificate;

    //
    // Specifies the number of sections that are contained in the image.
    //
    ULONG NumberOfSections;

    //
    // Specifies the virtual address of the XBE image section headers.
    //
    PXBEIMAGE_SECTION SectionHeaders;

    //
    // Specifies initialization flags to control the behavior of the XBE image.
    // See the XINIT_* flags.
    //
    ULONG InitFlags;

    //
    // Specifies the virtual address of the entry point of the XBE image.
    //
    PXBEIMAGE_ENTRY_POINT AddressOfEntryPoint;

    //
    // Specifies the virtual address of the IMAGE_TLS_DIRECTORY structure.  The
    // virtual address may be NULL if the image does not require any thread
    // local storage.
    //
    PIMAGE_TLS_DIRECTORY TlsDirectory;

    //
    // Specifies the default number of bytes to allocate for a stack for a
    // thread created by CreateThread.
    //
    ULONG SizeOfStackCommit;

    //
    // Specifies the number of bytes to reserve and commit for the default
    // process heap.
    //
    ULONG SizeOfHeapReserve;
    ULONG SizeOfHeapCommit;

    //
    // Specifies the pointer to the portable executable (PE) header of the
    // original file.  This pointer may be NULL if the image was not built with
    // the /PEHEADER switch specified.
    //
    PVOID NtBaseOfDll;

    //
    // Contains values from the IMAGE_NT_HEADERS of the original portable
    // executable (PE) file that was used to build this XBE image.  Used for
    // debugging purposes.
    //
    ULONG NtSizeOfImage;
    ULONG NtCheckSum;
    ULONG NtTimeDateStamp;

    //
    // Specifies the null-terminated full path to the original portable
    // executable (PE) file that was used to build this XBE image.  Used for
    // debugging purposes.
    //
    PUCHAR DebugPathName;

    //
    // Specifies the null-terminated file name of the original portable
    // executable (PE) file that was used to build this XBE image.  Used for
    // debugging purposes.
    //
    PUCHAR DebugFileName;
    PWCHAR DebugUnicodeFileName;

    //
    // Specifies the virtual address of the array of import thunks from the
    // Xbox kernel.  All import thunks must be by ordinal.  The array is
    // terminated by a NULL import thunk.
    //
    PIMAGE_THUNK_DATA XboxKernelThunkData;

    //
    // Specifies the virtual address of the array of import directories for
    // image imports other than those from the Xbox kernel.  The array is
    // terminated by an entry with a NULL ImageThunkData field.  This virtual
    // address may be NULL if no additional imports are required to run the
    // image.
    //
    // These import directories are only processed on a developer kit version of
    // the kernel.  For the retail version of the kernel, this field must be
    // NULL.
    //
    PXBEIMAGE_IMPORT_DESCRIPTOR ImportDirectory;

    //
    // Specifies the number of library versions that are contained in the image.
    //
    ULONG NumberOfLibraryVersions;

    //
    // Specifies the virtual address of the array of library version
    // descriptors.
    //
    PXBEIMAGE_LIBRARY_VERSION LibraryVersions;

    //
    // Specifies the virtual addresses of the XBOXKRNL and XAPI library version
    // descriptors.  These should be pointers within the above LibraryVersions
    // section.  These are maintained as separate pointers to avoid having
    // search code in the loader for these library version descriptors.  These
    // virtual addresses may be NULL if the image was not linked against these
    // libraries.
    //
    PXBEIMAGE_LIBRARY_VERSION XboxKernelLibraryVersion;
    PXBEIMAGE_LIBRARY_VERSION XapiLibraryVersion;

    //
    // Specifies the virtual address of the Microsoft logo bitmap used for
    // copyright purposes and the number of bytes used by the logo.
    //
    PVOID MicrosoftLogo;
    ULONG SizeOfMicrosoftLogo;

} XBEIMAGE_HEADER, *PXBEIMAGE_HEADER;

//
// Define the size of the image header structure in the first release of the XBE
// loader.
//

#define XBEIMAGE_HEADER_BASE_SIZEOF \
    (FIELD_OFFSET(XBEIMAGE_HEADER, SizeOfMicrosoftLogo) + sizeof(ULONG))

//
// Define the initialization flags stored in the image header.
//

#define XINIT_MOUNT_UTILITY_DRIVE               0x00000001
#define XINIT_FORMAT_UTILITY_DRIVE              0x00000002
#define XINIT_LIMIT_DEVKIT_MEMORY               0x00000004
#define XINIT_NO_SETUP_HARD_DISK                0x00000008
#define XINIT_DONT_MODIFY_HARD_DISK             0x00000010
#define XINIT_UTILITY_DRIVE_CLUSTER_SIZE_MASK   0xC0000000

#define XINIT_UTILITY_DRIVE_CLUSTER_SIZE_SHIFT  30
#define XINIT_UTILITY_DRIVE_16K_CLUSTER_SIZE    0x00000000
#define XINIT_UTILITY_DRIVE_32K_CLUSTER_SIZE    0x40000000
#define XINIT_UTILITY_DRIVE_64K_CLUSTER_SIZE    0x80000000
#define XINIT_UTILITY_DRIVE_128K_CLUSTER_SIZE   0xC0000000

#include <poppack.h>

#endif // XBEIMAGE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xactp.h ===
/**************************************************************************
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xact.h
 *  Content:    X-Box Audio Content Tool Runtime Engine.
//@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  01/17/2002  georgioc Created.
//@@END_MSINTERNAL
 *
 **************************************************************************/

#ifndef __XACT_ENGINE_INCLUDED__
#define __XACT_ENGINE_INCLUDED__

#pragma warning(disable:4201)

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(p)
#endif // UNREFERENCED_PARAMETER

//
// Forward declarations
//

typedef struct IXACTEngine IXACTEngine;
typedef IXACTEngine *LPXACTENGINE;
typedef IXACTEngine *PXACTENGINE;

typedef struct IXACTSoundBank IXACTSoundBank;
typedef IXACTSoundBank *LPXACTSOUNDBANK;
typedef IXACTSoundBank *PXACTSOUNDBANK;

typedef struct IXACTSoundSource IXACTSoundSource;
typedef IXACTSoundSource *LPXACTSOUNDSOURCE;
typedef IXACTSoundSource *PXACTSOUNDSOURCE;

typedef struct IXACTSoundCue IXACTSoundCue;
typedef IXACTSoundCue *LPXACTSOUNDCUE;
typedef IXACTSoundCue *PXACTSOUNDCUE;

typedef struct IXACTWaveBank IXACTWaveBank;
typedef IXACTWaveBank *LPXACTWAVEBANK;
typedef IXACTWaveBank *PXACTWAVEBANK;

//@@BEGIN_MSINTERNAL
typedef struct XACT_TRACK_EVENT XACT_TRACK_EVENT;
typedef XACT_TRACK_EVENT *PXACT_TRACK_EVENT;
typedef XACT_TRACK_EVENT *LPXACT_TRACK_EVENT;
//@@END_MSINTERNAL
//
// Structures and types
//

#define XACT_SIZEOF_MARKER_DATA		8

//
// Notifications
//

typedef enum _XACT_NOTIFICATION_TYPE {

    eXACTNotification_Start = 0,
    eXACTNotification_Stop,
    eXACTNotification_Marker,
	eXACTNotification_Max

};

#define XACT_MASK_NOTIFICATION_TYPE		0x0000FFFF
#define XACT_MASK_NOTIFICATION_FLAGS	0xFFFF0000


#define XACT_NOTIFICATION_TYPE_UNUSED	0xFFFFFFFF

//
// flags used when registering notifications
//

#define XACT_FLAG_NOTIFICATION_PERSIST	0x00010000


typedef struct _XACT_NOTIFICATION_START {

    DWORD dwFlags;

} XACT_NOTIFICATION_START, *PXACT_NOTIFICATION_START, *LPXACT_NOTIFICATION_START;
 
typedef struct _XACT_NOTIFICATION_STOP {

    DWORD dwFlags;

} XACT_NOTIFICATION_STOP, *PXACT_NOTIFICATION_STOP, *LPXACT_NOTIFICATION_STOP;
 
typedef struct _XACT_NOTIFICATION_MARKER {

    BYTE    bData[XACT_SIZEOF_MARKER_DATA];

} XACT_NOTIFICATION_MARKER, *PXACT_NOTIFICATION_MARKER, *LPXACT_NOTIFICATION_MARKER;

union XACT_NOTIFICATION_UNION {

    XACT_NOTIFICATION_START Start;
    XACT_NOTIFICATION_STOP Stop;
    XACT_NOTIFICATION_MARKER Marker;

}; 

typedef struct _XACT_NOTIFICATION_DESCRIPTION{
    
    DWORD            dwType;
    PXACTSOUNDBANK   pSoundBank;
    PXACTSOUNDCUE    pSoundCue;	
	DWORD			 dwSoundCueIndex;
    PVOID            pvContext;
	HANDLE			 hEvent;

} XACT_NOTIFICATION_DESCRIPTION, *PXACT_NOTIFICATION_DESCRIPTION, *LPXACT_NOTIFICATION_DESCRIPTION;

typedef struct _XACT_NOTIFICATION{
    

    XACT_NOTIFICATION_DESCRIPTION	Header;
    XACT_NOTIFICATION_UNION			Data;
    REFERENCE_TIME					rtTimeStamp;

} XACT_NOTIFICATION, *PXACT_NOTIFICATION, *LPXACT_NOTIFICATION;        
 
typedef struct _XACT_RUNTIME_PARAMETERS {
    DWORD dwMax2DHwVoices;
    DWORD dwMax3DHwVoices;
    DWORD dwMaxConcurrentStreams;
    PVOID pvHeap;
    DWORD dwHeapSize;
} XACT_RUNTIME_PARAMETERS, *PXACT_RUNTIME_PARAMETERS, *LPXACT_RUNTIME_PARAMETERS;

//
// constants
//

#define XACT_FLAG_SOUNDSOURCE_2D            0x00000001
#define XACT_FLAG_SOUNDSOURCE_3D            0x00000002
#define XACT_MASK_SOUNDSOURCE_FLAGS         (XACT_FLAG_SOUNDSOURCE_3D | XACT_FLAG_SOUNDSOURCE_2D)

#define XACT_FLAG_SOUNDCUE_AUTORELEASE			0x00000001
#define XACT_FLAG_SOUNDCUE_SYNCHRONOUS          0x10000000

#define XACT_SOUNDCUE_INDEX_UNUSED				0xFFFFFFFF
#define XACT_TRACK_INDEX_UNUSED	    			0xFFFFFFFF

//
// API definitions
//

//
// IXACTEngine
//

STDAPI XACTEngineCreate(PXACTENGINE *ppEngine, PXACT_RUNTIME_PARAMETERS pParams);
STDAPI_(void) XACTEngineDoWork(void);

STDAPI_(ULONG) IXACTEngine_AddRef(PXACTENGINE pEngine);
STDAPI_(ULONG) IXACTEngine_Release(PXACTENGINE pEngine);
STDAPI IXACTEngine_LoadDspImage(PXACTENGINE pEngine, PVOID pvData, DWORD dwSize, LPCDSEFFECTIMAGELOC pEffectLoc);
STDAPI IXACTEngine_CreateSoundSource(PXACTENGINE pEngine, DWORD dwFlags, PXACTSOUNDSOURCE *ppSoundSource);
STDAPI IXACTEngine_CreateSoundBank(PXACTENGINE pEngine, PVOID pvData, DWORD dwSize, PXACTSOUNDBANK *ppSoundBank);
STDAPI IXACTEngine_RegisterWaveBank(PXACTENGINE pEngine, PVOID pvData, DWORD dwSize, PXACTWAVEBANK * ppWaveBank);
STDAPI IXACTEngine_RegisterStreamedWaveBank(PXACTENGINE pEngine, PVOID pvStreamingBuffer, DWORD dwSize, HANDLE hFile, DWORD dwOffset, PXACTWAVEBANK *ppWaveBank);
STDAPI IXACTEngine_UnRegisterWaveBank(PXACTENGINE pEngine, PXACTWAVEBANK pWaveBank);
STDAPI IXACTEngine_SetMasterVolume(PXACTENGINE pEngine, LONG lVolume);
STDAPI IXACTEngine_SetListenerParameters(PXACTENGINE pEngine, LPCDS3DLISTENER pcDs3dListener, LPCDSI3DL2LISTENER pds3dl, DWORD dwApply);
STDAPI IXACTEngine_GlobalPause(PXACTENGINE pEngine, BOOL bPause);
STDAPI IXACTEngine_RegisterNotification(PXACTENGINE pEngine, PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc);
STDAPI IXACTEngine_UnRegisterNotification(PXACTENGINE pEngine, PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc);
STDAPI IXACTEngine_GetNotification(PXACTENGINE pEngine, PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc, PXACT_NOTIFICATION pNotification);
STDAPI IXACTEngine_FlushNotification(PXACTENGINE pEngine, PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc);
STDAPI IXACTEngine_CommitDeferredSettings(PXACTENGINE pEngine);
//@@BEGIN_MSINTERNAL
STDAPI IXACTEngine_ScheduleEvent(PXACTENGINE pEngine, XACT_TRACK_EVENT *pEventDesc, PXACTSOUNDCUE pSoundCue, DWORD dwTrackIndex);
//@@END_MSINTERNAL

#if defined(__cplusplus) && !defined(CINTERFACE)

struct IXACTEngine
{

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IXACTEngine_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IXACTEngine_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE LoadDspImage(PVOID pvData, DWORD dwSize, LPCDSEFFECTIMAGELOC pEffectLoc)
    {
        return IXACTEngine_LoadDspImage(this, pvData, dwSize, pEffectLoc);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateSoundSource(DWORD dwFlags,PXACTSOUNDSOURCE *ppSoundSource)
    {
        return IXACTEngine_CreateSoundSource(this, dwFlags, ppSoundSource);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateSoundBank(PVOID pvData, DWORD dwSize, PXACTSOUNDBANK *ppSoundBank)
    {
        return IXACTEngine_CreateSoundBank(this, pvData, dwSize, ppSoundBank);
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterWaveBank(PVOID pvData, DWORD dwSize, PXACTWAVEBANK *ppWaveBank)
    {
        return IXACTEngine_RegisterWaveBank(this, pvData, dwSize, ppWaveBank);
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterStreamedWaveBank(PVOID pvStreamingBuffer, DWORD dwSize, HANDLE hFile, DWORD dwOffset, PXACTWAVEBANK *ppWaveBank)
    {
        return IXACTEngine_RegisterStreamedWaveBank(this, pvStreamingBuffer, dwSize, hFile, dwOffset, ppWaveBank);
    }

    __inline HRESULT STDMETHODCALLTYPE UnRegisterWaveBank(PXACTWAVEBANK pWaveBank)
    {
        return IXACTEngine_UnRegisterWaveBank(this, pWaveBank);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMasterVolume(LONG lVolume)
    {
        return IXACTEngine_SetMasterVolume(this, lVolume);
    }

    __inline HRESULT STDMETHODCALLTYPE SetListenerParameters(LPCDS3DLISTENER pcDs3dListener, LPCDSI3DL2LISTENER pds3dl, DWORD dwApply)
	{
	    return IXACTEngine_SetListenerParameters(this, pcDs3dListener, pds3dl, dwApply);
	}

    __inline HRESULT STDMETHODCALLTYPE GlobalPause(BOOL bPause)
    {
        return IXACTEngine_GlobalPause(this,bPause);
    }

    __inline HRESULT STDMETHODCALLTYPE RegisterNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
    {
        return IXACTEngine_RegisterNotification(this, pNotificationDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE UnRegisterNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
    {
        return IXACTEngine_UnRegisterNotification(this, pNotificationDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE GetNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc, PXACT_NOTIFICATION pNotification)
    {
        return IXACTEngine_GetNotification(this, pNotificationDesc, pNotification);
    }

    __inline HRESULT STDMETHODCALLTYPE FlushNotification(PXACT_NOTIFICATION_DESCRIPTION pNotificationDesc)
    {
        return IXACTEngine_FlushNotification(this, pNotificationDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE CommitDeferredSettings(void)
    {
        return IXACTEngine_CommitDeferredSettings(this);
    }

//@@BEGIN_MSINTERNAL
    __inline HRESULT STDMETHODCALLTYPE ScheduleEvent(XACT_TRACK_EVENT *pEventDesc, PXACTSOUNDCUE pSoundCue, DWORD dwTrackIndex)
	{
        return IXACTEngine_ScheduleEvent(this, pEventDesc, pSoundCue, dwTrackIndex);
	}
//@@END_MSINTERNAL

};

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// IXACTSoundSource
//

STDAPI_(ULONG) IXACTSoundSource_AddRef(PXACTSOUNDSOURCE pSoundSource);
STDAPI_(ULONG) IXACTSoundSource_Release(PXACTSOUNDSOURCE pSoundSource);
STDAPI IXACTSoundSource_SetPosition(PXACTSOUNDSOURCE pSoundSource, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IXACTSoundSource_SetAllParameters(PXACTSOUNDSOURCE pSoundSource, LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply);
STDAPI IXACTSoundSource_SetConeOrientation(PXACTSOUNDSOURCE pSoundSource,FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IXACTSoundSource_SetI3DL2Source(PXACTSOUNDSOURCE pSoundSource,LPCDSI3DL2BUFFER pds3db, DWORD dwApply);
STDAPI IXACTSoundSource_SetVelocity(PXACTSOUNDSOURCE pSoundSource,FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IXACTSoundSource_SetMixBins(PXACTSOUNDSOURCE pSoundSource, LPCDSMIXBINS pMixBins);
STDAPI IXACTSoundSource_SetMixBinVolumes(PXACTSOUNDSOURCE pSoundSource, LPCDSMIXBINS pMixBins);

#if defined(__cplusplus) && !defined(CINTERFACE)

struct IXACTSoundSource
{

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IXACTSoundSource_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IXACTSoundSource_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPosition( FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IXACTSoundSource_SetPosition(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply)
    {
        return IXACTSoundSource_SetAllParameters(this, pcDs3dBuffer, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IXACTSoundSource_SetConeOrientation(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwApply)
    {
        return IXACTSoundSource_SetI3DL2Source(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IXACTSoundSource_SetVelocity(this, x,  y,  z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBins(LPCDSMIXBINS pMixBins)
    {
        return IXACTSoundSource_SetMixBins(this, pMixBins);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBinVolumes(LPCDSMIXBINS pMixBins)
    {
        return IXACTSoundSource_SetMixBinVolumes(this, pMixBins);
    }

};

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// IXACTSoundBank
//

STDAPI_(ULONG) IXACTSoundBank_AddRef(PXACTSOUNDBANK pBank);
STDAPI_(ULONG) IXACTSoundBank_Release(PXACTSOUNDBANK pBank);
STDAPI IXACTSoundBank_GetSoundCueIndexFromFriendlyName(PXACTSOUNDBANK pBank, LPCSTR lpFriendlyName, PDWORD pdwSoundCueIndex);
STDAPI IXACTSoundBank_Play(PXACTSOUNDBANK pBank, DWORD dwSoundCueIndex, PXACTSOUNDSOURCE pSoundSource, DWORD dwFlags, PXACTSOUNDCUE *ppSoundCue);
STDAPI IXACTSoundBank_Stop(PXACTSOUNDBANK pBank, DWORD dwSoundCueIndex, DWORD dwFlags, PXACTSOUNDCUE pSoundCue);
STDAPI IXACTSoundBank_SetSliderValue(PXACTSOUNDBANK pBank, DWORD dwSoundCueIndex, DWORD dwSliderIndex, PVOID pvValue);

#if defined(__cplusplus) && !defined(CINTERFACE)

struct IXACTSoundBank
{

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IXACTSoundBank_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IXACTSoundBank_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSoundCueIndexFromFriendlyName(LPCSTR lpFriendlyName, PDWORD pdwSoundCueIndex)
    {
        return IXACTSoundBank_GetSoundCueIndexFromFriendlyName(this, lpFriendlyName, pdwSoundCueIndex);
    }

    __inline HRESULT STDMETHODCALLTYPE Play( DWORD dwSoundCueIndex, PXACTSOUNDSOURCE pSoundSource, DWORD dwFlags, PXACTSOUNDCUE *ppSoundCue)
    {
        return IXACTSoundBank_Play(this, dwSoundCueIndex, pSoundSource, dwFlags, ppSoundCue);
    }

    __inline HRESULT STDMETHODCALLTYPE Stop( DWORD dwSoundCueIndex, DWORD dwFlags, PXACTSOUNDCUE pSoundCue)
    {
        return IXACTSoundBank_Stop(this, dwSoundCueIndex, dwFlags, pSoundCue);
    }

    __inline HRESULT STDMETHODCALLTYPE SetSliderValue(DWORD dwSoundCueIndex, DWORD dwSliderIndex, PVOID pvValue)
    {
        return IXACTSoundBank_SetSliderValue(this, dwSoundCueIndex, dwSliderIndex, pvValue);
    }

};

#endif // defined(__cplusplus) && !defined(CINTERFACE)


//@@BEGIN_MSINTERNAL

#define XACT_SOUNDBANK_HEADER_FRIENDLYNAME_LENGTH 16
#define XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH 16
#define XACT_SOUNDBANK_WAVEBANK_FRIENDLYNAME_LENGTH 16

#define XACT_SOUNDBANK_HEADER_SIGNATURE        'KBDS'
#define XACT_SOUNDBANK_HEADER_VERSION          1

typedef struct _XACT_SOUNDBANK_FILE_HEADER{

    DWORD    dwSignature;
    DWORD    dwVersion;
    DWORD    dwFlags;
    DWORD    dwSoundEntryCount;                 // Number of entries in the bank
    DWORD    dwCueEntryCount;                   // Number of cues in the bank;
    CHAR     szFriendlyName[XACT_SOUNDBANK_HEADER_FRIENDLYNAME_LENGTH];   // friendly name

} XACT_SOUNDBANK_FILE_HEADER, *PXACT_SOUNDBANK_FILE_HEADER, *LPXACT_SOUNDBANK_FILE_HEADER; 


//
// content flags defining CU behavior
//

#define XACT_FLAG_CUE_ENTRY_QUEUE     		0x00000001
#define XACT_FLAG_CUE_ENTRY_CROSSFADE 		0x00000002

//
// table of N cue entries follows the header
//

typedef struct _XACT_SOUNDBANK_CUE_ENTRY{

    DWORD    dwFlags;
    DWORD    dwSoundIndex;
    CHAR     szFriendlyName[XACT_SOUNDBANK_CUE_FRIENDLYNAME_LENGTH];

} XACT_SOUNDBANK_CUE_ENTRY, *PXACT_SOUNDBANK_CUE_ENTRY, *LPXACT_SOUNDBANK_CUE_ENTRY; 


#define XACT_FLAG_SOUND_3D              0x00000001
#define XACT_FLAG_SOUND_FXMULTIPASS     0x00000002

#define XACTMIXBINVOLUMEPAIR DSMIXBINVOLUMEPAIR

//
// table of N sound entries follows the cue table
//

typedef struct _XACT_SOUNDBANK_SOUND_ENTRY{

    DWORD					dwFlags;
    DWORD					dw3DParametersOffset;
    DWORD					dwTrackTableOffset;
    DWORD					dwWaveBankTableOffset;    
	WORD					wPriority;
	WORD					wLayer;
    WORD					wGroupNumber;
    WORD					wTrackCount;
    WORD					wWaveBankCount;
	WORD					wSliderCount;

} XACT_SOUNDBANK_SOUND_ENTRY, *PXACT_SOUNDBANK_SOUND_ENTRY, *LPXACT_SOUNDBANK_SOUND_ENTRY; 

//
// 3d parameters data structure that can optionally be associated with a sound
//

typedef struct _XACT_SOUNDBANK_SOUND_3D_PARAMETERS {

    XACTMIXBINVOLUMEPAIR	aVolumePair;	// volume for 8th mixbin on a 3d destination
    DWORD    dwInsideConeAngle;      // Buffer inside cone angle
    DWORD    dwOutsideConeAngle;     // Buffer outside cone angle
    LONG     lConeOutsideVolume;     // Volume outside the cone
    FLOAT    flMinDistance;          // Minimum distance value
    FLOAT    flMaxDistance;          // Maximum distance value
    DWORD    dwMode;                 // 3D processing mode
    FLOAT    flDistanceFactor;       // Distance factor
    FLOAT    flRolloffFactor;        // Rolloff factor
    FLOAT    flDopplerFactor;        // Doppler factor
    DWORD    dwDataEntryCount;       // number of custom rollof data points
    
    //
    // array of FLOATs immediately following if dwTableEntryCount != 0
    //

} XACT_SOUNDBANK_SOUND_3D_PARAMETERS, *PXACT_SOUNDBANK_SOUND_3D_PARAMETERS;


//
// wave banks are associated with a sound through a table. This is because the same wave bank
// can be re-used by multiple sounds so we need something like a handle table to abstract in-between
//
// the table of wavebank offsets follows the sound entry table
//

typedef struct _XACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY {

    CHAR  szFriendlyName[XACT_SOUNDBANK_WAVEBANK_FRIENDLYNAME_LENGTH];
    DWORD dwDataOffset;

} XACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY, *PXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY, *LPXACT_SOUNDBANK_WAVEBANK_TABLE_ENTRY;

//
// the track table is the array of track entries and follows the wavebank entry table
//

typedef struct _XACT_SOUNDBANK_TRACK_ENTRY {

    WORD wFlags;
    WORD wEventEntryCount;
    DWORD dwEventDataOffset;

} XACT_SOUNDBANK_TRACK_ENTRY, *PXACT_SOUNDBANK_TRACK_ENTRY, *LPXACT_SOUNDBANK_TRACK_ENTRY;

//
// slider data types
//

//
// the slider table is the array of slider entries and follows the track entry table
//

typedef struct _XACT_SOUNDBANK_SLIDER_ENTRY {
	WORD wNumHwParameters;
	WORD wSoundIndex;
	WORD wTrackIndex;
	WORD wReserved;
	DWORD dwMappingTableOffset;
} XACT_SOUNDBANK_SLIDER_ENTRY, *PXACT_SOUNDBANK_SLIDER_ENTRY, *LPXACT_SOUNDBANK_SLIDER_ENTRY;

//
// after the table of slider entries, there is a list of tables of mapping entries.
// each slider points to a table of mapping entry offsets. This way multiple mappings
// can be re-used by different sliders
//

typedef struct _XACT_SLIDER_MAPPING_TABLE_ENTRY {
	DWORD dwDataOffset;
} XACT_SLIDER_MAPPING_TABLE_ENTRY, *PXACT_SLIDER_MAPPING_TABLE_ENTRY, *LPXACT_SLIDER_MAPPING_TABLE_ENTRY;

//
// a slider mapping entry identifies the hw parameter associated with the slider
// and has a N point table of values (the mapping function). The values are of the native
// format of the hw parameter
//

typedef struct _XACT_SLIDER_MAPPING_ENTRY {
	WORD wParameterId;
	WORD wElementCount;
	DWORD dwData[1];

} XACT_SLIDER_MAPPING_ENTRY, *PXACT_SLIDER_MAPPING_ENTRY, *LPXACT_SLIDER_MAPPING_ENTRY;

//
// each track entry points to an array of variable length event entries. the events for all tracks follow
// the slider table
//

//
// Sequencer events
//

#define XACT_FLAG_EVENT_RUNTIME 	    0x00000001
#define XACT_FLAG_EVENT_USES_FXIN   	0x00000002

typedef struct _XACT_TRACK_EVENT_HEADER {

    WORD	wType;	
    WORD	wSize;
	DWORD	dwFlags;    
	ULONG	lSampleTime;

} XACT_TRACK_EVENT_HEADER, *PXACT_TRACK_EVENT_HEADER, *LPXACT_TRACK_EVENT_HEADER;

//
// Structures and types
//

typedef enum _XACT_TRACK_EVENT_TYPES {

    eXACTEvent_Play = 0,
	eXACTEvent_PlayWithPitchAndVolumeVariation, 
    eXACTEvent_Stop,
	eXACTEvent_PitchAndVolumeVariation,
	eXACTEvent_SetFrequency,
	eXACTEvent_SetVolume,
	eXACTEvent_SetHeadroom,
	eXACTEvent_SetLFO,
	eXACTEvent_SetEG,
	eXACTEvent_SetFilter,
	eXACTEvent_Marker,
	eXACTEvent_LoopStart,
	eXACTEvent_LoopEnd,
	eXACTEvent_SetMixBinVolumes,

	//
	// global events
	//

	eXACTEvent_SetEffectData,
	eXACTEvent_Max

} XACT_TRACK_EVENT_TYPES;

typedef struct _XACT_TRACK_EVENT_MARKER {

	BYTE	bData[XACT_SIZEOF_MARKER_DATA];

} XACT_TRACK_EVENT_MARKER, *PXACT_TRACK_EVENT_MARKER, *LPXACT_TRACK_EVENT_MARKER;

typedef struct _XACT_TRACK_EVENT_SETEFFECTDATA {

    WORD	wEffectIndex;
    WORD	wOffset;    
	WORD	wDataSize;
	WORD    wReserved;
	DWORD   dwData[1];

} XACT_TRACK_EVENT_SETEFFECTDATA, *PXACT_TRACK_EVENT_SETEFFECTDATA, *LPXACT_TRACK_EVENT_SETEFFECTDATA;

typedef struct _XACT_TRACK_EVENT_SETFILTER {

    DSFILTERDESC Desc;
    
} XACT_TRACK_EVENT_SETFILTER, *PXACT_TRACK_EVENT_SETFILTER, *LPXACT_TRACK_EVENT_SETFILTER;


typedef struct _XACT_TRACK_EVENT_SETEG {

    DSENVELOPEDESC Desc;
    
} XACT_TRACK_EVENT_SETEG, *PXACT_TRACK_EVENT_SETEG, *LPXACT_TRACK_EVENT_SETEG;

typedef struct _XACT_TRACK_EVENT_SETLFO {

    DSLFODESC Desc;
    
} XACT_TRACK_EVENT_SETLFO, *PXACT_TRACK_EVENT_SETLFO, *LPXACT_TRACK_EVENT_SETLFO;

typedef struct _XACT_TRACK_EVENT_SETHEADROOM {

    WORD wHeadroom;
    
} XACT_TRACK_EVENT_SETHEADROOM, *PXACT_TRACK_EVENT_SETHEADROOM, *LPXACT_TRACK_EVENT_SETHEADROOM;

typedef struct _XACT_TRACK_EVENT_SETVOLUME {

    SHORT sVolume;
    
} XACT_TRACK_EVENT_SETVOLUME, *PXACT_TRACK_EVENT_SETVOLUME, *LPXACT_TRACK_EVENT_SETVOLUME;

typedef struct _XACT_TRACK_EVENT_SETMIXBINVOLUMES {

	DWORD	dwCount;
    XACTMIXBINVOLUMEPAIR aVolumePairs[8];
    
} XACT_TRACK_EVENT_SETMIXBINVOLUMES, *PXACT_TRACK_EVENT_SETMIXBINVOLUMES, *LPXACT_TRACK_EVENT_SETMIXBINVOLUMES;

typedef struct _XACT_TRACK_EVENT_SETFREQUENCY {

    WORD wFrequency;
    
} XACT_TRACK_EVENT_SETFREQUENCY, *PXACT_TRACK_EVENT_SETFREQUENCY, *LPXACT_TRACK_EVENT_SETFREQUENCY;
 
typedef struct _XACT_TRACK_EVENT_STOP {
    
    
} XACT_TRACK_EVENT_STOP, *PXACT_TRACK_EVENT_STOP, *LPXACT_TRACK_EVENT_STOP;

typedef union XACT_EVENT_PLAY_DESC {

    struct {
        WORD wWaveIndex;
        WORD wBankIndex;
    } WaveSource;

    struct {
        DWORD dwMixBin;
    } EffectSource;

} XACT_EVENT_PLAY_DESC, *PXACT_EVENT_PLAY_DESC, *LPXACT_EVENT_PLAY_DESC;
 
typedef struct _XACT_TRACK_EVENT_PLAY {

	XACT_EVENT_PLAY_DESC PlayDesc;

} XACT_TRACK_EVENT_PLAY, *PXACT_TRACK_EVENT_PLAY, *LPXACT_TRACK_EVENT_PLAY;

typedef struct _XACT_EVENT_PITCH_VOLUME_VAR_DESC {

	struct {
		SHORT sPitchLo;
		SHORT sPitchHi;
	} Pitch;

	struct {
		SHORT sVolLo;
		SHORT sVolHi;
	} Volume;

} XACT_EVENT_PITCH_VOLUME_VAR_DESC, *PXACT_EVENT_PITCH_VOLUME_VAR_DESC, *LPXACT_EVENT_PITCH_VOLUME_VAR_DESC;

typedef struct _XACT_TRACK_EVENT_PITCH_VOLUME_VAR {

    XACT_EVENT_PITCH_VOLUME_VAR_DESC VarDesc;

} XACT_TRACK_EVENT_PITCH_VOLUME_VAR, *PXACT_TRACK_EVENT_PITCH_VOLUME_VAR, *LPXACT_TRACK_EVENT_PITCH_VOLUME_VAR;

typedef struct _XACT_TRACK_EVENT_PLAY_WITH_PITCH_VOLUME_VAR {

    XACT_EVENT_PLAY_DESC				PlayDesc;
	XACT_EVENT_PITCH_VOLUME_VAR_DESC	VarDesc;

} XACT_TRACK_EVENT_PLAY_WITH_PITCH_VOLUME_VAR, *PXACT_TRACK_EVENT_PLAY_WITH_PITCH_VOLUME_VAR, *LPXACT_TRACK_EVENT_PLAY_WITH_PITCH_VOLUME_VAR;

typedef struct _XACT_TRACK_EVENT_LOOPSTART {

	WORD	wLoopCount;

} XACT_TRACK_EVENT_LOOPSTART, *PXACT_TRACK_EVENT_LOOPSTART, *LPXACT_TRACK_EVENT_LOOPSTART;

typedef struct _XACT_TRACK_EVENT_LOOPEND {

} XACT_TRACK_EVENT_LOOPEND, *PXACT_TRACK_EVENT_LOOPEND, *LPXACT_TRACK_EVENT_LOOPEND;

union XACT_TRACK_EVENT_UNION {
    XACT_TRACK_EVENT_PLAY							Play;
	XACT_TRACK_EVENT_PLAY_WITH_PITCH_VOLUME_VAR		PlayWithPitchAndVolumeVariation;
    XACT_TRACK_EVENT_STOP							Stop;
	XACT_TRACK_EVENT_PITCH_VOLUME_VAR				PitchAndVolumeVariation;
	XACT_TRACK_EVENT_SETFREQUENCY					SetFrequency;
	XACT_TRACK_EVENT_SETVOLUME						SetVolume;
	XACT_TRACK_EVENT_SETHEADROOM					SetHeadroom;
	XACT_TRACK_EVENT_SETLFO							SetLFO;
	XACT_TRACK_EVENT_SETEG							SetEG;
	XACT_TRACK_EVENT_SETFILTER						SetFilter;
	XACT_TRACK_EVENT_SETEFFECTDATA					SetEffectData;
	XACT_TRACK_EVENT_MARKER							Marker;
	XACT_TRACK_EVENT_LOOPSTART						LoopStart;
	XACT_TRACK_EVENT_LOOPEND						LoopEnd;
	XACT_TRACK_EVENT_SETMIXBINVOLUMES				SetMixBinVolumes;
	
};

struct XACT_TRACK_EVENT {

    XACT_TRACK_EVENT_HEADER Header;
    XACT_TRACK_EVENT_UNION EventData;

};

//@@END_MSINTERNAL



#endif // __XACT_ENGINE INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xboxp.h ===
//
// All APIs unique to Xbox that live in XAPILIB.LIB should be
// defined in this header file
//

#ifndef _XBOXP_
#define _XBOXP_

#define XBOXAPI

#ifdef __cplusplus
extern "C" {
#endif	
#define MAX_SONG_NAME       32
#define MAX_SOUNDTRACK_NAME 32
#define MAX_SOUNDTRACKS     100
#define MAX_SONGS_IN_SNDTRK 500

#define MAX_SONGS                   500 // obsolete - replaced by public constant: MAX_SONGS_IN_SNDTRK
#define WMADESC_LIST_SIZE           6
#define STDB_VERSION                1
#define STDB_STSIG                  0x021371
#define STDB_LISTSIG                0x031073
#define STDB_PAGE_SIZE              512
#define INVALID_STID                0xFFFFFFFF

typedef struct {

    UINT    Version;
    UINT    StCount;
    UINT    NextStId;
    UINT    StBlocks[MAX_SOUNDTRACKS];
    UINT    NextSongId;



} STDB_HDR, *PSTDB_HDR;

typedef struct {

    UINT    Signature;
    UINT    Id;
    UINT    SongCount;
    UINT    ListBlocks[(MAX_SONGS_IN_SNDTRK / WMADESC_LIST_SIZE) + 1];
    UINT    SoundtrackLength;
    WCHAR   Name[MAX_SOUNDTRACK_NAME];

} STDB_STDESC, *PSTDB_STDESC;


typedef struct {

    DWORD Signature;
    UINT  StId;
    UINT  ListIndex;
    BOOL  InUse;
    DWORD SongIds[WMADESC_LIST_SIZE];
    DWORD SongLengths[WMADESC_LIST_SIZE];
    WCHAR SongNames[WMADESC_LIST_SIZE][MAX_SONG_NAME];



} STDB_LIST, *PSTDB_LIST;

typedef enum _XC_VALUE_INDEX
{
    XC_TIMEZONE_BIAS = 0,
    XC_TZ_STD_NAME,
    XC_TZ_STD_DATE,
    XC_TZ_STD_BIAS,
    XC_TZ_DLT_NAME,
    XC_TZ_DLT_DATE,
    XC_TZ_DLT_BIAS,
    XC_LANGUAGE,
    XC_VIDEO_FLAGS,
    XC_AUDIO_FLAGS,
    XC_PARENTAL_CONTROL_GAMES,
    XC_PARENTAL_CONTROL_PASSWORD,
    XC_PARENTAL_CONTROL_MOVIES,
    XC_ONLINE_IP_ADDRESS,
    XC_ONLINE_DNS_ADDRESS,
    XC_ONLINE_DEFAULT_GATEWAY_ADDRESS,
    XC_ONLINE_SUBNET_ADDRESS,
    XC_MISC_FLAGS,
    XC_DVD_REGION,

    // end of user configurations
    XC_MAX_OS = 0xff,

    // start of factory settings
    XC_FACTORY_START_INDEX,
    XC_FACTORY_SERIAL_NUMBER = XC_FACTORY_START_INDEX,
    XC_FACTORY_ETHERNET_ADDR,
    XC_FACTORY_ONLINE_KEY,
    XC_FACTORY_AV_REGION,
    XC_FACTORY_GAME_REGION,

    // end of factory settings
    XC_MAX_FACTORY = 0x1ff,

    // special value to access the encryption section of the EEPROM
    // or to access the entire EEPROM at once
    XC_ENCRYPTED_SECTION = 0xfffe,
    XC_MAX_ALL = 0xffff

} XC_VALUE_INDEX;


#define XC_LANGUAGE_UNKNOWN         0
#define XC_AV_PACK_NONE             7
#define XC_VIDEO_STANDARD_PAL_M     4
#define XC_GAME_REGION_NA             0x00000001
#define XC_GAME_REGION_JAPAN          0x00000002
#define XC_GAME_REGION_RESTOFWORLD    0x00000004
#define XC_GAME_REGION_MANUFACTURING  0x80000000

#define XC_MISC_FLAG_AUTOPOWERDOWN  0x0001
#define XC_MISC_FLAG_DONT_USE_DST   0x0002

//
// Config value routines specifically for OS config sector
//
XBOXAPI
DWORD
WINAPI
XSetValue(
    IN ULONG ulValueIndex,
    IN ULONG ulType,
    IN PVOID pValue,
    IN ULONG cbValueLength
    );

XBOXAPI
DWORD
WINAPI
XQueryValue(
    IN ULONG ulValueIndex,
    OUT PULONG pulType,
    OUT PVOID pValue,
    IN ULONG cbValueLength,
    OUT PULONG pcbResultLength
    );

//
// HACK to simulate XInput APIs using another machine on the network
//
#ifdef _XINPUT_REMOTE
#define XInitDevices                    XInitDevicesRM
#define XGetDevices                     XGetDevicesRM
#define XGetDeviceChanges               XGetDeviceChangesRM
#define XInputOpen                      XInputOpenRM
#define XInputClose                     XInputCloseRM
#define XInputGetState                  XInputGetStateRM
#define XInputPoll                      XInputPollRM
#define XInputSetState                  XInputSetStateRM
#define XInputGetCapabilities           XInputGetCapabilitiesRM
#define XMountMUA                       XMountMUARM
#define XUnmountMU                      XUnmountMURM
#define XMUPortFromDriveLetterA         XMUPortFromDriveLetterARM
#define XMUSlotFromDriveLetterA         XMUSlotFromDriveLetterARM
#define XInputDebugInitKeyboardQueue    XInputDebugInitKeyboardQueueRM
#define XInputDebugGetKeystroke         XInputDebugGetKeystrokeRM
#endif // _XINPUT_REMOTE

#ifdef _XBOX_ //only define this if xbox.h was already included.
extern XPP_DEVICE_TYPE XDEVICE_TYPE_IR_REMOTE_TABLE;
#define  XDEVICE_TYPE_IR_REMOTE       (&XDEVICE_TYPE_IR_REMOTE_TABLE)
extern   XPP_DEVICE_TYPE XDEVICE_TYPE_DVD_CODE_SERVER_TABLE;
#define  XDEVICE_TYPE_DVD_CODE_SERVER (&XDEVICE_TYPE_DVD_CODE_SERVER_TABLE)
#endif
extern BOOL XPP_XInitDevicesHasBeenCalled;

#ifdef _XBOX_ //only define this if xbox.h was already included.
XBOXAPI
DWORD
WINAPI
XPeekDevices(
    IN  PXPP_DEVICE_TYPE DeviceType,
    IN  OUT PDWORD pLastGotten,
    IN  OUT PDWORD pStale
    );
#endif

#ifdef _XBOX_
typedef struct _XINPUT_IR_REMOTE
{
    WORD  wKeyCode;
    WORD  wTimeDelta;
} XINPUT_IR_REMOTE, *PXINPUT_IR_REMOTE;

typedef struct _XINPUT_STATE_INTERNAL
{
    DWORD dwPacketNumber;
    union
    {
        XINPUT_GAMEPAD   Gamepad;
        XINPUT_IR_REMOTE IrRemote;
    };
} XINPUT_STATE_INTERNAL, *PXINPUT_STATE_INTERNAL;
#endif

XBOXAPI
DWORD
WINAPI
XMountMURootA(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT PCHAR pchDrive
    );
#define XMountMURoot XMountMURootA


XBOXAPI
DWORD
WINAPI
XMUNameFromPortSlot(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT LPWSTR lpName,
    IN UINT cchName
    );

XBOXAPI
DWORD
WINAPI
XReadMUMetaData(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN LPVOID lpBuffer,
    IN DWORD dwByteOffset,
    IN DWORD dwNumberOfBytesToRead
    );

XBOXAPI
DWORD
WINAPI
XMUWriteNameToDriveLetter(
    IN CHAR chDrive,
    IN LPCWSTR lpName
    );

XBOXAPI
DWORD
WINAPI
XCleanMUFromRoot(
    IN CHAR chDrive,
    PCSTR pszPreserveDir OPTIONAL
    );

XBOXAPI
DWORD
WINAPI
XCleanDrive(
    IN CHAR chDrive
    );

#define XINIT_MOUNT_UTILITY_DRIVE   0x00000001
#define XINIT_FORMAT_UTILITY_DRIVE  0x00000002
#define XINIT_LIMIT_DEVKIT_MEMORY   0x00000004
#define XINIT_NO_SETUP_HARD_DISK    0x00000008
#define XINIT_DONT_MODIFY_HARD_DISK 0x00000010
#ifdef _XBOX_ //only define this if xbox.h was already included.
#include <pshpack1.h>
typedef struct _XDCS_DVD_CODE_INFORMATION
{
    WORD    bcdVersion;
    DWORD   dwCodeLength;
} XDCS_DVD_CODE_INFORMATION, *PXDCS_DVD_CODE_INFORMATION;
#include <poppack.h>

typedef struct _XDCS_ASYNC_DOWNLOAD_REQUEST
{
    DWORD  dwDeviceInstance;
    PVOID  pvBuffer;
    ULONG  ulOffset;
    ULONG  ulLength;
    ULONG  ulBytesRead;
    ULONG  ulStatus;
    HANDLE hCompleteEvent;
} XDCS_ASYNC_DOWNLOAD_REQUEST, *PXDCS_ASYNC_DOWNLOAD_REQUEST;

DWORD
WINAPI
XDCSGetInformation(
    IN  DWORD  dwPort,
    OUT PDWORD pdwDeviceInstance,
    OUT PXDCS_DVD_CODE_INFORMATION pDvdCodeInformation
    );

DWORD
WINAPI
XDCSDownloadCode(
    DWORD   dwDeviceInstance,
    PVOID   pvBuffer,
    ULONG   ulOffset,
    ULONG   ulLength,
    PULONG  pulBytesRead
    );

DWORD
WINAPI
XDCSDownloadCodeAsync(
    IN OUT PXDCS_ASYNC_DOWNLOAD_REQUEST pXDCSDownloadRequest
    );
#endif //_XBOX_


DWORD
WINAPI
XAutoPowerDownSet(
    BOOL fAutoPowerDown
    );

DWORD
WINAPI
XAutoPowerDownGet(
    BOOL *pfAutoPowerDown
    );

void
WINAPI
XAutoPowerDownResetTimer();

#if DBG
void
WINAPI
XAutoPowerDownDebugSetTimeout(
    LONGLONG llTimeout
    );
#endif //DBG

BOOL
WINAPI
XapiSetLocalTime(
    IN CONST SYSTEMTIME *lpLocalTime
    );

DWORD
WINAPI
XapipQueryTimeZoneInformation(
    OUT PTIME_ZONE_INFORMATION TimeZoneInformation,
    OUT PBOOL pfUseDST
    );

DWORD
WINAPI
XapipSetTimeZoneInformation(
    IN PTIME_ZONE_INFORMATION TimeZoneInformation
    );

BOOL
WINAPI
XapipUseDaylightSavingTime();


#ifndef MAX_LAUNCH_DATA_SIZE
#define MAX_LAUNCH_DATA_SIZE 3072

typedef struct _LAUNCH_DATA
{
    BYTE Data[MAX_LAUNCH_DATA_SIZE];
} LAUNCH_DATA, *PLAUNCH_DATA;
#endif // ! MAX_LAUNCH_DATA_SIZE
#define XLD_LAUNCH_DASHBOARD_BOOT       5 // Not supported at this time

#define XLD_LAUNCH_DASHBOARD_NETWORK_CONFIGURATION	6
#define XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP         7 
#define XLD_LAUNCH_DASHBOARD_MESSAGE_SERVER_INFO        8
#define XLD_LAUNCH_DASHBOARD_POLICY_DOCUMENT            9
#define XLD_LAUNCH_DASHBOARD_ONLINE_MENU		10
#define XLD_LAUNCH_DASHBOARD_FORCED_NAME_CHANGE         11
#define XLD_LAUNCH_DASHBOARD_FORCED_BILLING_EDIT        12
//
// When the dwReason is XLD_LAUNCH_DASHBOARD_POLICY_DOCUMENT,
// LD_LAUNCH_DASHBOARD.dwParameter1 will have 1 or probably more of 
// the following flags set.
//
#define XLD_POLICY_SUBSCRIPTION_AGREEMENT 0x01
#define XLD_POLICY_TERMS_OF_USE           0x02
#define XLD_POLICY_CODE_OF_CONDUCT        0x04 
#define XLD_POLICY_PRIVACY_STATEMENT      0x08

typedef struct _LD_FROM_TITLE_UPDATE
{
    DWORD   dwContext;
    HRESULT hr;
    BYTE    Reserved[MAX_LAUNCH_DATA_SIZE - 8];
} LD_FROM_TITLE_UPDATE, *PLD_FROM_TITLE_UPDATE;

#define LDT_LAUNCH_DASHBOARD      1
#define LDT_TITLE_UPDATE          4
#define LDT_FROM_TITLE_UPDATE     6

XBOXAPI
DWORD
WINAPI
XWriteTitleInfoAndRebootA(
    IN LPCSTR pszLaunchPath,
    IN LPCSTR pszDDrivePath,
    IN DWORD dwLaunchDataType,
    IN DWORD dwTitleId,
    IN PLAUNCH_DATA pLaunchData
    );
#define XWriteTitleInfoAndReboot XWriteTitleInfoAndRebootA


//
// Register or deregister a notification routine
// which will be called when a thread is created or deleted.
//
// NOTE: The XTHREAD_NOTIFICATION structure must remain
// valid until the thread notification routine is deregistered.
// For example, you can use a global variable for this.
// But you should NOT use a local variable inside a function.
//
#ifdef __cplusplus
}
#endif
#endif  // _XBOXP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xdbg.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xdbg.h

Abstract:

    Internal debug header for XBox OS and library components
    
--*/


#ifndef _XDBG_H
#define _XDBG_H

#ifndef ASSERT
#if DBG
    #define ASSERT( exp ) \
        if (!(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, NULL )
#else  // DBG
    #define ASSERT( exp )
#endif // DBG
#endif // ! ASSERT

#ifndef ASSERTMSG
#if DBG
    #define ASSERTMSG( msg, exp ) \
        if (!(exp)) \
            RtlAssert( #exp, __FILE__, __LINE__, msg )
#else  // DBG
    #define ASSERTMSG( msg, exp )
#endif // DBG
#endif // ! ASSERTMSG

#if 0
#ifndef RIP
#if DBG
    #define RIP(msg)                         \
        do{ LPCSTR _ = (msg);                \
            _asm { mov eax, BREAKPOINT_RIP } \
            _asm { mov ecx, _ }              \
            _asm { int 2dh }                 \
            _asm { int 3 }                   \
        } while(0)

#else  // DBG
    #define RIP(msg) {}
#endif // DBG
#endif  // ! RIP

#ifndef RIP_ON_NOT_TRUE
#if DBG
    #define RIP_ON_NOT_TRUE(ApiName, Expression)  \
        do{                                       \
            if(!(Expression))                     \
            {                                     \
                UCHAR _[512];                     \ 
                _snprintf(_, sizeof(_), "%s: parameter check failed. (%s) was not true.\n", ApiName, #Expression);\
                _[511]='\0';                      \
                _asm { mov eax, BREAKPOINT_RIP }  \
                _asm { mov ecx, _ }               \
                _asm { int 2dh }                  \
                _asm { int 3 }                    \
            }                                     \
        }while(0)
#else  // DBG
#define RIP_ON_NOT_TRUE(ApiName, Expression)
#endif // DBG
#endif  // !RIP_ON_NOT_TRUE

#ifndef RIP_ON_NOT_TRUE_WITH_MESSAGE
#if DBG
    #define RIP_ON_NOT_TRUE_WITH_MESSAGE(Expression, Message)  \
    do{                                                        \
        if(!(Expression))                                      \
        {                                                      \
            RIP(Message);                                      \
        }                                                      \
    }while(0)                                   
#else  // DBG
    #define RIP_ON_NOT_TRUE_WITH_MESSAGE(Expression, Message)
#endif // DBG
#endif  // !RIP_ON_NOT_TRUE_WITH_MESSAGE
#endif // 0

#define XDBG_ERROR   1
#define XDBG_WARNING 2
#define XDBG_TRACE   3
#define XDBG_ENTRY   4
#define XDBG_EXIT    5

#ifndef XDBG_COMPILE_LEVEL
#define XDBG_COMPILE_LEVEL XDBG_WARNING
#endif // ! XDBG_COMPILE_LEVEL

#ifndef XDBGPRINT
#if DBG
#define XDBGPRINT XDebugPrint
#else  // DBG
#define XDBGPRINT 1 ? (void)0 : (void)
#endif // DBG
#endif // ! XDBGPRINT

#ifndef XDBGERR
#if DBG && (XDBG_COMPILE_LEVEL >= XDBG_ERROR)
#define XDBGERR XDebugError
#else  // DBG
#define XDBGERR 1 ? (void)0 : (void)
#endif // DBG
#endif // ! XDBGERR

#ifndef XDBGWRN
#if DBG && (XDBG_COMPILE_LEVEL >= XDBG_WARNING)
#define XDBGWRN XDebugWarning
#else  // DBG
#define XDBGWRN 1 ? (void)0 : (void)
#endif // DBG
#endif // ! XDBGWRN

#ifndef XDBGTRC
#if DBG && (XDBG_COMPILE_LEVEL >= XDBG_TRACE)
#define XDBGTRC XDebugTrace
#else  // DBG
#define XDBGTRC 1 ? (void)0 : (void)
#endif // DBG
#endif // ! XDBGTRC

#ifndef XDBGENT
#if DBG && (XDBG_COMPILE_LEVEL >= XDBG_ENTRY)
#define XDBGENT XDebugEntry
#else  // DBG
#define XDBGENT 1 ? (void)0 : (void)
#endif // DBG
#endif // ! XDBGENT

#ifndef XDBGEXT
#if DBG && (XDBG_COMPILE_LEVEL >= XDBG_EXIT)
#define XDBGEXT XDebugExit
#else  // DBG
#define XDBGEXT 1 ? (void)0 : (void)
#endif // DBG
#endif // ! XDBGEXT

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _NTSYSTEM_
#define XKERNELAPI
#else  // _NTSYSTEM_
#define XKERNELAPI     DECLSPEC_IMPORT
#endif // _NTSYSTEM_

#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define XDBGAPI      __stdcall
#define XDBGAPIV     __cdecl
#else
#define XDBGAPI
#define XDBGAPIV
#endif

XKERNELAPI
VOID
XDBGAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#if DBG
VOID
XDBGAPI
vXDebugPrint(
    ULONG Level,
    PCHAR Module,
    PCHAR Format,
    va_list arglist
    );

VOID
XDBGAPIV
XDebugPrint(
    ULONG Level,
    PCHAR Module,
    PCHAR Format,
    ...
    );

VOID
XDBGAPIV
XDebugError(
    PCHAR Module,
    PCHAR Format,
    ...
    );

VOID
XDBGAPIV
XDebugWarning(
    PCHAR Module,
    PCHAR Format,
    ...
    );

VOID
XDBGAPIV
XDebugTrace(
    PCHAR Module,
    PCHAR Format,
    ...
    );

VOID
XDBGAPIV
XDebugEntry(
    PCHAR Module,
    PCHAR Format,
    ...
    );

VOID
XDBGAPIV
XDebugExit(
    PCHAR Module,
    PCHAR Format,
    ...
    );
#endif // DBG

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _XDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xcabinet.h ===
// ---------------------------------------------------------------------------------------
// util.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __UTIL_H__
#define __UTIL_H__

// ---------------------------------------------------------------------------------------
// Includes
// ---------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include <xcrypt.h>

#ifdef __cplusplus
}
#endif

// ---------------------------------------------------------------------------------------

//
// Define the real RC4 SHA1 structures and functions
//
#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_SHA_HEADER {
    BYTE Checksum[XC_DIGEST_LEN];
    BYTE Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA_HEADER, *PRC4_SHA_HEADER;

//
// Define a structure that describes an extended CFFOLDER entry
// that also has an associated HMAC (per-folder reserved data)
//
typedef struct
{
	CFFOLDER		cffolder;		// CFFOLDER
	RC4_SHA_HEADER	hmac;			// RC4 SHA1 Hmac

} CFFOLDER_HMAC, *PCFFOLDER_HMAC;

//
// Define a union of all known CAB flags
//
#define cfhdrFLAGS_ALL	(cfhdrPREV_CABINET | \
						 cfhdrNEXT_CABINET | \
						 cfhdrRESERVE_PRESENT)

//
// Define our header cache structure
//
typedef struct 
{
	CFHEADER				cfheader;		// Cabinet file header
	CFRESERVE				cfreserve;		// Reserved data specification
	
	RC4_SHA_HEADER			digestFolders;	// CFFOLDERS digest
	RC4_SHA_HEADER			digestFiles;	// CFFILES digest
	
} XONLINECONTENT_HEADER, *PXONLINECONTENT_HEADER;


//
// Define sizes related to the fixed header
//
#define XONLINECONTENT_FIXED_HEADER_SIZE	\
			(sizeof(XONLINECONTENT_HEADER))

#define XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC	\
			(XONLINECONTENT_FIXED_HEADER_SIZE + \
			 sizeof(RC4_SHA_HEADER))

#define XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC_AND_CHECKPOINT	\
			(XONLINECONTENT_FIXED_HEADER_SIZE + \
			 sizeof(RC4_SHA_HEADER) + sizeof(DWORD))

#define XONLINECONTENT_COMPLETE_HEADER_SIZE	\
			(XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC_AND_CHECKPOINT + \
			 XONLINECONTENT_PK_SIGNATURE_SIZE)

#define XONLINECONTENT_CHECKPOINT	\
			(XONLINECONTENT_FIXED_HEADER_SIZE + \
			 sizeof(RC4_SHA_HEADER))

#define XONLINECONTENT_RESUME_MAX_READ_SIZE	\
			(XONLINECONTENT_COMPLETE_HEADER_SIZE + \
			 XONLINECONTENT_MAX_CFFOLDER * sizeof(CFFOLDER_HMAC))

//
// Define the maximum number of CFFOLDER entries allowed in a 
// content package
//
#define XONLINECONTENT_MAX_CFFOLDER			((DWORD)100)

//
// Define the size of a PK signature
//
#define XONLINECONTENT_PK_SIGNATURE_SIZE	256

//
// Define the max size of a public key
//
#define XONLINECONTENT_MAX_PUBLIC_KEY_SIZE	\
		(XONLINECONTENT_PK_SIGNATURE_SIZE + \
		 sizeof(BSAFE_PUB_KEY) + \
		 (sizeof(DWORD) * 4))


//
// Define the various reserve values
//
#define XONLINECONTENT_HEADER_RESERVE_SIZE	\
			((sizeof(RC4_SHA_HEADER) * 3) + sizeof(DWORD) + \
			 XONLINECONTENT_PK_SIGNATURE_SIZE)

#define XONLINECONTENT_PERFOLDER_RESERVE_SIZE	\
			(sizeof(RC4_SHA_HEADER))

//
// Define the smallest possible size for a content package
//
#define XONLINECONTENT_MIN_CONTENT_SIZE	\
			(sizeof(CFHEADER) + sizeof(CFRESERVE) + \
			 XONLINECONTENT_HEADER_RESERVE_SIZE)


//
// Define the name of the manifest file
//
#define XONLINECONTENT_MANIFEST_FILE_NAME			"manifest.xbx"

//
// Define the name of the special target manifest file
//
#define XONLINEAUTOUPD_TARGET_MANIFEST_FILE_NAME	"target.xbx"

//
// We deal with clusters a lot, so define the size of a cluster
//
#define XBOX_CLUSTER_SIZE							(1 << 14)

//
// Define a reasonable upper bound for the manifest size (1MB)
//
#define XONLINECONTENT_MANIFEST_MAX_FILE_SIZE		(1<<20)


// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xonlinep.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef __XONLINE__
#define __XONLINE__

#ifdef __cplusplus
extern "C" {
#endif

//@@BEGIN_MSINTERNAL
//@@BEGIN_CLIENTONLY
//@@END_MSINTERNAL

// ====================================================================
// XOnline Startup & Cleanup
//

typedef struct {

    DWORD           dwReserved;

} XONLINE_STARTUP_PARAMS, * PXONLINE_STARTUP_PARAMS;

XBOXAPI
HRESULT 
WINAPI 
XOnlineStartup(
    IN PXONLINE_STARTUP_PARAMS  pxosp
    );

XBOXAPI
HRESULT
WINAPI 
XOnlineCleanup();

//@@BEGIN_MSINTERNAL
//@@END_CLIENTONLY
//@@END_MSINTERNAL

// ====================================================================
// XOnline Error Codes
//

#define FACILITY_XONLINE            21

// Generic Errors
#define XONLINE_E_OVERFLOW                             _HRESULT_TYPEDEF_(0x80150001L)
#define XONLINE_E_NO_SESSION                           _HRESULT_TYPEDEF_(0x80150002L)
#define XONLINE_E_USER_NOT_LOGGED_ON                   _HRESULT_TYPEDEF_(0x80150003L)
#define XONLINE_E_NO_GUEST_ACCESS                      _HRESULT_TYPEDEF_(0x80150004L)
#define XONLINE_E_NOT_INITIALIZED                      _HRESULT_TYPEDEF_(0x80150005L)
#define XONLINE_E_NO_USER                              _HRESULT_TYPEDEF_(0x80150006L)
#define XONLINE_E_INTERNAL_ERROR                       _HRESULT_TYPEDEF_(0x80150007L)
#define XONLINE_E_OUT_OF_MEMORY                        _HRESULT_TYPEDEF_(0x80150008L)
#define XONLINE_E_TASK_BUSY		                       _HRESULT_TYPEDEF_(0x80150009L)
#define XONLINE_E_SERVER_ERROR	                       _HRESULT_TYPEDEF_(0x8015000AL)
#define XONLINE_E_IO_ERROR	                           _HRESULT_TYPEDEF_(0x8015000BL)
#define XONLINE_E_BAD_CONTENT_TYPE                     _HRESULT_TYPEDEF_(0x8015000CL)


// XOnlineLogon task successful return states
#define XONLINE_S_LOGON_CONNECTION_ESTABLISHED         _HRESULT_TYPEDEF_(0x00000002L)

// XOnlineLogon task failure return values
#define XONLINE_E_LOGON_NO_NETWORK_CONNECTION          _HRESULT_TYPEDEF_(0x80151001L)
#define XONLINE_E_LOGON_NO_IP_ADDRESS                  _HRESULT_TYPEDEF_(0x80151002L)
#define XONLINE_E_LOGON_NO_DNS_SERVICE                 _HRESULT_TYPEDEF_(0x80151003L)
#define XONLINE_E_LOGON_DNS_LOOKUP_FAILED              _HRESULT_TYPEDEF_(0x80151004L)
#define XONLINE_E_LOGON_DNS_LOOKUP_TIMEDOUT            _HRESULT_TYPEDEF_(0x80151005L)
#define XONLINE_E_LOGON_INVALID_XBOX_ONLINE_INFO       _HRESULT_TYPEDEF_(0x80151006L)
#define XONLINE_E_LOGON_MACS_FAILED                    _HRESULT_TYPEDEF_(0x80151007L)
#define XONLINE_E_LOGON_MACS_TIMEDOUT                  _HRESULT_TYPEDEF_(0x80151008L)
#define XONLINE_E_LOGON_AUTHENTICATION_FAILED          _HRESULT_TYPEDEF_(0x80151009L)
#define XONLINE_E_LOGON_AUTHENTICATION_TIMEDOUT        _HRESULT_TYPEDEF_(0x8015100AL)
#define XONLINE_E_LOGON_AUTHORIZATION_FAILED           _HRESULT_TYPEDEF_(0x8015100BL)
#define XONLINE_E_LOGON_AUTHORIZATION_TIMEDOUT         _HRESULT_TYPEDEF_(0x8015100CL)
#define XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID           _HRESULT_TYPEDEF_(0x8015100DL)
#define XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED            _HRESULT_TYPEDEF_(0x8015100EL)
#define XONLINE_E_LOGON_UPDATE_REQUIRED                _HRESULT_TYPEDEF_(0x8015100FL)
#define XONLINE_E_LOGON_SG_SERVICE_FAILED              _HRESULT_TYPEDEF_(0x80151010L)
#define XONLINE_E_LOGON_SG_SERVICE_TIMEDOUT            _HRESULT_TYPEDEF_(0x80151011L)
#define XONLINE_E_LOGON_PRESENCE_SERVICE_FAILED        _HRESULT_TYPEDEF_(0x80151012L)
#define XONLINE_E_LOGON_PRESENCE_SERVICE_TIMEDOUT      _HRESULT_TYPEDEF_(0x80151013L)
#define XONLINE_E_LOGON_SERVICE_UNAVAILABLE            _HRESULT_TYPEDEF_(0x80151014L)
#define XONLINE_E_LOGON_CONNECTION_LOST                _HRESULT_TYPEDEF_(0x80151015L)

// Service errors after XOnlineLogon task completion
#define XONLINE_E_LOGON_SERVICE_NOT_REQUESTED          _HRESULT_TYPEDEF_(0x80151020L)
#define XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED         _HRESULT_TYPEDEF_(0x80151021L)
#define XONLINE_E_LOGON_NO_SUBSCRIPTION                _HRESULT_TYPEDEF_(0x80151022L)

// User errors after XOnlineLogon task completion
#define XONLINE_E_LOGON_USER_ACCOUNT_INVALID           _HRESULT_TYPEDEF_(0x80151030L)
#define XONLINE_E_LOGON_USER_ACCOUNT_BANNED            _HRESULT_TYPEDEF_(0x80151031L)
#define XONLINE_E_LOGON_USER_ACCOUNT_SUSPENDED         _HRESULT_TYPEDEF_(0x80151032L)
#define XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT      _HRESULT_TYPEDEF_(0x80151033L)

// Other generic auth realted errors
#define XONLINE_E_LOGON_MU_NOT_MOUNTED                 _HRESULT_TYPEDEF_(0x80151040L)
#define XONLINE_E_LOGON_MU_IO_ERROR                    _HRESULT_TYPEDEF_(0x80151041L)
#define XONLINE_E_LOGON_NOT_LOGGED_ON                  _HRESULT_TYPEDEF_(0x80151042L)

// Errors returned by Presence/Notification
#define XONLINE_S_NOTIFICATION_UPTODATE                _HRESULT_TYPEDEF_(0x00000003L)
#define XONLINE_S_NOTIFICATION_FRIEND_RESULT           _HRESULT_TYPEDEF_(0x00000004L)
#define XONLINE_E_NOTIFICATION_BAD_CONTENT_TYPE        _HRESULT_TYPEDEF_(0x80155000L)
#define XONLINE_E_NOTIFICATION_REQUEST_TOO_SMALL       _HRESULT_TYPEDEF_(0x80155001L)
#define XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE    _HRESULT_TYPEDEF_(0x80155002L)
#define XONLINE_E_NOTIFICATION_NO_ADDRESS              _HRESULT_TYPEDEF_(0x80155003L)
#define XONLINE_E_NOTIFICATION_INVALID_PUID            _HRESULT_TYPEDEF_(0x80155004L)
#define XONLINE_E_NOTIFICATION_NO_CONNECTION           _HRESULT_TYPEDEF_(0x80155005L)
#define XONLINE_E_NOTIFICATION_SEND_FAILED             _HRESULT_TYPEDEF_(0x80155006L)
#define XONLINE_E_NOTIFICATION_RECV_FAILED             _HRESULT_TYPEDEF_(0x80155007L)
#define XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED       _HRESULT_TYPEDEF_(0x80155008L)
#define XONLINE_E_NOTIFICATION_SERVER_BUSY             _HRESULT_TYPEDEF_(0x80152001L)
#define XONLINE_E_NOTIFICATION_LIST_FULL               _HRESULT_TYPEDEF_(0x80152002L)
#define XONLINE_E_NOTIFICATION_BLOCKED                 _HRESULT_TYPEDEF_(0x80152003L)
#define XONLINE_E_NOTIFICATION_FRIEND_PENDING          _HRESULT_TYPEDEF_(0x80152004L)
#define XONLINE_E_NOTIFICATION_FLUSH_TICKETS           _HRESULT_TYPEDEF_(0x80152005L)

//  Errors returned by matchmaking
#define XONLINE_E_MATCH_INVALID_SESSION_ID             _HRESULT_TYPEDEF_(0x80155100L)  // specified session id does not exist
#define XONLINE_E_MATCH_INVALID_TITLE_ID               _HRESULT_TYPEDEF_(0x80155101L)  // specified title id is zero, or does not exist
#define XONLINE_E_MATCH_INVALID_DATA_TYPE              _HRESULT_TYPEDEF_(0x80155102L)  // attribute ID or parameter type specifies an invalid data type
#define XONLINE_E_MATCH_REQUEST_TOO_SMALL              _HRESULT_TYPEDEF_(0x80155103L)  // the request did not meet the minimum length for a valid request
#define XONLINE_E_MATCH_REQUEST_TRUNCATED              _HRESULT_TYPEDEF_(0x80155104L)  // the self described length is greater than the actual buffer size
#define XONLINE_E_MATCH_INVALID_SEARCH_REQ             _HRESULT_TYPEDEF_(0x80155105L)  // the search request was invalid
#define XONLINE_E_MATCH_INVALID_OFFSET                 _HRESULT_TYPEDEF_(0x80155106L)  // one of the attribute/parameter offsets in the request was invalid.  Will be followed by the zero based offset number.
#define XONLINE_E_MATCH_INVALID_ATTR_TYPE              _HRESULT_TYPEDEF_(0x80155107L)  // the attribute type was something other than user or session
#define XONLINE_E_MATCH_INVALID_VERSION                _HRESULT_TYPEDEF_(0x80155108L)  // bad protocol version in request
#define XONLINE_E_MATCH_OVERFLOW                       _HRESULT_TYPEDEF_(0x80155109L)  // an attribute or parameter flowed past the end of the request
#define XONLINE_E_MATCH_INVALID_RESULT_COL             _HRESULT_TYPEDEF_(0x8015510AL)  // referenced stored procedure returned a column with an unsupported data type
#define XONLINE_E_MATCH_INVALID_STRING                 _HRESULT_TYPEDEF_(0x8015510BL)  // string with length-prefix of zero, or string with no terminating null
#define XONLINE_E_MATCH_STRING_TOO_LONG                _HRESULT_TYPEDEF_(0x8015510CL)  // string exceeded 400 characters
#define XONLINE_E_MATCH_BLOB_TOO_LONG                  _HRESULT_TYPEDEF_(0x8015510DL)  // blob exceeded 800 bytes
#define XONLINE_E_MATCH_PUID_MISMATCH                  _HRESULT_TYPEDEF_(0x8015510EL)  // PUIDS did not match in attribute when added/changing players in a session
#define XONLINE_E_MATCH_INVALID_PLAYER                 _HRESULT_TYPEDEF_(0x8015510FL)  // player is not in the current session
#define XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID           _HRESULT_TYPEDEF_(0x80155110L)  // attribute id is invalid
#define XONLINE_E_MATCH_PLAYER_ALREADY_EXISTS          _HRESULT_TYPEDEF_(0x80155111L)  // player already exists in the db
#define XONLINE_E_MATCH_SESSION_ALREADY_EXISTS         _HRESULT_TYPEDEF_(0x80155112L)  // session id already exists in the db
#define XONLINE_E_MATCH_NO_TITLES                      _HRESULT_TYPEDEF_(0x80155113L)  // no titles in the db
#define XONLINE_E_MATCH_TITLE_ALREADY_EXISTS           _HRESULT_TYPEDEF_(0x80155114L)  // title already exists in the db
#define XONLINE_E_MATCH_CRITICAL_DB_ERR                _HRESULT_TYPEDEF_(0x80155115L)  // critical error in db
#define XONLINE_E_MATCH_NOT_ENOUGH_COLUMNS             _HRESULT_TYPEDEF_(0x80155116L)  // search result set had too few columns
#define XONLINE_E_MATCH_PERMISSION_DENIED              _HRESULT_TYPEDEF_(0x80155117L)  // incorrect permissions set on search sp
#define XONLINE_E_MATCH_INVALID_PART_SCHEME            _HRESULT_TYPEDEF_(0x80155118L)  // title specified an invalid partitioning scheme
#define XONLINE_E_MATCH_INVALID_PARAM                  _HRESULT_TYPEDEF_(0x80155119L)  // bad parameter passed to sp
#define XONLINE_E_MATCH_USE_SETPLAYER_PROC             _HRESULT_TYPEDEF_(0x8015511AL)  // attempt to use p_match_set_int_attribute to add/change player in session
#define XONLINE_E_MATCH_PLAYER_REQUIRED                _HRESULT_TYPEDEF_(0x8015511BL)  // attempt to set a per-player attribute with invalid PUID
#define XONLINE_E_MATCH_PLAYER_NOT_NEEDED              _HRESULT_TYPEDEF_(0x8015511CL)  // attempt to set a session attribute with non-zero PUID
#define XONLINE_E_MATCH_DATA_TYPE_MISMATCH             _HRESULT_TYPEDEF_(0x8015511DL)  // data type specified in attr id did not match type of attr being set
#define XONLINE_E_MATCH_SERVER_ERROR                   _HRESULT_TYPEDEF_(0x8015511EL)  // error on server not correctable by client
#define XONLINE_E_MATCH_NO_USERS                       _HRESULT_TYPEDEF_(0x8015511FL)  // no authenticated users in search request.
#define XONLINE_E_MATCH_INVALID_BLOB                   _HRESULT_TYPEDEF_(0x80155120L)  // invalid blob attribute

// Errors returned by billing/offerings
#define XONLINE_E_OFFERING_BAD_REQUEST                 _HRESULT_TYPEDEF_(0x80153001L)  // server received incorrectly formatted request 
#define XONLINE_E_OFFERING_INVALID_USER                _HRESULT_TYPEDEF_(0x80153002L)  // cannot find account for this user
#define XONLINE_E_OFFERING_INVALID_OFFER_ID            _HRESULT_TYPEDEF_(0x80153003L)  // offer does not exist
#define XONLINE_E_OFFERING_INELIGIBLE_FOR_OFFER        _HRESULT_TYPEDEF_(0x80153004L)  // user/title not allowed to purchase offer
#define XONLINE_E_OFFERING_OFFER_EXPIRED               _HRESULT_TYPEDEF_(0x80153005L)  // offer no longer available
#define XONLINE_E_OFFERING_SERVICE_UNREACHABLE         _HRESULT_TYPEDEF_(0x80153006L)  // apparent connectivity problems
#define XONLINE_E_OFFERING_PURCHASE_BLOCKED            _HRESULT_TYPEDEF_(0x80153007L)  // this user is not allowed to make purchases
#define XONLINE_E_OFFERING_PURCHASE_DENIED             _HRESULT_TYPEDEF_(0x80153008L)  // this user's payment is denied by billing provider
#define XONLINE_E_OFFERING_BILLING_SERVER_ERROR        _HRESULT_TYPEDEF_(0x80153009L)  // nonspecific billing provider error
#define XONLINE_E_OFFERING_OFFER_NOT_CANCELABLE        _HRESULT_TYPEDEF_(0x8015300AL)  // either this offer doesn't exist, or it's marked as un-cancelable
#define XONLINE_E_OFFERING_NOTHING_TO_CANCEL           _HRESULT_TYPEDEF_(0x8015300BL)  // this user doesn't have one of these anyways
#define XONLINE_E_OFFERING_PERMISSION_DENIED           _HRESULT_TYPEDEF_(0x80154001L)  // permission denied


//@@BEGIN_MSINTERNAL
// ====================================================================
// Localization defines

typedef enum {
    LANGUAGE_CURRENT  = -1,
    LANGUAGE_ENGLISH  = 0,
    LANGUAGE_JAPANESE,
    LANGUAGE_GERMAN,
    LANGUAGE_FRENCH,
    LANGUAGE_SPANISH,
    LANGUAGE_ITALIAN
} XONLINE_LANGUAGES;


// ====================================================================
// Localization defines

#define XOnlineIsOnlineError(hr) (((hr) & 0xFFFF0000L) == 0x80150000L)

#define LANGUAGE_COUNT                6

//@@END_MSINTERNAL



//@@BEGIN_MSINTERNAL

// ====================================================================
// SGADDR

#pragma pack(push, 1)

typedef struct {
    IN_ADDR         inaSg;              // IP address of the SG for the client
    DWORD           dwSpiSg;            // Pseudo-random identifier assigned by the SG
    ULONGLONG       qwXboxID;           // Unique identifier of client machine account
    BYTE            abReserved[4];      // Reserved (must be zero)
} SGADDR;

#pragma pack(pop)

//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
//@@BEGIN_CLIENTONLY
//@@END_MSINTERNAL

// ====================================================================
// XOnline Task Pump
//

DECLARE_HANDLE(XONLINETASK_HANDLE);
typedef XONLINETASK_HANDLE* PXONLINETASK_HANDLE;

//
// Define the two global state values
//
#define XONLINETASK_S_RUNNING                   (S_OK)
#define XONLINETASK_S_SUCCESS                   (S_FALSE)

XBOXAPI
HRESULT 
WINAPI
XOnlineTaskContinue(
    IN XONLINETASK_HANDLE hTask
    );

XBOXAPI
HRESULT 
WINAPI
XOnlineTaskClose(
    IN XONLINETASK_HANDLE hTask
    );

//@@BEGIN_MSINTERNAL
//@@END_CLIENTONLY
//@@END_MSINTERNAL


// ====================================================================
// XOnline Authentication
//

#define XONLINE_NAME_SIZE                       16
#define XONLINE_MAX_NAME_LENGTH                 (XONLINE_NAME_SIZE - 1)
#define XONLINE_KINGDOM_SIZE                    12
#define XONLINE_MAX_KINGDOM_LENGTH              (XONLINE_KINGDOM_SIZE - 1)
#define XONLINE_USERNAME_SIZE                   28 // (XONLINE_NAME_SIZE + XONLINE_KINGDOM_SIZE)
#define XONLINE_USERDOMAIN_SIZE                 20
#define XONLINE_MAX_USERDOMAIN_LENGTH           (XONLINE_USERDOMAIN_SIZE - 1)
#define XONLINE_REALM_NAME_SIZE                 24
#define XONLINE_MAX_REALM_NAME_LENGTH           (XONLINE_REALM_NAME_SIZE - 1)
#define XONLINE_MAX_TICKET_LENGTH             1024
#define XONLINE_KEY_LENGTH                      16
#define XONLINE_PIN_LENGTH                       4
#define XONLINE_MAX_LOGON_USERS                  4

//
// Services that can be passed to XOnlineLogon
//
#define XONLINE_BILLING_OFFERING_SERVICE    ((DWORD)4)
#define XONLINE_MATCHMAKING_SERVICE         ((DWORD)6)
#define XONLINE_STATISTICS_SERVICE          ((DWORD)7)
#define XONLINE_INVALID_SERVICE             ((DWORD)0)

//
// Used in dwUserFlags in XUID
//
#define XONLINE_USER_GUEST_MASK             0x00000003
#define XONLINE_USER_VOICE_NOT_ALLOWED      0x00010000
#define XONLINE_USER_PURCHASE_NOT_ALLOWED   0x00020000
#define XONLINE_USER_LOCKED_OUT             0x00040000;
#define XONLINE_USER_NICKNAME_NOT_ALLOWED   0x00080000;
#define XONLINE_USER_MUST_CHANGE_NAME       0x00100000;

#define XOnlineIsUserVoiceAllowed(dwUserFlags) (((dwUserFlags) & XONLINE_USER_VOICE_NOT_ALLOWED) == 0)

#define XOnlineIsUserPurchaseAllowed(dwUserFlags) (((dwUserFlags) & XONLINE_USER_PURCHASE_NOT_ALLOWED) == 0)

#define XOnlineIsUserLockedOut(dwUserFlags) (((dwUserFlags) & XONLINE_USER_LOCKED_OUT) != 0)

#define XOnlineIsUserNicknameAllowed(dwUserFlags) (((dwUserFlags) & XONLINE_USER_NICKNAME_NOT_ALLOWED) == 0)

#define XOnlineUserMustChangeName(dwUserFlags) (((dwUserFlags) & XONLINE_USER_MUST_CHANGE_NAME) != 0)

#define XOnlineIsUserGuest(dwUserFlags) (((dwUserFlags) & XONLINE_USER_GUEST_MASK) != 0)

#define XOnlineUserGuestNumber(dwUserFlags) ((dwUserFlags) & XONLINE_USER_GUEST_MASK)

#define XOnlineSetUserGuestNumber(dwUserFlags,guestNumber) ((dwUserFlags) |= ((guestNumber) & XONLINE_USER_GUEST_MASK))

#pragma pack(push, 4)

typedef struct {
    ULONGLONG qwUserID;
    DWORD dwUserFlags;
} XUID;

// 
//  Type of a offering ID
//
typedef DWORD    XONLINEOFFERING_ID;

//@@BEGIN_MSINTERNAL
//@@BEGIN_CLIENTONLY
//@@END_MSINTERNAL

#define XONLINE_USER_RESERVED_SIZE              72
#define XONLINE_MAX_STORED_ONLINE_USERS         16

DECLARE_HANDLE(XPININPUTHANDLE);

//
// Used in dwUserOptions in XONLINE_USER
//
#define XONLINE_USER_OPTION_REQUIRE_PIN     0x00000001
#define XONLINE_USER_OPTION_CAME_FROM_MU    0x80000000
#define XONLINE_USER_OPTION_MU_PORT_MASK    0x60000000
#define XONLINE_USER_OPTION_MU_PORT_SHIFT           29
#define XONLINE_USER_OPTION_MU_SLOT_MASK    0x10000000
#define XONLINE_USER_OPTION_MU_SLOT_SHIFT           28

typedef struct {
    XUID xuid;
    CHAR name[XONLINE_NAME_SIZE];
    CHAR kingdom[XONLINE_KINGDOM_SIZE];
    DWORD dwUserOptions;
    BYTE pin[XONLINE_PIN_LENGTH];
    BYTE reserved[XONLINE_USER_RESERVED_SIZE];
    HRESULT hr;
    DWORD index;
} XONLINE_USER, *PXONLINE_USER;

typedef struct {
    DWORD          dwServiceID;
    IN_ADDR        serviceIP;
    WORD           wServicePort;
    WORD           wReserved;
} XONLINE_SERVICE_INFO, *PXONLINE_SERVICE_INFO;

#pragma pack(pop)

XBOXAPI
HRESULT
WINAPI
XOnlineGetUsers (
    OUT PXONLINE_USER pUsers,
    OUT DWORD *pcUsers
    );

XBOXAPI
XPININPUTHANDLE
WINAPI
XOnlinePINStartInput(
    IN PXINPUT_STATE pInputState
    );

XBOXAPI
HRESULT
WINAPI
XOnlinePINDecodeInput(
    IN XPININPUTHANDLE handle,
    IN PXINPUT_STATE pInputState,
    IN PBYTE pPINByte
    );

XBOXAPI
HRESULT
WINAPI
XOnlinePINEndInput (
    IN XPININPUTHANDLE handle
    );

XBOXAPI
HRESULT
WINAPI
XOnlineLogon(
    IN PXONLINE_USER pUsers,
    IN DWORD* pdwServiceIDs,
    IN DWORD cServices,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE pHandle
    );

XBOXAPI
HRESULT
WINAPI
XOnlineLogonTaskGetResults(
    IN XONLINETASK_HANDLE hLogonTask
    );
    
XBOXAPI
PXONLINE_USER
WINAPI
XOnlineGetLogonUsers();

XBOXAPI
HRESULT
WINAPI
XOnlineGetServiceInfo(
    IN DWORD dwServiceID,
    OUT PXONLINE_SERVICE_INFO pServiceInfo
    );

// ====================================================================
// XOnline Title Update (Security updates)
//

// ====================================================================
// XOnline Offerings
//

#define XO_CURRENCY_EUR     1
#define XO_CURRENCY_GBP     2
#define XO_CURRENCY_JPY     4
#define XO_CURRENCY_KRW     8

// 
//  Type of a offering ID
//

typedef DWORD    XONLINEOFFERING_ID;


typedef struct {
    DWORD dwWholePart;
    DWORD dwFractionalPart;
    BYTE  bCurrencyFormat;
    WCHAR rgchISOCurrencyCode[3];
} XONLINE_PRICE, *PXONLINE_PRICE;


XBOXAPI
HRESULT 
WINAPI 
XOnlineOfferingPurchase( 
    IN DWORD dwUserIndex, 
    IN XONLINEOFFERING_ID OfferingId, 
    IN HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask 
    );

XBOXAPI
HRESULT 
WINAPI 
XOnlineOfferingCancel( 
    IN DWORD dwUserIndex, 
    IN XONLINEOFFERING_ID OfferingId, 
    IN HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask 
    );

XBOXAPI
HRESULT
WINAPI
XOnlineOfferingGetDetails ( 
    IN DWORD dwUserIndex,
    IN XONLINEOFFERING_ID OfferingId,
    IN WORD wLanguage,
    IN DWORD dwDescriptionIndex,
    IN PBYTE pbBuffer,
    IN DWORD cbBuffer,
    IN HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask 
    );

XBOXAPI
HRESULT
WINAPI 
XOnlineOfferingDetailsGetResults ( 
    IN XONLINETASK_HANDLE hTask,
    OUT PBYTE *pDetailsBuffer,
    OUT DWORD *pcbDetailsLength,
    OUT XONLINE_PRICE *pGrossPrice,
    OUT XONLINE_PRICE *pNetPrice 
    );

XBOXAPI
DWORD
WINAPI
XOnlineOfferingDetailsMaxSize(
    IN DWORD cbTitleSpecificDataMaxSize
    );

XBOXAPI
HRESULT
WINAPI
XOnlineOfferingPriceFormat( 
    IN XONLINE_PRICE *Price,
    IN OUT LPWSTR    lpwszFormattedPrice,
    IN OUT DWORD     *cbLength,
    IN DWORD         dwExtendedCharsFilter
    );


//@@BEGIN_MSINTERNAL
// (..for now, as we only expect this to be used via XOnlineContentVerify)
//

// user flags
#define XONLINE_LOGON_CONTROLLER1    0x0001   // logged-in user at controller 1
#define XONLINE_LOGON_CONTROLLER2    0x0002   // logged-in user at controller 2
#define XONLINE_LOGON_CONTROLLER3    0x0004   // logged-in user at controller 3
#define XONLINE_LOGON_CONTROLLER4    0x0008   // logged-in user at controller 4
#define XONLINE_LOGON_MACHINE        0x0010   // machine account
#define XONLINE_LOGON_ALL            0xffff   // machine and all logged-in users


// Function used to verify rights.   Will return
// success if any of the currently logged-in users, 
// or the machine, have rights to access the given
// offering id.
//
XBOXAPI
HRESULT 
WINAPI 
XOnlineOfferingVerifyLicense( 
    DWORD dwOfferingId, 
    DWORD dwUserAccounts,
    HANDLE hWorkEvent,
    XONLINETASK_HANDLE *phTask 
    );


// ====================================================================
// XOnline Content Delivery
//
XBOXAPI
HRESULT
WINAPI
XOnlineContentInstallFromDVD(
    IN PSTR szResourcePath,
    IN DWORD dwTitleId,
    IN XONLINEOFFERING_ID OfferingId,
    IN DWORD dwBitFlags,
    IN PBYTE pbSymmetricKey,
    IN DWORD cbSymmetricKey,
    IN PBYTE pbPublicKey,
    IN DWORD cbPublicKey,
    IN HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

// ====================================================================
// Autoupdate
//

typedef struct
{
    DWORD dwReason;
    DWORD dwContext;
    DWORD dwParameter1;
    DWORD dwParameter2;
    DWORD dwTitleId;
    DWORD dwBaseVersion;
    DWORD dwUpdateFlags;
    BYTE  rgbTitleKey[16];
    BYTE  rgbSymmetricKey[16];
    BYTE  rgbPublicKey[284];
    DWORD cbPublicKey;
    CHAR  szUpdatePath[MAX_PATH];
} LAUNCH_UPDATE_INFO, *PLAUNCH_UPDATE_INFO;

#define LAUNCH_UPDATE_FLAG_ONLINE	        ((DWORD)0x00000001)
#define LAUNCH_UPDATE_FLAG_USE_DEFAULT_KEYS ((DWORD)0x80000000)

#define IS_NEW_DASH_FEATURE(dwReason) (((dwReason) & 0x80000000)?TRUE:FALSE)

XBOXAPI
DWORD
WINAPI
XOnlineLaunchNewImage(
    IN LPCSTR lpImagePath,
    IN PLAUNCH_DATA pLaunchData
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineTitleUpdate(
    IN DWORD dwContext
    );

XBOXAPI
HRESULT 
WINAPI 
XOnlineTitleUpdateFromDVD(
    IN DWORD dwContext,
    IN PSTR szUpdatePath,
    IN DWORD dwTitleId,
    IN PBYTE pbSymmetricKey,
    IN DWORD cbSymmetricKey,
    IN PBYTE pbPublicKey,
    IN DWORD cbPublicKey
    );

XBOXAPI
HRESULT 
WINAPI
XOnlineTitleUpdateInternal(
    DWORD dwTitleId,
    DWORD dwTitleOldVersion,
    PBYTE pbTitleKey,
    HANDLE hWorkEvent,
    PXONLINETASK_HANDLE phTask
    );

XBOXAPI
HRESULT 
WINAPI
XOnlineTitleUpdateFromDVDInternal(
    PSTR szUpdatePath,
    DWORD dwTitleId,
    DWORD dwTitleOldVersion,
    PBYTE pbTitleKey,
    PBYTE pbSymmetricKey,
    DWORD cbSymmetricKey,
    PBYTE pbPublicKey,
    DWORD cbPublicKey,
    HANDLE hWorkEvent,
    PXONLINETASK_HANDLE phTask
    );

XBOXAPI
HRESULT
WINAPI
XOnlineTitleUpdateGetProgress(
    IN XONLINETASK_HANDLE hTask,
    OUT DWORD *pdwPercentDone,
    OUT ULONGLONG *pqwNumerator,
    OUT ULONGLONG *pqwDenominator
    );

//@@END_MSINTERNAL



//@@BEGIN_MSINTERNAL
//@@END_CLIENTONLY
//@@END_MSINTERNAL

// ===============================================================
// Offering enumeration APIs
//


// 
// Offering Type bitflags
//
#define    XONLINE_OFFERING_SUBSCRIPTION        0x1
#define    XONLINE_OFFERING_CONTENT             0x2


//
// The list of devices from which to enumerate offerings
//
typedef enum {
    XONLINEOFFERING_ENUM_DEVICE_DVD = 0,
    XONLINEOFFERING_ENUM_DEVICE_HD,
    XONLINEOFFERING_ENUM_DEVICE_ONLINE,
    XONLINEOFFERING_ENUM_DEVICE_MAX
} XONLINEOFFERING_ENUM_DEVICE, *PXONLINEOFFERING_ENUM_DEVICE;



//
// Offering enumeration parameters struct
//
typedef struct
{
    DWORD       dwOfferingType; // Filter on offering type
    DWORD       dwBitFilter;    // Bitfield for filtering offerings
    DWORD       dwDescriptionIndex;// Publisher-specific index
    DWORD       dwMaxResults;   // Desired max number of results
    FILETIME    ftActiveAfter;  // Return items newer than this date 
} XONLINEOFFERING_ENUM_PARAMS, *PXONLINEOFFERING_ENUM_PARAMS;

//
// Offering enumeration record
//
typedef struct {
    XONLINEOFFERING_ID  OfferingId;             // Offering ID
    DWORD               dwOfferingType;         // Offering type
    DWORD               dwBitFlags;             // Package-specific flags
    DWORD               cbPackageSize;          // Package wire size (bytes)
    DWORD               cbInstallSize;          // Installed size (blocks)
    FILETIME            ftActivationDate;       // Activation date of package
    DWORD               dwRating;               // Package rating
    DWORD               cbTitleSpecificData;    // Size of data blob (bytes)
    PBYTE               pbTitleSpecificData;    // Pointer to data blob
} XONLINEOFFERING_INFO, *PXONLINEOFFERING_INFO;

#define XONLINEOFFERING_ENUM_MAX_TITLE_DATA_SIZE    (8192)

//@@BEGIN_MSINTERNAL
//@@BEGIN_CLIENTONLY
//@@END_MSINTERNAL

//
// Define a special state code for enumeration
//
#define XONLINETASK_S_RESULTS_AVAIL                 ((HRESULT)2001)

//
// Function to kick off an offering enumeration request for the current title. 
//
// The caller must pass in a pEnumParame data structure to specify the enumeration
// parameters:
//   dwOfferingType - The type of offerings the caller is interested in.
//   dwBitFilter - Return offerings that have one or more of the specified bits set
//   dwMaxResults - Hints the number of results the caller wishes the server to 
//          return in each batch. Setting this to zero indicates that the server
//          should try to pack as many results into the supplied client buffer.
//          If the client buffer is not large enough to hold the specified number
//          of records, the server may return less records than specified. Use
//          the XOnlineOfferingMaxSize API to calculate the max buffer size required
//          to hold the desired number of results.
//   ftActiveAfter - Return offerings activated on or after this date 
//          (required for online)
//
// This API requires a work buffer that can either be supplied by the caller, or
// can be allocated as part of the task context (if NULL). cbBuffer specifies the 
// size of the buffer either case. It is the caller's responsibility to ensure that
// the buffer size is large enough to hold at least one offering record.
//
// if XOnlineTaskContinue returns XONLINETASK_S_SUCCESS, then the enumeration has
// completed successfully. The caller should call XOnlineOfferingEnumerateGetResults
// the get the final list of enumeration records. On the other hand, if this function
// returns XONLINETASK_S_RESULTS_AVAIL, this means that a batch of enumeration records
// are available, and that there are more results after these. The caller should also
// call XOnlineOfferingEnumerateGetResults to get the current batch of results, and
// then continue to call XOnlineTaskContinue to get the next batch of results.
//
XBOXAPI
HRESULT 
WINAPI
XOnlineOfferingEnumerate(
    IN XONLINEOFFERING_ENUM_DEVICE Device,
    IN DWORD dwUserIndex,
    IN PXONLINEOFFERING_ENUM_PARAMS pEnumParams,
    IN OPTIONAL PBYTE pbBuffer,
    IN DWORD cbBuffer,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

//
// Function to retrieve the results of an offering enumeration.
//
// Note: Callers will NOT have to free prgpOfferingInfo when they are done,
// but they must call XOnlineTaskClose(hTask) AFTER they are done with
// prgpOfferingInfo.
//
// prgpOfferingInfo returns a pointer to a vector of pointers to 
// XONLINEOFFERING_INFO structures (vs. pointer to an array of pointers to
// structs). i.e. ((*prgpOfferingInfo)[i])->wszName is the name of the ith 
// returned record.
//
// *pfMoreResults will indicate if there are more results available for this
// search criteria.
//
XBOXAPI
HRESULT 
WINAPI
XOnlineOfferingEnumerateGetResults(
    IN XONLINETASK_HANDLE hTask,
    OUT PXONLINEOFFERING_INFO **prgpOfferingInfo,
    OUT DWORD *pdwReturnedResults,
    OUT BOOL *pfMoreResults
    );

//
// Utility function to determine the absolute upper bound memory 
// requirements for receiving a specified number of offering entries.
//
// The max size is calculated based on pEnumParams->Device and
// pEnumDevice->dwMaxResults. cbTitleSpecificDataMaxSize is an 
// optional parameter that allows the title to override the max size
// for the rgbTitleSpecificData blob (to conserve memory). If this
// value is zero, then the hard limit for the blob size will be used
// in the calculations (which results in a bigger memory requirement).
//
XBOXAPI
DWORD 
WINAPI
XOnlineOfferingEnumerateMaxSize(
    IN PXONLINEOFFERING_ENUM_PARAMS pEnumParams,
    IN OPTIONAL DWORD cbTitleSpecificDataMaxSize
    );

//
// Function to kick off downloading and installing a
// content package as specified by the ID.
//
XBOXAPI
HRESULT 
WINAPI 
XOnlineContentInstall(
    IN XONLINEOFFERING_ID OfferingId,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

//
// Function to get the progress of an active content installation
//
XBOXAPI
HRESULT
WINAPI
XOnlineContentInstallGetProgress(
    IN XONLINETASK_HANDLE hTask,
    OUT OPTIONAL DWORD *pdwPercentDone,
    OUT OPTIONAL ULONGLONG *pqwNumerator,
    OUT OPTIONAL ULONGLONG *pqwDenominator
    );

//
// Function to kick off verification of a content package
//
XBOXAPI
HRESULT 
WINAPI 
XOnlineContentVerify(
    IN XONLINEOFFERING_ID OfferingId,
    IN OPTIONAL PBYTE pbBuffer,
    IN OUT DWORD *pcbBuffer,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

//
// Function to kick off the removal of a content package
// This blows away everything, including all content data
// under the title area, and user area.
//
XBOXAPI
HRESULT 
WINAPI 
XOnlineContentRemove(
    IN XONLINEOFFERING_ID OfferingId,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

//
// Utility function to compute the installation root directory of a
// content package.
//
XBOXAPI
HRESULT 
WINAPI 
XOnlineContentGetRootDirectory(
    IN XONLINEOFFERING_ID OfferingId,
    IN BOOL fUserData,
    IN OUT DWORD *pcbRootDirectory,
    OUT CHAR *szRootDirectory
    );

//@@BEGIN_MSINTERNAL
//@@END_CLIENTONLY
//@@END_MSINTERNAL


// ====================================================================
// XOnline Matchmaking
//

typedef struct _XONLINE_ATTRIBUTE {
    DWORD dwAttributeID;
    BOOL fChanged;
    union {
        struct {
            ULONGLONG      qwValue;
        } integer;
        struct {
            LPWSTR         pwszValue;
        } string;
        struct {
            PVOID          pvValue;
            DWORD          dwLength;
        } blob;
    } info;
} XONLINE_ATTRIBUTE, *PXONLINE_ATTRIBUTE;

typedef struct _XONLINE_ATTRIBUTE_SPEC {
    DWORD            type;
    DWORD            length;
} XONLINE_ATTRIBUTE_SPEC, *PXONLINE_ATTRIBUTE_SPEC;

#define X_MAX_STRING_ATTRIBUTE_LEN         400
#define X_MAX_BLOB_ATTRIBUTE_LEN           800

#define X_ATTRIBUTE_SCOPE_MASK             0x80000000
#define X_ATTRIBUTE_SCOPE_GLOBAL           0x80000000
#define X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC   0x00000000

#define X_ATTRIBUTE_DATATYPE_MASK          0x00F00000
#define X_ATTRIBUTE_DATATYPE_INTEGER       0x00000000
#define X_ATTRIBUTE_DATATYPE_STRING        0x00100000
#define X_ATTRIBUTE_DATATYPE_BLOB          0x00200000

#define X_ATTRIBUTE_ID_MASK                0x0000FFFF

//@@BEGIN_MSINTERNAL
#define X_ATTRIBUTE_DATATYPE_NULL          0x00F00000

#define X_ATTRIBUTE_TYPE_MASK              0x0F000000
#define X_ATTRIBUTE_TYPE_USER              0x01000000
#define X_ATTRIBUTE_TYPE_SESSION           0x00000000

#define X_ATTRIBUTE_USER_PUID               (DWORD)(X_ATTRIBUTE_SCOPE_GLOBAL |      \
                                                    X_ATTRIBUTE_TYPE_USER |         \
                                                    X_ATTRIBUTE_DATATYPE_INTEGER |  \
                                                    0x00000001)

#define X_ATTRIBUTE_RESERVED               ~(X_ATTRIBUTE_SCOPE_MASK | \
                                             X_ATTRIBUTE_DATATYPE_MASK | \
                                             X_ATTRIBUTE_TYPE_MASK | \
                                             X_ATTRIBUTE_ID_MASK)
//@@END_MSINTERNAL

#pragma pack(push, 1)

typedef struct
{
    DWORD  dwResultLength;
    XNKID  SessionID;
    XNADDR HostAddress;
    XNKEY  KeyExchangeKey;
    DWORD  dwPublicAvailable;
    DWORD  dwPrivateAvailable;
    DWORD  dwPublicCurrent;
    DWORD  dwPrivateCurrent;
    DWORD  dwNumAttributes;
} XMATCH_SEARCHRESULT, *PXMATCH_SEARCHRESULT;

#pragma pack(pop)

//@@BEGIN_MSINTERNAL
//@@BEGIN_CLIENTONLY
//@@END_MSINTERNAL

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionCreate(
    IN DWORD dwPublicCurrent,
    IN DWORD dwPublicAvailable,
    IN DWORD dwPrivateCurrent,
    IN DWORD dwPrivateAvailable,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionUpdate(
    IN XNKID SessionID,
    IN DWORD dwPublicCurrent,
    IN DWORD dwPublicAvailable,
    IN DWORD dwPrivateCurrent,
    IN DWORD dwPrivateAvailable,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionGetInfo(
    IN XONLINETASK_HANDLE hTask,
    OUT XNKID *pSessionID,
    OUT XNKEY *pKeyExchangeKey
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionDelete(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionFindFromID(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearch(
    IN DWORD dwProcedureIndex,
    IN DWORD dwNumResults,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN DWORD dwResultsLen,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

XBOXAPI
HRESULT 
WINAPI
XOnlineMatchSearchGetResults(
    IN XONLINETASK_HANDLE hTask,
    OUT PXMATCH_SEARCHRESULT **prgpSearchResults,
    OUT DWORD *pdwReturnedResults
    );
 
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchParse(
    IN PXMATCH_SEARCHRESULT pSearchResult,
    IN DWORD dwNumSessionAttributes,
    IN PXONLINE_ATTRIBUTE_SPEC pSessionAttributeSpec,
    OUT PVOID pQuerySession
    );

// ====================================================================
// Presence & Notification
//

#define XONLINE_NOTIFICATION_TYPE_FRIENDREQUEST    0x00000001
#define XONLINE_NOTIFICATION_TYPE_FRIENDSTATUS     0x00000002
#define XONLINE_NOTIFICATION_TYPE_GAMEINVITE       0x00000004
#define XONLINE_NOTIFICATION_TYPE_GAMEINVITEANSWER 0x00000008
#define XONLINE_NOTIFICATION_TYPE_ALL              0xFFFFFFFF

#define XONLINE_FRIENDSTATE_FLAG_NONE              0x00000000
#define XONLINE_FRIENDSTATE_FLAG_ONLINE            0x00000001
#define XONLINE_FRIENDSTATE_FLAG_PLAYING           0x00000002
#define XONLINE_FRIENDSTATE_FLAG_CLOAKED           0x00000004
#define XONLINE_FRIENDSTATE_FLAG_VOICE             0x00000008
#define XONLINE_FRIENDSTATE_FLAG_JOINABLE          0x00000010
#define XONLINE_FRIENDSTATE_MASK_GUESTS            0x00000060
#define XONLINE_FRIENDSTATE_FLAG_RESERVED0         0x00000080
#define XONLINE_FRIENDSTATE_FLAG_SENTINVITE        0x04000000
#define XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE    0x08000000
#define XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED    0x10000000
#define XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED    0x20000000
#define XONLINE_FRIENDSTATE_FLAG_REQUEST           0x40000000
#define XONLINE_FRIENDSTATE_FLAG_PENDING           0x80000000

#define XONLINE_FRIENDSTATE_GET_GUESTS(dwState) ((dwState & XONLINE_FRIENDSTATE_MASK_GUESTS) >> 5)
#define XONLINE_FRIENDSTATE_SET_GUESTS(dwState, bGuests) (dwState &= (bGuests << 5) & XONLINE_FRIENDSTATE_MASK_GUESTS)

typedef enum {
    XONLINE_NOTIFICATION_EVENT_SERVICE,
    NUM_XONLINE_NOTIFICATION_EVENT_TYPES
} XONLINE_NOTIFICATION_EVENT_TYPE;

typedef struct {
    XONLINE_NOTIFICATION_EVENT_TYPE     type;
    union {
        struct {
            DWORD                       dwCode;
        } service;
    } info;
} XONLINE_NOTIFICATION_MSG, *PXONLINE_NOTIFICATION_MSG;

XBOXAPI
BOOL
WINAPI
XOnlineNotificationSetState(
    IN DWORD dwUserIndex,
    IN DWORD dwStateFlags,
    IN XNKID sessionID,
    IN DWORD cbStateData,
    IN PBYTE pStateData
    );

XBOXAPI
HRESULT
WINAPI
XOnlineNotificationSetUserData(
    IN DWORD dwUserIndex,
    IN DWORD cbUserData,
    IN PBYTE pUserData,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

XBOXAPI
BOOL
WINAPI
XOnlineNotificationIsPending(
    IN DWORD dwUserIndex,
    IN DWORD dwType
    );
    
XBOXAPI
HRESULT
WINAPI
XOnlineNotificationEnumerate(
    IN DWORD dwUserIndex,
    IN PXONLINE_NOTIFICATION_MSG pbBuffer,
    IN WORD wBufferCount,
    IN DWORD dwNotificationTypes,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    );


// ====================================================================
// Friends
//

typedef enum {
    XONLINE_REQUEST_NO,
    XONLINE_REQUEST_YES,
    XONLINE_REQUEST_BLOCK
} XONLINE_REQUEST_ANSWER_TYPE;

typedef enum {
    XONLINE_GAMEINVITE_NO,
    XONLINE_GAMEINVITE_YES,
    XONLINE_GAMEINVITE_REMOVE
} XONLINE_GAMEINVITE_ANSWER_TYPE;

#define MAX_FRIENDS         100
#define MAX_STATEDATA_SIZE  8
#define MAX_USERDATA_SIZE   24

typedef struct {
    XUID                    xuid;           
    CHAR                    username[XONLINE_USERNAME_SIZE];
    DWORD                   friendState;
    XNKID                   sessionID;
    DWORD                   titleID;
    BYTE                    StateDataSize;
    BYTE                    StateData[MAX_STATEDATA_SIZE];
    BYTE                    UserDataSize;
    BYTE                    UserData[MAX_USERDATA_SIZE];
} XONLINE_FRIEND, *PXONLINE_FRIEND;

typedef struct {
    XONLINE_FRIEND InvitingFriend;
    XUID           xuidAcceptedFriend;
    FILETIME       InviteAcceptTime;
} XONLINE_ACCEPTED_GAMEINVITE, *PXONLINE_ACCEPTED_GAMEINVITE;

typedef enum {
    XONLINE_FRIENDS_RESULTS_FRIENDREQUESTFAILED = 0,
    XONLINE_FRIENDS_RESULTS_FRIENDREMOVEFAILED,
    NUM_XONLINE_FRIENDS_RESULTS_TYPES
} XONLINE_FRIENDS_RESULTS_TYPE;

typedef struct {
    XONLINE_FRIENDS_RESULTS_TYPE      type;
    union {
        struct {
            XUID                     xuid;
            HRESULT                  hr;
        } requestError;
        struct {
            XUID                     xuid;
            HRESULT                  hr;
        } removeError;
    } info;
} XONLINE_FRIENDS_RESULTS_ERROR, *PXONLINE_FRIENDS_RESULTS_ERROR;

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsStartup(
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    );


XBOXAPI
HRESULT
WINAPI
XOnlineFriendsGetResults(
    OUT DWORD *pdwUserIndex,
    OUT XUID *pxuidTargetUser
    );

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsEnumerate(
    IN DWORD dwUserIndex,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

XBOXAPI
DWORD
WINAPI
XOnlineFriendsGetLatest(
    IN DWORD dwUserIndex,
    IN DWORD dwFriendBufferCount,
    OUT PXONLINE_FRIEND pFriendBuffer
    );

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsRemove(
    IN DWORD dwUserIndex,
    IN PXONLINE_FRIEND pFriend
    );

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsRequest(
    IN DWORD dwUserIndex,
    IN XUID xuidToUser
    );

//@@BEGIN_MSINTERNAL
XBOXAPI
HRESULT
WINAPI
XOnlineFriendsRequestByName(
    IN DWORD dwUserIndex,
    IN PSTR pszUserName
    );
//@@END_MSINTERNAL
XBOXAPI
HRESULT
WINAPI
XOnlineFriendsGameInvite(
    IN DWORD dwUserIndex,
    IN XNKID SessionID,
    IN DWORD dwFriendListCount,
    IN PXONLINE_FRIEND pToFriendList
    );

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsRevokeGameInvite(
    IN DWORD dwUserIndex,
    IN XNKID SessionID,
    IN DWORD dwFriendListCount,
    IN PXONLINE_FRIEND pToFriendList
    );

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsAnswerRequest(
    IN DWORD dwUserIndex,
    IN PXONLINE_FRIEND pToFriend,
    IN XONLINE_REQUEST_ANSWER_TYPE Answer
    );

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsAnswerGameInvite(
    IN DWORD dwUserIndex,
    IN PXONLINE_FRIEND pToFriend,
    IN XONLINE_GAMEINVITE_ANSWER_TYPE Answer
    );

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsGetAcceptedGameInvite(
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

XBOXAPI
HRESULT
WINAPI
XOnlineFriendsGetAcceptedGameInviteResult(
    IN XONLINETASK_HANDLE hTask,
    OUT PXONLINE_ACCEPTED_GAMEINVITE pAcceptedGameInvite
    );

// ====================================================================
// LockoutList
//

#define MAX_LOCKOUTUSERS      250

typedef struct {
    XUID                    xuid;           
    CHAR                    username[XONLINE_USERNAME_SIZE];
} XONLINE_LOCKOUTUSER, *PXONLINE_LOCKOUTUSER;

XBOXAPI
DWORD
WINAPI
XOnlineLockoutlistGet(
    IN DWORD dwUserIndex,
    IN DWORD dwLockoutUserBufferCount,
    OUT PXONLINE_LOCKOUTUSER pLockoutUserBuffer
    );

XBOXAPI
HRESULT
WINAPI
XOnlineLockoutlistStartup(
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

XBOXAPI
HRESULT
WINAPI
XOnlineLockoutlistAdd(
    IN DWORD dwUserIndex,
    IN XUID xUserID,
    IN CHAR *pszUsername
    );

XBOXAPI
HRESULT
WINAPI
XOnlineLockoutlistRemove(
    IN DWORD dwUserIndex,
    IN XUID xUserID
    );

XBOXAPI
HRESULT
WINAPI
XOnlineVerifyNickname(
    IN LPCWSTR lpNickname,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    );

// ====================================================================
// XOnline Feedback
//

typedef enum {
	XONLINE_FEEDBACK_NEG_NICKNAME,
	XONLINE_FEEDBACK_NEG_GAMEPLAY,
	XONLINE_FEEDBACK_NEG_SCREAMING,
	XONLINE_FEEDBACK_NEG_HARASSMENT,
	XONLINE_FEEDBACK_NEG_LEWDNESS,
	XONLINE_FEEDBACK_POS_ATTITUDE,
	XONLINE_FEEDBACK_POS_SESSION,
	NUM_XONLINE_FEEDBACK_TYPES
} XONLINE_FEEDBACK_TYPE;

XBOXAPI
HRESULT
WINAPI
XOnlineFeedbackSend(
            IN DWORD dwUserIndex,
            IN XUID xTargetUser,
            IN XONLINE_FEEDBACK_TYPE FeedbackType,
            IN LPCWSTR lpszNickname,
            IN HANDLE hWorkEvent,
            OUT PXONLINETASK_HANDLE phTask
            );

// ====================================================================
// Statistics
//

#define XONLINE_STAT_RANK       ((WORD)0xFFFF)
#define XONLINE_STAT_RATING     ((WORD)0xFFFE)

typedef enum _XONLINE_STAT_TYPE {
	XONLINE_STAT_NONE,
	XONLINE_STAT_CHAR,
	XONLINE_STAT_SHORT,
	XONLINE_STAT_LONG,
	XONLINE_STAT_LONGLONG,
	XONLINE_STAT_FLOAT,
	XONLINE_STAT_DOUBLE
} XONLINE_STAT_TYPE;

typedef struct _XONLINE_STAT {
	WORD wID;
	XONLINE_STAT_TYPE type;
	
	union {
		CHAR cValue;
		SHORT sValue;
		LONG lValue;
		LONGLONG qwValue;
		float fValue;
		double dValue;             
	};
} XONLINE_STAT, *PXONLINE_STAT;

typedef struct _XONLINE_STAT_SPEC {
	XUID xuidUser;
	DWORD dwLeaderBoardID;
	DWORD dwNumStats;
	PXONLINE_STAT pStats;
} XONLINE_SET_STAT, *PXONLINE_STAT_SPEC;
 
typedef struct _XONLINE_STAT_USER {
	XUID xuidUser;
	CHAR szUsername[XONLINE_USERNAME_SIZE];
} XONLINE_STAT_USER, *PXONLINE_STAT_USER;

XBOXAPI
HRESULT
WINAPI
XOnlineStatSet(
	IN DWORD dwNumStatSpecs,
	IN PXONLINE_STAT_SPEC pStatSpecs,
	IN HANDLE hWorkEvent,
	OUT PXONLINETASK_HANDLE phTask
);

XBOXAPI
HRESULT
WINAPI
XOnlineStatGet(
    IN DWORD dwNumStatSpecs,
    IN OUT PXONLINE_STAT_SPEC pStatSpecs,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
);

XBOXAPI
HRESULT
WINAPI
XOnlineStatLeaderEnumerate(
	IN XUID* pxuidPagePivot,                           
	IN DWORD dwPageStart,                                              
	IN DWORD dwPageSize,
	IN DWORD dwLeaderboardID,
	IN DWORD dwNumStatsPerUser,
	IN DWORD *pStatsPerUser,
	OUT PXONLINE_STAT_USER pUsers,
	OUT PXONLINE_STAT pStats,
	IN HANDLE hWorkEvent,
	OUT PXONLINETASK_HANDLE phTask
);

XBOXAPI
HRESULT
WINAPI
XOnlineStatLeaderEnumerateGetResults(
    IN XONLINETASK_HANDLE hTask,
    OUT DWORD *pdwReturnedResults
);


//@@BEGIN_MSINTERNAL

// ********************************************************************
// Internal structures and functions begin here
// ********************************************************************

// ====================================================================
// Internal API hresults
//

#define XONLINE_S_ACCOUNTS_NAME_TAKEN            _HRESULT_TYPEDEF_(0x00000010L)

#define XONLINE_E_ACCOUNTS_INVALID_KINGDOM       _HRESULT_TYPEDEF_(0x80154001L)
#define XONLINE_E_ACCOUNTS_INVALID_USER          _HRESULT_TYPEDEF_(0x80154002L)
#define XONLINE_E_ACCOUNTS_USER_NOT_LOCKED_OUT   _HRESULT_TYPEDEF_(0x80154003L)
#define XONLINE_E_ACCOUNTS_ACCOUNT_INACTIVE      _HRESULT_TYPEDEF_(0x80154004L)

//
// Define macors to determine special states
//
#define XONLINETASK_STATUS_AVAILABLE(hr) \
            (((hr) == XONLINETASK_S_RUNNING)?FALSE:TRUE)
            
#define XONLINETASK_STATUS_SUCCESSFUL_COMPLETION(hr) \
            (((hr) == XONLINETASK_S_SUCCESS)?TRUE:FALSE)
            
#define XONLINETASK_STATUS_FAILED(hr)           (FAILED(hr))

#define XONLINETASK_SET_COMPLETION_STATUS(hr) \
            { if (SUCCEEDED(hr)) hr = XONLINETASK_S_SUCCESS; }


// ====================================================================
// XOnline Accounts
//

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// NOTE: ANY CHANGES TO THESE DEFINEs MUST ALSO 
// BE MADE TO
//  //depot/xonline/private/common/mc/xon.cs
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#define MAX_FIRSTNAME_SIZE       64
#define MAX_LASTNAME_SIZE        64
#define MAX_EMAIL_SIZE           129
#define MAX_PHONE_PREFIX_SIZE    12
#define MAX_PHONE_NUMBER_SIZE    12
#define MAX_PHONE_EXTENSION_SIZE 12
#define MAX_STREET_SIZE          128
#define MAX_CITY_SIZE            64
#define MAX_DISTRICT_SIZE        64
#define MAX_STATE_SIZE           64                                              
#define MAX_COUNTRYCODE_SIZE     2
#define MAX_POSTALCODE_SIZE      16
#define MAX_CC_NAME_SIZE         64
#define MAX_CC_TYPE_SIZE         32
#define MAX_CC_NUMBER_SIZE       24
#define MAX_CC_EXPIRATION_SIZE   6  
#define MAX_BANK_CODE_SIZE       64
#define MAX_BRANCH_CODE_SIZE     64
#define MAX_CHECK_DIGITS_SIZE    64


// priamry info required for payment
//
typedef struct 
{
    WCHAR    wszNickname[XONLINE_NAME_SIZE];
    WCHAR    wszKingdom[XONLINE_KINGDOM_SIZE];
    BYTE     rgbPin[XONLINE_PIN_LENGTH];
    
    WCHAR    wszFirstName[MAX_FIRSTNAME_SIZE];
    WCHAR    wszLastName[MAX_LASTNAME_SIZE];
    WCHAR    wszStreet1[MAX_STREET_SIZE];
    WCHAR    wszStreet2[MAX_STREET_SIZE];
    WCHAR    wszStreet3[MAX_STREET_SIZE];
    WCHAR    wszCity[MAX_CITY_SIZE];
    WCHAR    wszState[MAX_STATE_SIZE];
    BYTE     bCountryId;
    WCHAR    wszPostalCode[MAX_POSTALCODE_SIZE];
    WCHAR    wszPhonePrefix[MAX_PHONE_PREFIX_SIZE];
    WCHAR    wszPhoneNumber[MAX_PHONE_NUMBER_SIZE];
    WCHAR    wszPhoneExtension[MAX_PHONE_EXTENSION_SIZE];
    
    WCHAR    wszCardHolder[MAX_CC_NAME_SIZE];
    BYTE     bCardTypeId;
    WCHAR    wszCardNumber[MAX_CC_NUMBER_SIZE];
    FILETIME ftCardExpiration;
    
    WCHAR    wszEmail[MAX_EMAIL_SIZE];
    WCHAR    wszBankCode[MAX_BANK_CODE_SIZE];
    WCHAR    wszBranchCode[MAX_BRANCH_CODE_SIZE];
    WCHAR    wszCheckDigits[MAX_CHECK_DIGITS_SIZE];
} 
USER_ACCOUNT_INFO, *PUSER_ACCOUNT_INFO;

typedef struct
{
    WCHAR    wszNickname[XONLINE_NAME_SIZE];
    WCHAR    wszRealm[XONLINE_KINGDOM_SIZE];
} 
USER_XNAME, *PUSER_XNAME;


XBOXAPI
HRESULT
WINAPI
_XOnlineAccountTempCreate(
    IN PXONLINE_USER pUser, 
    IN HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask 
    );

XBOXAPI
HRESULT
WINAPI
_XOnlineAccountTempCreateGetResults(
    IN  XONLINETASK_HANDLE hTask,
    OUT PXONLINE_USER pUser
    );

XBOXAPI
HRESULT
WINAPI
_XOnlineGetTags(
    IN WORD wCountryId, 
    IN WORD wMaxTags, 
    IN LPCWSTR pwsName, 
    IN HANDLE hWorkEvent, 
    OUT XONLINETASK_HANDLE *phTask
    );

XBOXAPI
HRESULT
WINAPI
_XOnlineGetTagsResults(
    IN  XONLINETASK_HANDLE hTask,
    OUT LPWSTR* pszTags,
    OUT WORD* pwTagCount
    );


XBOXAPI
HRESULT
WINAPI
_XOnlineReserveName(
    IN LPCWSTR pwsGamerName,
    IN LPCWSTR pwsKingdom,
    IN WORD wMaxNames, 
    IN WORD wCountryId, 
    IN HANDLE hWorkEvent, 
    OUT XONLINETASK_HANDLE *phTask
    );



XBOXAPI
HRESULT
WINAPI
_XOnlineGetReserveNameResults(
    IN  XONLINETASK_HANDLE hTask,
    OUT PUSER_XNAME *ppNames,
    OUT DWORD* pdwNameCount
    );

XBOXAPI
HRESULT
WINAPI
_XOnlineCreateAccount(
    IN  USER_ACCOUNT_INFO* pAccountInfo,
    IN  HANDLE hWorkEvent, 
    OUT XONLINETASK_HANDLE *phTask
    );


XBOXAPI
HRESULT
WINAPI
_XOnlineGetCreateAccountResults(
    IN  XONLINETASK_HANDLE hTask,
    OUT PXONLINE_USER pUser
    );


// ====================================================================
// XOnline Authentication
//

#define XONLINE_E_LOGON_MACHINE_AUTHENTICATION_FAILED          _HRESULT_TYPEDEF_(0x80151900L)

#define XONLINE_USER_SIGNATURE_LENGTH           8
#define XONLINE_KERBEROS_PRINCIPLE_NAME_SIZE   64

#define XONLINE_MAX_HD_ONLINE_USERS             8
#define XONLINE_MAX_ONLINE_USERS_PER_SECTOR     4

typedef struct {

    XUID xuid;
    CHAR name[XONLINE_NAME_SIZE];
    CHAR kingdom[XONLINE_KINGDOM_SIZE];
    DWORD dwUserOptions;
    BYTE pin[XONLINE_PIN_LENGTH];

    //
    // The following 5 fields are marked as reserved in the public structure
    // The combined size should add up to XONLINE_USER_RESERVED_SIZE
    //
    CHAR domain[XONLINE_USERDOMAIN_SIZE];
    CHAR realm[XONLINE_REALM_NAME_SIZE];
    BYTE key[XONLINE_KEY_LENGTH];
    DWORD dwSignatureTime;
    BYTE signature[XONLINE_USER_SIGNATURE_LENGTH];
    
    HRESULT hr;
    DWORD index;

} XONLINEP_USER, *PXONLINEP_USER;

//@@END_CLIENTONLY
//
// These Services are hidden from title developers
//
#define XONLINE_PRESENCE_SERVICE                ((DWORD)1)
#define XONLINE_MESSAGE_SERVICE                 ((DWORD)2)
#define XONLINE_AUTO_UPDATE_SERVICE             ((DWORD)3)
#define XONLINE_USER_ACCOUNT_SERVICE            ((DWORD)5)

//
// These Services are for testing against the sgs
//
#define XONLINE_SG_DATA_ENUM_SERVICE            ((DWORD)257)
#define XONLINE_SG_DATA_TEST_SERVICE            ((DWORD)258)
#define XONLINE_SG_PERF_ENUM_SERVICE            ((DWORD)259)
#define XONLINE_SG_PERF_TEST_SERVICE            ((DWORD)260)
//@@BEGIN_CLIENTONLY

#pragma pack(push, 4)

typedef struct
{
    XUID xuid;
    CHAR name[XONLINE_NAME_SIZE];
    CHAR kingdom[XONLINE_KINGDOM_SIZE];
    DWORD dwUserOptions;
    BYTE pin[XONLINE_PIN_LENGTH];
    CHAR domain[XONLINE_USERDOMAIN_SIZE];
    CHAR realm[XONLINE_REALM_NAME_SIZE];
    BYTE key[XONLINE_KEY_LENGTH];
    DWORD dwSignatureTime;
    BYTE signature[XONLINE_USER_SIGNATURE_LENGTH];
} XC_ONLINE_USER_ACCOUNT_STRUCT, *PXC_ONLINE_USER_ACCOUNT_STRUCT;

typedef XC_ONLINE_USER_ACCOUNT_STRUCT XC_ONLINE_MACHINE_ACCOUNT_STRUCT, *PXC_ONLINE_MACHINE_ACCOUNT_STRUCT;

#define CONFIG_DATA_LENGTH 492
#define MACHINE_ACCOUNT_CONFIG_SECTOR   1
#define BASE_USER_ACCOUNT_CONFIG_SECTOR 2

// ====================================================================
// XOnline Content Delivery
//

//
// Function to kick off an enumeration of all active titles played on the
// Xbox. All titles that have been played on the Xbox and not removed will
// be enumerated. This operation, upon success, returns dwMaxResults title IDs,
// of the total number of titles on the system, whichever is less. The actual
// list of Title IDs can be retrieved using XOnlineEnumerateTitlesGetResults().
// Subsequent title IDs can be retrieved by calling 
// XOnlineEnumerateTitlesContinue().
//
XBOXAPI
HRESULT 
WINAPI
XOnlineEnumerateTitlesBegin(
    IN DWORD dwMaxResults,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

XBOXAPI
HRESULT 
WINAPI
XOnlineEnumerateTitlesContinue(
    IN XONLINETASK_HANDLE hTask
    );

//
// Function to retrieve the results of a title enumeration.
//
XBOXAPI
HRESULT 
WINAPI
XOnlineEnumerateTitlesGetResults(
    IN XONLINETASK_HANDLE hTask,
    OUT DWORD **prgTitleID,
    OUT DWORD *pdwTitleID
    );

// ====================================================================
// XRL (XOnlineDownload and XOnlineUpload) Functions
//

//
// Define extended status codes for download and upload
//
#define XONLINEDOWNLOAD_EXSTATUS_SUCCESS        (200)
#define XONLINEDOWNLOAD_EXSTATUS_TRANSERROR(es) (((es >= 400) && (es < 500))?TRUE:FALSE)
#define XONLINEDOWNLOAD_EXSTATUS_PERMERROR(es)  ((es >= 500)?TRUE:FALSE)
#define XONLINEDOWNLOAD_EXSTATUS_ANYERROR(es)   ((es >= 400)?TRUE:FALSE)

#define XONLINEUPLOAD_EXSTATUS_SUCCESS            (200)
#define XONLINEUPLOAD_EXSTATUS_NOCONTENT        (204)
#define XONLINEUPLOAD_EXSTATUS_PARTIALCONTENT   (206)
#define XONLINEUPLOAD_EXSTATUS_TRANSERROR(es)   (((es >= 400) && (es < 500))?TRUE:FALSE)
#define XONLINEUPLOAD_EXSTATUS_PERMERROR(es)    ((es >= 500)?TRUE:FALSE)
#define XONLINEUPLOAD_EXSTATUS_ANYERROR(es)     ((es >= 400)?TRUE:FALSE)

//
// Define flags for XOnlineDownloadFile
//
#define XON_DF_FORCE_DOWNLOAD            ((DWORD)0x00000001)

//
// XRL access functions
//

//
// Function to kick off downloading a resource from a service
// to memory
//
XBOXAPI
HRESULT 
WINAPI 
XOnlineDownloadToMemory(
    IN DWORD dwServiceID,
    IN LPCSTR szResourcePath, 
    IN PBYTE pbBuffer,
    IN DWORD cbBuffer, 
    IN OPTIONAL PBYTE pbExtraHeaders,
    IN OPTIONAL DWORD cbExtraHeaders,
    IN DWORD dwTimeout,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

//
// Function to kick off downloading a resoruce from a service
// to a file
//
XBOXAPI
HRESULT 
WINAPI 
XOnlineDownloadFile(
    IN DWORD dwServiceID,
    IN LPCSTR szResourcePath, 
    IN PBYTE pbBuffer,
    IN DWORD cbBuffer, 
    IN OPTIONAL PBYTE pbExtraHeaders,
    IN OPTIONAL DWORD cbExtraHeaders,
    IN DWORD dwFlags,
    IN LPCSTR szLocalPath, 
    IN DWORD dwTimeout,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

//
// Function to get the download progress
//
XBOXAPI
HRESULT
WINAPI 
XOnlineDownloadGetProgress(
    IN XONLINETASK_HANDLE hTask,
    OUT OPTIONAL DWORD *pdwPercentDone,
    OUT OPTIONAL ULARGE_INTEGER *puliNumerator,
    OUT OPTIONAL ULARGE_INTEGER *puliDenominator
    );

//
// Function to return the results of a download
//
XBOXAPI
HRESULT
WINAPI
XOnlineDownloadGetResults(
    IN XONLINETASK_HANDLE hTask,
    OUT OPTIONAL LPBYTE *ppbBuffer,
    OUT OPTIONAL DWORD *pcbBuffer,
    OUT OPTIONAL ULARGE_INTEGER *puliTotalReceived,
    OUT OPTIONAL ULARGE_INTEGER *puliContentLength,
    OUT OPTIONAL DWORD *pdwExtendedStatus,
    OUT OPTIONAL FILETIME *pftTimestamp,
    OUT OPTIONAL FILETIME *pftLastModified
    );

//
// Function to kick off uploading a memory buffer to the specified service
//
XBOXAPI
HRESULT
WINAPI 
XOnlineUploadFromMemory(
    IN DWORD dwServiceID,
    IN LPCSTR szTargetPath, 
    IN PBYTE pbBuffer,
    IN OUT DWORD *pcbBuffer, 
    IN OPTIONAL PBYTE pbExtraHeaders,
    IN OPTIONAL DWORD cbExtraHeaders,
    IN PBYTE pbDataToUpload,
    IN DWORD cbDataToUpload,
    IN DWORD dwTimeout,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

//
// Function to kick off uploading a local file to the specified service
//
XBOXAPI
HRESULT 
WINAPI 
XOnlineUploadFile(
    IN DWORD dwServiceID,
    IN LPCSTR szTargetPath, 
    IN PBYTE pbBuffer,
    IN OUT DWORD *pcbBuffer, 
    IN OPTIONAL PBYTE pbExtraHeaders,
    IN OPTIONAL DWORD cbExtraHeaders,
    IN LPCSTR szLocalPath, 
    IN DWORD dwTimeout,
    IN OPTIONAL HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE *phTask
    );

//
// Function to get the upload progress
//
XBOXAPI
HRESULT
WINAPI 
XOnlineUploadGetProgress(
    IN XONLINETASK_HANDLE hTask,
    OUT OPTIONAL DWORD *pdwPercentDone,
    OUT OPTIONAL ULARGE_INTEGER *puliNumerator,
    OUT OPTIONAL ULARGE_INTEGER *puliDenominator
    );

//
// Function to return the results of an upload
//
XBOXAPI
HRESULT
WINAPI
XOnlineUploadGetResults(
    IN XONLINETASK_HANDLE hTask,
    OUT OPTIONAL LPBYTE *ppbBuffer,
    OUT OPTIONAL DWORD *pcbBuffer,
    OUT OPTIONAL ULARGE_INTEGER *puliTotalReceived,
    OUT OPTIONAL ULARGE_INTEGER *puliContentLength,
    OUT OPTIONAL DWORD *pdwExtendedStatus,
    OUT OPTIONAL FILETIME *pftTimestamp
    );

//@@END_CLIENTONLY

// ====================================================================
// XOnline Presence & Notification
//

//
// Current version is v0.17
//
#define CURRENT_XPPROTOCOL_VER 0x00000011

//
// Various protocol related constants
//
#define MIN_PMSG_SIZE               4
#define MAX_PMSG_SIZE               0x10000 //~64k
#define MAX_HELLO_DESCRIPTION_LEN   80
#define MAX_ACCTNAME_BYTES          64
#define MAX_NICKNAME_BYTES          24
#define MAX_TITLE_STATE_BYTES       8
#define MAX_BUDDIES                 100

enum P_MSG_TYPES
{
    // Incoming messages
    PMSG_MIN_REQ_TYPE   = 1000,
    PMSG_HELLO          = 1000,
    PMSG_ALIVE          = 1001,
    PMSG_SYNC           = 1002,
    PMSG_REFRESH        = 1003,
    PMSG_ADD            = 1004,
    PMSG_DELETE         = 1005,
    PMSG_ACCEPT         = 1006,
    PMSG_REJECT         = 1007,
    PMSG_BLOCK          = 1008,
    PMSG_UNBLOCK        = 1009,
    PMSG_INVITE         = 1010,
    PMSG_CANCEL         = 1011,
    PMSG_INVITE_ANSWER  = 1012,
    PMSG_NICKNAME       = 1013,
    PMSG_STATE          = 1014,
    PMSG_DEAD_XBOX      = 1015,
    PMSG_DEAD_SG        = 1016,
    PMSG_ANNOUNCE       = 1017,
    PMSG_SUBSCRIBED     = 1018,
    PMSG_UNSUBSCRIBE    = 1019,
    PMSG_ADDED          = 1020,
    PMSG_ACCEPTED       = 1021,
    PMSG_REMOVED        = 1022,
    PMSG_KICK           = 1023,
    PMSG_MAX_REQ_TYPE   = 1023,

    // Outgoing messages
    PMSG_MIN_REPLY_TYPE = 1101,
    PMSG_ALIVE_REPLY    = 1101,
    PMSG_SYNC_REPLY     = 1102,
    PMSG_MAX_REPLY_TYPE = 1102
};

#define P_STATE_MASK_NONE           0x0000
#define P_STATE_MASK_ONLINE         0x0001 // Set if online
#define P_STATE_MASK_PLAYING        0x0002 // Set if playing a game
#define P_STATE_MASK_CLOAKED        0x0004 // Set to fake being offline
#define P_STATE_MASK_VOICE          0x0008 // Set if supports voice
#define P_STATE_MASK_JOINABLE       0x0010 // Set if session is joinable
#define P_STATE_MASK_GUESTS         0x0060
#define P_STATE_MASK_RESERVED0      0x0080

#define P_BUDDY_STATUS_OK      0 // Mutualy accepted buddy
#define P_BUDDY_STATUS_PENDING 1 // Buddy request pending accetance
#define P_BUDDY_STATUS_REQUEST 2 // Buddy request to accept or reject

enum P_INVITE_REPLIES
{
    PINVITE_REPLY_NO    = 0,
    PINVITE_REPLY_YES   = 1
};

enum P_QUEUE_TYPES
{
    //
    // Outgoing queued response items
    //
    PQUEUE_LIST_CHANGE   = 0,
    PQUEUE_PRESENCE      = 1,
    PQUEUE_INVITE        = 2,
    PQUEUE_INVITE_ANSWER = 3
};

enum P_LIST_OPERATIONS
{
    PLIST_BUDDY_NOP     = 0,
    PLIST_BUDDY_ADD     = 1,
    PLIST_BUDDY_ADDED   = 2,
    PLIST_BUDDY_ACCEPT  = 3,
    PLIST_BUDDY_REJECT  = 4,
    PLIST_BUDDY_DELETE  = 5,
    PLIST_BLOCK_NOP     = 6,
    PLIST_BLOCK_BLOCK   = 7,
    PLIST_BLOCK_UNBLOCK = 8
};

#define IGNOREME_SESSID     0
#define MSGTYPE_ACK         0xffffffff

//
// Current version is v0.17
//
#define CURRENT_XQPROTOCOL_VER 0x00000011

//
// Various protocol related constants
//
#define MIN_QMSG_SIZE               4
#define MAX_QMSG_SIZE               0x10000 //~64k
#define MAX_HELLO_DESCRIPTION_LEN   80

enum Q_MSG_TYPES
{
    //
    // Incoming messages
    //
    QMSG_HELLO = 0,
    QMSG_USER_INFO = 1,
    QMSG_ADD = 2,
    QMSG_DELETE = 3,
    QMSG_DELETE_MATCHES = 4,
    QMSG_DEAD_XBOX = 5,
    QMSG_DEAD_SG = 6,
    QMSG_LIST = 7,
    QMSG_DEQUEUE = 8,
    QMSG_MAX_REQ_TYPE = 8,

    //
    // Outgoing messages
    //
    QMSG_LIST_REPLY = 100,
    QMSG_MAX_REPLY_TYPE = 100
};
//----------------------------------------------------------------------------+
//  Structures
//

#ifdef __cplusplus

#pragma pack(push, 1)

//
// This is the basic message framing structure from which the queue and presence
// server protocols are derived.
//
// dwMsgType is an enumerated value unique across protocols
// dwMsgLen is the amount of message data that follows this header
// dwSeqNum is a client-assigned sequence number used to resolve async races
// dwSessID is a connection server assigned session ID used to resolve async races
//
struct BASE_MSG_HEADER
{
    DWORD dwMsgType;
    DWORD dwMsgLen;
    DWORD dwSeqNum;
    SGADDR sgaddr;

    // BYTE rgbMsgData[ dwMsgLen ];
};

//
// This is the basic acknowledgement message used in all derived protocols to
// signal reception of certain messages and indicate their resulting status.
//
struct BASE_ACK_MSG : public BASE_MSG_HEADER
{
    DWORD dwAckMsgType;     // dwMsgType of message being acknowledged
    DWORD dwAckSeqNum;      // dwSeqNum of message being acknowledged
    ULONGLONG qwAckUserID;
    HRESULT hrAck;
};

//
// This must be the first message sent to the server after establishing
// a TCP connection
//
struct Q_HELLO_MSG : public BASE_MSG_HEADER
{
    DWORD dwProtocolVersion;    // Hi word | lo word

    // char szDescription[];    // NULL-terminated ASCII string
};

//
// Before sending any messages pertaining to a user, this message must be
// sent to the server to establish the user's queues.
//
struct Q_USER_INFO_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// Add a new item asynchronously to one or more users' Qs, given the item type
//
struct Q_ADD_MSG : public BASE_MSG_HEADER
{
    WORD wQType;
    WORD wUserCount;

    // ULONGLONG qwUserIDs[ dwUserCount ];
    // BYTE rgbData[];
};

//
// Delete an item or range of items of the given item type from a user's Q
//
struct Q_DELETE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD wQType;
    DWORD dwFirstItemID;
    DWORD dwLastItemID;      // Set == dwFirstItemID to delete one item
};

//
// Delete any matching items of the given item type from one or more users' Qs
//
struct Q_DELETE_MATCHES_MSG : public BASE_MSG_HEADER
{
    WORD wQType;
    WORD wMatchAttrNum;   // must be zero for now
    WORD wUserCount;
    
    // ULONGLONG qwUserIDs[ dwUserCount ];
    // BYTE rgbMatchData[ MatchAttrLen ];
};

//
// Inform the Q server that the given XBox just went offline, so any
// items pertaining to this address that are no longer relevant should be
// deleted.
//
struct Q_DEAD_XBOX_MSG : public BASE_MSG_HEADER
{
};

//
// Inform the Q server that the given SG just went offline, so any users
// who were on this SG should be considered offline also.  This will end
// up emptying many Q's, as well as potentially deleting many individual items.
//
struct Q_DEAD_SG_MSG : public BASE_MSG_HEADER
{
};

//
// Ask the Q server to send a Q_LIST_REPLY_MSG containing up to the number of
// items given of a particular type for a certain user.
//
struct Q_LIST_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD  wQType;
    DWORD dwStartItemID;
    WORD  wMaxItems;
    DWORD dwMaxTotalItemDataSize;
};

//
// Ask the Q server to send a Q_LIST_REPLY_MSG containing up to the number of
// items given of a particular type for a certain user.  The items returned
// are removed from the queue.
//
struct Q_DEQUEUE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD  wQType;
    DWORD dwStartItemID;
    WORD  wMaxItems;
    DWORD dwMaxTotalItemDataSize;
};

//
// The asynchronous reply to a Q_LIST_MSG or Q_DEQUEUE_MSG 
//
struct Q_LIST_REPLY_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD  wQType;
    HRESULT hr;
    DWORD dwNextItemID;
    WORD  wQLeft;
    WORD  wNumItems;
    DWORD dwTotalItemDataSize;
    DWORD dwQFlags;
    DWORD dwSeqQFlags;

    // Q_LIST_ITEM rgItems[ dwNumItems ];
};

struct Q_LIST_ITEM
{
    DWORD dwItemID;
    WORD wItemLen;

    // BYTE rgbItemData[ dwItemLen ];
};

//
// This must be the first message sent to the server after establishing
// a TCP connection
//
struct P_HELLO_MSG : public BASE_MSG_HEADER
{
    DWORD dwProtocolVersion;    // Hi word | lo word
    // char szDescription[];    // NULL-terminated ASCII string
};

//
// This establishes the user's presence in the system
//
struct P_ALIVE_MSG : public BASE_MSG_HEADER
{
    // User Info
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    WORD  cbAcctName;
    // Sync info
    DWORD dwBuddyListVersion;
    DWORD dwBlockListVersion;
    // State into
    DWORD dwState;
    ULONGLONG qwMatchSessionID;
    WORD  cbNickname;
    WORD  cbTitleStuff;
    // char szAcctName[];               // ASCII Null terminated
    // byte rgbNickName[];              // Binary
    // byte rgbTitleStuff[];            // Binary
};

//
// The asynchronous reply to a P_ALIVE_MSG is contained in one of these
//
struct P_REPLY_BUDDY
{
    ULONGLONG qwBuddyID;
    WORD  cbAcctName;                   // Includes the '\0'
    BYTE  bStatus;
    // char szAcctName;                 // ASCII Null terminated
};

struct P_REPLY_BLOCK
{
    ULONGLONG qwBlockID;
    WORD  cbAcctName;                   // Includes the '\0'
    // char szAcctName;                 // ASCII Null terminated
};

struct P_ALIVE_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;                         // On fail other fields set to 0
    DWORD dwBuddyListVersion;
    WORD  cBuddiesSent;
    DWORD dwBlockListVersion;
    WORD  cBlocksSent;
    // P_REPLY_BUDDY rgBuddies[]
    // P_REPLY_BLOCK rgBlocks[]
};

//
// Resync the buddy and block lists
//
struct P_SYNC_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwBuddyListVersion;
    DWORD dwBlockListVersion;
};

//
// The asynchronous reply to a P_SYNC_MSG is contained in one of these
//
struct P_SYNC_REPLY_MSG : public BASE_MSG_HEADER
{
    HRESULT hr;                         // On fail other fields set to 0
    DWORD dwBuddyListVersion;
    WORD  cBuddiesSent;
    DWORD dwBlockListVersion;
    WORD  cBlocksSent;
    // P_REPLY_BUDDY rgBuddies[]
    // P_REPLY_BLOCK rgBlocks[]
};

//
// Refresh the presence and invitation notification queues
//
struct P_REFRESH_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
};

//
// Attempt to add the given person to the sender's buddy list, either by the
// person's ID or name.
//
struct P_ADD_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSenderID;
    ULONGLONG qwBuddyID;
    WORD  cbBuddyAcctname;
    // char szBuddyAcctName[ cbBuddyAcctname];   // ASCII Null terminated
                                                    // only used if qwBuddyID == 0
};

//
// Delete a buddy from my buddy list
//
struct P_DELETE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
};

//
// Accept a request to be someone's buddy
//
struct P_ACCEPT_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
};

//
// Reject a request to be someone's buddy
//
struct P_REJECT_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
    BOOL fNever;
};

//
// Add a user to my blocklist 
//
struct P_BLOCK_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBlockID;       
};

//
// Remove the a user from my blocklist 
// If qwBlockID == 0, clear the entire block list.
//
struct P_UNBLOCK_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBlockID;       
};

struct P_INVITE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwTitleID;
    ULONGLONG qwMatchSessionID;
    WORD  cInvitees;
    // ULONGLONG rgqwInvitees[ dwNumInvitees ];
};

struct P_CANCEL_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwMatchSessionID;
    WORD  cInvitees;
    // ULONGLONG rgqwInvitees[ dwNumInvitees ];
};

struct P_INVITE_ANSWER_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwHostID;
    ULONGLONG qwMatchSessionID;
    WORD wAnswer;
};

//
// This supplies the latest nickname info for a user
//
struct P_NICKNAME_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    WORD cbNickname;
    // byte rgbNickName[];              // Binary
};

//
// This supplies the latest state info for a user
//
struct P_STATE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    DWORD dwState;
    ULONGLONG qwMatchSessionID;
    WORD cbTitleStuff;
    // byte rgbTitleStuff[];            // Binary
};

//
// Inform the P server that the given XBox just went offline, so any users
// who were on this XBox should be considered offline also.
//
struct P_DEAD_XBOX_MSG : public BASE_MSG_HEADER
{
};

//
// Inform the P server that the given SG just went offline, so any users
// who were on this SG should be considered offline also.
//
struct P_DEAD_SG_MSG : public BASE_MSG_HEADER
{
};

//
// This tells the destination user's P server that the listed source users
// have added a subscription for the destination user and are expected to 
// subscribe back if online
//
struct P_ANNOUNCE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwDestUserID;
    WORD  cSourceUserIDs;
    // ULONGLONG qwSourceUserIDs[ dwCountSourceUsers ];
};

//
// This tells the destination user's P server that the listed source users
// have added a subscription for the destination user
//
struct P_SUBSCRIBED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwDestUserID;
    WORD  cSourceUserIDs;
    // ULONGLONG qwSourceUserIDs[ dwCountSourceUsers ];
};

//
// This tells the destination users' P server that the source user just went
// offline, which implies that any subscription for the source user should
// be removed.
//
struct P_UNSUBSCRIBE_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwSourceUserID;
    WORD  cDestUserIDs;
    // ULONGLONG qwDestUserIDs[ dwCountDestUsers ];
};

//
// Tell your new buddy's P server that you made a request to become buddies.
//
struct P_ADDED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
    DWORD dwVersion;
    WORD  cbBuddyAcctName;
    // char szBuddyAcctName[ cbBuddyAcctName ];  // ASCII string null terminated
};

//
// Tell your new buddy's P server that you accepted his request to become buddies.
//
struct P_ACCEPTED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
    DWORD dwVersion;
};

//
// Tell your ex-buddy's P server that you are no longer buddies.
//
struct P_REMOVED_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    ULONGLONG qwBuddyID;
    DWORD dwVersion;
};

// Kick a user off the system
//
struct P_KICK_MSG : public BASE_MSG_HEADER
{
    ULONGLONG qwUserID;
    BOOL fFlushTickets;
};

struct P_LIST_CHANGE_ITEM
{
    DWORD dwListVersion;
    ULONGLONG qwTargetID;
    WORD  wOperationID;
    HRESULT hr;
    WORD  cbTargetAcctName;
    // char szTargetAcctName[ cbTargetAcctName ];  // ASCII string null terminated
};

struct P_PRESENCE_ITEM
{
    ULONGLONG qwBuddyID;
    DWORD dwTitleID;
    DWORD dwState;
    ULONGLONG qwMatchSessionID;
    WORD  cbNickname;
    WORD  cbTitleStuff;
    // byte rgbNickName[];              // Binary
    // byte rgbTitleStuff[];            // Binary
};

struct P_INVITATION_ITEM
{
    ULONGLONG qwHostID;
    ULONGLONG qwMatchSessionID;
    DWORD dwTitleID;
};

struct P_INVITATION_ANSWER_ITEM
{
    ULONGLONG qwInviteeID;
    ULONGLONG qwMatchSessionID;
    WORD  wAnswer;
};

#pragma pack(pop)

#endif // __cplusplus

// ====================================================================
// XOnline Matchmaking
//

#define X_ATTRIBUTE_RESERVED1_MASK          0x70000000
#define X_ATTRIBUTE_RESERVED2_MASK          0x000F0000
#define X_ATTRIBUTE_RESERVED3_MASK          0x0F000000

#define X_MATCH_PROTOCOL_VERSION        0x01000000 // 1.0.0000
#define X_MIN_SEARCH_RESULT_COLUMNS     9

//
//  Reserved title search sproc indices
//
#define X_SSINDEX_GET_SESSION           (DWORD)-1   // special sproc to retrieve session by session id
#define X_SSINDEX_GET_ALL_SESSION_INFO  (DWORD)-2   // special sproc that retrieves all sessions for a given
                                                    // title id, as well as all session attributes

//----------------------------------------------------------------------------+
//  Structures
//

#pragma pack(push, 1)

//
// Internal search result structure
//
typedef struct
{
    ULONG               ulResultLen;
    double              fSelectionProbability;
    ULONG               ulNetworkDistance;
    ULONG               ulRank;
    XMATCH_SEARCHRESULT SearchResult;
} XMATCH_SEARCHRESULT_INTERNAL, *PXMATCH_SEARCHRESULT_INTERNAL;

//
//  This structure defines a session.  When used on the client, will be
//  included in a larger structure pre-pended with an async task struct.
//  The following structure is identical to the host advertisement wire
//  protocol.
//  The raw data for session title, application data and attributes will
//  typically follow this structure in the same area of memory, and on the
//  wire.
//
typedef struct
{
    DWORD               dwMessageLength;
    DWORD               dwProtocolVersion;
    XNKID               SessionID;
    DWORD               dwTitleID;
    XNADDR              HostAddress;
    DWORD               dwPublicAvailable;
    DWORD               dwPrivateAvailable;
    DWORD               dwPublicCurrent;
    DWORD               dwPrivateCurrent;
    DWORD               dwNumAttributes;
} XMATCH_SESSION, *PXMATCH_SESSION;

//
//  This structure defines the information returned to the client
//  after a session has been created.
//
typedef struct
{
    XNKID               SessionID;
    XNKEY               KeyExchangeKey;
} XMATCH_SESSION_INFO, *PXMATCH_SESSION_INFO;

//
//  This structure is passed up to delete a session.
//
typedef struct
{
    DWORD               dwMessageLength;
    DWORD               dwProtocolVersion;
    XNKID               SessionID;
    DWORD               dwTitleID;
} XMATCH_SESSION_DELETE, *PXMATCH_SESSION_DELETE;

//
//  This structure is the body of dead xbox requests.
//

typedef struct
{
    DWORD               dwMessageLength;
    DWORD               dwProtocolVersion;
    SGADDR              sgaddr;
} XMATCH_DEAD_XBOX, *PXMATCH_DEAD_XBOX;

//
//  This structure is the body of dead SG requests.
//

typedef struct
{
    DWORD               dwMessageLength;
    DWORD               dwProtocolVersion;
    SGADDR              sgaddr;
} XMATCH_DEAD_SG, *PXMATCH_DEAD_SG;

//
//  This structure defines the information passed to the server
//  to initiate a search for a game session.
//
typedef struct
{
    DWORD               dwMessageLength;
    DWORD               dwProtocolVersion;
    DWORD               dwTitleID;
    DWORD               dwProcedureIndex;
    DWORD               dwNumParameters;
} XMATCH_SEARCH, *PXMATCH_SEARCH;

#pragma pack(pop)


// ====================================================================
// XOnline Billing
//

//
// Wire structures can't be shared with the c# ISAPIs, so 
// this section has been moved to the top of billing.cpp. Visit us
// there at our new home!  
//

// ====================================================================
// XOnline Statistics
//

#pragma pack(push, 1)

struct XSTATS_MSG_SETDATA
{
    DWORD dwTitleId;
    ULONGLONG ullUserId;
    DWORD dwLeaderBoardType;
    DWORD dwAttrCount;
};

struct XSTATS_MSG_ATTRIBUTEDATA
{
    WORD wAttrId;
    BYTE bAttrType;

    union
    {
        BYTE bValue;
		WORD wValue;
		DWORD dwValue;
		ULONGLONG ullValue;
		float fValue;
		double dValue;             
	};        
};

#pragma pack(pop)


// ====================================================================
// Common sturctures for Kerberos pre-auth and authdata
//

//
// Xbox special ASN.1 Pre-auth data types
//
#define KRB5_PADATA_CLIENT_VERSION          132
#define KRB5_PADATA_XBOX_SERVICE_REQUEST    201
#define KRB5_PADATA_XBOX_SERVICE_ADDRESS    202
#define KRB5_PADATA_XBOX_ACCOUNT_CREATION   203

//
// SALT flags for pre-auth encryption
//
#define KERB_KDC_REQ_NONCE_CKSUM_SALT       1026
#define KERB_PA_CLIENT_VER_SALT             1027
#define KERB_PA_XBOX_SERVICE_REQUEST_SALT   1201
#define KERB_PA_XBOX_SERVICE_ADDRESS_SALT   1202
#define KERB_PA_XBOX_ACCOUNT_CREATION_SALT  1203

//
// Maximum services per logon
//
#define XONLINE_MAX_NUMBER_SERVICE 12

#define KINGDOM_SEPERATOR_CHAR ('.')
#define KINGDOM_SEPERATOR_STRING (".")

#pragma pack(push, 1)

typedef struct
{
    WORD wMajorVersion;
    WORD wMinorVersion;
    WORD wBuildNumber;
    WORD wQFENumber;
} XBOX_LIBRARY_VERSION;

//
// Pre-auth structure sent from Xbox to KDC 
// during Xbox TGS cycle.
// Encrypted with Session Key of TGT
//
typedef struct _XKERB_PA_XBOX_SERVICE_REQUEST
{
    #define XONLINE_SERVICE_REQUEST_VERSION 1
    WORD                    wServiceRequestVersion;
    BYTE					abEthernetAddr[6];
    XBOX_LIBRARY_VERSION    clientVersion;
    DWORD                   dwTitleID;
    DWORD                   dwTitleVersion;
    DWORD                   dwTitleRegion;

    //
    // Specifies the qwUserIDs in the order that they should be in
    // the returned XKERB_PA_XBOX_SERVICE_ADDRESS and XKERB_AD_XBOX.
    // The Xbox KDC will check that the qwUserIDs in this list
    // are all specified in the TGT.
    //
    ULONGLONG               qwUserID[XONLINE_MAX_LOGON_USERS];
    
    DWORD                   dwNumServices;
    DWORD                   dwServiceID[XONLINE_MAX_NUMBER_SERVICE];
} XKERB_PA_XBOX_SERVICE_REQUEST, *PXKERB_PA_XBOX_SERVICE_REQUEST;

typedef struct _XKERB_PA_XBOX_SERVICE_RESULT
{
    DWORD       dwServiceID;
    HRESULT     hr;             // S_FALSE means the service is at another site
    WORD        wServicePort;     // Only if hr == S_OK
    WORD        wReserved;
} XKERB_PA_XBOX_SERVICE_RESULT;

//
// Pre-auth structure sent from Xbox KDC 
// to Xbox client during TGS cycle reply.
// Encrypted with Session Key of TGT
//
typedef struct _XKERB_PA_XBOX_SERVICE_ADDRESS
{
    HRESULT     hr;
    HRESULT     hrUser[XONLINE_MAX_LOGON_USERS];
    // The high 16 bits of dwUserFlags should come from the UODB User Table.
    DWORD       dwUserFlags[XONLINE_MAX_LOGON_USERS];
    IN_ADDR     siteIPAddress;
    DWORD       dwNumServices;
    XKERB_PA_XBOX_SERVICE_RESULT     serviceResult[XONLINE_MAX_NUMBER_SERVICE];
} XKERB_PA_XBOX_SERVICE_ADDRESS, *PXKERB_PA_XBOX_SERVICE_ADDRESS;

//
// Pre-auth structure sent back from MACS server
// for newly created machine account
// Encrypted with online key
//
typedef struct _XKERB_PA_XBOX_ACCOUNT_CREATION
{
    ULONGLONG qwUserID;
    CHAR name[XONLINE_NAME_SIZE];
    CHAR kingdom[XONLINE_KINGDOM_SIZE];
    CHAR domain[XONLINE_USERDOMAIN_SIZE];
    CHAR realm[XONLINE_REALM_NAME_SIZE];
    BYTE key[XONLINE_KEY_LENGTH];
} XKERB_PA_XBOX_ACCOUNT_CREATION, *PXKERB_PA_XBOX_ACCOUNT_CREATION;

#define KERB_AUTH_DATA_XBOX  200

//
// auth-data structure in every TKT issued from the Xbox KDC
//
typedef struct _XKERB_AD_XBOX
{
    #define XONLINE_AUTHDATA_VERSION 1
    WORD                     wAuthDataVersion; 
    BYTE					 abEthernetAddr[6];
    DWORD                    dwAuthDataSize; 
    XBOX_LIBRARY_VERSION     clientVersion;
    DWORD                    dwTitleID;
    DWORD                    dwTitleVersion;
    DWORD                    dwTitleRegion;
    ULONGLONG                qwXboxID;
    // The high 16 bits of dwUserFlags should come from the UODB User Table.
    XUID                     users[XONLINE_MAX_LOGON_USERS]; 
    DWORD                    dwNumServices;
    DWORD                    dwServiceID[XONLINE_MAX_NUMBER_SERVICE];
} XKERB_AD_XBOX, *PXKERB_AD_XBOX;

typedef struct _XKERB_AD_XBOX_WITH_SIGNATURE
{
    BYTE                     ServerSignature[XONLINE_KEY_LENGTH];
    XKERB_AD_XBOX             authData;
} XKERB_AD_XBOX_WITH_SIGNATURE, *PXKERB_AD_XBOX_WITH_SIGNATURE;

#pragma pack(pop)

// ---------------------------------------------------------------------------------------
// XB/SG/Server shared definitions
// ---------------------------------------------------------------------------------------

#ifdef __cplusplus

#include <pshpack1.h>

struct CAuthData : public XKERB_AD_XBOX
{
    UINT            GetCb()             { return(dwAuthDataSize); }
    void            SetCb(UINT cb)      { dwAuthDataSize = (DWORD)cb; }
    UINT            GetSvcIdCount()     { return(dwNumServices); }
    DWORD *         GetSvcIdVector()    { return(dwServiceID); }
};

struct CKeyExHdr
{
    // Definitions -------------------------------------------------------------------

    #define KEYEX_TYPE_XBTOXB_INIT  0x0100  // CKeyExXbToXb | DH_GX | HMAC_SHA
    #define KEYEX_TYPE_XBTOXB_RESP  0x0101  // CKeyExXbToXb | DH_GX | HMAC_SHA
    #define KEYEX_TYPE_XBTOSG_INIT  0x0102  // CKeyExXbToSgInit | DH_GX | APREQ
    #define KEYEX_TYPE_SGTOXB_RESP  0x0103  // CKeyExSgToXbResp | DH_GX | APREP
    #define KEYEX_TYPE_NATOPEN_INIT 0x0104  // CKeyExNatOpen
    #define KEYEX_TYPE_NATOPEN_RESP 0x0105  // CKeyExNatOpen

    #define KEYEX_TYPE_DH_GX        0x0110  // diffie-hellman g^X (or g^Y)
    #define KEYEX_TYPE_HMAC_SHA     0x0111  // HMAC-SHA-1 digest (XbToXb)
    #define KEYEX_TYPE_KERB_APREQ   0x0112  // CKeyExKerbApReq (XbToSg)
    #define KEYEX_TYPE_KERB_APREP   0x0113  // CKeyExKerbApRep (SgToXb)
    #define KEYEX_TYPE_NULL_APREQ   0x0114  // CKeyExNullApReq (XbToSg; insecure; test only)
    #define KEYEX_TYPE_NULL_APREP   0x0115  // CKeyExNullApRep (SgToXb; insecure; test only)

    // Data --------------------------------------------------------------------------

    WORD            _wType;             // See KEYEX_TYPE_* above
    WORD            _cbEnt;             // Size of this entry (including header)
};

struct CKeyExXbToSgInit : public CKeyExHdr
{
    // Definitions -----------------------------------------------------------------------

    #define XSIF_CONNECTION_SERVICE 0x00000001  // Initiator requests connection service

    #define KEYEX_USER_GUEST_MASK         0x1F
    #define KEYEX_USER_PERMUTE_MASK       0x20
    #define KEYEX_USER_PERMUTATION_SHIFT     6
    
    // Data ------------------------------------------------------------------------------

    DWORD           _dwFlags;                   // See XSIF_* above
    DWORD           _dwSpiInit;                 // SPI of the initiator
    BYTE            _abNonceInit[8];            // Nonce of the initiator
    DWORD           _dwUserPerm;                // Permutation and guest bits for all 4 users
};

struct CKeyExSgToXbResp : public CKeyExHdr
{
    // Definitions -----------------------------------------------------------------------

    #define SXRF_ENCRYPT_DES        0x00000001  // SG wants DES encryption
    #define SXRF_ENCRYPT_3DES       0x00000002  // SG wants 3DES encryption

    // Data ------------------------------------------------------------------------------

    DWORD           _dwFlags;                   // See SXRF_* above
    DWORD           _dwSpiInit;                 // SPI of the initiator
    DWORD           _dwSpiResp;                 // SPI of the responder
    BYTE            _abNonceInit[8];            // Nonce of the initiator
    BYTE            _abNonceResp[8];            // Nonce of the responder
    WORD            _wXbToSgTimeoutInSecs;      // Secs of no inbound data/pulse before disconnecting
    WORD            _wXbToSgPulseTimeoutInSecs; // Secs of no outbound data/pulse before sending SECMSG_TYPE_XBTOSGPULSE
    SGADDR          _sgaddrInit;                // SGADDR assigned to the initiator
    IN_ADDR         _inaInit;                   // IP address of initiator (as seen by SG)
    WORD            _wPortInit;                 // IP port of initiator (as seen by SG)
};

struct CKeyExKerbApReq : public CKeyExHdr
{
    // Definitions -----------------------------------------------------------------------

    #define CBKERBAPREQ             800         // Maximum size of Kerberos Ap request

    // Data ------------------------------------------------------------------------------

    BYTE            _ab[CBKERBAPREQ];           // Kerberos AP request
};

struct CKeyExKerbApRep : public CKeyExHdr
{
    // Definitions -----------------------------------------------------------------------

    #define CBKERBAPREP             800         // Maximum size of Kerberos Ap reply

    // Data ------------------------------------------------------------------------------

    BYTE            _ab[CBKERBAPREP];           // Kerberos AP reply
};

struct CKeyExNullApReq : public CKeyExHdr
{
    BYTE            _abSha[20];                 // SHA of the rest of key-exchange message
    LARGE_INTEGER   _liTime;                    // Authenticator time of client
    CAuthData       _AuthData;                  // CAuthData of client
};

struct CKeyExNullApRep : public CKeyExHdr
{
    BYTE            _abSha[20];                 // SHA of the rest of key-exchange message
};

struct CSecMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    #define SECMSG_TYPE_DELETE          0x0200  // CSecMsgDelete
    #define SECMSG_TYPE_PULSE           0x0201  // CSecMsgPulse
    #define SECMSG_TYPE_XBTOSG_PULSE    0x0202  // CSecMsgXbToSgPulse
    #define SECMSG_TYPE_SGTOXB_PULSE    0x0203  // CSecMsgSgToXbPulse
    #define SECMSG_TYPE_XBTOXB_FORWARD  0x0204  // CSecMsgXbToXbForward

    // Data ------------------------------------------------------------------------------

    WORD            _wType;                     // See SECMSG_TYPE_* above
    WORD            _cbEnt;                     // Size of this entry (including header)

};

struct CSecMsgDelete : public CSecMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    #define SECMSG_DELETE_SHUTDOWN      0x0000  // Client is shutting down or logging off
    #define SECMSG_DELETE_UNREGISTER    0x0001  // Client unregistered key
    #define SECMSG_DELETE_KICK          0x0002  // Client has been kicked off the system

    // Data ------------------------------------------------------------------------------

    DWORD           _dwReason;                  // See SECMSG_DELETE_* above

};

struct CSecMsgPulse : public CSecMsgHdr
{
    // No additional data members
};

struct CSecMsgXbToSgPulse : public CSecMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    #define XBPULSE_USER_INDEX_MASK     0x03    // Specifies which user index changed
    #define XBPULSE_STATE_CHANGE        0x04    // dwUserState changed
    #define XBPULSE_XNKID_CHANGE        0x08    // xnkidSession changed
    #define XBPULSE_TDATA_CHANGE        0x10    // abTitleData changed

    // Data ------------------------------------------------------------------------------

    DWORD           _dwSeqAck;                  // Acknowledgement sequence number

    // The rest of this entry is filled with a padded series of changes.  The first byte 
    // contains the user-index (low two bits), and an indication of what else follows.
    // If the STATE_CHANGE bit is set, four bytes of dwUserState comes next.  Then if
    // the XNKID_CHANGE bit is set, eight bytes of XNKID comes next.  Then if the 
    // TDATA_CHANGE bit is set, the title data comes next.  The size of the title data
    // is encoded in one byte and the contents comes next.

};

struct CSecMsgSgToXbPulse : public CSecMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    #define SGPULSE_USER_INDEX_MASK     0x03    // Specifies which user index changed
    #define SGPULSE_QFLAGS_CHANGE       0x04    // dwQueueFlags changed

    // Data ------------------------------------------------------------------------------

    DWORD           _dwSeqAck;                  // Acknowledgement sequence number

    // The rest of this entry is filled with a padded series of changes.  The first byte
    // contains the user-index (low two bits), and an indication of what else follows.
    // If the QFLAGS_CHANGED bit is set, four bytes of dwQueueFlags comes next.

};

struct CSecMsgXbToXbForward : public CSecMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the target client

    // The rest of this entry contains the actual message being forwarded.
};

struct CSgMsgHdr
{
    // Definitions -------------------------------------------------------------------

    #define SGMSG_TYPE_AUTHDATA_REQ     0x0300  // CSgMsgAuthReq
    #define SGMSG_TYPE_AUTHDATA_REP     0x0301  // CSgMsgAuthRep
    #define SGMSG_TYPE_AUTHDATA         0x0302  // CAuthData in the payload
    #define SGMSG_TYPE_SET_QFLAGS_LAZY  0x0303  // CSgMsgSetQFlagsReq
    #define SGMSG_TYPE_SET_QFLAGS_PUSH  0x0304  // CSgMsgSetQFlagsReq
    #define SGMSG_TYPE_SET_QFLAGS_REP   0x0305  // CSgMsgSetQFlagsRep
    #define SGMSG_TYPE_KICK_REQ         0x0306  // CSgMsgKickReq
    #define SGMSG_TYPE_KICK_REP         0x0307  // CSgMsgKickRep
    #define SGMSG_TYPE_CLIENT_ADD       0x0308  // CSgMsgClient
    #define SGMSG_TYPE_CLIENT_DEL       0x0309  // CSgMsgClient
    #define SGMSG_TYPE_CLIENT_UPD       0x030A  // CSgMsgClient
    #define SGMSG_TYPE_XBTOXB_FORWARD   0x030B  // CSgMsgXbToXbForward

    // Data --------------------------------------------------------------------------

    WORD            _wType;                     // See SGMSG_TYPE_* above
    WORD            _cbEnt;                     // Size of this entry (including header)
};

struct CSgMsgAuthReq : public CSgMsgHdr
{
    DWORD           _dwReqNum;                  // Request number from requester
    IN_ADDR         _ipaZ;                      // IP address of the client on the DMZ
    WORD            _ipportZ;                   // IP port of the client on the DMZ
};

struct CSgMsgAuthRep : public CSgMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    #define CBSGAUTHREPMSG  (sizeof(CSgMsgAuthRep)+sizeof(CSgMsgHdr)+sizeof(CAuthData))

    // Data ------------------------------------------------------------------------------

    DWORD           _dwReqNum;                  // Copy of _dwReqNum from request
    IN_ADDR         _ipaI;                      // IP address of the client on the Internet
    IN_ADDR         _ipaZ;                      // IP address of the client on the DMZ
    WORD            _ipportZ;                   // IP port of the client on the DMZ
    BYTE            _fNotFound;                 // TRUE if client not found (no auth-data enclosed)
};

struct CSgMsgSetQFlagsReq : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client
    ULONGLONG       _qwUserId;                  // User Id of the user
    DWORD           _dwQFlags;                  // User flags to set
    DWORD           _dwSeqQFlags;               // Sequence number of this update
};

struct CSgMsgSetQFlagsRep : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client
    ULONGLONG       _qwUserId;                  // User id of the user
    DWORD           _dwSeqQFlags;               // Sequence number of this update
    BYTE            _fNotFound;                 // TRUE if client not found
    BYTE            _fNoSuchUser;               // TRUE if SG doesn't know about qwUserId
};

struct CSgMsgKickReq : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client to kick
};

struct CSgMsgKickRep : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the client that was kicked
    BYTE            _fNotFound;                 // TRUE if client not found
};

struct CSgMsgClient : public CSgMsgHdr
{
    // Definitions -----------------------------------------------------------------------

    struct CUpdate
    {
        ULONGLONG   _qwUserId;                  // User Id of the user
        DWORD       _dwPState;                  // Presence state
        XNKID       _xnkid;                     // Game session user is currently playing
        UINT        _cbData;                    // Count of bytes of title data
        BYTE        _abData[MAX_TITLE_STATE_BYTES]; // Custom presence title data
    };

    // Data ------------------------------------------------------------------------------

    SGADDR          _sgaddr;                    // SGADDR of the client
    IN_ADDR         _inaI;                      // IN_ADDR of the client
    IN_ADDR         _inaZ;                      // NAT'd IN_ADDR of the client

    // The rest of this entry contains a series of CUpdate records associated with the client,
    // if the type is SGMSG_TYPE_CLIENT_UPD.
};

struct CSgMsgXbToXbForward : public CSgMsgHdr
{
    SGADDR          _sgaddr;                    // SGADDR of the target client
    
    // The rest of this entry contains the actual message being forwarded.
};

#include <poppack.h>

#endif // __cplusplus

//@@BEGIN_CLIENTONLY

// ---------------------------------------------------------------------------------------
// XOnline Api List
// ---------------------------------------------------------------------------------------

#define XONLINEAPILIST() \
    XONAPI_(HRESULT,                XOnlineStartup, (PXONLINE_STARTUP_PARAMS pxosp), (pxosp)) \
    XONAPI_(HRESULT,                XOnlineCleanup, (), ()) \
    XONAPI (HRESULT,                XOnlineTaskContinue, (XONLINETASK_HANDLE hTask), (hTask)) \
    XONAPI (HRESULT,                XOnlineTaskClose, (XONLINETASK_HANDLE hTask), (hTask)) \
    XONAPI (HRESULT,                XOnlineGetUsers, (PXONLINE_USER pUsers, DWORD * pcUsers), (pUsers, pcUsers)) \
    XONAPI (XPININPUTHANDLE,        XOnlinePINStartInput, (PXINPUT_STATE pInputState), (pInputState)) \
    XONAPI (HRESULT,                XOnlinePINDecodeInput, (XPININPUTHANDLE handle, PXINPUT_STATE pInputState, PBYTE pPINByte), (handle, pInputState, pPINByte)) \
    XONAPI (HRESULT,                XOnlinePINEndInput, (XPININPUTHANDLE handle), (handle)) \
    XONAPI (HRESULT,                XOnlineLogon, (PXONLINE_USER pUsers, DWORD* pdwServiceIDs, DWORD cServices, HANDLE hEvent, PXONLINETASK_HANDLE pHandle), (pUsers, pdwServiceIDs, cServices, hEvent, pHandle)) \
    XONAPI (HRESULT,                XOnlineLogonTaskGetResults, (XONLINETASK_HANDLE hLogonTask), (hLogonTask)) \
    XONAPI (PXONLINE_USER,          XOnlineGetLogonUsers, (), ()) \
    XONAPI (HRESULT,                XOnlineGetServiceInfo, (DWORD dwServiceID, PXONLINE_SERVICE_INFO pServiceInfo), (dwServiceID, pServiceInfo)) \
    XONAPI (DWORD,                  XOnlineLaunchNewImage, (LPCSTR lpImagePath, PLAUNCH_DATA pLaunchData), (lpImagePath, pLaunchData)) \
    XONAPI (HRESULT,                XOnlineTitleUpdate, (DWORD dwContext), (dwContext)) \
    XONAPI (HRESULT,                XOnlineTitleUpdateFromDVD, (DWORD dwContext, PSTR szUpdatePath, DWORD dwTitleId, PBYTE pbSymmetricKey, DWORD cbSymmetricKey, PBYTE pbPublicKey, DWORD cbPublicKey), (dwContext, szUpdatePath, dwTitleId, pbSymmetricKey, cbSymmetricKey, pbPublicKey, cbPublicKey)) \
    XONAPI (HRESULT,                XOnlineTitleUpdateInternal, (DWORD dwTitleId, DWORD dwTitleOldVersion, PBYTE pbTitleKey, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (dwTitleId, dwTitleOldVersion, pbTitleKey, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineTitleUpdateFromDVDInternal, (PSTR szUpdatePath, DWORD dwTitleId, DWORD dwTitleOldVersion, PBYTE pbTitleKey, PBYTE pbSymmetricKey, DWORD cbSymmetricKey, PBYTE pbPublicKey, DWORD cbPublicKey, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (szUpdatePath, dwTitleId, dwTitleOldVersion, pbTitleKey, pbSymmetricKey, cbSymmetricKey, pbPublicKey, cbPublicKey, hWorkEvent, phTask))\
    XONAPI (HRESULT,                XOnlineTitleUpdateGetProgress, (XONLINETASK_HANDLE hTask, DWORD * pdwPercentDone, ULONGLONG *pqwNumerator, ULONGLONG *pqwDenominator), (hTask, pdwPercentDone, pqwNumerator, pqwDenominator)) \
    XONAPI (HRESULT,                XOnlineOfferingPurchase, (DWORD dwUserIndex, XONLINEOFFERING_ID OfferingId, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwUserIndex, OfferingId, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineOfferingCancel, (DWORD dwUserIndex, XONLINEOFFERING_ID OfferingId, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwUserIndex, OfferingId, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineOfferingGetDetails, (DWORD dwUserIndex, XONLINEOFFERING_ID OfferingId, WORD wLanguage, DWORD dwDescriptionIndex, PBYTE pbBuffer, DWORD cbBuffer, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwUserIndex, OfferingId, wLanguage, dwDescriptionIndex, pbBuffer, cbBuffer, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineOfferingDetailsGetResults, (XONLINETASK_HANDLE hTask, PBYTE * pDetailsBuffer, DWORD * pcbDetailsLength, XONLINE_PRICE * pGrossPrice, XONLINE_PRICE * pNetPrice), (hTask, pDetailsBuffer, pcbDetailsLength, pGrossPrice, pNetPrice)) \
    XONAPI (DWORD,                  XOnlineOfferingDetailsMaxSize, (DWORD cbTitleSpecificDataMaxSize), (cbTitleSpecificDataMaxSize)) \
    XONAPI (HRESULT,                XOnlineOfferingPriceFormat, (XONLINE_PRICE * Price, LPWSTR lpwszFormattedPrice, DWORD *cbLength, DWORD dwExtendedCharsFilter), (Price, lpwszFormattedPrice, cbLength, dwExtendedCharsFilter)) \
    XONAPI (HRESULT,                XOnlineOfferingVerifyLicense, (DWORD dwOfferingId, DWORD dwUserAccounts, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwOfferingId, dwUserAccounts, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineOfferingEnumerate, (XONLINEOFFERING_ENUM_DEVICE Device, DWORD dwUserIndex, PXONLINEOFFERING_ENUM_PARAMS pEnumParams, PBYTE pbBuffer, DWORD cbBuffer, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask), (Device, dwUserIndex, pEnumParams, pbBuffer, cbBuffer, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineOfferingEnumerateGetResults, (XONLINETASK_HANDLE hTask, PXONLINEOFFERING_INFO **prgpOfferingInfo, DWORD *pdwReturnedResults, BOOL *pfMoreResults), (hTask, prgpOfferingInfo, pdwReturnedResults, pfMoreResults)) \
    XONAPI (DWORD,                  XOnlineOfferingEnumerateMaxSize, (PXONLINEOFFERING_ENUM_PARAMS pEnumParams, DWORD cbTitleSpecificDataMaxSize), (pEnumParams, cbTitleSpecificDataMaxSize)) \
    XONAPI (HRESULT,                XOnlineFriendsGetResults, (DWORD *pdwUserIndex, XUID *pxuidTargetUser), (pdwUserIndex, pxuidTargetUser)) \
    XONAPI (HRESULT,                XOnlineContentInstall, (XONLINEOFFERING_ID OfferingId, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (OfferingId, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineContentInstallFromDVD, (PSTR szResourcePath, DWORD dwTitleId, XONLINEOFFERING_ID OfferingId, DWORD dwBitFlags, PBYTE pbSymmetricKey, DWORD cbSymmetricKey, PBYTE pbPublicKey, DWORD cbPublicKey, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask), (szResourcePath, dwTitleId, OfferingId, dwBitFlags, pbSymmetricKey, cbSymmetricKey, pbPublicKey, cbPublicKey, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineContentInstallGetProgress, (XONLINETASK_HANDLE hTask, DWORD * pdwPercentDone, ULONGLONG *pqwNumerator, ULONGLONG *pqwDenominator), (hTask, pdwPercentDone, pqwNumerator, pqwDenominator)) \
    XONAPI (HRESULT,                XOnlineContentVerify, (XONLINEOFFERING_ID OfferingId, PBYTE pbBuffer, DWORD * pcbBuffer, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (OfferingId, pbBuffer, pcbBuffer, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineContentRemove, (XONLINEOFFERING_ID OfferingId, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (OfferingId, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineContentGetRootDirectory, (XONLINEOFFERING_ID OfferingId, BOOL fUserData, DWORD * pcbRootDirectory, CHAR * szRootDirectory), (OfferingId, fUserData, pcbRootDirectory, szRootDirectory)) \
    XONAPI (HRESULT,                XOnlineMatchSessionCreate, (DWORD dwPublicCurrent, DWORD dwPublicAvailable, DWORD dwPrivateCurrent, DWORD dwPrivateAvailable, DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (dwPublicCurrent, dwPublicAvailable, dwPrivateCurrent, dwPrivateAvailable, dwNumAttributes, pAttributes, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineMatchSessionUpdate, (XNKID SessionID, DWORD dwPublicCurrent, DWORD dwPublicAvailable, DWORD dwPrivateCurrent, DWORD dwPrivateAvailable, DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (SessionID, dwPublicCurrent, dwPublicAvailable, dwPrivateCurrent, dwPrivateAvailable, dwNumAttributes, pAttributes, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineMatchSessionGetInfo, (XONLINETASK_HANDLE hTask, XNKID * pSessionID, XNKEY * pKeyExchangeKey), (hTask, pSessionID, pKeyExchangeKey)) \
    XONAPI (HRESULT,                XOnlineMatchSessionDelete, (XNKID SessionID, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (SessionID, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineMatchSessionFindFromID, (XNKID SessionID, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (SessionID, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineMatchSearch, (DWORD dwProcedureIndex, DWORD dwNumResults, DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes, DWORD dwResultsLen, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (dwProcedureIndex, dwNumResults, dwNumAttributes, pAttributes, dwResultsLen, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineMatchSearchGetResults, (XONLINETASK_HANDLE hTask, PXMATCH_SEARCHRESULT ** prgpSearchResults, DWORD * pdwReturnedResults), (hTask, prgpSearchResults, pdwReturnedResults)) \
    XONAPI (HRESULT,                XOnlineMatchSearchParse, (PXMATCH_SEARCHRESULT pSearchResult, DWORD dwNumSessionAttributes, PXONLINE_ATTRIBUTE_SPEC pSessionAttributeSpec, PVOID pQuerySession), (pSearchResult, dwNumSessionAttributes, pSessionAttributeSpec, pQuerySession)) \
    XONAPI (BOOL,                   XOnlineNotificationSetState, (DWORD dwUserIndex, DWORD dwStateFlags, XNKID sessionID, DWORD cbStateData, PBYTE pStateData), (dwUserIndex, dwStateFlags, sessionID, cbStateData, pStateData)) \
    XONAPI (HRESULT,                XOnlineNotificationSetUserData, (DWORD dwUserIndex, DWORD cbUserData, PBYTE pUserData, HANDLE hEvent, PXONLINETASK_HANDLE phTask), (dwUserIndex, cbUserData, pUserData, hEvent, phTask)) \
    XONAPI (BOOL,                   XOnlineNotificationIsPending, (DWORD dwUserIndex, DWORD dwType), (dwUserIndex, dwType)) \
    XONAPI (HRESULT,                XOnlineNotificationEnumerate, (DWORD dwUserIndex, PXONLINE_NOTIFICATION_MSG pbBuffer, WORD wBufferCount, DWORD dwNotificationTypes, HANDLE hEvent, PXONLINETASK_HANDLE phTask), (dwUserIndex, pbBuffer, wBufferCount, dwNotificationTypes, hEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineFriendsStartup, (HANDLE hEvent, PXONLINETASK_HANDLE phTask), (hEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineFriendsEnumerate, (DWORD dwUserIndex, HANDLE hEvent, PXONLINETASK_HANDLE phTask), (dwUserIndex, hEvent, phTask)) \
    XONAPI (DWORD,                  XOnlineFriendsGetLatest, (DWORD dwUserIndex, DWORD dwFriendBufferCount, PXONLINE_FRIEND pFriendBuffer), (dwUserIndex, dwFriendBufferCount, pFriendBuffer)) \
    XONAPI (HRESULT,                XOnlineFriendsRemove, (DWORD dwUserIndex, PXONLINE_FRIEND pFriend), (dwUserIndex, pFriend)) \
    XONAPI (HRESULT,                XOnlineFriendsRequest, (DWORD dwUserIndex, XUID xuidToUser), (dwUserIndex, xuidToUser)) \
    XONAPI (HRESULT,                XOnlineFriendsRequestByName, (DWORD dwUserIndex, PSTR pszUserName), (dwUserIndex, pszUserName)) \
    XONAPI (HRESULT,                XOnlineFriendsGameInvite, (DWORD dwUserIndex, XNKID SessionID, DWORD dwFriendListCount, PXONLINE_FRIEND pToFriendList), (dwUserIndex, SessionID, dwFriendListCount, pToFriendList)) \
    XONAPI (HRESULT,                XOnlineFriendsRevokeGameInvite, (DWORD dwUserIndex, XNKID SessionID, DWORD dwFriendListCount, PXONLINE_FRIEND pToFriendList), (dwUserIndex, SessionID, dwFriendListCount, pToFriendList)) \
    XONAPI (HRESULT,                XOnlineFriendsAnswerRequest, (DWORD dwUserIndex, PXONLINE_FRIEND pToFriend, XONLINE_REQUEST_ANSWER_TYPE Answer), (dwUserIndex, pToFriend, Answer)) \
    XONAPI (HRESULT,                XOnlineFriendsAnswerGameInvite, (DWORD dwUserIndex, PXONLINE_FRIEND pToFriend, XONLINE_GAMEINVITE_ANSWER_TYPE Answer), (dwUserIndex, pToFriend, Answer)) \
    XONAPI (HRESULT,                XOnlineFriendsGetAcceptedGameInvite, (HANDLE hEvent, PXONLINETASK_HANDLE phTask), (hEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineFriendsGetAcceptedGameInviteResult, (XONLINETASK_HANDLE hTask, PXONLINE_ACCEPTED_GAMEINVITE pAcceptedGameInvite), (hTask, pAcceptedGameInvite)) \
    XONAPI (DWORD,                  XOnlineLockoutlistGet, (DWORD dwUserIndex, DWORD dwLockoutUserBufferCount, PXONLINE_LOCKOUTUSER pLockoutUserBuffer), (dwUserIndex, dwLockoutUserBufferCount, pLockoutUserBuffer)) \
    XONAPI (HRESULT,                XOnlineLockoutlistStartup, (HANDLE hEvent, PXONLINETASK_HANDLE phTask), (hEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineLockoutlistAdd, (DWORD dwUserIndex, XUID xUserID, CHAR *pszUsername), (dwUserIndex, xUserID, pszUsername)) \
    XONAPI (HRESULT,                XOnlineLockoutlistRemove, (DWORD dwUserIndex, XUID xUserID), (dwUserIndex, xUserID)) \
    XONAPI (HRESULT,                XOnlineFeedbackSend, (DWORD dwUserIndex, XUID xTargetUser, XONLINE_FEEDBACK_TYPE FeedbackType, LPCWSTR lpszNickname, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (dwUserIndex, xTargetUser, FeedbackType, lpszNickname, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineEnumerateTitlesBegin, (DWORD dwMaxResults, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwMaxResults, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineEnumerateTitlesContinue, (XONLINETASK_HANDLE hTask), (hTask)) \
    XONAPI (HRESULT,                XOnlineEnumerateTitlesGetResults, (XONLINETASK_HANDLE hTask, DWORD ** prgTitleID, DWORD * pdwTitleID), (hTask, prgTitleID, pdwTitleID)) \
    XONAPI (HRESULT,                XOnlineDownloadToMemory, (DWORD dwServiceID, LPCSTR szResourcePath, PBYTE pbBuffer, DWORD cbBuffer, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, DWORD dwTimeout, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwServiceID, szResourcePath, pbBuffer, cbBuffer, pbExtraHeaders, cbExtraHeaders, dwTimeout, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineDownloadFile, (DWORD dwServiceID, LPCSTR szResourcePath, PBYTE pbBuffer, DWORD cbBuffer, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, DWORD dwFlags, LPCSTR szLocalPath, DWORD dwTimeout, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwServiceID, szResourcePath, pbBuffer, cbBuffer, pbExtraHeaders, cbExtraHeaders, dwFlags, szLocalPath, dwTimeout, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineDownloadGetProgress, (XONLINETASK_HANDLE hTask, DWORD * pdwPercentDone, ULARGE_INTEGER * puliNumerator, ULARGE_INTEGER * puliDenominator), (hTask, pdwPercentDone, puliNumerator, puliDenominator)) \
    XONAPI (HRESULT,                XOnlineDownloadGetResults, (XONLINETASK_HANDLE hTask, LPBYTE * ppbBuffer, DWORD * pcbBuffer, ULARGE_INTEGER * puliTotalReceived, ULARGE_INTEGER * puliContentLength, DWORD * pdwExtendedStatus, FILETIME * pftTimestamp, FILETIME * pftLastModified), (hTask, ppbBuffer, pcbBuffer, puliTotalReceived, puliContentLength, pdwExtendedStatus, pftTimestamp, pftLastModified)) \
    XONAPI (HRESULT,                XOnlineUploadFromMemory, (DWORD dwServiceID, LPCSTR szTargetPath, PBYTE pbBuffer, DWORD * pcbBuffer, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, PBYTE pbDataToUpload, DWORD cbDataToUpload, DWORD dwTimeout, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwServiceID, szTargetPath, pbBuffer, pcbBuffer, pbExtraHeaders, cbExtraHeaders, pbDataToUpload, cbDataToUpload, dwTimeout, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineUploadFile, (DWORD dwServiceID, LPCSTR szTargetPath, PBYTE pbBuffer, DWORD * pcbBuffer, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, LPCSTR szLocalPath, DWORD dwTimeout, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask), (dwServiceID, szTargetPath, pbBuffer, pcbBuffer, pbExtraHeaders, cbExtraHeaders, szLocalPath, dwTimeout, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineUploadGetProgress, (XONLINETASK_HANDLE hTask, DWORD * pdwPercentDone, ULARGE_INTEGER * puliNumerator, ULARGE_INTEGER * puliDenominator), (hTask, pdwPercentDone, puliNumerator, puliDenominator)) \
    XONAPI (HRESULT,                XOnlineUploadGetResults, (XONLINETASK_HANDLE hTask, LPBYTE * ppbBuffer, DWORD * pcbBuffer, ULARGE_INTEGER * puliTotalReceived, ULARGE_INTEGER * puliContentLength, DWORD * pdwExtendedStatus, FILETIME * pftTimestamp), (hTask, ppbBuffer, pcbBuffer, puliTotalReceived, puliContentLength, pdwExtendedStatus, pftTimestamp)) \
    XONAPI (HRESULT,                XOnlineVerifyNickname, (LPCWSTR lpszNickname,  HANDLE hEvent, PXONLINETASK_HANDLE phTask), (lpszNickname, hEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineStatSet, (DWORD dwNumStatSpecs, PXONLINE_STAT_SPEC pStatSpecs, HANDLE hWorkEvent,	PXONLINETASK_HANDLE phTask), (dwNumStatSpecs, pStatSpecs, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineStatGet, (DWORD dwNumStatSpecs, PXONLINE_STAT_SPEC pStatSpecs, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (dwNumStatSpecs, pStatSpecs,  hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineStatLeaderEnumerate, (XUID* pxuidPagePivot, DWORD dwPageStart, DWORD dwPageSize, DWORD dwLeaderboardID, DWORD dwNumStatsPerUser, DWORD *pStatsPerUser, PXONLINE_STAT_USER pUsers, PXONLINE_STAT pStats, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask), (pxuidPagePivot, dwPageStart, dwPageSize, dwLeaderboardID, dwNumStatsPerUser, pStatsPerUser, pUsers, pStats, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                XOnlineStatLeaderEnumerateGetResults, (XONLINETASK_HANDLE hTask, DWORD *pdwReturnedResults), (hTask, pdwReturnedResults)) \
    XONAPI (HRESULT,                _XOnlineGetMachineID, (ULONGLONG* pqwMachineID), (pqwMachineID)) \
    XONAPI (HRESULT,                _XOnlineGetSerialNumber, (CHAR abSerialNumber[12]), (abSerialNumber)) \
    XONAPI (HRESULT,                _XOnlineGetUsersFromHD, (PXONLINE_USER pUsers, DWORD *pcUsers), (pUsers, pcUsers)) \
    XONAPI (HRESULT,                _XOnlineGetUserFromMU, (DWORD dwPort, DWORD dwSlot, PXONLINE_USER pUser), (dwPort, dwSlot, pUser)) \
    XONAPI (HRESULT,                _XOnlineAddUserToHD, (PXONLINE_USER pUser), (pUser)) \
    XONAPI (HRESULT,                _XOnlineSetUserInMU, (CHAR chDrive, PXONLINE_USER pUser), (chDrive, pUser)) \
    XONAPI (HRESULT,                _XOnlineRemoveUserFromHD, (PXONLINE_USER pUser), (pUser)) \
    XONAPI (BOOL,                   _XOnlineIsUserCredentialPresent, (PXONLINE_USER pUser), (pUser)) \
    XONAPI (HRESULT,                _XOnlineOverrideInfo, (LPSTR pszXOnlineIniFile), (pszXOnlineIniFile)) \
    XONAPI (DWORD,                  _XOnlineSetTitleId, (DWORD dwTitleId), (dwTitleId)) \
    XONAPI (DWORD,                  _XOnlineSetTitleVersion, (DWORD dwTitleVersion), (dwTitleVersion)) \
    XONAPI (DWORD,                  _XOnlineSetTitleGameRegion, (DWORD dwTitleGameRegion), (dwTitleGameRegion)) \
    XONAPI (HRESULT,                _XOnlineAccountTempCreate, (PXONLINE_USER pUser, HANDLE hEvent, PXONLINETASK_HANDLE phTask), (pUser, hEvent, phTask)) \
    XONAPI (HRESULT,                _XOnlineAccountTempCreateGetResults, (XONLINETASK_HANDLE hTask, PXONLINE_USER pUser), (hTask, pUser)) \
    XONAPI (HRESULT,                _XOnlineGetTags, (WORD wCountryId, WORD wMaxTags, LPCWSTR pwsName, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask), (wCountryId, wMaxTags, pwsName, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                _XOnlineGetTagsResults, (XONLINETASK_HANDLE hTask, LPWSTR* prgszTags, WORD* pwTagCount), (hTask, prgszTags, pwTagCount)) \
    XONAPI (HRESULT,                _XOnlineReserveName, (LPCWSTR pwsGamerName, LPCWSTR pwsRealm, WORD wMaxNames, WORD wCountryId, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask), (pwsGamerName, pwsRealm, wMaxNames, wCountryId, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                _XOnlineGetReserveNameResults, (XONLINETASK_HANDLE hTask, PUSER_XNAME* ppNames, DWORD* pdwNameCount), (hTask, ppNames, pdwNameCount)) \
    XONAPI (HRESULT,                _XOnlineCreateAccount, (USER_ACCOUNT_INFO* pAccountInfo, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask), (pAccountInfo, hWorkEvent, phTask)) \
    XONAPI (HRESULT,                _XOnlineGetCreateAccountResults, (XONLINETASK_HANDLE hTask, PXONLINE_USER pUser), (hTask, pUser)) \
    
// If the compiler chokes on the following macro expansion, it means that one or more
// of the prototypes defined in this file is out of sync with the prototype in XONLINEAPILIST.

#undef  XONAPI
#define XONAPI(ret, fname, arglist, paramlist) XBOXAPI ret WINAPI fname arglist;
#undef  XONAPI_
#define XONAPI_(ret, fname, arglist, paramlist) XBOXAPI ret WINAPI fname arglist;

XONLINEAPILIST()

// ---------------------------------------------------------------------------------------
// CXOnline
// ---------------------------------------------------------------------------------------

#if defined(__cplusplus) && defined(XNETAPILIST)

class CXOnline : public CXNet
{
    friend class __single_inheritance CXo;

public:

    // Constructor -----------------------------------------------------------------------

    #ifdef _XBOX
        __forceinline CXOnline(char * pszXbox = NULL) : CXNet(pszXbox) {}
        #define _XONAPI_ WINAPI
    #else
        __forceinline CXOnline(char * pszXbox = NULL) : CXNet(pszXbox) { _pXo = NULL; }
        __forceinline CXo *  GetXo()    { return(_pXo); }
        __forceinline CXo ** GetXoRef() { return(&_pXo); }
        #define _XONAPI_ CXOnline::
    #endif

    // API -------------------------------------------------------------------------------

    #undef  XONAPI
    #undef  XONAPI_

    #ifdef _XBOX
        #define XONAPI(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
        #define XONAPI_(ret, fname, arglist, paramlist) __forceinline ret fname arglist { return(::fname paramlist); }
    #else
        #define XONAPI(ret, fname, arglist, paramlist) ret fname arglist;
        #define XONAPI_(ret, fname, arglist, paramlist) ret fname arglist;
    #endif

    XONLINEAPILIST()

    // Data ------------------------------------------------------------------------------

private:

    #ifndef _XBOX
        CXo *   _pXo;
    #endif

};

#endif

//@@END_CLIENTONLY
//@@END_MSINTERNAL

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xboxverp.h ===
/****************************************************************************
 *                                                                          *
 *      XboxVerP.H      -- Version information for internal builds          *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */
/* the VER_PRODUCTBUILD lines must contain the product          */
/* comments (Win9x or NT) and end with the build#<CR><LF>       */
/*                                                              */
/* the VER_PRODUCTBETA_STR lines must  contain the product      */
/* comments (Win9x or NT) and end with "some string"<CR><LF>    */
/*--------------------------------------------------------------*/

#if _MSC_VER > 1000 && !defined(SKIP_XBOXVERP_PRAGMA)
#pragma once
#endif

#define VER_PRODUCTBUILD_QFE        1
#define VER_PRODUCTBUILD            4400        // Must be greater than Windows 2000 gold
#define VER_PRODUCTBETA_STR         ""
#define VER_PRODUCTVERSION_STRING   "1.00"      // Not sure this will work, might have problems being less than NT5
#define VER_PRODUCTVERSION          1,00,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0100)
#define VER_PRODUCTVERSION_DW       (0x01000000 | VER_PRODUCTBUILD)

#define VER_WEB_YEAR_MONTH          02apr       // Format: YYmmm (Used for website URLs on xds.xbox.com for the current relnotes)

/* Define the _XTL_VER constant that will end up in xtl.h */
#if 0
#define _XTL_VER                   4400        // xtl
#endif

/* Define the minimum library version that we will approve (3911 == August Final). */
#define MINIMUM_APPROVED_XTL_VER    3911

/*--------------------------------------------------------------*/
/* this value is used by third party drivers build with the DDK */
/* and internally, to avoid version number conflicts.           */
/*--------------------------------------------------------------*/
#define VER_DDK_PRODUCTVERSION       5,01       // Leave this 5 so we don't not install over NT drivers
#define VER_DDK_PRODUCTVERSION_STR  "5.01"

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD#x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#if OFFICIAL_BUILD
#define VER_PRIVATE                 0
#else
#define VER_PRIVATE                 VS_FF_PRIVATEBUILD
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG|VER_PRIVATE)

// @@BEGIN_DDKSPLIT
#if 0
// @@END_DDKSPLIT
#define VER_COMPANYNAME_STR         "Windows (R) Xbox DDK provider"
#define VER_PRODUCTNAME_STR         "Windows (R) Xbox DDK driver"
#define VER_LEGALTRADEMARKS_STR     \
"Windows (R) is a registered trademark of Microsoft Corporation."
// @@BEGIN_DDKSPLIT
#else

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) Xbox(TM)"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Xbox(TM) is a trademark of Microsoft Corporation."
#endif
// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xvoicep.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xvoice.h
 *  Content:    Voice include file
//@@BEGIN_MSINTERNAL
 *  History:
 *  Date        By          Reason
 *  =====       =======     ==================================================
 //@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __XVOICE__
#define __XVOICE__

#ifdef __cplusplus
extern "C" {
#endif

const HRESULT QUEUE_S_OK             = S_OK;
const HRESULT QUEUE_E_FAIL           = E_FAIL;
const HRESULT QUEUE_E_OUTOFMEMORY    = E_OUTOFMEMORY;
const HRESULT QUEUE_E_NOINPUTYET     = 0x8000000A;
const HRESULT QUEUE_E_HWMNOTREACHED  = 0x8000000B;
const HRESULT QUEUE_E_FULL           = 0x8000000C;

XBOXAPI
HRESULT
WINAPI 
XVoiceCreateMediaObject(
       IN PXPP_DEVICE_TYPE XppDeviceType, 
	   IN DWORD dwPort, 
	   IN DWORD dwMaxAttachedPackets,
	   IN LPWAVEFORMATEX pwfxFormat, 
	   OUT LPXMEDIAOBJECT *ppMediaObject
	   );

XBOXAPI
HRESULT
WINAPI 
XVoiceEncoderCreateMediaObject(
       IN BOOL fAutoMode, 
	   IN DWORD dwCodecTag, 
	   IN LPWAVEFORMATEX pwfxEncoded, 
	   IN DWORD dwThreshold, 
	   OUT LPXMEDIAOBJECT *ppMediaObject
	   );

XBOXAPI
HRESULT
WINAPI 
XVoiceDecoderCreateMediaObject(
	   IN DWORD dwCodecTag, 
	   IN LPWAVEFORMATEX pwfxDecoded, 
	   OUT LPXMEDIAOBJECT *ppMediaObject
	   );

typedef struct _QUEUE_XMO_CONFIG {

	BYTE	cbSize;
	WORD    wVoiceSamplingRate;    
	DWORD   dwCodecTag;    
	WORD    wMsOfDataPerPacket;   
	WORD	wMaxDelay;				     
	WORD	wMinDelay;				     
	WORD	wInitialHighWaterMark;       	                                     
	DOUBLE  dIdealQuality;               
	DOUBLE  dInitialFrameStrength;       	                                     
}QUEUE_XMO_CONFIG , *LPQUEUE_XMO_CONFIG;

typedef struct _PCM_INFO {

	BYTE	cbSize;		
	INT     nMaxPower;  
}PCM_INFO , *LPPCM_INFO;

typedef struct XVoiceQueueMediaObject XVoiceQueueMediaObject , *LPXVOICEQUEUEMEDIAOBJECT;

XBOXAPI 
HRESULT 
WINAPI 
XVoiceQueueCreateMediaObject(
       IN LPQUEUE_XMO_CONFIG pConfig , 
	   OUT LPXVOICEQUEUEMEDIAOBJECT *ppVoiceQueueMediaObject
	   );

XBOXAPI
HRESULT
WINAPI 
XVoiceGetCodecBufferSize( 
       IN const LPXMEDIAOBJECT pCodecMediaObject, 
	   IN WORD wPCMBufferSize , 
	   OUT WORD *pwCodecBufferSize
	   );

#undef INTERFACE
#define INTERFACE XVoiceQueueMediaObject

DECLARE_INTERFACE_(XVoiceQueueMediaObject, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XVoiceQueueMediaObject methods
    STDMETHOD(GetLastOutputInfo)(THIS_ LPPCM_INFO pPCMInfo) PURE;
};

#define XVoiceQueueMediaObject_AddRef             IUnknown_AddRef
#define XVoiceQueueMediaObject_Release            IUnknown_Release

#define XVoiceQueueMediaObject_GetInfo            XMediaObject_GetInfo
#define XVoiceQueueMediaObject_GetStatus          XMediaObject_GetStatus
#define XVoiceQueueMediaObject_Process            XMediaObject_Process
#define XVoiceQueueMediaObject_Discontinuity      XMediaObject_Discontinuity
#define XVoiceQueueMediaObject_Flush              XMediaObject_Flush

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XVoiceQueueMediaObject_GetLastOutputInfo(p, a)    p->GetLastOutputInfo(a)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XVoiceQueueMediaObject_GetLastOutputInfo(p, a)    p->lpVtbl->GetLastOutputInfo(p, a)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

#ifdef __cplusplus
}
#endif

#endif  // __XVOICE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xrlp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:      xrl.h
 *  Content:   Xbox online XRL include file
 ***************************************************************************/

//
// XRLs are relative paths.  All XRLs must be valid XBox filesystem paths.
// No protocol information is supplied or allowed.
//

#ifndef __XRL__
#define __XRL__

#ifdef __cplusplus
extern "C" {
#endif



typedef char *XRL;
#define XRL_MAX_LEN     400


// PARSE_HEADERS_KNOWN is used to tell the parse headers function what you want to get out. Initialize
// it to zero, then only pass in pointers to values you care about.
typedef struct
{
    DWORD               dwHTTPResponseCode;
    ULARGE_INTEGER*     pContentLength;
    FILETIME*           pLastModifiedTime;
    FILETIME*           pDate;
} XRL_KNOWN_HEADERS;




//--------------------------------------------------------------------------------------------------------
// Blocking functions

HRESULT XRL_DownloadFile( const XRL xrl, DWORD cbBuffer, PBYTE pBuffer,
                                  FILETIME *pftLastModified, LPCSTR szPath, XRL_KNOWN_HEADERS *pHTTPHeaders );

HRESULT XRL_UploadFile( const XRL xrl, DWORD cbBuffer, PBYTE pBuffer,
                                  LPCSTR szPath, XRL_KNOWN_HEADERS *pHTTPHeaders );

HRESULT XRL_DownloadToMemory( const XRL xrl, DWORD* pcbBuffer, PBYTE pBuffer, XRL_KNOWN_HEADERS *pHTTPHeaders );


//@@BEGIN_MSINTERNAL

// These 3 routines are used by the SSL download routine

HRESULT XRL_LookupXRLIPAddress( XRL xrl, SOCKADDR_IN *pAddress, PXAPPSERVICEINFO pServiceInfo );

HRESULT XRL_BuildGetRequest( char* pBuffer, DWORD* pcbBuffer, XRL xrl, FILETIME* pModifiedSince, PXAPPSERVICEINFO pServiceInfo );

HRESULT XRL_ParseHeaders( char* pHeaders, DWORD cbHeaderSize, XRL_KNOWN_HEADERS* pH, PXAPPSERVICEINFO pServiceInfo );

//@@END_MSINTERNAL

#ifdef __cplusplus
}
#endif

#endif  //__XRL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3dx8.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8_H__
#define __D3DX8_H__

#include <d3d8.h>
#include <limits.h>

#include <xobjbase.h>

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#define D3DX_DEFAULT ULONG_MAX
#define D3DX_DEFAULT_FLOAT FLT_MAX

#include "d3dx8math.h"
#include "d3dx8core.h"
#include "d3dx8tex.h"
#include "d3dx8mesh.h"
#include "d3dx8shape.h"
#include "d3dx8effect.h"


#endif //__D3DX8_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\xvocver.h ===
#include <xboxverp.h>

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(push)
#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_XVoiceBuildNumberD")
__declspec(selectany) unsigned short XVoiceBuildNumberD[8] = { 'X' | ('V' << 8), 'O' | ('I' << 8), 'C' | ('E' << 8), 'D',
                                        VER_PRODUCTVERSION | 0x8000 };
#else
#pragma comment(linker, "/include:_XVoiceBuildNumber")
__declspec(selectany) unsigned short XVoiceBuildNumber[8] = { 'X' | ('V' << 8), 'O' | ('I' << 8), 'C' | ('E' << 8), 0,
                                        VER_PRODUCTVERSION | 0x0000 };
#endif

#pragma data_seg(pop)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3dx8effect.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8effect.h
//  Content:    D3DX effect types and functions
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8EFFECT_H__
#define __D3DX8EFFECT_H__


typedef enum _D3DXPARAMETERTYPE
{
    D3DXPT_DWORD        = 0,
    D3DXPT_FLOAT        = 1,
    D3DXPT_VECTOR       = 2,
    D3DXPT_MATRIX       = 3,
    D3DXPT_TEXTURE      = 4,
    D3DXPT_VERTEXSHADER = 5,
    D3DXPT_PIXELSHADER  = 6,
    D3DXPT_CONSTANT     = 7,
    D3DXPT_FORCE_DWORD  = 0x7fffffff /* force 32-bit size enum */

} D3DXPARAMETERTYPE;


typedef struct _D3DXEFFECT_DESC
{
    UINT Parameters;
    UINT Techniques;
    DWORD Usage;

} D3DXEFFECT_DESC;


typedef struct _D3DXPARAMETER_DESC
{
    DWORD Name;
    D3DXPARAMETERTYPE Type;

} D3DXPARAMETER_DESC;


typedef struct _D3DXTECHNIQUE_DESC
{
    DWORD Name;
    UINT Passes;

} D3DXTECHNIQUE_DESC;


typedef struct _D3DXPASS_DESC
{
    DWORD Name;

} D3DXPASS_DESC;


typedef struct ID3DXEffect *LPD3DXEFFECT;
typedef struct ID3DXTechnique *LPD3DXTECHNIQUE;




//////////////////////////////////////////////////////////////////////////////
// ID3DXTechnique ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// {A00F378D-AF79-4917-907E-4D635EE63844}
DEFINE_GUID( IID_ID3DXTechnique,
0xa00f378d, 0xaf79, 0x4917, 0x90, 0x7e, 0x4d, 0x63, 0x5e, 0xe6, 0x38, 0x44);


DECLARE_INTERFACE_(ID3DXTechnique, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXTechnique
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXTECHNIQUE_DESC* pDesc) PURE;
    STDMETHOD(GetPassDesc)(THIS_ UINT Index, D3DXPASS_DESC* pDesc) PURE;

    STDMETHOD_(BOOL, IsParameterUsed)(THIS_ DWORD dwName) PURE;

    STDMETHOD(Validate)(THIS) PURE;
    STDMETHOD(Begin)(THIS_ UINT *pPasses) PURE;
    STDMETHOD(Pass)(THIS_ UINT Index) PURE;
    STDMETHOD(End)(THIS) PURE;
};


//////////////////////////////////////////////////////////////////////////////
// ID3DXEffect ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


// {281BBDD4-AEDF-4907-8650-E79CDFD45165}
DEFINE_GUID( IID_ID3DXEffect,
0x281bbdd4, 0xaedf, 0x4907, 0x86, 0x50, 0xe7, 0x9c, 0xdf, 0xd4, 0x51, 0x65);


DECLARE_INTERFACE_(ID3DXEffect, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXEffect
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXEFFECT_DESC* pDesc) PURE;

    STDMETHOD(GetParameterDesc)(THIS_ UINT Index, D3DXPARAMETER_DESC* pDesc) PURE;
    STDMETHOD(GetTechniqueDesc)(THIS_ UINT Index, D3DXTECHNIQUE_DESC* pDesc) PURE;

    STDMETHOD(SetDword)(THIS_ DWORD Name, DWORD dw) PURE;
    STDMETHOD(GetDword)(THIS_ DWORD Name, DWORD* pdw) PURE;
    STDMETHOD(SetFloat)(THIS_ DWORD Name, FLOAT f) PURE;
    STDMETHOD(GetFloat)(THIS_ DWORD Name, FLOAT* pf) PURE;
    STDMETHOD(SetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector) PURE;
    STDMETHOD(GetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector) PURE;
    STDMETHOD(SetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix) PURE;
    STDMETHOD(GetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 pTexture) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 *ppTexture) PURE;
    STDMETHOD(SetVertexShader)(THIS_ DWORD Name, DWORD Handle) PURE;
    STDMETHOD(GetVertexShader)(THIS_ DWORD Name, DWORD* pHandle) PURE;
    STDMETHOD(SetPixelShader)(THIS_ DWORD Name, DWORD Handle) PURE;
    STDMETHOD(GetPixelShader)(THIS_ DWORD Name, DWORD* pHandle) PURE;

    STDMETHOD(GetTechnique)(THIS_ UINT Index, LPD3DXTECHNIQUE* ppTechnique) PURE;
    STDMETHOD(CloneEffect)(THIS_ LPDIRECT3DDEVICE8 pDevice, DWORD Usage, LPD3DXEFFECT* ppEffect) PURE;
};



//////////////////////////////////////////////////////////////////////////////
// APIs //////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//----------------------------------------------------------------------------
// D3DXCompileEffect:
// ------------------
// Compiles an ascii effect description into a binary form usable by
// D3DXCreateEffect.
//
// Parameters:
//  pSrcFile
//      Name of the file containing the ascii effect description
//  pSrcData
//      Pointer to ascii effect description
//  SrcDataSize
//      Size of the effect description in bytes
//  ppCompiledEffect
//      Returns a buffer containing compiled effect.
//  ppCompilationErrors
//      Returns a buffer containing any error messages which occurred during
//      compile.  Or NULL if you do not care about the error messages.
//
//----------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCompileEffectFromFileA(
        LPCSTR            pSrcFile,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);

#define D3DXCompileEffectFromFile D3DXCompileEffectFromFileA


HRESULT WINAPI
    D3DXCompileEffect(
        LPCVOID           pSrcData,
        UINT              SrcDataSize,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors);



//----------------------------------------------------------------------------
// D3DXCreateEffect:
// -----------------
// Creates an effect object, given compiled binary effect data
//
// Parameters:
//  pDevice
//      Pointer to the device to be used.
//  pCompiledEffect
//      Pointer to compiled effect data
//  CompiledEffectSize
//      Size of compiled effect data in bytes
//  Usage
//      Allows the specification of D3DUSAGE_SOFTWAREPROCESSING
//  ppEffect
//      Returns the created effect object
//----------------------------------------------------------------------------


HRESULT WINAPI
    D3DXCreateEffect(
        LPDIRECT3DDEVICE8 pDevice,
        LPCVOID           pCompiledEffect,
        UINT              CompiledEffectSize,
        DWORD             Usage,
        LPD3DXEFFECT*     ppEffect);



#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8EFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3d8caps.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8caps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8CAPS_H
#define _D3D8CAPS_H

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

#pragma pack(4)

typedef struct _D3DCAPS8
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT    AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture8's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture8's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture8's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture8's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture8's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth, MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   MaxPixelShaderValue;        // max value of pixel shader arithmetic component

} D3DCAPS8;

//
// BIT DEFINES FOR D3DCAPS8 DWORD MEMBERS
//

//
// Caps
//
#define D3DCAPS_READ_SCANLINE           0x00020000L

//
// Caps2
//
#define D3DCAPS2_NO2DDURING3DSCENE      0x00000002L
#define D3DCAPS2_FULLSCREENGAMMA        0x00020000L
#define D3DCAPS2_CANRENDERWINDOWED      0x00080000L
#define D3DCAPS2_CANCALIBRATEGAMMA      0x00100000L
#define D3DCAPS2_RESERVED               0x02000000L

//
// Caps3
//
#define D3DCAPS3_RESERVED               0x8000001fL

//
// PresentationIntervals
//
#define D3DPRESENT_INTERVAL_DEFAULT     0x00000000L
#define D3DPRESENT_INTERVAL_ONE         0x00000001L
#define D3DPRESENT_INTERVAL_TWO         0x00000002L
#define D3DPRESENT_INTERVAL_THREE       0x00000004L
#define D3DPRESENT_INTERVAL_FOUR        0x00000008L
#define D3DPRESENT_INTERVAL_IMMEDIATE   0x80000000L

//
// CursorCaps
//
// Driver supports HW color cursor in at least hi-res modes(height >=400)
#define D3DCURSORCAPS_COLOR             0x00000001L
// Driver supports HW cursor also in low-res modes(height < 400)
#define D3DCURSORCAPS_LOWRES            0x00000002L

//
// DevCaps
//
#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#define D3DDEVCAPS_DRAWPRIMITIVES2      0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX    0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT  0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL  0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION      0x00080000L /* Device has HW acceleration for rasterization */
#define D3DDEVCAPS_PUREDEVICE           0x00100000L /* Device supports D3DCREATE_PUREDEVICE */
#define D3DDEVCAPS_QUINTICRTPATCHES     0x00200000L /* Device supports quintic Beziers and BSplines */
#define D3DDEVCAPS_RTPATCHES            0x00400000L /* Device supports Rect and Tri patches */
#define D3DDEVCAPS_RTPATCHHANDLEZERO    0x00800000L /* Indicates that RT Patches may be drawn efficiently using handle 0 */
#define D3DDEVCAPS_NPATCHES             0x01000000L /* Device supports N-Patches */

//
// PrimitiveMiscCaps
//
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L
#define D3DPMISCCAPS_COLORWRITEENABLE   0x00000080L
#define D3DPMISCCAPS_CLIPPLANESCALEDPOINTS 0x00000100L /* Device correctly clips scaled points to clip planes */
#define D3DPMISCCAPS_CLIPTLVERTS        0x00000200L /* device will clip post-transformed vertex primitives */
#define D3DPMISCCAPS_TSSARGTEMP         0x00000400L /* device supports D3DTA_TEMP for temporary register */
#define D3DPMISCCAPS_BLENDOP            0x00000800L /* device supports D3DRS_BLENDOP */

//
// LineCaps
//
#define D3DLINECAPS_TEXTURE             0x00000001L
#define D3DLINECAPS_ZTEST               0x00000002L
#define D3DLINECAPS_BLEND               0x00000004L
#define D3DLINECAPS_ALPHACMP            0x00000008L
#define D3DLINECAPS_FOG                 0x00000010L

//
// RasterCaps
//
#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_ROP2             0x00000002L
#define D3DPRASTERCAPS_XOR              0x00000004L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_ANTIALIASEDGES   0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS    0x00002000L
#define D3DPRASTERCAPS_ZBIAS            0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR   0x00008000L
#define D3DPRASTERCAPS_FOGRANGE         0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY       0x00020000L
#define D3DPRASTERCAPS_WBUFFER          0x00040000L
#define D3DPRASTERCAPS_WFOG             0x00100000L
#define D3DPRASTERCAPS_ZFOG             0x00200000L
#define D3DPRASTERCAPS_COLORPERSPECTIVE 0x00400000L /* Device iterates colors perspective correct */
#define D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  0x00800000L

//
// ZCmpCaps, AlphaCmpCaps
//
#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

//
// SourceBlendCaps, DestBlendCaps
//
#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

//
// ShadeCaps
//
#define D3DPSHADECAPS_COLORGOURAUDRGB       0x00000008L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB    0x00000200L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND     0x00004000L
#define D3DPSHADECAPS_FOGGOURAUD            0x00080000L

//
// TextureCaps
//
#define D3DPTEXTURECAPS_PERSPECTIVE         0x00000001L /* Perspective-correct texturing is supported */
#define D3DPTEXTURECAPS_POW2                0x00000002L /* Power-of-2 texture dimensions are required - applies to non-Cube/Volume textures only. */
#define D3DPTEXTURECAPS_ALPHA               0x00000004L /* Alpha in texture pixels is supported */
#define D3DPTEXTURECAPS_SQUAREONLY          0x00000020L /* Only square textures are supported */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L /* Texture indices are not scaled by the texture size prior to interpolation */
#define D3DPTEXTURECAPS_ALPHAPALETTE        0x00000080L /* Device can draw alpha from texture palettes */
// Device can use non-POW2 textures if:
//  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
//  2) D3DRS_WRAP(N) is zero for this texture's coordinates
//  3) mip mapping is not enabled (use magnification filter only)
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L
#define D3DPTEXTURECAPS_PROJECTED           0x00000400L /* Device can do D3DTTFF_PROJECTED */
#define D3DPTEXTURECAPS_CUBEMAP             0x00000800L /* Device can do cubemap textures */
#define D3DPTEXTURECAPS_VOLUMEMAP           0x00002000L /* Device can do volume textures */
#define D3DPTEXTURECAPS_MIPMAP              0x00004000L /* Device can do mipmapped textures */
#define D3DPTEXTURECAPS_MIPVOLUMEMAP        0x00008000L /* Device can do mipmapped volume textures */
#define D3DPTEXTURECAPS_MIPCUBEMAP          0x00010000L /* Device can do mipmapped cube maps */
#define D3DPTEXTURECAPS_CUBEMAP_POW2        0x00020000L /* Device requires that cubemaps be power-of-2 dimension */
#define D3DPTEXTURECAPS_VOLUMEMAP_POW2      0x00040000L /* Device requires that volume maps be power-of-2 dimension */

//
// TextureFilterCaps
//
#define D3DPTFILTERCAPS_MINFPOINT           0x00000100L /* Min Filter */
#define D3DPTFILTERCAPS_MINFLINEAR          0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC     0x00000400L
#define D3DPTFILTERCAPS_MIPFPOINT           0x00010000L /* Mip Filter */
#define D3DPTFILTERCAPS_MIPFLINEAR          0x00020000L
#define D3DPTFILTERCAPS_MAGFPOINT           0x01000000L /* Mag Filter */
#define D3DPTFILTERCAPS_MAGFLINEAR          0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC     0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC      0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC   0x10000000L

//
// TextureAddressCaps
//
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#define D3DPTADDRESSCAPS_MIRRORONCE     0x00000020L

//
// StencilCaps
//
#define D3DSTENCILCAPS_KEEP             0x00000001L
#define D3DSTENCILCAPS_ZERO             0x00000002L
#define D3DSTENCILCAPS_REPLACE          0x00000004L
#define D3DSTENCILCAPS_INCRSAT          0x00000008L
#define D3DSTENCILCAPS_DECRSAT          0x00000010L
#define D3DSTENCILCAPS_INVERT           0x00000020L
#define D3DSTENCILCAPS_INCR             0x00000040L
#define D3DSTENCILCAPS_DECR             0x00000080L

//
// TextureOpCaps
//
#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L
#define D3DTEXOPCAPS_MULTIPLYADD                0x01000000L
#define D3DTEXOPCAPS_LERP                       0x02000000L

//
// FVFCaps
//
#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */
#define D3DFVFCAPS_PSIZE                0x00100000L /* Device can receive point size */

//
// VertexProcessingCaps
//
#define D3DVTXPCAPS_TEXGEN              0x00000001L /* device can do texgen */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L /* device can do DX7-level colormaterialsource ops */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L /* device can do directional lights */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L /* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L /* device can do local viewer */
#define D3DVTXPCAPS_TWEENING            0x00000040L /* device can do vertex tweening */
#define D3DVTXPCAPS_NO_VSDT_UBYTE4      0x00000080L /* device does not support D3DVSDT_UBYTE4 */

#pragma pack()

#endif /* _D3D8CAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\zwapi.h ===
NTSYSAPI
NTSTATUS
NTAPI
ZwContinue (
    IN PCONTEXT ContextRecord,
    IN BOOLEAN TestAlert
    );
NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    );

#define ZwAccessCheckAndAuditAlarm      NtAccessCheckAndAuditAlarm
#define ZwAdjustPrivilegesToken         NtAdjustPrivilegesToken
#define ZwAlertThread                   NtAlertThread
#define ZwAllocateVirtualMemory         NtAllocateVirtualMemory
#define ZwCancelIoFile                  NtCancelIoFile
#define ZwCancelTimer                   NtCancelTimer
#define ZwClearEvent                    NtClearEvent
#define ZwClose                         NtClose
#define ZwCloseObjectAuditAlarm         NtCloseObjectAuditAlarm
#define ZwConnectPort                   NtConnectPort
#define ZwCreateDirectoryObject         NtCreateDirectoryObject
#define ZwCreateEvent                   NtCreateEvent
#define ZwCreateFile                    NtCreateFile
#define ZwCreateKey                     NtCreateKey
#define ZwCreateSection                 NtCreateSection
#define ZwCreateSymbolicLinkObject      NtCreateSymbolicLinkObject
#define ZwCreateTimer                   NtCreateTimer
#define ZwDeleteFile                    NtDeleteFile
#define ZwDeleteKey                     NtDeleteKey
#define ZwDeleteValueKey                NtDeleteValueKey
#define ZwDeviceIoControlFile           NtDeviceIoControlFile
#define ZwDisplayString                 NtDisplayString
#define ZwDuplicateObject               NtDuplicateObject
#define ZwDuplicateToken                NtDuplicateToken
#define ZwEnumerateKey                  NtEnumerateKey
#define ZwEnumerateValueKey             NtEnumerateValueKey
#define ZwFlushBuffersFile              NtFlushBuffersFile
#define ZwFlushInstructionCache         NtFlushInstructionCache
#define ZwFlushKey                      NtFlushKey
#define ZwFlushVirtualMemory            NtFlushVirtualMemory
#define ZwFreeVirtualMemory             NtFreeVirtualMemory
#define ZwFsControlFile                 NtFsControlFile
#define ZwInitiatePowerAction           NtInitiatePowerAction
#define ZwInitializeRegistry            NtInitializeRegistry
#define ZwLoadDriver                    NtLoadDriver
#define ZwLoadKey                       NtLoadKey
#define ZwMakeTemporaryObject           NtMakeTemporaryObject
#define ZwMapViewOfSection              NtMapViewOfSection
#define ZwNotifyChangeKey               NtNotifyChangeKey
#define ZwOpenDirectoryObject           NtOpenDirectoryObject
#define ZwOpenEvent                     NtOpenEvent
#define ZwOpenFile                      NtOpenFile
#define ZwOpenKey                       NtOpenKey
#define ZwOpenProcess                   NtOpenProcess
#define ZwOpenProcessToken              NtOpenProcessToken
#define ZwOpenSection                   NtOpenSection
#define ZwOpenSymbolicLinkObject        NtOpenSymbolicLinkObject
#define ZwOpenThread                    NtOpenThread
#define ZwOpenThreadToken               NtOpenThreadToken
#define ZwOpenTimer                     NtOpenTimer
#define ZwPowerInformation              NtPowerInformation
#define ZwPulseEvent                    NtPulseEvent
#define ZwQueryDefaultLocale            NtQueryDefaultLocale
#define ZwQueryDefaultUILanguage        NtQueryDefaultUILanguage
#define ZwQueryInstallUILanguage        NtQueryInstallUILanguage
#define ZwQueryDirectoryFile            NtQueryDirectoryFile
#define ZwQueryDirectoryObject          NtQueryDirectoryObject
#define ZwQueryEaFile                   NtQueryEaFile
#define ZwQueryInformationFile          NtQueryInformationFile
#define ZwQueryInformationProcess       NtQueryInformationProcess
#define ZwQueryInformationToken         NtQueryInformationToken
#define ZwQueryInformationToken         NtQueryInformationToken
#define ZwQueryAttributesFile           NtQueryAttributesFile
#define ZwQueryKey                      NtQueryKey
#define ZwQueryObject                   NtQueryObject
#define ZwQuerySection                  NtQuerySection
#define ZwQuerySecurityObject           NtQuerySecurityObject
#define ZwQuerySymbolicLinkObject       NtQuerySymbolicLinkObject
#define ZwQuerySystemInformation        NtQuerySystemInformation
#define ZwQueryValueKey                 NtQueryValueKey
#define ZwQueryVirtualMemory            NtQueryVirtualMemory
#define ZwQueryVolumeInformationFile    NtQueryVolumeInformationFile
#define ZwRaiseHardError                NtRaiseHardError
#define ZwReadFile                      NtReadFile
#define ZwReplaceKey                    NtReplaceKey
#define ZwRequestWaitReplyPort          NtRequestWaitReplyPort
#define ZwResetEvent                    NtResetEvent
#define ZwRestoreKey                    NtRestoreKey
#define ZwSaveKey                       NtSaveKey
#define ZwSaveMergedKeys                NtSaveMergedKeys
#define ZwSetDefaultLocale              NtSetDefaultLocale
#define ZwSetDefaultUILanguage          NtSetDefaultUILanguage
#define ZwSetEaFile                     NtSetEaFile
#define ZwSetEvent                      NtSetEvent
#define ZwSetInformationFile            NtSetInformationFile
#define ZwSetInformationObject          NtSetInformationObject
#define ZwSetInformationProcess         NtSetInformationProcess
#define ZwSetInformationThread          NtSetInformationThread
#define ZwSetSecurityObject             NtSetSecurityObject
#define ZwSetSystemInformation          NtSetSystemInformation
#define ZwSetSystemPowerState           NtSetSystemPowerState
#define ZwSetSystemTime                 NtSetSystemTime
#define ZwSetTimer                      NtSetTimer
#define ZwSetValueKey                   NtSetValueKey
#define ZwSetVolumeInformationFile      NtSetVolumeInformationFile
#define ZwTerminateProcess              NtTerminateProcess
#define ZwTerminateThread               NtTerminateThread
#define ZwUnloadDriver                  NtUnloadDriver
#define ZwUnloadKey                     NtUnloadKey
#define ZwUnmapViewOfSection            NtUnmapViewOfSection
#define ZwWaitForMultipleObjects        NtWaitForMultipleObjects
#define ZwWaitForSingleObject           NtWaitForSingleObject
#define ZwWriteFile                     NtWriteFile
#define ZwWriteVirtualMemory            NtWriteVirtualMemory
#define ZwYieldExecution                NtYieldExecution
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3dx8shape.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8shapes.h
//  Content:    D3DX simple shapes
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8SHAPES_H__
#define __D3DX8SHAPES_H__

///////////////////////////////////////////////////////////////////////////
// Functions:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXCreatePolygon:
// ------------------
// Creates a mesh containing an n-sided polygon.  The polygon is centered
// at the origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Length      Length of each side.
//  Sides       Number of sides the polygon has.  (Must be >= 3)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreatePolygon(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Length,
        UINT                Sides,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateBox:
// --------------
// Creates a mesh containing an axis-aligned box.  The box is centered at
// the origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Width       Width of box (along X-axis)
//  Height      Height of box (along Y-axis)
//  Depth       Depth of box (along Z-axis)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateBox(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Width,
        FLOAT               Height,
        FLOAT               Depth,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateCylinder:
// -------------------
// Creates a mesh containing a cylinder.  The generated cylinder is
// centered at the origin, and its axis is aligned with the Z-axis.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Radius1     Radius at -Z end (should be >= 0.0f)
//  Radius2     Radius at +Z end (should be >= 0.0f)
//  Length      Length of cylinder (along Z-axis)
//  Slices      Number of slices about the main axis
//  Stacks      Number of stacks along the main axis
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCylinder(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               Radius1,
        FLOAT               Radius2,
        FLOAT               Length,
        UINT                Slices,
        UINT                Stacks,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateSphere:
// -----------------
// Creates a mesh containing a sphere.  The sphere is centered at the
// origin.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  Radius      Radius of the sphere (should be >= 0.0f)
//  Slices      Number of slices about the main axis
//  Stacks      Number of stacks along the main axis
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateSphere(
        LPDIRECT3DDEVICE8  pDevice,
        FLOAT              Radius,
        UINT               Slices,
        UINT               Stacks,
        LPD3DXMESH*        ppMesh,
        LPD3DXBUFFER*      ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateTorus:
// ----------------
// Creates a mesh containing a torus.  The generated torus is centered at
// the origin, and its axis is aligned with the Z-axis.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  InnerRadius Inner radius of the torus (should be >= 0.0f)
//  OuterRadius Outer radius of the torue (should be >= 0.0f)
//  Sides       Number of sides in a cross-section (must be >= 3)
//  Rings       Number of rings making up the torus (must be >= 3)
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTorus(
        LPDIRECT3DDEVICE8   pDevice,
        FLOAT               InnerRadius,
        FLOAT               OuterRadius,
        UINT                Sides,
        UINT                Rings,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


//-------------------------------------------------------------------------
// D3DXCreateTeapot:
// -----------------
// Creates a mesh containing a teapot.
//
// Parameters:
//
//  pDevice     The D3D device with which the mesh is going to be used.
//  ppMesh      The mesh object which will be created
//  ppAdjacency Returns a buffer containing adjacency info.  Can be NULL.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTeapot(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);


#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8SHAPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3d8.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8.h
 *  Content:    Xbox Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D8_H_
#define _D3D8_H_

#pragma warning( push )
#pragma warning( disable : 4100 ) // unreferenced formal parameter

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

#ifndef D3DINLINE
#define D3DINLINE static __forceinline
#endif

#ifndef D3DMINLINE
#define D3DMINLINE __forceinline
#endif

#define D3DFASTCALL __fastcall

/* 
 * This identifier is passed to Direct3DCreate8 in order to ensure that an
 * application was built against the correct header files. This number is
 * incremented whenever a header (or other) change would require applications
 * to be rebuilt. If the version doesn't match, Direct3DCreate8 will fail.
 * (The number itself has no meaning.)
 */

#define D3D_SDK_VERSION 0

#include <stdlib.h>

typedef struct Direct3D                  Direct3D;
typedef struct D3DDevice                 D3DDevice;
typedef struct D3DResource               D3DResource;
typedef struct D3DBaseTexture            D3DBaseTexture;
typedef struct D3DTexture                D3DTexture;
typedef struct D3DVolumeTexture          D3DVolumeTexture;
typedef struct D3DCubeTexture            D3DCubeTexture;
typedef struct D3DVertexBuffer           D3DVertexBuffer;
typedef struct D3DIndexBuffer            D3DIndexBuffer;
typedef struct D3DPalette                D3DPalette;
typedef struct D3DSurface                D3DSurface;
typedef struct D3DVolume                 D3DVolume;
typedef struct D3DPushBuffer             D3DPushBuffer;
typedef struct D3DFixup                  D3DFixup;

// Compatibility typedefs.

#define IDirect3D8                       Direct3D
#define IDirect3DDevice8                 D3DDevice
#define IDirect3DResource8               D3DResource
#define IDirect3DBaseTexture8            D3DBaseTexture
#define IDirect3DTexture8                D3DTexture
#define IDirect3DVolumeTexture8          D3DVolumeTexture
#define IDirect3DCubeTexture8            D3DCubeTexture
#define IDirect3DVertexBuffer8           D3DVertexBuffer
#define IDirect3DIndexBuffer8            D3DIndexBuffer
#define IDirect3DPalette8                D3DPalette
#define IDirect3DSurface8                D3DSurface
#define IDirect3DVolume8                 D3DVolume
#define IDirect3DPushBuffer8             D3DPushBuffer
#define IDirect3DFixup8                  D3DFixup

// Pointer typedefs.

typedef struct Direct3D                  *LPDIRECT3D8,              *PDIRECT3D8;
typedef struct D3DDevice                 *LPDIRECT3DDEVICE8,        *PDIRECT3DDEVICE8;
typedef struct D3DResource               *LPDIRECT3DRESOURCE8,      *PDIRECT3DRESOURCE8;
typedef struct D3DBaseTexture            *LPDIRECT3DBASETEXTURE8,   *PDIRECT3DBASETEXTURE8;
typedef struct D3DTexture                *LPDIRECT3DTEXTURE8,       *PDIRECT3DTEXTURE8;
typedef struct D3DVolumeTexture          *LPDIRECT3DVOLUMETEXTURE8, *PDIRECT3DVOLUMETEXTURE8;
typedef struct D3DCubeTexture            *LPDIRECT3DCUBETEXTURE8,   *PDIRECT3DCUBETEXTURE8;
typedef struct D3DVertexBuffer           *LPDIRECT3DVERTEXBUFFER8,  *PDIRECT3DVERTEXBUFFER8;
typedef struct D3DIndexBuffer            *LPDIRECT3DINDEXBUFFER8,   *PDIRECT3DINDEXBUFFER8;
typedef struct D3DPalette                *LPDIRECT3DPALETTE8,       *PDIRECT3DPALETTE8;
typedef struct D3DSurface                *LPDIRECT3DSURFACE8,       *PDIRECT3DSURFACE8;
typedef struct D3DVolume                 *LPDIRECT3DVOLUME8,        *PDIRECT3DVOLUME8;
typedef struct D3DPushBuffer             *LPDIRECT3DPUSHBUFFER8,    *PDIRECT3DPUSHBUFFER8;
typedef struct D3DFixup                  *LPDIRECT3DFIXUP8,         *PDIRECT3DFIXUP8;

#include "d3d8types.h"
#include "d3d8caps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Pass the value of the constant D3D_SDK_VERSION to this function so
 * that the run-time can validate that your application was compiled
 * against the right headers.
 *
 * The XBOX implementation of this method creates no object and always
 * returns 1 as the pointer.  The only reason to call this method
 * is to verify that your headers and libraries are in sync.  
 *
 * There is no need to store the result of this function call.  You can
 * pass 'NULL' for the Direct3D 'this' pointer as it is completely
 * ignored.
 */

Direct3D * WINAPI Direct3DCreate8(UINT SDKVersion);

/****************************************************************************
 *
 * Parameter for Direct3D Enum and GetCaps8 functions to get the info for
 * the current mode only.
 *
 ****************************************************************************/

#define D3DCURRENT_DISPLAY_MODE                 0x00EFFFFFL

/****************************************************************************
 *
 * Flags for Direct3D::CreateDevice's BehaviorFlags
 *
 ****************************************************************************/

#define D3DCREATE_PUREDEVICE                    0x00000010L
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING     0x00000020L
#define D3DCREATE_HARDWARE_VERTEXPROCESSING     0x00000040L
#define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L

// D3DCREATE_FPU_PRESERVE is not supported on Xbox
// D3DCREATE_MULTITHREADED is not supported on Xbox

/****************************************************************************
 *
 * Parameter for Direct3D::CreateDevice's Adapter
 *
 ****************************************************************************/

#define D3DADAPTER_DEFAULT                     0

/****************************************************************************
 *
 * Flags for Direct3D::EnumAdapters
 *
 ****************************************************************************/

#define D3DENUM_NO_WHQL_LEVEL                   0x00000002L

/****************************************************************************
 *
 * Maximum number of back-buffers supported in DX8
 *
 ****************************************************************************/

#define D3DPRESENT_BACK_BUFFERS_MAX             2L

/****************************************************************************
 *
 * Flags for D3DDevice::SetGammaRamp
 *
 ****************************************************************************/

#define D3DSGR_NO_CALIBRATION                  0x00000000L
#define D3DSGR_CALIBRATE                       0x00000001L
#define D3DSGR_IMMEDIATE                       0x00000002L

/****************************************************************************
 * Flags for SetPrivateData method on all D3D8 interfaces
 *
 * The passed pointer is an IUnknown ptr. The SizeOfData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). Direct3D will call AddRef through this
 * pointer and Release when the private data is destroyed. The data will be
 * destroyed when another SetPrivateData with the same GUID is set, when
 * FreePrivateData is called, or when the D3D8 object is freed.
 ****************************************************************************/

#define D3DSPD_IUNKNOWN                         0x00000001L

/*
 *  DirectDraw error codes
 */

#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

/*
 * Direct3D Errors
 */

#define D3D_OK                              S_OK

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)
#define D3DERR_TESTINCOMPLETE                   MAKE_D3DHRESULT(2088) // Xbox extension
#define D3DERR_BUFFERTOOSMALL                   MAKE_D3DHRESULT(2089) // Xbox extension

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)

/****************************************************************************
 *
 * BeginStateBlock/EndStateBlock semantics require that D3D have the ability
 * to record all API state-changing calls in a state block.  Rather than add 
 * a time-consuming are-we-recording-a-state-block check to every SetRenderState 
 * and SetTextureStageState call that would slow callers even if they never 
 * used BeginStateBlock/EndStateBlock, we've placed that logic inline so that 
 * it can be eliminated if not needed by the title.
 *
 * To enable BeginStateBlock/EndStateBlock, define the following before
 * including xtl.h.  This needs to be done for all modules that can change
 * state that should be recorded by BeginStateBlock.
 *
 *      #define D3DCOMPILE_BEGINSTATEBLOCK 1
 *
 ****************************************************************************/

typedef enum _D3DSTATEBLOCKDIRTYINDEX
{
    D3DSBD_TEXTURES              = 0, 
    D3DSBD_PIXELSHADER           = D3DSBD_TEXTURES + D3DTSS_MAXSTAGES,
    D3DSBD_VERTEXSHADER          = D3DSBD_PIXELSHADER + 1,
    D3DSBD_INDICES               = D3DSBD_VERTEXSHADER + 1,
    D3DSBD_STREAMS               = D3DSBD_INDICES + 1,
    D3DSBD_PIXELSHADERCONSTANTS  = D3DSBD_STREAMS + D3DVS_STREAMS_MAX_V1_0,
    D3DSBD_VERTEXSHADERCONSTANTS = D3DSBD_PIXELSHADERCONSTANTS + D3DPS_CONSTREG_MAX_DX8,
    D3DSBD_RENDERSTATES          = D3DSBD_VERTEXSHADERCONSTANTS + D3DVS_CONSTREG_COUNT_XBOX,
    D3DSBD_TEXTURESTATES         = D3DSBD_RENDERSTATES + D3DRS_MAX,
    D3DSBD_TRANSFORMS            = D3DSBD_TEXTURESTATES + (D3DTSS_MAXSTAGES * D3DTSS_MAX),
    D3DSBD_VIEWPORT              = D3DSBD_TRANSFORMS + D3DTS_MAX,
    D3DSBD_MATERIAL              = D3DSBD_VIEWPORT + 1,
    D3DSBD_BACKMATERIAL          = D3DSBD_MATERIAL + 1,
    D3DSBD_MAX                   = D3DSBD_BACKMATERIAL + 1,
    D3DSBD_FORCE_DWORD           = 0x7fffffff, // force 32-bit size enum
} D3DSTATEBLOCKDIRTYINDEX;

#ifdef D3DCOMPILE_BEGINSTATEBLOCK
        
    #define D3DDIRTY_TEXTURE(stage)                                         \
        { D3D__StateBlockDirty[D3DSBD_TEXTURES + (stage)] = TRUE; }
        
    #define D3DDIRTY_PIXELSHADER()                                          \
        { D3D__StateBlockDirty[D3DSBD_PIXELSHADER] = TRUE; }
        
    #define D3DDIRTY_VERTEXSHADER()                                         \
        { D3D__StateBlockDirty[D3DSBD_VERTEXSHADER] = TRUE; }
        
    #define D3DDIRTY_INDICES()                                              \
        { D3D__StateBlockDirty[D3DSBD_INDICES] = TRUE; }
        
    #define D3DDIRTY_STREAM(stream)                                         \
        { D3D__StateBlockDirty[D3DSBD_STREAMS + (stream)] = TRUE; }
        
    #define D3DDIRTY_PIXELSHADERCONSTANT(index, count)                      \
        { memset(&D3D__StateBlockDirty[D3DSBD_PIXELSHADERCONSTANTS + (index)], TRUE, (count)); }
        
    #define D3DDIRTY_VERTEXSHADERCONSTANT(index, count)                     \
        { memset(&D3D__StateBlockDirty[D3DSBD_VERTEXSHADERCONSTANTS + (index) + 96], TRUE, (count)); }
                          
    #define D3DDIRTY_RENDERSTATE(state)                                     \
        { D3D__StateBlockDirty[D3DSBD_RENDERSTATES + (state)] = TRUE; }
    
    #define D3DDIRTY_TEXTURESTATE(stage, state)                             \
        { D3D__StateBlockDirty[D3DSBD_TEXTURESTATES +                       \
                          ((state) * D3DTSS_MAXSTAGES) + (stage)] = TRUE; } 
        
    #define D3DDIRTY_TRANSFORM(transform)                                   \
        { D3D__StateBlockDirty[D3DSBD_TRANSFORMS + (transform)] = TRUE; }
        
    #define D3DDIRTY_VIEWPORT()                                             \
        { D3D__StateBlockDirty[D3DSBD_VIEWPORT] = TRUE; }
        
    #define D3DDIRTY_MATERIAL()                                             \
        { D3D__StateBlockDirty[D3DSBD_MATERIAL] = TRUE; }
        
    #define D3DDIRTY_BACKMATERIAL()                                         \
        { D3D__StateBlockDirty[D3DSBD_BACKMATERIAL] = TRUE; }
    
#else
        
    #define D3DDIRTY_TEXTURE(stage)
    #define D3DDIRTY_PIXELSHADER()                                         
    #define D3DDIRTY_VERTEXSHADER()                                        
    #define D3DDIRTY_INDICES()                                             
    #define D3DDIRTY_STREAM(stream)                                         
    #define D3DDIRTY_PIXELSHADERCONSTANT(index, count)                         
    #define D3DDIRTY_VERTEXSHADERCONSTANT(index, count)                        
    #define D3DDIRTY_RENDERSTATE(state)                                    
    #define D3DDIRTY_TEXTURESTATE(stage, state)                            
    #define D3DDIRTY_TRANSFORM(transform)                                  
    #define D3DDIRTY_VIEWPORT()
    #define D3DDIRTY_MATERIAL()                                            
    #define D3DDIRTY_BACKMATERIAL()                                            

#endif

/****************************************************************************
 *
 * __declspec(selectany) has the lovely attribute that it allows the linker
 * to remove duplicate instantiations of global declarations, and to remove
 * the instantiation entirely if unreferenced.
 *
 ****************************************************************************/

#define D3DCONST extern CONST DECLSPEC_SELECTANY

D3DCONST UINT D3DPRIMITIVETOVERTEXCOUNT[11][2] =
{
    {0, 0},         // Illegal
    {1, 0},         // D3DPT_POINTLIST     = 1,
    {2, 0},         // D3DPT_LINELIST      = 2,
    {1, 1},         // D3DPT_LINELOOP      = 3,
    {1, 1},         // D3DPT_LINESTRIP     = 4,
    {3, 0},         // D3DPT_TRIANGLELIST  = 5,
    {1, 2},         // D3DPT_TRIANGLESTRIP = 6,
    {1, 2},         // D3DPT_TRIANGLEFAN   = 7,
    {4, 0},         // D3DPT_QUADLIST      = 8,
    {2, 2},         // D3DPT_QUADSTRIP     = 9,
    {0, 0},         // Illegal (D3DPT_POLYGON)
};

D3DCONST DWORD D3DSIMPLERENDERSTATEENCODE[] =
{                                          
    0x040260,    0x040264,    0x040268,    0x04026c,    // 0
    0x040270,    0x040274,    0x040278,    0x04027c,    // 4
    0x040288,    0x04028c,    0x040a60,    0x040a64,    // 8
    0x040a68,    0x040a6c,    0x040a70,    0x040a74,    // 12
    0x040a78,    0x040a7c,    0x040a80,    0x040a84,    // 16
    0x040a88,    0x040a8c,    0x040a90,    0x040a94,    // 20
    0x040a98,    0x040a9c,    0x040aa0,    0x040aa4,    // 24
    0x040aa8,    0x040aac,    0x040ab0,    0x040ab4,    // 28
    0x040ab8,    0x040abc,    0x040ac0,    0x040ac4,    // 32
    0x040ac8,    0x040acc,    0x040ad0,    0x040ad4,    // 36
    0x040ad8,    0x040adc,    0x0417f8,    0x041e20,    // 40
    0x041e24,    0x041e40,    0x041e44,    0x041e48,    // 44
    0x041e4c,    0x041e50,    0x041e54,    0x041e58,    // 48
    0x041e5c,    0x041e60,    0x041d90,    0x041e74,    // 52
    0x041e78,    0x040354,    0x04033c,    0x040304,    // 56
    0x040300,    0x040340,    0x040344,    0x040348,    // 60
    0x04035c,    0x040310,    0x04037c,    0x040358,    // 64
    0x040374,    0x040378,    0x040364,    0x040368,    // 68
    0x04036c,    0x040360,    0x040350,    0x04034c,    // 72
    0x0409f8,    0x040384,    0x040388,    0x040330,    // 76
    0x040334,    0x040338,    
};

D3DCONST DWORD D3DTEXTUREDIRECTENCODE[] =
{ 
    0x081b00,    0x081b40,    0x081b80,    0x081bc0,
};

/****************************************************************************
 *
 * Accessible globals.
 *
 ****************************************************************************/

#ifdef __cplusplus
    #define D3DEXTERN extern "C"
#else
    #define D3DEXTERN extern
#endif

// This array marks what APIs have been called when recording state blocks:
//
D3DEXTERN BYTE D3D__StateBlockDirty[];

// This array shadows the current render states:
//
D3DEXTERN DWORD D3D__RenderState[D3DRS_MAX];

// This array shadows the current texture stage states:
//
D3DEXTERN DWORD D3D__TextureState[D3DTSS_MAXSTAGES][D3DTSS_MAX];

// Set D3D__NullHardware to TRUE to enable infinitely fast hardware (so fast 
// you can't even see the results).  If you re-enable, you'll more than likely
// crash, however.
//
D3DEXTERN BOOL D3D__NullHardware; 

// This points to the data of the currently selected index buffer:
//
D3DEXTERN WORD* D3D__IndexData;

/****************************************************************************
 *
 * Miscellaneous defines
 *
 ****************************************************************************/

// Macro for converting from primitive count to number of vertices.
//
#define D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount) \
    ((PrimitiveCount) * D3DPRIMITIVETOVERTEXCOUNT[PrimitiveType][0] + \
     + D3DPRIMITIVETOVERTEXCOUNT[PrimitiveType][1])

// The required alignment for any memory that is going to be
// rendered to from the hardware.
//
#define D3D_RENDER_MEMORY_ALIGNMENT           64

// The required alignment for any memory that is tiled, including the
// default frame buffers and depth buffer.
//
#define D3D_TILED_SURFACE_ALIGNMENT           0x4000

// Type of our DPC-level callback functions.
//
typedef void (__cdecl * D3DCALLBACK)(DWORD Context);

/*
 * NOTE: The C version of the methods for all of these interfaces
 *       are named "<interfacename>_<method name>" and have an 
 *       explicit pointer to the interface as the first parameter.
 *       The actual definition of these methods is at the end
 *       of this file.
 */

/*
 * Direct3D, IDirect3D8 interface
 *
 */

#ifdef __cplusplus

struct Direct3D
{
    static ULONG WINAPI AddRef();
    static ULONG WINAPI Release();

    static UINT WINAPI GetAdapterCount();

    static HRESULT WINAPI GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier);
    static UINT    WINAPI GetAdapterModeCount(UINT Adapter);
    static HRESULT WINAPI EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
    static HRESULT WINAPI CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
    static HRESULT WINAPI CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
    static HRESULT WINAPI CheckDepthStencilMatch(UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat);
    static HRESULT WINAPI GetDeviceCaps(UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps);
    static HRESULT WINAPI CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface);
    static HRESULT WINAPI SetPushBufferSize(DWORD PushBufferSize, DWORD KickOffSize); // Xbox extension
};

#endif __cplusplus

/*
 * D3DDevice, IDirect3DDevice8 interface
 */

#ifdef __cplusplus

struct D3DDevice
{
    static ULONG WINAPI AddRef();
    static ULONG WINAPI Release();
    static HRESULT WINAPI GetDirect3D(Direct3D **ppD3D8);
    static HRESULT WINAPI GetDeviceCaps(D3DCAPS8 *pCaps);
    static HRESULT WINAPI GetDisplayMode(D3DDISPLAYMODE *pMode);
    static HRESULT WINAPI GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters);
    static HRESULT WINAPI Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
    static HRESULT WINAPI Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2);
    static HRESULT WINAPI GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer);
    static HRESULT WINAPI GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);
    static void    WINAPI SetFlickerFilter(DWORD Filter);
    static void    WINAPI SetSoftDisplayFilter(BOOL Enable);
    static void    WINAPI SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp);
    static void    WINAPI GetGammaRamp(D3DGAMMARAMP *pRamp);
    static HRESULT WINAPI CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture);
    static HRESULT WINAPI CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture);
    static HRESULT WINAPI CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture);
    static HRESULT WINAPI CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer);
    static HRESULT WINAPI CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer);
    static HRESULT WINAPI CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette);
    static HRESULT WINAPI CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface);
    static HRESULT WINAPI CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface);
    static HRESULT WINAPI CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface);
    static HRESULT WINAPI CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray);
    static HRESULT WINAPI UpdateTexture(D3DBaseTexture *pSourceTexture, D3DBaseTexture *pDestinationTexture);
    static HRESULT WINAPI SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil);
    static HRESULT WINAPI GetRenderTarget(D3DSurface **ppRenderTarget);
    static HRESULT WINAPI GetDepthStencilSurface(D3DSurface **ppZStencilSurface);
    static HRESULT WINAPI BeginScene();
    static HRESULT WINAPI EndScene();
    static HRESULT WINAPI Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
    static HRESULT WINAPI SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    static HRESULT WINAPI GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
    static HRESULT WINAPI MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
    static HRESULT WINAPI SetViewport(CONST D3DVIEWPORT8 *pViewport);
    static HRESULT WINAPI GetViewport(D3DVIEWPORT8 *pViewport);
    static HRESULT WINAPI SetMaterial(CONST D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI GetMaterial(D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
    static HRESULT WINAPI GetLight(DWORD Index, D3DLIGHT8 *pLight);
    static HRESULT WINAPI LightEnable(DWORD Index, BOOL Enable);
    static HRESULT WINAPI GetLightEnable(DWORD Index, BOOL *pEnable);
    static HRESULT WINAPI SetRenderState(D3DRENDERSTATETYPE State, DWORD Value);
    static HRESULT WINAPI GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue);
#if D3DCOMPILE_BEGINSTATEBLOCK
    static HRESULT WINAPI BeginStateBlock();
    static HRESULT WINAPI EndStateBlock(DWORD *pToken);
#endif
    static HRESULT WINAPI ApplyStateBlock(DWORD Token);
    static HRESULT WINAPI CaptureStateBlock(DWORD Token);
    static HRESULT WINAPI DeleteStateBlock(DWORD Token);
    static HRESULT WINAPI CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);
    static HRESULT WINAPI GetTexture(DWORD Stage, D3DBaseTexture **ppTexture);
    static HRESULT WINAPI SetTexture(DWORD Stage, D3DBaseTexture *pTexture);
    static HRESULT WINAPI GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue);
    static HRESULT WINAPI SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
    static HRESULT WINAPI DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount);
    static HRESULT WINAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount);
    static HRESULT WINAPI DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
    static HRESULT WINAPI SetVertexShader(DWORD Handle);
    static HRESULT WINAPI GetVertexShader(DWORD *pHandle);
    static HRESULT WINAPI DeleteVertexShader(DWORD Handle);
    static HRESULT WINAPI SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
    static HRESULT WINAPI GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
    static HRESULT WINAPI SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride);
    static HRESULT WINAPI GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride);
    static HRESULT WINAPI SetIndices(D3DIndexBuffer *pIndexData, UINT BaseVertexIndex);
    static HRESULT WINAPI GetIndices(D3DIndexBuffer **ppIndexData, UINT *pBaseVertexIndex);
    static HRESULT WINAPI CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle);
    static HRESULT WINAPI SetPixelShader(DWORD Handle);
    static HRESULT WINAPI SetPixelShaderProgram(D3DPIXELSHADERDEF *pPSDef);
    static HRESULT WINAPI GetPixelShader(DWORD *pHandle);
    static HRESULT WINAPI DeletePixelShader(DWORD Handle);
    static HRESULT WINAPI SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
    static HRESULT WINAPI GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData);
    static HRESULT WINAPI DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
    static HRESULT WINAPI DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
    static HRESULT WINAPI DeletePatch(UINT Handle);

    // The following are all Xbox extensions:

    static HRESULT WINAPI SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode);
    static HRESULT WINAPI GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode);
    static HRESULT WINAPI LoadVertexShader(DWORD Handle, DWORD Address);
    static HRESULT WINAPI LoadVertexShaderProgram(DWORD *pFunction, DWORD Address);
    static HRESULT WINAPI SelectVertexShader(DWORD Handle, DWORD Address);
    static HRESULT WINAPI RunVertexStateShader(DWORD Address, CONST float *pData);
    static HRESULT WINAPI GetVertexShaderSize(DWORD Handle, UINT *pSize);
    static HRESULT WINAPI GetVertexShaderType(DWORD Handle, DWORD *pType);
    static HRESULT WINAPI DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount);
    static HRESULT WINAPI DrawIndexedVertices(D3DPRIMITIVETYPE, UINT VertexCount, CONST WORD *pIndexData);
    static HRESULT WINAPI DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
    static HRESULT WINAPI PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData);
    static HRESULT WINAPI GetPalette(DWORD Stage, D3DPalette **ppPalette);
    static HRESULT WINAPI SetPalette(DWORD Stage, D3DPalette *pPalette);
    static HRESULT WINAPI SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
    static HRESULT WINAPI SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value);
    static HRESULT WINAPI SetBackMaterial(CONST D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI GetBackMaterial(D3DMATERIAL8 *pMaterial);
    static HRESULT WINAPI UpdateOverlay(D3DSurface *pSurface, RECT *SrcRect, RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey);
    static HRESULT WINAPI EnableOverlay(BOOL Enable);
    static HRESULT WINAPI EnableCC(BOOL Enable);
    static HRESULT WINAPI SendCC(BOOL Field, BYTE cc1, BYTE cc2);
    static HRESULT WINAPI GetCCStatus(BOOL *pField1, BOOL *pField2);
    static HRESULT WINAPI BeginVisibilityTest();
    static HRESULT WINAPI EndVisibilityTest(DWORD Index);
    static HRESULT WINAPI GetVisibilityTestResult(DWORD Index, UINT* pResult, ULONGLONG* pTimeStamp);
    static BOOL    WINAPI GetOverlayUpdateStatus();
    static HRESULT WINAPI GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus);
    static HRESULT WINAPI SetVertexData2f(INT Register, FLOAT a, FLOAT b);
    static HRESULT WINAPI SetVertexData4f(INT Register, FLOAT a, FLOAT b, FLOAT c, FLOAT d);
    static HRESULT WINAPI SetVertexData2s(INT Register, SHORT a, SHORT b);
    static HRESULT WINAPI SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d);
    static HRESULT WINAPI SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d);
    static HRESULT WINAPI SetVertexDataColor(INT Register, D3DCOLOR Color);
    static HRESULT WINAPI Begin(D3DPRIMITIVETYPE PrimitiveType);
    static HRESULT WINAPI End();
    static HRESULT WINAPI CreateFixup(UINT Size, D3DFixup **ppFixup);
    static HRESULT WINAPI CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer);
    static HRESULT WINAPI BeginPushBuffer(D3DPushBuffer *pPushBuffer);
    static HRESULT WINAPI EndPushBuffer();
    static HRESULT WINAPI RunPushBuffer(D3DPushBuffer* pPushBuffer, D3DFixup *pFixup);
    static HRESULT WINAPI GetPushBufferOffset(DWORD* pOffset);
    static HRESULT WINAPI Nop();
    static HRESULT WINAPI GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
    static HRESULT WINAPI GetModelView(D3DMATRIX* pModelView);
    static HRESULT WINAPI SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport);
    static HRESULT WINAPI SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs);
    static HRESULT WINAPI SwitchTexture(DWORD Stage, D3DBaseTexture *pTexture);
    static HRESULT WINAPI Suspend();
    static HRESULT WINAPI Resume(BOOL Reset);
    static HRESULT WINAPI SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects);
    static HRESULT WINAPI GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects);
    static HRESULT WINAPI SetTile(DWORD Index, D3DTILE* pTile);
    static HRESULT WINAPI GetTile(DWORD Index, D3DTILE* pTile);
    static DWORD   WINAPI GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag);
    static void    WINAPI SetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
    static void    WINAPI GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
    static BOOL    WINAPI IsBusy();
    static void    WINAPI BlockUntilIdle();
    static void    WINAPI KickPushBuffer();
    static void    WINAPI SetVerticalBlankCallback(D3DCALLBACK pCallback);
    static void    WINAPI BlockUntilVerticalBlank();
    static DWORD   WINAPI InsertFence();
    static BOOL    WINAPI IsFencePending(DWORD Fence);
    static VOID    WINAPI BlockOnFence(DWORD Fence);
    static VOID    WINAPI InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context);
    static VOID    WINAPI FlushVertexCache();
    static HRESULT WINAPI PersistDisplay();
    static HRESULT WINAPI GetPersistedSurface(IDirect3DSurface8 **ppSurface);
};

#endif __cplusplus

/*
 * D3DResource, IDirect3DResource8 interface
 *
 * The root structure of all D3D 'resources' such as textures and vertex buffers.
 */

#define D3DCOMMON_REFCOUNT_MASK      0x0000FFFF

#define D3DCOMMON_TYPE_MASK          0x00070000
#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PUSHBUFFER    0x00020000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_TYPE_FIXUP         0x00060000

#define D3DCOMMON_INTREFCOUNT_MASK   0x00780000
#define D3DCOMMON_INTREFCOUNT_SHIFT  19

// This flag was used for UMA emulation on pre-Beta development kit
// machines, and is deprecated on the final hardware.
//
#define D3DCOMMON_VIDEOMEMORY        0

// Internal flag to indicate that this resource was created by Direct3D 
//
#define D3DCOMMON_D3DCREATED         0x01000000

// The rest of the bits may be used by derived classes.
#define D3DCOMMON_UNUSED_MASK        0xFE000000
#define D3DCOMMON_UNUSED_SHIFT       25

#ifdef __cplusplus

struct D3DResource
{
    ULONG WINAPI AddRef();

    // DOC:  If the GPU is currently using this object when the last call 
    //   to release is made then this call will block until the GPU is done 
    //   with this object.  The caller will have to manually check this if 
    //   they do not want this call to block.
    //
    ULONG WINAPI Release();

    HRESULT WINAPI GetDevice(D3DDevice **ppDevice);
    D3DRESOURCETYPE WINAPI GetType();

    HRESULT WINAPI SetPrivateData(REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags);
    HRESULT WINAPI GetPrivateData(REFGUID refguid, void *pData, DWORD *pSizeOfData);
    HRESULT WINAPI FreePrivateData(REFGUID refguid);

    // DOC: This additional method returns TRUE if the data for this
    //  : resource is currently being used by the GPU.  This can be used
    //  : to avoid blocking in Release and Lock.  This will always return
    //  : TRUE if the resource is currently set on the device.
    //
    BOOL WINAPI IsBusy();

    // DOC: A blocking form of 'IsBusy' that ensure that this resource is
    //  : no longer used by the GPU.  This will wait for the GPU to go
    //  : idle if this resource is set on the device.
    //
    void    WINAPI BlockUntilNotBusy();

    // DOC: On pre-beta development kits, this API set whether the we should 
    //  ; use video or AGP memory for the data of this resource.  
    //  ;
    //  ; This API has been deprecated on the final hardware.
    //
    void    WINAPI MoveResourceMemory(D3DMEMORY where);

    // DOC: Performs some debug checks and maps the resource's 
    //  : data field from a contiguous memory address to the physical memory
    //  : address.  It should be called for any resource that is not created
    //  : through an D3DDevice "Create" routine.
    //  :
    //  : This API does not modify any state in the resource besides the
    //  : Data field nor does the library keep track of what resources
    //  : have been registered.  
    //  :
    //  : This method takes a contiguous memory address, adds the current
    //  : contents of the Data field to it, converts it to a physical
    //  : address and sets that as the Data field of the resource.
    //
    void    WINAPI Register(void *pBase);

    // All resources need these fields.  Inherit them in C++.

    DWORD Common;           // Refcount and flags common to all resources
    DWORD Data;             // Offset to the data held by this resource
    DWORD Lock;             // Lock information, initialize to zero
};

#endif __cplusplus

/*
 * D3DPixelContainer interface
 *
 * A base structure that describes the shared layout between textures
 * and surfaces.
 */

// The layout of the Format field.

#define D3DFORMAT_RESERVED1_MASK        0x00000003      // Must be zero
                                        
#define D3DFORMAT_DMACHANNEL_MASK       0x00000003
#define D3DFORMAT_DMACHANNEL_A          0x00000001      // DMA channel A - the default for all system memory
#define D3DFORMAT_DMACHANNEL_B          0x00000002      // DMA channel B - video memory, will not be in the
                                                        //   final product
#define D3DFORMAT_CUBEMAP               0x00000004      // Set if the texture if a cube map
#define D3DFORMAT_BORDERSOURCE_COLOR    0x00000008
#define D3DFORMAT_DIMENSION_MASK        0x000000F0      // # of dimensions
#define D3DFORMAT_DIMENSION_SHIFT       4
#define D3DFORMAT_FORMAT_MASK           0x0000FF00
#define D3DFORMAT_FORMAT_SHIFT          8
#define D3DFORMAT_MIPMAP_MASK           0x000F0000 
#define D3DFORMAT_MIPMAP_SHIFT          16
#define D3DFORMAT_USIZE_MASK            0x00F00000      // Log 2 of the U size of the base texture
#define D3DFORMAT_USIZE_SHIFT           20
#define D3DFORMAT_VSIZE_MASK            0x0F000000      // Log 2 of the V size of the base texture
#define D3DFORMAT_VSIZE_SHIFT           24
#define D3DFORMAT_PSIZE_MASK            0xF0000000      // Log 2 of the P size of the base texture
#define D3DFORMAT_PSIZE_SHIFT           28

// The layout of the size field, used for non swizzled or compressed textures.
// 
// The Size field of a container will be zero if the texture is swizzled or compressed.
// It is guarenteed to be non-zero otherwise because either the height/width will be 
// greater than one or the pitch adjust will be nonzero because the minimum texture
// pitch is 8 bytes.

#define D3DSIZE_WIDTH_MASK              0x00000FFF   // Width of the texture - 1, in texels
#define D3DSIZE_HEIGHT_MASK             0x00FFF000   // Height of the texture - 1, in texels
#define D3DSIZE_HEIGHT_SHIFT            12
#define D3DSIZE_PITCH_MASK              0xFF000000   // Pitch / 64 - 1
#define D3DSIZE_PITCH_SHIFT             24

#define D3DTEXTURE_ALIGNMENT            128
#define D3DTEXTURE_CUBEFACE_ALIGNMENT   128

#define D3DTEXTURE_PITCH_ALIGNMENT 64
#define D3DTEXTURE_PITCH_MIN       64

#ifdef __cplusplus

struct D3DPixelContainer : public D3DResource
{
    DWORD Format;   // Format information about the texture.
    DWORD Size;     // Size of a non power-of-2 texture, must be zero otherwise
};

#endif __cplusplus

/*
 * D3DBaseTexture interface
 *
 * The root structure of all D3D textures.  Inherits all of the methods
 * from D3DResource.
 *
 * The data memory pointed to by the Data field must be aligned on a
 * D3DTEXTURE_ALIGNMENT byte multiple.
 */

struct D3DBaseTexture
    #ifdef __cplusplus
        : public D3DPixelContainer
    #endif
{

#ifdef __cplusplus
    DWORD WINAPI GetLevelCount();
#endif

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

    DWORD Format;   // Format information about the texture.
    DWORD Size;     // Size of a non power-of-2 texture, must be zero otherwise
#endif

};


/*
 * D3DTexture, IDirect3DTexture8 interface
 *
 * A normal texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI GetSurfaceLevel(UINT Level, D3DSurface **ppSurfaceLevel);
    HRESULT WINAPI LockRect(UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect(UINT Level);
};

#endif __cplusplus


/*
 * D3DVolumeTexture, IDirect3DVolumeTexture8 interface
 *
 * A volume texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DVolumeTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DVOLUME_DESC *pDesc);
    HRESULT WINAPI GetVolumeLevel(UINT Level, D3DVolume **ppVolumeLevel);
    HRESULT WINAPI LockBox(UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
    HRESULT WINAPI UnlockBox(UINT Level);
};

#endif __cplusplus


/*
 * D3DCubeTexture, IDirect3DCubeTexture8 interface
 *
 * A cube texture.  Inherits from D3DBaseTexture
 */

#ifdef __cplusplus

struct D3DCubeTexture : public D3DBaseTexture
{
    HRESULT WINAPI GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface);
    HRESULT WINAPI LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level);
};

#endif __cplusplus


/*
 * D3DVertexBuffer, IDirect3DVertexBuffer8 interface
 *
 * A vertex buffer.
 *
 * The data for the vertex buffer must be aligned on a 
 * D3DVERTEXBUFFER_ALIGNMENT byte multiple.
 */

#define D3DVERTEXBUFFER_ALIGNMENT     4    

struct D3DVertexBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
    HRESULT WINAPI Unlock();
    HRESULT WINAPI GetDesc(D3DVERTEXBUFFER_DESC *pDesc);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DIndexBuffer, IDirect3DIndexBuffer8 interface
 *
 * An index buffer.
 *
 * The data for the index buffer must be aligned on a D3DINDEXBUFFER_ALIGNMENT
 * byte multiple.
 */

#define D3DINDEXBUFFER_ALIGNMENT        4      

struct D3DIndexBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
    HRESULT WINAPI Unlock();
    HRESULT WINAPI GetDesc(D3DINDEXBUFFER_DESC *pDesc);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;                    
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DPalette, IDirect3DPalette8 interface
 *
 * A palette.
 */

#define D3DPALETTE_ALIGNMENT 64

#define D3DPALETTE_COMMON_VIDEOMEMORY            0
#define D3DPALETTE_COMMON_UNUSED                 0x20000000
#define D3DPALETTE_COMMON_PALETTESIZE_MASK       0xC0000000
#define D3DPALETTE_COMMON_PALETTESIZE_SHIFT      30

#define D3DPALETTE_COMMON_PALETTESET_SHIFT       28
#define D3DPALETTE_COMMON_PALETTESET_MASK        0xF

struct D3DPalette
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Lock(D3DCOLOR **ppColors, DWORD Flags);
    HRESULT WINAPI Unlock();
    D3DPALETTESIZE WINAPI GetSize();

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

};


/*
 * D3DSurface, IDirect3DSurface8 interface
 *
 * Abstracts a chunk of data that can be drawn to.  The Common and Format
 * fields use the D3DCOMMON and D3DFORMAT constants defined for
 * textures.
 */

#define D3DSURFACE_ALIGNMENT    D3D_RENDER_MEMORY_ALIGNMENT
#define D3DSURFACE_OWNSMEMORY   0x80000000

struct D3DSurface
    #if defined(__cplusplus)
        : public D3DPixelContainer
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI GetContainer(D3DBaseTexture **ppBaseTexture);
    HRESULT WINAPI GetDesc(D3DSURFACE_DESC *pDesc);
    HRESULT WINAPI LockRect(D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
    HRESULT WINAPI UnlockRect();

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DPixelContainer
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format;
    DWORD Size;

#endif

    D3DBaseTexture *Parent; 
};


/*
 * D3DVolume, IDirect3DVolume8 interface
 */

#define D3DVOLUME_ALIGNMENT    D3D_RENDER_MEMORY_ALIGNMENT
#define D3DVOLUME_OWNSMEMORY   0x800000000

struct D3DVolume
    #if defined(__cplusplus)
        : public D3DPixelContainer
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI GetContainer(D3DBaseTexture **ppBaseTexture);
    HRESULT WINAPI GetDesc(D3DVOLUME_DESC *pDesc);
    HRESULT WINAPI LockBox(D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
    HRESULT WINAPI UnlockBox();

#endif

#ifndef __cplusplus

    // Manually inherit these from D3DResource
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format; 
    DWORD Size;

#endif

    D3DBaseTexture *Parent; 
};


/*
 * D3DPushBuffer, IDirect3DPushBuffer8 interface
 *
 * A push-buffer resource.
 */

#define D3DPUSHBUFFER_ALIGNMENT 4

// The following flag, when set in the Common field, dictates that when 
// RunPushBuffer is called, the push-buffer is copied using the CPU instead 
// of executed in-place by the GPU.  This should be used for small push-
// buffers to avoid the high latency cost of the GPU JUMP command.  In this
// case, the memory should be cacheable (not write-combined), and need not
// be physically contiguous.
#define D3DPUSHBUFFER_RUN_USING_CPU_COPY  0x80000000

struct D3DPushBuffer
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Verify(BOOL StampResources);
    HRESULT WINAPI BeginFixup(D3DFixup* pFixup, BOOL NoWait);
    HRESULT WINAPI EndFixup();
    HRESULT WINAPI RunPushBuffer(DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup);
    HRESULT WINAPI SetModelView(DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
    HRESULT WINAPI SetVertexBlendModelView(DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
    HRESULT WINAPI SetVertexShaderInput(DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
    HRESULT WINAPI SetRenderTarget(DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer);
    HRESULT WINAPI SetTexture(DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture);
    HRESULT WINAPI SetPalette(DWORD Offset, DWORD Stage,D3DPalette *pPalette);
    HRESULT WINAPI EndVisibilityTest(DWORD Offset, DWORD Index);
    HRESULT WINAPI SetVertexShaderConstant(DWORD Offset, INT Register, CONST VOID* pConstantData, DWORD ConstantCount);
    HRESULT WINAPI Jump(DWORD Offset, UINT DestinationOffset);
    HRESULT WINAPI GetSize(DWORD* pSize);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource.  
    //
    // Note (in an exception to all other resources) that 'Data' is a virtual 
    // address for the D3DPUSHBUFFER_RUN_USING_CPU_COPY case.
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

    // Size, in bytes, of the push-buffer program.
    DWORD Size;

    // Size, in bytes, of the allocation of the buffer pointed to by 'Data'.
    DWORD AllocationSize;
};


/*
 * D3DFixup, IFixup8 interface
 *
 * A fix-up resource for push-buffers.
 */

#define D3DFIXUP_ALIGNMENT 4

struct D3DFixup
    #ifdef __cplusplus
        : public D3DResource
    #endif
{
#ifdef __cplusplus

    HRESULT WINAPI Reset(); 
    HRESULT WINAPI GetSize(DWORD* pSize);
    HRESULT WINAPI GetSpace(DWORD* pSpace);

#endif __cplusplus

#ifndef __cplusplus

    // Manually inherit these from D3DResource.  
    //
    // Note that 'Data' is always a virtual address.
    DWORD Common;
    DWORD Data;
    DWORD Lock;

#endif

    // Offset to the last completed fix-up.  RunPushBuffer uses this and 'Data'.
    DWORD Run;

    // Offset to where we'll append the next fix-up.
    DWORD Next;

    // Size of the whole allocation.
    DWORD Size;
};


/*
 * Helper methods.
 */

//----------------------------------------------------------------------------
// Allocate a block of contiguous memory and return a write-combined
// pointer to it.  This memory is suitable to be used as the data
// for any of the D3D structures.
//
// Returns NULL if the memory could not be allocated.
//
void* WINAPI D3D_AllocContiguousMemory(
    DWORD Size,         // The size of the allocation in bytes
    DWORD Alignment     // The alignment of the allocation
    );

//----------------------------------------------------------------------------
// Frees memory allocated by the above method.
//
    
void WINAPI D3D_FreeContiguousMemory(
    void *pMemory       // The block of memory to free
    );


//----------------------------------------------------------------------------
// D3D_CopyContiguousMemory has been deprecated on the final hardware.
// Use CopyRects instead.  
//
// With the API as speced, this function was hideously expensive because 
// it had to flush the GPU's entire push-buffer, and then spin the CPU until 
// the copy was done.  CopyRects lets everything be nicely asynchronous,
// just as it is with all other GPU APIs.  
// 
// To get equivalent behavior with CopyRects, use XGSetSurfaceHeader to create
// wrapper surfaces around the memory (the pitches should equal the widths 
// times the pixel size and not be more than 8128).  Then surface.IsBusy(),
// LockRect(), and the other standard synchronization APIs may be used to
// determine when the copy is done.
//
// void WINAPI D3D_CopyContiguousMemory(
//     void *pSource,
//     void *pDest,
//     DWORD Size
//     ); 

//----------------------------------------------------------------------------
// On pre-beta development kits, this function was used to copy data
// from AGP memory to video memory.
//
// This function is deprecated on the final hardware.
//
D3DINLINE void WINAPI D3D_CopyContiguousMemoryToVideo(
    void *pMemory          // Contiguous memory block to move.
    )
{
}


/*
 * C exported method definitions for the class methods defined above and the C++
 * thunks that defer to them.
 */

/* Direct3D */

D3DINLINE ULONG   WINAPI Direct3D_AddRef() { return 1; }
D3DINLINE ULONG   WINAPI Direct3D_Release() { return 1; }
D3DINLINE UINT    WINAPI Direct3D_GetAdapterCount() { return 1; }
HRESULT WINAPI Direct3D_GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier);
UINT    WINAPI Direct3D_GetAdapterModeCount(UINT Adapter);
HRESULT WINAPI Direct3D_EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode);
HRESULT WINAPI Direct3D_GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode);
HRESULT WINAPI Direct3D_CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed);
HRESULT WINAPI Direct3D_CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat);
HRESULT WINAPI Direct3D_CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType);
HRESULT WINAPI Direct3D_CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat);
HRESULT WINAPI Direct3D_GetDeviceCaps(UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps);
HRESULT WINAPI Direct3D_CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface);
void    WINAPI Direct3D_SetPushBufferSize(DWORD PushBufferSize, DWORD SegmentCount);

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3D8_AddRef(Direct3D *pThis) { return Direct3D_AddRef(); }
D3DINLINE ULONG   WINAPI IDirect3D8_Release(Direct3D *pThis) { return Direct3D_Release(); }
D3DINLINE UINT    WINAPI IDirect3D8_GetAdapterCount(Direct3D *pThis) { return Direct3D_GetAdapterCount(); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetAdapterIdentifier(Direct3D *pThis, UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier) { return Direct3D_GetAdapterIdentifier(Adapter, Flags, pIdentifier); }
D3DINLINE UINT    WINAPI IDirect3D8_GetAdapterModeCount(Direct3D *pThis, UINT Adapter) { return Direct3D_GetAdapterModeCount(Adapter); }
D3DINLINE HRESULT WINAPI IDirect3D8_EnumAdapterModes(Direct3D *pThis, UINT Adapter, UINT iMode, D3DDISPLAYMODE *pMode) { return Direct3D_EnumAdapterModes(Adapter, iMode, pMode); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetAdapterDisplayMode(Direct3D *pThis, UINT Adapter, D3DDISPLAYMODE *pMode) { return Direct3D_GetAdapterDisplayMode(Adapter, pMode); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceType(Direct3D *pThis, UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed) { return Direct3D_CheckDeviceType(Adapter, CheckType, DisplayFormat, BackBufferFormat, Windowed); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceFormat(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) { return Direct3D_CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDeviceMultiSampleType(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType) { return Direct3D_CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType); }
D3DINLINE HRESULT WINAPI IDirect3D8_CheckDepthStencilMatch(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) { return Direct3D_CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat); }
D3DINLINE HRESULT WINAPI IDirect3D8_GetDeviceCaps(Direct3D *pThis, UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8 *pCaps) { return Direct3D_GetDeviceCaps(Adapter, DeviceType, pCaps); }
D3DINLINE HRESULT WINAPI IDirect3D8_CreateDevice(Direct3D *pThis, UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface) { return Direct3D_CreateDevice(Adapter, DeviceType, pUnused, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface); }
D3DINLINE HRESULT WINAPI IDirect3D8_SetPushBufferSize(Direct3D *pThis, DWORD PushBufferSize, DWORD SegmentCount) { Direct3D_SetPushBufferSize(PushBufferSize, SegmentCount); return S_OK; }

#ifdef __cplusplus

D3DMINLINE ULONG   WINAPI Direct3D::AddRef() { return Direct3D_AddRef(); }
D3DMINLINE ULONG   WINAPI Direct3D::Release() { return Direct3D_Release(); }
D3DMINLINE UINT    WINAPI Direct3D::GetAdapterCount() { return Direct3D_GetAdapterCount(); }
D3DMINLINE HRESULT WINAPI Direct3D::GetAdapterIdentifier(UINT Adapter, DWORD Flags, D3DADAPTER_IDENTIFIER8 *pIdentifier) { return Direct3D_GetAdapterIdentifier(Adapter, Flags, pIdentifier); }
D3DMINLINE UINT    WINAPI Direct3D::GetAdapterModeCount(UINT Adapter) { return Direct3D_GetAdapterModeCount(Adapter); }
D3DMINLINE HRESULT WINAPI Direct3D::EnumAdapterModes(UINT Adapter, UINT Mode, D3DDISPLAYMODE *pMode) { return Direct3D_EnumAdapterModes(Adapter, Mode, pMode); }
D3DMINLINE HRESULT WINAPI Direct3D::GetAdapterDisplayMode(UINT Adapter, D3DDISPLAYMODE *pMode) { return Direct3D_GetAdapterDisplayMode(Adapter, pMode); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceType(UINT Adapter, D3DDEVTYPE CheckType, D3DFORMAT DisplayFormat, D3DFORMAT BackBufferFormat, BOOL Windowed) { return Direct3D_CheckDeviceType(Adapter, CheckType, DisplayFormat, BackBufferFormat, Windowed); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceFormat(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, DWORD Usage, D3DRESOURCETYPE RType, D3DFORMAT CheckFormat) { return Direct3D_CheckDeviceFormat(Adapter, DeviceType, AdapterFormat, Usage, RType, CheckFormat); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDeviceMultiSampleType(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT SurfaceFormat, BOOL Windowed, D3DMULTISAMPLE_TYPE MultiSampleType) { return Direct3D_CheckDeviceMultiSampleType(Adapter, DeviceType, SurfaceFormat, Windowed, MultiSampleType); }
D3DMINLINE HRESULT WINAPI Direct3D::CheckDepthStencilMatch(UINT Adapter, D3DDEVTYPE DeviceType, D3DFORMAT AdapterFormat, D3DFORMAT RenderTargetFormat, D3DFORMAT DepthStencilFormat) { return Direct3D_CheckDepthStencilMatch(Adapter, DeviceType, AdapterFormat, RenderTargetFormat, DepthStencilFormat); }
D3DMINLINE HRESULT WINAPI Direct3D::GetDeviceCaps(UINT Adapter, D3DDEVTYPE DeviceType, D3DCAPS8 *pCaps) { return Direct3D_GetDeviceCaps(Adapter, DeviceType, pCaps); }
D3DMINLINE HRESULT WINAPI Direct3D::CreateDevice(UINT Adapter, D3DDEVTYPE DeviceType, void *pUnused, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS *pPresentationParameters, D3DDevice **ppReturnedDeviceInterface) { return Direct3D_CreateDevice(Adapter, DeviceType, pUnused, BehaviorFlags, pPresentationParameters, ppReturnedDeviceInterface); }
D3DMINLINE HRESULT WINAPI Direct3D::SetPushBufferSize(DWORD PushBufferSize, DWORD SegmentCount) { Direct3D_SetPushBufferSize(PushBufferSize, SegmentCount); return S_OK; }

#endif __cplusplus

/* D3DDevice */

ULONG   WINAPI D3DDevice_AddRef();
ULONG   WINAPI D3DDevice_Release();
void    WINAPI D3DDevice_GetDirect3D(Direct3D **ppD3D8);
void    WINAPI D3DDevice_GetDeviceCaps(D3DCAPS8 *pCaps);
void    WINAPI D3DDevice_GetDisplayMode(D3DDISPLAYMODE *pMode);
void    WINAPI D3DDevice_GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters);
HRESULT WINAPI D3DDevice_Reset(D3DPRESENT_PARAMETERS *pPresentationParameters);
void    WINAPI D3DDevice_Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2);
void    WINAPI D3DDevice_GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer);
void    WINAPI D3DDevice_GetRasterStatus(D3DRASTER_STATUS *pRasterStatus);
void    WINAPI D3DDevice_SetFlickerFilter(DWORD Filter);
void    WINAPI D3DDevice_SetSoftDisplayFilter(BOOL Enable);
void    WINAPI D3DDevice_SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp);
void    WINAPI D3DDevice_GetGammaRamp(D3DGAMMARAMP *pRamp);
HRESULT WINAPI D3DDevice_CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture);
HRESULT WINAPI D3DDevice_CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture);
HRESULT WINAPI D3DDevice_CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture);
HRESULT WINAPI D3DDevice_CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer);
HRESULT WINAPI D3DDevice_CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer);
HRESULT WINAPI D3DDevice_CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette);
HRESULT WINAPI D3DDevice_CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface);
HRESULT WINAPI D3DDevice_CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface);
HRESULT WINAPI D3DDevice_CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface);
void    WINAPI D3DDevice_CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray);
void    WINAPI D3DDevice_UpdateTexture(D3DBaseTexture *pSourceTexture, D3DBaseTexture *pDestinationTexture);
void    WINAPI D3DDevice_SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil);
void    WINAPI D3DDevice_GetRenderTarget(D3DSurface **ppRenderTarget);
HRESULT WINAPI D3DDevice_GetDepthStencilSurface(D3DSurface **ppZStencilSurface);
D3DINLINE void    WINAPI D3DDevice_BeginScene() { }
D3DINLINE void    WINAPI D3DDevice_EndScene() { }
void    WINAPI D3DDevice_Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil);
void    WINAPI D3DDevice_SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix);
void    WINAPI D3DDevice_SetViewport(CONST D3DVIEWPORT8 *pViewport);
void    WINAPI D3DDevice_GetViewport(D3DVIEWPORT8 *pViewport);
void    WINAPI D3DDevice_SetMaterial(CONST D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_GetMaterial(D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_SetBackMaterial(CONST D3DMATERIAL8 *pMaterial);
void    WINAPI D3DDevice_GetBackMaterial(D3DMATERIAL8 *pMaterial);
HRESULT WINAPI D3DDevice_SetLight(DWORD Index, CONST D3DLIGHT8 *pLight);
void    WINAPI D3DDevice_GetLight(DWORD Index, D3DLIGHT8 *pLight);
HRESULT WINAPI D3DDevice_LightEnable(DWORD Index, BOOL Enable);
void    WINAPI D3DDevice_GetLightEnable(DWORD Index, BOOL *pEnable);
void    WINAPI D3DDevice_SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value);
HRESULT WINAPI D3DDevice_SetRenderState_ParameterCheck(D3DRENDERSTATETYPE State, DWORD Value);
void    D3DFASTCALL D3DDevice_SetRenderState_Simple(DWORD Method, DWORD Value);
void    D3DFASTCALL D3DDevice_SetRenderState_Deferred(D3DRENDERSTATETYPE State, DWORD Value);
void    WINAPI D3DDevice_SetRenderState_PSTextureModes(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_VertexBlend(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FogColor(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FillMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_BackFillMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_TwoSidedLighting(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_NormalizeNormals(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ZEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilFail(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_CullMode(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_FrontFace(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_TextureFactor(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ZBias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_LogicOp(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_EdgeAntiAlias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleAntiAlias(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleMask(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_MultiSampleType(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_ShadowFunc(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_LineWidth(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_Dxt1NoiseEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_YuvEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_OcclusionCullEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_StencilCullEnable(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_RopZCmpAlwaysRead(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_RopZRead(DWORD Value);
void    WINAPI D3DDevice_SetRenderState_DoNotCullUncompressed(DWORD Value);
void    WINAPI D3DDevice_SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
HRESULT WINAPI D3DDevice_SetTextureState_ParameterCheck(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    D3DFASTCALL D3DDevice_SetTextureState_Deferred(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_BumpEnv(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_TexCoordIndex(DWORD Stage, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_BorderColor(DWORD Stage, DWORD Value);
void    WINAPI D3DDevice_SetTextureState_ColorKeyColor(DWORD Stage, DWORD Value);
#if D3DCOMPILE_BEGINSTATEBLOCK
void    WINAPI D3DDevice_BeginStateBlock();
HRESULT WINAPI D3DDevice_EndStateBlock(DWORD *pToken);
#endif
void    WINAPI D3DDevice_ApplyStateBlock(DWORD Token);
void    WINAPI D3DDevice_CaptureStateBlock(DWORD Token);
void    WINAPI D3DDevice_DeleteStateBlock(DWORD Token);
HRESULT WINAPI D3DDevice_CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken);
void    WINAPI D3DDevice_GetTexture(DWORD Stage, D3DBaseTexture **ppTexture);
void    WINAPI D3DDevice_SetTexture(DWORD Stage, D3DBaseTexture *pTexture);
void    WINAPI D3DDevice_GetPalette(DWORD Stage, D3DPalette **ppPalette);
void    WINAPI D3DDevice_SetPalette(DWORD Stage, D3DPalette *pPalette);
void    WINAPI D3DDevice_DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount);
void    WINAPI D3DDevice_DrawIndexedVertices(D3DPRIMITIVETYPE, UINT VertexCount, CONST WORD *pIndexData);
void    WINAPI D3DDevice_DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
void    WINAPI D3DDevice_DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride);
void    WINAPI D3DDevice_PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData);
HRESULT WINAPI D3DDevice_CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage);
void    WINAPI D3DDevice_SetVertexShader(DWORD Handle);
void    WINAPI D3DDevice_GetVertexShader(DWORD *pHandle);
void    WINAPI D3DDevice_DeleteVertexShader(DWORD Handle);
void    WINAPI D3DDevice_SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode);
void    WINAPI D3DDevice_GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode);
void    WINAPI D3DDevice_LoadVertexShader(DWORD Handle, DWORD Address);
void    WINAPI D3DDevice_LoadVertexShaderProgram(DWORD *pFunction, DWORD Address);
void    WINAPI D3DDevice_SelectVertexShader(DWORD Handle, DWORD Address);
void    WINAPI D3DDevice_RunVertexStateShader(DWORD Address, CONST float *pData);
void    WINAPI D3DDevice_GetVertexShaderSize(DWORD Handle, UINT* pSize);
void    WINAPI D3DDevice_GetVertexShaderType(DWORD Handle, DWORD* pType);
HRESULT WINAPI D3DDevice_GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData);
HRESULT WINAPI D3DDevice_GetVertexShaderFunction(DWORD Handle,void *pData, DWORD *pSizeOfData);
void    WINAPI D3DDevice_SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride);
void    WINAPI D3DDevice_GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride);
void    WINAPI D3DDevice_SetIndices(D3DIndexBuffer* pIndexData, UINT BaseVertexIndex);
void    WINAPI D3DDevice_GetIndices(D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex);
void    WINAPI D3DDevice_CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle);
void    WINAPI D3DDevice_SetPixelShader(DWORD Handle);
void    WINAPI D3DDevice_SetPixelShaderProgram(D3DPIXELSHADERDEF *pPSDef);
void    WINAPI D3DDevice_GetPixelShader(DWORD *pHandle);
void    WINAPI D3DDevice_DeletePixelShader(DWORD Handle);
void    WINAPI D3DDevice_SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount);
void    WINAPI D3DDevice_GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData);
HRESULT WINAPI D3DDevice_DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo);
HRESULT WINAPI D3DDevice_DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo);
void    WINAPI D3DDevice_DeletePatch(UINT Handle);
void    WINAPI D3DDevice_UpdateOverlay(D3DSurface *pSurface, RECT *SrcRect, RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey);
void    WINAPI D3DDevice_EnableOverlay(BOOL Enable);
void    WINAPI D3DDevice_EnableCC(BOOL Enable);
void    WINAPI D3DDevice_SendCC(BOOL Field, BYTE cc1, BYTE cc2);
void    WINAPI D3DDevice_GetCCStatus(BOOL *pField1, BOOL *pField2);
void    WINAPI D3DDevice_BeginVisibilityTest();
HRESULT WINAPI D3DDevice_EndVisibilityTest(DWORD Index);
HRESULT WINAPI D3DDevice_GetVisibilityTestResult(DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp);
BOOL    WINAPI D3DDevice_IsBusy();
void    WINAPI D3DDevice_BlockUntilIdle();
void    WINAPI D3DDevice_KickPushBuffer();
void    WINAPI D3DDevice_SetVerticalBlankCallback(D3DCALLBACK pCallback);
void    WINAPI D3DDevice_BlockUntilVerticalBlank();
DWORD   WINAPI D3DDevice_InsertFence();
BOOL    WINAPI D3DDevice_IsFencePending(DWORD Fence);
VOID    WINAPI D3DDevice_BlockOnFence(DWORD Fence);
void    WINAPI D3DDevice_InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context);
void    WINAPI D3DDevice_FlushVertexCache();
HRESULT WINAPI D3DDevice_PersistDisplay();
HRESULT WINAPI D3DDevice_GetPersistedSurface(IDirect3DSurface8 **ppSurface);
BOOL    WINAPI D3DDevice_GetOverlayUpdateStatus();
void    WINAPI D3DDevice_GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus);
void    WINAPI D3DDevice_SetVertexData2f(INT Register, FLOAT a, FLOAT b);
void    WINAPI D3DDevice_SetVertexData4f(INT Register, FLOAT a, FLOAT b, FLOAT c, FLOAT d);
void    WINAPI D3DDevice_SetVertexData2s(INT Register, SHORT a, SHORT b);
void    WINAPI D3DDevice_SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d);
void    WINAPI D3DDevice_SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d);
void    WINAPI D3DDevice_SetVertexDataColor(INT Register, D3DCOLOR Color);
void    WINAPI D3DDevice_Begin(D3DPRIMITIVETYPE PrimitiveType);
void    WINAPI D3DDevice_End();
HRESULT WINAPI D3DDevice_CreateFixup(UINT Size, D3DFixup **ppFixup);
HRESULT WINAPI D3DDevice_CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer);
void    WINAPI D3DDevice_BeginPushBuffer(D3DPushBuffer *pPushBuffer);
HRESULT WINAPI D3DDevice_EndPushBuffer();
void    WINAPI D3DDevice_RunPushBuffer(D3DPushBuffer *pPushBuffer, D3DFixup *pFixup);
void    WINAPI D3DDevice_GetPushBufferOffset(DWORD* pOffset);
void    WINAPI D3DDevice_Nop();
void    WINAPI D3DDevice_GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport);
void    WINAPI D3DDevice_SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
HRESULT WINAPI D3DDevice_GetModelView(D3DMATRIX* pModelView);
void    WINAPI D3DDevice_SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
HRESULT WINAPI D3DDevice_GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport);
void    WINAPI D3DDevice_SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs);
HRESULT WINAPI D3DDevice_GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs);
void    D3DFASTCALL D3DDevice_SwitchTexture(DWORD Method, DWORD Data, DWORD Format);
void    WINAPI D3DDevice_Suspend();
void    WINAPI D3DDevice_Resume(BOOL Reset);
void    WINAPI D3DDevice_SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects);
void    WINAPI D3DDevice_GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects);
void    WINAPI D3DDevice_SetTile(DWORD Index, D3DTILE* pTile);
void    WINAPI D3DDevice_GetTile(DWORD Index, D3DTILE* pTile);
DWORD   WINAPI D3DDevice_GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag);
void    WINAPI D3DDevice_SetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);
void    WINAPI D3DDevice_GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count);

D3DINLINE void D3DDevice_GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue)
{
    *pValue = D3D__RenderState[State];
}
D3DINLINE void D3DDevice_GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue)
{
    *pValue = D3D__TextureState[Stage][Type];
}

#if D3DCOMPILE_NOTINLINE
    
    D3DINLINE void D3DDevice_SetRenderState(D3DRENDERSTATETYPE State, DWORD Value)
    {
        D3DDevice_SetRenderStateNotInline(State, Value);
    }
    D3DINLINE void D3DDevice_SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
    {
        D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value);
    }

#else
    
    // This D3DINLINE version of SetRenderState has the nice advantage that it
    // essentially moves to compile-time the big 'switch' statement for
    // handling all the render state types.  When given a constant value for 
    // 'State', all of these 'if's get nicely compiled away.  We can't use a 
    // static call-table because the compiler cannot remove the indirect.
    //
    // If you're calling SetRenderState with a non-constant value for 'State',
    // it's better to call SetRenderStateNotInline (it will reduce code bloat
    // and be a bit faster because the non-D3DINLINE version uses a call-table).
    //
    D3DINLINE void D3DDevice_SetRenderState(D3DRENDERSTATETYPE State, DWORD Value)
    {
        #ifdef _DEBUG
        if (D3DDevice_SetRenderState_ParameterCheck(State, Value) != S_OK)
            return;
        #endif

        if (State < D3DRS_SIMPLE_MAX)
        {
            D3DDevice_SetRenderState_Simple(D3DSIMPLERENDERSTATEENCODE[State], Value);
            #if !D3DCOMPILE_PUREDEVICE
            D3D__RenderState[State] = Value;
            #endif
        }
        else if (State < D3DRS_DEFERRED_MAX)
        {
            D3DDevice_SetRenderState_Deferred(State, Value);
        }
        else if (State == D3DRS_PSTEXTUREMODES)
        {
            D3DDevice_SetRenderState_PSTextureModes(Value);
        }
        else if (State == D3DRS_VERTEXBLEND)
        {
            D3DDevice_SetRenderState_VertexBlend(Value);
        }
        else if (State == D3DRS_FOGCOLOR)
        {
            D3DDevice_SetRenderState_FogColor(Value);
        }
        else if (State == D3DRS_FILLMODE)
        {
            D3DDevice_SetRenderState_FillMode(Value);
        }
        else if (State == D3DRS_BACKFILLMODE)
        {
            D3DDevice_SetRenderState_BackFillMode(Value);
        }
        else if (State == D3DRS_TWOSIDEDLIGHTING)
        {
            D3DDevice_SetRenderState_TwoSidedLighting(Value);
        }
        else if (State == D3DRS_NORMALIZENORMALS)
        {
            D3DDevice_SetRenderState_NormalizeNormals(Value);
        }
        else if (State == D3DRS_ZENABLE)
        {
            D3DDevice_SetRenderState_ZEnable(Value);
        }
        else if (State == D3DRS_STENCILENABLE)
        {
            D3DDevice_SetRenderState_StencilEnable(Value);
        }
        else if (State == D3DRS_STENCILFAIL)
        {
            D3DDevice_SetRenderState_StencilFail(Value);
        }
        else if (State == D3DRS_CULLMODE)
        {
            D3DDevice_SetRenderState_CullMode(Value);
        }
        else if (State == D3DRS_FRONTFACE)
        {
            D3DDevice_SetRenderState_FrontFace(Value);
        }
        else if (State == D3DRS_TEXTUREFACTOR)
        {
            D3DDevice_SetRenderState_TextureFactor(Value);
        }
        else if (State == D3DRS_ZBIAS)
        {
            D3DDevice_SetRenderState_ZBias(Value);
        }
        else if (State == D3DRS_LOGICOP)
        {
            D3DDevice_SetRenderState_LogicOp(Value);
        }
        else if (State == D3DRS_EDGEANTIALIAS)
        {
            D3DDevice_SetRenderState_EdgeAntiAlias(Value);
        }
        else if (State == D3DRS_MULTISAMPLEANTIALIAS)
        {
            D3DDevice_SetRenderState_MultiSampleAntiAlias(Value);
        }
        else if (State == D3DRS_MULTISAMPLEMASK)
        {
            D3DDevice_SetRenderState_MultiSampleMask(Value);
        }
        else if (State == D3DRS_MULTISAMPLETYPE)
        {
            D3DDevice_SetRenderState_MultiSampleType(Value);
        }
        else if (State == D3DRS_SHADOWFUNC)
        {
            D3DDevice_SetRenderState_ShadowFunc(Value);
        }
        else if (State == D3DRS_LINEWIDTH)
        {
            D3DDevice_SetRenderState_LineWidth(Value);
        }
        else if (State == D3DRS_DXT1NOISEENABLE)
        {
            D3DDevice_SetRenderState_Dxt1NoiseEnable(Value);
        }
        else if (State == D3DRS_YUVENABLE)
        {
            D3DDevice_SetRenderState_YuvEnable(Value);
        }
        else if (State == D3DRS_OCCLUSIONCULLENABLE)
        {
            D3DDevice_SetRenderState_OcclusionCullEnable(Value);
        }
        else if (State == D3DRS_STENCILCULLENABLE)
        {
            D3DDevice_SetRenderState_StencilCullEnable(Value);
        }
        else if (State == D3DRS_ROPZCMPALWAYSREAD)
        {
            D3DDevice_SetRenderState_RopZCmpAlwaysRead(Value);
        }
        else if (State == D3DRS_ROPZREAD)
        {
            D3DDevice_SetRenderState_RopZRead(Value);
        }
        else if (State == D3DRS_DONOTCULLUNCOMPRESSED)
        {
            D3DDevice_SetRenderState_DoNotCullUncompressed(Value);
        }
    }

    // As above, but for SetTextureStageState:

    D3DINLINE void D3DDevice_SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value)
    {
        #ifdef _DEBUG
        if (D3DDevice_SetTextureState_ParameterCheck(Stage, Type, Value) != S_OK)
            return;
        #endif

        if (Type < D3DTSS_DEFERRED_MAX)
        {
            D3DDevice_SetTextureState_Deferred(Stage, Type, Value);
        }
        else if (Type == D3DTSS_TEXCOORDINDEX)
        {
            D3DDevice_SetTextureState_TexCoordIndex(Stage, Value);
        }
        else if (Type == D3DTSS_BORDERCOLOR)
        {
            D3DDevice_SetTextureState_BorderColor(Stage, Value);
        }
        else if (Type == D3DTSS_COLORKEYCOLOR)
        {
            D3DDevice_SetTextureState_ColorKeyColor(Stage, Value);
        }
        else if ((Type >= D3DTSS_BUMPENVMAT00) && (Type <= D3DTSS_BUMPENVLOFFSET))
        {
            D3DDevice_SetTextureState_BumpEnv(Stage, Type, Value);
        }
    }

#endif

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DDevice8_AddRef(D3DDevice *pThis) { return D3DDevice_AddRef(); }
D3DINLINE ULONG   WINAPI IDirect3DDevice8_Release(D3DDevice *pThis) { return D3DDevice_Release(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDirect3D(D3DDevice *pThis, Direct3D **ppD3D8) { D3DDevice_GetDirect3D(ppD3D8); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDeviceCaps(D3DDevice *pThis, D3DCAPS8 *pCaps) { D3DDevice_GetDeviceCaps(pCaps); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDisplayMode(D3DDevice *pThis, D3DDISPLAYMODE *pMode) { D3DDevice_GetDisplayMode(pMode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetCreationParameters(D3DDevice *pThis, D3DDEVICE_CREATION_PARAMETERS *pParameters) { D3DDevice_GetCreationParameters(pParameters); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Reset(D3DDevice *pThis, D3DPRESENT_PARAMETERS *pPresentationParameters) { return D3DDevice_Reset(pPresentationParameters); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Present(D3DDevice *pThis, CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2) { D3DDevice_Present(pSourceRect, pDestRect, pUnused, pUnused2); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackBuffer(D3DDevice *pThis, INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer) { D3DDevice_GetBackBuffer(BackBuffer, Type, ppBackBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRasterStatus(D3DDevice *pThis, D3DRASTER_STATUS *pRasterStatus) { D3DDevice_GetRasterStatus(pRasterStatus); return S_OK; }
D3DINLINE void    WINAPI IDirect3DDevice8_SetFlickerFilter(D3DDevice *pThis, DWORD Filter) { D3DDevice_SetFlickerFilter(Filter); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetSoftDisplayFilter(D3DDevice *pThis, BOOL Enable) { D3DDevice_SetSoftDisplayFilter(Enable); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetGammaRamp(D3DDevice *pThis, DWORD Flags, CONST D3DGAMMARAMP *pRamp) { D3DDevice_SetGammaRamp(Flags, pRamp); }
D3DINLINE void    WINAPI IDirect3DDevice8_GetGammaRamp(D3DDevice *pThis, D3DGAMMARAMP *pRamp) { D3DDevice_GetGammaRamp(pRamp); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateTexture(D3DDevice *pThis, UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture) { return D3DDevice_CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVolumeTexture(D3DDevice *pThis, UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture) { return D3DDevice_CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateCubeTexture(D3DDevice *pThis, UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture) { return D3DDevice_CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVertexBuffer(D3DDevice *pThis, UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer) { return D3DDevice_CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateIndexBuffer(D3DDevice *pThis, UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer) { return D3DDevice_CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePalette(D3DDevice *pThis, D3DPALETTESIZE Size, D3DPalette **ppPalette) { return D3DDevice_CreatePalette(Size, ppPalette); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateRenderTarget(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface) { return D3DDevice_CreateRenderTarget(Width, Height, Format, MultiSample, Lockable, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateDepthStencilSurface(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface) { return D3DDevice_CreateDepthStencilSurface(Width, Height, Format, MultiSample, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateImageSurface(D3DDevice *pThis, UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface) { return D3DDevice_CreateImageSurface(Width, Height, Format, ppSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CopyRects(D3DDevice *pThis, D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray) { D3DDevice_CopyRects(pSourceSurface, pSourceRectsArray, cRects, pDestinationSurface, pDestPointsArray); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_UpdateTexture(D3DDevice *pThis, D3DBaseTexture *pSourceTexture, D3DBaseTexture *pDestinationTexture) { D3DDevice_UpdateTexture(pSourceTexture, pDestinationTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderTarget(D3DDevice *pThis, D3DSurface *pRenderTarget, D3DSurface *pNewZStencil) { D3DDevice_SetRenderTarget(pRenderTarget, pNewZStencil); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRenderTarget(D3DDevice *pThis, D3DSurface **ppRenderTarget) { D3DDevice_GetRenderTarget(ppRenderTarget); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDepthStencilSurface(D3DDevice *pThis, D3DSurface **ppZStencilSurface) { return D3DDevice_GetDepthStencilSurface(ppZStencilSurface); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginScene(D3DDevice *pThis) { D3DDevice_BeginScene(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndScene(D3DDevice *pThis) { D3DDevice_EndScene(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Clear(D3DDevice *pThis, DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) { D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDIRTY_TRANSFORM(State); D3DDevice_SetTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix) { D3DDevice_GetTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_MultiplyTransform(D3DDevice *pThis, D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDevice_MultiplyTransform(State, pMatrix); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetViewport(D3DDevice *pThis, CONST D3DVIEWPORT8 *pViewport) { D3DDIRTY_VIEWPORT(); D3DDevice_SetViewport(pViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetViewport(D3DDevice *pThis, D3DVIEWPORT8 *pViewport) { D3DDevice_GetViewport(pViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetMaterial(D3DDevice *pThis, CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_MATERIAL(); D3DDevice_SetMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetMaterial(D3DDevice *pThis, D3DMATERIAL8 *pMaterial) { D3DDevice_GetMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetBackMaterial(D3DDevice *pThis, CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_BACKMATERIAL(); D3DDevice_SetBackMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetBackMaterial(D3DDevice *pThis, D3DMATERIAL8 *pMaterial) { D3DDevice_GetBackMaterial(pMaterial); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetLight(D3DDevice *pThis, DWORD Index, CONST D3DLIGHT8 *pLight) { return D3DDevice_SetLight(Index, pLight); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetLight(D3DDevice *pThis, DWORD Index, D3DLIGHT8 *pLight) { D3DDevice_GetLight(Index, pLight); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LightEnable(D3DDevice *pThis, DWORD Index, BOOL Enable) { return D3DDevice_LightEnable(Index, Enable); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetLightEnable(D3DDevice *pThis, DWORD Index, BOOL *pEnable) { D3DDevice_GetLightEnable(Index, pEnable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderState(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderState(State, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetRenderStateNotInline(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderStateNotInline(State, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetRenderState(D3DDevice *pThis, D3DRENDERSTATETYPE State, DWORD *pValue) { D3DDevice_GetRenderState(State, pValue); return S_OK; }
#if D3DCOMPILE_BEGINSTATEBLOCK
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginStateBlock(D3DDevice *pThis) { D3DDevice_BeginStateBlock(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndStateBlock(D3DDevice *pThis, DWORD *pToken) { return D3DDevice_EndStateBlock(pToken); }
#endif
D3DINLINE HRESULT WINAPI IDirect3DDevice8_ApplyStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_ApplyStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CaptureStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_CaptureStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeleteStateBlock(D3DDevice *pThis, DWORD Token) { D3DDevice_DeleteStateBlock(Token); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateStateBlock(D3DDevice *pThis, D3DSTATEBLOCKTYPE Type,DWORD *pToken) { return D3DDevice_CreateStateBlock(Type, pToken); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture **ppTexture) { D3DDevice_GetTexture(Stage, ppTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture *pTexture) { D3DDIRTY_TEXTURE(Stage); D3DDevice_SetTexture(Stage, pTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPalette(D3DDevice *pThis, DWORD Stage, D3DPalette **ppPalette) { D3DDevice_GetPalette(Stage, ppPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPalette(D3DDevice *pThis, DWORD Stage, D3DPalette *pPalette) { D3DDevice_SetPalette(Stage, pPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTextureStageState(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue) { D3DDevice_GetTextureStageState(Stage, Type, pValue); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTextureStageState(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageState(Stage, Type, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTextureStageStateNotInline(D3DDevice *pThis, DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawPrimitive(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount)); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedPrimitive(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount) { D3DDevice_DrawIndexedVertices(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), D3D__IndexData + StartIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawPrimitiveUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedPrimitiveUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawVertices(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, VertexCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedVertices(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, WORD *pIndexData) { D3DDevice_DrawIndexedVertices(PrimitiveType, VertexCount, pIndexData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawVerticesUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, VertexCount, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawIndexedVerticesUP(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, VertexCount, pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_PrimeVertexCache(D3DDevice *pThis, UINT VertexCount, CONST WORD *pIndexData) { D3DDevice_PrimeVertexCache(VertexCount, pIndexData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateVertexShader(D3DDevice *pThis, CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage) { return D3DDevice_CreateVertexShader(pDeclaration, pFunction, pHandle, Usage); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShader(D3DDevice *pThis, DWORD Handle) { D3DDIRTY_VERTEXSHADER(); D3DDevice_SetVertexShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShader(D3DDevice *pThis, DWORD *pHandle) { D3DDevice_GetVertexShader(pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeleteVertexShader(D3DDevice *pThis, DWORD Handle) { D3DDevice_DeleteVertexShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderConstant(D3DDevice *pThis, INT Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_VERTEXSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderConstant(D3DDevice *pThis, INT Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetShaderConstantMode(D3DDevice *pThis, D3DSHADERCONSTANTMODE Mode) { D3DDevice_SetShaderConstantMode(Mode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetShaderConstantMode(D3DDevice *pThis, D3DSHADERCONSTANTMODE *pMode) { D3DDevice_GetShaderConstantMode(pMode); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LoadVertexShader(D3DDevice *pThis, DWORD Handle, DWORD Address) { D3DDevice_LoadVertexShader(Handle, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_LoadVertexShaderProgram(D3DDevice *pThis, DWORD *pFunction, DWORD Address) { D3DDevice_LoadVertexShaderProgram(pFunction, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SelectVertexShader(D3DDevice *pThis, DWORD Handle, DWORD Address) { D3DDevice_SelectVertexShader(Handle, Address); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_RunVertexStateShader(D3DDevice *pThis, DWORD Address, CONST float *pData) { D3DDevice_RunVertexStateShader(Address, pData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderSize(D3DDevice *pThis, DWORD Handle, UINT* pSize) { D3DDevice_GetVertexShaderSize(Handle, pSize); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderType(D3DDevice *pThis, DWORD Handle, DWORD* pType) { D3DDevice_GetVertexShaderType(Handle, pType); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderDeclaration(D3DDevice *pThis, DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderDeclaration(Handle, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderFunction(D3DDevice *pThis, DWORD Handle,void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderFunction(Handle, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetStreamSource(D3DDevice *pThis, UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride) { D3DDIRTY_STREAM(StreamNumber); D3DDevice_SetStreamSource(StreamNumber, pStreamData, Stride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetStreamSource(D3DDevice *pThis, UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride) { D3DDevice_GetStreamSource(StreamNumber, ppStreamData, pStride); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetIndices(D3DDevice *pThis, D3DIndexBuffer* pIndexData, UINT BaseVertexIndex) { D3DDIRTY_INDICES(); D3DDevice_SetIndices(pIndexData, BaseVertexIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetIndices(D3DDevice *pThis, D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex) { D3DDevice_GetIndices(ppIndexData, pBaseVertexIndex); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePixelShader(D3DDevice *pThis, CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle) { D3DDevice_CreatePixelShader(pPSDef, pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShader(D3DDevice *pThis, DWORD Handle) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShaderProgram(D3DDevice *pThis, D3DPIXELSHADERDEF *pPSDef) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShaderProgram(pPSDef); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShader(D3DDevice *pThis, DWORD *pHandle) { D3DDevice_GetPixelShader(pHandle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeletePixelShader(D3DDevice *pThis, DWORD Handle) { D3DDevice_DeletePixelShader(Handle); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetPixelShaderConstant(D3DDevice *pThis, DWORD Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_PIXELSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShaderConstant(D3DDevice *pThis, DWORD Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPixelShaderFunction(D3DDevice *pThis, DWORD Handle, D3DPIXELSHADERDEF *pData) { D3DDevice_GetPixelShaderFunction(Handle, pData); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawRectPatch(D3DDevice *pThis, UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo) { return D3DDevice_DrawRectPatch(Handle, pNumSegs, pRectPatchInfo); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DrawTriPatch(D3DDevice *pThis, UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo) { return D3DDevice_DrawTriPatch(Handle, pNumSegs, pTriPatchInfo); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_DeletePatch(D3DDevice *pThis, UINT Handle) { D3DDevice_DeletePatch(Handle); return S_OK; }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_IsBusy(D3DDevice *pThis) { return D3DDevice_IsBusy(); }
D3DINLINE void    WINAPI IDirect3DDevice8_BlockUntilIdle(D3DDevice *pThis) { D3DDevice_BlockUntilIdle(); }
D3DINLINE void    WINAPI IDirect3DDevice8_KickPushBuffer(D3DDevice *pThis) { D3DDevice_KickPushBuffer(); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetVerticalBlankCallback(D3DDevice *pThis, D3DCALLBACK pCallback) { D3DDevice_SetVerticalBlankCallback(pCallback); }
D3DINLINE void    WINAPI IDirect3DDevice8_BlockUntilVerticalBlank(D3DDevice *pThis) { D3DDevice_BlockUntilVerticalBlank(); }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_InsertFence(D3DDevice *pThis) { return D3DDevice_InsertFence(); }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_IsFencePending(D3DDevice *pThis, DWORD Fence) { return D3DDevice_IsFencePending(Fence); }
D3DINLINE VOID    WINAPI IDirect3DDevice8_BlockOnFence(D3DDevice *pThis, DWORD Fence) { D3DDevice_BlockOnFence(Fence); }
D3DINLINE void    WINAPI IDirect3DDevice8_InsertCallback(D3DDevice *pThis, D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context) { D3DDevice_InsertCallback(Type, pCallback, Context); }
D3DINLINE void    WINAPI IDirect3DDevice8_FlushVertexCache(D3DDevice *pThis) { D3DDevice_FlushVertexCache(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_PersistDisplay(D3DDevice *pThis) { return D3DDevice_PersistDisplay(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPersistedSurface(D3DDevice *pThis, IDirect3DSurface8 **ppSurface) { D3DDevice_GetPersistedSurface(ppSurface); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_UpdateOverlay(D3DDevice *pThis, D3DSurface *pSurface, RECT *SrcRect, RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey) { D3DDevice_UpdateOverlay(pSurface, SrcRect, DstRect, EnableColorKey, ColorKey); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EnableOverlay(D3DDevice *pThis, BOOL Enable) { D3DDevice_EnableOverlay(Enable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EnableCC(D3DDevice *pThis, BOOL Enable) { D3DDevice_EnableCC(Enable); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SendCC(D3DDevice *pThis, BOOL Field, BYTE cc1, BYTE cc2) { D3DDevice_SendCC(Field, cc1, cc2); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetCCStatus(D3DDevice *pThis, BOOL *pField1, BOOL *pField2) { D3DDevice_GetCCStatus(pField1, pField2); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginVisibilityTest(D3DDevice *pThis) { D3DDevice_BeginVisibilityTest(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndVisibilityTest(D3DDevice *pThis, DWORD Index) { return D3DDevice_EndVisibilityTest(Index); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVisibilityTestResult(D3DDevice *pThis, DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp) { return D3DDevice_GetVisibilityTestResult(Index, pResult, pTimeStamp); }
D3DINLINE BOOL    WINAPI IDirect3DDevice8_GetOverlayUpdateStatus(D3DDevice *pThis) { return D3DDevice_GetOverlayUpdateStatus(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetDisplayFieldStatus(D3DDevice *pThis, D3DFIELD_STATUS *pFieldStatus) { D3DDevice_GetDisplayFieldStatus(pFieldStatus); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData2f(D3DDevice *pThis, INT Register, FLOAT a, FLOAT b) { D3DDevice_SetVertexData2f(Register, a, b); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4f(D3DDevice *pThis, INT Register, FLOAT a, FLOAT b, FLOAT c, FLOAT d) { D3DDevice_SetVertexData4f(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData2s(D3DDevice *pThis, INT Register, SHORT a, SHORT b) { D3DDevice_SetVertexData2s(Register, a, b); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4s(D3DDevice *pThis, INT Register, SHORT a, SHORT b, SHORT c, SHORT d) { D3DDevice_SetVertexData4s(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexData4ub(D3DDevice *pThis, INT Register, BYTE a, BYTE b, BYTE c, BYTE d) { D3DDevice_SetVertexData4ub(Register, a, b, c, d); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexDataColor(D3DDevice *pThis, INT Register, D3DCOLOR Color) { D3DDevice_SetVertexDataColor(Register, Color); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Begin(D3DDevice *pThis, D3DPRIMITIVETYPE PrimitiveType) { D3DDevice_Begin(PrimitiveType); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_End(D3DDevice *pThis) { D3DDevice_End(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreateFixup(D3DDevice *pThis, UINT Size, D3DFixup **ppFixup) { return D3DDevice_CreateFixup(Size, ppFixup); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_CreatePushBuffer(D3DDevice *pThis, UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer** ppPushBuffer) { return D3DDevice_CreatePushBuffer(Size, RunUsingCpuCopy, ppPushBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_BeginPushBuffer(D3DDevice *pThis, D3DPushBuffer *pPushBuffer) { D3DDevice_BeginPushBuffer(pPushBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_EndPushBuffer(D3DDevice *pThis) { return D3DDevice_EndPushBuffer(); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_RunPushBuffer(D3DDevice *pThis, D3DPushBuffer* pPushBuffer, D3DFixup *pFixup) { D3DDevice_RunPushBuffer(pPushBuffer, pFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetPushBufferOffset(D3DDevice *pThis, DWORD* pOffset) { D3DDevice_GetPushBufferOffset(pOffset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Nop(D3DDevice *pThis) { D3DDevice_Nop(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetProjectionViewportMatrix(D3DDevice *pThis, D3DMATRIX* pProjectionViewport) { D3DDevice_GetProjectionViewportMatrix(pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetModelView(D3DDevice *pThis, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DDevice_SetModelView(pModelView, pInverseModelView, pComposite); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetModelView(D3DDevice *pThis, D3DMATRIX* pModelView) { return D3DDevice_GetModelView(pModelView); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexBlendModelView(D3DDevice *pThis, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DDevice_SetVertexBlendModelView(Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexBlendModelView(D3DDevice *pThis, UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport) { return D3DDevice_GetVertexBlendModelView(Count, pModelViews, pProjectionViewport); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetVertexShaderInput(D3DDevice *pThis, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInput(Handle, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetVertexShaderInput(D3DDevice *pThis, DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs) { return D3DDevice_GetVertexShaderInput(pHandle, pStreamCount, pStreamInputs); }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SwitchTexture(D3DDevice *pThis, DWORD Stage, D3DBaseTexture *pTexture) { D3DDevice_SwitchTexture(D3DTEXTUREDIRECTENCODE[Stage], (pTexture)->Data, (pTexture)->Format); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Suspend(D3DDevice *pThis) { D3DDevice_Suspend(); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_Resume(D3DDevice *pThis, BOOL Reset) { D3DDevice_Resume(Reset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetScissors(D3DDevice *pThis, DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects) { D3DDevice_SetScissors(Count, Exclusive, pRects); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetScissors(D3DDevice *pThis, DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects) { D3DDevice_GetScissors(pCount, pExclusive, pRects); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_SetTile(D3DDevice *pThis, DWORD Index, D3DTILE* pTile) { D3DDevice_SetTile(Index, pTile); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DDevice8_GetTile(D3DDevice *pThis, DWORD Index, D3DTILE* pTile) { D3DDevice_GetTile(Index, pTile); return S_OK; }
D3DINLINE DWORD   WINAPI IDirect3DDevice8_GetTileCompressionTags(D3DDevice *pThis, DWORD ZStartTag, DWORD ZEndTag) { return D3DDevice_GetTileCompressionTags(ZStartTag, ZEndTag); }
D3DINLINE void    WINAPI IDirect3DDevice8_SetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_SetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DINLINE void    WINAPI IDirect3DDevice8_GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_GetTileCompressionTagBits(Partition, Address, pData, Count); }
                                                                                                                                 

#ifdef __cplusplus

D3DMINLINE ULONG   WINAPI D3DDevice::AddRef() { return D3DDevice_AddRef(); }
D3DMINLINE ULONG   WINAPI D3DDevice::Release() { return D3DDevice_Release(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDirect3D(Direct3D **ppD3D8) { D3DDevice_GetDirect3D(ppD3D8); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDeviceCaps(D3DCAPS8 *pCaps) { D3DDevice_GetDeviceCaps(pCaps); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDisplayMode(D3DDISPLAYMODE *pMode) { D3DDevice_GetDisplayMode(pMode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetCreationParameters(D3DDEVICE_CREATION_PARAMETERS *pParameters) { D3DDevice_GetCreationParameters(pParameters); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Reset(D3DPRESENT_PARAMETERS *pPresentationParameters) { return D3DDevice_Reset(pPresentationParameters); }
D3DMINLINE HRESULT WINAPI D3DDevice::Present(CONST RECT *pSourceRect, CONST RECT *pDestRect, void *pUnused, void *pUnused2) { D3DDevice_Present(pSourceRect, pDestRect, pUnused, pUnused2); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackBuffer(INT BackBuffer, D3DBACKBUFFER_TYPE Type, D3DSurface **ppBackBuffer) { D3DDevice_GetBackBuffer(BackBuffer, Type, ppBackBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRasterStatus(D3DRASTER_STATUS *pRasterStatus) { D3DDevice_GetRasterStatus(pRasterStatus); return S_OK; }
D3DMINLINE void    WINAPI D3DDevice::SetFlickerFilter(DWORD Filter) { D3DDevice_SetFlickerFilter(Filter); }
D3DMINLINE void    WINAPI D3DDevice::SetSoftDisplayFilter(BOOL Enable) { D3DDevice_SetSoftDisplayFilter(Enable); }
D3DMINLINE void    WINAPI D3DDevice::SetGammaRamp(DWORD Flags, CONST D3DGAMMARAMP *pRamp) { D3DDevice_SetGammaRamp(Flags, pRamp); }
D3DMINLINE void    WINAPI D3DDevice::GetGammaRamp(D3DGAMMARAMP *pRamp) { D3DDevice_GetGammaRamp(pRamp); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateTexture(UINT Width, UINT Height, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DTexture **ppTexture) { return D3DDevice_CreateTexture(Width, Height, Levels, Usage, Format, Pool, ppTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVolumeTexture(UINT Width, UINT Height, UINT Depth, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DVolumeTexture **ppVolumeTexture) { return D3DDevice_CreateVolumeTexture(Width, Height, Depth, Levels, Usage, Format, Pool, ppVolumeTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateCubeTexture(UINT EdgeLength, UINT Levels, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DCubeTexture **ppCubeTexture) { return D3DDevice_CreateCubeTexture(EdgeLength, Levels, Usage, Format, Pool, ppCubeTexture); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVertexBuffer(UINT Length, DWORD Usage, DWORD FVF, D3DPOOL Pool, D3DVertexBuffer **ppVertexBuffer) { return D3DDevice_CreateVertexBuffer(Length, Usage, FVF, Pool, ppVertexBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateIndexBuffer(UINT Length, DWORD Usage, D3DFORMAT Format, D3DPOOL Pool, D3DIndexBuffer **ppIndexBuffer) { return D3DDevice_CreateIndexBuffer(Length, Usage, Format, Pool, ppIndexBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePalette(D3DPALETTESIZE Size, D3DPalette **ppPalette) { return D3DDevice_CreatePalette(Size, ppPalette); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateRenderTarget(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, BOOL Lockable, D3DSurface **ppSurface) { return D3DDevice_CreateRenderTarget(Width, Height, Format, MultiSample, Lockable, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateDepthStencilSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DMULTISAMPLE_TYPE MultiSample, D3DSurface **ppSurface) { return D3DDevice_CreateDepthStencilSurface(Width, Height, Format, MultiSample, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateImageSurface(UINT Width, UINT Height, D3DFORMAT Format, D3DSurface **ppSurface) { return D3DDevice_CreateImageSurface(Width, Height, Format, ppSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::CopyRects(D3DSurface *pSourceSurface, CONST RECT *pSourceRectsArray, UINT cRects, D3DSurface *pDestinationSurface, CONST POINT *pDestPointsArray) { D3DDevice_CopyRects(pSourceSurface, pSourceRectsArray, cRects, pDestinationSurface, pDestPointsArray); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::UpdateTexture(D3DBaseTexture *pSourceTexture, D3DBaseTexture *pDestinationTexture) { D3DDevice_UpdateTexture(pSourceTexture, pDestinationTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderTarget(D3DSurface *pRenderTarget, D3DSurface *pNewZStencil) { D3DDevice_SetRenderTarget(pRenderTarget, pNewZStencil); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRenderTarget(D3DSurface **ppRenderTarget) { D3DDevice_GetRenderTarget(ppRenderTarget); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDepthStencilSurface(D3DSurface **ppZStencilSurface) { return D3DDevice_GetDepthStencilSurface(ppZStencilSurface); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginScene() { D3DDevice_BeginScene(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndScene() { D3DDevice_EndScene(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Clear(DWORD Count, CONST D3DRECT *pRects, DWORD Flags, D3DCOLOR Color, float Z, DWORD Stencil) { D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDIRTY_TRANSFORM(State); D3DDevice_SetTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTransform(D3DTRANSFORMSTATETYPE State, D3DMATRIX *pMatrix) { D3DDevice_GetTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::MultiplyTransform(D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX *pMatrix) { D3DDevice_MultiplyTransform(State, pMatrix); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetViewport(CONST D3DVIEWPORT8 *pViewport) { D3DDIRTY_VIEWPORT(); D3DDevice_SetViewport(pViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetViewport(D3DVIEWPORT8 *pViewport) { D3DDevice_GetViewport(pViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetMaterial(CONST D3DMATERIAL8 *pMaterial) { D3DDIRTY_MATERIAL(); D3DDevice_SetMaterial(pMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetMaterial(D3DMATERIAL8 *pMaterial) { D3DDevice_GetMaterial(pMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetBackMaterial(CONST D3DMATERIAL8 *pBackMaterial) { D3DDIRTY_BACKMATERIAL(); D3DDevice_SetBackMaterial(pBackMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetBackMaterial(D3DMATERIAL8 *pBackMaterial) { D3DDevice_GetBackMaterial(pBackMaterial); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetLight(DWORD Index, CONST D3DLIGHT8 *pLight) { return D3DDevice_SetLight(Index, pLight); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetLight(DWORD Index, D3DLIGHT8 *pLight) { D3DDevice_GetLight(Index, pLight); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LightEnable(DWORD Index, BOOL Enable) { return D3DDevice_LightEnable(Index, Enable); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetLightEnable(DWORD Index, BOOL *pEnable) { D3DDevice_GetLightEnable(Index, pEnable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderState(D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderState(State, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetRenderStateNotInline(D3DRENDERSTATETYPE State, DWORD Value) { D3DDIRTY_RENDERSTATE(State); D3DDevice_SetRenderStateNotInline(State, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetRenderState(D3DRENDERSTATETYPE State, DWORD *pValue) { D3DDevice_GetRenderState(State, pValue); return S_OK; }
#if D3DCOMPILE_BEGINSTATEBLOCK
D3DMINLINE HRESULT WINAPI D3DDevice::BeginStateBlock() { D3DDevice_BeginStateBlock(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndStateBlock(DWORD *pToken) { return D3DDevice_EndStateBlock(pToken); }
#endif
D3DMINLINE HRESULT WINAPI D3DDevice::ApplyStateBlock(DWORD Token) { D3DDevice_ApplyStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CaptureStateBlock(DWORD Token) { D3DDevice_CaptureStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DeleteStateBlock(DWORD Token) { D3DDevice_DeleteStateBlock(Token); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateStateBlock(D3DSTATEBLOCKTYPE Type,DWORD *pToken) { return D3DDevice_CreateStateBlock(Type, pToken); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTexture(DWORD Stage, D3DBaseTexture **ppTexture) { D3DDevice_GetTexture(Stage, ppTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTexture(DWORD Stage, D3DBaseTexture *pTexture) { D3DDIRTY_TEXTURE(Stage); D3DDevice_SetTexture(Stage, pTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPalette(DWORD Stage, D3DPalette **ppPalette) { D3DDevice_GetPalette(Stage, ppPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPalette(DWORD Stage, D3DPalette *pPalette) { D3DDevice_SetPalette(Stage, pPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD *pValue) { D3DDevice_GetTextureStageState(Stage, Type, pValue); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTextureStageState(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageState(Stage, Type, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTextureStageStateNotInline(DWORD Stage, D3DTEXTURESTAGESTATETYPE Type, DWORD Value) { D3DDIRTY_TEXTURESTATE(Stage, Type); D3DDevice_SetTextureStageStateNotInline(Stage, Type, Value); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT PrimitiveCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount)); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType, UINT MinIndex, UINT NumIndices, UINT StartIndex, UINT PrimitiveCount) { D3DDevice_DrawIndexedVertices(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), D3D__IndexData + StartIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT PrimitiveCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedPrimitiveUP(D3DPRIMITIVETYPE PrimitiveType, UINT MinVertexIndex, UINT NumVertexIndices, UINT PrimitiveCount, CONST void *pIndexData, D3DFORMAT IndexDataFormat, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, D3DVERTEXCOUNT(PrimitiveType, PrimitiveCount), pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawVertices(D3DPRIMITIVETYPE PrimitiveType, UINT StartVertex, UINT VertexCount) { D3DDevice_DrawVertices(PrimitiveType, StartVertex, VertexCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedVertices(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST WORD* pIndexData) { D3DDevice_DrawIndexedVertices(PrimitiveType, VertexCount, pIndexData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawVerticesUP(PrimitiveType, VertexCount, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawIndexedVerticesUP(D3DPRIMITIVETYPE PrimitiveType, UINT VertexCount, CONST void *pIndexData, CONST void *pVertexStreamZeroData, UINT VertexStreamZeroStride) { D3DDevice_DrawIndexedVerticesUP(PrimitiveType, VertexCount, pIndexData, pVertexStreamZeroData, VertexStreamZeroStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::PrimeVertexCache(UINT VertexCount, CONST WORD *pIndexData) { D3DDevice_PrimeVertexCache(VertexCount, pIndexData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateVertexShader(CONST DWORD *pDeclaration, CONST DWORD *pFunction, DWORD *pHandle, DWORD Usage) { return D3DDevice_CreateVertexShader(pDeclaration, pFunction, pHandle, Usage); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShader(DWORD Handle) { D3DDIRTY_VERTEXSHADER(); D3DDevice_SetVertexShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShader(DWORD *pHandle) { D3DDevice_GetVertexShader(pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetShaderConstantMode(D3DSHADERCONSTANTMODE Mode) { D3DDevice_SetShaderConstantMode(Mode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetShaderConstantMode(D3DSHADERCONSTANTMODE *pMode) { D3DDevice_GetShaderConstantMode(pMode); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LoadVertexShader(DWORD Handle, DWORD Address) { D3DDevice_LoadVertexShader(Handle, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::LoadVertexShaderProgram(DWORD *pFunction, DWORD Address) { D3DDevice_LoadVertexShaderProgram(pFunction, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SelectVertexShader(DWORD Handle, DWORD Address) { D3DDevice_SelectVertexShader(Handle, Address); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::RunVertexStateShader(DWORD Address, CONST float *pData) { D3DDevice_RunVertexStateShader(Address, pData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderSize(DWORD Handle, UINT *pSize) { D3DDevice_GetVertexShaderSize(Handle, pSize); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderType(DWORD Handle, DWORD *pType) { D3DDevice_GetVertexShaderType(Handle, pType); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderDeclaration(DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderDeclaration(Handle, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderFunction(DWORD Handle, void *pData, DWORD *pSizeOfData) { return D3DDevice_GetVertexShaderFunction(Handle, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DDevice::DeleteVertexShader(DWORD Handle) { D3DDevice_DeleteVertexShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderConstant(INT Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_VERTEXSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderConstant(INT Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetVertexShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetStreamSource(UINT StreamNumber, D3DVertexBuffer *pStreamData, UINT Stride) { D3DDIRTY_STREAM(StreamNumber); D3DDevice_SetStreamSource(StreamNumber, pStreamData, Stride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetStreamSource(UINT StreamNumber, D3DVertexBuffer **ppStreamData, UINT *pStride) { D3DDevice_GetStreamSource(StreamNumber, ppStreamData, pStride); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetIndices(D3DIndexBuffer* pIndexData, UINT BaseVertexIndex) { D3DDIRTY_INDICES(); D3DDevice_SetIndices(pIndexData, BaseVertexIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetIndices(D3DIndexBuffer** ppIndexData, UINT *pBaseVertexIndex) { D3DDevice_GetIndices(ppIndexData, pBaseVertexIndex); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePixelShader(CONST D3DPIXELSHADERDEF *pPSDef, DWORD *pHandle) { D3DDevice_CreatePixelShader(pPSDef, pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShader(DWORD Handle) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShaderProgram(D3DPIXELSHADERDEF *pPSDef) { D3DDIRTY_PIXELSHADER(); D3DDevice_SetPixelShaderProgram(pPSDef); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShader(DWORD *pHandle) { D3DDevice_GetPixelShader(pHandle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DeletePixelShader(DWORD Handle) { D3DDevice_DeletePixelShader(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetPixelShaderConstant(DWORD Register, CONST void *pConstantData, DWORD ConstantCount) { D3DDIRTY_PIXELSHADERCONSTANT(Register, ConstantCount); D3DDevice_SetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShaderConstant(DWORD Register, void *pConstantData, DWORD ConstantCount) { D3DDevice_GetPixelShaderConstant(Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPixelShaderFunction(DWORD Handle, D3DPIXELSHADERDEF *pData) { D3DDevice_GetPixelShaderFunction(Handle, pData); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawRectPatch(UINT Handle, CONST float *pNumSegs, CONST D3DRECTPATCH_INFO *pRectPatchInfo) { return D3DDevice_DrawRectPatch(Handle, pNumSegs, pRectPatchInfo); }
D3DMINLINE HRESULT WINAPI D3DDevice::DrawTriPatch(UINT Handle, CONST float *pNumSegs, CONST D3DTRIPATCH_INFO *pTriPatchInfo) { return D3DDevice_DrawTriPatch(Handle, pNumSegs, pTriPatchInfo); }
D3DMINLINE HRESULT WINAPI D3DDevice::DeletePatch(UINT Handle) { D3DDevice_DeletePatch(Handle); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::UpdateOverlay(D3DSurface *pSurface, RECT *SrcRect, RECT *DstRect, BOOL EnableColorKey, D3DCOLOR ColorKey) { D3DDevice_UpdateOverlay(pSurface, SrcRect, DstRect, EnableColorKey, ColorKey); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EnableOverlay(BOOL Enable) { D3DDevice_EnableOverlay(Enable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EnableCC(BOOL Enable) { D3DDevice_EnableCC(Enable); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SendCC(BOOL Field, BYTE cc1, BYTE cc2) { D3DDevice_SendCC(Field, cc1, cc2); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetCCStatus(BOOL *pField1, BOOL *pField2) { D3DDevice_GetCCStatus(pField1, pField2); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginVisibilityTest() { D3DDevice_BeginVisibilityTest(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndVisibilityTest(DWORD Index) { return D3DDevice_EndVisibilityTest(Index); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVisibilityTestResult(DWORD Index, UINT *pResult, ULONGLONG *pTimeStamp) { return D3DDevice_GetVisibilityTestResult(Index, pResult, pTimeStamp); }
D3DMINLINE BOOL    WINAPI D3DDevice::IsBusy() { return D3DDevice_IsBusy(); }
D3DMINLINE void    WINAPI D3DDevice::BlockUntilIdle() { D3DDevice_BlockUntilIdle(); }
D3DMINLINE void    WINAPI D3DDevice::KickPushBuffer() { D3DDevice_KickPushBuffer(); }
D3DMINLINE void    WINAPI D3DDevice::SetVerticalBlankCallback(D3DCALLBACK pCallback) { D3DDevice_SetVerticalBlankCallback(pCallback); }
D3DMINLINE void    WINAPI D3DDevice::BlockUntilVerticalBlank() { D3DDevice_BlockUntilVerticalBlank(); }
D3DMINLINE DWORD   WINAPI D3DDevice::InsertFence() { return D3DDevice_InsertFence(); }
D3DMINLINE BOOL    WINAPI D3DDevice::IsFencePending(DWORD Fence) { return D3DDevice_IsFencePending(Fence); }
D3DMINLINE void    WINAPI D3DDevice::BlockOnFence(DWORD Fence) { D3DDevice_BlockOnFence(Fence); }
D3DMINLINE void    WINAPI D3DDevice::InsertCallback(D3DCALLBACKTYPE Type, D3DCALLBACK pCallback, DWORD Context) { D3DDevice_InsertCallback(Type, pCallback, Context); }
D3DMINLINE void    WINAPI D3DDevice::FlushVertexCache() { D3DDevice_FlushVertexCache(); }
D3DMINLINE HRESULT WINAPI D3DDevice::PersistDisplay() { return D3DDevice_PersistDisplay(); }
D3DMINLINE HRESULT WINAPI GetPersistedSurface(IDirect3DSurface8 **ppSurface) { return D3DDevice_GetPersistedSurface(ppSurface); return S_OK; }
D3DMINLINE BOOL    WINAPI D3DDevice::GetOverlayUpdateStatus() { return D3DDevice_GetOverlayUpdateStatus(); }
D3DMINLINE HRESULT WINAPI D3DDevice::GetDisplayFieldStatus(D3DFIELD_STATUS *pFieldStatus) { D3DDevice_GetDisplayFieldStatus(pFieldStatus); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData2f(INT Register, FLOAT a, FLOAT b) { D3DDevice_SetVertexData2f(Register, a, b); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4f(INT Register, FLOAT a, FLOAT b, FLOAT c, FLOAT d) { D3DDevice_SetVertexData4f(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData2s(INT Register, SHORT a, SHORT b) { D3DDevice_SetVertexData2s(Register, a, b); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4s(INT Register, SHORT a, SHORT b, SHORT c, SHORT d) { D3DDevice_SetVertexData4s(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexData4ub(INT Register, BYTE a, BYTE b, BYTE c, BYTE d) { D3DDevice_SetVertexData4ub(Register, a, b, c, d); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexDataColor(INT Register, D3DCOLOR Color) { D3DDevice_SetVertexDataColor(Register, Color); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Begin(D3DPRIMITIVETYPE PrimitiveType) { D3DDevice_Begin(PrimitiveType); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::End() { D3DDevice_End(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::CreateFixup(UINT Size, D3DFixup **ppFixup) { return D3DDevice_CreateFixup(Size, ppFixup); }
D3DMINLINE HRESULT WINAPI D3DDevice::CreatePushBuffer(UINT Size, BOOL RunUsingCpuCopy, D3DPushBuffer **ppPushBuffer) { return D3DDevice_CreatePushBuffer(Size, RunUsingCpuCopy, ppPushBuffer); }
D3DMINLINE HRESULT WINAPI D3DDevice::BeginPushBuffer(D3DPushBuffer* pPushBuffer) { D3DDevice_BeginPushBuffer(pPushBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::EndPushBuffer() { return D3DDevice_EndPushBuffer(); }
D3DMINLINE HRESULT WINAPI D3DDevice::RunPushBuffer(D3DPushBuffer* pPushBuffer, D3DFixup *pFixup) { D3DDevice_RunPushBuffer(pPushBuffer, pFixup); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetPushBufferOffset(DWORD* pOffset) { D3DDevice_GetPushBufferOffset(pOffset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Nop() { D3DDevice_Nop(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetProjectionViewportMatrix(D3DMATRIX* pProjectionViewport) { D3DDevice_GetProjectionViewportMatrix(pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetModelView(CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DDevice_SetModelView(pModelView, pInverseModelView, pComposite); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetModelView(D3DMATRIX* pModelView) { return D3DDevice_GetModelView(pModelView); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexBlendModelView(UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DDevice_SetVertexBlendModelView(Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexBlendModelView(UINT Count, D3DMATRIX* pModelViews, D3DMATRIX* pProjectionViewport) { return D3DDevice_GetVertexBlendModelView(Count, pModelViews, pProjectionViewport); }
D3DMINLINE HRESULT WINAPI D3DDevice::SetVertexShaderInput(DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT* pStreamInputs) { D3DDevice_SetVertexShaderInput(Handle, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetVertexShaderInput(DWORD* pHandle, UINT* pStreamCount, D3DSTREAM_INPUT* pStreamInputs) { return D3DDevice_GetVertexShaderInput(pHandle, pStreamCount, pStreamInputs); }
D3DMINLINE HRESULT WINAPI D3DDevice::SwitchTexture(DWORD Stage, D3DBaseTexture *pTexture) { D3DDevice_SwitchTexture(D3DTEXTUREDIRECTENCODE[Stage], (pTexture)->Data, (pTexture)->Format); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Suspend() { D3DDevice_Suspend(); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::Resume(BOOL Reset) { D3DDevice_Resume(Reset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetScissors(DWORD Count, BOOL Exclusive, CONST D3DRECT *pRects) { D3DDevice_SetScissors(Count, Exclusive, pRects); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetScissors(DWORD* pCount, BOOL *pExclusive, D3DRECT *pRects) { D3DDevice_GetScissors(pCount, pExclusive, pRects); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::SetTile(DWORD Index, D3DTILE* pTile) { D3DDevice_SetTile(Index, pTile); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DDevice::GetTile(DWORD Index, D3DTILE* pTile) { D3DDevice_GetTile(Index, pTile); return S_OK; }
D3DMINLINE DWORD   WINAPI D3DDevice::GetTileCompressionTags(DWORD ZStartTag, DWORD ZEndTag) { return D3DDevice_GetTileCompressionTags(ZStartTag, ZEndTag); }
D3DMINLINE void    WINAPI D3DDevice::SetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_SetTileCompressionTagBits(Partition, Address, pData, Count); }
D3DMINLINE void    WINAPI D3DDevice::GetTileCompressionTagBits(DWORD Partition, DWORD Address, DWORD *pData, DWORD Count) { D3DDevice_GetTileCompressionTagBits(Partition, Address, pData, Count); }

#endif __cplusplus

/* D3DResource */

ULONG   WINAPI D3DResource_AddRef(D3DResource *pThis);
ULONG   WINAPI D3DResource_Release(D3DResource *pThis);
void    WINAPI D3DResource_GetDevice(D3DResource *pThis, D3DDevice **ppDevice);
HRESULT WINAPI D3DResource_SetPrivateData(D3DResource *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags);
HRESULT WINAPI D3DResource_GetPrivateData(D3DResource *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData);
void    WINAPI D3DResource_FreePrivateData(D3DResource *pThis, REFGUID refguid);
D3DRESOURCETYPE WINAPI D3DResource_GetType(D3DResource *pThis);
BOOL    WINAPI D3DResource_IsBusy(D3DResource *pThis);
void    WINAPI D3DResource_BlockUntilNotBusy(D3DResource *pThis);
void    WINAPI D3DResource_Register(D3DResource *pThis, void *pBase);
D3DINLINE void WINAPI D3DResource_MoveResourceMemory(D3DResource *pThis, D3DMEMORY where) { }

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DResource8_AddRef(D3DResource *pThis) { return D3DResource_AddRef(pThis); }
D3DINLINE ULONG   WINAPI IDirect3DResource8_Release(D3DResource *pThis) { return D3DResource_Release(pThis); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_GetDevice(D3DResource *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice(pThis, ppDevice); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DResource8_SetPrivateData(D3DResource *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData(pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_GetPrivateData(D3DResource *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData(pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DResource8_FreePrivateData(D3DResource *pThis, REFGUID refguid) { D3DResource_FreePrivateData(pThis, refguid); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DResource8_GetType(D3DResource *pThis) { return D3DResource_GetType(pThis); }
D3DINLINE BOOL    WINAPI IDirect3DResource8_IsBusy(D3DResource *pThis) { return D3DResource_IsBusy(pThis); }
D3DINLINE void    WINAPI IDirect3DResource8_BlockUntilNotBusy(D3DResource *pThis) { D3DResource_BlockUntilNotBusy(pThis); }
D3DINLINE void    WINAPI IDirect3DResource8_MoveResourceMemory(D3DResource *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory(pThis, where); }
D3DINLINE void    WINAPI IDirect3DResource8_Register(D3DResource *pThis, void *pBase) { D3DResource_Register(pThis, pBase); }

#ifdef __cplusplus

D3DMINLINE ULONG WINAPI D3DResource::AddRef() { return D3DResource_AddRef(this); }
D3DMINLINE ULONG WINAPI D3DResource::Release() { return D3DResource_Release(this); }
D3DMINLINE HRESULT WINAPI D3DResource::GetDevice(D3DDevice **ppDevice) { D3DResource_GetDevice(this, ppDevice); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DResource::SetPrivateData(REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData(this, refguid, pData, SizeOfData, Flags); }
D3DMINLINE HRESULT WINAPI D3DResource::GetPrivateData(REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData(this, refguid, pData, pSizeOfData); }
D3DMINLINE HRESULT WINAPI D3DResource::FreePrivateData(REFGUID refguid) { D3DResource_FreePrivateData(this, refguid); return S_OK; }
D3DMINLINE D3DRESOURCETYPE WINAPI D3DResource::GetType() { return D3DResource_GetType(this); }
D3DMINLINE BOOL    WINAPI D3DResource::IsBusy() { return D3DResource_IsBusy(this); }
D3DMINLINE void    WINAPI D3DResource::BlockUntilNotBusy() { D3DResource_BlockUntilNotBusy(this); }
D3DMINLINE void    WINAPI D3DResource::MoveResourceMemory(D3DMEMORY where) { D3DResource_MoveResourceMemory(this, where); }
D3DMINLINE void    WINAPI D3DResource::Register(void *pBase) { D3DResource_Register(this, pBase); }

#endif __cplusplus

/* D3DBaseTexture */

D3DINLINE ULONG   WINAPI D3DBaseTexture_AddRef(D3DBaseTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DBaseTexture_Release(D3DBaseTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_GetDevice(D3DBaseTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DBaseTexture_GetType(D3DBaseTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DBaseTexture_IsBusy(D3DBaseTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_BlockUntilNotBusy(D3DBaseTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DBaseTexture_MoveResourceMemory(D3DBaseTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DBaseTexture_Register(D3DBaseTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DBaseTexture_SetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DBaseTexture_GetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DBaseTexture_FreePrivateData(D3DBaseTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

DWORD WINAPI D3DBaseTexture_GetLevelCount(D3DBaseTexture *pThis);

// Compatibility wrappers.

D3DINLINE ULONG   WINAPI IDirect3DBaseTexture8_AddRef(D3DBaseTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DBaseTexture8_Release(D3DBaseTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_GetDevice(D3DBaseTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DBaseTexture8_GetType(D3DBaseTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DBaseTexture8_IsBusy(D3DBaseTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_BlockUntilNotBusy(D3DBaseTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_MoveResourceMemory(D3DBaseTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DBaseTexture8_Register(D3DBaseTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_SetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_GetPrivateData(D3DBaseTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DBaseTexture8_FreePrivateData(D3DBaseTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE DWORD WINAPI IDirect3DBaseTexture8_GetLevelCount(D3DBaseTexture *pThis) { return D3DBaseTexture_GetLevelCount(pThis); }

#ifdef __cplusplus

D3DMINLINE DWORD WINAPI D3DBaseTexture::GetLevelCount() { return D3DBaseTexture_GetLevelCount(this); }

#endif __cplusplus

/* D3DTexture */

D3DINLINE ULONG   WINAPI D3DTexture_AddRef(D3DTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DTexture_Release(D3DTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_GetDevice(D3DTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DTexture_GetType(D3DTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DTexture_IsBusy(D3DTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_BlockUntilNotBusy(D3DTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DTexture_MoveResourceMemory(D3DTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DTexture_Register(D3DTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DTexture_GetLevelCount(D3DTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DTexture_SetPrivateData(D3DTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DTexture_GetPrivateData(D3DTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DTexture_FreePrivateData(D3DTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DTexture_GetLevelDesc(D3DTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
HRESULT WINAPI D3DTexture_GetSurfaceLevel(D3DTexture *pThis, UINT Level, D3DSurface **ppSurfaceLevel);
void    WINAPI D3DTexture_LockRect(D3DTexture *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DTexture_UnlockRect(D3DTexture *pThis, UINT Level) { }

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DTexture8_AddRef(D3DTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DTexture8_Release(D3DTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetDevice(D3DTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DTexture8_GetType(D3DTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DTexture8_IsBusy(D3DTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DTexture8_BlockUntilNotBusy(D3DTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DTexture8_MoveResourceMemory(D3DTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DTexture8_Register(D3DTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DTexture8_GetLevelCount(D3DTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_SetPrivateData(D3DTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetPrivateData(D3DTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_FreePrivateData(D3DTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetLevelDesc(D3DTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc) { D3DTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_GetSurfaceLevel(D3DTexture *pThis, UINT Level, D3DSurface **ppSurfaceLevel) { return D3DTexture_GetSurfaceLevel(pThis, Level, ppSurfaceLevel); }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_LockRect(D3DTexture *pThis, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DTexture_LockRect(pThis, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DTexture8_UnlockRect(D3DTexture *pThis, UINT Level) { D3DTexture_UnlockRect(pThis, Level); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DTexture::GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc) { D3DTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DTexture::GetSurfaceLevel(UINT Level, D3DSurface **ppSurfaceLevel) { return D3DTexture_GetSurfaceLevel(this, Level, ppSurfaceLevel); }
D3DMINLINE HRESULT WINAPI D3DTexture::LockRect(UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DTexture_LockRect(this, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DTexture::UnlockRect(UINT Level) { D3DTexture_UnlockRect(this, Level); return S_OK; }

#endif __cplusplus

/* D3DVolumeTexture */

D3DINLINE ULONG   WINAPI D3DVolumeTexture_AddRef(D3DVolumeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVolumeTexture_Release(D3DVolumeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_GetDevice(D3DVolumeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVolumeTexture_GetType(D3DVolumeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVolumeTexture_IsBusy(D3DVolumeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_BlockUntilNotBusy(D3DVolumeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolumeTexture_MoveResourceMemory(D3DVolumeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVolumeTexture_Register(D3DVolumeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DVolumeTexture_GetLevelCount(D3DVolumeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DVolumeTexture_SetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVolumeTexture_GetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVolumeTexture_FreePrivateData(D3DVolumeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVolumeTexture_GetLevelDesc(D3DVolumeTexture *pThis, UINT Level, D3DVOLUME_DESC *pDesc);
HRESULT WINAPI D3DVolumeTexture_GetVolumeLevel(D3DVolumeTexture *pThis, UINT Level, D3DVolume **ppVolumeLevel);
void    WINAPI D3DVolumeTexture_LockBox(D3DVolumeTexture *pThis, UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
D3DINLINE void WINAPI D3DVolumeTexture_UnlockBox(D3DVolumeTexture *pThis, UINT Level) { }

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DVolumeTexture8_AddRef(D3DVolumeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVolumeTexture8_Release(D3DVolumeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetDevice(D3DVolumeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVolumeTexture8_GetType(D3DVolumeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVolumeTexture8_IsBusy(D3DVolumeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_BlockUntilNotBusy(D3DVolumeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_MoveResourceMemory(D3DVolumeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVolumeTexture8_Register(D3DVolumeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DVolumeTexture8_GetLevelCount(D3DVolumeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_SetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetPrivateData(D3DVolumeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_FreePrivateData(D3DVolumeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetLevelDesc(D3DVolumeTexture *pThis, UINT Level, D3DVOLUME_DESC *pDesc) { D3DVolumeTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_GetVolumeLevel(D3DVolumeTexture *pThis, UINT Level, D3DVolume **ppVolumeLevel) { return D3DVolumeTexture_GetVolumeLevel(pThis, Level, ppVolumeLevel); }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_LockBox(D3DVolumeTexture *pThis, UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolumeTexture_LockBox(pThis, Level, pLockedVolume, pBox, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolumeTexture8_UnlockBox(D3DVolumeTexture *pThis, UINT Level) { D3DVolumeTexture_UnlockBox(pThis, Level); return S_OK; }


#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVolumeTexture::GetLevelDesc(UINT Level, D3DVOLUME_DESC *pDesc) { D3DVolumeTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::GetVolumeLevel(UINT Level, D3DVolume **ppVolumeLevel) { return D3DVolumeTexture_GetVolumeLevel(this, Level, ppVolumeLevel); }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::LockBox(UINT Level, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolumeTexture_LockBox(this, Level, pLockedVolume, pBox, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolumeTexture::UnlockBox(UINT Level) { D3DVolumeTexture_UnlockBox(this, Level); return S_OK; }

#endif __cplusplus

/* D3DCubeTexture */

D3DINLINE ULONG   WINAPI D3DCubeTexture_AddRef(D3DCubeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DCubeTexture_Release(D3DCubeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_GetDevice(D3DCubeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DCubeTexture_GetType(D3DCubeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DCubeTexture_IsBusy(D3DCubeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_BlockUntilNotBusy(D3DCubeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DCubeTexture_MoveResourceMemory(D3DCubeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DCubeTexture_Register(D3DCubeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI D3DCubeTexture_GetLevelCount(D3DCubeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI D3DCubeTexture_SetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DCubeTexture_GetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DCubeTexture_FreePrivateData(D3DCubeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DCubeTexture_GetLevelDesc(D3DCubeTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc);
HRESULT WINAPI D3DCubeTexture_GetCubeMapSurface(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface);
void    WINAPI D3DCubeTexture_LockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DCubeTexture_UnlockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level) { }

D3DINLINE ULONG   WINAPI IDirect3DCubeTexture8_AddRef(D3DCubeTexture *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DCubeTexture8_Release(D3DCubeTexture *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetDevice(D3DCubeTexture *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DCubeTexture8_GetType(D3DCubeTexture *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DCubeTexture8_IsBusy(D3DCubeTexture *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_BlockUntilNotBusy(D3DCubeTexture *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_MoveResourceMemory(D3DCubeTexture *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DCubeTexture8_Register(D3DCubeTexture *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE DWORD   WINAPI IDirect3DCubeTexture8_GetLevelCount(D3DCubeTexture *pThis) { return D3DBaseTexture_GetLevelCount((D3DBaseTexture *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_SetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetPrivateData(D3DCubeTexture *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_FreePrivateData(D3DCubeTexture *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetLevelDesc(D3DCubeTexture *pThis, UINT Level, D3DSURFACE_DESC *pDesc) { D3DCubeTexture_GetLevelDesc(pThis, Level, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_GetCubeMapSurface(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface) { return D3DCubeTexture_GetCubeMapSurface(pThis, FaceType, Level, ppCubeMapSurface); }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_LockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DCubeTexture_LockRect(pThis, FaceType, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DCubeTexture8_UnlockRect(D3DCubeTexture *pThis, D3DCUBEMAP_FACES FaceType, UINT Level) { D3DCubeTexture_UnlockRect(pThis, FaceType, Level); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DCubeTexture::GetLevelDesc(UINT Level, D3DSURFACE_DESC *pDesc) { D3DCubeTexture_GetLevelDesc(this, Level, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::GetCubeMapSurface(D3DCUBEMAP_FACES FaceType, UINT Level, D3DSurface **ppCubeMapSurface) { return D3DCubeTexture_GetCubeMapSurface(this, FaceType, Level, ppCubeMapSurface); }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::LockRect(D3DCUBEMAP_FACES FaceType, UINT Level, D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DCubeTexture_LockRect(this, FaceType, Level, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DCubeTexture::UnlockRect(D3DCUBEMAP_FACES FaceType, UINT Level) { D3DCubeTexture_UnlockRect(this, FaceType, Level); return S_OK; }

#endif __cplusplus

/* D3DVertexBuffer */

D3DINLINE ULONG   WINAPI D3DVertexBuffer_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVertexBuffer_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVertexBuffer_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVertexBuffer_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_BlockUntilNotBusy(D3DVertexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVertexBuffer_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVertexBuffer_Register(D3DVertexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DVertexBuffer_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVertexBuffer_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVertexBuffer_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVertexBuffer_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags);
void    WINAPI D3DVertexBuffer_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc);
D3DINLINE void WINAPI D3DVertexBuffer_Unlock(D3DVertexBuffer *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DVertexBuffer8_AddRef(D3DVertexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVertexBuffer8_Release(D3DVertexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetDevice(D3DVertexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVertexBuffer8_GetType(D3DVertexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVertexBuffer8_IsBusy(D3DVertexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_BlockUntilNotBusy(D3DVertexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_MoveResourceMemory(D3DVertexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVertexBuffer8_Register(D3DVertexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_SetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetPrivateData(D3DVertexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_FreePrivateData(D3DVertexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_Lock(D3DVertexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DVertexBuffer_Lock(pThis, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_Unlock(D3DVertexBuffer *pThis) { D3DVertexBuffer_Unlock(pThis); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVertexBuffer8_GetDesc(D3DVertexBuffer *pThis, D3DVERTEXBUFFER_DESC *pDesc) { D3DVertexBuffer_GetDesc(pThis, pDesc); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVertexBuffer::Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DVertexBuffer_Lock(this, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVertexBuffer::Unlock() { D3DVertexBuffer_Unlock(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVertexBuffer::GetDesc(D3DVERTEXBUFFER_DESC *pDesc) { D3DVertexBuffer_GetDesc(this, pDesc); return S_OK; }

#endif __cplusplus

/* D3DIndexBuffer */

D3DINLINE ULONG   WINAPI D3DIndexBuffer_AddRef(D3DIndexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DIndexBuffer_Release(D3DIndexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_GetDevice(D3DIndexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DIndexBuffer_GetType(D3DIndexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DIndexBuffer_IsBusy(D3DIndexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_BlockUntilNotBusy(D3DIndexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DIndexBuffer_MoveResourceMemory(D3DIndexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DIndexBuffer_Register(D3DIndexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DIndexBuffer_SetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DIndexBuffer_GetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DIndexBuffer_FreePrivateData(D3DIndexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

D3DINLINE void    WINAPI D3DIndexBuffer_Lock(D3DIndexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { *(ppbData) = (BYTE*) (pThis)->Data + (OffsetToLock); }
D3DINLINE void    WINAPI D3DIndexBuffer_Unlock(D3DIndexBuffer *pThis) { }
void    WINAPI D3DIndexBuffer_GetDesc(D3DIndexBuffer *pThis, D3DINDEXBUFFER_DESC *pDesc);

// Compatibilty wrappers.

D3DINLINE ULONG   WINAPI IDirect3DIndexBuffer8_AddRef(D3DIndexBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DIndexBuffer8_Release(D3DIndexBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetDevice(D3DIndexBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DIndexBuffer8_GetType(D3DIndexBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DIndexBuffer8_IsBusy(D3DIndexBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_BlockUntilNotBusy(D3DIndexBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_MoveResourceMemory(D3DIndexBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DIndexBuffer8_Register(D3DIndexBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_SetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetPrivateData(D3DIndexBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_FreePrivateData(D3DIndexBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_Lock(D3DIndexBuffer *pThis, UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DIndexBuffer_Lock(pThis, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_Unlock(D3DIndexBuffer *pThis) { D3DIndexBuffer_Unlock(pThis); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DIndexBuffer8_GetDesc(D3DIndexBuffer *pThis, D3DINDEXBUFFER_DESC *pDesc) { D3DIndexBuffer_GetDesc(pThis, pDesc); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DIndexBuffer::Lock(UINT OffsetToLock, UINT SizeToLock, BYTE **ppbData, DWORD Flags) { D3DIndexBuffer_Lock(this, OffsetToLock, SizeToLock, ppbData, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DIndexBuffer::Unlock() { D3DIndexBuffer_Unlock(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DIndexBuffer::GetDesc(D3DINDEXBUFFER_DESC *pDesc) { D3DIndexBuffer_GetDesc(this, pDesc); return S_OK; }

#endif __cplusplus

/* D3DPalette */

D3DINLINE ULONG   WINAPI D3DPalette_AddRef(D3DPalette *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DPalette_Release(D3DPalette *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_GetDevice(D3DPalette *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DPalette_GetType(D3DPalette *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DPalette_IsBusy(D3DPalette *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_BlockUntilNotBusy(D3DPalette *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPalette_MoveResourceMemory(D3DPalette *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DPalette_Register(D3DPalette *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DPalette_SetPrivateData(D3DPalette *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DPalette_GetPrivateData(D3DPalette *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DPalette_FreePrivateData(D3DPalette *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DPalette_Lock(D3DPalette *pThis, D3DCOLOR **ppColor, DWORD Flags);
D3DPALETTESIZE WINAPI D3DPalette_GetSize(D3DPalette *pThis);
D3DINLINE void WINAPI D3DPalette_Unlock(D3DPalette *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DPalette8_AddRef(D3DPalette *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DPalette8_Release(D3DPalette *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_GetDevice(D3DPalette *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DPalette8_GetType(D3DPalette *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DPalette8_IsBusy(D3DPalette *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPalette8_BlockUntilNotBusy(D3DPalette *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPalette8_MoveResourceMemory(D3DPalette *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DPalette8_Register(D3DPalette *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_SetPrivateData(D3DPalette *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_GetPrivateData(D3DPalette *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_FreePrivateData(D3DPalette *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DPalette8_Lock(D3DPalette *pThis, D3DCOLOR **ppColor, DWORD Flags) { D3DPalette_Lock(pThis, ppColor, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPalette8_Unlock(D3DPalette *pThis) { D3DPalette_Unlock(pThis); return S_OK; }
D3DINLINE D3DPALETTESIZE WINAPI IDirect3DPalette8_GetSize(D3DPalette *pThis) { return D3DPalette_GetSize(pThis); }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DPalette::Lock(D3DCOLOR **ppColors, DWORD Flags) { D3DPalette_Lock(this, ppColors, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPalette::Unlock() { D3DPalette_Unlock(this); return S_OK; }
D3DMINLINE D3DPALETTESIZE WINAPI D3DPalette::GetSize() { return D3DPalette_GetSize(this); }

#endif __cplusplus

/* D3DPushBuffer */

D3DINLINE ULONG   WINAPI D3DPushBuffer_AddRef(D3DPushBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DPushBuffer_Release(D3DPushBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_GetDevice(D3DPushBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DPushBuffer_GetType(D3DPushBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DPushBuffer_IsBusy(D3DPushBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_BlockUntilNotBusy(D3DPushBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DPushBuffer_MoveResourceMemory(D3DPushBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DPushBuffer_Register(D3DPushBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DPushBuffer_SetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DPushBuffer_GetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DPushBuffer_FreePrivateData(D3DPushBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DPushBuffer_Verify(D3DPushBuffer* pPushBuffer, BOOL StampResources);
void    WINAPI D3DPushBuffer_BeginFixup(D3DPushBuffer* pPushBuffer, D3DFixup* pFixup, BOOL NoWait);
HRESULT WINAPI D3DPushBuffer_EndFixup(D3DPushBuffer* pPushBuffer);
void    WINAPI D3DPushBuffer_RunPushBuffer(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup);
void    WINAPI D3DPushBuffer_SetModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite);
void    WINAPI D3DPushBuffer_SetVertexBlendModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport);
void    WINAPI D3DPushBuffer_SetVertexShaderInput(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs);
void    WINAPI D3DPushBuffer_SetRenderTarget(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer);
void    WINAPI D3DPushBuffer_SetTexture(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture);
void    WINAPI D3DPushBuffer_SetPalette(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage,D3DPalette *pPalette);
HRESULT WINAPI D3DPushBuffer_EndVisibilityTest(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Index);
void    WINAPI D3DPushBuffer_SetVertexShaderConstant(D3DPushBuffer* pPushBuffer, DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount);
void    WINAPI D3DPushBuffer_Jump(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT DestinationOffset);

D3DINLINE ULONG   WINAPI IDirect3DPushBuffer8_AddRef(D3DPushBuffer *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DPushBuffer8_Release(D3DPushBuffer *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetDevice(D3DPushBuffer *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DPushBuffer8_GetType(D3DPushBuffer *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DPushBuffer8_IsBusy(D3DPushBuffer *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_BlockUntilNotBusy(D3DPushBuffer *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_MoveResourceMemory(D3DPushBuffer *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DPushBuffer8_Register(D3DPushBuffer *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetPrivateData(D3DPushBuffer *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_FreePrivateData(D3DPushBuffer *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_Verify(D3DPushBuffer* pPushBuffer, BOOL StampResources) { D3DPushBuffer_Verify(pPushBuffer, StampResources); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_BeginFixup(D3DPushBuffer* pPushBuffer, D3DFixup* pFixup, BOOL NoWait) { D3DPushBuffer_BeginFixup(pPushBuffer, pFixup, NoWait); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_EndFixup(D3DPushBuffer* pPushBuffer) { return D3DPushBuffer_EndFixup(pPushBuffer); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_RunPushBuffer(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup) { D3DPushBuffer_RunPushBuffer(pPushBuffer, Offset, pDestinationPushBuffer, pDestinationFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DPushBuffer_SetModelView(pPushBuffer, Offset, pModelView, pInverseModelView, pComposite); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexBlendModelView(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DPushBuffer_SetVertexBlendModelView(pPushBuffer, Offset, Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderInput(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInput(pPushBuffer, Offset, Handle, StreamCount, pStreamInputs); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetRenderTarget(D3DPushBuffer* pPushBuffer, DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer) { D3DPushBuffer_SetRenderTarget(pPushBuffer, Offset, pRenderTarget, pZBuffer); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetTexture(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture) { D3DPushBuffer_SetTexture(pPushBuffer, Offset, Stage, pTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetPalette(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Stage,D3DPalette *pPalette) { D3DPushBuffer_SetPalette(pPushBuffer, Offset, Stage, pPalette); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_EndVisibilityTest(D3DPushBuffer* pPushBuffer, DWORD Offset, DWORD Index) { return D3DPushBuffer_EndVisibilityTest(pPushBuffer, Offset, Index); }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_SetVertexShaderConstant(D3DPushBuffer* pPushBuffer, DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount) { D3DPushBuffer_SetVertexShaderConstant(pPushBuffer, Offset, Register, pConstantData, ConstantCount); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_Jump(D3DPushBuffer* pPushBuffer, DWORD Offset, UINT DestinationOffset) { D3DPushBuffer_Jump(pPushBuffer, Offset, DestinationOffset); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DPushBuffer8_GetSize(D3DPushBuffer* pPushBuffer, DWORD* pSize) { *pSize = pPushBuffer->Size; return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DPushBuffer::Verify(BOOL StampResources) { D3DPushBuffer_Verify(this, StampResources); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::BeginFixup(D3DFixup* pFixup, BOOL NoWait) { D3DPushBuffer_BeginFixup(this, pFixup, NoWait); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::EndFixup() { return D3DPushBuffer_EndFixup(this); }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::RunPushBuffer(DWORD Offset, D3DPushBuffer* pDestinationPushBuffer, D3DFixup* pDestinationFixup) { D3DPushBuffer_RunPushBuffer(this, Offset, pDestinationPushBuffer, pDestinationFixup); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetModelView(DWORD Offset, CONST D3DMATRIX* pModelView, CONST D3DMATRIX* pInverseModelView, CONST D3DMATRIX* pComposite) { D3DPushBuffer_SetModelView(this, Offset, pModelView, pInverseModelView, pComposite); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexBlendModelView(DWORD Offset, UINT Count, CONST D3DMATRIX* pModelViews, CONST D3DMATRIX* pInverseModelViews, CONST D3DMATRIX* pProjectionViewport) { D3DPushBuffer_SetVertexBlendModelView(this, Offset, Count, pModelViews, pInverseModelViews, pProjectionViewport); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderInput(DWORD Offset, DWORD Handle, UINT StreamCount, CONST D3DSTREAM_INPUT *pStreamInputs) { D3DPushBuffer_SetVertexShaderInput(this, Offset, Handle, StreamCount, pStreamInputs); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetRenderTarget(DWORD Offset, D3DSurface* pRenderTarget, D3DSurface* pZBuffer) { D3DPushBuffer_SetRenderTarget(this, Offset, pRenderTarget, pZBuffer); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetTexture(DWORD Offset, DWORD Stage, D3DBaseTexture *pTexture) { D3DPushBuffer_SetTexture(this, Offset, Stage, pTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetPalette(DWORD Offset, DWORD Stage,D3DPalette *pPalette) { D3DPushBuffer_SetPalette(this, Offset, Stage, pPalette); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::EndVisibilityTest(DWORD Offset, DWORD Index) { return D3DPushBuffer_EndVisibilityTest(this, Offset, Index); }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::SetVertexShaderConstant(DWORD Offset, INT Register, CONST void* pConstantData, DWORD ConstantCount) { D3DPushBuffer_SetVertexShaderConstant(this, Offset, Register, pConstantData, ConstantCount); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::Jump(DWORD Offset, UINT DestinationOffset) { D3DPushBuffer_Jump(this, Offset, DestinationOffset); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DPushBuffer::GetSize(DWORD* pSize) { *pSize = Size; return S_OK; }

#endif __cplusplus

/* D3DFixup */

D3DINLINE ULONG   WINAPI D3DFixup_AddRef(D3DFixup *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DFixup_Release(D3DFixup *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_GetDevice(D3DFixup *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DFixup_GetType(D3DFixup *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DFixup_IsBusy(D3DFixup *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_BlockUntilNotBusy(D3DFixup *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DFixup_MoveResourceMemory(D3DFixup *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DFixup_Register(D3DFixup *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DFixup_SetPrivateData(D3DFixup *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DFixup_GetPrivateData(D3DFixup *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DFixup_FreePrivateData(D3DFixup *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DFixup_Reset(D3DFixup* pFixup);
void    WINAPI D3DFixup_GetSize(D3DFixup* pFixup, DWORD* pSize);
void    WINAPI D3DFixup_GetSpace(D3DFixup* pFixup, DWORD* pSpace);

D3DINLINE ULONG   WINAPI IDirect3DFixup8_AddRef(D3DFixup *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DFixup8_Release(D3DFixup *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetDevice(D3DFixup *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DFixup8_GetType(D3DFixup *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DFixup8_IsBusy(D3DFixup *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DFixup8_BlockUntilNotBusy(D3DFixup *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DFixup8_MoveResourceMemory(D3DFixup *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DFixup8_Register(D3DFixup *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_SetPrivateData(D3DFixup *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetPrivateData(D3DFixup *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_FreePrivateData(D3DFixup *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }

D3DINLINE HRESULT WINAPI IDirect3DFixup8_Reset(D3DFixup* pFixup) { D3DFixup_Reset(pFixup); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetSize(D3DFixup* pFixup, DWORD* pSize) { D3DFixup_GetSize(pFixup, pSize); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DFixup8_GetSpace(D3DFixup* pFixup, DWORD* pSpace) { D3DFixup_GetSpace(pFixup, pSpace); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DFixup::Reset() { D3DFixup_Reset(this); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DFixup::GetSize(DWORD* pSize) { D3DFixup_GetSize(this, pSize); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DFixup::GetSpace(DWORD* pSpace) { D3DFixup_GetSpace(this, pSpace); return S_OK; }

#endif __cplusplus

/* D3DSurface */

D3DINLINE ULONG   WINAPI D3DSurface_AddRef(D3DSurface *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DSurface_Release(D3DSurface *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_GetDevice(D3DSurface *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DSurface_GetType(D3DSurface *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DSurface_IsBusy(D3DSurface *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_BlockUntilNotBusy(D3DSurface *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DSurface_MoveResourceMemory(D3DSurface *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DSurface_Register(D3DSurface *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DSurface_SetPrivateData(D3DSurface *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DSurface_GetPrivateData(D3DSurface *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DSurface_FreePrivateData(D3DSurface *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

HRESULT WINAPI D3DSurface_GetContainer(D3DSurface *pThis, D3DBaseTexture **ppBaseTexture);
void    WINAPI D3DSurface_GetDesc(D3DSurface *pThis, D3DSURFACE_DESC *pDesc);
void    WINAPI D3DSurface_LockRect(D3DSurface *pThis, D3DLOCKED_RECT *pLockedRect,CONST RECT *pRect, DWORD Flags);
D3DINLINE void WINAPI D3DSurface_UnlockRect(D3DSurface *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DSurface8_AddRef(D3DSurface *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DSurface8_Release(D3DSurface *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetDevice(D3DSurface *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DSurface8_GetType(D3DSurface *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DSurface8_IsBusy(D3DSurface *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DSurface8_BlockUntilNotBusy(D3DSurface *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DSurface8_MoveResourceMemory(D3DSurface *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DSurface8_Register(D3DSurface *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_SetPrivateData(D3DSurface *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetPrivateData(D3DSurface *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_FreePrivateData(D3DSurface *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetContainer(D3DSurface *pThis, D3DBaseTexture **ppBaseTexture) { return D3DSurface_GetContainer(pThis, ppBaseTexture); }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_GetDesc(D3DSurface *pThis, D3DSURFACE_DESC *pDesc) { D3DSurface_GetDesc(pThis, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_LockRect(D3DSurface *pThis, D3DLOCKED_RECT *pLockedRect,CONST RECT *pRect, DWORD Flags) { D3DSurface_LockRect(pThis, pLockedRect,pRect, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DSurface8_UnlockRect(D3DSurface *pThis) { D3DSurface_UnlockRect(pThis); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DSurface::GetContainer(D3DBaseTexture **ppBaseTexture) { return D3DSurface_GetContainer(this, ppBaseTexture); }
D3DMINLINE HRESULT WINAPI D3DSurface::GetDesc(D3DSURFACE_DESC *pDesc) { D3DSurface_GetDesc(this, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DSurface::LockRect(D3DLOCKED_RECT *pLockedRect, CONST RECT *pRect, DWORD Flags) { D3DSurface_LockRect(this, pLockedRect, pRect, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DSurface::UnlockRect() { D3DSurface_UnlockRect(this); return S_OK; }

#endif __cplusplus

/* D3DVolume */

D3DINLINE ULONG   WINAPI D3DVolume_AddRef(D3DVolume *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI D3DVolume_Release(D3DVolume *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_GetDevice(D3DVolume *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); }
D3DINLINE D3DRESOURCETYPE WINAPI D3DVolume_GetType(D3DVolume *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI D3DVolume_IsBusy(D3DVolume *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_BlockUntilNotBusy(D3DVolume *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI D3DVolume_MoveResourceMemory(D3DVolume *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI D3DVolume_Register(D3DVolume *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI D3DVolume_SetPrivateData(D3DVolume *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI D3DVolume_GetPrivateData(D3DVolume *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE void    WINAPI D3DVolume_FreePrivateData(D3DVolume *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); }

void    WINAPI D3DVolume_GetContainer(D3DVolume *pThis, D3DBaseTexture **ppBaseTexture);
void    WINAPI D3DVolume_GetDesc(D3DVolume *pThis, D3DVOLUME_DESC *pDesc);
void    WINAPI D3DVolume_LockBox(D3DVolume *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags);
D3DINLINE void WINAPI D3DVolume_UnlockBox(D3DVolume *pThis) { }

D3DINLINE ULONG   WINAPI IDirect3DVolume8_AddRef(D3DVolume *pThis) { return D3DResource_AddRef((D3DResource *)pThis); }
D3DINLINE ULONG   WINAPI IDirect3DVolume8_Release(D3DVolume *pThis) { return D3DResource_Release((D3DResource *)pThis); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetDevice(D3DVolume *pThis, D3DDevice **ppDevice) { D3DResource_GetDevice((D3DResource *)pThis, ppDevice); return S_OK; }
D3DINLINE D3DRESOURCETYPE WINAPI IDirect3DVolume8_GetType(D3DVolume *pThis) { return D3DResource_GetType((D3DResource *)pThis); }
D3DINLINE BOOL    WINAPI IDirect3DVolume8_IsBusy(D3DVolume *pThis) { return D3DResource_IsBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolume8_BlockUntilNotBusy(D3DVolume *pThis) { D3DResource_BlockUntilNotBusy((D3DResource *)pThis); }
D3DINLINE void    WINAPI IDirect3DVolume8_MoveResourceMemory(D3DVolume *pThis, D3DMEMORY where) { D3DResource_MoveResourceMemory((D3DResource *)pThis, where); }
D3DINLINE void    WINAPI IDirect3DVolume8_Register(D3DVolume *pThis, void *pBase) { D3DResource_Register((D3DResource *)pThis, pBase); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_SetPrivateData(D3DVolume *pThis, REFGUID refguid, CONST void *pData, DWORD SizeOfData, DWORD Flags) { return D3DResource_SetPrivateData((D3DResource *)pThis, refguid, pData, SizeOfData, Flags); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetPrivateData(D3DVolume *pThis, REFGUID refguid, void *pData, DWORD *pSizeOfData) { return D3DResource_GetPrivateData((D3DResource *)pThis, refguid, pData, pSizeOfData); }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_FreePrivateData(D3DVolume *pThis, REFGUID refguid) { D3DResource_FreePrivateData((D3DResource *)pThis, refguid); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetContainer(D3DVolume *pThis, D3DBaseTexture **ppBaseTexture) { D3DVolume_GetContainer(pThis, ppBaseTexture); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_GetDesc(D3DVolume *pThis, D3DVOLUME_DESC *pDesc) { D3DVolume_GetDesc(pThis, pDesc); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_LockBox(D3DVolume *pThis, D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolume_LockBox(pThis, pLockedVolume, pBox, Flags); return S_OK; }
D3DINLINE HRESULT WINAPI IDirect3DVolume8_UnlockBox(D3DVolume *pThis) { D3DVolume_UnlockBox(pThis); return S_OK; }

#ifdef __cplusplus

D3DMINLINE HRESULT WINAPI D3DVolume::GetContainer(D3DBaseTexture **ppBaseTexture) { D3DVolume_GetContainer(this, ppBaseTexture); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::GetDesc(D3DVOLUME_DESC *pDesc) { D3DVolume_GetDesc(this, pDesc); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::LockBox(D3DLOCKED_BOX *pLockedVolume, CONST D3DBOX *pBox, DWORD Flags) { D3DVolume_LockBox(this, pLockedVolume, pBox, Flags); return S_OK; }
D3DMINLINE HRESULT WINAPI D3DVolume::UnlockBox() { D3DVolume_UnlockBox(this); return S_OK; }

#endif __cplusplus

#ifdef __cplusplus
};
#endif

#pragma warning( pop )

#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3dx8core.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8core.h
//  Content:    D3DX core types and functions
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8CORE_H__
#define __D3DX8CORE_H__

#undef INTERFACE
#define INTERFACE VOID

///////////////////////////////////////////////////////////////////////////
// ID3DXBuffer:
// ------------
// The buffer object is used to return arbitrary lenght data.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXBuffer ID3DXBuffer;
typedef interface ID3DXBuffer *LPD3DXBUFFER;

// {932E6A7E-C68E-45dd-A7BF-53D19C86DB1F}
DEFINE_GUID(IID_ID3DXBuffer,
0x932e6a7e, 0xc68e, 0x45dd, 0xa7, 0xbf, 0x53, 0xd1, 0x9c, 0x86, 0xdb, 0x1f);

DECLARE_INTERFACE_(ID3DXBuffer, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBuffer
    STDMETHOD_(LPVOID, GetBufferPointer)(THIS) PURE;
    STDMETHOD_(DWORD, GetBufferSize)(THIS) PURE;
};






///////////////////////////////////////////////////////////////////////////
// ID3DXSprite:
// ------------
// This object intends to provide an easy way to drawing sprites using D3D.
//
// Begin -
//    Prepares device for drawing sprites
//
// Draw, DrawAffine, DrawTransform
//    Draws a sprite in screen-space.  Before transformation, the sprite is
//    the size of SrcRect, with its top-left corner at the origin (0,0).
//    The color and alpha channels are modulated by Color.
//
// End -
//     Restores device state to how it was when Begin was called.
///////////////////////////////////////////////////////////////////////////

typedef interface ID3DXSprite ID3DXSprite;
typedef interface ID3DXSprite *LPD3DXSPRITE;


// {E8691849-87B8-4929-9050-1B0542D5538C}
DEFINE_GUID( IID_ID3DXSprite,
0xe8691849, 0x87b8, 0x4929, 0x90, 0x50, 0x1b, 0x5, 0x42, 0xd5, 0x53, 0x8c);


DECLARE_INTERFACE_(ID3DXSprite, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSprite
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;

    STDMETHOD(Begin)(THIS) PURE;

    STDMETHOD(Draw)(THIS_ LPDIRECT3DTEXTURE8  pSrcTexture,
        CONST RECT* pSrcRect, CONST D3DXVECTOR2* pScaling,
        CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation,
        CONST D3DXVECTOR2* pTranslation, D3DCOLOR Color) PURE;

    STDMETHOD(DrawTransform)(THIS_ LPDIRECT3DTEXTURE8 pSrcTexture,
        CONST RECT* pSrcRect, CONST D3DXMATRIX* pTransform,
        D3DCOLOR Color) PURE;

    STDMETHOD(End)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


HRESULT WINAPI
    D3DXCreateSprite(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXSPRITE*       ppSprite);

#ifdef __cplusplus
}
#endif //__cplusplus





///////////////////////////////////////////////////////////////////////////
// ID3DXRenderToSurface:
// ---------------------
// This object abstracts rendering to surfaces.  These surfaces do not
// necessarily need to be render targets.  If they are not, a compatible
// render target is used, and the result copied into surface at end scene.
///////////////////////////////////////////////////////////////////////////

typedef struct _D3DXRTS_DESC
{
    UINT                Width;
    UINT                Height;
    D3DFORMAT           Format;
    BOOL                DepthStencil;
    D3DFORMAT           DepthStencilFormat;

} D3DXRTS_DESC;


typedef interface ID3DXRenderToSurface ID3DXRenderToSurface;
typedef interface ID3DXRenderToSurface *LPD3DXRENDERTOSURFACE;


// {69CC587C-E40C-458d-B5D3-B029E18EB60A}
DEFINE_GUID( IID_ID3DXRenderToSurface,
0x69cc587c, 0xe40c, 0x458d, 0xb5, 0xd3, 0xb0, 0x29, 0xe1, 0x8e, 0xb6, 0xa);


DECLARE_INTERFACE_(ID3DXRenderToSurface, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXRenderToSurface
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXRTS_DESC* pDesc) PURE;

    STDMETHOD(BeginScene)(THIS_ LPDIRECT3DSURFACE8 pSurface, CONST D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateRenderToSurface(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Width,
        UINT                    Height,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRENDERTOSURFACE*  ppRenderToSurface);

#ifdef __cplusplus
}
#endif //__cplusplus



///////////////////////////////////////////////////////////////////////////
// ID3DXRenderToEnvMap:
// --------------------
///////////////////////////////////////////////////////////////////////////

typedef struct _D3DXRTE_DESC
{
    UINT        Size;
    D3DFORMAT   Format;
    BOOL        DepthStencil;
    D3DFORMAT   DepthStencilFormat;
} D3DXRTE_DESC;


typedef interface ID3DXRenderToEnvMap ID3DXRenderToEnvMap;
typedef interface ID3DXRenderToEnvMap *LPD3DXRenderToEnvMap;

// {9F6779E5-60A9-4d8b-AEE4-32770F405DBA}
DEFINE_GUID( IID_ID3DXRenderToEnvMap,
0x9f6779e5, 0x60a9, 0x4d8b, 0xae, 0xe4, 0x32, 0x77, 0xf, 0x40, 0x5d, 0xba);


DECLARE_INTERFACE_(ID3DXRenderToEnvMap, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXRenderToEnvMap
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DXRTE_DESC* pDesc) PURE;

    STDMETHOD(BeginCube)(THIS_
        LPDIRECT3DCUBETEXTURE8 pCubeTex) PURE;

    STDMETHOD(BeginSphere)(THIS_
        LPDIRECT3DTEXTURE8 pTex) PURE;

    STDMETHOD(BeginHemisphere)(THIS_
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg) PURE;

    STDMETHOD(BeginParabolic)(THIS_
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg) PURE;

    STDMETHOD(Face)(THIS_ D3DCUBEMAP_FACES Face) PURE;
    STDMETHOD(End)(THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateRenderToEnvMap(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Size,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRenderToEnvMap*   ppRenderToEnvMap);

#ifdef __cplusplus
}
#endif //__cplusplus

///////////////////////////////////////////////////////////////////////////
// Misc APIs:
///////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


//-------------------------------------------------------------------------
// D3DXGetFVFVertexSize:
// ---------------------
// Returns the size (in bytes) of a vertex for a given FVF.
//-------------------------------------------------------------------------

UINT WINAPI
    D3DXGetFVFVertexSize(DWORD FVF);


//-------------------------------------------------------------------------
// D3DXGetErrorString:
// ------------------
// Returns the error string for given an hresult.  Interprets all D3DX and
// D3D hresults.
//
// Parameters:
//  hr
//      The error code to be deciphered.
//  pBuffer
//      Pointer to the buffer to be filled in.
//  BufferLen
//      Count of characters in buffer.  Any error message longer than this
//      length will be truncated to fit.
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXGetErrorStringA(
        HRESULT             hr,
        LPSTR               pBuffer,
        UINT                BufferLen);

HRESULT WINAPI
    D3DXGetErrorStringW(
        HRESULT             hr,
        LPWSTR              pBuffer,
        UINT                BufferLen);

#ifdef UNICODE
#define D3DXGetErrorString D3DXGetErrorStringW
#else
#define D3DXGetErrorString D3DXGetErrorStringA
#endif



#ifdef __cplusplus
}
#endif //__cplusplus


#endif //__D3DX8CORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3d8perf.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8perf.h
 *  Content:    Xbox Direct3D debug library API
 *
 ****************************************************************************/


#ifndef _D3D8PERF_H_
#define _D3D8PERF_H_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * This file exposes the extra functionality implemented in the
 * debug version of the Direct3D library (d3d8d.lib).
 */

// Enumeration of all of the non-api events that the driver counts.
typedef enum _D3DPERF_PerformanceCounters
{
    PERF_VERTICES,

    PERF_SETTRANSFORM_WORLD,
    PERF_SETTRANSFORM_VIEW,
    PERF_SETTRANSFORM_PROJECTION,
    PERF_SETTRANSFORM_TEXTURE,

    PERF_PUSHBUFFER_SEGMENTS,
    PERF_PUSHBUFFER_WAITS,
    PERF_OBJECTLOCK_WAITS,
    PERF_PRESENT_WAITS,
    PERF_D3DDEVICE_BLOCKUNTILIDLE_WAITS,
    PERF_D3DDEVICE_BLOCKUNTILVERTICALBLANK_WAITS,
    PERF_D3DDEVICE_BLOCKONFENCE_WAITS,
    PERF_CPUSPINDURINGWAIT_TIME,
    PERF_UNSWIZZLING_TEXTURE_LOCKS,
    PERF_PUSHBUFFER_JUMPTOBEGINNING,
    PERF_RUNPUSHBUFFER_BYTES,

    PERF_REDUNDANT_SETRENDERSTATE,
    PERF_REDUNDANT_SETTEXTURESTATE,
    PERF_REDUNDANT_SETVERTEXSHADER,
    PERF_REDUNDANT_SETTRANSFORM,
    PERF_REDUNDANT_SETTEXTURE,
    PERF_REDUNDANT_SETPALETTE,
    PERF_REDUNDANT_SETSTREAMSOURCE,

    PERF_SETSTATE_POINTPARAMS,
    PERF_SETSTATE_COMBINERS,
    PERF_SETSTATE_TEXTURESTATE,
    PERF_SETSTATE_SPECFOGCOMBINER,
    PERF_SETSTATE_TEXTRANSFORM,
    PERF_SETSTATE_LIGHTS,
    PERF_SETSTATE_TRANSFORM,

    D3DPERF_MAX,
    D3DPERF_FORCE_LONG  =   0xFFFFFFFF

} D3DPERF_PerformanceCounters;

// Counts of the number of times each API is called.
typedef enum _D3DPERF_APICounters
{

    /* Direct3D APIs */

    API_DIRECT3D_CHECKDEPTHSTENCILMATCH,
    API_DIRECT3D_CHECKDEVICEFORMAT,
    API_DIRECT3D_CHECKDEVICEMULTISAMPLETYPE,
    API_DIRECT3D_CHECKDEVICETYPE,
    API_DIRECT3D_CREATEDEVICE,
    API_DIRECT3D_ENUMADAPTERMODES,
    API_DIRECT3D_GETADAPTERDISPLAYMODE,
    API_DIRECT3D_GETADAPTERIDENTIFIER,
    API_DIRECT3D_GETADAPTERMODECOUNT,
    API_DIRECT3D_GETDEVICECAPS,
    API_DIRECT3D_SETPUSHBUFFERSIZE,

    /* D3DDevice APIs */

    API_D3DDEVICE_APPLYSTATEBLOCK,
    API_D3DDEVICE_BEGIN,
    API_D3DDEVICE_BEGINPUSHBUFFER,
    API_D3DDEVICE_BEGINSTATEBLOCK,
    API_D3DDEVICE_BEGINVISIBILITYTEST,
    API_D3DDEVICE_BLOCKONFENCE,
    API_D3DDEVICE_BLOCKUNTILIDLE,
    API_D3DDEVICE_BLOCKUNTILVERTICALBLANK,
    API_D3DDEVICE_CAPTURESTATEBLOCK,
    API_D3DDEVICE_CLEAR,
    API_D3DDEVICE_COPYRECTS,
    API_D3DDEVICE_CREATECUBETEXTURE,
    API_D3DDEVICE_CREATEDEPTHSTENCILSURFACE,
    API_D3DDEVICE_CREATEFIXUP,
    API_D3DDEVICE_CREATEIMAGESURFACE,
    API_D3DDEVICE_CREATEINDEXBUFFER,
    API_D3DDEVICE_CREATEPALETTE,
    API_D3DDEVICE_CREATEPIXELSHADER,
    API_D3DDEVICE_CREATEPUSHBUFFER,
    API_D3DDEVICE_CREATERENDERTARGET,
    API_D3DDEVICE_CREATESTATEBLOCK,
    API_D3DDEVICE_CREATETEXTURE,
    API_D3DDEVICE_CREATEVERTEXBUFFER,
    API_D3DDEVICE_CREATEVERTEXSHADER,
    API_D3DDEVICE_CREATEVOLUMETEXTURE,
    API_D3DDEVICE_DELETEPATCH,
    API_D3DDEVICE_DELETEPIXELSHADER,
    API_D3DDEVICE_DELETESTATEBLOCK,
    API_D3DDEVICE_DELETEVERTEXSHADER,
    API_D3DDEVICE_DRAWINDEXEDVERTICES,
    API_D3DDEVICE_DRAWINDEXEDVERTICESUP,
    API_D3DDEVICE_DRAWRECTPATCH,
    API_D3DDEVICE_DRAWTRIPATCH,
    API_D3DDEVICE_DRAWVERTICES,
    API_D3DDEVICE_DRAWVERTICESUP,
    API_D3DDEVICE_ENABLECC,
    API_D3DDEVICE_ENABLEOVERLAY,
    API_D3DDEVICE_END,
    API_D3DDEVICE_ENDPUSHBUFFER,
    API_D3DDEVICE_ENDSTATEBLOCK,
    API_D3DDEVICE_ENDVISIBILITYTEST,
    API_D3DDEVICE_FLUSHVERTEXCACHE,
    API_D3DDEVICE_GETBACKBUFFER,
    API_D3DDEVICE_GETBACKMATERIAL,
    API_D3DDEVICE_GETCCSTATUS,
    API_D3DDEVICE_GETCREATIONPARAMETERS,
    API_D3DDEVICE_GETDEPTHSTENCILSURFACE,
    API_D3DDEVICE_GETDEVICECAPS,
    API_D3DDEVICE_GETDIRECT3D,
    API_D3DDEVICE_GETDISPLAYFIELDSTATUS,
    API_D3DDEVICE_GETDISPLAYMODE,
    API_D3DDEVICE_GETGAMMARAMP,
    API_D3DDEVICE_GETINDICES,
    API_D3DDEVICE_GETLIGHT,
    API_D3DDEVICE_GETLIGHTENABLE,
    API_D3DDEVICE_GETMATERIAL,
    API_D3DDEVICE_GETMODELVIEW,
    API_D3DDEVICE_GETOVERLAYUPDATESTATUS,
    API_D3DDEVICE_GETPALETTE,
    API_D3DDEVICE_GETPIXELSHADER,
    API_D3DDEVICE_GETPIXELSHADERCONSTANT,
    API_D3DDEVICE_GETPIXELSHADERFUNCTION,
    API_D3DDEVICE_GETPROJECTIONVIEWPORTMATRIX,
    API_D3DDEVICE_GETPUSHBUFFEROFFSET,
    API_D3DDEVICE_GETRASTERSTATUS,
    API_D3DDEVICE_GETRENDERSTATE,
    API_D3DDEVICE_GETRENDERTARGET,
    API_D3DDEVICE_GETSCISSORS,
    API_D3DDEVICE_GETSHADERCONSTANTMODE,
    API_D3DDEVICE_GETSTREAMSOURCE,
    API_D3DDEVICE_GETTEXTURE,
    API_D3DDEVICE_GETTEXTURESTAGESTATE,
    API_D3DDEVICE_GETTILE,
    API_D3DDEVICE_GETTILECOMPRESSIONTAGS,
    API_D3DDEVICE_GETTRANSFORM,
    API_D3DDEVICE_GETVERTEXBLENDMODELVIEW,
    API_D3DDEVICE_GETVERTEXSHADER,
    API_D3DDEVICE_GETVERTEXSHADERCONSTANT,
    API_D3DDEVICE_GETVERTEXSHADERDECLARATION,
    API_D3DDEVICE_GETVERTEXSHADERFUNCTION,
    API_D3DDEVICE_GETVERTEXSHADERINPUT,
    API_D3DDEVICE_GETVERTEXSHADERSIZE,
    API_D3DDEVICE_GETVERTEXSHADERTYPE,
    API_D3DDEVICE_GETVIEWPORT,
    API_D3DDEVICE_GETVISIBILITYTESTRESULT,
    API_D3DDEVICE_INSERTCALLBACK,
    API_D3DDEVICE_INSERTFENCE,
    API_D3DDEVICE_ISBUSY,
    API_D3DDEVICE_ISFENCEPENDING,
    API_D3DDEVICE_KICKPUSHBUFFER,
    API_D3DDEVICE_LIGHTENABLE,
    API_D3DDEVICE_LOADVERTEXSHADER,
    API_D3DDEVICE_LOADVERTEXSHADERPROGRAM,
    API_D3DDEVICE_MULTIPLYTRANSFORM,
    API_D3DDEVICE_NOP,
    API_D3DDEVICE_PERSISTDISPLAY,
    API_D3DDEVICE_PRESENT,
    API_D3DDEVICE_PRIMEVERTEXCACHE,
    API_D3DDEVICE_READVERTEXSHADERCONSTANT,
    API_D3DDEVICE_RESET,
    API_D3DDEVICE_RESUME,
    API_D3DDEVICE_RUNPUSHBUFFER,
    API_D3DDEVICE_RUNVERTEXSTATESHADER,
    API_D3DDEVICE_SELECTVERTEXSHADER,
    API_D3DDEVICE_SENDCC,
    API_D3DDEVICE_SETBACKMATERIAL,
    API_D3DDEVICE_SETGAMMARAMP,
    API_D3DDEVICE_SETINDICES,
    API_D3DDEVICE_SETLIGHT,
    API_D3DDEVICE_SETMATERIAL,
    API_D3DDEVICE_SETMODELVIEW,
    API_D3DDEVICE_SETPALETTE,
    API_D3DDEVICE_SETPIXELSHADER,
    API_D3DDEVICE_SETPIXELSHADERCONSTANT,
    API_D3DDEVICE_SETPIXELSHADERPROGRAM,
    API_D3DDEVICE_SETRENDERSTATE_BACKFILLMODE,
    API_D3DDEVICE_SETRENDERSTATE_CULLMODE,
    API_D3DDEVICE_SETRENDERSTATE_DEFERRED,
    API_D3DDEVICE_SETRENDERSTATE_DONOTCULLUNCOMPRESSED,
    API_D3DDEVICE_SETRENDERSTATE_DXT1NOISEENABLE,
    API_D3DDEVICE_SETRENDERSTATE_EDGEANTIALIAS,
    API_D3DDEVICE_SETRENDERSTATE_FILLMODE,
    API_D3DDEVICE_SETRENDERSTATE_FOGCOLOR,
    API_D3DDEVICE_SETRENDERSTATE_FRONTFACE,
    API_D3DDEVICE_SETRENDERSTATE_LINEWIDTH,
    API_D3DDEVICE_SETRENDERSTATE_LOGICOP,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEANTIALIAS,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMASK,
    API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLETYPE,
    API_D3DDEVICE_SETRENDERSTATE_NORMALIZENORMALS,
    API_D3DDEVICE_SETRENDERSTATE_OCCLUSIONCULLENABLE,
    API_D3DDEVICE_SETRENDERSTATE_PARAMETERCHECK,
    API_D3DDEVICE_SETRENDERSTATE_PSTEXTUREMODES,
    API_D3DDEVICE_SETRENDERSTATE_ROPZCMPALWAYSREAD,
    API_D3DDEVICE_SETRENDERSTATE_ROPZREAD,
    API_D3DDEVICE_SETRENDERSTATE_SHADOWFUNC,
    API_D3DDEVICE_SETRENDERSTATE_SIMPLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILCULLENABLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILENABLE,
    API_D3DDEVICE_SETRENDERSTATE_STENCILFAIL,
    API_D3DDEVICE_SETRENDERSTATE_TEXTUREFACTOR,
    API_D3DDEVICE_SETRENDERSTATE_TWOSIDEDLIGHTING,
    API_D3DDEVICE_SETRENDERSTATE_VERTEXBLEND,
    API_D3DDEVICE_SETRENDERSTATE_YUVENABLE,
    API_D3DDEVICE_SETRENDERSTATE_ZBIAS,
    API_D3DDEVICE_SETRENDERSTATE_ZENABLE,
    API_D3DDEVICE_SETRENDERSTATENOTINLINE,
    API_D3DDEVICE_SETRENDERTARGET,
    API_D3DDEVICE_SETSCISSORS,
    API_D3DDEVICE_SETSHADERCONSTANTMODE,
    API_D3DDEVICE_SETSTREAMSOURCE,
    API_D3DDEVICE_SETTEXTURE,
    API_D3DDEVICE_SETTEXTURESTAGESTATENOTINLINE,
    API_D3DDEVICE_SETTEXTURESTATE_BORDERCOLOR,
    API_D3DDEVICE_SETTEXTURESTATE_BUMPENV,
    API_D3DDEVICE_SETTEXTURESTATE_COLORKEYCOLOR,
    API_D3DDEVICE_SETTEXTURESTATE_DEFERRED,
    API_D3DDEVICE_SETTEXTURESTATE_PARAMETERCHECK,
    API_D3DDEVICE_SETTEXTURESTATE_TEXCOORDINDEX,
    API_D3DDEVICE_SETTILE,
    API_D3DDEVICE_SETTRANSFORM,
    API_D3DDEVICE_SETVERTEXBLENDMODELVIEW,
    API_D3DDEVICE_SETVERTEXDATA2F,
    API_D3DDEVICE_SETVERTEXDATA2S,
    API_D3DDEVICE_SETVERTEXDATA4F,
    API_D3DDEVICE_SETVERTEXDATA4S,
    API_D3DDEVICE_SETVERTEXDATA4UB,
    API_D3DDEVICE_SETVERTEXDATACOLOR,
    API_D3DDEVICE_SETVERTEXSHADER,
    API_D3DDEVICE_SETVERTEXSHADERCONSTANT,
    API_D3DDEVICE_SETVERTEXSHADERINPUT,
    API_D3DDEVICE_SETVERTICALBLANKCALLBACK,
    API_D3DDEVICE_SETVIEWPORT,
    API_D3DDEVICE_SUSPEND,
    API_D3DDEVICE_SWITCHTEXTURE,
    API_D3DDEVICE_UPDATEOVERLAY,
    API_D3DDEVICE_UPDATETEXTURE,

    /* D3DResource APIs */

    API_D3DRESOURCE_ADDREF,
    API_D3DRESOURCE_BLOCKUNTILNOTBUSY,
    API_D3DRESOURCE_FREEPRIVATEDATA,
    API_D3DRESOURCE_GETDEVICE,
    API_D3DRESOURCE_GETPRIVATEDATA,
    API_D3DRESOURCE_GETTYPE,
    API_D3DRESOURCE_ISBUSY,
    API_D3DRESOURCE_REGISTER,
    API_D3DRESOURCE_RELEASE,
    API_D3DRESOURCE_SETPRIVATEDATA,

    /* D3DBaseTexture APIs */

    API_D3DBASETEXTURE_GETLEVELCOUNT,

    /* D3DTexture APIs */

    API_D3DTEXTURE_GETLEVELDESC,
    API_D3DTEXTURE_GETSURFACELEVEL,
    API_D3DTEXTURE_LOCKRECT,

    /* D3DCubeTexture APIs */

    API_D3DCUBETEXTURE_GETCUBEMAPSURFACE,
    API_D3DCUBETEXTURE_GETLEVELDESC,
    API_D3DCUBETEXTURE_LOCKRECT,

    /* D3DVolumeTexture APIs */

    API_D3DVOLUMETEXURE_GETLEVELDESC,
    API_D3DVOLUMETEXURE_GETVOLUMELEVEL,
    API_D3DVOLUMETEXURE_LOCKBOX,

    /* D3DVertexBuffer APIs */

    API_D3DVERTEXBUFFER_GETDESC,
    API_D3DVERTEXBUFFER_LOCK,

    /* D3DIndexBuffer APIs */

    API_D3DINDEXBUFFER_GETDESC,

    /* D3DVolume APIs */

    API_D3DVOLUME_GETCONTAINER,
    API_D3DVOLUME_GETDESC,
    API_D3DVOLUME_LOCKBOX,

    /* D3DSurface APIs */

    API_D3DSURFACE_GETCONTAINER,
    API_D3DSURFACE_GETDESC,
    API_D3DSURFACE_LOCKRECT,

    /* D3DPalette APIs */

    API_D3DPALETTE_GETSIZE,
    API_D3DPALETTE_LOCK,

    /* D3DPushBuffer APIs */

    API_D3DPUSHBUFFER_BEGINFIXUP,
    API_D3DPUSHBUFFER_ENDFIXUP,
    API_D3DPUSHBUFFER_ENDVISIBILITYTEST,
    API_D3DPUSHBUFFER_JUMP,
    API_D3DPUSHBUFFER_RUNPUSHBUFFER,
    API_D3DPUSHBUFFER_SETMODELVIEW,
    API_D3DPUSHBUFFER_SETPALETTE,
    API_D3DPUSHBUFFER_SETRENDERTARGET,
    API_D3DPUSHBUFFER_SETTEXTURE,
    API_D3DPUSHBUFFER_SETVERTEXBLENDMODELVIEW,
    API_D3DPUSHBUFFER_SETVERTEXSHADERCONSTANT,
    API_D3DPUSHBUFFER_SETVERTEXSHADERINPUT,
    API_D3DPUSHBUFFER_VERIFY,

    /* D3DFixup APIs */

    API_D3DFIXUP_GETSIZE,
    API_D3DFIXUP_GETSPACE,
    API_D3DFIXUP_RESET,

    D3DAPI_MAX,
    D3DAPI_FORCE_LONG  =   0xFFFFFFFF

} D3DPERF_APICounters;

// A structure that contains performance information gathered by
// the driver.
//
typedef struct _D3DWAITINFO
{
    DWORD Count;
    ULONGLONG Cycles;

} D3DWAITINFO;

// function callback declaration for cycle time threshold callback
//
typedef void (WINAPI *PFNCycleThresholdHandler)(D3DPERF_PerformanceCounters perfctr,
    ULONGLONG Cycles);

// function callback declaration for spewing framerate information
//
typedef void (WINAPI *PFNDumpFrameRateInfoHandler)(void);

// m_dwDumpFPSInfoMask flags which specify what data to display during default
// m_pfnDumpFrameRateInfoHandler callback. By default everything is enabled
// except D3DPERF_DUMP_FPS_PERFPROFILE which has a much higher overhead.
//
// To use set m_FrameRateIntervalTime to 10000 (10ms) or similar.
//
#define D3DPERF_DUMP_FPS_INTINFO        0x00000001  // interrupts & context switches
#define D3DPERF_DUMP_FPS_MEMORY         0x00000002  // memory info
#define D3DPERF_DUMP_FPS_PUSHBUFFER     0x00000004  // pushbuffer info
#define D3DPERF_DUMP_FPS_WAITINFO       0x00000008  // *_WAITS timings
#define D3DPERF_DUMP_FPS_PERFPROFILE    0x00000010  // 100ns timer which pings GPU to
                                                    // determine %busy/idle time.
#define D3DPERF_DUMP_FPS_VERTEXINFO     0x00000020  // vertex processing info

// Structure which allows SetRenderState calls to be overriden. For example,
// set m_RenderStateOverrides[D3DRS_FILLMODE] = { TRUE, D3DFILL_WIREFRAME }
// to turn on wireframe mode.
//
typedef struct _D3DOVERRIDERENDERSTATE
{
    BOOL Override;
    DWORD Value;
} D3DOVERRIDERENDERSTATE;

// D3D profile busy/idle samples
//
typedef enum _D3DPERFPROF
{
    D3DPERF_PROF_GPU,
    D3DPERF_PROF_FE,
    D3DPERF_PROF_BE,
    D3DPERF_PROF_MAX
} D3DPERFPROF;

// Structure that contains all of the performance information gathered by
// the driver.
//
typedef struct _D3DPERF
{
    // Time Stamp Counter value of last D3DPERF_Reset() call.
    ULONGLONG m_TSCLastResetVal;

    // Time Stamp Counter value of last Present() call
    ULONGLONG m_TSCLastPresentVal;

    // Max and Min Frame number (.Count) with cycle counts (.Cycles)
    D3DWAITINFO m_FrameTimeMin;
    D3DWAITINFO m_FrameTimeMax;

    // Issues debug break when perfctr and break number line up.
    DWORD m_BreakCount;
    D3DPERF_PerformanceCounters m_Breakperfctr;

    // Pushbuffer location at D3DPERF_Reset call
    DWORD *m_pPutLocationAtReset;

    // Count of dwords skipped jumping back to pushbuffer start
    ULONGLONG m_PushBufferEndDwordsSkipped;

    // Interval time to dump framerate information in milliseconds
    DWORD m_FrameRateIntervalTime;
    // Mask which controls what information D3DPERF_DumpFrameRateInfo
    // (default m_pfnDumpFrameRateInfoHandler handler) spits out.
    DWORD m_dwDumpFPSInfoMask;
    PFNDumpFrameRateInfoHandler m_pfnDumpFrameRateInfoHandler;

    // Holds threshold cycle count for spewing wait times
    DWORD m_DumpWaitCycleTimesThreshold;
    // Handler function to call when threshold cycle count hit. This
    // function defaults to D3DPERF_DumpCounterCycleInfo which simply
    // dumps PERF_OBJECTLOCK_WAITS count and wait times.
    PFNCycleThresholdHandler m_pfnCycleThresholdHandler;

    // If true, the next D3DPERF_Reset call will go through
    // m_RenderStateOverrides and set any renderstates which have
    // the Override member set to true.
    BOOL m_SetRenderStateOverridesOnReset;

    // Profile data gathered when profile is started via D3DPERF_StartPerfProfile
    //  (also via m_dwDumpFPSInfoMask/m_DumpWaitCycleTimesThreshold)

    // Total number of profile samples read
    DWORD m_ProfileSamples;

    // Time profiler was started. Initialized in D3DPERF_StartPerfProfile.
    ULONGLONG m_TSCProfileStartTime;

    // Perf state bitmask history over last 10ms where it then wraps.
    // 0x2 means gpu (1 << D3DPERF_PROF_GPU) and (1 << D3DPERF_PROF_FE) were busy.
    // Cleared in D3DPERF_StartPerfProfile and D3DPERF_Reset calls.
    WORD m_ProfileData[105000];

    // Total busy counts for each unit read while profiler was enabled
    DWORD m_ProfileBusyCounts[D3DPERF_PROF_MAX];

    // Values used to override any calls to SetRenderState.
    //
    D3DOVERRIDERENDERSTATE m_RenderStateOverrides[D3DRS_MAX];

    // The count of the number of times certain performance-related events
    // happen.  Use D3DPERF_PerformanceCounters to index into this array.
    //
    D3DWAITINFO m_PerformanceCounters[D3DPERF_MAX];

    // The count of the number of times each API is called.  Use
    // D3DPERF_APICounters to index into this array.
    //
    DWORD m_APICounters[D3DAPI_MAX];

    // The count of the number of times each render state is set.  Use
    // D3DRENDERSTATE to index into this array.
    //
    DWORD m_RenderStateCounters[D3DRS_MAX];

    // The count of the number of times each texture state is set.
    DWORD m_TextureStateCounters[D3DTSS_MAX];

} D3DPERF;

// Holds the name of an individual renderstate or texturestate.  You need
// to search through the array of these things to find the name for the
// state.
//
typedef struct _D3DSTATENAME
{
    DWORD m_State;
    char *m_Name;

} D3DSTATENAME;

// Holds the names for the different performance things gathered
// by the driver.
//
typedef struct _D3DPERFNAMES
{
    // Array of string of human-readable names for the above counters.
    char *m_PerformanceCounterNames[D3DPERF_MAX];

    // An array of human-readable names for the above counters.
    char *m_APICounterNames[D3DAPI_MAX];

    // Human-readable names for the renderstate counters.
    D3DSTATENAME m_RenderStateNames[D3DRS_MAX];

    // Human-readable names for the texture states.
    D3DSTATENAME m_TextureStateNames[D3DTSS_MAX];

} D3DPERFNAMES;

// Holds information on the pushbuffer and guesstimate on count of bytes
// written since last D3DPERF_Reset.
//
typedef struct _D3DPUSHBUFFERINFO
{
    DWORD PushBufferSize;
    DWORD PushSegmentSize;
    DWORD PushSegmentCount;

    DWORD *pPushBase;
    DWORD *pPushLimit;

    ULONGLONG PushBufferBytesWritten;

} D3DPUSHBUFFERINFO;


// Returns the performance structure which is statically allocated and should
// never be freed.
//
D3DPERF * WINAPI D3DPERF_GetStatistics();

// Returns an array of names which is statically allocated.
//
D3DPERFNAMES * WINAPI D3DPERF_GetNames();

// Returns information on the pushbuffer
//
void WINAPI D3DPERF_GetPushBufferInfo(D3DPUSHBUFFERINFO *pPushBufferInfo);

// Dumps current frame rate information.
//
void WINAPI D3DPERF_DumpFrameRateInfo();

// Reset all of the perf counters to zero.
//
void WINAPI D3DPERF_Reset();

// Trivial dumper of all statistics to the debug output.
//
void WINAPI D3DPERF_Dump();


// D3D Perf states
//
typedef enum _D3DPERFSTATETYPE
{
    D3DPERFSTATE_VTX_CACHE,     // 4KB pre-t&l cache
    D3DPERFSTATE_VTX_FILE,      // 24 entry post t&l cache
    D3DPERFSTATE_VTX_ALL,       // enable/disable all vtx states
} D3DPERFSTATETYPE;

// Set state routine which allows you to enable/disable
// the vertex cache and/or file. This can be useful to determine
// how well you're currently, or not, using vertex caching.
//
HRESULT WINAPI D3DPERF_SetState(D3DPERFSTATETYPE State, DWORD Value);

// GPU Profile control routines. Enabling the PerfProfiler starts
// profiler interrupt run every 100ns which checks the current busy/idle
// status of the gpu.
//
BOOL WINAPI D3DPERF_StartPerfProfile();
void WINAPI D3DPERF_StopPerfProfile();
void WINAPI D3DPERF_DumpPerfProfCounts();

/*
 * Helper routines to set up various d3dperf members to dump
 *  framerate information.
 */

// Sets a breakpoint on a specified performance counter number
//
__inline void WINAPI D3DPERF_SetBreakPerfCount(D3DPERF_PerformanceCounters perfctr,
    DWORD BreakCount)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_Breakperfctr = perfctr;
    pPerf->m_BreakCount = BreakCount;
}

// Sets frame rate interval (in ms) to call D3DPERF_DumpFrameRateInfo()
//
__inline void WINAPI D3DPERF_SetShowFrameRateInterval(DWORD FrameRateIntervalTime)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_FrameRateIntervalTime = FrameRateIntervalTime;
}

// Default handler for DumpWaitCycleTimesThreshold which just spews
// PERF_OBJECTLOCK_WAITS count and time
void WINAPI D3DPERF_DumpCounterCycleInfo(D3DPERF_PerformanceCounters perfctr,
    ULONGLONG Cycles);

// Sets threshold Cycle count and handler function for hitting wait time thresholds
__inline void WINAPI D3DPERF_SetWaitCycleTimeThreshold(
    PFNCycleThresholdHandler pfnCycleThresholdHandler,
    DWORD DumpWaitCycleTimesThreshold)
{
    D3DPERF *pPerf = D3DPERF_GetStatistics();
    pPerf->m_DumpWaitCycleTimesThreshold = DumpWaitCycleTimesThreshold;
    pPerf->m_pfnCycleThresholdHandler = pfnCycleThresholdHandler;
}

#ifdef __cplusplus
}
#endif

#endif _D3D8PERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3d8types.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8types.h
 *  Content:    Xbox Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8TYPES_H_
#define _D3D8TYPES_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#include <float.h>

#pragma warning(disable:4201) // anonymous unions warning
#pragma pack(4)

// D3DCOLOR is equivalent to D3DFMT_A8R8G8B8
#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

// maps unsigned 8 bits/channel to D3DCOLOR
#define D3DCOLOR_ARGB(a,r,g,b) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))
#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)
#define D3DCOLOR_XRGB(r,g,b)   D3DCOLOR_ARGB(0xff,r,g,b)

// maps floating point channels (0.f to 1.f range) to D3DCOLOR
#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif
typedef struct _D3DVECTOR *LPD3DVECTOR;

#ifndef D3DCOLORVALUE_DEFINED
typedef struct _D3DCOLORVALUE {
    float r;
    float g;
    float b;
    float a;
} D3DCOLORVALUE;
#define D3DCOLORVALUE_DEFINED
#endif

#ifndef D3DRECT_DEFINED
typedef struct _D3DRECT {
    LONG x1;
    LONG y1;
    LONG x2;
    LONG y2;
} D3DRECT;
#define D3DRECT_DEFINED
#endif

#ifndef D3DMATRIX_DEFINED
typedef struct _D3DMATRIX {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
} D3DMATRIX;
#define D3DMATRIX_DEFINED
#endif

typedef struct _D3DVIEWPORT8 {
    DWORD       X;
    DWORD       Y;            /* Viewport Top left */
    DWORD       Width;
    DWORD       Height;       /* Viewport Dimensions */
    float       MinZ;         /* Min/max of clip Volume */
    float       MaxZ;
} D3DVIEWPORT8;

typedef struct _D3DMATERIAL8 {
    D3DCOLORVALUE   Diffuse;        /* Diffuse color RGBA */
    D3DCOLORVALUE   Ambient;        /* Ambient color RGB */
    D3DCOLORVALUE   Specular;       /* Specular 'shininess' */
    D3DCOLORVALUE   Emissive;       /* Emissive color RGB */
    float           Power;          /* Sharpness if specular highlight */
} D3DMATERIAL8;

typedef enum _D3DLIGHTTYPE {
    D3DLIGHT_POINT          = 1,
    D3DLIGHT_SPOT           = 2,
    D3DLIGHT_DIRECTIONAL    = 3,
    D3DLIGHT_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DLIGHTTYPE;

typedef struct _D3DLIGHT8 {
    D3DLIGHTTYPE    Type;            /* Type of light source */
    D3DCOLORVALUE   Diffuse;         /* Diffuse color of light */
    D3DCOLORVALUE   Specular;        /* Specular color of light */
    D3DCOLORVALUE   Ambient;         /* Ambient color of light */
    D3DVECTOR       Position;         /* Position in world space */
    D3DVECTOR       Direction;        /* Direction in world space */
    float           Range;            /* Cutoff range */
    float           Falloff;          /* Falloff */
    float           Attenuation0;     /* Constant attenuation */
    float           Attenuation1;     /* Linear attenuation */
    float           Attenuation2;     /* Quadratic attenuation */
    float           Theta;            /* Inner angle of spotlight cone */
    float           Phi;              /* Outer angle of spotlight cone */
} D3DLIGHT8;

/*
 * Options for clearing
 */
#define D3DCLEAR_TARGET            0x000000f0l  /* Clear target surface */
#define D3DCLEAR_ZBUFFER           0x00000001l  /* Clear target z buffer */
#define D3DCLEAR_STENCIL           0x00000002l  /* Clear stencil planes */

// The follow are Xbox extensions
#define D3DCLEAR_TARGET_R          0x00000010l  /* Clear target surface R component */
#define D3DCLEAR_TARGET_G          0x00000020l  /* Clear target surface G component */
#define D3DCLEAR_TARGET_B          0x00000040l  /* Clear target surface B component */
#define D3DCLEAR_TARGET_A          0x00000080l  /* Clear target surface A component */

// The driver uses these values as the maximum value for Z in the z-buffer.

#define D3DZ_MAX_D16         65535.0
#define D3DZ_MAX_D24S8       16777215.0
#define D3DZ_MAX_F16         511.9375   

// We can't use the whole available range for the 24-bit floating point z
// because the maximum value is very, very close to the IEEE single 
// precision maximum.  Any calculation using the value will cause an overflow.
//
// Back off a bit from the max (3.4028e38),
//
#define D3DZ_MAX_F24S8       1.0e30

/*
 * The following defines the rendering states
 */

typedef enum _D3DSHADEMODE {
    D3DSHADE_FLAT               = 0x1d00,
    D3DSHADE_GOURAUD            = 0x1d01,
    D3DSHADE_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSHADEMODE;


typedef enum _D3DFILLMODE {
    D3DFILL_POINT               = 0x1b00,
    D3DFILL_WIREFRAME           = 0x1b01,
    D3DFILL_SOLID               = 0x1b02,
    D3DFILL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DFILLMODE;

typedef enum _D3DBLEND {
    D3DBLEND_ZERO               = 0,
    D3DBLEND_ONE                = 1,
    D3DBLEND_SRCCOLOR           = 0x300,
    D3DBLEND_INVSRCCOLOR        = 0x301,
    D3DBLEND_SRCALPHA           = 0x302,
    D3DBLEND_INVSRCALPHA        = 0x303,
    D3DBLEND_DESTALPHA          = 0x304,
    D3DBLEND_INVDESTALPHA       = 0x305,
    D3DBLEND_DESTCOLOR          = 0x306,
    D3DBLEND_INVDESTCOLOR       = 0x307,
    D3DBLEND_SRCALPHASAT        = 0x308,
    D3DBLEND_CONSTANTCOLOR      = 0x8001,
    D3DBLEND_INVCONSTANTCOLOR   = 0x8002,
    D3DBLEND_CONSTANTALPHA      = 0x8003,
    D3DBLEND_INVCONSTANTALPHA   = 0x8004,

    // D3DBLEND_BOTHSRCALPHA not supported on Xbox
    // D3DBLEND_BOTHINVSRCALPHA not supported on Xbox

    D3DBLEND_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DBLEND;

typedef enum _D3DBLENDOP {
    D3DBLENDOP_ADD              = 0x8006,
    D3DBLENDOP_SUBTRACT         = 0x800a,
    D3DBLENDOP_REVSUBTRACT      = 0x800b,
    D3DBLENDOP_MIN              = 0x8007,
    D3DBLENDOP_MAX              = 0x8008,
    D3DBLENDOP_ADDSIGNED        = 0xf006,       // Xbox extension
    D3DBLENDOP_REVSUBTRACTSIGNED= 0xf005,       // Xbox extension
    D3DBLENDOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DBLENDOP;

typedef enum _D3DTEXTUREADDRESS {
    D3DTADDRESS_WRAP            = 1,
    D3DTADDRESS_MIRROR          = 2,
    D3DTADDRESS_CLAMP           = 3,
    D3DTADDRESS_BORDER          = 4,
    D3DTADDRESS_CLAMPTOEDGE     = 5, // Xbox extension

    // D3DTADDRESS_MIRRORONCE not supported on Xbox

    D3DTADDRESS_MAX             = 6,
    D3DTADDRESS_FORCE_DWORD     = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREADDRESS;

typedef enum _D3DTEXTURECOLORKEYOP {            // Xbox extension
    D3DTCOLORKEYOP_DISABLE      = 0,
    D3DTCOLORKEYOP_ALPHA        = 1,
    D3DTCOLORKEYOP_RGBA         = 2,
    D3DTCOLORKEYOP_KILL         = 3,

    D3DTCOLORKEYOP_MAX          = 4,
    D3DTCOLORKEYOP_FORCE_DWORD  = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTURECOLORKEYOP;

typedef enum _D3DTEXTUREALPHAKILL {             // Xbox extension
    D3DTALPHAKILL_DISABLE       = 0,
    D3DTALPHAKILL_ENABLE        = 4,

    D3DTALPHAKILL_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTEXTUREALPHAKILL;

typedef enum _D3DCULL {
    D3DCULL_NONE                = 0,
    D3DCULL_CW                  = 0x900,
    D3DCULL_CCW                 = 0x901,
    D3DCULL_FORCE_DWORD         = 0x7fffffff, /* force 32-bit size enum */
} D3DCULL;

typedef enum _D3DFRONT {                        // Xbox extension
    D3DFRONT_CW                 = 0x900,
    D3DFRONT_CCW                = 0x901,
    D3DFRONT_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DFRONT;

typedef enum _D3DCMPFUNC {
    D3DCMP_NEVER                = 0x200,
    D3DCMP_LESS                 = 0x201,
    D3DCMP_EQUAL                = 0x202,
    D3DCMP_LESSEQUAL            = 0x203,
    D3DCMP_GREATER              = 0x204,
    D3DCMP_NOTEQUAL             = 0x205,
    D3DCMP_GREATEREQUAL         = 0x206,
    D3DCMP_ALWAYS               = 0x207,
    D3DCMP_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DCMPFUNC;

typedef enum _D3DSTENCILOP {
    D3DSTENCILOP_KEEP           = 0x1e00,
    D3DSTENCILOP_ZERO           = 0,
    D3DSTENCILOP_REPLACE        = 0x1e01,
    D3DSTENCILOP_INCRSAT        = 0x1e02,
    D3DSTENCILOP_DECRSAT        = 0x1e03,
    D3DSTENCILOP_INVERT         = 0x150a,
    D3DSTENCILOP_INCR           = 0x8507,
    D3DSTENCILOP_DECR           = 0x8508,
    D3DSTENCILOP_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DSTENCILOP;

typedef enum _D3DFOGMODE {
    D3DFOG_NONE                 = 0,
    D3DFOG_EXP                  = 1,
    D3DFOG_EXP2                 = 2,
    D3DFOG_LINEAR               = 3,
    D3DFOG_FORCE_DWORD          = 0x7fffffff, /* force 32-bit size enum */
} D3DFOGMODE;

typedef enum _D3DSWATHWIDTH {                   // Xbox extension
    D3DSWATH_8                  = 0,
    D3DSWATH_16                 = 1,
    D3DSWATH_32                 = 2,
    D3DSWATH_64                 = 3,
    D3DSWATH_128                = 4,
    D3DSWATH_OFF                = 0xf,
    D3DSWATH_FORCE_DWORD        = 0x7fffffff, /* force 32-bit size enum */
} D3DSWATHWIDTH;

typedef enum _D3DPALETTESIZE {                  // Xbox extension
    D3DPALETTE_256              = 0,
    D3DPALETTE_128              = 1,
    D3DPALETTE_64               = 2,
    D3DPALETTE_32               = 3,

    D3DPALETTE_MAX              = 4,
    D3DPALETTE_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DPALETTESIZE;

typedef DWORD D3DSHADERCONSTANTMODE;            // Xbox extension

#define D3DSCM_96CONSTANTS                  0
#define D3DSCM_192CONSTANTS                 1
#define D3DSCM_192CONSTANTSANDFIXEDPIPELINE 2
#define D3DSCM_NORESERVEDCONSTANTS          0x10    // Flag

typedef enum _D3DLOGICOP {                      // Xbox extension
    D3DLOGICOP_NONE             = 0,
    D3DLOGICOP_CLEAR            = 0x1500,
    D3DLOGICOP_AND              = 0x1501,
    D3DLOGICOP_AND_REVERSE      = 0x1502,
    D3DLOGICOP_COPY             = 0x1503,
    D3DLOGICOP_AND_INVERTED     = 0x1504,
    D3DLOGICOP_NOOP             = 0x1505,
    D3DLOGICOP_XOR              = 0x1506,
    D3DLOGICOP_OR               = 0x1507,
    D3DLOGICOP_NOR              = 0x1508,
    D3DLOGICOP_EQUIV            = 0x1509,
    D3DLOGICOP_INVERT           = 0x150a,
    D3DLOGICOP_OR_REVERSE       = 0x150b,
    D3DLOGICOP_COPY_INVERTED    = 0x150c,
    D3DLOGICOP_OR_INVERTED      = 0x150d,
    D3DLOGICOP_NAND             = 0x150e,
    D3DLOGICOP_SET              = 0x150f,
    D3DLOGICOP_FORCE_DWORD      = 0x7fffffff, /* force 32-bit size enum */
} D3DLOGICOP;

typedef enum _D3DZBUFFERTYPE {
    D3DZB_FALSE                 = 0,
    D3DZB_TRUE                  = 1, // Z buffering
    D3DZB_USEW                  = 2, // W buffering
    D3DZB_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DZBUFFERTYPE;

// Primitives supported by draw-primitive API
typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINELOOP              = 3,  // Xbox extension
    D3DPT_LINESTRIP             = 4,
    D3DPT_TRIANGLELIST          = 5,
    D3DPT_TRIANGLESTRIP         = 6,
    D3DPT_TRIANGLEFAN           = 7,
    D3DPT_QUADLIST              = 8,  // Xbox extension
    D3DPT_QUADSTRIP             = 9,  // Xbox extension
    D3DPT_POLYGON               = 10, // Xbox extension

    D3DPT_MAX                   = 11,
    D3DPT_FORCE_DWORD           = 0x7fffffff, /* force 32-bit size enum */
} D3DPRIMITIVETYPE;

typedef enum _D3DTRANSFORMSTATETYPE {
    D3DTS_VIEW          = 0,
    D3DTS_PROJECTION    = 1,
    D3DTS_TEXTURE0      = 2,
    D3DTS_TEXTURE1      = 3,
    D3DTS_TEXTURE2      = 4,
    D3DTS_TEXTURE3      = 5,
    D3DTS_WORLD         = 6,
    D3DTS_WORLD1        = 7,
    D3DTS_WORLD2        = 8,
    D3DTS_WORLD3        = 9,

    D3DTS_MAX           = 10,
    D3DTS_FORCE_DWORD   = 0x7fffffff, /* force 32-bit size enum */
} D3DTRANSFORMSTATETYPE;

#define D3DTS_WORLDMATRIX(index) (D3DTRANSFORMSTATETYPE)(index + D3DTS_WORLD)

typedef enum _D3DRENDERSTATETYPE {

    // Simple render states that are processed by D3D immediately:

    D3DRS_PS_MIN                    = 0,

    // The following pixel-shader renderstates are all Xbox extensions:

    D3DRS_PSALPHAINPUTS0            = 0,    // Pixel shader, Stage 0 alpha inputs                         
    D3DRS_PSALPHAINPUTS1            = 1,    // Pixel shader, Stage 1 alpha inputs                         
    D3DRS_PSALPHAINPUTS2            = 2,    // Pixel shader, Stage 2 alpha inputs                         
    D3DRS_PSALPHAINPUTS3            = 3,    // Pixel shader, Stage 3 alpha inputs                         
    D3DRS_PSALPHAINPUTS4            = 4,    // Pixel shader, Stage 4 alpha inputs                         
    D3DRS_PSALPHAINPUTS5            = 5,    // Pixel shader, Stage 5 alpha inputs                         
    D3DRS_PSALPHAINPUTS6            = 6,    // Pixel shader, Stage 6 alpha inputs                         
    D3DRS_PSALPHAINPUTS7            = 7,    // Pixel shader, Stage 7 alpha inputs                         
    D3DRS_PSFINALCOMBINERINPUTSABCD = 8,    // Pixel shader, Final combiner inputs ABCD
    D3DRS_PSFINALCOMBINERINPUTSEFG  = 9,    // Pixel shader, Final combiner inputs EFG
    D3DRS_PSCONSTANT0_0             = 10,   // Pixel shader, C0 in stage 0
    D3DRS_PSCONSTANT0_1             = 11,   // Pixel shader, C0 in stage 1
    D3DRS_PSCONSTANT0_2             = 12,   // Pixel shader, C0 in stage 2
    D3DRS_PSCONSTANT0_3             = 13,   // Pixel shader, C0 in stage 3
    D3DRS_PSCONSTANT0_4             = 14,   // Pixel shader, C0 in stage 4
    D3DRS_PSCONSTANT0_5             = 15,   // Pixel shader, C0 in stage 5
    D3DRS_PSCONSTANT0_6             = 16,   // Pixel shader, C0 in stage 6
    D3DRS_PSCONSTANT0_7             = 17,   // Pixel shader, C0 in stage 7
    D3DRS_PSCONSTANT1_0             = 18,   // Pixel shader, C1 in stage 0
    D3DRS_PSCONSTANT1_1             = 19,   // Pixel shader, C1 in stage 1
    D3DRS_PSCONSTANT1_2             = 20,   // Pixel shader, C1 in stage 2
    D3DRS_PSCONSTANT1_3             = 21,   // Pixel shader, C1 in stage 3
    D3DRS_PSCONSTANT1_4             = 22,   // Pixel shader, C1 in stage 4
    D3DRS_PSCONSTANT1_5             = 23,   // Pixel shader, C1 in stage 5
    D3DRS_PSCONSTANT1_6             = 24,   // Pixel shader, C1 in stage 6
    D3DRS_PSCONSTANT1_7             = 25,   // Pixel shader, C1 in stage 7
    D3DRS_PSALPHAOUTPUTS0           = 26,   // Pixel shader, Stage 0 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS1           = 27,   // Pixel shader, Stage 1 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS2           = 28,   // Pixel shader, Stage 2 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS3           = 29,   // Pixel shader, Stage 3 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS4           = 30,   // Pixel shader, Stage 4 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS5           = 31,   // Pixel shader, Stage 5 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS6           = 32,   // Pixel shader, Stage 6 alpha outputs                        
    D3DRS_PSALPHAOUTPUTS7           = 33,   // Pixel shader, Stage 7 alpha outputs                        
    D3DRS_PSRGBINPUTS0              = 34,   // Pixel shader, Stage 0 RGB inputs                           
    D3DRS_PSRGBINPUTS1              = 35,   // Pixel shader, Stage 1 RGB inputs                           
    D3DRS_PSRGBINPUTS2              = 36,   // Pixel shader, Stage 2 RGB inputs                           
    D3DRS_PSRGBINPUTS3              = 37,   // Pixel shader, Stage 3 RGB inputs                           
    D3DRS_PSRGBINPUTS4              = 38,   // Pixel shader, Stage 4 RGB inputs                           
    D3DRS_PSRGBINPUTS5              = 39,   // Pixel shader, Stage 5 RGB inputs                           
    D3DRS_PSRGBINPUTS6              = 40,   // Pixel shader, Stage 6 RGB inputs                           
    D3DRS_PSRGBINPUTS7              = 41,   // Pixel shader, Stage 7 RGB inputs                           
    D3DRS_PSCOMPAREMODE             = 42,   // Pixel shader, Compare modes for clipplane texture mode     
    D3DRS_PSFINALCOMBINERCONSTANT0  = 43,   // Pixel shader, C0 in final combiner
    D3DRS_PSFINALCOMBINERCONSTANT1  = 44,   // Pixel shader, C1 in final combiner
    D3DRS_PSRGBOUTPUTS0             = 45,   // Pixel shader, Stage 0 RGB outputs                          
    D3DRS_PSRGBOUTPUTS1             = 46,   // Pixel shader, Stage 1 RGB outputs                          
    D3DRS_PSRGBOUTPUTS2             = 47,   // Pixel shader, Stage 2 RGB outputs                          
    D3DRS_PSRGBOUTPUTS3             = 48,   // Pixel shader, Stage 3 RGB outputs                          
    D3DRS_PSRGBOUTPUTS4             = 49,   // Pixel shader, Stage 4 RGB outputs                          
    D3DRS_PSRGBOUTPUTS5             = 50,   // Pixel shader, Stage 5 RGB outputs                          
    D3DRS_PSRGBOUTPUTS6             = 51,   // Pixel shader, Stage 6 RGB outputs                          
    D3DRS_PSRGBOUTPUTS7             = 52,   // Pixel shader, Stage 7 RGB outputs                          
    D3DRS_PSCOMBINERCOUNT           = 53,   // Pixel shader, Active combiner count (Stages 0-7)           
                                            // Pixel shader, Reserved
    D3DRS_PSDOTMAPPING              = 55,   // Pixel shader, Input mapping for dot product modes          
    D3DRS_PSINPUTTEXTURE            = 56,   // Pixel shader, Texture source for some texture modes        

    D3DRS_PS_MAX                    = 57,  

    D3DRS_ZFUNC                     = 57,   // D3DCMPFUNC 
    D3DRS_ALPHAFUNC                 = 58,   // D3DCMPFUNC 
    D3DRS_ALPHABLENDENABLE          = 59,   // TRUE to enable alpha blending 
    D3DRS_ALPHATESTENABLE           = 60,   // TRUE to enable alpha tests 
    D3DRS_ALPHAREF                  = 61,   // BYTE
    D3DRS_SRCBLEND                  = 62,   // D3DBLEND 
    D3DRS_DESTBLEND                 = 63,   // D3DBLEND 
    D3DRS_ZWRITEENABLE              = 64,   // TRUE to enable Z writes 
    D3DRS_DITHERENABLE              = 65,   // TRUE to enable dithering 
    D3DRS_SHADEMODE                 = 66,   // D3DSHADEMODE 
    D3DRS_COLORWRITEENABLE          = 67,   // D3DCOLORWRITEENABLE_ALPHA, etc. per-channel write enable
    D3DRS_STENCILZFAIL              = 68,   // D3DSTENCILOP to do if stencil test passes and Z test fails 
    D3DRS_STENCILPASS               = 69,   // D3DSTENCILOP to do if both stencil and Z tests pass 
    D3DRS_STENCILFUNC               = 70,   // D3DCMPFUNC
    D3DRS_STENCILREF                = 71,   // BYTE reference value used in stencil test 
    D3DRS_STENCILMASK               = 72,   // BYTE mask value used in stencil test 
    D3DRS_STENCILWRITEMASK          = 73,   // BYTE write mask applied to values written to stencil buffer 
    D3DRS_BLENDOP                   = 74,   // D3DBLENDOP setting
    D3DRS_BLENDCOLOR                = 75,   // D3DCOLOR for D3DBLEND_CONSTANT, etc. (Xbox extension)
    D3DRS_SWATHWIDTH                = 76,   // D3DSWATHWIDTH (Xbox extension)
    D3DRS_POLYGONOFFSETZSLOPESCALE  = 77,   // float Z factor for shadow maps (Xbox extension)
    D3DRS_POLYGONOFFSETZOFFSET      = 78,   // float bias for polygon offset (Xbox extension)
    D3DRS_POINTOFFSETENABLE         = 79,   // TRUE to enable polygon offset for points (Xbox extension)
    D3DRS_WIREFRAMEOFFSETENABLE     = 80,   // TRUE to enable polygon offset for lines (Xbox extension)
    D3DRS_SOLIDOFFSETENABLE         = 81,   // TRUE to enable polygon offset for fills (Xbox extension)

    D3DRS_SIMPLE_MAX                = 82,

    // State whose handling is deferred until the next Draw[Indexed]Vertices
    // call because of interdependencies on other states:

    D3DRS_FOGENABLE                 = 82,   // TRUE to enable fog blending 
    D3DRS_FOGTABLEMODE              = 83,   // D3DFOGMODE 
    D3DRS_FOGSTART                  = 84,   // float fog start (for both vertex and pixel fog) 
    D3DRS_FOGEND                    = 85,   // float fog end      
    D3DRS_FOGDENSITY                = 86,   // float fog density  
    D3DRS_RANGEFOGENABLE            = 87,   // TRUE to enable range-based fog 
    D3DRS_WRAP0                     = 88,   // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 1st texture coord.
    D3DRS_WRAP1                     = 89,   // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 2nd texture coord. 
    D3DRS_WRAP2                     = 90,   // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 3rd texture coord. 
    D3DRS_WRAP3                     = 91,   // D3DWRAP* flags (D3DWRAP_U, D3DWRAPCOORD_0, etc.) for 4th texture coord. 
    D3DRS_LIGHTING                  = 92,   // TRUE to enable lighting
    D3DRS_SPECULARENABLE            = 93,   // TRUE to enable specular 
    D3DRS_LOCALVIEWER               = 94,   // TRUE to enable camera-relative specular highlights
    D3DRS_COLORVERTEX               = 95,   // TRUE to enable per-vertex color
    D3DRS_BACKSPECULARMATERIALSOURCE= 96,   // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKDIFFUSEMATERIALSOURCE = 97,   // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKAMBIENTMATERIALSOURCE = 98,   // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_BACKEMISSIVEMATERIALSOURCE= 99,   // D3DMATERIALCOLORSOURCE (Xbox extension)
    D3DRS_SPECULARMATERIALSOURCE    = 100,  // D3DMATERIALCOLORSOURCE 
    D3DRS_DIFFUSEMATERIALSOURCE     = 101,  // D3DMATERIALCOLORSOURCE 
    D3DRS_AMBIENTMATERIALSOURCE     = 102,  // D3DMATERIALCOLORSOURCE 
    D3DRS_EMISSIVEMATERIALSOURCE    = 103,  // D3DMATERIALCOLORSOURCE 
    D3DRS_BACKAMBIENT               = 104,  // D3DCOLOR (Xbox extension)
    D3DRS_AMBIENT                   = 105,  // D3DCOLOR 
    D3DRS_POINTSIZE                 = 106,  // float point size 
    D3DRS_POINTSIZE_MIN             = 107,  // float point size min threshold 
    D3DRS_POINTSPRITEENABLE         = 108,  // TRUE to enable point sprites
    D3DRS_POINTSCALEENABLE          = 109,  // TRUE to enable point size scaling
    D3DRS_POINTSCALE_A              = 110,  // float point attenuation A value 
    D3DRS_POINTSCALE_B              = 111,  // float point attenuation B value 
    D3DRS_POINTSCALE_C              = 112,  // float point attenuation C value 
    D3DRS_POINTSIZE_MAX             = 113,  // float point size max threshold 
    D3DRS_PATCHEDGESTYLE            = 114,  // D3DPATCHEDGESTYLE
    D3DRS_PATCHSEGMENTS             = 115,  // DWORD number of segments per edge when drawing patches

    D3DRS_DEFERRED_MAX              = 116,

    // Complex state that has immediate processing:

    D3DRS_PSTEXTUREMODES            = 116,  // Pixel shader, Texture addressing modes (Xbox extension)
    D3DRS_VERTEXBLEND               = 117,  // D3DVERTEXBLENDFLAGS
    D3DRS_FOGCOLOR                  = 118,  // D3DCOLOR 
    D3DRS_FILLMODE                  = 119,  // D3DFILLMODE        
    D3DRS_BACKFILLMODE              = 120,  // D3DFILLMODE (Xbox extension)
    D3DRS_TWOSIDEDLIGHTING          = 121,  // TRUE to enable two-sided lighting (Xbox extension)
    D3DRS_NORMALIZENORMALS          = 122,  // TRUE to enable automatic normalization
    D3DRS_ZENABLE                   = 123,  // D3DZBUFFERTYPE (or TRUE/FALSE for legacy) 
    D3DRS_STENCILENABLE             = 124,  // TRUE to enable stenciling
    D3DRS_STENCILFAIL               = 125,  // D3DSTENCILOP to do if stencil test fails 
    D3DRS_FRONTFACE                 = 126,  // D3DFRONT (Xbox extension)
    D3DRS_CULLMODE                  = 127,  // D3DCULL 
    D3DRS_TEXTUREFACTOR             = 128,  // D3DCOLOR used for multi-texture blend 
    D3DRS_ZBIAS                     = 129,  // LONG Z bias 
    D3DRS_LOGICOP                   = 130,  // D3DLOGICOP (Xbox extension)
    D3DRS_EDGEANTIALIAS             = 131,  // TRUE to enable edge antialiasing (Xbox extension)
    D3DRS_MULTISAMPLEANTIALIAS      = 132,  // TRUE to enable multisample antialiasing
    D3DRS_MULTISAMPLEMASK           = 133,  // DWORD per-pixel and sample enable/disable
    D3DRS_MULTISAMPLETYPE           = 134,  // D3DMULTISAMPLE_TYPE (Xbox extension)
    D3DRS_SHADOWFUNC                = 135,  // D3DCMPFUNC (Xbox extension)
    D3DRS_LINEWIDTH                 = 136,  // float (Xbox extension)
    D3DRS_DXT1NOISEENABLE           = 137,  // TRUE to enable DXT1 decompression noise (Xbox extension)
    D3DRS_YUVENABLE                 = 138,  // TRUE to enable use of D3DFMT_YUY2 and D3DFMT_UYVY texture formats
    D3DRS_OCCLUSIONCULLENABLE       = 139,  // TRUE to enable Z occlusion culling
    D3DRS_STENCILCULLENABLE         = 140,  // TRUE to enable stencil culling
    D3DRS_ROPZCMPALWAYSREAD         = 141,  // TRUE to always read target packet when Z enabled
    D3DRS_ROPZREAD                  = 142,  // TRUE to always read Z
    D3DRS_DONOTCULLUNCOMPRESSED     = 143,  // TRUE to never attempt occlusion culling (stencil or Z) on uncompressed packets
    
    D3DRS_MAX                       = 144,  // Total number of renderstates 

    // Render states that are not supported on Xbox:
    //
    // D3DRS_LINEPATTERN
    // D3DRS_LASTPIXEL
    // D3DRS_CLIPPING
    // D3DRS_FOGVERTEXMODE
    // D3DRS_CLIPPLANEENABLE
    // D3DRS_SOFTWAREVERTEXPROCESSING
    // D3DRS_DEBUGMONITORTOKEN
    // D3DRS_INDEXEDVERTEXBLENDENABLE
    // D3DRS_TWEENFACTOR

    D3DRS_FORCE_DWORD               = 0x7fffffff, /* force 32-bit size enum */
} D3DRENDERSTATETYPE;

// Values for material source
typedef enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL         = 0,            // Color from material is used
    D3DMCS_COLOR1           = 1,            // Diffuse vertex color is used
    D3DMCS_COLOR2           = 2,            // Specular vertex color is used
    D3DMCS_FORCE_DWORD      = 0x7fffffff,   // force 32-bit size enum
} D3DMATERIALCOLORSOURCE;

// Bias to apply to the texture coordinate set to apply a wrap to.
#define D3DRENDERSTATE_WRAPBIAS                 D3DRS_WRAP0

/* Flags to construct the WRAP render states */
#define D3DWRAP_U   0x00000010L
#define D3DWRAP_V   0x00001000L
#define D3DWRAP_W   0x00100000L

/* Flags to construct the WRAP render states for 1D thru 4D texture coordinates */
#define D3DWRAPCOORD_0   0x00000010L    // same as D3DWRAP_U
#define D3DWRAPCOORD_1   0x00001000L    // same as D3DWRAP_V
#define D3DWRAPCOORD_2   0x00100000L    // same as D3DWRAP_W
#define D3DWRAPCOORD_3   0x01000000L

/* Flags to construct D3DRS_COLORWRITEENABLE */
#define D3DCOLORWRITEENABLE_RED     (1L<<16)
#define D3DCOLORWRITEENABLE_GREEN   (1L<<8)
#define D3DCOLORWRITEENABLE_BLUE    (1L<<0)
#define D3DCOLORWRITEENABLE_ALPHA   (1L<<24)
#define D3DCOLORWRITEENABLE_ALL     0x01010101 // Xbox extension

/*
 * State enumerants for per-stage texture processing.
 */
typedef enum _D3DTEXTURESTAGESTATETYPE
{
    // State whose handling is deferred until the next Draw[Indexed]Vertices
    // call because of interdependencies on other states:

    D3DTSS_COLOROP               =  0,  // D3DTEXTUREOP - per-stage blending controls for color channels 
    D3DTSS_COLORARG0             =  1,  // D3DTA_* (D3DTA_TEXTURE etc.) third arg for triadic ops 
    D3DTSS_COLORARG1             =  2,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg
    D3DTSS_COLORARG2             =  3,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg 
    D3DTSS_ALPHAOP               =  4,  // D3DTEXTUREOP - per-stage blending controls for alpha channel 
    D3DTSS_ALPHAARG0             =  5,  // D3DTA_* (D3DTA_TEXTURE etc.) third arg for triadic ops 
    D3DTSS_ALPHAARG1             =  6,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg
    D3DTSS_ALPHAARG2             =  7,  // D3DTA_* (D3DTA_TEXTURE etc.) texture arg) 
    D3DTSS_RESULTARG             =  8,  // D3DTA_* (D3DTA_TEXTURE etc.) arg for result (CURRENT or TEMP) 
    D3DTSS_TEXTURETRANSFORMFLAGS =  9,  // D3DTEXTURETRANSFORMFLAGS controls texture transform 
    D3DTSS_ADDRESSU              = 10,  // D3DTEXTUREADDRESS for U coordinate 
    D3DTSS_ADDRESSV              = 11,  // D3DTEXTUREADDRESS for V coordinate 
    D3DTSS_ADDRESSW              = 12,  // D3DTEXTUREADDRESS for W coordinate 
    D3DTSS_MAGFILTER             = 13,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for magnification 
    D3DTSS_MINFILTER             = 14,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use for minification 
    D3DTSS_MIPFILTER             = 15,  // D3DTEXF_* (D3DTEXF_LINEAR etc.) filter to use between mipmaps during minification 
    D3DTSS_MIPMAPLODBIAS         = 16,  // float mipmap LOD bias 
    D3DTSS_MAXMIPLEVEL           = 17,  // DWORD 0..(n-1) LOD index of largest map to use (0 == largest) 
    D3DTSS_MAXANISOTROPY         = 18,  // DWORD maximum anisotropy 
    D3DTSS_COLORKEYOP            = 19,  // D3DTEXTURECOLORKEYOP (Xbox extension)
    D3DTSS_COLORSIGN             = 20,  // D3DTSIGN_* (D3DTSIGN_ASIGNED etc.) for color channels (xbox extension)
    D3DTSS_ALPHAKILL             = 21,  // D3DTEXTUREALPHAKILL (Xbox extension)

    D3DTSS_DEFERRED_MAX          = 22,

    // State that has immediate processing:

    D3DTSS_BUMPENVMAT00          = 22,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT01          = 23,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT11          = 24,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVMAT10          = 25,  // float (bump mapping matrix) 
    D3DTSS_BUMPENVLSCALE         = 26,  // float scale for bump map luminance 
    D3DTSS_BUMPENVLOFFSET        = 27,  // float offset for bump map luminance 
    D3DTSS_TEXCOORDINDEX         = 28,  // DWORD identifies which set of texture coordinates index this texture 
    D3DTSS_BORDERCOLOR           = 29,  // D3DCOLOR 
    D3DTSS_COLORKEYCOLOR         = 30,  // D3DCOLOR value for color key (Xbox extension)
                                 
    D3DTSS_MAX                   = 32,  // Total number of texture stage states (bumped to a power of 2)

    D3DTSS_FORCE_DWORD           = 0x7fffffff, // force 32-bit size enum 
} D3DTEXTURESTAGESTATETYPE;

/*
 * The maximum number of texture stages supported on Xbox
 */

#define D3DTSS_MAXSTAGES 4

/*
 * The maximum index value possible for EndVisibilityTest
 */

#define D3DVISIBILITY_TEST_MAX 4096

// Values, used with D3DTSS_TEXCOORDINDEX, to specify that the vertex data(position
// and normal in the camera space) should be taken as texture coordinates
// Low 16 bits are used to specify texture coordinate index, to take the WRAP mode from
//
#define D3DTSS_TCI_PASSTHRU                             0x00000000
#define D3DTSS_TCI_CAMERASPACENORMAL                    0x00010000
#define D3DTSS_TCI_CAMERASPACEPOSITION                  0x00020000
#define D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR          0x00030000
#define D3DTSS_TCI_OBJECT                               0x00040000
#define D3DTSS_TCI_SPHERE                               0x00050000

#define D3DTSS_TCI_TEXCOORDINDEX_MAX                    8
#define D3DTSS_TCI_TEXGEN_MAX                           0x00060000

/*
 * Enumerations for COLOROP and ALPHAOP texture blending operations set in
 * texture processing stage controls in D3DRENDERSTATE.
 */
typedef enum _D3DTEXTUREOP
{
    // Control
    D3DTOP_DISABLE              = 1,      // disables stage
    D3DTOP_SELECTARG1           = 2,      // the default
    D3DTOP_SELECTARG2           = 3,

    // Modulate
    D3DTOP_MODULATE             = 4,      // multiply args together
    D3DTOP_MODULATE2X           = 5,      // multiply and  1 bit
    D3DTOP_MODULATE4X           = 6,      // multiply and  2 bits

    // Add
    D3DTOP_ADD                  =  7,   // add arguments together
    D3DTOP_ADDSIGNED            =  8,   // add with -0.5 bias
    D3DTOP_ADDSIGNED2X          =  9,   // as above but left  1 bit
    D3DTOP_SUBTRACT             = 10,   // Arg1 - Arg2, with no saturation
    D3DTOP_ADDSMOOTH            = 11,   // add 2 args, subtract product
                                        // Arg1 + Arg2 - Arg1*Arg2
                                        // = Arg1 + (1-Arg1)*Arg2

    // Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
    D3DTOP_BLENDDIFFUSEALPHA    = 12, // iterated alpha
    D3DTOP_BLENDTEXTUREALPHA    = 13, // texture alpha
    D3DTOP_BLENDFACTORALPHA     = 14, // alpha from D3DRENDERSTATE_TEXTUREFACTOR

    // Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
    D3DTOP_BLENDTEXTUREALPHAPM  = 15, // texture alpha
    D3DTOP_BLENDCURRENTALPHA    = 16, // by alpha of current color

    // Specular mapping
    D3DTOP_PREMODULATE            = 17,     // modulate with next texture before use
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
                                            // COLOROP only
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
                                            // COLOROP only
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
                                            // COLOROP only
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
                                            // COLOROP only

    // This can do either diffuse or specular bump mapping with correct input.
    // Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
    // where each component has been scaled and offset to make it signed.
    // The result is replicated into all four (including alpha) channels.
    // This is a valid COLOROP only.
    D3DTOP_DOTPRODUCT3          = 22,

    // Triadic ops
    D3DTOP_MULTIPLYADD          = 23, // Arg0 + Arg1*Arg2
    D3DTOP_LERP                 = 24, // (Arg0)*Arg1 + (1-Arg0)*Arg2

    // Bump mapping
    D3DTOP_BUMPENVMAP           = 25, // per pixel env map perturbation
    D3DTOP_BUMPENVMAPLUMINANCE  = 26, // with luminance channel

    D3DTOP_MAX                  = 27,
    D3DTOP_FORCE_DWORD = 0x7fffffff,
} D3DTEXTUREOP;

/*
 * Values for COLORARG0,1,2, ALPHAARG0,1,2, and RESULTARG texture blending
 * operations set in texture processing stage controls in D3DRENDERSTATE.
 */
#define D3DTA_SELECTMASK        0x0000000f  // mask for arg selector
#define D3DTA_DIFFUSE           0x00000000  // select diffuse color (read only)
#define D3DTA_CURRENT           0x00000001  // select stage destination register (read/write)
#define D3DTA_TEXTURE           0x00000002  // select texture color (read only)
#define D3DTA_TFACTOR           0x00000003  // select RENDERSTATE_TEXTUREFACTOR (read only)
#define D3DTA_SPECULAR          0x00000004  // select specular color (read only)
#define D3DTA_TEMP              0x00000005  // select temporary register color (read/write)
#define D3DTA_COMPLEMENT        0x00000010  // take 1.0 - x (read modifier)
#define D3DTA_ALPHAREPLICATE    0x00000020  // replicate alpha to color components (read modifier)

#define D3DTA_SELECTMAX         0x00000006
#define D3DTA_MODIFIERMAX       0x00000030

/*
 * Flags for D3DTSS_COLORSIGN (Xbox extension)
 */
#define D3DTSIGN_ASIGNED           0x10000000
#define D3DTSIGN_AUNSIGNED         0
#define D3DTSIGN_RSIGNED           0x20000000
#define D3DTSIGN_RUNSIGNED         0
#define D3DTSIGN_GSIGNED           0x40000000
#define D3DTSIGN_GUNSIGNED         0
#define D3DTSIGN_BSIGNED           0x80000000
#define D3DTSIGN_BUNSIGNED         0

//
// Values for D3DTSS_***FILTER texture stage states
//
typedef enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE            = 0,    // filtering disabled (valid for mip filter only)
    D3DTEXF_POINT           = 1,    // nearest
    D3DTEXF_LINEAR          = 2,    // linear interpolation
    D3DTEXF_ANISOTROPIC     = 3,    // anisotropic
    D3DTEXF_QUINCUNX        = 4,    // quincunx kernel (Xbox extension)
    D3DTEXF_GAUSSIANCUBIC   = 5,    // different cubic kernel

    D3DTEXF_MAX             = 6,
    D3DTEXF_FORCE_DWORD     = 0x7fffffff,   // force 32-bit size enum
} D3DTEXTUREFILTERTYPE;

/* The maximum number of vertices user can pass to any d3d
   drawing function or to create vertex buffer with
*/
#define D3DMAXNUMVERTICES    ((1<<16) - 1)
/* The maximum number of primitives user can pass to any d3d
   drawing function.
*/
#define D3DMAXNUMPRIMITIVES  ((1<<16) - 1)

//-------------------------------------------------------------------
// Flexible vertex format bits
//
#define D3DFVF_RESERVED0        0x001
#define D3DFVF_POSITION_MASK    0x00E
#define D3DFVF_XYZ              0x002
#define D3DFVF_XYZRHW           0x004
#define D3DFVF_XYZB1            0x006
#define D3DFVF_XYZB2            0x008
#define D3DFVF_XYZB3            0x00a
#define D3DFVF_XYZB4            0x00c

#define D3DFVF_NORMAL           0x010
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_SPECULAR         0x080

#define D3DFVF_TEXCOUNT_MASK    0xf00
#define D3DFVF_TEXCOUNT_SHIFT   8
#define D3DFVF_TEX0             0x000
#define D3DFVF_TEX1             0x100
#define D3DFVF_TEX2             0x200
#define D3DFVF_TEX3             0x300
#define D3DFVF_TEX4             0x400

#define D3DFVF_RESERVED2        0xE000  // 4 reserved bits

// D3DFVF_PSIZE is not supported on Xbox with the fixed function pipeline 
// (a programmable vertex shader can be written to support per-vertex point
// sizes)

//---------------------------------------------------------------------
// Vertex Shaders
//

/*

Vertex Shader Declaration

The declaration portion of a vertex shader defines the static external
interface of the shader.  The information in the declaration includes:

- Assignments of vertex shader input registers to data streams.  These
assignments bind a specific vertex register to a single component within a
vertex stream.  A vertex stream element is identified by a byte offset
within the stream and a type.  The type specifies the arithmetic data type
plus the dimensionality (1, 2, 3, or 4 values).  Stream data which is
less than 4 values are always expanded out to 4 values with zero or more
0.F values and one 1.F value.

- Assignment of vertex shader input registers to implicit data from the
primitive tessellator.  This controls the loading of vertex data which is
not loaded from a stream, but rather is generated during primitive
tessellation prior to the vertex shader.

- Loading data into the constant memory at the time a shader is set as the
current shader.  Each token specifies values for one or more contiguous 4
DWORD constant registers.  This allows the shader to update an arbitrary
subset of the constant memory, overwriting the device state (which
contains the current values of the constant memory).  Note that these
values can be subsequently overwritten (between DrawPrimitive calls)
during the time a shader is bound to a device via the
SetVertexShaderConstant method.


Declaration arrays are single-dimensional arrays of DWORDs composed of
multiple tokens each of which is one or more DWORDs.  The single-DWORD
token value 0xFFFFFFFF is a special token used to indicate the end of the
declaration array.  The single DWORD token value 0x00000000 is a NOP token
with is ignored during the declaration parsing.  Note that 0x00000000 is a
valid value for DWORDs following the first DWORD for multiple word tokens.

[31:29] TokenType
    0x0 - NOP (requires all DWORD bits to be zero)
    0x1 - stream selector
    0x2 - stream data definition (map to vertex input memory)
    0x3 - vertex input memory from tessellator
    0x4 - constant memory from shader
    0x5 - extension
    0x6 - reserved
    0x7 - end-of-array (requires all DWORD bits to be 1)

NOP Token (single DWORD token)
    [31:29] 0x0
    [28:00] 0x0

Stream Selector (single DWORD token)
    [31:29] 0x1
    [28]    indicates whether this is a tessellator stream
    [27:04] 0x0
    [03:00] stream selector (0..15)

Stream Data Definition (single DWORD token)
    Vertex Input Register Load
      [31:29] 0x2
      [28]    0x0
      [27:24] 0x0
      [23:16] type (dimensionality and data type)
      [15:04] 0x0
      [03:00] vertex register address (0..15)
    DWORD Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27]    0x0
      [26:20] 0x0
      [19:16] count of DWORDS to skip over (0..15)
      [15:00] 0x0
    BYTE Data Skip (no register load)
      [31:29] 0x2
      [28]    0x1
      [27]    0x1
      [26:20] 0x0
      [19:16] count of BYTES to skip over (0..15)
      [15:00] 0x0
  
Vertex Input Memory from Tessellator Data (single DWORD token)
    [31:29] 0x3
    [28]    indicates whether data is normals or u/v
    [27:24] 0x0
    [23:20] vertex register address (0..15)
    [19:04] 0x0
    [03:00] vertex register address (0..15)

Constant Memory from Shader (multiple DWORD token)
    [31:29] 0x4
    [28:25] count of 4*DWORD constants to load (0..15)
    [24:08] 0x0
    [07:00] constant memory address (0..191 - biased by 96)

Extension Token (single or multiple DWORD token)
    [31:29] 0x5
    [28:24] count of additional DWORDs in token (0..31)
    [23:00] extension-specific information

End-of-array token (single DWORD token)
    [31:29] 0x7
    [28:00] 0x1fffffff

The stream selector token must be immediately followed by a contiguous set 
of stream data definition tokens.  This token sequence fully defines that 
stream, including the set of elements within the stream, the order in 
which the elements appear, the type of each element, and the vertex 
register into which to load an element.

Streams are allowed to include data which is not loaded into a vertex 
register, thus allowing data which is not used for this shader to exist 
in the vertex stream.  This skipped data is defined only by a count of 
DWORDs to skip over, since the type i nformation is irrelevant.

The token sequence:
Stream Select: stream=0
Stream Data Definition (Load): type=FLOAT3; register=3
Stream Data Definition (Load): type=FLOAT3; register=4
Stream Data Definition (Skip): count=2
Stream Data Definition (Load): type=FLOAT2; register=7

defines stream zero to consist of 4 elements, 3 of which are loaded into 
registers and the fourth skipped over.  Register 3 is loaded with the 
first three DWORDs in each vertex interpreted as FLOAT data.  Register 4 
is loaded with the 4th, 5th, and 6th DWORDs interpreted as FLOAT data.  
The next two DWORDs (7th and 8th) are skipped over and not loaded into 
any vertex input register.   Register 7 is loaded with the 9th and 10th 
DWORDS interpreted as FLOAT data.  Placing of tokens other than NOPs 
between the Stream Selector and Stream Data Definition tokens is disallowed.

*/

// Vertex Shader 1.0 register limits. D3D device must provide at least
// specified number of registers
//

#define D3DVS_STREAMS_MAX_V1_0          16
#define D3DVS_INPUTREG_MAX_V1_0         16
#define D3DVS_TEMPREG_MAX_V1_0          12
// This max required number. Device could have more registers. Check caps.
#define D3DVS_CONSTREG_COUNT_XBOX       192
#define D3DVS_TCRDOUTREG_MAX_V1_0       8
#define D3DVS_ADDRREG_MAX_V1_0          1
#define D3DVS_ATTROUTREG_MAX_V1_0       2
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_0  128

// The following two vertex shader constant addresses are reserved on Xbox
// when the SetShaderConstantMode does not have the D3DSCM_NORESERVEDCONSTANTS 
// bit set (that is, these are reserved unless all of your vertex shaders use
// #pragma screenspace):
//
#define D3DVS_XBOX_RESERVEDCONSTANT1    -38
#define D3DVS_XBOX_RESERVEDCONSTANT2    -37

// Calling SetVertexShader with FVF_XYZRHW invalidates the first 11 or 12
// vertex shader program slots as loaded via LoadVertexShader. Max is 12...
//
#define D3DVS_XBOX_RESERVEDXYZRHWSLOTS  12

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define D3DPS_INPUTREG_MAX_DX8         8
#define D3DPS_TEMPREG_MAX_DX8          8
#define D3DPS_CONSTREG_MAX_DX8         16
#define D3DPS_TEXTUREREG_MAX_DX8       8


typedef enum _D3DVSD_TOKENTYPE
{
    D3DVSD_TOKEN_NOP        = 0,    // NOP or extension
    D3DVSD_TOKEN_STREAM,            // stream selector
    D3DVSD_TOKEN_STREAMDATA,        // stream data definition (map to vertex input memory)
    D3DVSD_TOKEN_TESSELLATOR,       // vertex input memory from tessellator
    D3DVSD_TOKEN_CONSTMEM,          // constant memory from shader
    D3DVSD_TOKEN_EXT,               // extension
    D3DVSD_TOKEN_END = 7,           // end-of-array (requires all DWORD bits to be 1)
    D3DVSD_FORCE_DWORD = 0x7fffffff,// force 32-bit size enum
} D3DVSD_TOKENTYPE;

#define D3DVSD_TOKENTYPESHIFT   29
#define D3DVSD_TOKENTYPEMASK    (7 << D3DVSD_TOKENTYPESHIFT)

#define D3DVSD_STREAMNUMBERSHIFT 0
#define D3DVSD_STREAMNUMBERMASK (0xF << D3DVSD_STREAMNUMBERSHIFT)

#define D3DVSD_DATALOADTYPESHIFT 28
#define D3DVSD_DATALOADTYPEMASK (0x1 << D3DVSD_DATALOADTYPESHIFT)

#define D3DVSD_DATATYPESHIFT 16
#define D3DVSD_DATATYPEMASK (0xFF << D3DVSD_DATATYPESHIFT)

#define D3DVSD_SKIPCOUNTSHIFT 16
#define D3DVSD_SKIPCOUNTMASK (0xF << D3DVSD_SKIPCOUNTSHIFT)

#define D3DVSD_VERTEXREGSHIFT 0
#define D3DVSD_VERTEXREGMASK (0x1F << D3DVSD_VERTEXREGSHIFT)

#define D3DVSD_VERTEXREGINSHIFT 20
#define D3DVSD_VERTEXREGINMASK (0xF << D3DVSD_VERTEXREGINSHIFT)

#define D3DVSD_CONSTCOUNTSHIFT 25
#define D3DVSD_CONSTCOUNTMASK (0xF << D3DVSD_CONSTCOUNTSHIFT)

#define D3DVSD_CONSTADDRESSSHIFT 0
#define D3DVSD_CONSTADDRESSMASK (0xFF << D3DVSD_CONSTADDRESSSHIFT)

#define D3DVSD_CONSTRSSHIFT 16
#define D3DVSD_CONSTRSMASK (0x1FFF << D3DVSD_CONSTRSSHIFT)

#define D3DVSD_EXTCOUNTSHIFT 24
#define D3DVSD_EXTCOUNTMASK (0x1F << D3DVSD_EXTCOUNTSHIFT)

#define D3DVSD_EXTINFOSHIFT 0
#define D3DVSD_EXTINFOMASK (0xFFFFFF << D3DVSD_EXTINFOSHIFT)

#define D3DVSD_MAKETOKENTYPE(tokenType) ((tokenType << D3DVSD_TOKENTYPESHIFT) & D3DVSD_TOKENTYPEMASK)

// macros for generation of CreateVertexShader Declaration token array

// Set current stream
// _StreamNumber [0..(MaxStreams-1)] stream to get data from
//
#define D3DVSD_STREAM( _StreamNumber ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (_StreamNumber))

// Set tessellator stream
//
#define D3DVSD_STREAMTESSSHIFT 28
#define D3DVSD_STREAMTESSMASK (1 << D3DVSD_STREAMTESSSHIFT)
#define D3DVSD_STREAM_TESS( ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (D3DVSD_STREAMTESSMASK))

// bind single vertex register to vertex element from vertex stream
//
// _VertexRegister [0..26] address of the vertex register
// _Type [D3DVSDT_*] dimensionality and arithmetic data type

#define D3DVSD_REG( _VertexRegister, _Type ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) |            \
     ((_Type) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))

// Skip _DWORDCount DWORDs in vertex
//
#define D3DVSD_SKIP( _DWORDCount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x10000000 | \
     ((_DWORDCount) << D3DVSD_SKIPCOUNTSHIFT))

// Skip _BYTECount BYTEs in vertex (Xbox extension)
//
#define D3DVSD_SKIPBYTES( _BYTECount ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x18000000 | \
     ((_BYTECount) << D3DVSD_SKIPCOUNTSHIFT))

// load data into vertex shader constant memory
//
// _ConstantAddress [-96..95] - address of constant array to begin filling data
// _Count [0..15] - number of constant vectors to load (4 DWORDs each)
// followed by 4*_Count DWORDS of data
//
#define D3DVSD_CONST( _ConstantAddress, _Count ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM) | \
     ((_Count) << D3DVSD_CONSTCOUNTSHIFT) | ((_ConstantAddress) + 96))

// enable tessellator generated normals
//
// _VertexRegisterIn  [0..15] address of vertex register whose input stream
//                            will be used in normal computation
// _VertexRegisterOut [0..15] address of vertex register to output the normal to
//
#define D3DVSD_TESSNORMAL( _VertexRegisterIn, _VertexRegisterOut ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | \
     ((_VertexRegisterIn) << D3DVSD_VERTEXREGINSHIFT) | \
     (_VertexRegisterOut))

// enable tessellator generated surface parameters
//
// _VertexRegister [0..15] address of vertex register to output parameters
//
#define D3DVSD_TESSUV( _VertexRegister ) \
    (D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) | 0x10000000 | \
     (_VertexRegister))

// Generates END token
//
#define D3DVSD_END() 0xFFFFFFFF

// Generates NOP token
#define D3DVSD_NOP() 0x00000000

// bit declarations for _Type fields
#define D3DVSDT_FLOAT1      0x12    // 1D float expanded to (value, 0., 0., 1.)
#define D3DVSDT_FLOAT2      0x22    // 2D float expanded to (value, value, 0., 1.)
#define D3DVSDT_FLOAT3      0x32    // 3D float expanded to (value, value, value, 1.)
#define D3DVSDT_FLOAT4      0x42    // 4D float
#define D3DVSDT_D3DCOLOR    0x40    // 4D packed unsigned bytes mapped to 0. to 1. range
                                    // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
#define D3DVSDT_SHORT2      0x25    // 2D signed short expanded to (value, value, 0., 1.)
#define D3DVSDT_SHORT4      0x45    // 4D signed short

// The following are Xbox extensions
#define D3DVSDT_NORMSHORT1  0x11    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
                                    // (signed, normalized short maps from -1.0 to 1.0)
#define D3DVSDT_NORMSHORT2  0x21    // 2D signed, normalized short expanded to (value, value, 0., 1.)
#define D3DVSDT_NORMSHORT3  0x31    // 3D signed, normalized short expanded to (value, value, value, 1.)  
#define D3DVSDT_NORMSHORT4  0x41    // 4D signed, normalized short expanded to (value, value, value, value)  
#define D3DVSDT_NORMPACKED3 0x16    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
                                    // Each component ranges from -1.0 to 1.0.  
                                    // Expanded to (value, value, value, 1.)
#define D3DVSDT_SHORT1      0x15    // 1D signed short expanded to (value, 0., 0., 1.)  
                                    // Signed shorts map to the range [-32768, 32767]
#define D3DVSDT_SHORT3      0x35    // 3D signed short expanded to (value, value, value, 1.)
#define D3DVSDT_PBYTE1      0x14    // 1D packed byte expanded to (value, 0., 0., 1.)  
                                    // Packed bytes map to the range [0, 1]
#define D3DVSDT_PBYTE2      0x24    // 2D packed byte expanded to (value, value, 0., 1.)
#define D3DVSDT_PBYTE3      0x34    // 3D packed byte expanded to (value, value, value, 1.)
#define D3DVSDT_PBYTE4      0x44    // 4D packed byte expanded to (value, value, value, value) 
#define D3DVSDT_FLOAT2H     0x72    // 2D homogeneous float expanded to (value, value,0., value.)
                                    // Useful for projective texture coordinates.
#define D3DVSDT_NONE        0x02    // No stream data

// D3DVSDT_UBYTE4 not supported on Xbox (hardware can't do it)

// assignments of vertex input registers for fixed function vertex shader
//
#define D3DVSDE_VERTEX          -1  // Xbox extension, used only in Begin/End bracket
#define D3DVSDE_POSITION        0
#define D3DVSDE_BLENDWEIGHT     1
#define D3DVSDE_NORMAL          2
#define D3DVSDE_DIFFUSE         3
#define D3DVSDE_SPECULAR        4
#define D3DVSDE_FOG             5   // Xbox extension
#define D3DVSDE_BACKDIFFUSE     7   // Xbox extension
#define D3DVSDE_BACKSPECULAR    8   // Xbox extension
#define D3DVSDE_TEXCOORD0       9
#define D3DVSDE_TEXCOORD1       10
#define D3DVSDE_TEXCOORD2       11
#define D3DVSDE_TEXCOORD3       12

// D3DVSDE_PSIZE is not supported on Xbox with the fixed function pipeline 
// (a programmable vertex shader can be written to support per-vertex point
// sizes)

// Maximum supported number of texture coordinate sets
#define D3DDP_MAXTEXCOORD   4


//
// Instruction Token Bit Definitions
//
#define D3DSI_OPCODE_MASK       0x0000FFFF

typedef enum _D3DSHADER_INSTRUCTION_OPCODE_TYPE
{
    D3DSIO_NOP          = 0,    // PS/VS
    D3DSIO_MOV          ,       // PS/VS
    D3DSIO_ADD          ,       // PS/VS
    D3DSIO_SUB          ,       // PS
    D3DSIO_MAD          ,       // PS/VS
    D3DSIO_MUL          ,       // PS/VS
    D3DSIO_RCP          ,       // VS
    D3DSIO_RSQ          ,       // VS
    D3DSIO_DP3          ,       // PS/VS
    D3DSIO_DP4          ,       // VS
    D3DSIO_MIN          ,       // VS
    D3DSIO_MAX          ,       // VS
    D3DSIO_SLT          ,       // VS
    D3DSIO_SGE          ,       // VS
    D3DSIO_EXP          ,       // VS
    D3DSIO_LOG          ,       // VS
    D3DSIO_LIT          ,       // VS
    D3DSIO_DST          ,       // VS
    D3DSIO_LRP          ,       // PS
    D3DSIO_FRC          ,       // VS
    D3DSIO_M4x4         ,       // VS
    D3DSIO_M4x3         ,       // VS
    D3DSIO_M3x4         ,       // VS
    D3DSIO_M3x3         ,       // VS
    D3DSIO_M3x2         ,       // VS

    D3DSIO_TEXCOORD     = 64,   // PS
    D3DSIO_TEXKILL      ,       // PS
    D3DSIO_TEX          ,       // PS
    D3DSIO_TEXBEM       ,       // PS
    D3DSIO_TEXBEML      ,       // PS
    D3DSIO_TEXREG2AR    ,       // PS
    D3DSIO_TEXREG2GB    ,       // PS
    D3DSIO_TEXM3x2PAD   ,       // PS
    D3DSIO_TEXM3x2TEX   ,       // PS
    D3DSIO_TEXM3x3PAD   ,       // PS
    D3DSIO_TEXM3x3TEX   ,       // PS
    D3DSIO_TEXM3x3DIFF  ,       // PS
    D3DSIO_TEXM3x3SPEC  ,       // PS
    D3DSIO_TEXM3x3VSPEC ,       // PS
    D3DSIO_EXPP         ,       // VS
    D3DSIO_LOGP         ,       // VS
    D3DSIO_CND          ,       // PS
    D3DSIO_DEF          ,       // PS
    
    // Xbox Extensions
    D3DSIO_DPH          =256,   // VS
    D3DSIO_RCC          ,       // VS
    D3DSIO_XMMA         ,       // PS
    D3DSIO_XMMC         ,       // PS
    D3DSIO_XDM          ,       // PS
    D3DSIO_XDD          ,       // PS
    D3DSIO_XFC          ,       // PS
    D3DSIO_TEXM3x2DEPTH ,       // PS
    D3DSIO_TEXBRDF      ,       // PS

    D3DSIO_COMMENT      = 0xFFFE,
    D3DSIO_END          = 0xFFFF,

    D3DSIO_FORCE_DWORD  = 0x7fffffff,   // force 32-bit size enum
} D3DSHADER_INSTRUCTION_OPCODE_TYPE;

//
// Co-Issue Instruction Modifier - if set then this instruction is to be
// issued in parallel with the previous instruction(s) for which this bit
// is not set.
//
#define D3DSI_COISSUE           0x40000000

//
// Parameter Token Bit Definitions
//
#define D3DSP_REGNUM_MASK       0x00000FFF

// destination parameter write mask
#define D3DSP_WRITEMASK_0       0x00010000  // Component 0 (X;Red)
#define D3DSP_WRITEMASK_1       0x00020000  // Component 1 (Y;Green)
#define D3DSP_WRITEMASK_2       0x00040000  // Component 2 (Z;Blue)
#define D3DSP_WRITEMASK_3       0x00080000  // Component 3 (W;Alpha)
#define D3DSP_WRITEMASK_ALL     0x000F0000  // All Components

// destination parameter modifiers
#define D3DSP_DSTMOD_SHIFT      20
#define D3DSP_DSTMOD_MASK       0x00F00000

#define D3DSP_DSTSRC_SHIFT      15          // indicates src or dst
#define D3DSP_DSTSRC_MASK       0x00008000

typedef enum _D3DSHADER_PARAM_DSTMOD_TYPE
{
    D3DSPDM_NONE    = 0<<D3DSP_DSTMOD_SHIFT, // nop
    D3DSPDM_BIAS    = 1<<D3DSP_DSTMOD_SHIFT, // subtract 0.5
    D3DSPDM_FORCE_DWORD  = 0x7fffffff,      // force 32-bit size enum
} D3DSHADER_PARAM_DSTMOD_TYPE;

// destination parameter 
#define D3DSP_DSTSHIFT_SHIFT    24
#define D3DSP_DSTSHIFT_MASK     0x0F000000

// destination/source parameter register type
#define D3DSP_REGTYPE_SHIFT     28
#define D3DSP_REGTYPE_MASK      0x70000000

typedef enum _D3DSHADER_PARAM_REGISTER_TYPE
{
    D3DSPR_TEMP     = 0<<D3DSP_REGTYPE_SHIFT, // Temporary Register File
    D3DSPR_INPUT    = 1<<D3DSP_REGTYPE_SHIFT, // Input Register File
    D3DSPR_CONST    = 2<<D3DSP_REGTYPE_SHIFT, // Constant Register File
    D3DSPR_ADDR     = 3<<D3DSP_REGTYPE_SHIFT, // Address Register (VS)
    D3DSPR_TEXTURE  = 3<<D3DSP_REGTYPE_SHIFT, // Texture Register File (PS)
    D3DSPR_RASTOUT  = 4<<D3DSP_REGTYPE_SHIFT, // Rasterizer Register File
    D3DSPR_ATTROUT  = 5<<D3DSP_REGTYPE_SHIFT, // Attribute Output Register File
    D3DSPR_TEXCRDOUT= 6<<D3DSP_REGTYPE_SHIFT, // Texture Coordinate Output Register File
    D3DSPR_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DSHADER_PARAM_REGISTER_TYPE;

// Register offsets in the Rasterizer Register File
//
typedef enum _D3DVS_RASTOUT_OFFSETS
{
    D3DSRO_POSITION = 0,
    D3DSRO_FOG,
    D3DSRO_POINT_SIZE,
    D3DSRO_FORCE_DWORD  = 0x7fffffff,         // force 32-bit size enum
} D3DVS_RASTOUT_OFFSETS;

// Source operand addressing modes

#define D3DVS_ADDRESSMODE_SHIFT 13
#define D3DVS_ADDRESSMODE_MASK  (3 << D3DVS_ADDRESSMODE_SHIFT)

enum D3DVS_ADRRESSMODE
{
    D3DVS_ADDRMODE_ABSOLUTE  = (0 << D3DVS_ADDRESSMODE_SHIFT),
    D3DVS_ADDRMODE_RELATIVE  = (1 << D3DVS_ADDRESSMODE_SHIFT),   // Relative to register A0
    D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, // force 32-bit size enum
};

// Source operand swizzle definitions
//
#define D3DVS_SWIZZLE_SHIFT     16
#define D3DVS_SWIZZLE_MASK      0x00FF0000

// The following bits define where to take component X:

#define D3DVS_X_X       (0 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Y       (1 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_Z       (2 << D3DVS_SWIZZLE_SHIFT)
#define D3DVS_X_W       (3 << D3DVS_SWIZZLE_SHIFT)

// The following bits define where to take component Y:

#define D3DVS_Y_X       (0 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 2))
#define D3DVS_Y_W       (3 << (D3DVS_SWIZZLE_SHIFT + 2))

// The following bits define where to take component Z:

#define D3DVS_Z_X       (0 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 4))
#define D3DVS_Z_W       (3 << (D3DVS_SWIZZLE_SHIFT + 4))

// The following bits define where to take component W:

#define D3DVS_W_X       (0 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Y       (1 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_Z       (2 << (D3DVS_SWIZZLE_SHIFT + 6))
#define D3DVS_W_W       (3 << (D3DVS_SWIZZLE_SHIFT + 6))

// Value when there is no swizzle (X is taken from X, Y is taken from Y,
// Z is taken from Z, W is taken from W
//
#define D3DVS_NOSWIZZLE (D3DVS_X_X | D3DVS_Y_Y | D3DVS_Z_Z | D3DVS_W_W)

// source parameter swizzle
#define D3DSP_SWIZZLE_SHIFT     16
#define D3DSP_SWIZZLE_MASK      0x00FF0000

#define D3DSP_NOSWIZZLE \
    ( (0 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (1 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (2 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// pixel-shader swizzle ops
#define D3DSP_REPLICATEALPHA \
    ( (3 << (D3DSP_SWIZZLE_SHIFT + 0)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 2)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 4)) | \
      (3 << (D3DSP_SWIZZLE_SHIFT + 6)) )

// source parameter modifiers
#define D3DSP_SRCMOD_SHIFT      24
#define D3DSP_SRCMOD_MASK       0x0F000000

typedef enum _D3DSHADER_PARAM_SRCMOD_TYPE
{
    D3DSPSM_NONE    = 0<<D3DSP_SRCMOD_SHIFT, // nop
    D3DSPSM_NEG     = 1<<D3DSP_SRCMOD_SHIFT, // negate
    D3DSPSM_BIAS    = 2<<D3DSP_SRCMOD_SHIFT, // bias
    D3DSPSM_BIASNEG = 3<<D3DSP_SRCMOD_SHIFT, // bias and negate
    D3DSPSM_SIGN    = 4<<D3DSP_SRCMOD_SHIFT, // sign
    D3DSPSM_SIGNNEG = 5<<D3DSP_SRCMOD_SHIFT, // sign and negate
    D3DSPSM_COMP    = 6<<D3DSP_SRCMOD_SHIFT, // complement
    D3DSPSM_SAT     = 7<<D3DSP_SRCMOD_SHIFT, // saturate

    D3DSPSM_FORCE_DWORD = 0x7fffffff,        // force 32-bit size enum
} D3DSHADER_PARAM_SRCMOD_TYPE;

// pixel shader version token
#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))

// vertex shader version token
#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))

// extract major/minor from version cap
#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)>>8)&0xFF)
#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)>>0)&0xFF)

// destination/source parameter register type
#define D3DSI_COMMENTSIZE_SHIFT     16
#define D3DSI_COMMENTSIZE_MASK      0x7FFF0000
#define D3DSHADER_COMMENT(_DWordSize) \
    ((((_DWordSize)<<D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|D3DSIO_COMMENT)

// pixel/vertex shader end token
#define D3DPS_END()  0x0000FFFF
#define D3DVS_END()  0x0000FFFF

//-------------------------------------------------------------------------
// D3D Vertex Shader Microcode Type values:
// --------------
//
// D3DSMT_VERTEXSHADER
//   An ordinary vertex shader.
//
// D3DSMT_READWRITE_VERTEXSHADER
//   A vertex shader that can write to the constant registers.
//
// D3DSMT_VERTEXSTATESHADER
//   A vertex state shader.
//
//-------------------------------------------------------------------------

#define D3DSMT_VERTEXSHADER              1
#define D3DSMT_READWRITE_VERTEXSHADER    2
#define D3DSMT_VERTEXSTATESHADER         3

//---------------------------------------------------------------------

// High order surfaces
//
typedef enum _D3DBASISTYPE
{
   D3DBASIS_BEZIER      = 0,
   D3DBASIS_BSPLINE     = 1,
   D3DBASIS_INTERPOLATE = 2,
   D3DBASIS_FORCE_DWORD = 0x7fffffff,
} D3DBASISTYPE;

typedef enum _D3DORDERTYPE
{
   D3DORDER_LINEAR      = 1,
   D3DORDER_CUBIC       = 3,
   D3DORDER_QUINTIC     = 5,
   D3DORDER_FORCE_DWORD = 0x7fffffff,
} D3DORDERTYPE;

typedef enum _D3DPATCHEDGESTYLE
{
   D3DPATCHEDGE_DISCRETE    = 0,
   D3DPATCHEDGE_CONTINUOUS  = 1,
   D3DPATCHEDGE_FORCE_DWORD = 0x7fffffff,
} D3DPATCHEDGESTYLE;

typedef enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL           = 1, // capture all state
    D3DSBT_PIXELSTATE    = 2, // capture pixel state
    D3DSBT_VERTEXSTATE   = 3, // capture vertex state
    D3DSBT_FORCE_DWORD   = 0x7fffffff,
} D3DSTATEBLOCKTYPE;

// The D3DVERTEXBLENDFLAGS type is used with D3DRS_VERTEXBLEND state.
//
typedef enum _D3DVERTEXBLENDFLAGS
{
    D3DVBF_DISABLE           = 0,     // Disable vertex blending
    D3DVBF_1WEIGHTS          = 1,     // 2 matrix blending
    D3DVBF_2WEIGHTS          = 3,     // 3 matrix blending
    D3DVBF_3WEIGHTS          = 5,     // 4 matrix blending
    D3DVBF_2WEIGHTS2MATRICES = 2,     // Xbox extension
    D3DVBF_3WEIGHTS3MATRICES = 4,     // Xbox extension
    D3DVBF_4WEIGHTS4MATRICES = 6,     // Xbox extension

    D3DVBF_MAX               = 7,
    D3DVBF_FORCE_DWORD       = 0x7fffffff, // force 32-bit size enum
} D3DVERTEXBLENDFLAGS;

typedef enum _D3DTEXTURETRANSFORMFLAGS 
{
    D3DTTFF_DISABLE         = 0,    // texture coordinates are passed directly
    D3DTTFF_COUNT1          = 1,    // rasterizer should expect 1-D texture coords
    D3DTTFF_COUNT2          = 2,    // rasterizer should expect 2-D texture coords
    D3DTTFF_COUNT3          = 3,    // rasterizer should expect 3-D texture coords
    D3DTTFF_COUNT4          = 4,    // rasterizer should expect 4-D texture coords
    D3DTTFF_PROJECTED       = 256,  // texcoords to be divided by COUNTth element
    D3DTTFF_FORCE_DWORD     = 0x7fffffff,
} D3DTEXTURETRANSFORMFLAGS;

// Macros to set texture coordinate format bits in the FVF id

#define D3DFVF_TEXTUREFORMAT2 0         // Two floating point values
#define D3DFVF_TEXTUREFORMAT1 3         // One floating point value
#define D3DFVF_TEXTUREFORMAT3 1         // Three floating point values
#define D3DFVF_TEXTUREFORMAT4 2         // Four floating point values

#define D3DFVF_TEXCOORDSIZE3(CoordIndex) (D3DFVF_TEXTUREFORMAT3 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE2(CoordIndex) (D3DFVF_TEXTUREFORMAT2)
#define D3DFVF_TEXCOORDSIZE4(CoordIndex) (D3DFVF_TEXTUREFORMAT4 << (CoordIndex*2 + 16))
#define D3DFVF_TEXCOORDSIZE1(CoordIndex) (D3DFVF_TEXTUREFORMAT1 << (CoordIndex*2 + 16))


//---------------------------------------------------------------------

/* Direct3D8 Device types */
typedef enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL         = 1,
    D3DDEVTYPE_REF         = 2,
    D3DDEVTYPE_SW          = 3,

    D3DDEVTYPE_FORCE_DWORD  = 0x7fffffff
} D3DDEVTYPE;

/* Antialiasing buffer types */

typedef DWORD D3DMULTISAMPLE_TYPE;

#define D3DMULTISAMPLE_NONE                                      0x0011

// Number of samples, sample type, and filter (Xbox extensions):
//
#define D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR              0x1021
#define D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX            0x1121
#define D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR   0x2021
#define D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR     0x2012
                                                              
#define D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR              0x1022
#define D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN            0x1222
#define D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR              0x2022
#define D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN            0x2222
                                                              
#define D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN            0x1233
#define D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN            0x2233
                                                                  
// Format of the pre-filter (big) color buffer (Xbox extensions):
//                                                          
#define D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT                  0x00000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5                 0x10000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5                   0x20000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8                 0x30000 
#define D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8                 0x40000 

// Defaults:
//
#define D3DMULTISAMPLE_2_SAMPLES D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMULTISAMPLE_4_SAMPLES D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMULTISAMPLE_9_SAMPLES D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN


/* Formats
 * Most of these names have the following convention:
 *      A = Alpha
 *      R = Red
 *      G = Green
 *      B = Blue
 *      X = Unused Bits
 *      P = Palette
 *      L = Luminance
 *      U = dU coordinate for BumpMap
 *      V = dV coordinate for BumpMap
 *      S = Stencil
 *      D = Depth (e.g. Z or W buffer)
 *
 *      Further, the order of the pieces are from MSB first; hence
 *      D3DFMT_A8L8 indicates that the high byte of this two byte
 *      format is alpha.
 *
 *      D16 indicates:
 *           - An integer 16-bit value.
 *           - An app-lockable surface.
 *
 *      All Depth/Stencil formats except D3DFMT_D16_LOCKABLE indicate:
 *          - no particular bit ordering per pixel, and
 *          - are not app lockable, and
 *          - the driver is allowed to consume more than the indicated
 *            number of bits per Depth channel (but not Stencil channel).
 */

// DOC: The numerical values for these formats have changed from D3D8
//    : to make the mapping to the NV internal format value easier.
//    : Most noteably is that D3DFMT_UNKNOWN is no longer zero.
//
typedef enum _D3DFORMAT
{
    D3DFMT_UNKNOWN              = 0xFFFFFFFF,

    /* Swizzled formats */

    D3DFMT_A8R8G8B8             = 0x00000006,
    D3DFMT_X8R8G8B8             = 0x00000007,
    D3DFMT_R5G6B5               = 0x00000005,
    D3DFMT_R6G5B5               = 0x00000027,
    D3DFMT_X1R5G5B5             = 0x00000003,
    D3DFMT_A1R5G5B5             = 0x00000002,
    D3DFMT_A4R4G4B4             = 0x00000004,
    D3DFMT_A8                   = 0x00000019,
    D3DFMT_A8B8G8R8             = 0x0000003A,   
    D3DFMT_B8G8R8A8             = 0x0000003B,   
    D3DFMT_R4G4B4A4             = 0x00000039,   
    D3DFMT_R5G5B5A1             = 0x00000038,   
    D3DFMT_R8G8B8A8             = 0x0000003C,   
    D3DFMT_R8B8                 = 0x00000029,   
    D3DFMT_G8B8                 = 0x00000028,   

    D3DFMT_P8                   = 0x0000000B,

    D3DFMT_L8                   = 0x00000000,
    D3DFMT_A8L8                 = 0x0000001A,
    D3DFMT_AL8                  = 0x00000001,   
    D3DFMT_L16                  = 0x00000032,   

    D3DFMT_V8U8                 = 0x00000028,
    D3DFMT_L6V5U5               = 0x00000027,
    D3DFMT_X8L8V8U8             = 0x00000007,
    D3DFMT_Q8W8V8U8             = 0x0000003A,
    D3DFMT_V16U16               = 0x00000033,

    D3DFMT_D16_LOCKABLE         = 0x0000002C,
    D3DFMT_D16                  = 0x0000002C,
    D3DFMT_D24S8                = 0x0000002A,
    D3DFMT_F16                  = 0x0000002D,   
    D3DFMT_F24S8                = 0x0000002B,

    /* YUV formats */

    D3DFMT_YUY2                 = 0x00000024,
    D3DFMT_UYVY                 = 0x00000025,

    /* Compressed formats */

    D3DFMT_DXT1                 = 0x0000000C,
    D3DFMT_DXT2                 = 0x0000000E,
    D3DFMT_DXT3                 = 0x0000000E,
    D3DFMT_DXT4                 = 0x0000000F,
    D3DFMT_DXT5                 = 0x0000000F,

    /* Linear formats */

    D3DFMT_LIN_A1R5G5B5         = 0x00000010,   
    D3DFMT_LIN_A4R4G4B4         = 0x0000001D,   
    D3DFMT_LIN_A8               = 0x0000001F,   
    D3DFMT_LIN_A8B8G8R8         = 0x0000003F,   
    D3DFMT_LIN_A8R8G8B8         = 0x00000012,   
    D3DFMT_LIN_B8G8R8A8         = 0x00000040,   
    D3DFMT_LIN_G8B8             = 0x00000017,   
    D3DFMT_LIN_R4G4B4A4         = 0x0000003E,   
    D3DFMT_LIN_R5G5B5A1         = 0x0000003D,   
    D3DFMT_LIN_R5G6B5           = 0x00000011,   
    D3DFMT_LIN_R6G5B5           = 0x00000037,   
    D3DFMT_LIN_R8B8             = 0x00000016,   
    D3DFMT_LIN_R8G8B8A8         = 0x00000041,   
    D3DFMT_LIN_X1R5G5B5         = 0x0000001C,   
    D3DFMT_LIN_X8R8G8B8         = 0x0000001E,   

    D3DFMT_LIN_A8L8             = 0x00000020,   
    D3DFMT_LIN_AL8              = 0x0000001B,   
    D3DFMT_LIN_L16              = 0x00000035,   
    D3DFMT_LIN_L8               = 0x00000013,   

    D3DFMT_LIN_V16U16           = 0x00000036,
    D3DFMT_LIN_V8U8             = 0x00000017,
    D3DFMT_LIN_L6V5U5           = 0x00000037,
    D3DFMT_LIN_X8L8V8U8         = 0x0000001E,
    D3DFMT_LIN_Q8W8V8U8         = 0x00000012,

    D3DFMT_LIN_D24S8            = 0x0000002E,   
    D3DFMT_LIN_F24S8            = 0x0000002F,   
    D3DFMT_LIN_D16              = 0x00000030,   
    D3DFMT_LIN_F16              = 0x00000031,   

    D3DFMT_VERTEXDATA           = 100,
    D3DFMT_INDEX16              = 101,

    D3DFMT_FORCE_DWORD          =0x7fffffff
} D3DFORMAT;

/* Display mode flags */

#define D3DPRESENTFLAG_LOCKABLE_BACKBUFFER      0x00000001
#define D3DPRESENTFLAG_WIDESCREEN               0x00000010
#define D3DPRESENTFLAG_INTERLACED               0x00000020
#define D3DPRESENTFLAG_PROGRESSIVE              0x00000040
#define D3DPRESENTFLAG_FIELD                    0x00000080
#define D3DPRESENTFLAG_10X11PIXELASPECTRATIO    0x00000100

/* Display Modes */
typedef struct _D3DDISPLAYMODE
{
    UINT            Width;
    UINT            Height;
    UINT            RefreshRate;
    DWORD           Flags;
    D3DFORMAT       Format;
} D3DDISPLAYMODE;

/* Creation Parameters */
typedef struct _D3DDEVICE_CREATION_PARAMETERS
{
    UINT            AdapterOrdinal;
    D3DDEVTYPE      DeviceType;
    HWND            hFocusWindow;
    DWORD           BehaviorFlags;
} D3DDEVICE_CREATION_PARAMETERS;


/* SwapEffects */
typedef enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD           = 1,
    D3DSWAPEFFECT_FLIP              = 2,
    D3DSWAPEFFECT_COPY              = 3,
    D3DSWAPEFFECT_COPY_VSYNC        = 4,

    D3DSWAPEFFECT_FORCE_DWORD       = 0x7fffffff
} D3DSWAPEFFECT;

/* Insert Callback */
typedef enum _D3DCALLBACKTYPE
{
    D3DCALLBACK_READ                = 0,
    D3DCALLBACK_WRITE               = 1,

    D3DCALLBACKTYPE_FORCE_DWORD     = 0x7fffffff
} D3DCALLBACKTYPE;

/* Pool types */

// DOC: All parameters typed as D3DPOOL will be ignored.  Change the type from an enum
//  : to a DWORD so developers can cheat and just pass '0' for this value.

typedef DWORD D3DPOOL;

#define D3DPOOL_DEFAULT             0
#define D3DPOOL_MANAGED             1
#define D3DPOOL_SYSTEMMEM           2

/* RefreshRate pre-defines */
#define D3DPRESENT_RATE_DEFAULT         0x00000000
#define D3DPRESENT_RATE_UNLIMITED       0x00000000


/* Resize Optional Parameters */
typedef struct _D3DPRESENT_PARAMETERS_
{
    UINT                BackBufferWidth;
    UINT                BackBufferHeight;
    D3DFORMAT           BackBufferFormat;
    UINT                BackBufferCount;

    D3DMULTISAMPLE_TYPE MultiSampleType;

    D3DSWAPEFFECT       SwapEffect;
    HWND                hDeviceWindow;
    BOOL                Windowed;
    BOOL                EnableAutoDepthStencil;
    D3DFORMAT           AutoDepthStencilFormat;
    DWORD               Flags;

    /* Following elements must be zero for Windowed mode */
    UINT                FullScreen_RefreshRateInHz;
    UINT                FullScreen_PresentationInterval;

} D3DPRESENT_PARAMETERS;

/* Gamma Ramp: Xbox changes WORD values to BYTE */

typedef struct _D3DGAMMARAMP
{
    BYTE                red  [256];
    BYTE                green[256];
    BYTE                blue [256];
} D3DGAMMARAMP;

/* Back buffer types */
typedef DWORD D3DBACKBUFFER_TYPE;

#define D3DBACKBUFFER_TYPE_MONO   0


/* Types */
typedef enum _D3DRESOURCETYPE 
{
    D3DRTYPE_NONE                   =  0,
    D3DRTYPE_SURFACE                =  1,
    D3DRTYPE_VOLUME                 =  2,
    D3DRTYPE_TEXTURE                =  3,
    D3DRTYPE_VOLUMETEXTURE          =  4,
    D3DRTYPE_CUBETEXTURE            =  5,
    D3DRTYPE_VERTEXBUFFER           =  6,
    D3DRTYPE_INDEXBUFFER            =  7,
    D3DRTYPE_PUSHBUFFER             =  8,
    D3DRTYPE_PALETTE                =  9,
    D3DRTYPE_FIXUP                  =  10,

    D3DRTYPE_FORCE_DWORD            = 0x7fffffff
} D3DRESOURCETYPE;

/* Locations */

// Enumeration used for memory movement (Xbox extension)
//
typedef enum _D3DMEMORY 
{
    D3DMEM_AGP                      = 0,
    D3DMEM_VIDEO                    = 1
} D3DMEMORY;

/* Usages */
#define D3DUSAGE_RENDERTARGET           (0x00000001L)
#define D3DUSAGE_DEPTHSTENCIL           (0x00000002L)

/* Usages for Vertex/Index buffers */
#define D3DUSAGE_WRITEONLY              (0x00000008L)
#define D3DUSAGE_POINTS                 (0x00000040L)
#define D3DUSAGE_RTPATCHES              (0x00000080L)
#define D3DUSAGE_DYNAMIC                (0x00000200L)

/* Usages for CreateVertexShader */
#define D3DUSAGE_PERSISTENTDIFFUSE      (0x00000400L)   // Xbox extension
#define D3DUSAGE_PERSISTENTSPECULAR     (0x00000800L)   // Xbox extension
#define D3DUSAGE_PERSISTENTBACKDIFFUSE  (0x00001000L)   // Xbox extension
#define D3DUSAGE_PERSISTENTBACKSPECULAR (0x00002000L)   // Xbox extension

/* Usages for CreateTexture/CreateImageSurface */
#define D3DUSAGE_BORDERSOURCE_COLOR     (0x00000000L)   // Xbox extension
#define D3DUSAGE_BORDERSOURCE_TEXTURE   (0x00010000L)   // Xbox extension


/* CubeMap Face identifiers */
typedef enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X     = 0,
    D3DCUBEMAP_FACE_NEGATIVE_X     = 1,
    D3DCUBEMAP_FACE_POSITIVE_Y     = 2,
    D3DCUBEMAP_FACE_NEGATIVE_Y     = 3,
    D3DCUBEMAP_FACE_POSITIVE_Z     = 4,
    D3DCUBEMAP_FACE_NEGATIVE_Z     = 5,

    D3DCUBEMAP_FACE_FORCE_DWORD    = 0x7fffffff
} D3DCUBEMAP_FACES;


/* Lock flags */

#define D3DLOCK_NOFLUSH             0x00000010L // Xbox extension
#define D3DLOCK_NOOVERWRITE         0x00000020L 
#define D3DLOCK_TILED               0x00000040L // Xbox extension
#define D3DLOCK_READONLY            0x00000080L

// D3DLOCK_NOSYSLOCK not supported on Xbox
// D3DLOCK_NO_DIRTY_UPDATE not supported on Xbox
// D3DLOCK_DISCARD not supported on Xbox 
//
//     (NOTE: The lack of D3DLOCK_DISCARD support can cause significant 
//      performance degradation for the unwary.  See the documentation
//      for notes on using IsBusy or fences in order to manage your own
//      pool of temporary vertex buffers when generating vertex data
//      dynamically.)

/* Vertex Buffer Description */
typedef struct _D3DVERTEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;

} D3DVERTEXBUFFER_DESC;

/* Index Buffer Description */
typedef struct _D3DINDEXBUFFER_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
} D3DINDEXBUFFER_DESC;


/* Surface Description */
typedef struct _D3DSURFACE_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    D3DMULTISAMPLE_TYPE MultiSampleType;
    UINT                Width;
    UINT                Height;
} D3DSURFACE_DESC;

typedef struct _D3DVOLUME_DESC
{
    D3DFORMAT           Format;
    D3DRESOURCETYPE     Type;
    DWORD               Usage;
    UINT                Size;

    UINT                Width;
    UINT                Height;
    UINT                Depth;
} D3DVOLUME_DESC;

/* Structure for LockRect */
typedef struct _D3DLOCKED_RECT
{
    INT                 Pitch;
    void*               pBits;
} D3DLOCKED_RECT;

/* Structures for LockBox */
typedef struct _D3DBOX
{
    UINT                Left;
    UINT                Top;
    UINT                Right;
    UINT                Bottom;
    UINT                Front;
    UINT                Back;
} D3DBOX;

typedef struct _D3DLOCKED_BOX
{
    INT                 RowPitch;
    INT                 SlicePitch;
    void*               pBits;
} D3DLOCKED_BOX;

/* Structures for high order primitives */
typedef struct _D3DRECTPATCH_INFO
{
    UINT                StartVertexOffsetWidth;
    UINT                StartVertexOffsetHeight;
    UINT                Width;
    UINT                Height;
    UINT                Stride;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DRECTPATCH_INFO;

typedef struct _D3DTRIPATCH_INFO
{
    UINT                StartVertexOffset;
    UINT                NumVertices;
    D3DBASISTYPE        Basis;
    D3DORDERTYPE        Order;
} D3DTRIPATCH_INFO;

/* Adapter Identifier */
#define MAX_DEVICE_IDENTIFIER_STRING        512
typedef struct _D3DADAPTER_IDENTIFIER8
{
    char            Driver[MAX_DEVICE_IDENTIFIER_STRING];
    char            Description[MAX_DEVICE_IDENTIFIER_STRING];

#ifdef _WIN32
    LARGE_INTEGER   DriverVersion;            /* Defined for 32 bit components */
#else
    DWORD           DriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD           DriverVersionHighPart;
#endif

    DWORD           VendorId;
    DWORD           DeviceId;
    DWORD           SubSysId;
    DWORD           Revision;

    GUID            DeviceIdentifier;

    DWORD           WHQLLevel;

} D3DADAPTER_IDENTIFIER8;


/* Raster Status structure returned by GetRasterStatus */
typedef struct _D3DRASTER_STATUS
{
    BOOL            InVBlank;
    UINT            ScanLine;
} D3DRASTER_STATUS;


/* Field Type enum defines possible values for a display field */
typedef enum _D3DFIELDTYPE                      // Xbox extension
{                    
    D3DFIELD_ODD            = 1,
    D3DFIELD_EVEN           = 2,
    D3DFIELD_PROGRESSIVE    = 3,
    D3DFIELD_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
} D3DFIELDTYPE;


/* Field Status structure is returned by GetDisplayFieldStatus */
typedef struct _D3DFIELD_STATUS                 // Xbox extension
{
    D3DFIELDTYPE   Field;
    UINT           VBlankCount;
} D3DFIELD_STATUS;


/* SetVertexInput struct */
typedef struct _D3DSTREAM_INPUT                 // Xbox extension
{
    D3DVertexBuffer    *VertexBuffer;
    UINT                Stride;
    UINT                Offset;
} D3DSTREAM_INPUT;


/* Maximum number of scissors rectangles */     
#define D3DSCISSORS_MAX             8

/* D3DTILE constants */
#define D3DTILE_MAXTILES            8
#define D3DTILE_MAXTAGS             76800
#define D3DTILE_TAGSIZE             64
#define D3DTILE_ALIGNMENT           0x4000

/* D3DTILE macro for calculating the end tag for a Z-compressed tile */
#define D3DTILE_ZENDTAG(pTile) ((((pTile)->ZStartTag + ((pTile)->Size / D3DTILE_TAGSIZE)) + 255) & ~255)

/* D3DTILE Flags */
#define D3DTILE_FLAGS_ZBUFFER       0x00000001
#define D3DTILE_FLAGS_ZCOMPRESS     0x80000000
#define D3DTILE_FLAGS_Z32BITS       0x04000000
#define D3DTILE_FLAGS_Z16BITS       0x00000000

/* D3DTILE Pitch values */
#define D3DTILE_PITCH_0200          0x0200
#define D3DTILE_PITCH_0400          0x0400
#define D3DTILE_PITCH_0600          0x0600
#define D3DTILE_PITCH_0800          0x0800
#define D3DTILE_PITCH_0A00          0x0A00
#define D3DTILE_PITCH_0C00          0x0C00
#define D3DTILE_PITCH_0E00          0x0E00
#define D3DTILE_PITCH_1000          0x1000
#define D3DTILE_PITCH_1400          0x1400
#define D3DTILE_PITCH_1800          0x1800
#define D3DTILE_PITCH_1C00          0x1C00
#define D3DTILE_PITCH_2800          0x2800
#define D3DTILE_PITCH_3000          0x3000
#define D3DTILE_PITCH_3800          0x3800
#define D3DTILE_PITCH_5000          0x5000
#define D3DTILE_PITCH_7000          0x7000

/* SetTile struct */
typedef struct _D3DTILE                         // Xbox extension
{                   
    DWORD   Flags;
    void*   pMemory;
    DWORD   Size;
    DWORD   Pitch;
    DWORD   ZStartTag; 
    DWORD   ZOffset;
} D3DTILE;


/*----------------------------------------------
/* Pixel Shader Binary Format
/*----------------------------------------------

/*---------------------------------------------------*/
/*  This structure holds all of the state necessary  */
/*  to define an Xbox Pixel Shader.  It is the       */
/*  structure generated when a pixel shader is       */
/*  assembled.  Each member of this structure        */
/*  corresponds to a D3D Renderstate that can be     */
/*  set at any time using the SetRenderState()       */
/*  method.                                          */
/*  The members of this structure have been ordered  */
/*  to enable the most efficient hardware load       */
/*  possible.                                        */
/*---------------------------------------------------*/

typedef struct _D3DPixelShaderDef
{
   DWORD    PSAlphaInputs[8];          // Alpha inputs for each stage
   DWORD    PSFinalCombinerInputsABCD; // Final combiner inputs
   DWORD    PSFinalCombinerInputsEFG;  // Final combiner inputs (continued)
   DWORD    PSConstant0[8];            // C0 for each stage
   DWORD    PSConstant1[8];            // C1 for each stage
   DWORD    PSAlphaOutputs[8];         // Alpha output for each stage
   DWORD    PSRGBInputs[8];            // RGB inputs for each stage
   DWORD    PSCompareMode;             // Compare modes for clipplane texture mode
   DWORD    PSFinalCombinerConstant0;  // C0 in final combiner
   DWORD    PSFinalCombinerConstant1;  // C1 in final combiner
   DWORD    PSRGBOutputs[8];           // Stage 0 RGB outputs
   DWORD    PSCombinerCount;           // Active combiner count (Stages 0-7)
   DWORD    PSTextureModes;            // Texture addressing modes
   DWORD    PSDotMapping;              // Input mapping for dot product modes
   DWORD    PSInputTexture;            // Texture source for some texture modes
   DWORD    PSC0Mapping;               // Mapping of c0 regs to D3D constants
   DWORD    PSC1Mapping;               // Mapping of c1 regs to D3D constants
   DWORD    PSFinalCombinerConstants;  // Final combiner constant mapping
} D3DPIXELSHADERDEF;

/*---------------------------------------------------------------------------*/
/*  Texture configuration - The following members of the D3DPixelShaderDef   */
/*  structure define the addressing modes of each of the four texture stages:*/
/*      PSTextureModes                                                       */
/*      PSDotMapping                                                         */
/*      PSInputTexture                                                       */
/*      PSCompareMode                                                        */
/*---------------------------------------------------------------------------*/

// =========================================================================================================
// PSTextureModes
// --------.--------.--------.---xxxxx stage0
// --------.--------.------xx.xxx----- stage1
// --------.--------.-xxxxx--.-------- stage2
// --------.----xxxx.x-------.-------- stage3

#define PS_TEXTUREMODES(t0,t1,t2,t3) (((t3)<<15)|((t2)<<10)|((t1)<<5)|(t0))

/*
Texture modes:
NONE           :stage inactive
PROJECT2D      :argb = texture(s/q, t/q)
PROJECT3D      :argb = texture(s/q, t/q, r/q)
CUBEMAP        :argb = cubemap(s,t,r)
PASSTHRU       :argb = s,t,r,q
CLIPPLANE      :pixel not drawn if s,t,r, or q < 0.  PSCompareMode affects comparison
BUMPENVMAP     :argb=texture(s+mat00*src.r+mat01*src.g,
                             t+mat10*src.r+mat11*src.g)
                mat00 set via D3DTSS_BUMPENVMAT00, etc.
BUMPENVMAP_LUM :argb=texture(s+mat00*src.r+mat01*src.g, 
                             t+mat10*src.r+mat11*src.g) * (lum_scale*src.b + lum_bias)
                lum_scale set by D3DTSS_BUMPENVLSCALE
                lum_bias set by D3DTSS_BUMPENVLOFFSET
                mat00 set via D3DTSS_BUMPENVMAT00, etc.
BRDF           :argb = texture(eyeSigma, lightSigma, dPhi)
                       eyeSigma = Sigma of eye vector in spherical coordinates
                       lightSigma = Sigma of light vector in spherical coordinates
                       dPhi = Phi of eye - Phi of light
DOT_ST         :argb = texture(<DotResult of stage-1>, (s,t,r).(src.r,src.g,src.b))
DOT_ZW         :frag depth = (<DotResult of stage-1>/((s,t,r).(src.r,src.g,src.b))
DOT_RFLCT_DIFF :n = (<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b),<DotResult of stage+1>)
                argb = cubemap(n)
DOT_RFLCT_SPEC :n = (<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b))
                r = 2*n*(n.e)/(n.n) - e where e is eye vector built from q coord of each stage
                argb = cubemap(r)
DOT_STR_3D     :argb=texture((<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b)))
DOT_STR_CUBE   :argb=cubemap((<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b)))
DEPENDENT_AR   :argb = texture(src.a, src.r) 
DEPENDENT_GB   :argb = texture(src.g, src.b)
DOTPRODUCT     :argb = (s,t,r).(src.r,src.g,src.b)
DOT_RFLCT_SPEC_CONST :n = (<DotResult of stage-2>,<DotResult of stage-1>,(s,t,r).(src.r,src.g,src.b))
                r = 2*n*(n.e)/(n.n) - e where e is eye vector set via SetEyeVector()
                argb = cubemap(r)
*/

enum PS_TEXTUREMODES
{                                 // valid in stage 0 1 2 3
    PS_TEXTUREMODES_NONE=                 0x00L, // * * * *
    PS_TEXTUREMODES_PROJECT2D=            0x01L, // * * * *
    PS_TEXTUREMODES_PROJECT3D=            0x02L, // * * * *
    PS_TEXTUREMODES_CUBEMAP=              0x03L, // * * * *
    PS_TEXTUREMODES_PASSTHRU=             0x04L, // * * * *
    PS_TEXTUREMODES_CLIPPLANE=            0x05L, // * * * *
    PS_TEXTUREMODES_BUMPENVMAP=           0x06L, // - * * *
    PS_TEXTUREMODES_BUMPENVMAP_LUM=       0x07L, // - * * *
    PS_TEXTUREMODES_BRDF=                 0x08L, // - - * *
    PS_TEXTUREMODES_DOT_ST=               0x09L, // - - * *
    PS_TEXTUREMODES_DOT_ZW=               0x0aL, // - - * *
    PS_TEXTUREMODES_DOT_RFLCT_DIFF=       0x0bL, // - - * -
    PS_TEXTUREMODES_DOT_RFLCT_SPEC=       0x0cL, // - - - *
    PS_TEXTUREMODES_DOT_STR_3D=           0x0dL, // - - - *
    PS_TEXTUREMODES_DOT_STR_CUBE=         0x0eL, // - - - *
    PS_TEXTUREMODES_DPNDNT_AR=            0x0fL, // - * * *
    PS_TEXTUREMODES_DPNDNT_GB=            0x10L, // - * * *
    PS_TEXTUREMODES_DOTPRODUCT=           0x11L, // - * * -
    PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST= 0x12L, // - - - *
    // 0x13-0x1f reserved
};


// =========================================================================================================
// PSDotMapping
// --------.--------.--------.-----xxx // stage1
// --------.--------.--------.-xxx---- // stage2
// --------.--------.-----xxx.-------- // stage3

#define PS_DOTMAPPING(t0,t1,t2,t3) (((t3)<<8)|((t2)<<4)|(t1))

// Mappings:
// ZERO_TO_ONE         :rgb->(r,g,b): 0x0=>0.0, 0xff=>1.0
// MINUS1_TO_1_D3D     :rgb->(r,g,b): 0x0=>-128/127, 0x01=>-1.0, 0x80=>0.0, 0xff=>1.0
// MINUS1_TO_1_GL      :rgb->(r,g,b): 0x80=>-1.0, 0x7f=>1.0
// MINUS1_TO_1         :rgb->(r,g,b): 0x80=>-128/127, 0x81=>-1.0, 0x0=>0.0, 0x7f=>1.0
// HILO_1              :HL->(H,L,1.0): 0x0000=>0.0, 0xffff=>1.0
// HILO_HEMISPHERE_D3D :HL->(H,L,sqrt(1-H*H-L*L)): 0x8000=>-1.0, 0x0=>0.0, 0x7fff=32767/32768
// HILO_HEMISPHERE_GL  :HL->(H,L,sqrt(1-H*H-L*L)): 0x8000=>-1.0, 0x7fff=>1.0
// HILO_HEMISPHERE     :HL->(H,L,sqrt(1-H*H-L*L)): 0x8001=>-1.0, 0x0=>0.0, 0x7fff=>1.0, 0x8000=>-32768/32767

enum PS_DOTMAPPING
{                              // valid in stage 0 1 2 3
    PS_DOTMAPPING_ZERO_TO_ONE=         0x00L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1_D3D=     0x01L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1_GL=      0x02L, // - * * *
    PS_DOTMAPPING_MINUS1_TO_1=         0x03L, // - * * *
    PS_DOTMAPPING_HILO_1=              0x04L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE_D3D= 0x05L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE_GL=  0x06L, // - * * *
    PS_DOTMAPPING_HILO_HEMISPHERE=     0x07L, // - * * *
};

// =========================================================================================================
// PSCompareMode
// --------.--------.--------.----xxxx // stage0
// --------.--------.--------.xxxx---- // stage1
// --------.--------.----xxxx.-------- // stage2
// --------.--------.xxxx----.-------- // stage3

#define PS_COMPAREMODE(t0,t1,t2,t3) (((t3)<<12)|((t2)<<8)|((t1)<<4)|(t0))

enum PS_COMPAREMODE
{
    PS_COMPAREMODE_S_LT= 0x00L,
    PS_COMPAREMODE_S_GE= 0x01L,
    
    PS_COMPAREMODE_T_LT= 0x00L,
    PS_COMPAREMODE_T_GE= 0x02L,
    
    PS_COMPAREMODE_R_LT= 0x00L,
    PS_COMPAREMODE_R_GE= 0x04L,
    
    PS_COMPAREMODE_Q_LT= 0x00L,
    PS_COMPAREMODE_Q_GE= 0x08L,
};

// =========================================================================================================
// PSInputTexture
// --------.-------x.--------.-------- // stage2
// --------.--xx----.--------.-------- // stage3
//
// Selects the other texture to use as an input in the following texture modes:
// DOT_ST, DOT_STR_3D, DOT_STR_CUBE, DOT_ZW, DOT_RFLCT_SPEC, 
// DOT_RFLCT_DIFF, DPNDNT_AR, DPNDNT_GB, BUMPENVMAP,
// BUMPENVMAP_LUM, DOT_PRODUCT

#define PS_INPUTTEXTURE(t0,t1,t2,t3) (((t3)<<20)|((t2)<<16))


/*---------------------------------------------------------------------------------*/
/*  Color combiners - The following members of the D3DPixelShaderDef structure     */
/*  define the state for the eight stages of color combiners:                      */
/*      PSCombinerCount - Number of stages                                         */
/*      PSAlphaInputs[8] - Inputs for alpha portion of each stage                  */
/*      PSRGBInputs[8] - Inputs for RGB portion of each stage                      */
/*      PSConstant0[8] - Constant 0 for each stage                                 */
/*      PSConstant1[8] - Constant 1 for each stage                                 */
/*      PSFinalCombinerConstant0 - Constant 0 for final combiner                   */
/*      PSFinalCombinerConstant1 - Constant 1 for final combiner                   */
/*      PSAlphaOutputs[8] - Outputs for alpha portion of each stage                */
/*      PSRGBOutputs[8] - Outputs for RGB portion of each stage                    */
/*---------------------------------------------------------------------------------*/


// =========================================================================================================
// PSCombinerCount
// --------.--------.--------.----xxxx // number of combiners (1-8)
// --------.--------.-------x.-------- // mux bit (0= LSB, 1= MSB)
// --------.--------.---x----.-------- // separate C0
// --------.-------x.--------.-------- // separate C1

#define PS_COMBINERCOUNT(count, flags) (((flags)<<8)|(count))
// count is 1-8, flags contains one or more values from PS_COMBINERCOUNTFLAGS

enum PS_COMBINERCOUNTFLAGS
{
    PS_COMBINERCOUNT_MUX_LSB=     0x0000L, // mux on r0.a lsb
    PS_COMBINERCOUNT_MUX_MSB=     0x0001L, // mux on r0.a msb
    
    PS_COMBINERCOUNT_SAME_C0=     0x0000L, // c0 same in each stage
    PS_COMBINERCOUNT_UNIQUE_C0=   0x0010L, // c0 unique in each stage
    
    PS_COMBINERCOUNT_SAME_C1=     0x0000L, // c1 same in each stage
    PS_COMBINERCOUNT_UNIQUE_C1=   0x0100L  // c1 unique in each stage
};


// =========================================================================================================
// PSRGBInputs[0-7]
// PSAlphaInputs[0-7]
// PSFinalCombinerInputsABCD
// PSFinalCombinerInputsEFG
// --------.--------.--------.----xxxx // D register
// --------.--------.--------.---x---- // D channel (0= RGB/BLUE, 1= ALPHA)
// --------.--------.--------.xxx----- // D input mapping
// --------.--------.----xxxx.-------- // C register
// --------.--------.---x----.-------- // C channel (0= RGB/BLUE, 1= ALPHA)
// --------.--------.xxx-----.-------- // C input mapping
// --------.----xxxx.--------.-------- // B register
// --------.---x----.--------.-------- // B channel (0= RGB/BLUE, 1= ALPHA)
// --------.xxx-----.--------.-------- // B input mapping
// ----xxxx.--------.--------.-------- // A register
// ---x----.--------.--------.-------- // A channel (0= RGB/BLUE, 1= ALPHA)
// xxx-----.--------.--------.-------- // A input mapping

// examples:
// 
// shader.PSRGBInputs[3]= PS_COMBINERINPUTS(
//     PS_REGISTER_T0 | PS_INPUTMAPPING_EXPAND_NORMAL     | PS_CHANNEL_RGB,
//     PS_REGISTER_C0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
//     PS_REGISTER_ZERO,
//     PS_REGISTER_ZERO);
// 
// shader.PSFinalCombinerInputsABCD= PS_COMBINERINPUTS(
//     PS_REGISTER_T0     | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
//     PS_REGISTER_ZERO   | PS_INPUTMAPPING_EXPAND_NORMAL     | PS_CHANNEL_RGB,
//     PS_REGISTER_EFPROD | PS_INPUTMAPPING_UNSIGNED_INVERT   | PS_CHANNEL_RGB,
//     PS_REGISTER_ZERO);
//
// PS_FINALCOMBINERSETTING is set in 4th field of PSFinalCombinerInputsEFG with PS_COMBINERINPUTS
// example:
// 
// shader.PSFinalCombinerInputsEFG= PS_COMBINERINPUTS(
//     PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
//     PS_REGISTER_R1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
//     PS_REGISTER_R1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_BLUE,
//    PS_FINALCOMBINERSETTING_CLAMP_SUM | PS_FINALCOMBINERSETTING_COMPLEMENT_R0);

#define PS_COMBINERINPUTS(a,b,c,d) (((a)<<24)|((b)<<16)|((c)<<8)|(d))
// For PSFinalCombinerInputsEFG,
//     a,b,c contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING for input E,F, and G
//     d contains values from PS_FINALCOMBINERSETTING
// For all other inputs,
//     a,b,c,d each contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING

enum PS_INPUTMAPPING
{
    PS_INPUTMAPPING_UNSIGNED_IDENTITY= 0x00L, // max(0,x)         OK for final combiner
    PS_INPUTMAPPING_UNSIGNED_INVERT=   0x20L, // 1 - max(0,x)     OK for final combiner
    PS_INPUTMAPPING_EXPAND_NORMAL=     0x40L, // 2*max(0,x) - 1   invalid for final combiner
    PS_INPUTMAPPING_EXPAND_NEGATE=     0x60L, // 1 - 2*max(0,x)   invalid for final combiner
    PS_INPUTMAPPING_HALFBIAS_NORMAL=   0x80L, // max(0,x) - 1/2   invalid for final combiner
    PS_INPUTMAPPING_HALFBIAS_NEGATE=   0xa0L, // 1/2 - max(0,x)   invalid for final combiner
    PS_INPUTMAPPING_SIGNED_IDENTITY=   0xc0L, // x                invalid for final combiner
    PS_INPUTMAPPING_SIGNED_NEGATE=     0xe0L, // -x               invalid for final combiner
};

enum PS_REGISTER
{
    PS_REGISTER_ZERO=              0x00L, // r    
    PS_REGISTER_DISCARD=           0x00L, // w
    PS_REGISTER_C0=                0x01L, // r
    PS_REGISTER_C1=                0x02L, // r
    PS_REGISTER_FOG=               0x03L, // r
    PS_REGISTER_V0=                0x04L, // r/w  
    PS_REGISTER_V1=                0x05L, // r/w
    PS_REGISTER_T0=                0x08L, // r/w
    PS_REGISTER_T1=                0x09L, // r/w
    PS_REGISTER_T2=                0x0aL, // r/w
    PS_REGISTER_T3=                0x0bL, // r/w
    PS_REGISTER_R0=                0x0cL, // r/w
    PS_REGISTER_R1=                0x0dL, // r/w
    PS_REGISTER_V1R0_SUM=          0x0eL, // r
    PS_REGISTER_EF_PROD=           0x0fL, // r
    
    PS_REGISTER_ONE=               PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT, // OK for final combiner
    PS_REGISTER_NEGATIVE_ONE=      PS_REGISTER_ZERO | PS_INPUTMAPPING_EXPAND_NORMAL,   // invalid for final combiner
    PS_REGISTER_ONE_HALF=          PS_REGISTER_ZERO | PS_INPUTMAPPING_HALFBIAS_NEGATE, // invalid for final combiner
    PS_REGISTER_NEGATIVE_ONE_HALF= PS_REGISTER_ZERO | PS_INPUTMAPPING_HALFBIAS_NORMAL, // invalid for final combiner
};

// FOG ALPHA is only available in final combiner
// V1R0_SUM and EF_PROD are only available in final combiner (A,B,C,D inputs only)
// V1R0_SUM_ALPHA and EF_PROD_ALPHA are not available
// R0_ALPHA is initialized to T0_ALPHA in stage0

enum PS_CHANNEL
{
    PS_CHANNEL_RGB=   0x00, // used as RGB source
    PS_CHANNEL_BLUE=  0x00, // used as ALPHA source
    PS_CHANNEL_ALPHA= 0x10, // used as RGB or ALPHA source
};


enum PS_FINALCOMBINERSETTING
{
    PS_FINALCOMBINERSETTING_CLAMP_SUM=     0x80, // V1+R0 sum clamped to [0,1]
    
    PS_FINALCOMBINERSETTING_COMPLEMENT_V1= 0x40, // unsigned invert mapping
    
    PS_FINALCOMBINERSETTING_COMPLEMENT_R0= 0x20, // unsigned invert mapping
};

// =========================================================================================================
// PSRGBOutputs[0-7]
// PSAlphaOutputs[0-7]
// --------.--------.--------.----xxxx // CD register
// --------.--------.--------.xxxx---- // AB register
// --------.--------.----xxxx.-------- // SUM register
// --------.--------.---x----.-------- // CD output (0= multiply, 1= dot product)
// --------.--------.--x-----.-------- // AB output (0= multiply, 1= dot product)
// --------.--------.-x------.-------- // AB_CD mux/sum select (0= sum, 1= mux)
// --------.------xx.x-------.-------- // Output mapping
// --------.-----x--.--------.-------- // CD blue to alpha
// --------.----x---.--------.-------- // AB blue to alpha

#define PS_COMBINEROUTPUTS(ab,cd,mux_sum,flags) (((flags)<<12)|((mux_sum)<<8)|((ab)<<4)|(cd))
// ab,cd,mux_sum contain a value from PS_REGISTER
// flags contains values from PS_COMBINEROUTPUT

enum PS_COMBINEROUTPUT
{
    PS_COMBINEROUTPUT_IDENTITY=            0x00L, // y = x        
    PS_COMBINEROUTPUT_BIAS=                0x08L, // y = x - 0.5  
    PS_COMBINEROUTPUT_SHIFTLEFT_1=         0x10L, // y = x*2      
    PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS=    0x18L, // y = (x - 0.5)*2
    PS_COMBINEROUTPUT_SHIFTLEFT_2=         0x20L, // y = x*4      
    PS_COMBINEROUTPUT_SHIFTRIGHT_1=        0x30L, // y = x/2      
    
    PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA=    0x80L, // RGB only
    
    PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA=    0x40L, // RGB only
    
    PS_COMBINEROUTPUT_AB_MULTIPLY=         0x00L,
    PS_COMBINEROUTPUT_AB_DOT_PRODUCT=      0x02L, // RGB only
    
    PS_COMBINEROUTPUT_CD_MULTIPLY=         0x00L,
    PS_COMBINEROUTPUT_CD_DOT_PRODUCT=      0x01L, // RGB only
    
    PS_COMBINEROUTPUT_AB_CD_SUM=           0x00L, // 3rd output is AB+CD
    PS_COMBINEROUTPUT_AB_CD_MUX=           0x04L, // 3rd output is MUX(AB,CD) based on R0.a
};

// AB_CD register output must be DISCARD if either AB_DOT_PRODUCT or CD_DOT_PRODUCT are set

// =========================================================================================================
// PSC0Mapping
// PSC1Mapping
// --------.--------.--------.----xxxx // offset of D3D constant for stage 0
// --------.--------.--------.xxxx---- // offset of D3D constant for stage 1
// --------.--------.----xxxx.-------- // offset of D3D constant for stage 2
// --------.--------.xxxx----.-------- // offset of D3D constant for stage 3
// --------.----xxxx.--------.-------- // offset of D3D constant for stage 4
// --------.xxxx----.--------.-------- // offset of D3D constant for stage 5
// ----xxxx.--------.--------.-------- // offset of D3D constant for stage 6
// xxxx----.--------.--------.-------- // offset of D3D constant for stage 7

#define PS_CONSTANTMAPPING(s0,s1,s2,s3,s4,s5,s6,s7) \
     (((DWORD)(s0)&0xf)<< 0) | (((DWORD)(s1)&0xf)<< 4) | \
     (((DWORD)(s2)&0xf)<< 8) | (((DWORD)(s3)&0xf)<<12) | \
     (((DWORD)(s4)&0xf)<<16) | (((DWORD)(s5)&0xf)<<20) | \
     (((DWORD)(s6)&0xf)<<24) | (((DWORD)(s7)&0xf)<<28) 
// s0-s7 contain the offset of the D3D constant that corresponds to the 
// c0 or c1 constant in stages 0 through 7.  These mappings are only used in 
// SetPixelShaderConstant().
   
// =========================================================================================================
// PSFinalCombinerConstants
// --------.--------.--------.----xxxx // offset of D3D constant for C0
// --------.--------.--------.xxxx---- // offset of D3D constant for C1
// --------.--------.-------x.-------- // Adjust texture flag

#define PS_FINALCOMBINERCONSTANTS(c0,c1,flags) (((DWORD)(flags) << 8) | ((DWORD)(c0)&0xf)<< 0) | (((DWORD)(c1)&0xf)<< 4)
// c0 and c1 contain the offset of the D3D constant that corresponds to the
// constants in the final combiner.  These mappings are only used in 
// SetPixelShaderConstant().  Flags contains values from PS_GLOBALFLAGS

enum PS_GLOBALFLAGS
{
    // if this flag is set, the texture mode for each texture stage is adjusted as follows:
    //     if set texture is a cubemap, 
    //         change PS_TEXTUREMODES_PROJECT2D to PS_TEXTUREMODES_CUBEMAP
    //         change PS_TEXTUREMODES_PROJECT3D to PS_TEXTUREMODES_CUBEMAP
    //         change PS_TEXTUREMODES_DOT_STR_3D to PS_TEXTUREMODES_DOT_STR_CUBE
    //     if set texture is a volume texture, 
    //         change PS_TEXTUREMODES_PROJECT2D to PS_TEXTUREMODES_PROJECT3D
    //         change PS_TEXTUREMODES_CUBEMAP to PS_TEXTUREMODES_PROJECT3D
    //         change PS_TEXTUREMODES_DOT_STR_CUBE to PS_TEXTUREMODES_DOT_STR_3D
    //     if set texture is neither cubemap or volume texture, 
    //         change PS_TEXTUREMODES_PROJECT3D to PS_TEXTUREMODES_PROJECT2D
    //         change PS_TEXTUREMODES_CUBEMAP to PS_TEXTUREMODES_PROJECT2D

    PS_GLOBALFLAGS_NO_TEXMODE_ADJUST=     0x0000L, // don't adjust texture modes
    PS_GLOBALFLAGS_TEXMODE_ADJUST=        0x0001L, // adjust texture modes according to set texture
};

   
typedef struct _D3DPixelShaderDefFile
{
    DWORD               FileID;         // Uniquely identifies the file as pixel shader binary
    D3DPIXELSHADERDEF   Psd;            // The pixel shader def structure
} D3DPIXELSHADERDEF_FILE;

#define D3DPIXELSHADERDEF_FILE_ID   0x30425350  // "PSB0"

/*----------------------- End of Pixel Shader Defines -----------------------*/

#pragma pack()
#pragma warning(default:4201)

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8TYPES(P)_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3dx8math.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8math.h
//  Content:    D3DX math types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __XGMATH_H__

#ifndef __D3DX8MATH_H__
#define __D3DX8MATH_H__

#ifdef __cplusplus
extern "C++" {
#endif // __cplusplus

#include <math.h>

#pragma warning(disable:4201) // anonymous unions warning



typedef struct ID3DXMatrixStack *LPD3DXMATRIXSTACK;

// {E3357330-CC5E-11d2-A434-00A0C90629A8}
DEFINE_GUID( IID_ID3DXMatrixStack,
0xe3357330, 0xcc5e, 0x11d2, 0xa4, 0x34, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);


//===========================================================================
//
// General purpose utilities
//
//===========================================================================
#define D3DX_PI    ((FLOAT)  3.141592654f)
#define D3DX_1BYPI ((FLOAT)  0.318309886f)

#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))



//===========================================================================
//
// Vectors
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------
typedef struct D3DXVECTOR2
{
#ifdef __cplusplus
public:
    D3DXVECTOR2() {};
    D3DXVECTOR2( CONST FLOAT * );
    D3DXVECTOR2( FLOAT x, FLOAT y );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR2& operator += ( CONST D3DXVECTOR2& );
    D3DXVECTOR2& operator -= ( CONST D3DXVECTOR2& );
    D3DXVECTOR2& operator *= ( FLOAT );
    D3DXVECTOR2& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR2 operator + () const;
    D3DXVECTOR2 operator - () const;

    // binary operators
    D3DXVECTOR2 operator + ( CONST D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator - ( CONST D3DXVECTOR2& ) const;
    D3DXVECTOR2 operator * ( FLOAT ) const;
    D3DXVECTOR2 operator / ( FLOAT ) const;

    friend D3DXVECTOR2 operator * ( FLOAT, CONST D3DXVECTOR2& );

    BOOL operator == ( CONST D3DXVECTOR2& ) const;
    BOOL operator != ( CONST D3DXVECTOR2& ) const;


public:
#endif //__cplusplus
    FLOAT x, y;
} D3DXVECTOR2, *LPD3DXVECTOR2;


//--------------------------
// 3D Vector
//--------------------------
#ifdef __cplusplus
typedef struct D3DXVECTOR3 : public D3DVECTOR
{
public:
    D3DXVECTOR3() {};
    D3DXVECTOR3( CONST FLOAT * );
    D3DXVECTOR3( CONST D3DVECTOR& );
    D3DXVECTOR3( FLOAT x, FLOAT y, FLOAT z );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR3& operator += ( CONST D3DXVECTOR3& );
    D3DXVECTOR3& operator -= ( CONST D3DXVECTOR3& );
    D3DXVECTOR3& operator *= ( FLOAT );
    D3DXVECTOR3& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR3 operator + () const;
    D3DXVECTOR3 operator - () const;

    // binary operators
    D3DXVECTOR3 operator + ( CONST D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator - ( CONST D3DXVECTOR3& ) const;
    D3DXVECTOR3 operator * ( FLOAT ) const;
    D3DXVECTOR3 operator / ( FLOAT ) const;

    friend D3DXVECTOR3 operator * ( FLOAT, CONST struct D3DXVECTOR3& );

    BOOL operator == ( CONST D3DXVECTOR3& ) const;
    BOOL operator != ( CONST D3DXVECTOR3& ) const;

} D3DXVECTOR3, *LPD3DXVECTOR3;

#else //!__cplusplus
typedef struct _D3DVECTOR D3DXVECTOR3, *LPD3DXVECTOR3;
#endif //!__cplusplus


//--------------------------
// 4D Vector
//--------------------------
typedef struct D3DXVECTOR4
{
#ifdef __cplusplus
public:
    D3DXVECTOR4() {};
    D3DXVECTOR4( CONST FLOAT* );
    D3DXVECTOR4( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXVECTOR4& operator += ( CONST D3DXVECTOR4& );
    D3DXVECTOR4& operator -= ( CONST D3DXVECTOR4& );
    D3DXVECTOR4& operator *= ( FLOAT );
    D3DXVECTOR4& operator /= ( FLOAT );

    // unary operators
    D3DXVECTOR4 operator + () const;
    D3DXVECTOR4 operator - () const;

    // binary operators
    D3DXVECTOR4 operator + ( CONST D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator - ( CONST D3DXVECTOR4& ) const;
    D3DXVECTOR4 operator * ( FLOAT ) const;
    D3DXVECTOR4 operator / ( FLOAT ) const;

    friend D3DXVECTOR4 operator * ( FLOAT, CONST D3DXVECTOR4& );

    BOOL operator == ( CONST D3DXVECTOR4& ) const;
    BOOL operator != ( CONST D3DXVECTOR4& ) const;

public:
#endif //__cplusplus
    FLOAT x, y, z, w;
} D3DXVECTOR4, *LPD3DXVECTOR4;


//===========================================================================
//
// Matrices
//
//===========================================================================
#ifdef __cplusplus
typedef struct D3DXMATRIX : public D3DMATRIX
{
public:
    D3DXMATRIX() {};
    D3DXMATRIX( CONST FLOAT * );
    D3DXMATRIX( CONST D3DMATRIX& );
    D3DXMATRIX( FLOAT _11, FLOAT _12, FLOAT _13, FLOAT _14,
                FLOAT _21, FLOAT _22, FLOAT _23, FLOAT _24,
                FLOAT _31, FLOAT _32, FLOAT _33, FLOAT _34,
                FLOAT _41, FLOAT _42, FLOAT _43, FLOAT _44 );


    // access grants
    FLOAT& operator () ( UINT Row, UINT Col );
    FLOAT  operator () ( UINT Row, UINT Col ) const;

    // casting operators
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXMATRIX& operator *= ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator += ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator -= ( CONST D3DXMATRIX& );
    D3DXMATRIX& operator *= ( FLOAT );
    D3DXMATRIX& operator /= ( FLOAT );

    // unary operators
    D3DXMATRIX operator + () const;
    D3DXMATRIX operator - () const;

    // binary operators
    D3DXMATRIX operator * ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator + ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator - ( CONST D3DXMATRIX& ) const;
    D3DXMATRIX operator * ( FLOAT ) const;
    D3DXMATRIX operator / ( FLOAT ) const;

    friend D3DXMATRIX operator * ( FLOAT, CONST D3DXMATRIX& );

    BOOL operator == ( CONST D3DXMATRIX& ) const;
    BOOL operator != ( CONST D3DXMATRIX& ) const;

} D3DXMATRIX, *LPD3DXMATRIX;

#else //!__cplusplus
typedef struct _D3DMATRIX D3DXMATRIX, *LPD3DXMATRIX;
#endif //!__cplusplus


//===========================================================================
//
//    Quaternions
//
//===========================================================================
typedef struct D3DXQUATERNION
{
#ifdef __cplusplus
public:
    D3DXQUATERNION() {}
    D3DXQUATERNION( CONST FLOAT * );
    D3DXQUATERNION( FLOAT x, FLOAT y, FLOAT z, FLOAT w );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // assignment operators
    D3DXQUATERNION& operator += ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator -= ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( CONST D3DXQUATERNION& );
    D3DXQUATERNION& operator *= ( FLOAT );
    D3DXQUATERNION& operator /= ( FLOAT );

    // unary operators
    D3DXQUATERNION  operator + () const;
    D3DXQUATERNION  operator - () const;

    // binary operators
    D3DXQUATERNION operator + ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator - ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( CONST D3DXQUATERNION& ) const;
    D3DXQUATERNION operator * ( FLOAT ) const;
    D3DXQUATERNION operator / ( FLOAT ) const;

    friend D3DXQUATERNION operator * (FLOAT, CONST D3DXQUATERNION& );

    BOOL operator == ( CONST D3DXQUATERNION& ) const;
    BOOL operator != ( CONST D3DXQUATERNION& ) const;

#endif //__cplusplus
    FLOAT x, y, z, w;
} D3DXQUATERNION, *LPD3DXQUATERNION;


//===========================================================================
//
// Planes
//
//===========================================================================
typedef struct D3DXPLANE
{
#ifdef __cplusplus
public:
    D3DXPLANE() {}
    D3DXPLANE( CONST FLOAT* );
    D3DXPLANE( FLOAT a, FLOAT b, FLOAT c, FLOAT d );

    // casting
    operator FLOAT* ();
    operator CONST FLOAT* () const;

    // unary operators
    D3DXPLANE operator + () const;
    D3DXPLANE operator - () const;

    // binary operators
    BOOL operator == ( CONST D3DXPLANE& ) const;
    BOOL operator != ( CONST D3DXPLANE& ) const;

#endif //__cplusplus
    FLOAT a, b, c, d;
} D3DXPLANE, *LPD3DXPLANE;


//===========================================================================
//
// Colors
//
//===========================================================================

typedef struct D3DXCOLOR
{
#ifdef __cplusplus
public:
    D3DXCOLOR() {}
    D3DXCOLOR( DWORD argb );
    D3DXCOLOR( CONST FLOAT * );
    D3DXCOLOR( CONST D3DCOLORVALUE& );
    D3DXCOLOR( FLOAT r, FLOAT g, FLOAT b, FLOAT a );

    // casting
    operator DWORD () const;

    operator FLOAT* ();
    operator CONST FLOAT* () const;

    operator D3DCOLORVALUE* ();
    operator CONST D3DCOLORVALUE* () const;

    operator D3DCOLORVALUE& ();
    operator CONST D3DCOLORVALUE& () const;

    // assignment operators
    D3DXCOLOR& operator += ( CONST D3DXCOLOR& );
    D3DXCOLOR& operator -= ( CONST D3DXCOLOR& );
    D3DXCOLOR& operator *= ( FLOAT );
    D3DXCOLOR& operator /= ( FLOAT );

    // unary operators
    D3DXCOLOR operator + () const;
    D3DXCOLOR operator - () const;

    // binary operators
    D3DXCOLOR operator + ( CONST D3DXCOLOR& ) const;
    D3DXCOLOR operator - ( CONST D3DXCOLOR& ) const;
    D3DXCOLOR operator * ( FLOAT ) const;
    D3DXCOLOR operator / ( FLOAT ) const;

    friend D3DXCOLOR operator * (FLOAT, CONST D3DXCOLOR& );

    BOOL operator == ( CONST D3DXCOLOR& ) const;
    BOOL operator != ( CONST D3DXCOLOR& ) const;

#endif //__cplusplus
    FLOAT r, g, b, a;
} D3DXCOLOR, *LPD3DXCOLOR;



//===========================================================================
//
// D3DX math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

FLOAT D3DXVec2Length
    ( CONST D3DXVECTOR2 *pV );

FLOAT D3DXVec2LengthSq
    ( CONST D3DXVECTOR2 *pV );

FLOAT D3DXVec2Dot
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
FLOAT D3DXVec2CCW
    ( CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Add
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
D3DXVECTOR2* D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
D3DXVECTOR2* D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, FLOAT s );

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR2* D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR2* WINAPI D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR2* WINAPI D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pT1,
      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR2* WINAPI D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV0, CONST D3DXVECTOR2 *pV1,
      CONST D3DXVECTOR2 *pV2, CONST D3DXVECTOR2 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV1, CONST D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, 0, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, CONST D3DXVECTOR2 *pV, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

FLOAT D3DXVec3Length
    ( CONST D3DXVECTOR3 *pV );

FLOAT D3DXVec3LengthSq
    ( CONST D3DXVECTOR3 *pV );

FLOAT D3DXVec3Dot
    ( CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Add
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR3* D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR3* D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR3* D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR3* WINAPI D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR3* WINAPI D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pT1,
      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR3* WINAPI D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV0, CONST D3DXVECTOR3 *pV1,
      CONST D3DXVECTOR3 *pV2, CONST D3DXVECTOR3 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      CONST D3DXVECTOR3 *pV3, FLOAT f, FLOAT g);

// Transform (x, y, z, 1) by matrix.
D3DXVECTOR4* WINAPI D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Transform (x, y, z, 0) by matrix.  If you transforming a normal by a
// non-affine matrix, the matrix you pass to this function should be the
// transpose of the inverse of the matrix you would use to transform a coord.
D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DXMATRIX *pM );

// Project vector from object space into screen space
D3DXVECTOR3* WINAPI D3DXVec3Project
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);

// Project vector from screen space into object space
D3DXVECTOR3* WINAPI D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, CONST D3DVIEWPORT8 *pViewport,
      CONST D3DXMATRIX *pProjection, CONST D3DXMATRIX *pView, CONST D3DXMATRIX *pWorld);

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

FLOAT D3DXVec4Length
    ( CONST D3DXVECTOR4 *pV );

FLOAT D3DXVec4LengthSq
    ( CONST D3DXVECTOR4 *pV );

FLOAT D3DXVec4Dot
    ( CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2 );

D3DXVECTOR4* D3DXVec4Add
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR4* D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR4* D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, FLOAT s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR4* D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      FLOAT s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
D3DXVECTOR4* WINAPI D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      CONST D3DXVECTOR4 *pV3);

D3DXVECTOR4* WINAPI D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR4* WINAPI D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pT1,
      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pT2, FLOAT s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR4* WINAPI D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV0, CONST D3DXVECTOR4 *pV1,
      CONST D3DXVECTOR4 *pV2, CONST D3DXVECTOR4 *pV3, FLOAT s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV1, CONST D3DXVECTOR4 *pV2,
      CONST D3DXVECTOR4 *pV3, FLOAT f, FLOAT g);

// Transform vector by matrix.
D3DXVECTOR4* WINAPI D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, CONST D3DXVECTOR4 *pV, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

D3DXMATRIX* D3DXMatrixIdentity
    ( D3DXMATRIX *pOut );

BOOL D3DXMatrixIsIdentity
    ( CONST D3DXMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

FLOAT WINAPI D3DXMatrixfDeterminant
    ( CONST D3DXMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2
// followed by the transformation M1.  (Out = M1 * M2)
D3DXMATRIX* WINAPI D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM1, CONST D3DXMATRIX *pM2 );

D3DXMATRIX* WINAPI D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, CONST D3DXMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
D3DXMATRIX* WINAPI D3DXMatrixInverse
    ( D3DXMATRIX *pOut, FLOAT *pDeterminant, CONST D3DXMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
D3DXMATRIX* WINAPI D3DXMatrixScaling
    ( D3DXMATRIX *pOut, FLOAT sx, FLOAT sy, FLOAT sz );

// Build a matrix which translates by (x, y, z)
D3DXMATRIX* WINAPI D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, FLOAT x, FLOAT y, FLOAT z );

// Build a matrix which rotates around the X axis
D3DXMATRIX* WINAPI D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Y axis
D3DXMATRIX* WINAPI D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around the Z axis
D3DXMATRIX* WINAPI D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, FLOAT Angle );

// Build a matrix which rotates around an arbitrary axis
D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );

// Build a matrix from a quaternion
D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, CONST D3DXQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );


// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pScalingCenter,
      CONST D3DXQUATERNION *pScalingRotation, CONST D3DXVECTOR3 *pScaling,
      CONST D3DXVECTOR3 *pRotationCenter, CONST D3DXQUATERNION *pRotation,
      CONST D3DXVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, FLOAT Scaling, CONST D3DXVECTOR3 *pRotationCenter,
      CONST D3DXQUATERNION *pRotation, CONST D3DXVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
      CONST D3DXVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR3 *pEye, CONST D3DXVECTOR3 *pAt,
      CONST D3DXVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, FLOAT fovy, FLOAT Aspect, FLOAT zn, FLOAT zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, FLOAT w, FLOAT h, FLOAT zn, FLOAT zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, FLOAT l, FLOAT r, FLOAT b, FLOAT t, FLOAT zn,
      FLOAT zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
D3DXMATRIX* WINAPI D3DXMatrixShadow
    ( D3DXMATRIX *pOut, CONST D3DXVECTOR4 *pLight,
      CONST D3DXPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
D3DXMATRIX* WINAPI D3DXMatrixReflect
    ( D3DXMATRIX *pOut, CONST D3DXPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

FLOAT D3DXQuaternionLength
    ( CONST D3DXQUATERNION *pQ );

// Length squared, or "norm"
FLOAT D3DXQuaternionLengthSq
    ( CONST D3DXQUATERNION *pQ );

FLOAT D3DXQuaternionDot
    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 );

// (0, 0, 0, 1)
D3DXQUATERNION* D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut );

BOOL D3DXQuaternionIsIdentity
    ( CONST D3DXQUATERNION *pQ );

// (-x, -y, -z, w)
D3DXQUATERNION* D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI D3DXQuaternionToAxisAngle
    ( CONST D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, FLOAT *pAngle );

// Build a quaternion from a rotation matrix.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, CONST D3DXMATRIX *pM);

// Rotation about arbitrary axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, CONST D3DXVECTOR3 *pV, FLOAT Angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, FLOAT Yaw, FLOAT Pitch, FLOAT Roll );

// Quaternion multiplication.  The result represents the rotation Q2
// followed by the rotation Q1.  (Out = Q2 * Q1)
D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2 );

D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Conjugate and re-norm
D3DXQUATERNION* WINAPI D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
D3DXQUATERNION* WINAPI D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
D3DXQUATERNION* WINAPI D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, FLOAT t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
D3DXQUATERNION* WINAPI D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
      CONST D3DXQUATERNION *pQ4, FLOAT t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, CONST D3DXQUATERNION *pQ1,
      CONST D3DXQUATERNION *pQ2, CONST D3DXQUATERNION *pQ3,
      FLOAT f, FLOAT g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
FLOAT D3DXPlaneDot
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR4 *pV);

// ax + by + cz + d
FLOAT D3DXPlaneDotCoord
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);

// ax + by + cz
FLOAT D3DXPlaneDotNormal
    ( CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
D3DXPLANE* WINAPI D3DXPlaneNormalize
    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, CONST D3DXPLANE *pP, CONST D3DXVECTOR3 *pV1,
      CONST D3DXVECTOR3 *pV2);

// Construct a plane from a point and a normal
D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pPoint, CONST D3DXVECTOR3 *pNormal);

// Construct a plane from 3 points
D3DXPLANE* WINAPI D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, CONST D3DXVECTOR3 *pV1, CONST D3DXVECTOR3 *pV2,
      CONST D3DXVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
D3DXPLANE* WINAPI D3DXPlaneTransform
    ( D3DXPLANE *pOut, CONST D3DXPLANE *pP, CONST D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
D3DXCOLOR* D3DXColorNegative
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC);

D3DXCOLOR* D3DXColorAdd
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorSubtract
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

D3DXCOLOR* D3DXColorScale
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
D3DXCOLOR* D3DXColorModulate
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
D3DXCOLOR* D3DXColorLerp
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC1, CONST D3DXCOLOR *pC2, FLOAT s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
D3DXCOLOR* WINAPI D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, CONST D3DXCOLOR *pC, FLOAT c);

#ifdef __cplusplus
}
#endif






//===========================================================================
//
//    Matrix Stack
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   ID3DXMatrixStack

DECLARE_INTERFACE_(ID3DXMatrixStack, IUnknown)
{
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    // ID3DXMatrixStack methods
    //

    // Pops the top of the stack, returns the current top
    // *after* popping the top.
    STDMETHOD(Pop)(THIS) PURE;

    // Pushes the stack by one, duplicating the current matrix.
    STDMETHOD(Push)(THIS) PURE;

    // Loads identity in the current matrix.
    STDMETHOD(LoadIdentity)(THIS) PURE;

    // Loads the given matrix into the current matrix
    STDMETHOD(LoadMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Right-Multiplies the given matrix to the current matrix.
    // (transformation is about the current world origin)
    STDMETHOD(MultMatrix)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Left-Multiplies the given matrix to the current matrix
    // (transformation is about the local origin of the object)
    STDMETHOD(MultMatrixLocal)(THIS_ CONST D3DXMATRIX* pM ) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the current world origin)
    STDMETHOD(RotateAxis)
        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix, counterclockwise about the given axis with the given angle.
    // (rotation is about the local origin of the object)
    STDMETHOD(RotateAxisLocal)
        (THIS_ CONST D3DXVECTOR3* pV, FLOAT Angle) PURE;

    // Right multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // current world origin)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRoll)
        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;

    // Left multiply the current matrix with the computed rotation
    // matrix. All angles are counterclockwise. (rotation is about the
    // local origin of the object)

    // The rotation is composed of a yaw around the Y axis, a pitch around
    // the X axis, and a roll around the Z axis.
    STDMETHOD(RotateYawPitchRollLocal)
        (THIS_ FLOAT Yaw, FLOAT Pitch, FLOAT Roll) PURE;

    // Right multiply the current matrix with the computed scale
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Scale)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Left multiply the current matrix with the computed scale
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(ScaleLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Right multiply the current matrix with the computed translation
    // matrix. (transformation is about the current world origin)
    STDMETHOD(Translate)(THIS_ FLOAT x, FLOAT y, FLOAT z ) PURE;

    // Left multiply the current matrix with the computed translation
    // matrix. (transformation is about the local origin of the object)
    STDMETHOD(TranslateLocal)(THIS_ FLOAT x, FLOAT y, FLOAT z) PURE;

    // Obtain the current matrix at the top of the stack
    STDMETHOD_(D3DXMATRIX*, GetTop)(THIS) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI D3DXCreateMatrixStack( DWORD Flags, LPD3DXMATRIXSTACK *ppStack );

#ifdef __cplusplus
}
#endif

#include "d3dx8math.inl"

#pragma warning(default:4201)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __D3DX8MATH_H__

#endif // __XGMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3dx8tex.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8tex.h
//  Content:    D3DX texturing APIs
//
///////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8TEX_H__
#define __D3DX8TEX_H__

//-------------------------------------------------------------------------
// D3DXSetDXT3DXT5
// ---------------
//
// Set premultiplied alpha format for DXT surface and texture processing.
// When set to true, DXT surfaces will be processed with nonpremultiplied
// alpha i.e. DXT3 / DXT5 format. When set to false, surfaces will be
// processed with premultiplied alpha, i.e. DXT2 / DXT4 format. The default
// is nonpremultiplied alpha - DXT3 / DXT5.
//
//-------------------------------------------------------------------------

void WINAPI D3DXSetDXT3DXT5(BOOL Set);

//-------------------------------------------------------------------------
// D3DXGetDXT3DXT5
// ---------------
//
// Get whether D3DX is currently using nonpremultiplied alpha format -
// DXT3 / DXT5 or premultiplied alpha format - DXT2 / DXT4 for DXT surface
// and texture processing.
//
//-------------------------------------------------------------------------

BOOL WINAPI D3DXGetDXT3DXT5(void);

//-------------------------------------------------------------------------
// D3DX_FILTER flags:
// ------------------
//
// A valid filter must contain one of these values:
//
//  D3DX_FILTER_NONE
//      No scaling or filtering will take place.  Pixels outside the bounds
//      of the source image are assumed to be transparent black.
//  D3DX_FILTER_POINT
//      Each destination pixel is computed by sampling the nearest pixel
//      from the source image.
//  D3DX_FILTER_LINEAR
//      Each destination pixel is computed by linearly interpolating between
//      the nearest pixels in the source image.  This filter works best
//      when the scale on each axis is less than 2.
//  D3DX_FILTER_TRIANGLE
//      Every pixel in the source image contributes equally to the
//      destination image.  This is the slowest of all the filters.
//  D3DX_FILTER_BOX
//      Each pixel is computed by averaging a 2x2(x2) box pixels from
//      the source image. Only works when the dimensions of the
//      destination are half those of the source. (as with mip maps)
//
//
// And can be OR'd with any of these optional flags:
//
//  D3DX_FILTER_MIRROR_U
//      Indicates that pixels off the edge of the texture on the U-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR_V
//      Indicates that pixels off the edge of the texture on the V-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR_W
//      Indicates that pixels off the edge of the texture on the W-axis
//      should be mirrored, not wraped.
//  D3DX_FILTER_MIRROR
//      Same as specifying D3DX_FILTER_MIRROR_U, D3DX_FILTER_MIRROR_V,
//      and D3DX_FILTER_MIRROR_V
//  D3DX_FILTER_DITHER
//      Dithers the resulting image.
//
//-------------------------------------------------------------------------

#define D3DX_FILTER_NONE      (1 << 0)
#define D3DX_FILTER_POINT     (2 << 0)
#define D3DX_FILTER_LINEAR    (3 << 0)
#define D3DX_FILTER_TRIANGLE  (4 << 0)
#define D3DX_FILTER_BOX       (5 << 0)

#define D3DX_FILTER_MIRROR_U  (1 << 16)
#define D3DX_FILTER_MIRROR_V  (2 << 16)
#define D3DX_FILTER_MIRROR_W  (4 << 16)
#define D3DX_FILTER_MIRROR    (7 << 16)
#define D3DX_FILTER_DITHER    (8 << 16)


//-------------------------------------------------------------------------
// D3DXIMAGE_INFO:
// ---------------
// This structure is used to return a rough description of what the
// the original contents of an image file looked like.
//
//  Width
//      Width of original image in pixels
//  Height
//      Height of original image in pixels
//  Depth
//      Depth of original image in pixels
//  MipLevels
//      Number of mip levels in original image
//  Format
//      D3D format which most closely describes the data in original image
//
//-------------------------------------------------------------------------


typedef struct _D3DXIMAGE_INFO
{
    UINT Width;
    UINT Height;
    UINT Depth;
    UINT MipLevels;
    D3DFORMAT Format;

} D3DXIMAGE_INFO;

#ifndef _PALETTEENTRY_DEFINED
#define _PALETTEENTRY_DEFINED

typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY, FAR *LPPALETTEENTRY;

#endif


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromFile/Resource:
// ---------------------------------
// Load surface from a file or resource
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcFile
//      File name of the source image.
//  pSrcModule
//      Module where resource is located, or NULL for module associated
//      with image the os used to create the current process.
//  pSrcResource
//      Resource name
//  pSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  pSrcRect
//      Source rectangle, or NULL for entire image
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the
//      description of the data in the source image file, or NULL.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromFileA(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCSTR                pSrcFile,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);

#define D3DXLoadSurfaceFromFile D3DXLoadSurfaceFromFileA


HRESULT WINAPI
    D3DXLoadSurfaceFromResourceA(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);

#define D3DXLoadSurfaceFromResource


HRESULT WINAPI
    D3DXLoadSurfaceFromFileInMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo);



//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromSurface:
// --------------------------
// Load surface from another surface (with color conversion)
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcSurface
//      Source surface
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcRect
//      Source rectangle, or NULL for entire surface
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromSurface(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPDIRECT3DSURFACE8    pSrcSurface,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


//-------------------------------------------------------------------------
// D3DXLoadSurfaceFromMemory:
// ------------------------
// Load surface from memory.
//
// Parameters:
//  pDestSurface
//      Destination surface, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestRect
//      Destination rectangle, or NULL for entire surface
//  pSrcMemory
//      Pointer to the top-left corner of the source image in memory
//  SrcFormat
//      Pixel format of the source image.
//  SrcPitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the width of one row of cells, in bytes.
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcRect
//      Source rectangle.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadSurfaceFromMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  SrcPitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//-------------------------------------------------------------------------
// D3DXLoadVolumeFromVolume:
// --------------------------
// Load volume from another volume (with color conversion)
//
// Parameters:
//  pDestVolume
//      Destination volume, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestBox
//      Destination box, or NULL for entire volume
//  pSrcVolume
//      Source volume
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcBox
//      Source box, or NULL for entire volume
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadVolumeFromVolume(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPDIRECT3DVOLUME8     pSrcVolume,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


//-------------------------------------------------------------------------
// D3DXLoadVolumeFromMemory:
// ------------------------
// Load volume from memory.
//
// Parameters:
//  pDestVolume
//      Destination volume, which will receive the image.
//  pDestPalette
//      Destination palette of 256 colors, or NULL
//  pDestBox
//      Destination box, or NULL for entire volume
//  pSrcMemory
//      Pointer to the top-left corner of the source volume in memory
//  SrcFormat
//      Pixel format of the source volume.
//  SrcRowPitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the size of one row of cells, in bytes.
//  SrcSlicePitch
//      Pitch of source image, in bytes.  For DXT formats, this number
//      should represent the size of one slice of cells, in bytes.
//  pSrcPalette
//      Source palette of 256 colors, or NULL
//  pSrcBox
//      Source box.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXLoadVolumeFromMemory(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  SrcRowPitch,
        UINT                  SrcSlicePitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 Filter,
        D3DCOLOR              ColorKey);


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




//-------------------------------------------------------------------------
// D3DXCheckTextureRequirements:
// -----------------------------
//
// Checks texture creation parameters.  If parameters are invalid, this
// function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pWidth
//      Desired width in pixels, or NULL.  Returns corrected width.
//  pHeight
//      Desired height in pixels, or NULL.  Returns corrected height.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  Usage
//      Texture usage flags
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//  Pool
//      Memory pool to be used to create texture
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateTexture:
// ------------------
// Create an empty texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Width
//      width in pixels; must be non-zero
//  Height
//      height in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Pixel format.
//  Pool
//      Memory pool to be used to create texture
//  ppTexture
//      The texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateTexture(
        LPDIRECT3DDEVICE8     pDevice,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        LPDIRECT3DTEXTURE8*   ppTexture);


//-------------------------------------------------------------------------
// D3DXCreateTextureFromFile:
// --------------------------
// Create a texture object from a file.
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  pSrcFile
//      File name.
//  hSrcModule
//      Module handle. if NULL, current module will be used.
//  pSrcResource
//      Resource name in module
//  pvSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  Width
//      Width in pixels; if zero or D3DX_DEFAULT, the width will be taken
//      from the file.
//  Height
//      Height in pixels; if zero of D3DX_DEFAULT, the height will be taken
//      from the file.
//  MipLevels
//      Number of mip levels;  if zero or D3DX_DEFAULT, a complete mipmap
//      chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Desired pixel format.  If D3DFMT_UNKNOWN, the format will be
//      taken from the file.
//  Pool
//      Memory pool to be used to create texture
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  MipFilter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the
//      description of the data in the source image file, or NULL.
//  pPalette
//      256 color palette to be filled in, or NULL
//  ppTexture
//      The texture object that will be created
//
//-------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCreateTextureFromFileA(
        LPDIRECT3DDEVICE8     pDevice,
        LPCSTR                pSrcFile,
        LPDIRECT3DTEXTURE8*   ppTexture);

#define D3DXCreateTextureFromFile D3DXCreateTextureFromFileA


HRESULT WINAPI
    D3DXCreateTextureFromResourceA(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        LPDIRECT3DTEXTURE8*   ppTexture);

#define D3DXCreateTextureFromResource D3DXCreateTextureFromResourceA


HRESULT WINAPI
    D3DXCreateTextureFromFileExA(
        LPDIRECT3DDEVICE8     pDevice,
        LPCSTR                pSrcFile,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);

#define D3DXCreateTextureFromFileEx D3DXCreateTextureFromFileExA


HRESULT WINAPI
    D3DXCreateTextureFromResourceExA(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);

#define D3DXCreateTextureFromResourceEx D3DXCreateTextureFromResourceExA


HRESULT WINAPI
    D3DXCreateTextureFromFileInMemory(
        LPDIRECT3DDEVICE8     pDevice,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        LPDIRECT3DTEXTURE8*   ppTexture);


HRESULT WINAPI
    D3DXCreateTextureFromFileInMemoryEx(
        LPDIRECT3DDEVICE8     pDevice,
        LPCVOID               pSrcData,
        UINT                  SrcDataSize,
        UINT                  Width,
        UINT                  Height,
        UINT                  MipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 Filter,
        DWORD                 MipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture);



//-------------------------------------------------------------------------
// D3DXFilterTexture:
// ------------------
// Filters mipmaps levels of a texture.
//
// Parameters:
//  pTexture
//      The texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL for non-palettized formats
//  SrcLevel
//      The level whose image is used to generate the subsequent levels.
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterTexture(
        LPDIRECT3DTEXTURE8    pTexture,
        CONST PALETTEENTRY*   pPalette,
        UINT                  SrcLevel,
        DWORD                 Filter);





///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////





//-------------------------------------------------------------------------
// D3DXCheckCubeTextureRequirements:
// ---------------------------------
//
// Checks cube texture creation parameters.  If parameters are invalid,
// this function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pSize
//      Desired width and height in pixels, or NULL.  Returns corrected size.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  Usage
//      Texture usage flags
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//  Pool
//      Memory pool to be used to create texture
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckCubeTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pSize,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateCubeTexture:
// ----------------------
// Create an empty cube texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Size
//      width and height in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Usage
//      Texture usage flags
//  Format
//      Pixel format.
//  Pool
//      Memory pool to be used to create texture
//  ppCubeTexture
//      The cube texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCubeTexture(
        LPDIRECT3DDEVICE8         pDevice,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


//-------------------------------------------------------------------------
// D3DXCreateCubeTextureFromFile:
// --------------------------
// Create a cube texture object from a file.
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  pSrcFile
//      File name.
//  pvSrcData
//      Pointer to file in memory.
//  SrcDataSize
//      Size in bytes of file in memory.
//  Size
//      Width and height in pixels; if zero or D3DX_DEFAULT, the size
//      will be taken from the file.
//  MipLevels
//      Number of mip levels;  if zero or D3DX_DEFAULT, a complete mipmap
//      chain will be created.
//  Format
//      Desired pixel format.  If D3DFMT_UNKNOWN, the format will be
//      taken from the file.
//  Filter
//      D3DX_FILTER flags controlling how the image is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_TRIANGLE.
//  MipFilter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//  ColorKey
//      Color to replace with transparent black, or 0 to disable colorkey.
//      This is always a 32-bit ARGB color, independent of the source image
//      format.  Alpha is significant, and should usually be set to FF for
//      opaque colorkeys.  (ex. Opaque black == 0xff000000)
//  pSrcInfo
//      Pointer to a D3DXIMAGE_INFO structure to be filled in with the
//      description of the data in the source image file, or NULL.
//  pPalette
//      256 color palette to be filled in, or NULL
//  ppCubeTexture
//      The cube texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateCubeTextureFromFileA(
        LPDIRECT3DDEVICE8         pDevice,
        LPCSTR                    pSrcFile,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);

#define D3DXCreateCubeTextureFromFile D3DXCreateCubeTextureFromFileA


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileExA(
        LPDIRECT3DDEVICE8         pDevice,
        LPCSTR                    pSrcFile,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        DWORD                     Filter,
        DWORD                     MipFilter,
        D3DCOLOR                  ColorKey,
        D3DXIMAGE_INFO*           pSrcInfo,
        PALETTEENTRY*             pPalette,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);

#define D3DXCreateCubeTextureFromFileEx D3DXCreateCubeTextureFromFileExA


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileInMemory(
        LPDIRECT3DDEVICE8         pDevice,
        LPCVOID                   pSrcData,
        UINT                      SrcDataSize,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileInMemoryEx(
        LPDIRECT3DDEVICE8         pDevice,
        LPCVOID                   pSrcData,
        UINT                      SrcDataSize,
        UINT                      Size,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        DWORD                     Filter,
        DWORD                     MipFilter,
        D3DCOLOR                  ColorKey,
        D3DXIMAGE_INFO*           pSrcInfo,
        PALETTEENTRY*             pPalette,
        LPDIRECT3DCUBETEXTURE8*   ppCubeTexture);


//-------------------------------------------------------------------------
// D3DXFilterCubeTexture:
// ----------------------
// Filters mipmaps levels of a cube texture map.
//
// Parameters:
//  pCubeTexture
//      The cube texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL
//  SrcLevel
//      The level whose image is used to generate the subsequent levels.
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterCubeTexture(
        LPDIRECT3DCUBETEXTURE8    pCubeTexture,
        CONST PALETTEENTRY*       pPalette,
        UINT                      SrcLevel,
        DWORD                     Filter);




///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




//-------------------------------------------------------------------------
// D3DXCheckVolumeTextureRequirements:
// -----------------------------------
//
// Checks volume texture creation parameters.  If parameters are invalid,
// this function returns corrected parameters.
//
// Parameters:
//
//  pDevice
//      The D3D device to be used
//  pWidth
//      Desired width in pixels, or NULL.  Returns corrected size.
//  pHeight
//      Desired height in pixels, or NULL.  Returns corrected size.
//  pDepth
//      Desired depth in pixels, or NULL.  Returns corrected size.
//  pNumMipLevels
//      Number of desired mipmap levels, or NULL.  Returns corrected number.
//  pFormat
//      Desired pixel format, or NULL.  Returns corrected format.
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCheckVolumeTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pDepth,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool);


//-------------------------------------------------------------------------
// D3DXCreateVolumeTexture:
// ----------------------
// Create an empty volume texture
//
// Parameters:
//
//  pDevice
//      The D3D device with which the texture is going to be used.
//  Width
//      width in pixels; must be non-zero
//  Height
//      height in pixels; must be non-zero
//  Depth
//      depth in pixels; must be non-zero
//  MipLevels
//      number of mip levels desired; if zero or D3DX_DEFAULT, a complete
//      mipmap chain will be created.
//  Format
//      pixel format.
//  ppVolumeTexture
//      The volume texture object that will be created
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXCreateVolumeTexture(
        LPDIRECT3DDEVICE8         pDevice,
        UINT                      Width,
        UINT                      Height,
        UINT                      Depth,
        UINT                      MipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
        LPDIRECT3DVOLUMETEXTURE8* ppVolumeTexture);


//-------------------------------------------------------------------------
// D3DXFilterVolumeTexture:
// ------------------------
// Filters mipmaps levels of a volume texture map.
//
// Parameters:
//  pVolumeTexture
//      The volume texture object to be filtered
//  pPalette
//      256 color palette to be used, or NULL
//  SrcLevel
//      The level whose image is used to generate the subsequent levels.
//  Filter
//      D3DX_FILTER flags controlling how each miplevel is filtered.
//      Or D3DX_DEFAULT for D3DX_FILTER_BOX,
//
//-------------------------------------------------------------------------
HRESULT WINAPI
    D3DXFilterVolumeTexture(
        LPDIRECT3DVOLUMETEXTURE8  pVolumeTexture,
        CONST PALETTEENTRY*       pPalette,
        UINT                      SrcLevel,
        DWORD                     Filter);



#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8TEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\d3dx8mesh.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8mesh.h
//  Content:    D3DX mesh types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8MESH_H__
#define __D3DX8MESH_H__

#include "dxfile.h"     // defines LPDIRECTXFILEDATA

// {A69BA991-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXBaseMesh,
0xa69ba991, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {9D84AC46-6B90-49a9-A721-085C7A3E3DAE}
DEFINE_GUID(IID_ID3DXMesh,
0x9d84ac46, 0x6b90, 0x49a9, 0xa7, 0x21, 0x8, 0x5c, 0x7a, 0x3e, 0x3d, 0xae);

// {15981AA8-1A05-48e3-BBE7-FF5D49654E3F}
DEFINE_GUID(IID_ID3DXPMesh,
0x15981aa8, 0x1a05, 0x48e3, 0xbb, 0xe7, 0xff, 0x5d, 0x49, 0x65, 0x4e, 0x3f);

// {BC3BBDE2-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXSPMesh,
0xbc3bbde2, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {82A53844-F322-409e-A2E9-992E1104069D}
DEFINE_GUID(IID_ID3DXSkinMesh,
0x82a53844, 0xf322, 0x409e, 0xa2, 0xe9, 0x99, 0x2e, 0x11, 0x4, 0x6, 0x9d);


enum _D3DXMESH {
    D3DXMESH_32BIT                  = 0x001, // If set, then use 32 bit indices, if not set use 16 bit indices. 32BIT meshes currently not supported on ID3DXSkinMesh object
    D3DXMESH_DONOTCLIP              = 0x002, // Use D3DUSAGE_DONOTCLIP for VB & IB.
    D3DXMESH_POINTS                 = 0x004, // Use D3DUSAGE_POINTS for VB & IB.
    D3DXMESH_RTPATCHES              = 0x008, // Use D3DUSAGE_RTPATCHES for VB & IB.
    D3DXMESH_NPATCHES               = 0x4000,// Use D3DUSAGE_NPATCHES for VB & IB.
    D3DXMESH_VB_SYSTEMMEM           = 0x010, // Use D3DPOOL_SYSTEMMEM for VB. Overrides D3DXMESH_MANAGEDVERTEXBUFFER
    D3DXMESH_VB_MANAGED             = 0x020, // Use D3DPOOL_MANAGED for VB.
    D3DXMESH_VB_WRITEONLY           = 0x040, // Use D3DUSAGE_WRITEONLY for VB.
    D3DXMESH_VB_DYNAMIC             = 0x080, // Use D3DUSAGE_DYNAMIC for VB.
    D3DXMESH_IB_SYSTEMMEM           = 0x100, // Use D3DPOOL_SYSTEMMEM for IB. Overrides D3DXMESH_MANAGEDINDEXBUFFER
    D3DXMESH_IB_MANAGED             = 0x200, // Use D3DPOOL_MANAGED for IB.
    D3DXMESH_IB_WRITEONLY           = 0x400, // Use D3DUSAGE_WRITEONLY for IB.
    D3DXMESH_IB_DYNAMIC             = 0x800, // Use D3DUSAGE_DYNAMIC for IB.

    D3DXMESH_VB_SHARE               = 0x1000, // Valid for Clone* calls only, forces cloned mesh/pmesh to share vertex buffer

    D3DXMESH_USEHWONLY              = 0x2000, // Valid for ID3DXSkinMesh::ConvertToBlendedMesh

    // Helper options
    D3DXMESH_SYSTEMMEM              = 0x110, // D3DXMESH_VB_SYSTEMMEM | D3DXMESH_IB_SYSTEMMEM
    D3DXMESH_MANAGED                = 0x220, // D3DXMESH_VB_MANAGED | D3DXMESH_IB_MANAGED
    D3DXMESH_WRITEONLY              = 0x440, // D3DXMESH_VB_WRITEONLY | D3DXMESH_IB_WRITEONLY
    D3DXMESH_DYNAMIC                = 0x880, // D3DXMESH_VB_DYNAMIC | D3DXMESH_IB_DYNAMIC

};

// option field values for specifying min value in D3DXGeneratePMesh and D3DXSimplifyMesh
enum _D3DXMESHSIMP
{
    D3DXMESHSIMP_VERTEX   = 0x1,
    D3DXMESHSIMP_FACE     = 0x2,

};

enum _MAX_FVF_DECL_SIZE
{
    MAX_FVF_DECL_SIZE = 20
};

typedef struct ID3DXBaseMesh *LPD3DXBASEMESH;
typedef struct ID3DXMesh *LPD3DXMESH;
typedef struct ID3DXPMesh *LPD3DXPMESH;
typedef struct ID3DXSPMesh *LPD3DXSPMESH;
typedef struct ID3DXSkinMesh *LPD3DXSKINMESH;

typedef struct _D3DXATTRIBUTERANGE
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
} D3DXATTRIBUTERANGE;

typedef D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE;

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
struct D3DXMATERIAL
{
    D3DMATERIAL8  MatD3D;
    LPSTR         pTextureFilename;
};
typedef struct D3DXMATERIAL *LPD3DXMATERIAL;
#ifdef __cplusplus
}
#endif //__cplusplus

typedef struct _D3DXATTRIBUTEWEIGHTS
{
    FLOAT Position;
    FLOAT Boundary;
    FLOAT Normal;
    FLOAT Diffuse;
    FLOAT Specular;
    FLOAT Tex[8];
} D3DXATTRIBUTEWEIGHTS;

typedef D3DXATTRIBUTEWEIGHTS* LPD3DXATTRIBUTEWEIGHTS;

DECLARE_INTERFACE_(ID3DXBaseMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;
};

DECLARE_INTERFACE_(ID3DXMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXMesh
    STDMETHOD(LockAttributeBuffer)(THIS_ DWORD Flags, DWORD** ppData) PURE;
    STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;
    STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;
    STDMETHOD(GenerateAdjacency)(THIS_ FLOAT fEpsilon, DWORD* pAdjacency) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(OptimizeInplace)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap) PURE;
};

DECLARE_INTERFACE_(ID3DXPMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXPMesh
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(SetNumFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(SetNumVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinVertices)(THIS) PURE;
    STDMETHOD(Save)(THIS_ IStream *pStream, LPD3DXMATERIAL pMaterials, DWORD NumMaterials) PURE;

    STDMETHOD(Optimize)(THIS_ DWORD Flags, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(GetAdjacency)(THIS_ DWORD* pAdjacency) PURE;
};

DECLARE_INTERFACE_(ID3DXSPMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSPMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ReduceFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(ReduceVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
};

#define UNUSED16 (0xffff)
#define UNUSED32 (0xffffffff)

// ID3DXMesh::Optimize options
enum _D3DXMESHOPT {
    D3DXMESHOPT_COMPACT       = 0x001,
    D3DXMESHOPT_ATTRSORT      = 0x002,
    D3DXMESHOPT_VERTEXCACHE   = 0x004,
    D3DXMESHOPT_STRIPREORDER  = 0x008,
    D3DXMESHOPT_IGNOREVERTS   = 0x010,  // optimize faces only, don't touch vertices
    D3DXMESHOPT_SHAREVB       = 0x020,
};

// Subset of the mesh that has the same attribute and bone combination.
// This subset can be rendered in a single draw call
typedef struct _D3DXBONECOMBINATION
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
    DWORD* BoneId;
} D3DXBONECOMBINATION, *LPD3DXBONECOMBINATION;

DECLARE_INTERFACE_(ID3DXSkinMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(LockAttributeBuffer)(THIS_ DWORD flags, DWORD** ppData) PURE;
    STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    // ID3DXSkinMesh
    STDMETHOD_(DWORD, GetNumBones)(THIS) PURE;
    STDMETHOD(GetOriginalMesh)(THIS_ LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(SetBoneInfluence)(THIS_ DWORD bone, DWORD numInfluences, CONST DWORD* vertices, CONST FLOAT* weights) PURE;
    STDMETHOD_(DWORD, GetNumBoneInfluences)(THIS_ DWORD bone) PURE;
    STDMETHOD(GetBoneInfluence)(THIS_ DWORD bone, DWORD* vertices, FLOAT* weights) PURE;
    STDMETHOD(GetMaxVertexInfluences)(THIS_ DWORD* maxVertexInfluences) PURE;
    STDMETHOD(GetMaxFaceInfluences)(THIS_ DWORD* maxFaceInfluences) PURE;
    STDMETHOD(ConvertToBlendedMesh)(THIS_ DWORD options, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut,
                            DWORD* pNumBoneCombinations, LPD3DXBUFFER* ppBoneCombinationTable, LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(ConvertToIndexedBlendedMesh)(THIS_ DWORD options,
                                           CONST LPDWORD pAdjacencyIn,
                                           DWORD paletteSize,
                                           LPDWORD pAdjacencyOut,
                                           DWORD* pNumBoneCombinations,
                                           LPD3DXBUFFER* ppBoneCombinationTable,
                                           LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(GenerateSkinnedMesh)(THIS_ DWORD options, FLOAT minWeight, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut, LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(UpdateSkinnedMesh)(THIS_ CONST D3DXMATRIX* pBoneTransforms, LPD3DXMESH pMesh) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateMesh(
        DWORD NumFaces,
        DWORD NumVertices,
        DWORD Options,
        CONST DWORD *pDeclaration,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXCreateMeshFVF(
        DWORD NumFaces,
        DWORD NumVertices,
        DWORD Options,
        DWORD FVF,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXCreateSPMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        LPD3DXSPMESH* ppSMesh);

// clean a mesh up for simplification, try to make manifold
HRESULT WINAPI
    D3DXCleanMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency,
    LPD3DXMESH* ppMeshOut);

HRESULT WINAPI
    D3DXValidMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency);

HRESULT WINAPI
    D3DXGeneratePMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue,
        DWORD Options,
        LPD3DXPMESH* ppPMesh);

HRESULT WINAPI
    D3DXSimplifyMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue,
        DWORD Options,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXComputeBoundingSphere(
        PVOID pPointsFVF,
        DWORD NumVertices,
        DWORD FVF,
        D3DXVECTOR3 *pCenter,
        FLOAT *pRadius);

HRESULT WINAPI
    D3DXComputeBoundingBox(
        PVOID pPointsFVF,
        DWORD NumVertices,
        DWORD FVF,
        D3DXVECTOR3 *pMin,
        D3DXVECTOR3 *pMax);

HRESULT WINAPI
    D3DXComputeNormals(
        LPD3DXBASEMESH pMesh);

HRESULT WINAPI
    D3DXCreateBuffer(
        DWORD NumBytes,
        LPD3DXBUFFER *ppBuffer);


HRESULT WINAPI
    D3DXLoadMeshFromX(
        LPSTR pFilename,
        DWORD Options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials,
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXSaveMeshToX(
        LPSTR pFilename,
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXMATERIAL pMaterials,
        DWORD NumMaterials,
        DWORD Format
        );

HRESULT WINAPI
    D3DXCreatePMeshFromStream(
        IStream *pStream,
    DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice,
        LPD3DXBUFFER *ppMaterials,
        DWORD* pNumMaterials,
        LPD3DXPMESH *ppPMesh);

HRESULT WINAPI
    D3DXCreateSkinMesh(
        DWORD numFaces,
        DWORD numVertices,
        DWORD numBones,
        DWORD options,
        CONST DWORD *pDeclaration,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFVF(
        DWORD numFaces,
        DWORD numVertices,
        DWORD numBones,
        DWORD options,
        DWORD fvf,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFromMesh(
        LPD3DXMESH pMesh,
        DWORD numBones,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXLoadMeshFromXof(
        LPDIRECTXFILEDATA pXofObjMesh,
        DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice,
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials,
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXLoadSkinMeshFromXof(
        LPDIRECTXFILEDATA pxofobjMesh,
        DWORD options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER* ppAdjacency,
        LPD3DXBUFFER* ppMaterials,
        PDWORD pMatOut,
        LPD3DXBUFFER* ppBoneNames,
        LPD3DXBUFFER* ppBoneTransforms,
        LPD3DXSKINMESH* ppMesh);

HRESULT WINAPI
    D3DXTesselateMesh(
        LPD3DXMESH pMeshIn,
        CONST DWORD* pAdjacency,
        FLOAT NumSegs,
        BOOL  QuadraticInterpNormals,     // if false use linear intrep for normals, if true use quadratic
        LPD3DXMESH *ppMeshOut);

HRESULT WINAPI
    D3DXDeclaratorFromFVF(
        DWORD FVF,
        DWORD Declaration[MAX_FVF_DECL_SIZE]);

HRESULT WINAPI
    D3DXFVFFromDeclarator(
        CONST DWORD *pDeclarator,
        DWORD *pFVF);

HRESULT WINAPI
    D3DXWeldVertices(
        CONST LPD3DXMESH pMesh,
        float fEpsilon,
        CONST DWORD *rgdwAdjacencyIn,
        DWORD *rgdwAdjacencyOut,
        DWORD* pFaceRemap,
        LPD3DXBUFFER *ppbufVertexRemap);

HRESULT WINAPI
    D3DXIntersect(
        LPD3DXBASEMESH pMesh,
        CONST D3DXVECTOR3 *pRayPos,
        CONST D3DXVECTOR3 *pRayDir,
        BOOL    *pHit,
        DWORD   *pFaceIndex,
        FLOAT   *pU,
        FLOAT   *pV,
        FLOAT   *pDist);

BOOL WINAPI
    D3DXSphereBoundProbe(
        CONST D3DXVECTOR3 *pvCenter,
        FLOAT fRadius,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

BOOL WINAPI
    D3DXBoxBoundProbe(
        CONST D3DXVECTOR3 *pvMin,
        CONST D3DXVECTOR3 *pvMax,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

enum _D3DXERR {
    D3DXERR_CANNOTMODIFYINDEXBUFFER     = MAKE_DDHRESULT(2900),
    D3DXERR_INVALIDMESH                 = MAKE_DDHRESULT(2901),
    D3DXERR_CANNOTATTRSORT              = MAKE_DDHRESULT(2902),
    D3DXERR_SKINNINGNOTSUPPORTED        = MAKE_DDHRESULT(2903),
    D3DXERR_TOOMANYINFLUENCES           = MAKE_DDHRESULT(2904),
    D3DXERR_INVALIDDATA                 = MAKE_DDHRESULT(2905),
};

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8MESH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\dsound.h ===
/**************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    X-Box DirectSound.
 *
 **************************************************************************/

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

#include <xtl.h>
#include <dsfxparm.h>

#pragma warning(disable:4201)

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(p)
#endif // UNREFERENCED_PARAMETER

//
// Forward declarations
//

typedef struct XMediaObject XMediaObject;
typedef XMediaObject *LPXMEDIAOBJECT;

typedef struct XFileMediaObject XFileMediaObject;
typedef XFileMediaObject *LPXFILEMEDIAOBJECT;

typedef struct XWmaFileMediaObject XWmaFileMediaObject;
typedef XWmaFileMediaObject *LPXWMAFILEMEDIAOBJECT;

typedef struct IDirectSound IDirectSound;
typedef IDirectSound *LPDIRECTSOUND;

#define IDirectSound8 IDirectSound
#define LPDIRECTSOUND8 LPDIRECTSOUND

#define IDirectSound3DListener IDirectSound
#define LPDIRECTSOUND3DLISTENER LPDIRECTSOUND

typedef struct IDirectSoundBuffer IDirectSoundBuffer;
typedef IDirectSoundBuffer *LPDIRECTSOUNDBUFFER;

#define IDirectSoundBuffer8 IDirectSoundBuffer
#define LPDIRECTSOUNDBUFFER8 LPDIRECTSOUNDBUFFER

#define IDirectSound3DBuffer IDirectSoundBuffer
#define LPDIRECTSOUND3DBUFFER LPDIRECTSOUNDBUFFER

#define IDirectSoundNotify IDirectSoundBuffer
#define LPDIRECTSOUNDNOTIFY LPDIRECTSOUNDBUFFER

typedef struct IDirectSoundStream IDirectSoundStream;
typedef IDirectSoundStream *LPDIRECTSOUNDSTREAM;

typedef struct XAc97MediaObject XAc97MediaObject;
typedef XAc97MediaObject *LPAC97MEDIAOBJECT;

//
// Structures and types
//

#pragma pack(push, 1)

typedef struct tWAVEFORMATEX
{
    WORD    wFormatTag;                     // Format type
    WORD    nChannels;                      // Channel count
    DWORD   nSamplesPerSec;                 // Sampling rate
    DWORD   nAvgBytesPerSec;                // Average number of bytes per second
    WORD    nBlockAlign;                    // Block size of data
    WORD    wBitsPerSample;                 // Count of bits per mono sample
    WORD    cbSize;                         // Bytes of extra format information following this structure
} WAVEFORMATEX, *PWAVEFORMATEX, *LPWAVEFORMATEX;

typedef const WAVEFORMATEX *LPCWAVEFORMATEX;

typedef struct xbox_adpcmwaveformat_tag 
{
    WAVEFORMATEX    wfx;                    // WAVEFORMATEX data
    WORD            wSamplesPerBlock;       // Count of samples per encoded block.  Must be 64.
} XBOXADPCMWAVEFORMAT, *PXBOXADPCMWAVEFORMAT, *LPXBOXADPCMWAVEFORMAT;

typedef const XBOXADPCMWAVEFORMAT *LPCXBOXADPCMWAVEFORMAT;

#pragma pack(pop)

typedef LONGLONG REFERENCE_TIME, *PREFERENCE_TIME, *LPREFERENCE_TIME;

typedef struct _XMEDIAPACKET
{
    LPVOID          pvBuffer;               // Packet data buffer
    DWORD           dwMaxSize;              // Packet data buffer size, in bytes
    LPDWORD         pdwCompletedSize;       // Optional pointer to completed size, in bytes
    LPDWORD         pdwStatus;              // Optional pointer to buffer status
    union 
    {
        HANDLE      hCompletionEvent;       // Optional packet completion event
        LPVOID      pContext;               // Optional callback function packet context
    };
    PREFERENCE_TIME prtTimestamp;           // Optional packet timestamp
} XMEDIAPACKET, *PXMEDIAPACKET, *LPXMEDIAPACKET;

typedef const XMEDIAPACKET *LPCXMEDIAPACKET;

typedef struct _XMEDIAINFO
{
    DWORD           dwFlags;                // Object flags (XMEDIA_STREAMF_*)
    DWORD           dwInputSize;            // Input buffer size
    DWORD           dwOutputSize;           // Output buffer size
    DWORD           dwMaxLookahead;         // Maximum amount of data that must be buffered to prevent underrun
} XMEDIAINFO, *PXMEDIAINFO, *LPXMEDIAINFO;

typedef const XMEDIAINFO *LPCXMEDIAINFO;

typedef struct _DSCAPS                                  
{                                                       
    DWORD           dwFree2DBuffers;        // Number of available 2D sound buffers
    DWORD           dwFree3DBuffers;        // Number of available 3D sound buffers
    DWORD           dwFreeBufferSGEs;       // Number of available buffer scatter/gather entries
    DWORD           dwMemoryAllocated;      // Total amount of memory allocated by DirectSound
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;                 // Structure size, in bytes
    DWORD           dwFlags;                // DSBCAPS flags
    DWORD           dwBufferBytes;          // Buffer size, in bytes
    LPWAVEFORMATEX  lpwfxFormat;            // Buffer format
    DWORD           dwMixBinMask;           // Buffer output mixbin assignments
    DWORD           dwInputMixBinMask;      // Buffer input mixbin assignment (FXIN buffers only)
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;               // Play cursor position
    HANDLE          hEventNotify;           // Notification event
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

typedef VOID (CALLBACK *LPFNXMEDIAOBJECTCALLBACK)(LPVOID pStreamContext, LPVOID pPacketContext, DWORD dwStatus);
typedef LPFNXMEDIAOBJECTCALLBACK PFNXMEDIAOBJECTCALLBACK;

typedef struct _DSSTREAMDESC
{
    DWORD                       dwFlags;                // DSSTREAMCAPS flags
    DWORD                       dwMaxAttachedPackets;   // Maximum count of packets that will be simultaneously submitted to the stream
    LPWAVEFORMATEX              lpwfxFormat;            // Stream format
    LPFNXMEDIAOBJECTCALLBACK    lpfnCallback;           // Packet completion callback routine
    LPVOID                      lpvContext;             // Packet completion callback routine context
    DWORD                       dwMixBinMask;           // Stream output mixbin assignments
} DSSTREAMDESC, *LPDSSTREAMDESC;

typedef const DSSTREAMDESC *LPCDSSTREAMDESC;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;                 // Structure size, in bytes
    D3DXVECTOR3     vPosition;              // Buffer 3D position
    D3DXVECTOR3     vVelocity;              // Buffer 3D velocity
    DWORD           dwInsideConeAngle;      // Buffer inside cone angle
    DWORD           dwOutsideConeAngle;     // Buffer outside cone angle
    D3DXVECTOR3     vConeOrientation;       // Buffer cone orientation
    LONG            lConeOutsideVolume;     // Volume outside the cone
    FLOAT           flMinDistance;          // Minimum distance value
    FLOAT           flMaxDistance;          // Maximum distance value
    DWORD           dwMode;                 // 3D processing mode
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;                 // Structure size, in bytes
    D3DXVECTOR3     vPosition;              // Listener 3D position
    D3DXVECTOR3     vVelocity;              // Listener 3D velocity
    D3DXVECTOR3     vOrientFront;           // Listener front orientation
    D3DXVECTOR3     vOrientTop;             // Listener top orientation
    FLOAT           flDistanceFactor;       // Distance factor
    FLOAT           flRolloffFactor;        // Rolloff factor
    FLOAT           flDopplerFactor;        // Doppler factor
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSI3DL2OBSTRUCTION
{
    LONG            lHFLevel;               // [-10000, 0] default: 0 mB
    FLOAT           flLFRatio;              // [0.0, 1.0] default: 0.0
} DSI3DL2OBSTRUCTION, *LPDSI3DL2OBSTRUCTION;

typedef const DSI3DL2OBSTRUCTION *LPCDSI3DL2OBSTRUCTION;

typedef struct _DSI3DL2OCCLUSION
{
    LONG            lHFLevel;               // [-10000, 0] default: 0 mB
    FLOAT           flLFRatio;              // [0.0, 1.0] default: 0.0
} DSI3DL2OCCLUSION, *LPDSI3DL2OCCLUSION;

typedef const DSI3DL2OCCLUSION *LPCDSI3DL2OCCLUSION;

typedef struct _DSI3DL2BUFFER
{
    LONG                lDirect;            // [-10000, 1000] default: 0 mB
    LONG                lDirectHF;          // [-10000, 0] default: 0 mB
    LONG                lRoom;              // [-10000, 1000] default: 0 mB
    LONG                lRoomHF;            // [-10000, 0] default: 0 mB
    FLOAT               flRoomRolloffFactor;// [0.0, 10.0] default: 0.0
    DSI3DL2OBSTRUCTION  Obstruction;        // Source obstruction parameters
    DSI3DL2OCCLUSION    Occlusion;          // Source occlusion parameters
} DSI3DL2BUFFER, *LPDSI3DL2BUFFER;

typedef const DSI3DL2BUFFER *LPCDSI3DL2BUFFER;

typedef struct _DSI3DL2LISTENER
{
    LONG            lRoom;                  // [-10000, 0] default: -10000 mB
    LONG            lRoomHF;                // [-10000, 0] default: 0 mB
    FLOAT           flRoomRolloffFactor;    // [0.0, 10.0] default: 0.0
    FLOAT           flDecayTime;            // [0.1, 20.0] default: 1.0 s
    FLOAT           flDecayHFRatio;         // [0.1, 2.0] default: 0.5
    LONG            lReflections;           // [-10000, 1000] default: -10000 mB
    FLOAT           flReflectionsDelay;     // [0.0, 0.3] default: 0.02 s
    LONG            lReverb;                // [-10000, 2000] default: -10000 mB
    FLOAT           flReverbDelay;          // [0.0, 0.1] default: 0.04 s
    FLOAT           flDiffusion;            // [0.0, 100.0] default: 100.0 %
    FLOAT           flDensity;              // [0.0, 100.0] default: 100.0 %
    FLOAT           flHFReference;          // [20.0, 20000.0] default: 5000.0 Hz
} DSI3DL2LISTENER, *LPDSI3DL2LISTENER;

typedef const DSI3DL2LISTENER *LPCDSI3DL2LISTENER;

typedef struct _DSLFODESC
{
    DWORD           dwLFO;                  // LFO to set data on
    DWORD           dwDelay;                // Initial delay before LFO is applied, in 32-sample blocks
    DWORD           dwDelta;                // Delta added to LFO each frame
    LONG            lPitchModulation;       // Pitch modulation
    LONG            lFilterCutOffRange;     // Frequency cutoff range (multi-function LFO only)
    LONG            lAmplitudeModulation;   // Amplitude modulation (multi-function LFO only)
} DSLFODESC, *LPDSLFODESC;

typedef const DSLFODESC *LPCDSLFODESC;

typedef struct _DSENVELOPEDESC
{
    DWORD           dwEG;                   // Envelope generator to set data on
    DWORD           dwMode;                 // Envelope mode
    DWORD           dwDelay;                // Count of 512-sample blocks to delay before attack
    DWORD           dwAttack;               // Attack segment length, in 512-sample blocks
    DWORD           dwHold;                 // Count of 512-sample blocks to hold after attack
    DWORD           dwDecay;                // Decay segment length, in 512-sample blocks
    DWORD           dwRelease;              // Release segment length, in 512-sample blocks
    DWORD           dwSustain;              // Sustain level
    LONG            lPitchScale;            // Pitch scale (multi-function envelope only)
    LONG            lFilterCutOff;          // Filter cut-off (multi-function envelope only)
} DSENVELOPEDESC, *LPDSENVELOPEDESC;

typedef const DSENVELOPEDESC *LPCDSENVELOPEDESC;

typedef struct _DSFILTERDESC
{
    DWORD           dwMode;                 // Filter mode
    DWORD           dwQCoefficient;         // Q-coefficient (PEQ only)
    DWORD           adwCoefficients[4];     // Filter coefficients
} DSFILTERDESC, *LPDSFILTERDESC;

typedef const DSFILTERDESC *LPCDSFILTERDESC;

typedef struct _DSEFFECTMAP
{
    LPVOID          lpvCodeSegment;         // Starting address of the DSP code segment
    DWORD           dwCodeSize;             // Code segment size, in DWORDs
    LPVOID          lpvStateSegment;        // Starting address of the effect state segment
    DWORD           dwStateSize;            // Effect state segment size, in DWORDs
    LPVOID          lpvYMemorySegment;      // Starting address of the DSP Y-memory segment
    DWORD           dwYMemorySize;          // Y-memory segment size, in DWORDs            
    LPVOID          lpvScratchSegment;      // Starting address of the scratch memory segment
    DWORD           dwScratchSize;          // Scratch segment size, in DWORDs
} DSEFFECTMAP, *LPDSEFFECTMAP;

typedef const DSEFFECTMAP *LPCDSEFFECTMAP;

typedef struct _DSEFFECTIMAGEDESC
{
    DWORD           dwEffectCount;          // Count of effects in the image
    DWORD           dwTotalScratchSize;     // total FX delay line scratch used
    DSEFFECTMAP     aEffectMaps[1];         // Variable-length array of effect maps
} DSEFFECTIMAGEDESC, *LPDSEFFECTIMAGEDESC;

typedef const DSEFFECTIMAGEDESC *LPCDSEFFECTIMAGEDESC;

typedef struct _DSEFFECTIMAGELOC
{
    DWORD           dwI3DL2ReverbIndex;     // I3DL2 reverb effect index
    DWORD           dwCrosstalkIndex;       // Crosstalk cancellation effect index
} DSEFFECTIMAGELOC, *LPDSEFFECTIMAGELOC;

typedef const DSEFFECTIMAGELOC *LPCDSEFFECTIMAGELOC;

typedef DWORD FOURCC, *PFOURCC, *LPFOURCC;

//
// Return Codes
//

#define _FACDS 0x878
#define MAKE_DSHRESULT(code) MAKE_HRESULT(1, _FACDS, code)

// The function completed successfully
#define DS_OK                   S_OK                    

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL    MAKE_DSHRESULT(30)      

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL       MAKE_DSHRESULT(50)      

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC           E_FAIL                  

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY       E_OUTOFMEMORY           

// The function called is not supported at this time
#define DSERR_UNSUPPORTED       E_NOTIMPL               

// No sound driver is available for use
#define DSERR_NODRIVER          MAKE_DSHRESULT(120)     

// This object does not support aggregation
#define DSERR_NOAGGREGATION     CLASS_E_NOAGGREGATION   

//
// Format tags
//

#define WAVE_FORMAT_PCM                     1
#define WAVE_FORMAT_XBOX_ADPCM              0x0069
#define WAVE_FORMAT_VOXWARE_VR12            0x0077
#define WAVE_FORMAT_VOXWARE_SC03            0x007A
#define WAVE_FORMAT_VOXWARE_SC06            0x007B

//
// FOURCC codes
//

#ifndef MAKEFOURCC

#define MAKEFOURCC(ch0, ch1, ch2, ch3) \
    ((FOURCC)(BYTE)(ch0) | ((FOURCC)(BYTE)(ch1) << 8) | \
    ((FOURCC)(BYTE)(ch2) << 16) | ((FOURCC)(BYTE)(ch3) << 24 ))

#endif // MAKEFOURCC

//
// XMediaObject constants
//

#define XMO_STATUSF_ACCEPT_INPUT_DATA           0x00000001      // The object is ready to accept input data
#define XMO_STATUSF_ACCEPT_OUTPUT_DATA          0x00000002      // The object is ready to provide output data
                                                
#define XMO_STREAMF_WHOLE_SAMPLES               0x00000001      // The object supports whole samples only
#define XMO_STREAMF_SINGLE_SAMPLE_PER_PACKET    0x00000002      // The object supports only a single sample per packet
#define XMO_STREAMF_FIXED_SAMPLE_SIZE           0x00000004      // The object supports only a fixed sample size
#define XMO_STREAMF_FIXED_PACKET_ALIGNMENT      0x00000008      // The object supports only a fixed packet alignment
#define XMO_STREAMF_INPUT_ASYNC                 0x00000010      // The object supports receiving input data asynchronously
#define XMO_STREAMF_OUTPUT_ASYNC                0x00000020      // The object supports providing output data asynchronously
#define XMO_STREAMF_IN_PLACE                    0x00000040      // The object supports in-place modification of data
#define XMO_STREAMF_DISCARDABLE                 0x00000080      // BUGBUG: what does this mean?

#define XMEDIAPACKET_STATUS_SUCCESS             S_OK            // The packet completed successfully
#define XMEDIAPACKET_STATUS_PENDING             E_PENDING       // The packet is waiting to be processed
#define XMEDIAPACKET_STATUS_FLUSHED             E_ABORT         // The packet was completed as a result of a Flush operation
#define XMEDIAPACKET_STATUS_FAILURE             E_FAIL          // The packet was completed as a result of a failure

//
// Cooperative levels (not used on Xbox)
//

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004

//
// Speaker configuration
//

#define DSSPEAKER_SURROUND          XC_AUDIO_FLAGS_SURROUND      // Dolby Surround
#define DSSPEAKER_STEREO            XC_AUDIO_FLAGS_STEREO        // Stereo
#define DSSPEAKER_MONO              XC_AUDIO_FLAGS_MONO          // Mono
#define DSSPEAKER_ENABLE_AC3        XC_AUDIO_FLAGS_ENABLE_AC3    // Enable Dolby Digital output
#define DSSPEAKER_ENABLE_DTS        XC_AUDIO_FLAGS_ENABLE_DTS    // Enable DTS output

#define DSSPEAKER_BASIC(c)          XC_AUDIO_FLAGS_BASIC(c)
#define DSSPEAKER_ENCODED(c)        XC_AUDIO_FLAGS_ENCODED(c)
#define DSSPEAKER_COMBINED(b,e)     XC_AUDIO_FLAGS_COMBINED(b,e)

#define XAudioGetSpeakerConfig      XGetAudioFlags
                                        
//
// DirectSound global headroom ranges
//

#define DSHEADROOM_MIN              0               // Minimum valid headroom value
#define DSHEADROOM_MAX              7               // Maximum valid headroom value
#define DSHEADROOM_DEFAULT          1               // Default headroom value
                                                                        
//
// DirectSound Buffer creation flags
//

#define DSBCAPS_CTRL3D              0x00000010      // The buffer supports 3D
#define DSBCAPS_CTRLFREQUENCY       0x00000020      // The buffer supports frequency changes
#define DSBCAPS_CTRLVOLUME          0x00000080      // The buffer supports volume changes
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100      // The buffer supports position notifications
#define DSBCAPS_MIXIN               0x00002000      // The buffer is to be used as the destination of a submix operation
#define DSBCAPS_LOCDEFER            0x00040000      // The buffer does not acquire resources at creation
#define DSBCAPS_FXIN                0x00080000      // The buffer is to be used as the destination of a post-effects submix operation
                                                                        
//
// IDirectSoundBuffer::Play(Ex) flags
//

#define DSBPLAY_LOOPING             0x00000001      // The buffer should play in a loop

//
// IDirectSoundBuffer::StopEx flags
//

#define DSBSTOPEX_IMMEDIATE         0x00000000      // The buffer should stop immediately
#define DSBSTOPEX_ENVELOPE          0x00000001      // The buffer should enter it's release phase
#define DSBSTOPEX_RELEASEWAVEFORM   0x00000002      // The buffer should break out of the loop region and enter it's release phase
                                                                        
//
// Buffer status flags
//

#define DSBSTATUS_PLAYING           0x00000001      // The buffer is playing
#define DSBSTATUS_LOOPING           0x00000004      // The buffer is playing in a loop
                                                                            
//
// IDirectSoundBuffer::Lock flags
//

#define DSBLOCK_FROMWRITECURSOR     0x00000001      // Lock the buffer from the current write cursor position
#define DSBLOCK_ENTIREBUFFER        0x00000002      // Lock the entire buffer
                                                                            
//
// Buffer frequency range
//

#define DSBFREQUENCY_MIN            188             // Minimum valid frequency value
#define DSBFREQUENCY_MAX            191983          // Maximum valid frequency value
#define DSBFREQUENCY_ORIGINAL       0               // Reserved value meaning original frequency
                                                                        
//
// Buffer volume range
//

#define DSBVOLUME_MIN               -10000          // Maximum valid attenuation value
#define DSBVOLUME_MAX               0               // Minimum valid attenuation value

//
// Buffer headroom range 
//

#define DSBHEADROOM_MIN             0               // Minimum valid headroom value
#define DSBHEADROOM_MAX             10000           // Maximum valid headroom value
#define DSBHEADROOM_DEFAULT_2D      600             // Default headroom value for 2D voices
#define DSBHEADROOM_DEFAULT_3D      0               // Default headroom value for 3D voices
#define DSBHEADROOM_DEFAULT_SUBMIX  0               // Default headroom value for submix destinations

//
// Buffer pitch range
//

#define DSBPITCH_MIN                -32767          // Minimum valid pitch value
#define DSBPITCH_MAX                8191            // Maximum valid pitch value
                                                                        
//
// Buffer size range
//

#define DSBSIZE_MIN                 4               // Minimum valid buffer size, in bytes
#define DSBSIZE_MAX                 0x0FFFFFFF      // Maximum valid buffer size, in bytes
                                                                        
//
// Reserved notification offset values
//

#define DSBPN_OFFSETSTOP            0xFFFFFFFF      // Offset value representing "stop" to IDirectSoundNotify

//
// DirectSound Stream creation flags
//

#define DSSTREAMCAPS_CTRL3D         DSBCAPS_CTRL3D              // The stream supports 3D
#define DSSTREAMCAPS_CTRLFREQUENCY  DSBCAPS_CTRLFREQUENCY       // The stream supports frequency changes
#define DSSTREAMCAPS_CTRLVOLUME     DSBCAPS_CTRLVOLUME          // The stream supports volume changes
#define DSSTREAMCAPS_LOCDEFER       DSBCAPS_LOCDEFER            // The stream does not acquire resources at creation
#define DSSTREAMCAPS_ACCURATENOTIFY 0x40000000                  // The stream should provide more accurate packet completion notifications
                                                                    
//
// Stream frequency range
//

#define DSSTREAMFREQUENCY_MIN       DSBFREQUENCY_MIN            // Minimum valid frequency value
#define DSSTREAMFREQUENCY_MAX       DSBFREQUENCY_MAX            // Maximum valid frequency value
#define DSSTREAMFREQUENCY_ORIGINAL  DSBFREQUENCY_ORIGINAL       // Reserved value meaning original frequency
                                                                    
//
// Stream volume range
//

#define DSSTREAMVOLUME_MIN          DSBVOLUME_MIN               // Minimum valid volume value
#define DSSTREAMVOLUME_MAX          DSBVOLUME_MAX               // Maximum valid volume value

//
// Stream headroom range 
//

#define DSSTREAMHEADROOM_MIN        DSBHEADROOM_MIN             // Minimum valid headroom value
#define DSSTREAMHEADROOM_MAX        DSBHEADROOM_MAX             // Maximum valid headroom value
#define DSSTREAMHEADROOM_DEFAULT_2D DSBHEADROOM_DEFAULT_2D      // Default headroom value for 2D voices
#define DSSTREAMHEADROOM_DEFAULT_3D DSBHEADROOM_DEFAULT_3D      // Default headroom value for 3D voices

//
// Buffer pitch range
//

#define DSSTREAMPITCH_MIN           DSBPITCH_MIN                // Minimum valid pitch value
#define DSSTREAMPITCH_MAX           DSBPITCH_MAX                // Maximum valid pitch value
                                                                        
//
// Stream pause state
//

#define DSSTREAMPAUSE_RESUME        0x00000000                  // Resume a paused stream
#define DSSTREAMPAUSE_PAUSE         0x00000001                  // Pause the stream

//
// 3D modes
//

#define DS3DMODE_NORMAL             0x00000000      // Normal 3D mode
#define DS3DMODE_HEADRELATIVE       0x00000001      // Head-relative 3D mode
#define DS3DMODE_DISABLE            0x00000002      // Disable 3D processing

//
// 3D parameter flags
//

#define DS3D_IMMEDIATE              0x00000000      // Apply the values immediately
#define DS3D_DEFERRED               0x00000001      // Defer the values until CommitDeferredSettings is called

//
// 3D bounds and defaults
//

#define DS3D_MINDISTANCEFACTOR          FLT_MIN         // Minimum valid distance factor value
#define DS3D_MAXDISTANCEFACTOR          FLT_MAX         // Maximum valid distance factor value
#define DS3D_DEFAULTDISTANCEFACTOR      1.0f            // Default distance factor value
                                        
#define DS3D_MINROLLOFFFACTOR           0.0f            // Minimum valid rolloff factor value
#define DS3D_MAXROLLOFFFACTOR           10.0f           // Maximum valid rolloff factor value
#define DS3D_DEFAULTROLLOFFFACTOR       1.0f            // Default rolloff factor value
                                        
#define DS3D_MINDOPPLERFACTOR           0.0f            // Minimum valid Doppler factor value
#define DS3D_MAXDOPPLERFACTOR           10.0f           // Maximum valid Doppler factor value
#define DS3D_DEFAULTDOPPLERFACTOR       1.0f            // Default Doppler factor value
                                        
#define DS3D_MINMINDISTANCE             1.17549e-37f    // Minimum minimum distance value
#define DS3D_MAXMINDISTANCE             FLT_MAX         // Maximum minimum distance value
#define DS3D_DEFAULTMINDISTANCE         1.0f            // Default minimum distance value

#define DS3D_MINMAXDISTANCE             1.17549e-37f    // Minimum maximum distance value
#define DS3D_MAXMAXDISTANCE             FLT_MAX         // Maximum maximum distance value
#define DS3D_DEFAULTMAXDISTANCE         1000000000.0f   // Default maximum distance value
                                        
#define DS3D_MINCONEANGLE               0               // Minimum valid cone angle value
#define DS3D_MAXCONEANGLE               360             // Maximum valid cone angle value
#define DS3D_DEFAULTCONEANGLE           360             // Default cone angle value
                                        
#define DS3D_DEFAULTORIENTFRONT_X       0.0f            // Default front orientation (x)
#define DS3D_DEFAULTORIENTFRONT_Y       0.0f            // Default front orientation (y)
#define DS3D_DEFAULTORIENTFRONT_Z       1.0f            // Default front orientation (z)
                                        
#define DS3D_DEFAULTORIENTTOP_X         0.0f            // Default top orientation (x)
#define DS3D_DEFAULTORIENTTOP_Y         1.0f            // Default top orientation (y)
#define DS3D_DEFAULTORIENTTOP_Z         0.0f            // Default top orientation (z)
                                        
#define DS3D_DEFAULTCONEORIENT_X        0.0f            // Default cone orientation (x)
#define DS3D_DEFAULTCONEORIENT_Y        0.0f            // Default cone orientation (y)
#define DS3D_DEFAULTCONEORIENT_Z        1.0f            // Default cone orientation (z)
                                        
#define DS3D_DEFAULTPOSITION_X          0.0f            // Default position (x)
#define DS3D_DEFAULTPOSITION_Y          0.0f            // Default position (y)
#define DS3D_DEFAULTPOSITION_Z          0.0f            // Default position (z)
                                        
#define DS3D_DEFAULTVELOCITY_X          0.0f            // Default velocity (x)
#define DS3D_DEFAULTVELOCITY_Y          0.0f            // Default velocity (y)
#define DS3D_DEFAULTVELOCITY_Z          0.0f            // Default velocity (z)

#define DS3D_DEFAULTCONEOUTSIDEVOLUME   DSBVOLUME_MAX   // Default cone outside volume

//
// I3DL2 bounds and defaults
//

#define DSI3DL2LISTENER_MINROOM                     -10000
#define DSI3DL2LISTENER_MAXROOM                     0
#define DSI3DL2LISTENER_DEFAULTROOM                 -10000
#define DSI3DL2LISTENER_MINROOMHF                   -10000
#define DSI3DL2LISTENER_MAXROOMHF                   0
#define DSI3DL2LISTENER_DEFAULTROOMHF               0
#define DSI3DL2LISTENER_MINROOMROLLOFFFACTOR        0.0f
#define DSI3DL2LISTENER_MAXROOMROLLOFFFACTOR        10.0f
#define DSI3DL2LISTENER_DEFAULTROOMROLLOFFFACTOR    0.0f
#define DSI3DL2LISTENER_MINDECAYTIME                0.1f
#define DSI3DL2LISTENER_MAXDECAYTIME                20.0f
#define DSI3DL2LISTENER_DEFAULTDECAYTIME            1.0f
#define DSI3DL2LISTENER_MINDECAYHFRATIO             0.1f
#define DSI3DL2LISTENER_MAXDECAYHFRATIO             2.0f
#define DSI3DL2LISTENER_DEFAULTDECAYHFRATIO         0.5f
#define DSI3DL2LISTENER_MINREFLECTIONS              -10000
#define DSI3DL2LISTENER_MAXREFLECTIONS              1000
#define DSI3DL2LISTENER_DEFAULTREFLECTIONS          -10000
#define DSI3DL2LISTENER_MINREFLECTIONSDELAY         0.0f
#define DSI3DL2LISTENER_MAXREFLECTIONSDELAY         0.3f
#define DSI3DL2LISTENER_DEFAULTREFLECTIONSDELAY     0.02f
#define DSI3DL2LISTENER_MINREVERB                   -10000
#define DSI3DL2LISTENER_MAXREVERB                   2000
#define DSI3DL2LISTENER_DEFAULTREVERB               -10000
#define DSI3DL2LISTENER_MINREVERBDELAY              0.0f
#define DSI3DL2LISTENER_MAXREVERBDELAY              0.1f
#define DSI3DL2LISTENER_DEFAULTREVERBDELAY          0.04f
#define DSI3DL2LISTENER_MINDIFFUSION                0.0f
#define DSI3DL2LISTENER_MAXDIFFUSION                100.0f
#define DSI3DL2LISTENER_DEFAULTDIFFUSION            100.0f
#define DSI3DL2LISTENER_MINDENSITY                  0.0f
#define DSI3DL2LISTENER_MAXDENSITY                  100.0f
#define DSI3DL2LISTENER_DEFAULTDENSITY              100.0f
#define DSI3DL2LISTENER_MINHFREFERENCE              20.0f
#define DSI3DL2LISTENER_MAXHFREFERENCE              20000.0f
#define DSI3DL2LISTENER_DEFAULTHFREFERENCE          5000.0f

#define DSI3DL2BUFFER_MINDIRECT                     -10000
#define DSI3DL2BUFFER_MAXDIRECT                     1000
#define DSI3DL2BUFFER_DEFAULTDIRECT                 0
#define DSI3DL2BUFFER_MINDIRECTHF                   -10000
#define DSI3DL2BUFFER_MAXDIRECTHF                   0
#define DSI3DL2BUFFER_DEFAULTDIRECTHF               0
#define DSI3DL2BUFFER_MINROOM                       -10000
#define DSI3DL2BUFFER_MAXROOM                       1000
#define DSI3DL2BUFFER_DEFAULTROOM                   0
#define DSI3DL2BUFFER_MINROOMHF                     -10000
#define DSI3DL2BUFFER_MAXROOMHF                     0
#define DSI3DL2BUFFER_DEFAULTROOMHF                 0
#define DSI3DL2BUFFER_MINROOMROLLOFFFACTOR          0.0f
#define DSI3DL2BUFFER_MAXROOMROLLOFFFACTOR          10.f
#define DSI3DL2BUFFER_DEFAULTROOMROLLOFFFACTOR      0.0f
#define DSI3DL2BUFFER_MINOBSTRUCTION                -10000
#define DSI3DL2BUFFER_MAXOBSTRUCTION                0
#define DSI3DL2BUFFER_DEFAULTOBSTRUCTION            0
#define DSI3DL2BUFFER_MINOBSTRUCTIONLFRATIO         0.0f
#define DSI3DL2BUFFER_MAXOBSTRUCTIONLFRATIO         1.0f
#define DSI3DL2BUFFER_DEFAULTOBSTRUCTIONLFRATIO     0.0f
#define DSI3DL2BUFFER_MINOCCLUSION                  -10000
#define DSI3DL2BUFFER_MAXOCCLUSION                  0
#define DSI3DL2BUFFER_DEFAULTOCCLUSION              0
#define DSI3DL2BUFFER_MINOCCLUSIONLFRATIO           0.0f
#define DSI3DL2BUFFER_MAXOCCLUSIONLFRATIO           1.0f
#define DSI3DL2BUFFER_DEFAULTOCCLUSIONLFRATIO       0.25f

//
// I3DL2 listener environmental presets
//

#define DSI3DL2_ENVIRONMENT_PRESET_DEFAULT           -1000,   -100, 0.0f, 1.49f, 0.83f,  -2602, 0.007f,    200, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_GENERIC           -1000,   -100, 0.0f, 1.49f, 0.83f,  -2602, 0.007f,    200, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL        -1000,  -6000, 0.0f, 0.17f, 0.10f,  -1204, 0.001f,    207, 0.002f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_ROOM              -1000,   -454, 0.0f, 0.40f, 0.83f,  -1646, 0.002f,     53, 0.003f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_BATHROOM          -1000,  -1200, 0.0f, 1.49f, 0.54f,   -370, 0.007f,   1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM        -1000,  -6000, 0.0f, 0.50f, 0.10f,  -1376, 0.003f,  -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_STONEROOM         -1000,   -300, 0.0f, 2.31f, 0.64f,   -711, 0.012f,     83, 0.017f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM        -1000,   -476, 0.0f, 4.32f, 0.59f,   -789, 0.020f,   -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL       -1000,   -500, 0.0f, 3.92f, 0.70f,  -1230, 0.020f,     -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_CAVE              -1000,      0, 0.0f, 2.91f, 1.30f,   -602, 0.015f,   -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_ARENA             -1000,   -698, 0.0f, 7.24f, 0.33f,  -1166, 0.020f,     16, 0.030f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_HANGAR            -1000,  -1000, 0.0f,10.05f, 0.23f,   -602, 0.020f,    198, 0.030f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY   -1000,  -4000, 0.0f, 0.30f, 0.10f,  -1831, 0.002f,  -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_HALLWAY           -1000,   -300, 0.0f, 1.49f, 0.59f,  -1219, 0.007f,    441, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR     -1000,   -237, 0.0f, 2.70f, 0.79f,  -1214, 0.013f,    395, 0.020f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_ALLEY             -1000,   -270, 0.0f, 1.49f, 0.86f,  -1204, 0.007f,     -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_FOREST            -1000,  -3300, 0.0f, 1.49f, 0.54f,  -2560, 0.162f,   -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_CITY              -1000,   -800, 0.0f, 1.49f, 0.67f,  -2273, 0.007f,  -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS         -1000,  -2500, 0.0f, 1.49f, 0.21f,  -2780, 0.300f,  -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_QUARRY            -1000,  -1000, 0.0f, 1.49f, 0.83f, -10000, 0.061f,    500, 0.025f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_PLAIN             -1000,  -2000, 0.0f, 1.49f, 0.50f,  -2466, 0.179f,  -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT        -1000,      0, 0.0f, 1.65f, 1.50f,  -1363, 0.008f,  -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE         -1000,  -1000, 0.0f, 2.81f, 0.14f,    429, 0.014f,    648, 0.021f,  80.0f,  60.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER        -1000,  -4000, 0.0f, 1.49f, 0.10f,   -449, 0.007f,   1700, 0.011f, 100.0f, 100.0f, 5000.0f
#define DSI3DL2_ENVIRONMENT_PRESET_NOREVERB         -10000, -10000, 0.0f, 1.00f, 1.00f, -10000, 0.000f, -10000, 0.000f,   0.0f,   0.0f, 5000.0f

//
// I3DL2 source material presets
//

#define DSI3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800, 0.71f
#define DSI3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000, 0.40f
#define DSI3DL2_MATERIAL_PRESET_THINDOOR        -1800, 0.66f
#define DSI3DL2_MATERIAL_PRESET_THICKDOOR       -4400, 0.64f
#define DSI3DL2_MATERIAL_PRESET_WOODWALL        -4000, 0.50f
#define DSI3DL2_MATERIAL_PRESET_BRICKWALL       -5000, 0.60f
#define DSI3DL2_MATERIAL_PRESET_STONEWALL       -6000, 0.68f
#define DSI3DL2_MATERIAL_PRESET_CURTAIN         -1200, 0.15f

//
// MixBin identifiers
//

#define DSMIXBIN_FRONT_LEFT         0x00000001
#define DSMIXBIN_FRONT_RIGHT        0x00000002
#define DSMIXBIN_FRONT_CENTER       0x00000004
#define DSMIXBIN_LOW_FREQUENCY      0x00000008
#define DSMIXBIN_BACK_LEFT          0x00000010
#define DSMIXBIN_BACK_RIGHT         0x00000020
#define DSMIXBIN_SPEAKER_MASK       0x0000003F

#define DSMIXBIN_XTLK_FRONT_LEFT    0x00000040
#define DSMIXBIN_XTLK_FRONT_RIGHT   0x00000080
#define DSMIXBIN_XTLK_BACK_LEFT     0x00000100
#define DSMIXBIN_XTLK_BACK_RIGHT    0x00000200
#define DSMIXBIN_XTLK_MASK          0x000003C0

#define DSMIXBIN_I3DL2              0x00000400

#define DSMIXBIN_FXSEND_0           0x00000800
#define DSMIXBIN_FXSEND_1           0x00001000
#define DSMIXBIN_FXSEND_2           0x00002000
#define DSMIXBIN_FXSEND_3           0x00004000
#define DSMIXBIN_FXSEND_4           0x00008000
#define DSMIXBIN_FXSEND_5           0x00010000
#define DSMIXBIN_FXSEND_6           0x00020000
#define DSMIXBIN_FXSEND_7           0x00040000
#define DSMIXBIN_FXSEND_8           0x00080000
#define DSMIXBIN_FXSEND_9           0x00100000
#define DSMIXBIN_FXSEND_10          0x00200000
#define DSMIXBIN_FXSEND_11          0x00400000
#define DSMIXBIN_FXSEND_12          0x00800000
#define DSMIXBIN_FXSEND_13          0x01000000
#define DSMIXBIN_FXSEND_14          0x02000000
#define DSMIXBIN_FXSEND_15          0x04000000
#define DSMIXBIN_FXSEND_16          0x08000000
#define DSMIXBIN_FXSEND_17          0x10000000
#define DSMIXBIN_FXSEND_18          0x20000000
#define DSMIXBIN_FXSEND_19          0x40000000
#define DSMIXBIN_FXSEND_MASK        0x7FFFF800

//
// LFO identifiers
//

#define DSLFO_MULTI                 0x00000000      // Multi-function LFO
#define DSLFO_PITCH                 0x00000001      // Pitch-only LFO

//
// EG identifiers
//

#define DSEG_MULTI                  0x00000000      // Multi-function EG
#define DSEG_AMPLITUDE              0x00000001      // Amplitude-only EG

//
// EG modes
//

#define DSEG_MODE_DISABLE           0x00000000      // The envelope is disabled and the envelope value is always full-scale
#define DSEG_MODE_DELAY             0x00000001      // Starts with the envelope at zero amplitude with an initial delay
#define DSEG_MODE_ATTACK            0x00000002      // Bypasses the initial delay and goes directly to the attack envelope
#define DSEG_MODE_HOLD              0x00000003      // Bypasses the attack segment and immediately goes full scale

//
// Filter modes
//

#define DSFILTER_MODE_BYPASS        0x00000000      // The filter is bypassed
#define DSFILTER_MODE_DLS2          0x00000001      // DLS2 mode
#define DSFILTER_MODE_PARAMEQ       0x00000002      // Parametric equalizer mode
#define DSFILTER_MODE_MULTI         0x00000003      // Multifunction mode

//
// Effects parameter flags
//

#define DSFX_IMMEDIATE              0x00000000      // Apply the values immediately
#define DSFX_DEFERRED               0x00000001      // Defer the values until CommitEffectsData is called

//
// Effect index identifiers (for DSEFFECTIMAGELOC)
//

#define DSFX_IMAGELOC_UNUSED        0xFFFFFFFF      // The effect does not appear in the image

//
// AC'97 channel types
//

#define DSAC97_CHANNEL_ANALOG       0x00000000
#define DSAC97_CHANNEL_DIGITAL      0x00000001

//
// AC'97 digital channel modes
//

#define DSAC97_MODE_PCM             0x02000000
#define DSAC97_MODE_ENCODED         0x02000002

//
// AC'97 packet counts
//

#define DSAC97_MAX_ATTACHED_PACKETS 31

//
// WMA in-memory decoder data callback
//

typedef DWORD (CALLBACK *LPFNWMAXMODATACALLBACK)(LPVOID pvContext, DWORD dwOffset, DWORD dwByteCount, LPVOID *ppvData);

//
// API
//

STDAPI DirectSoundCreate(LPGUID pguidDeviceId, LPDIRECTSOUND *ppDirectSound, LPUNKNOWN pUnkOuter);
STDAPI DirectSoundCreateBuffer(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer);
STDAPI DirectSoundCreateStream(LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream);
STDAPI_(void) DirectSoundDoWork(void);
STDAPI_(void) DirectSoundUseFullHRTF(void);
STDAPI_(void) DirectSoundUseLightHRTF(void);

STDAPI WmaCreateDecoder(LPCSTR pszFileName, HANDLE hFile, BOOL fAsyncMode, DWORD dwLookaheadBufferSize, DWORD dwMaxPackets, DWORD dwYieldRate, LPWAVEFORMATEX pwfxCompressed, XFileMediaObject **ppMediaObject);
STDAPI WmaCreateInMemoryDecoder(LPFNWMAXMODATACALLBACK pfnCallback, LPVOID pvContext, DWORD dwYieldRate, LPWAVEFORMATEX pwfxCompressed, LPXMEDIAOBJECT *ppMediaObject);

STDAPI WmaCreateDecoderEx(LPCSTR pszFileName, HANDLE hFile, BOOL fAsyncMode, DWORD dwLookaheadBufferSize, DWORD dwMaxPackets, DWORD dwYieldRate, LPWAVEFORMATEX pwfxCompressed, XWmaFileMediaObject **ppMediaObject);
STDAPI WmaCreateInMemoryDecoderEx(LPFNWMAXMODATACALLBACK pfnCallback, LPVOID pvContext, DWORD dwYieldRate, LPWAVEFORMATEX pwfxCompressed, XWmaFileMediaObject **ppMediaObject);

STDAPI Ac97CreateMediaObject(DWORD dwChannel, LPFNXMEDIAOBJECTCALLBACK pfnCallback, LPVOID pvContext, LPAC97MEDIAOBJECT *ppMediaObject);

STDAPI XFileCreateMediaObject(LPCSTR pszFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, XFileMediaObject **ppMediaObject);
STDAPI XWaveFileCreateMediaObject(LPCSTR pszFileName, LPCWAVEFORMATEX *ppwfxFormat, XFileMediaObject **ppMediaObject);

//
// IUnknown
//

#ifndef IUnknown_AddRef
#if defined(__cplusplus) && !defined(CINTERFACE)
#define IUnknown_AddRef(p)  p->AddRef()
#else // defined(__cplusplus) && !defined(CINTERFACE)
#define IUnknown_AddRef(p)  p->lpVtbl->AddRef(p)
#endif // defined(__cplusplus) && !defined(CINTERFACE)
#endif // IUnknown_Addref

#ifndef IUnknown_Release
#if defined(__cplusplus) && !defined(CINTERFACE)
#define IUnknown_Release(p) p->Release()
#else // defined(__cplusplus) && !defined(CINTERFACE)
#define IUnknown_Release(p) p->lpVtbl->Release(p)
#endif // defined(__cplusplus) && !defined(CINTERFACE)
#endif // IUnknown_Release

//
// XMediaObject
//

#undef INTERFACE
#define INTERFACE XMediaObject

DECLARE_INTERFACE(XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;
};

#define XMediaObject_AddRef             IUnknown_AddRef
#define XMediaObject_Release            IUnknown_Release

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XMediaObject_GetInfo(p, a)      p->GetInfo(a)
#define XMediaObject_GetStatus(p, a)    p->GetStatus(a)
#define XMediaObject_Process(p, a, b)   p->Process(a, b)
#define XMediaObject_Discontinuity(p)   p->Discontinuity()
#define XMediaObject_Flush(p)           p->Flush()

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XMediaObject_GetInfo(p, a)      p->lpVtbl->GetInfo(p, a)
#define XMediaObject_GetStatus(p, a)    p->lpVtbl->GetStatus(p, a)
#define XMediaObject_Process(p, a, b)   p->lpVtbl->Process(p, a, b)
#define XMediaObject_Discontinuity(p)   p->lpVtbl->Discontinuity(p)
#define XMediaObject_Flush(p)           p->lpVtbl->Flush(p)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// XFileMediaObject
//

#undef INTERFACE
#define INTERFACE XFileMediaObject

DECLARE_INTERFACE_(XFileMediaObject, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XFileMediaObject methods
    STDMETHOD(Seek)(THIS_ LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute) PURE;
    STDMETHOD(GetLength)(THIS_ LPDWORD pdwLength) PURE;
};

#define XFileMediaObject_AddRef             IUnknown_AddRef
#define XFileMediaObject_Release            IUnknown_Release

#define XFileMediaObject_GetInfo            XMediaObject_GetInfo
#define XFileMediaObject_GetStatus          XMediaObject_GetStatus
#define XFileMediaObject_Process            XMediaObject_Process
#define XFileMediaObject_Discontinuity      XMediaObject_Discontinuity
#define XFileMediaObject_Flush              XMediaObject_Flush

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XFileMediaObject_Seek(p, a, b, c)   p->Seek(a, b, c)
#define XFileMediaObject_GetLength(p, a)    p->GetLength(a)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XFileMediaObject_Seek(p, a, b, c)   p->lpVtbl->Seek(p, a, b, c)
#define XFileMediaObject_GetLength(p, a)    p->lpVtbl->GetLength(p, a)

#endif // defined(__cplusplus) && !defined(CINTERFACE)


//
// WMA XMO definitions
//

#include <PSHPACK1.H>

typedef struct _WMAXMOFileContDesc
{
    /* *_len: as [in], they specify how large (in bytes) the corresponding
     *        buffers below are.
     *        as [out], they specify how large (in bytes) the returned
     *        strings actually are, including the zero WCHAR at the end
	 *        of the string.
     */

    WORD wTitleLength;
    WORD wAuthorLength;
    WORD wCopyrightLength;
    WORD wDescriptionLength;   /* rarely used */
    WORD wRatingLength;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */

    WCHAR* pTitle;
    WCHAR* pAuthor;
    WCHAR* pCopyright;
    WCHAR* pDescription;
    WCHAR* pRating;

} WMAXMOFileContDesc, *LPWMAXMOFileContDesc;

#include <POPPACK.H>

typedef struct _WMAXMOFileHeader
{
    DWORD dwVersion;		  /* version of the codec */
    DWORD dwSampleRate;		  /* sampling rate, Hz */
    DWORD dwNumChannels;	  /* number of audio channels */
    DWORD dwDuration;               /* of the file in milliseconds */
    DWORD dwBitrate;                /* bit-rate of the WMA bitstream */

} WMAXMOFileHeader;


//
// XWmaFileMediaObject
//

#undef INTERFACE
#define INTERFACE XWmaFileMediaObject

DECLARE_INTERFACE_(XWmaFileMediaObject, XFileMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XFileMediaObject methods
    STDMETHOD(Seek)(THIS_ LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute) PURE;
    STDMETHOD(GetLength)(THIS_ LPDWORD pdwLength) PURE;

    // XWmaFileMediaObject methods
    STDMETHOD(GetFileHeader)(THIS_ WMAXMOFileHeader* pFileHeader) PURE;
    STDMETHOD(GetFileContentDescription)(THIS_ WMAXMOFileContDesc* pContentDesc) PURE;
    
};

#define XWmaFileMediaObject_AddRef          IUnknown_AddRef
#define XWmaFileMediaObject_Release         IUnknown_Release

#define XWmaFileMediaObject_GetInfo         XMediaObject_GetInfo
#define XWmaFileMediaObject_GetStatus       XMediaObject_GetStatus
#define XWmaFileMediaObject_Process         XMediaObject_Process
#define XWmaFileMediaObject_Discontinuity   XMediaObject_Discontinuity
#define XWmaFileMediaObject_Flush           XMediaObject_Flush

#define XWmaFileMediaObject_Seek            XFileMediaObject_Seek
#define XWmaFileMediaObject_GetLength       XFileMediaOjbect_GetLength

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XWmaFileMediaObject_GetFileHeader(p, a)  p->GetFileHeader(a)
#define XWmaFileMediaObject_GetFileContentDescription(p, a)  p->GetFileContentDescription(a)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XWmaFileMediaObject_GetFileHeader(p, a)  p->lpVtbl->GetFileHeader(p, a)
#define XWmaFileMediaObject_GetFileContentDescription(p, a)  p->lpVtbl->GetFileContentDescription(p,a)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// IDirectSound
//

#if defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSound_QueryInterface(LPDIRECTSOUND pDirectSound, REFIID iid, LPVOID *ppvInterface);

#else // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSound_QueryInterfaceC(LPDIRECTSOUND pDirectSound, const IID *iid, LPVOID *ppvInterface);
#define IDirectSound_QueryInterface IDirectSound_QueryInterfaceC

#endif // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI_(ULONG) IDirectSound_AddRef(LPDIRECTSOUND pDirectSound);
STDAPI_(ULONG) IDirectSound_Release(LPDIRECTSOUND pDirectSound);
STDAPI IDirectSound_GetCaps(LPDIRECTSOUND pDirectSound, LPDSCAPS pdsc);
STDAPI IDirectSound_CreateSoundBuffer(LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter);
STDAPI IDirectSound_CreateSoundStream(LPDIRECTSOUND pDirectSound, LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter);
STDAPI IDirectSound_GetSpeakerConfig(LPDIRECTSOUND pDirectSound, LPDWORD pdwSpeakerConfig);
STDAPI IDirectSound_SetCooperativeLevel(LPDIRECTSOUND pDirectSound, HWND hWnd, DWORD dwLevel);
STDAPI IDirectSound_Compact(LPDIRECTSOUND pDirectSound);
STDAPI IDirectSound_DownloadEffectsImage(LPDIRECTSOUND pDirectSound, LPCVOID pvImageBuffer, DWORD dwImageSize, LPCDSEFFECTIMAGELOC pImageLoc, LPDSEFFECTIMAGEDESC *ppImageDesc);
STDAPI IDirectSound_GetEffectData(LPDIRECTSOUND pDirectSound, DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize);
STDAPI IDirectSound_SetEffectData(LPDIRECTSOUND pDirectSound, DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwApply);
STDAPI IDirectSound_CommitEffectData(LPDIRECTSOUND pDirectSound);
STDAPI IDirectSound_EnableHeadphones(LPDIRECTSOUND pDirectSound, BOOL fEnabled);
STDAPI IDirectSound_SetMixBinHeadroom(LPDIRECTSOUND pDirectSound, DWORD dwMixBinMask, DWORD dwHeadroom);
STDAPI IDirectSound_SetAllParameters(LPDIRECTSOUND pDirectSound, LPCDS3DLISTENER pds3dl, DWORD dwApply);
STDAPI IDirectSound_SetDistanceFactor(LPDIRECTSOUND pDirectSound, FLOAT flDistanceFactor, DWORD dwApply);
STDAPI IDirectSound_SetDopplerFactor(LPDIRECTSOUND pDirectSound, FLOAT flDopplerFactor, DWORD dwApply);
STDAPI IDirectSound_SetOrientation(LPDIRECTSOUND pDirectSound, FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop, DWORD dwApply);
STDAPI IDirectSound_SetPosition(LPDIRECTSOUND pDirectSound, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSound_SetRolloffFactor(LPDIRECTSOUND pDirectSound, FLOAT flRolloffFactor, DWORD dwApply);
STDAPI IDirectSound_SetVelocity(LPDIRECTSOUND pDirectSound, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSound_SetI3DL2Listener(LPDIRECTSOUND pDirectSound, LPCDSI3DL2LISTENER pds3dl, DWORD dwApply);
STDAPI IDirectSound_CommitDeferredSettings(LPDIRECTSOUND pDirectSound);
STDAPI IDirectSound_GetTime(LPDIRECTSOUND pDirectSound, REFERENCE_TIME *prtCurrent);

#if defined(__cplusplus) && !defined(CINTERFACE)

struct IDirectSound
{
    __inline HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return IDirectSound_QueryInterface(this, iid, ppvInterface);
    }

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectSound_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectSound_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE GetCaps(LPDSCAPS pdsc)
    {
        return IDirectSound_GetCaps(this, pdsc);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateSoundBuffer(LPCDSBUFFERDESC pdsbd, LPDIRECTSOUNDBUFFER *ppBuffer, LPUNKNOWN pUnkOuter)
    {
        return IDirectSound_CreateSoundBuffer(this, pdsbd, ppBuffer, pUnkOuter);
    }

    __inline HRESULT STDMETHODCALLTYPE CreateSoundStream(LPCDSSTREAMDESC pdssd, LPDIRECTSOUNDSTREAM *ppStream, LPUNKNOWN pUnkOuter)
    {
        return IDirectSound_CreateSoundStream(this, pdssd, ppStream, pUnkOuter);
    }

    __inline HRESULT STDMETHODCALLTYPE GetSpeakerConfig(LPDWORD pdwSpeakerConfig)
    {
        return IDirectSound_GetSpeakerConfig(this, pdwSpeakerConfig);
    }

    __inline HRESULT STDMETHODCALLTYPE SetCooperativeLevel(HWND hWnd, DWORD dwLevel)
    {
        return IDirectSound_SetCooperativeLevel(this, hWnd, dwLevel);
    }

    __inline HRESULT STDMETHODCALLTYPE Compact(void)
    {
        return IDirectSound_Compact(this);
    }

    __inline HRESULT STDMETHODCALLTYPE DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPCDSEFFECTIMAGELOC pImageLoc, LPDSEFFECTIMAGEDESC *ppImageDesc)
    {
        return IDirectSound_DownloadEffectsImage(this, pvImageBuffer, dwImageSize, pImageLoc, ppImageDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize)
    {
        return IDirectSound_GetEffectData(this, dwEffectIndex, dwOffset, pvData, dwDataSize);
    }

    __inline HRESULT STDMETHODCALLTYPE SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwApply)
    {
        return IDirectSound_SetEffectData(this, dwEffectIndex, dwOffset, pvData, dwDataSize, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE CommitEffectData(void)
    {
        return IDirectSound_CommitEffectData(this);
    }

    __inline HRESULT STDMETHODCALLTYPE EnableHeadphones(BOOL fEnabled)
    {
        return IDirectSound_EnableHeadphones(this, fEnabled);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBinHeadroom(DWORD dwMixBinMask, DWORD dwHeadroom)
    {
        return IDirectSound_SetMixBinHeadroom(this, dwMixBinMask, dwHeadroom);
    }

    __inline HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DLISTENER pds3dl, DWORD dwApply)
    {
        return IDirectSound_SetAllParameters(this, pds3dl, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDistanceFactor(FLOAT flDistanceFactor, DWORD dwApply)
    {
        return IDirectSound_SetDistanceFactor(this, flDistanceFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetDopplerFactor(FLOAT flDopplerFactor, DWORD dwApply)
    {
        return IDirectSound_SetDopplerFactor(this, flDopplerFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetOrientation(FLOAT xFront, FLOAT yFront, FLOAT zFront, FLOAT xTop, FLOAT yTop, FLOAT zTop, DWORD dwApply)
    {
        return IDirectSound_SetOrientation(this, xFront, yFront, zFront, xTop, yTop, zTop, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSound_SetPosition(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetRolloffFactor(FLOAT flRolloffFactor, DWORD dwApply)
    {
        return IDirectSound_SetRolloffFactor(this, flRolloffFactor, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSound_SetVelocity(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetI3DL2Listener(LPCDSI3DL2LISTENER pds3dl, DWORD dwApply)
    {
        return IDirectSound_SetI3DL2Listener(this, pds3dl, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE CommitDeferredSettings(void)
    {
        return IDirectSound_CommitDeferredSettings(this);
    }

    __inline HRESULT STDMETHODCALLTYPE GetTime(REFERENCE_TIME *prtCurrent)
    {
        return IDirectSound_GetTime(this, prtCurrent);
    }
};

#endif // defined(__cplusplus) && !defined(CINTERFACE)

#define IDirectSound8_QueryInterface                        IDirectSound_QueryInterface
#define IDirectSound8_AddRef                                IDirectSound_AddRef
#define IDirectSound8_Release                               IDirectSound_Release
#define IDirectSound8_GetCaps                               IDirectSound_GetCaps
#define IDirectSound8_CreateSoundBuffer                     IDirectSound_CreateSoundBuffer
#define IDirectSound8_GetSpeakerConfig                      IDirectSound_GetSpeakerConfig
#define IDirectSound8_Compact                               IDirectSound_Compact
#define IDirectSound8_SetCooperativeLevel                   IDirectSound_SetCooperativeLevel

#define IDirectSound3DListener_QueryInterface               IDirectSound_QueryInterface
#define IDirectSound3DListener_AddRef                       IDirectSound_AddRef
#define IDirectSound3DListener_Release                      IDirectSound_Release
#define IDirectSound3DListener_SetAllParameters             IDirectSound_SetAllParameters
#define IDirectSound3DListener_SetDistanceFactor            IDirectSound_SetDistanceFactor
#define IDirectSound3DListener_SetDopplerFactor             IDirectSound_SetDopplerFactor
#define IDirectSound3DListener_SetOrientation               IDirectSound_SetOrientation
#define IDirectSound3DListener_SetPosition                  IDirectSound_SetPosition
#define IDirectSound3DListener_SetRolloffFactor             IDirectSound_SetRolloffFactor
#define IDirectSound3DListener_SetVelocity                  IDirectSound_SetVelocity
#define IDirectSound3DListener_CommitDeferredSettings       IDirectSound_CommitDeferredSettings

#define IReferenceClock_QueryInterface                      IDirectSound_QueryInterface
#define IReferenceClock_AddRef                              IDirectSound_AddRef
#define IReferenceClock_Release                             IDirectSound_Release
#define IReferenceClock_GetTime                             IDirectSound_GetTime

//
// IDirectSoundBuffer
//

#if defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundBuffer_QueryInterface(LPDIRECTSOUNDBUFFER pBuffer, REFIID iid, LPVOID *ppvInterface);

#else // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundBuffer_QueryInterfaceC(LPDIRECTSOUNDBUFFER pBuffer, const IID *iid, LPVOID *ppvInterface);
#define IDirectSoundBuffer_QueryInterface IDirectSoundBuffer_QueryInterfaceC

#endif // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI_(ULONG) IDirectSoundBuffer_AddRef(LPDIRECTSOUNDBUFFER pBuffer);
STDAPI_(ULONG) IDirectSoundBuffer_Release(LPDIRECTSOUNDBUFFER pBuffer);
STDAPI IDirectSoundBuffer_SetFrequency(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwFrequency);
STDAPI IDirectSoundBuffer_SetVolume(LPDIRECTSOUNDBUFFER pBuffer, LONG lVolume);
STDAPI IDirectSoundBuffer_SetPitch(LPDIRECTSOUNDBUFFER pBuffer, LONG lPitch);
STDAPI IDirectSoundBuffer_SetLFO(LPDIRECTSOUNDBUFFER pBuffer, LPCDSLFODESC pLFODesc);
STDAPI IDirectSoundBuffer_SetEG(LPDIRECTSOUNDBUFFER pBuffer, LPCDSENVELOPEDESC pEnvelopeDesc);
STDAPI IDirectSoundBuffer_SetFilter(LPDIRECTSOUNDBUFFER pBuffer, LPCDSFILTERDESC pFilterDesc);
STDAPI IDirectSoundBuffer_SetHeadroom(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwHeadroom);
STDAPI IDirectSoundBuffer_SetOutputBuffer(LPDIRECTSOUNDBUFFER pBuffer, LPDIRECTSOUNDBUFFER pOutputBuffer);
STDAPI IDirectSoundBuffer_SetMixBins(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwMixBinMask);
STDAPI IDirectSoundBuffer_SetMixBinVolumes(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwMixBinMask, const LONG *alVolumes);
STDAPI IDirectSoundBuffer_SetAllParameters(LPDIRECTSOUNDBUFFER pBuffer, LPCDS3DBUFFER pds3db, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetConeAngles(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetConeOrientation(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetConeOutsideVolume(LPDIRECTSOUNDBUFFER pBuffer, LONG lConeOutsideVolume, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetMaxDistance(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flMaxDistance, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetMinDistance(LPDIRECTSOUNDBUFFER pBuffer, FLOAT flMinDistance, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetMode(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwMode, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetPosition(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetVelocity(LPDIRECTSOUNDBUFFER pBuffer, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundBuffer_SetI3DL2Source(LPDIRECTSOUNDBUFFER pBuffer, LPCDSI3DL2BUFFER pds3db, DWORD dwApply);
STDAPI IDirectSoundBuffer_Play(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags);
STDAPI IDirectSoundBuffer_PlayEx(LPDIRECTSOUNDBUFFER pBuffer, REFERENCE_TIME rtTimeStamp, DWORD dwFlags);
STDAPI IDirectSoundBuffer_Stop(LPDIRECTSOUNDBUFFER pBuffer);
STDAPI IDirectSoundBuffer_StopEx(LPDIRECTSOUNDBUFFER pBuffer, REFERENCE_TIME rtTimeStamp, DWORD dwFlags);
STDAPI IDirectSoundBuffer_SetLoopRegion(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwLoopStart, DWORD dwLoopLength);
STDAPI IDirectSoundBuffer_GetStatus(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwStatus);
STDAPI IDirectSoundBuffer_GetCurrentPosition(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor);
STDAPI IDirectSoundBuffer_SetCurrentPosition(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwPlayCursor);
STDAPI IDirectSoundBuffer_SetBufferData(LPDIRECTSOUNDBUFFER pBuffer, LPVOID pvBufferData, DWORD dwBufferBytes);
STDAPI IDirectSoundBuffer_Lock(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags);
STDAPI IDirectSoundBuffer_Unlock(LPDIRECTSOUNDBUFFER pBuffer, LPVOID pvLock1, DWORD dwLockSize1, LPVOID pvLock2, DWORD dwLockSize2);
STDAPI IDirectSoundBuffer_Restore(LPDIRECTSOUNDBUFFER pBuffer);
STDAPI IDirectSoundBuffer_SetNotificationPositions(LPDIRECTSOUNDBUFFER pBuffer, DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies);

#if defined(__cplusplus) && !defined(CINTERFACE)                

struct IDirectSoundBuffer
{
    __inline HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return IDirectSoundBuffer_QueryInterface(this, iid, ppvInterface);
    }

    __inline ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return IDirectSoundBuffer_AddRef(this);
    }

    __inline ULONG STDMETHODCALLTYPE Release(void)
    {
        return IDirectSoundBuffer_Release(this);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFrequency(DWORD dwFrequency)
    {
        return IDirectSoundBuffer_SetFrequency(this, dwFrequency);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVolume(LONG lVolume)
    {
        return IDirectSoundBuffer_SetVolume(this, lVolume);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPitch(LONG lPitch)
    {
        return IDirectSoundBuffer_SetPitch(this, lPitch);
    }

    __inline HRESULT STDMETHODCALLTYPE SetLFO(LPCDSLFODESC pLFODesc)
    {
        return IDirectSoundBuffer_SetLFO(this, pLFODesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetEG(LPCDSENVELOPEDESC pEnvelopeDesc)
    {
        return IDirectSoundBuffer_SetEG(this, pEnvelopeDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFilter(LPCDSFILTERDESC pFilterDesc)
    {
        return IDirectSoundBuffer_SetFilter(this, pFilterDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetHeadroom(DWORD dwHeadroom)
    {
        return IDirectSoundBuffer_SetHeadroom(this, dwHeadroom);
    }

    __inline HRESULT STDMETHODCALLTYPE SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer)
    {
        return IDirectSoundBuffer_SetOutputBuffer(this, pOutputBuffer);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBins(DWORD dwMixBinMask)
    {
        return IDirectSoundBuffer_SetMixBins(this, dwMixBinMask);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBinVolumes(DWORD dwMixBinMask, const LONG *alVolumes)
    {
        return IDirectSoundBuffer_SetMixBinVolumes(this, dwMixBinMask, alVolumes);
    }

    __inline HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetAllParameters(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetConeAngles(this, dwInsideConeAngle, dwOutsideConeAngle, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetConeOrientation(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetConeOutsideVolume(this, lConeOutsideVolume, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMaxDistance(FLOAT flMaxDistance, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetMaxDistance(this, flMaxDistance, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMinDistance(FLOAT flMinDistance, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetMinDistance(this, flMinDistance, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetMode(this, dwMode, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetPosition(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetVelocity(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwApply)
    {
        return IDirectSoundBuffer_SetI3DL2Source(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE Play(DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags)
    {   
        return IDirectSoundBuffer_Play(this, dwReserved1, dwReserved2, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE PlayEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return IDirectSoundBuffer_PlayEx(this, rtTimeStamp, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Stop(void)
    {
        return IDirectSoundBuffer_Stop(this);
    }

    __inline HRESULT STDMETHODCALLTYPE StopEx(REFERENCE_TIME rtTimeStamp, DWORD dwFlags)
    {
        return IDirectSoundBuffer_StopEx(this, rtTimeStamp, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE SetLoopRegion(DWORD dwLoopStart, DWORD dwLoopLength)
    {
        return IDirectSoundBuffer_SetLoopRegion(this, dwLoopStart, dwLoopLength);
    }

    __inline HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus)
    {
        return IDirectSoundBuffer_GetStatus(this, pdwStatus);
    }

    __inline HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor)
    {
        return IDirectSoundBuffer_GetCurrentPosition(this, pdwPlayCursor, pdwWriteCursor);
    }

    __inline HRESULT STDMETHODCALLTYPE SetCurrentPosition(DWORD dwPlayCursor)
    {
        return IDirectSoundBuffer_SetCurrentPosition(this, dwPlayCursor);
    }

    __inline HRESULT STDMETHODCALLTYPE SetBufferData(LPVOID pvBufferData, DWORD dwBufferBytes)
    {
        return IDirectSoundBuffer_SetBufferData(this, pvBufferData, dwBufferBytes);
    }

    __inline HRESULT STDMETHODCALLTYPE Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
    {
        return IDirectSoundBuffer_Lock(this, dwOffset, dwBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
    }

    __inline HRESULT STDMETHODCALLTYPE Unlock(LPVOID pvLock1, DWORD dwLockSize1, LPVOID pvLock2, DWORD dwLockSize2)
    {
        return IDirectSoundBuffer_Unlock(this, pvLock1, dwLockSize1, pvLock2, dwLockSize2);
    }

    __inline HRESULT STDMETHODCALLTYPE Restore(void)
    {
        return IDirectSoundBuffer_Restore(this);
    }

    __inline HRESULT STDMETHODCALLTYPE SetNotificationPositions(DWORD dwNotifyCount, LPCDSBPOSITIONNOTIFY paNotifies)
    {
        return IDirectSoundBuffer_SetNotificationPositions(this, dwNotifyCount, paNotifies);
    }
};

#endif // defined(__cplusplus) && !defined(CINTERFACE)                

#define IDirectSoundBuffer8_QueryInterface          IDirectSoundBuffer_QueryInterface
#define IDirectSoundBuffer8_AddRef                  IDirectSoundBuffer_AddRef
#define IDirectSoundBuffer8_Release                 IDirectSoundBuffer_Release
#define IDirectSoundBuffer8_Play                    IDirectSoundBuffer_Play              
#define IDirectSoundBuffer8_Stop                    IDirectSoundBuffer_Stop              
#define IDirectSoundBuffer8_GetStatus               IDirectSoundBuffer_GetStatus         
#define IDirectSoundBuffer8_GetCurrentPosition      IDirectSoundBuffer_GetCurrentPosition
#define IDirectSoundBuffer8_SetCurrentPosition      IDirectSoundBuffer_SetCurrentPosition
#define IDirectSoundBuffer8_Lock                    IDirectSoundBuffer_Lock              
#define IDirectSoundBuffer8_SetFrequency            IDirectSoundBuffer_SetFrequency
#define IDirectSoundBuffer8_SetVolume               IDirectSoundBuffer_SetVolume         
                                                    
#define IDirectSound3DBuffer_QueryInterface         IDirectSoundBuffer_QueryInterface
#define IDirectSound3DBuffer_AddRef                 IDirectSoundBuffer_AddRef
#define IDirectSound3DBuffer_Release                IDirectSoundBuffer_Release
#define IDirectSound3DBuffer_SetAllParameters       IDirectSoundBuffer_SetAllParameters  
#define IDirectSound3DBuffer_SetConeAngles          IDirectSoundBuffer_SetConeAngles     
#define IDirectSound3DBuffer_SetConeOrientation     IDirectSoundBuffer_SetConeOrientation
#define IDirectSound3DBuffer_SetConeOutsideVolume   IDirectSoundBuffer_SetConeOutsideVolume
#define IDirectSound3DBuffer_SetMaxDistance         IDirectSoundBuffer_SetMaxDistance    
#define IDirectSound3DBuffer_SetMinDistance         IDirectSoundBuffer_SetMinDistance    
#define IDirectSound3DBuffer_SetMode                IDirectSoundBuffer_SetMode           
#define IDirectSound3DBuffer_SetPosition            IDirectSoundBuffer_SetPosition       
#define IDirectSound3DBuffer_SetVelocity            IDirectSoundBuffer_SetVelocity       
                                                    
#define IDirectSoundNotify_QueryInterface           IDirectSoundBuffer_QueryInterface
#define IDirectSoundNotify_AddRef                   IDirectSoundBuffer_AddRef
#define IDirectSoundNotify_Release                  IDirectSoundBuffer_Release
#define IDirectSoundNotify_SetNotificationPositions IDirectSoundBuffer_SetNotificationPositions

//
// IDirectSoundStream
//

#if defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundStream_QueryInterface(LPDIRECTSOUNDSTREAM pStream, REFIID iid, LPVOID *ppvInterface);

#else // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundStream_QueryInterfaceC(LPDIRECTSOUNDSTREAM pStream, const IID *iid, LPVOID *ppvInterface);
#define IDirectSoundStream_QueryInterface IDirectSoundStream_QueryInterfaceC

#endif // defined(__cplusplus) && !defined(CINTERFACE)

STDAPI IDirectSoundStream_SetFrequency(LPDIRECTSOUNDSTREAM pStream, DWORD dwFrequency);
STDAPI IDirectSoundStream_SetVolume(LPDIRECTSOUNDSTREAM pStream, LONG lVolume);
STDAPI IDirectSoundStream_SetPitch(LPDIRECTSOUNDSTREAM pStream, LONG lPitch);
STDAPI IDirectSoundStream_SetLFO(LPDIRECTSOUNDSTREAM pStream, LPCDSLFODESC pLFODesc);
STDAPI IDirectSoundStream_SetEG(LPDIRECTSOUNDSTREAM pStream, LPCDSENVELOPEDESC pEnvelopeDesc);
STDAPI IDirectSoundStream_SetFilter(LPDIRECTSOUNDSTREAM pStream, LPCDSFILTERDESC pFilterDesc);
STDAPI IDirectSoundStream_SetHeadroom(LPDIRECTSOUNDSTREAM pStream, DWORD dwHeadroom);
STDAPI IDirectSoundStream_SetOutputBuffer(LPDIRECTSOUNDSTREAM pStream, LPDIRECTSOUNDBUFFER pOutputBuffer);
STDAPI IDirectSoundStream_SetMixBins(LPDIRECTSOUNDSTREAM pStream, DWORD dwMixBinMask);
STDAPI IDirectSoundStream_SetMixBinVolumes(LPDIRECTSOUNDSTREAM pStream, DWORD dwMixBinMask, const LONG *alVolumes);
STDAPI IDirectSoundStream_SetAllParameters(LPDIRECTSOUNDSTREAM pStream, LPCDS3DBUFFER pds3db, DWORD dwApply);
STDAPI IDirectSoundStream_SetConeAngles(LPDIRECTSOUNDSTREAM pStream, DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply);
STDAPI IDirectSoundStream_SetConeOrientation(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundStream_SetConeOutsideVolume(LPDIRECTSOUNDSTREAM pStream, LONG lConeOutsideVolume, DWORD dwApply);
STDAPI IDirectSoundStream_SetMaxDistance(LPDIRECTSOUNDSTREAM pStream, FLOAT flMaxDistance, DWORD dwApply);
STDAPI IDirectSoundStream_SetMinDistance(LPDIRECTSOUNDSTREAM pStream, FLOAT flMinDistance, DWORD dwApply);
STDAPI IDirectSoundStream_SetMode(LPDIRECTSOUNDSTREAM pStream, DWORD dwMode, DWORD dwApply);
STDAPI IDirectSoundStream_SetPosition(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundStream_SetVelocity(LPDIRECTSOUNDSTREAM pStream, FLOAT x, FLOAT y, FLOAT z, DWORD dwApply);
STDAPI IDirectSoundStream_Pause(LPDIRECTSOUNDSTREAM pStream, DWORD dwPause);
STDAPI IDirectSoundStream_SetI3DL2Source(LPDIRECTSOUNDSTREAM pStream, LPCDSI3DL2BUFFER pds3db, DWORD dwApply);

#define IDirectSoundStream_AddRef           IUnknown_AddRef
#define IDirectSoundStream_Release          IUnknown_Release

#define IDirectSoundStream_GetInfo          XMediaObject_GetInfo
#define IDirectSoundStream_GetStatus        XMediaObject_GetStatus
#define IDirectSoundStream_Process          XMediaObject_Process
#define IDirectSoundStream_Discontinuity    XMediaObject_Discontinuity
#define IDirectSoundStream_Flush            XMediaObject_Flush

#undef INTERFACE
#define INTERFACE IDirectSoundStream

DECLARE_INTERFACE_(IDirectSoundStream, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

#if defined(__cplusplus) && !defined(CINTERFACE)

    __inline HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, LPVOID *ppvInterface)
    {
        return IDirectSoundStream_QueryInterface(this, iid, ppvInterface);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFrequency(DWORD dwFrequency)
    {
        return IDirectSoundStream_SetFrequency(this, dwFrequency);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVolume(LONG lVolume)
    {
        return IDirectSoundStream_SetVolume(this, lVolume);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPitch(LONG lPitch)
    {
        return IDirectSoundStream_SetPitch(this, lPitch);
    }

    __inline HRESULT STDMETHODCALLTYPE SetLFO(LPCDSLFODESC pLFODesc)
    {
        return IDirectSoundStream_SetLFO(this, pLFODesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetEG(LPCDSENVELOPEDESC pEnvelopeDesc)
    {
        return IDirectSoundStream_SetEG(this, pEnvelopeDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetFilter(LPCDSFILTERDESC pFilterDesc)
    {
        return IDirectSoundStream_SetFilter(this, pFilterDesc);
    }

    __inline HRESULT STDMETHODCALLTYPE SetHeadroom(DWORD dwHeadroom)
    {
        return IDirectSoundStream_SetHeadroom(this, dwHeadroom);
    }

    __inline HRESULT STDMETHODCALLTYPE SetOutputBuffer(LPDIRECTSOUNDBUFFER pOutputBuffer)
    {
        return IDirectSoundStream_SetOutputBuffer(this, pOutputBuffer);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBins(DWORD dwMixBinMask)
    {
        return IDirectSoundStream_SetMixBins(this, dwMixBinMask);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMixBinVolumes(DWORD dwMixBinMask, const LONG *alVolumes)
    {
        return IDirectSoundStream_SetMixBinVolumes(this, dwMixBinMask, alVolumes);
    }

    __inline HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER pds3db, DWORD dwApply)
    {
        return IDirectSoundStream_SetAllParameters(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply)
    {
        return IDirectSoundStream_SetConeAngles(this, dwInsideConeAngle, dwOutsideConeAngle, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOrientation(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundStream_SetConeOrientation(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG lConeOutsideVolume, DWORD dwApply)
    {
        return IDirectSoundStream_SetConeOutsideVolume(this, lConeOutsideVolume, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMaxDistance(FLOAT flMaxDistance, DWORD dwApply)
    {
        return IDirectSoundStream_SetMaxDistance(this, flMaxDistance, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMinDistance(FLOAT flMinDistance, DWORD dwApply)
    {
        return IDirectSoundStream_SetMinDistance(this, flMinDistance, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode, DWORD dwApply)
    {
        return IDirectSoundStream_SetMode(this, dwMode, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetI3DL2Source(LPCDSI3DL2BUFFER pds3db, DWORD dwApply)
    {
        return IDirectSoundStream_SetI3DL2Source(this, pds3db, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetPosition(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundStream_SetPosition(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE SetVelocity(FLOAT x, FLOAT y, FLOAT z, DWORD dwApply)
    {
        return IDirectSoundStream_SetVelocity(this, x, y, z, dwApply);
    }

    __inline HRESULT STDMETHODCALLTYPE Pause(DWORD dwPause)
    {
        return IDirectSoundStream_Pause(this, dwPause);
    }

#endif // defined(__cplusplus) && !defined(CINTERFACE)

};

//
// XAc97MediaObject
//

#undef INTERFACE
#define INTERFACE XAc97MediaObject

DECLARE_INTERFACE_(XAc97MediaObject, XMediaObject)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // XMediaObject methods
    STDMETHOD(GetInfo)(THIS_ LPXMEDIAINFO pInfo) PURE;
    STDMETHOD(GetStatus)(THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Process)(THIS_ LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket) PURE;
    STDMETHOD(Discontinuity)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;

    // XAc97MediaObject methods
    STDMETHOD(SetMode)(THIS_ DWORD dwMode) PURE;
    STDMETHOD(GetCurrentPosition)(THIS_ LPDWORD pdwMode) PURE;
};

#define XAc97MediaObject_AddRef                     IUnknown_AddRef
#define XAc97MediaObject_Release                    IUnknown_Release
                                                    
#define XAc97MediaObject_GetInfo                    XMediaObject_GetInfo
#define XAc97MediaObject_GetStatus                  XMediaObject_GetStatus
#define XAc97MediaObject_Process                    XMediaObject_Process
#define XAc97MediaObject_Discontinuity              XMediaObject_Discontinuity
#define XAc97MediaObject_Flush                      XMediaObject_Flush

#if defined(__cplusplus) && !defined(CINTERFACE)

#define XAc97MediaObject_SetMode(p, a)              p->SetMode(a)
#define XAc97MediaObject_GetCurrentPosition(p, a)   p->GetCurrentPosition(a)

#else // defined(__cplusplus) && !defined(CINTERFACE)

#define XAc97MediaObject_SetMode(p, a)              p->lpVtbl->SetMode(p, a)
#define XAc97MediaObject_GetCurrentPosition(p, a)   p->lpVtbl->GetCurrentPosition(p, a)

#endif // defined(__cplusplus) && !defined(CINTERFACE)

//
// Multimedia timer support
//

#define MMSYSERR_BASE               0
#define MMSYSERR_NOERROR            0                   // No error

#define TIMERR_BASE                 96
#define TIMERR_NOERROR              (0)                 // No error
#define TIMERR_NOCANDO              (TIMERR_BASE+1)     // Request not completed
#define TIMERR_STRUCT               (TIMERR_BASE+33)    // Time struct size

#define TIME_MS                     0x0001              // Time in milliseconds
#define TIME_SAMPLES                0x0002              // Number of wave samples
#define TIME_BYTES                  0x0004              // Current byte offset
#define TIME_SMPTE                  0x0008              // SMPTE time
#define TIME_MIDI                   0x0010              // MIDI time
#define TIME_TICKS                  0x0020              // Ticks within MIDI stream

#define TIME_ONESHOT                0x0000              // Program timer for single event
#define TIME_PERIODIC               0x0001              // Program for continuous periodic event

#define TIME_CALLBACK_FUNCTION      0x0000              // Callback is function
#define TIME_CALLBACK_EVENT_SET     0x0010              // Callback is event - use SetEvent
#define TIME_CALLBACK_EVENT_PULSE   0x0020              // Callback is event - use PulseEvent

typedef void (CALLBACK TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);

typedef TIMECALLBACK *LPTIMECALLBACK;

typedef struct mmtime_tag
{
    UINT            wType;                  // Indicates the contents of the union
    union
    {
        DWORD       ms;                     // Milliseconds
        DWORD       sample;                 // Samples
        DWORD       cb;                     // Byte count
        DWORD       ticks;                  // Ticks in MIDI stream

        struct
        {
            BYTE    hour;                   // Hours
            BYTE    min;                    // Minutes
            BYTE    sec;                    // Seconds
            BYTE    frame;                  // Frames
            BYTE    fps;                    // Frames per second
            BYTE    dummy;                  // Pad
            BYTE    pad[2];
        } smpte;

        struct
        {
            DWORD songptrpos;               // Song pointer position
        } midi;
    } u;
} MMTIME, *PMMTIME, *LPMMTIME;

typedef const MMTIME *LPCMMTIME;

typedef UINT MMRESULT;

EXTERN_C MMRESULT WINAPI timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt);
EXTERN_C MMRESULT WINAPI timeSetEvent(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD dwUser, UINT fuEvent);
EXTERN_C MMRESULT WINAPI timeKillEvent(UINT uTimerID);

#define timeGetTime GetTickCount

#pragma warning(default:4201)

#endif // __DSOUND_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\dsfxparm.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsfxparm.h
 *  Content:    DirectSound effect parameters.
 *
 ****************************************************************************/

#ifndef __DSFXPARM_H__
#define __DSFXPARM_H__

//
// State flags
//

#define DSFX_STATE_INITIALIZED  0x00000001
#define DSFX_STATE_GLOBAL       0x00000002
#define DSFX_STATE_UPDATE       0x00000004

//
// Amplitude modulation (mono)
//

typedef struct _DSFX_AMPMOD_MONO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_AMPMOD_MONO_STATE, *LPDSFX_AMPMOD_MONO_STATE;

typedef const DSFX_AMPMOD_MONO_STATE *LPCDSFX_AMPMOD_MONO_STATE;

typedef struct _DSFX_AMPMOD_MONO_PARAMS
{
    DSFX_AMPMOD_MONO_STATE  State;
} DSFX_AMPMOD_MONO_PARAMS, *LPDSFX_AMPMOD_MONO_PARAMS;

typedef const DSFX_AMPMOD_MONO_PARAMS *LPCDSFX_AMPMOD_MONO_PARAMS;

//
// Amplitude modulation (stereo)
//

typedef struct _DSFX_AMPMOD_STEREO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[3];
    DWORD       dwOutMixbinPtrs[2];
} DSFX_AMPMOD_STEREO_STATE, *LPDSFX_AMPMOD_STEREO_STATE;

typedef const DSFX_AMPMOD_STEREO_STATE *LPCDSFX_AMPMOD_STEREO_STATE;

typedef struct _DSFX_AMPMOD_STEREO_PARAMS
{
    DSFX_AMPMOD_STEREO_STATE    State;
} DSFX_AMPMOD_STEREO_PARAMS, *LPDSFX_AMPMOD_STEREO_PARAMS;

typedef const DSFX_AMPMOD_STEREO_PARAMS *LPCDSFX_AMPMOD_STEREO_PARAMS;

//
// Chorus (mono)
//

typedef struct _DSFX_CHORUS_MONO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_CHORUS_MONO_STATE, *LPDSFX_CHORUS_MONO_STATE;

typedef const DSFX_CHORUS_MONO_STATE *LPCDSFX_CHORUS_MONO_STATE;

typedef struct _DSFX_CHORUS_MONO_PARAMS
{
    DSFX_CHORUS_MONO_STATE  State;
    DWORD                   dwGain;
    DWORD                   dwModScale;
} DSFX_CHORUS_MONO_PARAMS, *LPDSFX_CHORUS_MONO_PARAMS;

typedef const DSFX_CHORUS_MONO_PARAMS *LPCDSFX_CHORUS_MONO_PARAMS;

//
// Chorus (stereo)
//

typedef struct _DSFX_CHORUS_STEREO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[3];
    DWORD       dwOutMixbinPtrs[2];
} DSFX_CHORUS_STEREO_STATE, *LPDSFX_CHORUS_STEREO_STATE;

typedef const DSFX_CHORUS_STEREO_STATE *LPCDSFX_CHORUS_STEREO_STATE;

typedef struct _DSFX_CHORUS_STEREO_PARAMS
{
    DSFX_CHORUS_STEREO_STATE    State;
    DWORD                       dwGain;
    DWORD                       dwModScale;
} DSFX_CHORUS_STEREO_PARAMS, *LPDSFX_CHORUS_STEREO_PARAMS;

typedef const DSFX_CHORUS_STEREO_PARAMS *LPCDSFX_CHORUS_STEREO_PARAMS;


//
// Distortion
//

typedef struct _DSFX_DISTORTION_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_DISTORTION_STATE, *LPDSFX_DISTORTION_STATE;

typedef const DSFX_DISTORTION_STATE *LPCDSFX_DISTORTION_STATE;

typedef struct _DSFX_DISTORTION_PARAMS
{
    DSFX_DISTORTION_STATE   State;
    DWORD                   dwGain;
    DWORD                   dwPreFilterB0;
    DWORD                   dwPreFilterB1;
    DWORD                   dwPreFilterB2;
    DWORD                   dwPreFilterA1;
    DWORD                   dwPreFilterA2;
    DWORD                   dwPostFilterB0;
    DWORD                   dwPostFilterB1;
    DWORD                   dwPostFilterB2;
    DWORD                   dwPostFilterA1;
    DWORD                   dwPostFilterA2;
} DSFX_DISTORTION_PARAMS, *LPDSFX_DISTORTION_PARAMS;

typedef const DSFX_DISTORTION_PARAMS *LPCDSFX_DISTORTION_PARAMS;

//
// Echo (mono)
//

typedef struct _DSFX_ECHO_MONO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_ECHO_MONO_STATE, *LPDSFX_ECHO_MONO_STATE;

typedef const DSFX_ECHO_MONO_STATE *LPCDSFX_ECHO_MONO_STATE;

typedef struct _DSFX_ECHO_MONO_PARAMS
{
    DSFX_ECHO_MONO_STATE    State;
    DWORD                   dwGain;
} DSFX_ECHO_MONO_PARAMS, *LPDSFX_ECHO_MONO_PARAMS;

typedef const DSFX_ECHO_MONO_PARAMS *LPCDSFX_ECHO_MONO_PARAMS;

//
// Echo (stereo)
//

typedef struct _DSFX_ECHO_STEREO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[2];
} DSFX_ECHO_STEREO_STATE, *LPDSFX_ECHO_STEREO_STATE;

typedef const DSFX_ECHO_STEREO_STATE *LPCDSFX_ECHO_STEREO_STATE;

typedef struct _DSFX_ECHO_STEREO_PARAMS
{
    DSFX_ECHO_STEREO_STATE  State;
    DWORD                   dwGain;
} DSFX_ECHO_STEREO_PARAMS, *LPDSFX_ECHO_STEREO_PARAMS;

typedef const DSFX_ECHO_STEREO_PARAMS *LPCDSFX_ECHO_STEREO_PARAMS;

//
// second order IIR filter, can be used as bandbass(or single band param EQ)
//

typedef struct _DSFX_IIR2_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_IIR2_STATE, *LPDSFX_IIR2_STATE;

typedef const DSFX_IIR2_STATE *LPCDSFX_IIR2_STATE;

typedef struct _DSFX_IIR2_PARAMS
{
    DSFX_IIR2_STATE  State;
    DWORD                   dwFilterB0;
    DWORD                   dwFilterB1;
    DWORD                   dwFilterB2;
    DWORD                   dwFilterA1;
    DWORD                   dwFilterA2;    

} DSFX_IIR2_PARAMS, *LPDSFX_IIR2_PARAMS;

typedef const DSFX_IIR2_PARAMS *LPCDSFX_IIR2_PARAMS;

//
// Flange (mono)
//

typedef struct _DSFX_FLANGE_MONO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_FLANGE_MONO_STATE, *LPDSFX_FLANGE_MONO_STATE;

typedef const DSFX_FLANGE_MONO_STATE *LPCDSFX_FLANGE_MONO_STATE;

typedef struct _DSFX_FLANGE_MONO_PARAMS
{
    DSFX_FLANGE_MONO_STATE  State;
    DWORD                   dwFeedback;
    DWORD                   dwModScale;
} DSFX_FLANGE_MONO_PARAMS, *LPDSFX_FLANGE_MONO_PARAMS;

typedef const DSFX_FLANGE_MONO_PARAMS *LPCDSFX_FLANGE_MONO_PARAMS;

//
// Flange (stereo)
//

typedef struct _DSFX_FLANGE_STEREO_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[3];
    DWORD       dwOutMixbinPtrs[2];
} DSFX_FLANGE_STEREO_STATE, *LPDSFX_FLANGE_STEREO_STATE;

typedef const DSFX_FLANGE_STEREO_STATE *LPCDSFX_FLANGE_STEREO_STATE;

typedef struct _DSFX_FLANGE_STEREO_PARAMS
{
    DSFX_FLANGE_STEREO_STATE    State;
    DWORD                       dwFeedback;
    DWORD                       dwModScale;
} DSFX_FLANGE_STEREO_PARAMS, *LPDSFX_FLANGE_STEREO_PARAMS;

typedef const DSFX_FLANGE_STEREO_PARAMS *LPCDSFX_FLANGE_STEREO_PARAMS;

//
// Simple reverb
//

typedef struct _DSFX_MINIREVERB_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[12];
} DSFX_MINIREVERB_STATE, *LPDSFX_MINIREVERB_STATE;

typedef const DSFX_MINIREVERB_STATE *LPCDSFX_MINIREVERB_STATE;

typedef struct _DSFX_MINIREVERB_PARAMS
{
    DSFX_MINIREVERB_STATE   State;
    DWORD                   dwDelayLineLengths[8];
    DWORD                   dwReflectionTaps[8];
    DWORD                   dwReflectionGains[8];
    DWORD                   dwInputIIRCoefficients[2];
    DWORD                   dwInputIIRDelay;
    DWORD                   dwOutputIIRCoefficients[2];
    DWORD                   dwOutputIIRDelay;
} DSFX_MINIREVERB_PARAMS, *LPDSFX_MINIREVERB_PARAMS;

typedef const DSFX_MINIREVERB_PARAMS *LPCDSFX_MINIREVERB_PARAMS;

//
// I3DL2 reverb
//

typedef struct _DSFX_I3DL2REVERB_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[2];
    DWORD       dwOutMixbinPtrs[35];
} DSFX_I3DL2REVERB_STATE, *LPDSFX_I3DL2REVERB_STATE;

typedef const DSFX_I3DL2REVERB_STATE *LPCDSFX_I3DL2REVERB_STATE;

typedef struct _DSFX_I3DL2REVERB_DELAYLINE
{
    DWORD       dwBase;
    DWORD       dwLength;
} DSFX_I3DL2REVERB_DELAYLINE, *LPDSFX_I3DL2REVERB_DELAYLINE;

typedef const DSFX_I3DL2REVERB_DELAYLINE *LPCDSFX_I3DL2REVERB_DELAYLINE;

typedef struct _DSFX_I3DL2REVERB_IIR
{
    DWORD       dwDelay;
    DWORD       dwCoefficients[2];
} DSFX_I3DL2REVERB_IIR, *LPDSFX_I3DL2REVERB_IIR;

typedef const DSFX_I3DL2REVERB_IIR *LPCDSFX_I3DL2REVERB_IIR;

typedef struct _DSFX_I3DL2REVERB_PARAMS
{
    DSFX_I3DL2REVERB_STATE      State;
    DSFX_I3DL2REVERB_DELAYLINE  DelayLines[14];
    DWORD                       dwReflectionsInputDelay[5];
    DWORD                       dwShortReverbInputDelay;
    DWORD                       dwLongReverbInputDelay[8];
    DWORD                       dwReflectionsFeedbackDelay[4];
    DWORD                       dwLongReverbFeedbackDelay;
    DWORD                       dwShortReverbInputGain[8];
    DWORD                       dwLongReverbInputGain;
    DWORD                       dwLongReverbCrossfeedGain;
    DWORD                       dwReflectionsOutputGain[4];
    DWORD                       dwShortReverbOutputGain;
    DWORD                       dwLongReverbOutputGain;
    DWORD                       dwChannelCount;
    DSFX_I3DL2REVERB_IIR        IIR[10];
} DSFX_I3DL2REVERB_PARAMS, *LPDSFX_I3DL2REVERB_PARAMS;

typedef const DSFX_I3DL2REVERB_PARAMS *LPCDSFX_I3DL2REVERB_PARAMS;

//
// IIR
//

typedef struct _DSFX_IIR_STATE
{
    DWORD       dwScratchOffset;
    DWORD       dwScratchLength;
    DWORD       dwYMemoryOffset;
    DWORD       dwYMemoryLength;
    DWORD       dwFlags;
    DWORD       dwInMixbinPtrs[1];
    DWORD       dwOutMixbinPtrs[1];
} DSFX_IIR_STATE, *LPDSFX_IIR_STATE;

typedef const DSFX_IIR_STATE *LPCDSFX_IIR_STATE;

typedef struct _DSFX_IIR_PARAMS
{
    DSFX_IIR_STATE  State;
    DWORD           dwDelayLength;
    DWORD           dwGain;
    DWORD           dwType;
} DSFX_IIR_PARAMS, *LPDSFX_IIR_PARAMS;

typedef const DSFX_IIR_PARAMS *LPCDSFX_IIR_PARAMS;

#endif // __DSFXPARM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\benaloh.h ===
#ifndef __BENALOH_H__
#define __BENALOH_H__

#ifdef __cplusplus
extern "C" {
#endif

struct BenalohData
{
    DWORD N;            /* length of modulus */
    LPDWORD M;          /* a multiple of modulus, with highest bit set */
    LPDWORD U;          /* base**(N+1) mod modulus */
    LPDWORD V;          /* modulus - U */
    LPDWORD product;
};

BOOL BenalohSetup(struct BenalohData *context, LPDWORD M, DWORD N);
void BenalohTeardown(struct BenalohData *context);
void BenalohMod(struct BenalohData *context, LPDWORD T, LPDWORD X);
void BenalohModSquare(struct BenalohData *context, LPDWORD A, LPDWORD B);
void BenalohModMultiply(struct BenalohData *context, LPDWORD A, LPDWORD B, LPDWORD C);
BOOL BenalohModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);
BOOL BenalohModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize);
DWORD BenalohEstimateQuotient(DWORD a1, DWORD a2, DWORD m1);

#ifdef __cplusplus
}
#endif

#endif // __BENALOH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\aug01\xgraphics.h ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xgraphics.h
 *  Content:    Xbox graphics helper utilities
 *
 ****************************************************************************/

#ifndef _XGRAPHICS_H_
#define _XGRAPHICS_H_

/*****************************************************************************
 * 
 * Swizzler
 *
 * Purpose: To allow simple manipulations of a swizzled texture, without the 
 * hassle or overhead of unswizzling the whole thing in order to tweak a few 
 * points on the texture. This works with both 2D and 3D textures.
 * 
 * Notes: 
 *   Most of the time when messing with a texture, you will be incrementing
 *   by a constant value in each dimension.  Those deltas can be converted
 *   to an intermediate value via the SwizzleXXX(num) methods which can be
 *   used to quickly increment a dimension.
 *
 *   The type SWIZNUM is used to represent numbers returned by the SwizzleXXX()
 *   methods, also known as "intermediate values" in this documentation.
 * 
 *   Code in comments may be uncommented in order to provide some sort of 
 *   parameter sanity. It assures that any number passed to num will only 
 *   alter the dimension specified by dim.
 * 
 * Elements:
 *   
 *   m_u = texture map (converted) u coordinate
 *   m_v = texture map (converted) v coordinate
 *   m_w = texture map (converted) w coordinate
 * 
 *   m_MaskU = internal mask for u coordinate
 *   m_MaskV = internal mask for v coordinate
 *   m_MaskW = internal mask for w coordinate
 *
 *   m_Width = width of the texture this instance of the class has been initialized for
 *   m_Height = height of the texture this instance of the class has been initialized for
 *   m_Depth = depth of the texture this instance of the class has been initialized for
 * 
 * Methods:
 *   SWIZNUM SwizzleU(DWORD num) -- converts num to an intermediate value that
 *     can be used to modify the u coordinate
 *   SWIZNUM SwizzleV(DWORD num) -- converts num to an intermediate value that
 *     can be used to modify the v coordinate
 *   SWIZNUM SwizzleW(DWORD num) -- converts num to an intermediate value that
 *     can be used to modify the w coordinate
 *
 *   DWORD UnswizzleU(SWIZNUM index) -- takes an index to the swizzled texture, 
 *     and extracts & returns the u coordinate
 *   DWORD UnswizzleV(SWIZNUM index) -- takes an index to the swizzled texture, 
 *     and extracts & returns the v coordinate
 *   DWORD UnswizzleW(SWIZNUM index) -- takes an index to the swizzled texture, 
 *     and extracts & returns the w coordinate
 *
 *   SWIZNUM SetU(SWIZNUM num) -- sets the U coordinate to num, where num is an intermediate 
 *     value returned by Convert; returns num.
 *   SWIZNUM SetV(SWIZNUM num) -- sets the V coordinate to num, where num is an intermediate 
 *     value returned by Convert; returns num.
 *   SWIZNUM SetW(SWIZNUM num) -- sets the W coordinate to num, where num is an intermediate 
 *     value returned by Convert; returns num.
 *
 *   SWIZNUM AddU(SWIZNUM num) -- adds num to the U coordinate, where num is an intermediate value 
 *     returned by Convert; returns the new (swizzled) U coordinate
 *   SWIZNUM AddV(SWIZNUM num) -- adds num to the V coordinate, where num is an intermediate value 
 *     returned by Convert; returns the new (swizzled) V coordinate
 *   SWIZNUM AddW(SWIZNUM num) -- adds num to the W coordinate, where num is an intermediate value 
 *     returned by Convert; returns the new (swizzled) W coordinate
 *
 *   SWIZNUM SubU(SWIZNUM num) -- subtracts num from the U coordinate, where num is an intermediate value 
 *     returned by Convert; returns the new (swizzled) U coordinate
 *   SWIZNUM SubV(SWIZNUM num) -- subtracts num from the V coordinate, where num is an intermediate value 
 *     returned by Convert; returns the new (swizzled) V coordinate
 *   SWIZNUM SubW(SWIZNUM num) -- subtracts num from the W coordinate, where num is an intermediate value 
 *     returned by Convert; returns the new (swizzled) W coordinate
 *
 *   SWIZNUM IncU() -- increments the U coordinate by 1, returns the new (swizzled) U coordinate.
 *   SWIZNUM IncV() -- increments the V coordinate by 1, returns the new (swizzled) V coordinate.
 *   SWIZNUM IncW() -- increments the W coordinate by 1, returns the new (swizzled) W coordinate.
 *
 *   SWIZNUM DecU() -- decrements the U coordinate by 1, returns the new (swizzled) U coordinate.
 *   SWIZNUM DecV() -- decrements the V coordinate by 1, returns the new (swizzled) V coordinate.
 *   SWIZNUM DecW() -- decrements the W coordinate by 1, returns the new (swizzled) W coordinate.
 *
 *   SWIZNUM Get2() -- returns the index to the swizzled volume texture, based on 
 *     the U, and V coordinates, as modified by the previous methods.
 *
 *   SWIZNUM Get3() -- returns the index to the swizzled volume texture, based on 
 *     the U, V, and W coordinates, as modified by the previous methods.
 *
 * Performance:
 *   The algorithm used in most methods of this class require only Subtraction and a binary And
 *   operation to complete the operation. In the AddXXX methods, a negation, a subtraction, and two
 *   binary And operations are required. For this reason, the SubXXX methods are actually faster than
 *   AddXXX. Inc and Dec are roughly the same speed however.
 *
 ****************************************************************************/

#ifdef __cplusplus

typedef DWORD SWIZNUM;

class Swizzler 
{
public:

    // Dimensions of the texture
    DWORD m_Width;
    DWORD m_Height;
    DWORD m_Depth; 

    // Internal mask for each coordinate
    DWORD m_MaskU;
    DWORD m_MaskV;
    DWORD m_MaskW; 

    // Swizzled texture coordinates
    DWORD m_u;
    DWORD m_v;
    DWORD m_w;     

    Swizzler(): m_Width(0), m_Height(0), m_Depth(0),
        m_MaskU(0), m_MaskV(0), m_MaskW(0),
        m_u(0), m_v(0), m_w(0)
        { }

    // Initializes the swizzler
    Swizzler(
        DWORD width, 
        DWORD height, 
        DWORD depth
        )
    { 
		Init(width, height, depth);
	}

	void Init(
		DWORD width,
		DWORD height,
		DWORD depth
		)
	{
        m_Width = width; 
        m_Height = height; 
        m_Depth = depth;
		m_MaskU = 0;
		m_MaskV = 0;
		m_MaskW = 0;
		m_u = 0;
		m_v = 0;
		m_w = 0;

        DWORD i = 1;
        DWORD j = 1;
        DWORD k;

        do 
        {
            k = 0;
            if (i < width)   
            { 
                m_MaskU |= j;   
                k = (j<<=1);  
            }

            if (i < height)  
            { 
                m_MaskV |= j;   
                k = (j<<=1);  
            }

            if (i < depth)   
            {
                 m_MaskW |= j;   
                 k = (j<<=1);  
            }

            i <<= 1;
        } 
        while (k);
    }

    // Swizzles a texture coordinate
    SWIZNUM SwizzleU( 
        DWORD num 
        )
    {
        SWIZNUM r = 0;

        for (DWORD i = 1; i <= m_MaskU; i <<= 1) 
        {
            if (m_MaskU & i) 
            {
                r |= (num & i);
            }
            else
            {
                num <<= 1;
            }
        }

        return r;
    }

    SWIZNUM SwizzleV( 
        DWORD num 
        )
    {
        SWIZNUM r = 0;

        for (DWORD i = 1; i <= m_MaskV; i <<= 1) 
        {
            if (m_MaskV & i)
            {
                r |= (num & i);
            }
            else
            {
                num <<= 1;
            }
        }

        return r;
    }

    SWIZNUM SwizzleW( 
        DWORD num 
        )
    {
        SWIZNUM r = 0;

        for (DWORD i = 1; i <= m_MaskW; i <<= 1) 
        {
            if (m_MaskW & i)
            {
                r |= (num & i);
            }
            else
            {
                num <<= 1;
            }
        }

        return r;
    }

    SWIZNUM Swizzle(
        DWORD u, 
        DWORD v, 
        DWORD w
        )
    {
        return SwizzleU(u) | SwizzleV(v) | SwizzleW(w);
    }
    
    // Unswizzles a texture coordinate
    DWORD UnswizzleU( 
        SWIZNUM num
        )
    {
        DWORD r = 0;

        for (DWORD i = 1, j = 1; i; i <<= 1) 
        {
            if (m_MaskU & i)  
            {   
                r |= (num & j);   
                j <<= 1; 
            } 
            else               
            {   
                num >>= 1; 
            }
        }

        return r;
    }

    DWORD UnswizzleV( 
        SWIZNUM num 
        )
    {
        DWORD r = 0;

        for (DWORD i = 1, j = 1; i; i <<= 1) 
        {
            if (m_MaskV & i)  
            {   
                r |= (num & j);   
                j <<= 1; 
            } 
            else
            {   
                num >>= 1; 
            }
        }

        return r;
    }

    DWORD UnswizzleW( 
        SWIZNUM num 
        )
    {
        DWORD r = 0;

        for (DWORD i = 1, j = 1; i; i <<= 1) 
        {
            if (m_MaskW & i)  
            {   
                r |= (num & j);   
                j <<= 1; 
            } 
            else               
            {   
                num >>= 1; 
            }
        }

        return r;
    }

    // Sets a texture coordinate
    __forceinline SWIZNUM SetU(SWIZNUM num) { return m_u = num /* & m_MaskU */; }
    __forceinline SWIZNUM SetV(SWIZNUM num) { return m_v = num /* & m_MaskV */; }
    __forceinline SWIZNUM SetW(SWIZNUM num) { return m_w = num /* & m_MaskW */; }
    
    // Adds a value to a texture coordinate
    __forceinline SWIZNUM AddU(SWIZNUM num) { return m_u = ( m_u - ( (0-num) & m_MaskU ) ) & m_MaskU; }
    __forceinline SWIZNUM AddV(SWIZNUM num) { return m_v = ( m_v - ( (0-num) & m_MaskV ) ) & m_MaskV; }
    __forceinline SWIZNUM AddW(SWIZNUM num) { return m_w = ( m_w - ( (0-num) & m_MaskW ) ) & m_MaskW; }

    // Subtracts a value from a texture coordinate
    __forceinline SWIZNUM SubU(SWIZNUM num) { return m_u = ( m_u - num /* & m_MaskU */ ) & m_MaskU; }
    __forceinline SWIZNUM SubV(SWIZNUM num) { return m_v = ( m_v - num /* & m_MaskV */ ) & m_MaskV; }
    __forceinline SWIZNUM SubW(SWIZNUM num) { return m_w = ( m_w - num /* & m_MaskW */ ) & m_MaskW; }

    // Increments a texture coordinate
    __forceinline SWIZNUM IncU()              { return m_u = ( m_u - m_MaskU ) & m_MaskU; }
    __forceinline SWIZNUM IncV()              { return m_v = ( m_v - m_MaskV ) & m_MaskV; }
    __forceinline SWIZNUM IncW()              { return m_w = ( m_w - m_MaskW ) & m_MaskW; }

    // Decrements a texture coordinate
    __forceinline SWIZNUM DecU()              { return m_u = ( m_u - 1 ) & m_MaskU; }
    __forceinline SWIZNUM DecV()              { return m_v = ( m_v - 1 ) & m_MaskV; }
    __forceinline SWIZNUM DecW()              { return m_w = ( m_w - 1 ) & m_MaskW; }

    // Gets the current swizzled address for a 2D or 3D texture
    __forceinline SWIZNUM Get2D()          { return m_u | m_v; }
    __forceinline SWIZNUM Get3D()          { return m_u | m_v | m_w; }
};

#endif __cplusplus

/*
 * Swizzle methods.  These are implemented based on the above class
 * for the moment but will be further optimized in the future.
 */

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct _XGPOINT3D
{
    DWORD u;
    DWORD v;
    DWORD w;
} XGPOINT3D;

// Returns whether a texture format is swizzled or not.
BOOL WINAPI XGIsSwizzledFormat(
    D3DFORMAT Format
    );

// Returns the byte per texel of a format.
DWORD WINAPI XGBytesPerPixelFromFormat(
    D3DFORMAT Format
    );

// Swizzle a subrectangle from a buffer into a larger texture.  The 
// destination rectangle must be completely contained within the destination 
// texture (no clipping).
//
// If pRect is NULL, pPoint is NULL and Pitch == 0, this routine will
// assume that the source buffer is exactly the same size as the destination
// texture and will swizzle the whole thing.  This routine will run
// considerably faster in that case.
//
VOID WINAPI XGSwizzleRect(
    LPCVOID  pSource,      // The buffer that contains the source rectangle
    DWORD    Pitch,        // The pitch of the buffer that contains the source
    LPCRECT  pRect,        // The rectangle within the buffer to copy.
    LPVOID   pDest,        // The destination texture.
    DWORD    Width,        // The width of the entire destination texture.
    DWORD    Height,       // The height of the entire destination texture.
    CONST LPPOINT pPoint,  // Where to put the rectangle in the texture.
    DWORD    BytesPerPixel
    );

// Unswizzle a subrectangle from a texture into a buffer.
//
// If pRect is NULL, pPoint is NULL and Pitch == 0, this routine will
// assume that the source texture is exactly the same size as the destination
// buffer and will unswizzle the whole thing.  This routine will run
// considerably faster in that case.
//
VOID WINAPI XGUnswizzleRect(
    LPCVOID  pSource,      // The source texture.
    DWORD    Width,        // The width of the entire source texture.
    DWORD    Height,       // The height of the entire source texture.
    LPCRECT  pRect,        // The rectangle within the texture to copy.
    LPVOID   pDest,        // The destination buffer
    DWORD    Pitch,        // The pitch of the destination buffer
    CONST LPPOINT pPoint,  // Where to copy the rectangle to
    DWORD    BytesPerPixel
    );

// Swizzle a box from a buffer into a larger texture.  The destination box 
// must be completely contained within the destination texture (no clipping).
//
VOID WINAPI XGSwizzleBox(
    LPCVOID     pSource,      // The buffer that contains the source rectangle
    DWORD       RowPitch,     // Byte offset from the left edge of one row to
                                // the left edge of the next row
    DWORD       SlicePitch,   // Byte offset from the top-left of one slice to
                                // the top-left of the next deepest slice
    CONST D3DBOX * pBox,      // The box within the buffer to copy.
    LPVOID      pDest,        // The destination texture.
    DWORD       Width,        // The width of the entire destination texture.
    DWORD       Height,       // The height of the entire destination texture.
    DWORD       Depth,        // The depth of the entire destination texture.
    CONST XGPOINT3D * pPoint, // Where to put the rectangle in the texture.
    DWORD       BytesPerPixel
    );

// Unswizzle a box from a texture into a buffer.
//
void WINAPI XGUnswizzleBox(
    LPCVOID     pSource,      // The source texture.
    DWORD       Width,        // The width of the entire source texture.
    DWORD       Height,       // The height of the entire source texture.
    DWORD       Depth,        // The depth of the entire destination texture.
    D3DBOX *    pBox,         // The rectangle within the texture to copy.
    LPVOID      pDest,        // The destination buffer
    DWORD       RowPitch,     // Byte offset from the left edge of one row to
                                // the left edge of the next row
    DWORD       SlicePitch,   // Byte offset from the top-left of one slice to
                                // the top-left of the next deepest slice
    XGPOINT3D * pPoint,       // Where to copy the rectangle to
    DWORD       BytesPerPixel
    );

#ifdef __cplusplus
}
#endif

/****************************************************************************
 *
 * Push buffer compiler.
 *
 ****************************************************************************/

#ifdef __cplusplus
extern "C"
{
#endif

/*
 * The push-buffer compiler allows the title developer to pre-process
 *   some common commands into a push buffer to save the driver the work of
 *   having to process the commands into the format that the hardware
 *   understands at runtime.  This should be a big win for calls to the
 *   indexed draw primitives, which normally have to use the CPU to copy
 *   the indices every time.
 */

HRESULT WINAPI XGCompileDrawIndexedVertices(
    void *pBuffer,
    DWORD *pSize, // In: total size of buffer, Out: size of resulting push-buffer
    D3DPRIMITIVETYPE PrimitiveType,
    UINT VertexCount,
    CONST WORD *pIndexData
    );

#ifdef __cplusplus
}
#endif

/****************************************************************************
 *
 * XGBuffer:
 *
 * An object that is used to return arbitrary length data.
 *
 ****************************************************************************/

typedef struct XGBuffer XGBuffer;
typedef XGBuffer *LPXGBUFFER, *PXGBUFFER;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

HRESULT WINAPI XGBufferCreate(DWORD numBytes, LPXGBUFFER* ppBuffer);

/* XGBuffer */

ULONG   WINAPI XGBuffer_AddRef(XGBuffer *pThis);
ULONG   WINAPI XGBuffer_Release(XGBuffer *pThis);
LPVOID  WINAPI XGBuffer_GetBufferPointer(XGBuffer *pThis);
DWORD   WINAPI XGBuffer_GetBufferSize(XGBuffer *pThis);

#ifdef __cplusplus
}
#endif //__cplusplus

struct XGBuffer
{
    DWORD  refCount;            // The ref count.
    LPVOID pData;               // The data
    DWORD  size;                // The size of the buffer
#ifdef __cplusplus
    // IUnknown
    ULONG WINAPI AddRef() { return XGBuffer_AddRef(this); }
    ULONG WINAPI Release(){ return XGBuffer_Release(this); }

    // IXGBuffer methods
    LPVOID WINAPI GetBufferPointer() { return XGBuffer_GetBufferPointer(this); }
    DWORD  WINAPI GetBufferSize() { return XGBuffer_GetBufferSize(this); }
#endif // __cplusplus
};

/****************************************************************************
 *
 * Vertex and Pixel Shader Assembler.
 *
 ****************************************************************************/

/* Typedef of Resolver callback function used to process #include files
 *
 * This function is and called by the assembler to read files when the
 * #include statement is encountered.
 *
 * Parameters:
 *
 *    pResolverUserData
 *        This is arbitray data passed in to the AssembleShader
 *        function. Typically used to store context information
 *        for the resolver function.
 *    isSystemInclude
 *        A boolean value that is TRUE if the #include statement
 *        uses angle brackets, and FALSE if it uses double-quotes.
 *        The look-up rules are slightly different for
 *        the two types of files. Ordinary include files are first
 *        searched for in the same directory as the file that containst
 *        the #include statement. If the file is not found there,
 *        then additional directories are searched. System include
 *        files just search the additional directories. It's up to
 *        the function implementer to follow this rule.
 *    sourceFilePath
 *        The path of the file that contains the #include statement.
 *        Useful to implement searching for the #include file.
 *    includeFileName
 *        The name of the file to include. This has had the double-quotes
 *        and/or angle-brackets removed.
 *    resolvedFilePath
 *        Return the full path name of the file here.
 *    resolvedFilePathSize
 *        The size of the resolvedFilePath buffer.
 *    ppResolvedFile
 *        Used to return a pointer to an XGBuffer containing the text
 *        of the resolved file.
 *
 * return value:
 *
 *   Return SUCCESS if the file was found and read successfully.
 *   Return FAILURE if the file could not be found, or could not be read.
 */

typedef HRESULT (*SASM_ResolverCallback)(LPVOID pResolverUserData,
        BOOL isSystemInclude, LPCSTR sourceFilePath,
        LPCSTR includeFileName,
        LPSTR resolvedFilePath, DWORD resolvedFilePathSize,
        LPXGBUFFER* ppResolvedFile);


//-------------------------------------------------------------------------
// SASM flags:
// --------------
//
// SASM_DEBUG
//   Add debugging information to the token stream. Only effective if
//   used in combination with the SASM_OUTPUTTOKENS flag.
//
// SASM_SKIPVALIDATION
//   Don't validate the correctness of the shader.
//
// SASM_DONOTOPTIMIZE
//   Don't attempt to optimize the microcode.
//
// SASM_OUTPUTTOKENS
//   Output DX8 tokens instead of microcode.
//
// Only choose at most one of the SASM_INPUT_XXX_SHADER_TOKENS flags:
//
// SASM_INPUT_PIXELSHADER_TOKENS
//   Input is DX8 pixel shader tokens instead of ascii assembler source code.
//
// SASM_INPUT_VERTEXSHADER_TOKENS
//   Input is DX8 vertex shader tokens instead of ascii assembler source code.
//
// SASM_INPUT_READWRITE_VERTEXSHADER_TOKENS
//   Input is DX8 read/write vertex shader tokens instead of ascii assembler source code.
//
// SASM_INPUT_VERTEXSTATESHADER_TOKENS
//   Input is DX8 vertex state shader tokens instead of ascii assembler source code.
//
// SASM_INPUT_SCREENSPACE_VERTEXSHADER_TOKENS
//   Input tokens are for a #pragma screenspace vertex shader. Only valid if combined
//   with SASM_INPUT_VERTEXSHADER_TOKENS or SASM_INPUT_READWRITE_VERTEXSHADER_TOKENS.
//
// SASM_INPUT_NONXBOX_TOKENS
//   Input tokens are for an ordinary, non-Xbox shader. Only valid if combined
//   with SASM_INPUT_VERTEXSHADER_TOKENS or SASM_INPUT_PIXELSHADER_TOKENS.
//
// SASM_INPUT_MICROCODE
//   Input is microcode. Useful for optimizing hand-built code.
//
// SASM_INPUT_SCREENSPACE_MICROCODE
//   Input is screenspace microcode. Useful for optimizing hand-built code.
//
// SASM_PREPROCESSONLY
//   Run the preprocessor, and copy output of the preprocessor to the output.
//
// SASM_DISABLE_GLOBAL_OPTIMIZATIONS
//   Disable global optimizations in the vertex shader.
//
// SASM_VERIFY_OPTIMIZATIONS
//   Verify that the optimized shader produces the same result as the
//   original shader. Use this if you suspect that your vertex shader is
//   being optimized incorrectly. (There can be a substantial speed and
//   memory penalty for using this flag.)
//-------------------------------------------------------------------------

#define SASM_DEBUG                                  (1 << 0)
#define SASM_SKIPVALIDATION                         (1 << 1)
#define SASM_DONOTOPTIMIZE                          (1 << 2)
#define SASM_OUTPUTTOKENS                           (1 << 3)
#define SASM_INPUT_PIXELSHADER_TOKENS               (1 << 4)
#define SASM_INPUT_VERTEXSHADER_TOKENS              (1 << 5)
#define SASM_INPUT_READWRITE_VERTEXSHADER_TOKENS    (1 << 6)
#define SASM_INPUT_VERTEXSTATESHADER_TOKENS         (1 << 7)
#define SASM_INPUT_SCREENSPACE_VERTEXSHADER_TOKENS  (1 << 8)
#define SASM_INPUT_NONXBOX_TOKENS                   (1 << 9)
#define SASM_INPUT_MICROCODE                        (1 << 10)
#define SASM_INPUT_SCREENSPACE_MICROCODE            (1 << 11)
#define SASM_PREPROCESSONLY                         (1 << 12)
#define SASM_SKIPPREPROCESSOR                       (1 << 13)
#define SASM_DISABLE_GLOBAL_OPTIMIZATIONS           (1 << 14)
#define SASM_VERIFY_OPTIMIZATIONS                   (1 << 15)

//-------------------------------------------------------------------------
// SASMT values:
// --------------
//
// SASMT_PIXELSHADER
//   A pixel shader.
//
// SASMT_VERTEXSHADER
//   An ordinary vertex shader.
//
// SASMT_READWRITE_VERTEXSHADER
//   A vertex shader that can write to the constant registers.
//
// SASMT_VERTEXSTATESHADER
//   A vertex state shader.
//
//
// SASMT_SCREENSPACE
//   For vertex shaders and read/write vertex shaders, indicates that the
//   shader outputs screen space coordinates rather than clip space coordinates.
//
//
// SASMT_VERTEXSHADER thru SASMT_VERTEXSTATESHADER are
// guaranteed to have the same values as D3DMT_VERTEXSHADER
// thru D3DMT_VERTEXSTATESHADER.
//
//-------------------------------------------------------------------------

#define SASMT_PIXELSHADER               0
#define SASMT_VERTEXSHADER              1
#define SASMT_READWRITE_VERTEXSHADER    2
#define SASMT_VERTEXSTATESHADER         3
#define SASMT_INVALIDSHADER             0xff
#define SASMT_SCREENSPACE               0x100
#define SASMT_SHADERTYPEMASK            0xff

#define SASMT_SHADERTYPE(X) ((X) & SASMT_SHADERTYPEMASK)
#define SASMT_ISSCREENSPACE(X) (((X) & SASMT_SCREENSPACE) != 0)

//-------------------------------------------------------------------------
// XGAssembleShader:
// ------------------------
// Assembles an ASCII description of a vertex or pixel shader into 
// binary form.
//
// Parameters:
//
//  pSourceFileName
//      Source file name - used in error messages
//  pSrcData
//      A pointer to the source data
//  SrcDataLen
//      The source data length
//  Flags
//      SASM_xxx flags
//  pConstants
//      If constants are declared in the shader, they are written here. Pass NULL if
//      you don't care.
//  pCompiledShader
//      The shader microcode is written here. Pass NULL if you don't care.
//  pErrorLog
//      Errors are written here. Pass NULL if you don't care.
//  pListing
//      A human-readable listing is written here. Pass NULL if you don't want it.
//  pResolver
//      Used by the preprocessor. Can be NULL if you don't use #include in your source file.
//  pResolverUserData
//      Passed unmodified to the pResolver function.
//  pShaderType
//      Returns the type of shader that was assembled. Pass NULL if you don't care.
//
// Return value:
//    Returns S_OK if no errors.
//    Returns a failure code if an error occured. For problems with the
//    assembly program syntax, human-readable errors and warnings are
//    written to the pErrorLog.
//-------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
XGAssembleShader(
    LPCSTR pSourceFileName,
    LPCVOID pSrcData,
    UINT SrcDataLen,
    DWORD Flags,
    LPXGBUFFER* pConstants,
    LPXGBUFFER* pCompiledShader,
    LPXGBUFFER* pErrorLog,
    LPXGBUFFER* pListing,
    SASM_ResolverCallback pResolver,
    LPVOID pResolverUserData,
    LPDWORD pShaderType
    );

#define AssembleShader XGAssembleShader


//XGSpliceVertexShaders:
//	Splice together shaders in the ppShaderArray, return it in *pNewShader.
//	If pcbNewShaderBufferSize is provided and is too small, it will be changed to the minimum allowable buffer size, and will return S_FALSE. 
//		pNewShader can be NULL in this case. If pcbNewShaderBufferSize is NULL or points to a non-zero size, pNewShader must not be NULL.
//	The return value will be S_OK or S_FALSE. If optimizing in low-mem conditions, it can run out of memory, and will return an error code.
//	If bad params are passed, it will assert.
HRESULT WINAPI XGSpliceVertexShaders (
	/*			   OUT  */  DWORD*   pNewShader,			  //pointer to buffer to fill with output
	/* OPTIONAL IN OUT  */  DWORD*   pcbNewShaderBufferSize, //How many bytes long the shader buffer is
 	/* OPTIONAL    OUT  */  DWORD*   pNewInstructionCount,   //how many instrucitons are in the newly-spliced shader
	/*    IN      */  CONST DWORD* CONST*  ppShaderArray,          //arrray of pointers to shaders to splice together
	/*		    IN      */  DWORD    NumShaders,             //num of shaders in ppShaderArray
	/*		    IN      */  BOOL     bOptimizeResults        //TRUE to optimize, FALSE to not optimize
);




// Examines vertex shader microcode, and determines the type of vertex shader.
//
// Parameters:
//
//  pMicrocode
//      A pointer to the vertex shader microcode.
//
// Return value:
//   Returns
//      Returns the type of shader that is pointed to by pMicrocode. Due to
//      implementation restrictions, the SASMT_SCREENSPACE bit will not be
//      set, even if the microcode is for a screen space vertex shader.
//
//      If the microcode is invalid, the result is SASMT_INVALIDSHADER.

DWORD WINAPI XGSUCode_GetVertexShaderType(
    LPCVOID pMicrocode
    );

// Examines shader microcode, and determines the length
// in instructions.
//
// Parameters:
//
//  pMicrocode
//      A pointer to the vertex shader microcode.
//
// Return value:
//      Returns the length of the vertex shader in microinstructions.
//      If the microcode is not a valid vertex shader, the result is undefined.

DWORD WINAPI XGSUCode_GetVertexShaderLength(
    LPCVOID pMicrocode
    );

// Compares two vertex shaders to see if they produce equivalent results.
//
// Parameters:
//
//  pMicrocodeA
//      A pointer to a vertex shader microcode program.
//  pMicrocodeB
//      A pointer to a vertex shader microcode program.
//  ppErrorLog
//      Differences between the two shaders results are written here. Pass NULL if you don't care.
//
// Return value:
//      Returns S_OK if the two shaders produce equivalent results.
//      Returns a failure code if the two shaders do not produce equivalent results, or
//      if there was an internal error.
//
//      If either microcode program is not valid vertex shader, the result is undefined.

HRESULT WINAPI XGSUCode_CompareVertexShaders(
    LPCVOID pMicrocodeA,
    LPCVOID pMicrocodeB,
    LPXGBUFFER* ppErrorLog
    );


/*****************************************************************************
 * 
 * XGWriteSurfaceToFile
 *
 * Purpose: 
 *   Allows the contents of a surface to be written to a 24-bit .bmp file.
 *   The following surface formats are supported:
 *     D3DFMT_LIN_A8R8G8B8
 *     D3DFMT_LIN_X8R8G8B8
 *     D3DFMT_LIN_R5G6B5
 *     D3DFMT_LIN_R5G6B5
 *     D3DFMT_LIN_X1R5G5B5
 *
 *   These are the formats that are possible for a frontbuffer.  Swizzled
 *   formats are not currently supported.
 *
 *   Requires creation of a temporary buffer 3*heigh*width bytes big.  If 
 *   this allocation fails, the file is written more slowly using a much 
 *   smaller buffer.
 *
 *   pSurf holds a pointer to a surface.
 *   cPath is a character string that contains the drive, path and filename
 *   for the output file.  If the file exists, it will be overwritten.  The
 *   filename should have a .bmp extension.
 *
 ****************************************************************************/

HRESULT WINAPI XGWriteSurfaceToFile(
    IDirect3DSurface8 *pSurf,
    const char *cPath
    );


/*****************************************************************************
 * 
 * XPR structures and constants
 *
 * Purpose: 
 *   The XPR file format allows multiple graphics resources to be pre-defined
 *   and bundled together into one file.  These resources can be copied into
 *   memory and then immediately used in-place as D3D objects such as textures
 *   and vertex buffers.  The structure below defines the XPR header and the 
 *   unique identifier for this file type.
 *
 ****************************************************************************/
typedef struct {
    DWORD dwMagic;
    DWORD dwTotalSize;
    DWORD dwHeaderSize;
} XPR_HEADER;

#define XPR_MAGIC_VALUE 0x30525058


/*****************************************************************************
 * 
 * XGWriteSurfaceOrTextureToXPR
 *
 * Purpose: 
 *   This utility functions allows a single surface or texture to be saved
 *   to a packed resource file (.xpr).  All surface and texture formats
 *   supported by Direct3D are supported by this function.
 *
 *   pResource holds a pointer to a surface or texture.
 *   cPath is a character string that contains the drive, path and filename
 *   for the output file.  If the file exists, it will be overwritten.  The
 *   filename should have a .xpr or .xbx extension.
 *   if bWriteSurfaceAsTexture is TRUE and pResource is a surface, the 
 *   resource is converted to a texture before writing it to the xpr file.
 *
 *   Note that on Silver XDK boxes, the texture or surface must reside in 
 *   AGP memory.
 *
 ****************************************************************************/
HRESULT WINAPI XGWriteSurfaceOrTextureToXPR(
    IDirect3DResource8 *pResource, 
    const char *cPath,
    BOOL bWriteSurfaceAsTexture
    );


/*****************************************************************************
 * 
 * XGCompressRect
 *
 * Purpose: 
 *   This function will compress a rectangle into one of the Xbox supported 
 *   compressed texture formats: DXT1, DXT2, DXT3, DXT4, or DXT5.  The format
 *   should be specified in the format argument.  The compressed texture data 
 *   is written out to pDestBuf, which can point to a D3DCreated texture or a 
 *   contiguous memory allocation to be used with the Register() API
 *
 * Parameters:
 * DestFormat 
 *      Should be one of the Xbox DXT format enums
 * dwDestPitch
 *      Should be the pitch of the destination, in terms of a row
 *      of 4x4 blocks.  So a DXT1 texture with a width of 16 pixels has a
 *      pitch of 4 blocks * 8 bytes per block = 32 bytes
 * pSrcData 
 *      Should point to linear (not swizzled) texture data
 * SrcFormat
 *      Should be one of the Xbox linear ARGB or XRGB texture formats
 * dwSrcPitch
 *      Should be the pitch of the source texture, in bytes
 * fAlphaRef 
 *      The cutoff between transparent and opaque for DXT1
 * dwFlags:
 *  XGCOMPRESS_PREMULTIPLY specifies whether or not to premultiply 
 *      by alpha (DXT2/4)
 *  XGCOMPRESS_NEEDALPHA0(1) specify that interpolated alpha should ensure
 *      that 0(1) is one of the resultant values
 *  XGCOMPRESS_PROTECTNONZERO specifies that non-zero alpha values should
 *      not be quantized to zero.
 ****************************************************************************/
#define XGCOMPRESS_PREMULTIPLY      0x1
#define XGCOMPRESS_NEEDALPHA0       0x2
#define XGCOMPRESS_NEEDALPHA1       0x4
#define XGCOMPRESS_PROTECTNONZERO   0x8

HRESULT WINAPI XGCompressRect(
    LPVOID pDestBuf,
    D3DFORMAT DestFormat,
    DWORD dwDestPitch, 
    DWORD dwWidth,
    DWORD dwHeight,
    LPVOID pSrcData,
    D3DFORMAT SrcFormat,
    DWORD dwSrcPitch,
    FLOAT fAlphaRef,
    DWORD dwFlags
    );


/*****************************************************************************
 * 
 * XGSetSurfaceHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetSurfaceHeader(
    UINT Width,
    UINT Height,
    D3DFORMAT Format,
    IDirect3DSurface8* pSurface,
    UINT Data,                  // Offset to the data held by this resource
    UINT Pitch                  // Surface pitch
    );


/*****************************************************************************
 * 
 * XGSetTextureHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetTextureHeader(
    UINT Width,
    UINT Height,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    IDirect3DTexture8* pTexture,
    UINT Data,                  // Offset to the data held by this resource
    UINT Pitch                  // Texture pitch
    );


/*****************************************************************************
 * 
 * XGSetCubeTextureHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetCubeTextureHeader(
    UINT EdgeLength,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    IDirect3DCubeTexture8* pCubeTexture,
    UINT Data,                  // Offset to the data held by this resource
    UINT Pitch                  // CubeTexture pitch
    );


/*****************************************************************************
 * 
 * XGSetVolumeTextureHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetVolumeTextureHeader(
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    IDirect3DVolumeTexture8* pVolumeTexture,
    UINT Data,                  // Offset to the data held by this resource
    UINT Pitch                  // VolumeTexture pitch
    );

/*****************************************************************************
 * 
 * XGSetVertexBufferHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetVertexBufferHeader(
    UINT Length,
    DWORD Usage,
    DWORD FVF,
    D3DPOOL Pool,
    IDirect3DVertexBuffer8 *ppVertexBuffer,
    UINT Data
    );

/*****************************************************************************
 * 
 * XGSetIndexBufferHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetIndexBufferHeader(
    UINT Length,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    IDirect3DIndexBuffer8 *pIndexBuffer,
    UINT Data
    );

#ifdef _XBOX_

/*****************************************************************************
 * 
 * XGSetPaletteHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetPaletteHeader(
    D3DPALETTESIZE Size, 
    IDirect3DPalette8 *pPalette,
    UINT Data
    );

/*****************************************************************************
 * 
 * XGSetPushBufferHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetPushBufferHeader(
    UINT Size,
    BOOL RunUsingCpuCopy,
    IDirect3DPushBuffer8 *pPushBuffer,
    UINT Data
    );

/*****************************************************************************
 * 
 * XGSetFixupHeader
 *
 ****************************************************************************/

VOID WINAPI XGSetFixupHeader(
    UINT Size,
    IDirect3DFixup8 *pFixup,
    UINT Data
    );

#endif // _XBOX_

#ifdef __cplusplus
}
#endif //__cplusplus

#endif /* _XGRAPHICS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\des.h ===
#ifndef __DES_H__
#define __DES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,unsigned char *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(BYTE *pbOut, BYTE *pbIn, void *key, int op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(BYTE *pbKey, DWORD cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(BYTE *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(BYTE *pbKey, BYTE *pbExpanded_key);


void
RSA32API
desexpand128to192(
    BYTE *pbKey,        // input 128bit or 192bit buffer
    BYTE *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, BYTE *key);

void RSA32API desx(BYTE *pbOut, BYTE *pbIn, void *keyin, int op);


extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\Copy of xcrypt.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xcrypt.h

Abstract:

    This module contains definitions the XBox encryption and certificate

--*/


#ifndef _XCRYPT_H
#define _XCRYPT_H

#ifdef __cplusplus
extern "C" {
#endif

#include "guiddef.h"

//
// Number of bits for keys in the public key algorithms
//
#define XC_KEY_BITS               (2048)

//
// Size of sigunature corresponding to the keysize.  This is the
// buffer size needed for public key encryption of a digest
//
#define XC_ENC_SIGNATURE_SIZE     ((XC_KEY_BITS + 7) / 8)

//
// Number of bytes in the public key based on the key size
//
#define XC_PUBLIC_KEYDATA_SIZE    (284)

//
// Size of our symmetric key
//
#define XC_SYMMETRIC_KEY_SIZE     16

//
// Number of bytes in a digest (same as A_SHA_DIGEST_LEN)
// NOTE: do not change this value.  XE needs this to be 20
//
#define XC_DIGEST_LEN             20

//
// Size for SHA digest
//
#define XC_SERVICE_DIGEST_SIZE    XC_DIGEST_LEN

//
// Number of bytes in SHA Buffer
//
#define XC_SERVICE_SHA_CONTEXT_SIZE  116
 
//
// Number of bytes in RC4 Buffer
//
#define XC_SERVICE_RC4_KEYSTRUCT_SIZE   258

//
// Constanst needed for DES
//
#define XC_SERVICE_DES_TABLESIZE	128
#define XC_SERVICE_DES_BLOCKLEN	    8
#define XC_SERVICE_DES_KEYSIZE	    8

#define XC_SERVICE_DES3_TABLESIZE	(3 * XC_SERVICE_DES_TABLESIZE)
#define XC_SERVICE_DES3_KEYSIZE	    24

// constants for Block operations
#define XC_SERVICE_ENCRYPT		1
#define XC_SERVICE_DECRYPT		0

// constants for selecting DES or triple DES cipher
#define XC_SERVICE_DES_CIPHER		0
#define XC_SERVICE_DES3_CIPHER		1

//
// Low level crypto API
//

VOID
XCCalcDigest(
    IN  PUCHAR MsgData,
    IN  ULONG  MsgDataLen,
    IN  PUCHAR Digest
    );

VOID
XCSymmetricEncDec(
    IN  PUCHAR MsgData,
    IN  ULONG  MsgDataLen,
    IN  PUCHAR Key,
    IN  ULONG  KeyBytes
    );

ULONG
XCCalcSigSize(
    IN  PUCHAR  pbPrivateKey
    );

ULONG
XCCalcKeyLen(
    IN  PUCHAR  pbPublicKey
    );

BOOLEAN
XCSignDigest(
    IN   PUCHAR    pbDigest,
    IN   PUCHAR    pbPrivateKey,
    OUT  PUCHAR    pbSig
    );

BOOLEAN
XCVerifyDigest(
    IN   PUCHAR   pbSig,
    IN   PUCHAR   pbPublicKey,
    IN   PUCHAR   pbWorkspace,
    IN   PUCHAR   pbCompareDigest
    );

//
// Crypto APIs the ROM exports
//

//
// Equivalent to A_SHAInit. Byte array pointed to by pbSHAContext
// must be at least XC_SERVICE_SHA_CONTEXT_SIZE (116) bytes long.
//
void
XcSHAInit(
    OUT PUCHAR pbSHAContext
    );
   
//
// Equivalent to A_SHAUpdate. Byte array pointed to by pbSHAContext
// must be at least XC_SERVICE_SHA_CONTEXT_SIZE (116) bytes long.
//
void
XcSHAUpdate(
    IN OUT PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    );
   
//
// Equivalent to A_SHAFinal.
// Byte array pbDigest must be able to hold XC_SERVICE_DIGEST_SIZE (20) bytes
//
void
XcSHAFinal(
    IN PUCHAR pbSHAContext,
    OUT PUCHAR pbDigest
    );
   
//
// Equivalent to rc4_key. Byte array pointed to by pbKeyStruct
// must be at least XC_SERVICE_RC4_KEYSTRUCT_SIZE (258) bytes long.
//
void
XcRC4Key(
    OUT PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    );
   
//
// Equivalent to rc4. Byte array pointed to by pbKeyStruct
// must be at least XC_SERVICE_RC4_KEYSTRUCT_SIZE (258) bytes long.
//
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN OUT PUCHAR pbInput
    );
   
//
// Computes SHA1-HMAC according to RFC 2104 for 2 pieces of input data.
// Byte array pbDigest must be able to hold XC_SERVICE_DIGEST_SIZE (20) bytes
//
void
XcHMAC(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput2,
    IN ULONG dwInputLength2,
    OUT PUCHAR pbDigest
    );
   
//
// Equivalent to BSafeEncPublic.
//
ULONG
XcPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    OUT PUCHAR pbOutput
    );
   
//
// Equivalent to BSafeDecPrivate.
//
ULONG
XcPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    OUT PUCHAR pbOutput
    );

//
// Get keylen for public key
//
ULONG
XcPKGetKeyLen(
    IN PUCHAR pbPubKey
    );

//
// Verify PKCS1 signature for given XC_SERVICE_DIGEST_SIZE (20) byte digest
//
BOOLEAN
XcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    );
  
//
// Equivalent to BenalohModExp
// computes A = B ^ C mod D, N = len of params in DWORDs
//
ULONG
XcModExp(
    OUT ULONG* pA,
    IN ULONG* pB,
    IN ULONG* pC,
    IN ULONG* pD,
    IN ULONG dwN
    );
   
//
// Equivalent to desparityonkey
//
void
XcDESKeyParity(
    IN OUT PUCHAR pbKey,
    IN ULONG dwKeyLength
    );
   
//
// Equivalent to deskey or tripledes3key.
// dwKeyLength must be either XC_SERVICE_DES_KEYSIZE (8) or XC_SERVICE_DES3_KEYSIZE (24)
// Byte array pbKeyTable must be able to hold XC_SERVICE_DES_TABLESIZE (128)
// or XC_SERVICE_DES3_TABLESIZE (384) bytes
//
void
XcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    );

//
// Equivalent to des or tripledes.
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1)
// dwOp must be either XC_SERVICE_DECRYPT (0) or XC_SERVICE_ENCRYPT (1)
//
void
XcBlockCrypt(
    IN ULONG dwCipher,
    OUT PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    );
   
//
// Roughly equivalent to CBC. Will loop through multiple blocks.
// dwInputLength can contain any multiple of XC_SERVICE_DES_BLOCKLEN (8)
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1)
// dwOp must be either XC_SERVICE_DECRYPT (0) or XC_SERVICE_ENCRYPT (1)
//
void
XcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    OUT PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    );

//
// Generic Crypt Service function for future extension
//
ULONG
XcCryptService(
    IN ULONG dwOp,
    IN void* pArgs
    );

//
// typedef's of all the ROM crypto exports
//
typedef void (*pfXcSHAInit)(PUCHAR pbSHAContext);
typedef void (*pfXcSHAUpdate)(PUCHAR pbSHAContext, PUCHAR pbInput, ULONG dwInputLength);
typedef void (*pfXcSHAFinal)(PUCHAR pbSHAContext, PUCHAR pbDigest);
typedef void (*pfXcRC4Key)(PUCHAR pbKeyStruct, ULONG dwKeyLength, PUCHAR pbKey);
typedef void (*pfXcRC4Crypt)(PUCHAR pbKeyStruct, ULONG dwInputLength, PUCHAR pbInput);
typedef void (*pfXcHMAC)(PUCHAR pbKey, ULONG dwKeyLength, PUCHAR pbInput, ULONG dwInputLength, PUCHAR pbInput2, ULONG dwInputLength2, PUCHAR pbDigest);
typedef ULONG (*pfXcPKEncPublic)(PUCHAR pbPubKey, PUCHAR pbInput, PUCHAR pbOutput);
typedef ULONG (*pfXcPKDecPrivate)(PUCHAR pbPrvKey, PUCHAR pbInput, PUCHAR pbOutput);
typedef ULONG (*pfXcPKGetKeyLen)(PUCHAR pbPubKey);
typedef BOOLEAN (*pfXcVerifyPKCS1Signature)(PUCHAR pbSig, PUCHAR pbPubKey, PUCHAR pbDigest);
typedef ULONG (*pfXcModExp)(ULONG* pA, ULONG* pB, ULONG* pC, ULONG* pD, ULONG dwN);
typedef void (*pfXcDESKeyParity)(PUCHAR pbKey, ULONG dwKeyLength);
typedef void (*pfXcKeyTable)(ULONG dwCipher, PUCHAR pbKeyTable, PUCHAR pbKey);
typedef void (*pfXcBlockCrypt)(ULONG dwCipher, PUCHAR pbOutput, PUCHAR pbInput, PUCHAR pbKeyTable, ULONG dwOp);
typedef void (*pfXcBlockCryptCBC)(ULONG dwCipher, ULONG dwInputLength, PUCHAR pbOutput, PUCHAR pbInput, PUCHAR pbKeyTable, ULONG dwOp, PUCHAR pbFeedback);
typedef ULONG (*pfXcCryptService)(ULONG dwOp, void* pArgs);

//
// Vector to store all ROM Crypto routines
//
typedef struct {
    pfXcSHAInit pXcSHAInit;
    pfXcSHAUpdate pXcSHAUpdate;
    pfXcSHAFinal pXcSHAFinal;
    pfXcRC4Key pXcRC4Key;
    pfXcRC4Crypt pXcRC4Crypt;
    pfXcHMAC pXcHMAC;
    pfXcPKEncPublic pXcPKEncPublic;
    pfXcPKDecPrivate pXcPKDecPrivate;
    pfXcPKGetKeyLen pXcPKGetKeyLen;
    pfXcVerifyPKCS1Signature pXcVerifyPKCS1Signature;
    pfXcModExp pXcModExp;
    pfXcDESKeyParity pXcDESKeyParity;
    pfXcKeyTable pXcKeyTable;
    pfXcBlockCrypt pXcBlockCrypt;
    pfXcBlockCryptCBC pXcBlockCryptCBC;
    pfXcCryptService pXcCryptService;
} CRYPTO_VECTOR, *PCRYPTO_VECTOR;

//
// Update the current set of crypto routines with updated ones.
// Also return back the original ROM routines if needed.
//
void
XcUpdateCrypto(
    IN PCRYPTO_VECTOR pNewVector,
    OUT OPTIONAL PCRYPTO_VECTOR pROMVector
    );

#ifdef __cplusplus
}      // extern "C"
#endif

#endif // _XCRYPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\des3.h ===
#ifndef __DES3_H__
#define __DES3_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

// In des2key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API des2key(PDES3TABLE pDES3Table, PBYTE pbKey);

// In des3key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API des3key(PDES3TABLE pDES3Table, PBYTE pbKey);

//
//   Encrypt or decrypt with the key in pKey
//

void RSA32API des3(PBYTE pbIn, PBYTE pbOut, void *pKey, int op);

//
// set the parity on the DES key to be odd
//

void RSA32API desparity(PBYTE pbKey, DWORD cbKey);

#ifdef __cplusplus
}
#endif

#endif // __DES3_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\engine.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    engine.h

Abstract:

    Defines public structures and APIs necessary to use the encryption engine

Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include "md4.h"

// This header file comes to use with FAR in it.
// Kill the FAR keyword within the file
#ifndef FAR
#define FAR
#include "descrypt.h"
#undef  FAR
#else
#include "descrypt.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\descrypt.h ===
#ifndef __DESCRYPT_H__
#define __DESCRYPT_H__

#ifdef __cplusplus
extern "C" {
#endif

#define ENCRYPT   0
#define DECRYPT   1

#ifndef DECR_KEY
#define DECR_KEY  0
#define ENCR_KEY  1
#define ENCR_STD  2
#define ENCR_SES  4
#endif

#define CRYPT_ERR 1
#define CRYPT_OK  0

unsigned FAR __cdecl
DES_CBC(    unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * IV,
            unsigned char FAR * Source,
            unsigned char FAR * Dest,
            unsigned            Size);


unsigned FAR __cdecl
DES_CBC_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * IV,
            unsigned char FAR * Source,
            unsigned char FAR * Dest,
            unsigned            Size);

unsigned FAR __cdecl
DES_ECB(    unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);

unsigned FAR __cdecl
DES_ECB_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);

#ifdef __cplusplus
}
#endif

#endif // __DESCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\hmac.h ===
#ifndef __HMAC_H__
#define __HMAC_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

// include "md5.h" before this

typedef struct {
    MD5_CTX context_ipad;
    MD5_CTX context_opad;
} HMACMD5_CTX;

// Initialize an HMAC context with a session key
//  Afterword, context can be used to sign messages with the session key
//
void
RSA32API
HMACMD5Init(
    HMACMD5_CTX * pCtx,                 // IN, OUT -- the context to initialize
    unsigned char *pKey,                // IN -- the session key
    unsigned int cKey                   // IN -- session key length
    );

// Update the signature of a message
//  takes a fragment of a message, updates signature for that fragment
void
RSA32API
HMACMD5Update(
  HMACMD5_CTX * pCtx,                   // IN, OUT -- context of signature to update
  unsigned char *pMsg,                  // IN -- message fragment
  unsigned int cMsg                     // IN -- message length
  );

// Get the signature out of the context, reset for next message
//
void
RSA32API
HMACMD5Final(
    HMACMD5_CTX * pCtx,                 // IN, OUT -- the context
    unsigned char Hash[MD5DIGESTLEN]    // OUT -- the signature
    );

#ifdef __cplusplus
}
#endif


#endif // __HMAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\GuidDef.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001. All rights reserved.
//
//  File:       guiddef.h
//
//  Contents:   GUID definition
//
//----------------------------------------------------------------------------

#ifndef GUID_DEFINED
#define GUID_DEFINED
#ifdef __midl
typedef struct {
#else
typedef struct _GUID {
#endif
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#endif

#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif
#endif

#ifdef DEFINE_GUID
#undef DEFINE_GUID
#endif

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#endif // INITGUID

#define DEFINE_OLEGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifndef _GUIDDEF_H_
#define _GUIDDEF_H_

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef GUID IID;
typedef IID *LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
typedef GUID CLSID;
typedef CLSID *LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)
typedef GUID FMTID;
typedef FMTID *LPFMTID;
#define FMTID_NULL          GUID_NULL
#define IsEqualFMTID(rfmtid1, rfmtid2) IsEqualGUID(rfmtid1, rfmtid2)

#ifdef __midl_proxy
#define __MIDL_CONST
#else
#define __MIDL_CONST const
#endif

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#ifdef __cplusplus
#define REFGUID const GUID &
#else
#define REFGUID const GUID * __MIDL_CONST
#endif
#endif

#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#ifdef __cplusplus
#define REFIID const IID &
#else
#define REFIID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#ifdef __cplusplus
#define REFCLSID const IID &
#else
#define REFCLSID const IID * __MIDL_CONST
#endif
#endif

#ifndef _REFFMTID_DEFINED
#define _REFFMTID_DEFINED
#ifdef __cplusplus
#define REFFMTID const IID &
#else
#define REFFMTID const IID * __MIDL_CONST
#endif
#endif

#endif // !__IID_DEFINED__

#if !defined (__midl)
#if !defined (_SYS_GUID_OPERATORS_)
#define _SYS_GUID_OPERATORS_
#include <string.h>

// Faster (but makes code fatter) inline version...use sparingly
#ifdef __cplusplus
__inline int InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(REFGUID rguid1, REFGUID rguid2) { return !memcmp(&rguid1, &rguid2, sizeof(GUID));}

#else   // ! __cplusplus

#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((unsigned long *) rguid1)[0] == ((unsigned long *) rguid2)[0] &&   \
        ((unsigned long *) rguid1)[1] == ((unsigned long *) rguid2)[1] &&    \
        ((unsigned long *) rguid1)[2] == ((unsigned long *) rguid2)[2] &&    \
        ((unsigned long *) rguid1)[3] == ((unsigned long *) rguid2)[3])

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

#endif  // __cplusplus

#ifdef __INLINE_ISEQUAL_GUID
#undef IsEqualGUID
#define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
#endif

// Same type, different name

#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if !defined _SYS_GUID_OPERATOR_EQ_ && !defined _NO_SYS_GUID_OPERATOR_EQ_
#define _SYS_GUID_OPERATOR_EQ_
// A couple of C++ helpers

#ifdef __cplusplus
__inline int operator==(REFGUID guidOne, REFGUID guidOther)
{
    return IsEqualGUID(guidOne,guidOther);
}

__inline int operator!=(REFGUID guidOne, REFGUID guidOther)
{
    return !(guidOne == guidOther);
}
#endif
#endif  // _SYS_GUID_OPERATOR_EQ_
#endif  // _SYS_GUID_OPERATORS_
#endif  // __midl
#endif  // _GUIDDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\md4.h ===
#ifndef __MD4_H__
#define __MD4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
** ********************************************************************
** md4.h -- Header file for implementation of                        **
** MD4 Message Digest Algorithm                                      **
** Updated: 2/13/90 by Ronald L. Rivest                              **
** (C) 1990 RSA Data Security, Inc.                                  **
** ********************************************************************
*/

#ifdef __cplusplus
extern "C" {
#endif

// MD4Update Errors
#define MD4_SUCCESS         0
#define MD4_TOO_BIG         1
#define MD4_ALREADY_DONE    2

// MD4 Digest length -- 4 word result == 16 bytes
#define MD4DIGESTLEN 16

// Block size of MD4 -- Assumes 8 bits per byte
#define MD4BLOCKSIZE 64
#define MD4BYTESTOBITS(bytes) ((bytes)*8)   // MDupdate wants bits

/* MDstruct is the data structure for a message digest computation.
*/
typedef struct {
  unsigned long buffer[4]; /* Holds 4-word result of MD computation */
  unsigned char count[8]; /* Number of bits processed so far */
  unsigned int done;      /* Nonzero means MD computation finished */
} MDstruct, *MDptr;

/* MDbegin(MD)
** Input: MD -- an MDptr
** Initialize the MDstruct prepatory to doing a message digest
** computation.
**
** MTS: Assumes MDPtr is locked against simultaneous use.
*/
extern void MDbegin(MDptr);

/* MDupdate(MD,X,count)
** Input: MD -- an MDptr
**     X -- a pointer to an array of unsigned characters.
**        count -- the number of bits of X to use (an unsigned int).
** Updates MD using the first "count" bits of X.
** The array pointed to by X is not modified.
** If count is not a multiple of 8, MDupdate uses high bits of
** last byte.
** This is the basic input routine for a user.
** The routine terminates the MD computation when count < MD4BLOCKSIZE, so
** every MD computation should end with one call to MDupdate with a
** count less than MD4BLOCKSIZE.  Zero is OK for a count.
**
** Return values:
**      MD4_SUCCESS:        success
**      MD4_TOO_LONG:       Hash is already terminated
**      MD4_ALREADY_DONE:   Length is invalid (too big)
**
** MTS: Assumes MDPtr is locked against simultaneous use.
**
**
** NOTE: MDupdate wants the length in BITS
*/
extern int MDupdate(MDptr, const unsigned char *pbData, int wLen);



/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Scott Field (sfield)    21-Oct-97

*/


#ifndef UINT4
#define UINT4   unsigned long
#endif

/* Data structure for MD4 (Message Digest) computation */
typedef struct {
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
  unsigned char digest[16];    /* actual digest after MD4Final call */
} MD4_CTX;

#define MD4_LEN 16

void RSA32API MD4Init (MD4_CTX *);
void RSA32API MD4Update (MD4_CTX *, unsigned char *, unsigned int);
void RSA32API MD4Final (MD4_CTX * );

#ifdef __cplusplus
}
#endif

#endif __MD4_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\md2.h ===
#ifndef __MD2_H__
#define __MD2_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
   rights reserved.

   License to copy and use this software is granted for
   non-commercial Internet Privacy-Enhanced Mail provided that it is
   identified as the "RSA Data Security, Inc. MD2 Message Digest
   Algorithm" in all material mentioning or referencing this software
   or this function.

   RSA Data Security, Inc. makes no representations concerning either
   the merchantability of this software or the suitability of this
   software for any particular purpose. It is provided "as is"
   without express or implied warranty of any kind.

   These notices must be retained in any copies of any part of this
   documentation and/or software.
 */


typedef struct {
  unsigned char state[16];                                 /* state */
  unsigned char checksum[16];                           /* checksum */
  unsigned int count;                 /* number of bytes, modulo 16 */
  unsigned char buffer[16];                         /* input buffer */
} MD2_CTX;

int RSA32API MD2Update(MD2_CTX *, unsigned char *, unsigned int);
int RSA32API MD2Final(MD2_CTX *);
void RSA32API MD2Transform(unsigned char [16], unsigned char [16],
                  unsigned char [16]);


#ifdef __cplusplus
}
#endif

#endif // __MD2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\modes.h ===
#ifndef __MODES_H__
#define __MODES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* modes.h

    Defines the generic routines used to do chaining modes with a
    block cipher.
*/


#ifdef __cplusplus
extern "C" {
#endif

// constants for operations
#define ENCRYPT     1
#define DECRYPT     0

/* CBC()
 *
 * Performs a XOR on the plaintext with the previous ciphertext
 *
 * Parameters:
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CBC(
         void   RSA32API Cipher(BYTE *, BYTE *, void *, int),
         DWORD  dwBlockLen,
         BYTE   *output,
         BYTE   *input,
         void   *keyTable,
         int    op,
         BYTE   *feedback
         );


/* CFB (cipher feedback)
 *
 *
 * Parameters:
 *
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CFB(
         void   RSA32API Cipher(BYTE *, BYTE *, void *, int),
         DWORD  dwBlockLen,
         BYTE   *output,
         BYTE   *input,
         void   *keyTable,
         int    op,
         BYTE   *feedback
         );


#ifdef __cplusplus
}
#endif

#endif // __MODES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\rc2.h ===
#ifndef __RC2_H__
#define __RC2_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1990.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Actual table size to use */
#define RC2_TABLESIZE 128

/* number of bytes in an RC2 block */
#define RC2_BLOCKLEN    8

/* RC2Key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *      pwKT        Pointer to a key table that will be initialized.
 *                      MUST be RC2_TABLESIZE.
 *      pbKey       Pointer to the key.
 *      dwLen       Size of the key, in bytes.
 *                      MUST be <= RC2_TABLESIZE.
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */
int
RSA32API
RC2Key (
    WORD *pwKT,
    BYTE *pbKey,
    DWORD dwLen
    );

/* RC2KeyEx()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *      pwKT        Pointer to a key table that will be initialized.
 *                      MUST be RC2_TABLESIZE.
 *      pbKey       Pointer to the key.
 *      dwLen       Size of the key, in bytes.
 *                      MUST be <= RC2_TABLESIZE.
 *      eSpace      effective key space in bits, 0 < n <= 1024
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */

int
RSA32API
RC2KeyEx (
    WORD *keyTable,
    BYTE *key,
    DWORD keyLen,
    DWORD eSpace
    );


/* RC2()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *      pbIn        Input buffer    -- MUST be RC2_BLOCKLEN
 *      pbOut       Output buffer   -- MUST be RC2_BLOCKLEN
 *      pwKT        Pointer to an initialized (by RC2Key) key table.
 *      op          ENCRYPT, or DECRYPT
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */
void RSA32API RC2 (BYTE *pbIn, BYTE *pbOut, void *pwKT, int op);

#ifdef __cplusplus
}
#endif

#endif // __RC2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\randlib.h ===
/*++

Copyright (c) 1993, 1998  Microsoft Corporation

Module Name:

    randlib.h

Abstract:

    Exported procedures for core cryptographic random number generation.

Author:

    Scott Field (sfield)    27-Oct-98

Revision History:

      Oct 11 1996 jeffspel moved from ntagimp1.h
      Aug 27 1997 sfield   Increase RAND_CTXT_LEN
      Aug 15 1998 sfield   Kernel mode and general cleanup

--*/

#ifndef __RANDLIB_H__
#define __RANDLIB_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif


typedef struct {
    unsigned long   cbSize;
    unsigned long   Flags;
    unsigned char   *pbRandSeed;
    unsigned long   cbRandSeed;
} RNG_CONTEXT, *PRNG_CONTEXT, *LPRNG_CONTEXT;

#define RNG_FLAG_REKEY_ONLY 1


//
// primary random number generation interface
// Functions return TRUE for success, FALSE for failure.
//

unsigned int
RSA32API
NewGenRandomEx(
    IN      RNG_CONTEXT *pRNGContext,
    IN  OUT unsigned char *pbRandBuffer,
    IN      unsigned long cbRandBuffer
    );


unsigned int
RSA32API
NewGenRandom(
    IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
    IN      unsigned long *pcbRandSeed,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    );

//
// RNG seed set and query
//

unsigned int
RSA32API
InitRand(
    IN  OUT unsigned char **ppbRandSeed,    // new seed value to set (over-writes current)
    IN      unsigned long *pcbRandSeed
    );

unsigned int
RSA32API
DeInitRand(
    IN  OUT unsigned char *pbRandSeed,      // output of current seed
    IN      unsigned long cbRandSeed
    );


//
// RNG initializers for DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH
//

unsigned int
RSA32API
InitializeRNG(
    VOID *pvReserved
    );

void
RSA32API
ShutdownRNG(
    VOID *pvReserved
    );



//
// RC4 thread safe primitives, for the bold users who stream data from RC4
// themselves.
//


//
// rc4_safe_startup called to initialize internal structures.
// typically called during DLL_PROCESS_ATTACH type initialiation code.
//

unsigned int
RSA32API
rc4_safe_startup(
    IN OUT  void **ppContext
    );

unsigned int
RSA32API
rc4_safe_startup_np(
    IN OUT  void **ppContext
    );


//
// typically call rc4_safe_shutdown during DLL_PROCESS_DETACH, with the
// value obtained during rc4_safe_startup
//

void
RSA32API
rc4_safe_shutdown(
    IN      void *pContext
    );

void
RSA32API
rc4_safe_shutdown_np(
    IN      void *pContext
    );


//
// select a safe entry.
// outputs: entry index
//          bytes used for specified index.  0xffffffff indicates caller
//          MUST call rc4_safe_key to initialize the key.
//          caller decides when to rekey based on non-zero output of pBytesUsed
//          example is RNG re-keying when pBytesUsed >= 16384
//


void
RSA32API
rc4_safe_select(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

void
RSA32API
rc4_safe_select_np(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

//
// initialize the key specified by Entry index.
//  key material is size cb, pointer to key is pv.
// this routine is the safe version of rc4_key()
//

void
RSA32API
rc4_safe_key(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    );

void
RSA32API
rc4_safe_key_np(
    IN      void *pContext,
    IN      unsigned int Entry, // 0xffffffff for default
    IN      unsigned int cb,
    IN      const void *pv
    );

//
// encrypt using the key specified by Entry index.
// buffer of size cb at location pv is encrypted.
// this routine is the safe version of rc4()
//

void
RSA32API
rc4_safe(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );

void
RSA32API
rc4_safe_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );


#ifdef __cplusplus
}
#endif

#endif // __RANDLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\md5.h ===
#ifndef __MD5_H__
#define __MD5_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
  ULONG FinishFlag;
} MD5_CTX;


#define MD5DIGESTLEN    16
#define MD5_LEN         MD5DIGESTLEN    // second def for WinNT source compatibility

#define PROTO_LIST(list)    list


/*
 * MTS: Each of these assumes MD5_CTX is locked against simultaneous use.
 */
void RSA32API MD5Init PROTO_LIST ((MD5_CTX *));
void RSA32API MD5Update PROTO_LIST ((MD5_CTX *, const unsigned char *, unsigned int));
void RSA32API MD5Final PROTO_LIST ((MD5_CTX *));

#ifdef __cplusplus
}
#endif

#endif // __MD5_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\rsa_fast.h ===
/* rsa_fast.h
 *
 *  Headers for performance critical RSA routines.
 */

/*
 *
 *  #defines used by RSA routines
 */

#define DIGIT_BYTES     4
#define DIGIT_BITS      32
#define DIGIT_HIBIT     0x80000000
#define DIGIT_ALLONES   0xffffffff

#define ULTRA           unsigned __int64
#define U_RADIX         (ULTRA)0x100000000
#define F_RADIX         (double)(DIGIT_HIBIT) * 2.0

#if !defined(BIGENDIAN) || !BIGENDIAN
#define LODWORD(x)      (DWORD)(x & DIGIT_ALLONES)
#else
#define LODWORD(x)      (DWORD)(x)
#endif

// warning!!!!!
// the following macro defines a highspeed 32 bit right shift by modeling an ULTRA
// as a low dword followed by a high dword.  We just pick up the high dword instead
// of shifting.

#if !defined(BIGENDIAN) || !BIGENDIAN
#define HIDWORD(x)      (DWORD)(*(((DWORD *)&x)+1))
#else
#define HIDWORD(x)      (DWORD)(*(((DWORD *)&x)))
#endif

// Sub(A, B, C, N)
// A = B - C
// All operands are N DWORDS long.

DWORD Sub(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// Add(A, B, C, N)
// A = B + C
// All operands are N DWORDS long.

DWORD Add(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// BaseMult(A, B, C, N)
// A = B * C
// returns A[N]
// All operands are N DWORDS long.

DWORD BaseMult(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// Accumulate(A, B, C, N)
// A = A + B * C
// returns A[N]
// All operands are N DWORDS long.

DWORD Accumulate(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// Reduce(A, B, C, N)
// A = A - C * B
// returns -A[N]
// All operands are N DWORDS long.

DWORD Reduce(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// square the digits in B, and add them to A

void AccumulateSquares(LPDWORD A, LPDWORD B, DWORD blen);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\rsa.h ===
#ifndef __RSA_H__
#define __RSA_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* rsa.h
 *
 *      RSA library functions.
 *
 * Copyright (C) RSA Data Security, Inc. created 1990.  This is an
 * unpublished work protected as such under copyright law.  This work
 * contains proprietary, confidential, and trade secret information of
 * RSA Data Security, Inc.  Use, disclosure or reproduction without the
 * express written authorization of RSA Data Security, Inc. is
 * prohibited.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#define RSA2 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24))

// Key header structures.
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.

typedef struct {
    DWORD       magic;                  /* Should always be RSA1 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // # of bits in modulus
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 //public exponent
} BSAFE_PUB_KEY, FAR *LPBSAFE_PUB_KEY;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef const BYTE far *cLPBYTE;                // const LPBYTE resolves wrong

// Structure for passing info into BSafe calls (currently this is used for
// passing in a callback function pointer for random number generation and
// information needed by the RNG, may eventually support exponentiation
// offload.
//

typedef struct {
    void        *pRNGInfo;              // dat
    void        *pFuncRNG;              // Function pointer for RNG callback
                                        // callback prototype is
                                        // void pFuncRNG(
                                        //        IN      void *pRNGInfo, 
                                        //        IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
                                        //        IN      unsigned long *pcbRandSeed,
                                        //        IN  OUT unsigned char *pbBuffer,
                                        //        IN      unsigned long dwLength
                                        //        );
} BSAFE_OTHER_INFO;


/* BSafeEncPublic
 *
 * BSafeEncPublic(key, part_in, part_out)
 *
 *      RSA encrypt a buffer of size key->keylen, filled with data of size
 *      key->datalen with the public key pointed to by key, returning the
 *      encrypted data in part_out.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY key - points to a public key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be encrypted.  The
 *                              data in the buffer should be no larger
 *                              than key->datalen.  All other bytes should
 *                              be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size keylen
 *                              to receive the encrypted data.
 *
 *      Returns
 *
 *              TRUE - encryption succeeded.
 *              FALSE - encryption failed.
 *
 */

BOOL
RSA32API
BSafeEncPublic(
    const LPBSAFE_PUB_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );


/* BSafeDecPrivate
 *
 * BSafeDecPrivate(key, part_in, part_out)
 *
 *      RSA decrypt a buffer of size keylen, containing key->datalen bytes
 *      of data with the private key pointed to by key, returning the
 *      decrypted data in part_out.
 *
 *      Parameters
 *
 *              LPBSAFE_PRV_KEY key - points to a private key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be decrypted.  The data
 *                              in the buffer should be no longer than
 *                              key->datalen.  All other bytes should be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size GRAINSIZE
 *                              to receive the decrypted data.
 *
 *      Returns
 *
 *              TRUE - decryption succeeded.
 *              FALSE - decryption failed.
 *
 */

BOOL
RSA32API
BSafeDecPrivate(
    const LPBSAFE_PRV_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );

/* BSafeMakeKeyPair
 *
 * BSafeMakeKeyPair(public_key, private_key, bits)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                              This value must be even and greater than 63
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPair(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits
    );

/* BSafeMakeKeyPairEx
 *
 * BSafeMakeKeyPairEx(public_key, private_key, bits, public_exp)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                                      This value must be even and greater
 *                                      than 63
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPairEx(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits,
    DWORD public_exp
    );

/* BSafeMakeKeyPairEx2
 *
 * BSafeMakeKeyPairEx2(pOtherInfo, public_key, private_key, bits, public_exp)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              BSAFE_OTHER_INFO pOtherInfo - points to a structure with information
 *                                      alternate information to be used when
 *                                      generating the RSA key pair.  Currently
 *                                      this structure has a pointer to a callback
 *                                      function which may be used when generating
 *                                      keys.  It also has a information to pass
 *                                      into that callback function (see OTHER_INFO).
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                                      This value must be even and greater
 *                                      than 63
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPairEx2(BSAFE_OTHER_INFO *pOtherInfo,
                    LPBSAFE_PUB_KEY public_key,
                    LPBSAFE_PRV_KEY private_key,
                    DWORD bits,
                    DWORD dwPubExp);

/* BSafeFreePubKey
 *
 * BSafeFreePubKey(public_key)
 *
 *      Free the data associated with a public key
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to a BSAFE_PUB_KEY
 *                               structure to free.
 *
 *      Returns
 *
 *              nothing
 *
 */

void
RSA32API
BSafeFreePubKey(
    LPBSAFE_PUB_KEY public_key
    );

/* BSafeFreePrvKey
 *
 * BSafeFreePrvKey(public_key)
 *
 *      Free the data associated with a private key
 *
 *      Parameters
 *
 *              LPBSAFE_PRV_KEY private_key - points to a BSAFE_PRV_KEY
 *                               structure to free.
 *
 *      Returns
 *
 *              nothing
 *
 */

void
RSA32API
BSafeFreePrvKey(
    LPBSAFE_PRV_KEY private_key
    );


/* BSafeComputeKeySizes
 *
 *      BSafeComputeKeySizes(   LPDWORD PubKeySize,
 *                              LPDWORD PrivKeySize,
 *                              LPDWORD bits )
 *
 *      Computes the required memory to hold a public and private key of
 *      a specified number of bits.
 *
 *      Parameters:
 *
 *              LPDWORD PubKeySize - pointer to DWORD to return the public
 *                                   key size, in bytes.
 *
 *              LPDWORD PrivKeySize - pointer to DWORD to return the private
 *                                    key size, in bytes.
 *
 *              LPDWORD bits      - pointer to DWORD specifying number of bits
 *                                  in the RSA modulus.
 *
 *      Returns:
 *
 *              TRUE if *bits is a valid RSA modulus size.
 *              FALSE if *bits is an invalid RSA modulus size.
 *
 */

BOOL
RSA32API
BSafeComputeKeySizes(
    LPDWORD PublicKeySize,
    LPDWORD PrivateKeySize,
    LPDWORD bits
    );

/* BSafeGetPrvKeyParts
 *
 * BOOL BSafeGetPrvKeyParts(    LPBSAFE_PRV_KEY key,
 *                              LPBSAFE_KEY_PARTS parts)
 *
 *      Returns pointers to the parts of a private key, and the length of
 *      the modulus in bytes.
 *
 *      Parameters:
 *
 *              LPBSAFE_PRV_KEY key     - the key to disassemble
 *              LPBSAFE_KEY_PARTS parts - the structure to fill in
 *
 *      Returns -
 *              FALSE if the key is not valid.
 */

BOOL
RSA32API
BSafeGetPrvKeyParts(
    LPBSAFE_PRV_KEY key,
    LPBSAFE_KEY_PARTS parts
    );


/* BSafeGetPubKeyModulus
 *
 * BYTE *BSafeGetPubKeyModulus(LPBSAFE_PUB_KEY key)
 *
 *      Returns pointer to the modulus of a public key
 *
 *      Parameters:
 *
 *              LPBSAFE_PUB_KEY key     - the key to disassemble
 *
 *      Returns -
 *
 *              Pointer to the parts, VOID on error.
 *              Fails if the key is not valid.
 */

BYTE *
RSA32API
BSafeGetPubKeyModulus(
    LPBSAFE_PUB_KEY key
    );

#ifdef __cplusplus
}
#endif


#endif // __RSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\rc4.h ===
#ifndef __RC4_H__
#define __RC4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Key structure */
#if defined(_WIN64) && !defined(MIDL_PASS)
__declspec(align(8))
#endif
typedef struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
} RC4_KEYSTRUCT;

/* rc4_key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *   Key        A KEYSTRUCT structure that will be initialized.
 *   dwLen      Size of the key, in bytes.
 *   pbKey      Pointer to the key.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4_key(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbKey);

/* rc4()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *   pKS        Pointer to the KEYSTRUCT created using rc4_key().
 *   dwLen      Size of buffer, in bytes.
 *   pbuf       Buffer to be encrypted.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbuf);

#ifdef __cplusplus
}
#endif

#endif // __RC4_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\rsa_math.h ===
/* rsa_math.h
 *
 *	Headers for math routines related to RSA.
 *
 *  Except for Mod(), output parameters are listed first
 */

// void Decrement(LPDWORD A, DWORD N)
// Decrement the value A of length N.
void Decrement(LPDWORD A, DWORD N);

// BOOL Increment(LPDWORD A, DWORD N)
// Increment the value A of length N.
BOOL Increment(LPDWORD A, DWORD N);

// void SetValDWORD(LPDWORD num DWORD val, WORD len)
// Set the value of num to val.
void SetValDWORD(LPDWORD num, DWORD val, DWORD len);

// void TwoPower(LPDWORD A, DWORD V, DWORD N)
// Set A to 2^^V
void TwoPower(LPDWORD A, DWORD V, DWORD N);

// DWORD DigitLen(LPDWORD A, DWORD N)
// Return the number of non-zero words in A.
// N is number of total words in A.
DWORD DigitLen(LPDWORD A, DWORD N);

// DWORD BitLen(LPDWORD A, DWORD N)
// Return the bit length of A.
// N is the number of total words in A.
DWORD BitLen(LPDWORD A, DWORD N);

// void MultiplyLow(A, B, C, N)
// A = lower half of B * C.
void MultiplyLow(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// int Compare(A, B, N)
// Return 1 if A > B
// Return 0 if A = B
// Return -1 if A < B
int Compare(LPDWORD A, LPDWORD B, DWORD N);

// Multiply(A, B, C, N)
// A = B * C
// B and C are N DWORDS long
// A is 2N DWORDS long
void Multiply(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// Square(A, B, N)
// A = B * B
// B is N DWORDS long
// A is 2N DWORDS long

void Square(LPDWORD A, LPDWORD B, DWORD N);

// Mod(A, B, R, T, N)
// R = A mod B
// T = allocated length of A
// N = allocated length of B
BOOL Mod(LPDWORD A, LPDWORD B, LPDWORD R, DWORD T, DWORD N);

// ModSquare(A, B, D, N)
// A = B ^ 2 mod D
// N = len B
BOOL ModSquare(LPDWORD A, LPDWORD B, LPDWORD D, DWORD N);

// ModMultiply(A, B, C, D, N)
// A = B * C mod D
// N = len B, C, D
BOOL ModMultiply(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD N);

// Divide(qi, ri, uu, vv, N)
// qi = uu / vv
// ri = uu mod vv
// N = len uu, vv
BOOL Divide(LPDWORD qi,LPDWORD ri, LPDWORD uu, LPDWORD vv, DWORD ll, DWORD kk);

// GCD
// extended euclid GCD.
// N = length of params
BOOL GCD(LPDWORD u3, LPDWORD u1, LPDWORD u2, LPDWORD u, LPDWORD v, DWORD k);

// ModExp
// A = B ^ C mod D
// N = len of params
BOOL ModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);

// ModRoot(M, C, PP, QQ, DP, DQ, CR)
// CRT ModExp.
BOOL ModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize) ;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\rsa_sys.h ===
/* rsa_sys.c
 *
 *	RSA system dependent functions.
 *		Memory allocation
 *		Random number generation.
 *
 */

#ifndef __RSA_SYS_H__
#define __RSA_SYS_H__

#ifndef KMODE_RSA32

#define RSA32Alloc(cb) LocalAlloc(0, cb)
#define RSA32Free(pv) LocalFree(pv)

#else

void* __stdcall RSA32Alloc( unsigned long cb );
void __stdcall RSA32Free( void *pv );

#endif  // KMODE_RSA32

#endif  // __RSA_SYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\sha.h ===
#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

typedef struct {
    DWORD       FinishFlag;
    BYTE        HashVal[A_SHA_DIGEST_LEN];
    DWORD state[5];                             /* state (ABCDE) */
    DWORD count[2];                             /* number of bytes, msb first */
    unsigned char buffer[64];                   /* input buffer */
} A_SHA_CTX;

void RSA32API A_SHAInit(A_SHA_CTX *);
void RSA32API A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
// versions that don't internally byteswap (NoSwap version), for apps like
// the RNG that don't need hash compatibility - perf increase helps.
//

void RSA32API A_SHAUpdateNS(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinalNS(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\tripldes.h ===
#ifndef __TRIPLDES_H__
#define __TRIPLDES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

//   tripledes2key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes2key(PDES3TABLE pDES3Table, BYTE *pbKey);

//   tripledes3key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes3key(PDES3TABLE pDES3Table, BYTE *pbKey);

//
//   Encrypt or decrypt with the key in pKey (DES3Table)
//

void RSA32API tripledes(BYTE *pbOut, BYTE *pbIn, void *pKey, int op);

extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __TRIPLDES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\shacomm.h ===
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHACOMM_H_
#define _SHACOMM_H_ 1

//
// this file and it's contents were made obsolete.  Only sha.h is required.
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\uint4.h ===
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _UINT4_H_
#define _UINT4_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

/* Encodes x (DWORD) into block (unsigned char), most significant
     byte first.
 */
void DWORDToBigEndian (
    unsigned char *block,
    DWORD *x,
    unsigned int digits     // number of DWORDs
    );

/* Decodes block (unsigned char) into x (DWORD), most significant
     byte first.
 */
void DWORDFromBigEndian (
    DWORD *x,
    unsigned int digits,    // number of DWORDs
    unsigned char *block
    );

/* Encodes input (DWORD) into output (unsigned char), least significant
     byte first.  Assumes len is a multiple of 4.
 */
void DWORDToLittleEndian (
    unsigned char *output,
    const DWORD *input,
    unsigned int len
    );

void DWORDFromLittleEndian (
    DWORD *output,
    const unsigned char *input,
    unsigned int len
    );


#ifdef __cplusplus
}
#endif

#endif // _UINT4_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\xcrypt.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xcrypt.h

Abstract:

    This module contains definitions the XBox encryption and certificate

--*/


#ifndef _XCRYPT_H
#define _XCRYPT_H

#ifdef __cplusplus
extern "C" {
#endif

#include "guiddef.h"

//
// Number of bits for keys in the public key algorithms
//
#define XC_KEY_BITS               (2048)

//
// Size of sigunature corresponding to the keysize.  This is the
// buffer size needed for public key encryption of a digest
//
#define XC_ENC_SIGNATURE_SIZE     ((XC_KEY_BITS + 7) / 8)

//
// Number of bytes in the public key based on the key size
//
#define XC_PUBLIC_KEYDATA_SIZE    (284)

//
// Size of our symmetric key
//
#define XC_SYMMETRIC_KEY_SIZE     16

//
// Number of bytes in a digest (same as A_SHA_DIGEST_LEN)
// NOTE: do not change this value.  XE needs this to be 20
//
#define XC_DIGEST_LEN             20

//
// Size for SHA digest
//
#define XC_SERVICE_DIGEST_SIZE    XC_DIGEST_LEN

//
// Number of bytes in SHA Buffer
//
#define XC_SERVICE_SHA_CONTEXT_SIZE  116
 
//
// Number of bytes in RC4 Buffer
//
#define XC_SERVICE_RC4_KEYSTRUCT_SIZE   258

//
// Constanst needed for DES
//
#define XC_SERVICE_DES_TABLESIZE	128
#define XC_SERVICE_DES_BLOCKLEN	    8
#define XC_SERVICE_DES_KEYSIZE	    8

#define XC_SERVICE_DES3_TABLESIZE	(3 * XC_SERVICE_DES_TABLESIZE)
#define XC_SERVICE_DES3_KEYSIZE	    24

// constants for Block operations
#define XC_SERVICE_ENCRYPT		1
#define XC_SERVICE_DECRYPT		0

// constants for selecting DES or triple DES cipher
#define XC_SERVICE_DES_CIPHER		0
#define XC_SERVICE_DES3_CIPHER		1

//
// Low level crypto API
//

VOID
XCCalcDigest(
    IN  PUCHAR MsgData,
    IN  ULONG  MsgDataLen,
    IN  PUCHAR Digest
    );

VOID
XCSymmetricEncDec(
    IN  PUCHAR MsgData,
    IN  ULONG  MsgDataLen,
    IN  PUCHAR Key,
    IN  ULONG  KeyBytes
    );

ULONG
XCCalcSigSize(
    IN  PUCHAR  pbPrivateKey
    );

ULONG
XCCalcKeyLen(
    IN  PUCHAR  pbPublicKey
    );

BOOLEAN
XCSignDigest(
    IN   PUCHAR    pbDigest,
    IN   PUCHAR    pbPrivateKey,
    OUT  PUCHAR    pbSig
    );

BOOLEAN
XCVerifyDigest(
    IN   PUCHAR   pbSig,
    IN   PUCHAR   pbPublicKey,
    IN   PUCHAR   pbWorkspace,
    IN   PUCHAR   pbCompareDigest
    );

//
// Crypto APIs the ROM exports
//

//
// Equivalent to A_SHAInit. Byte array pointed to by pbSHAContext
// must be at least XC_SERVICE_SHA_CONTEXT_SIZE (116) bytes long.
//
void
XcSHAInit(
    OUT PUCHAR pbSHAContext
    );
   
//
// Equivalent to A_SHAUpdate. Byte array pointed to by pbSHAContext
// must be at least XC_SERVICE_SHA_CONTEXT_SIZE (116) bytes long.
//
void
XcSHAUpdate(
    IN OUT PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    );
   
//
// Equivalent to A_SHAFinal.
// Byte array pbDigest must be able to hold XC_SERVICE_DIGEST_SIZE (20) bytes
//
void
XcSHAFinal(
    IN PUCHAR pbSHAContext,
    OUT PUCHAR pbDigest
    );
   
//
// Equivalent to rc4_key. Byte array pointed to by pbKeyStruct
// must be at least XC_SERVICE_RC4_KEYSTRUCT_SIZE (258) bytes long.
//
void
XcRC4Key(
    OUT PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    );
   
//
// Equivalent to rc4. Byte array pointed to by pbKeyStruct
// must be at least XC_SERVICE_RC4_KEYSTRUCT_SIZE (258) bytes long.
//
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN OUT PUCHAR pbInput
    );
   
//
// Computes SHA1-HMAC according to RFC 2104 for 2 pieces of input data.
// Byte array pbDigest must be able to hold XC_SERVICE_DIGEST_SIZE (20) bytes
//
void
XcHMAC(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput2,
    IN ULONG dwInputLength2,
    OUT PUCHAR pbDigest
    );
   
//
// Equivalent to BSafeEncPublic.
//
ULONG
XcPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    OUT PUCHAR pbOutput
    );
   
//
// Equivalent to BSafeDecPrivate.
//
ULONG
XcPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    OUT PUCHAR pbOutput
    );

//
// Get keylen for public key
//
ULONG
XcPKGetKeyLen(
    IN PUCHAR pbPubKey
    );

//
// Verify PKCS1 signature for given XC_SERVICE_DIGEST_SIZE (20) byte digest
//
BOOLEAN
XcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    );
  
//
// Equivalent to BenalohModExp
// computes A = B ^ C mod D, N = len of params in DWORDs
//
ULONG
XcModExp(
    OUT ULONG* pA,
    IN ULONG* pB,
    IN ULONG* pC,
    IN ULONG* pD,
    IN ULONG dwN
    );
   
//
// Equivalent to desparityonkey
//
void
XcDESKeyParity(
    IN OUT PUCHAR pbKey,
    IN ULONG dwKeyLength
    );
   
//
// Equivalent to deskey or tripledes3key.
// dwKeyLength must be either XC_SERVICE_DES_KEYSIZE (8) or XC_SERVICE_DES3_KEYSIZE (24)
// Byte array pbKeyTable must be able to hold XC_SERVICE_DES_TABLESIZE (128)
// or XC_SERVICE_DES3_TABLESIZE (384) bytes
//
void
XcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    );

//
// Equivalent to des or tripledes.
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1)
// dwOp must be either XC_SERVICE_DECRYPT (0) or XC_SERVICE_ENCRYPT (1)
//
void
XcBlockCrypt(
    IN ULONG dwCipher,
    OUT PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    );
   
//
// Roughly equivalent to CBC. Will loop through multiple blocks.
// dwInputLength can contain any multiple of XC_SERVICE_DES_BLOCKLEN (8)
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1)
// dwOp must be either XC_SERVICE_DECRYPT (0) or XC_SERVICE_ENCRYPT (1)
//
void
XcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    OUT PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    );

//
// Generic Crypt Service function for future extension
//
ULONG
XcCryptService(
    IN ULONG dwOp,
    IN void* pArgs
    );

//
// typedef's of all the ROM crypto exports
//
typedef void (*pfXcSHAInit)(PUCHAR pbSHAContext);
typedef void (*pfXcSHAUpdate)(PUCHAR pbSHAContext, PUCHAR pbInput, ULONG dwInputLength);
typedef void (*pfXcSHAFinal)(PUCHAR pbSHAContext, PUCHAR pbDigest);
typedef void (*pfXcRC4Key)(PUCHAR pbKeyStruct, ULONG dwKeyLength, PUCHAR pbKey);
typedef void (*pfXcRC4Crypt)(PUCHAR pbKeyStruct, ULONG dwInputLength, PUCHAR pbInput);
typedef void (*pfXcHMAC)(PUCHAR pbKey, ULONG dwKeyLength, PUCHAR pbInput, ULONG dwInputLength, PUCHAR pbInput2, ULONG dwInputLength2, PUCHAR pbDigest);
typedef ULONG (*pfXcPKEncPublic)(PUCHAR pbPubKey, PUCHAR pbInput, PUCHAR pbOutput);
typedef ULONG (*pfXcPKDecPrivate)(PUCHAR pbPrvKey, PUCHAR pbInput, PUCHAR pbOutput);
typedef ULONG (*pfXcPKGetKeyLen)(PUCHAR pbPubKey);
typedef BOOLEAN (*pfXcVerifyPKCS1Signature)(PUCHAR pbSig, PUCHAR pbPubKey, PUCHAR pbDigest);
typedef ULONG (*pfXcModExp)(ULONG* pA, ULONG* pB, ULONG* pC, ULONG* pD, ULONG dwN);
typedef void (*pfXcDESKeyParity)(PUCHAR pbKey, ULONG dwKeyLength);
typedef void (*pfXcKeyTable)(ULONG dwCipher, PUCHAR pbKeyTable, PUCHAR pbKey);
typedef void (*pfXcBlockCrypt)(ULONG dwCipher, PUCHAR pbOutput, PUCHAR pbInput, PUCHAR pbKeyTable, ULONG dwOp);
typedef void (*pfXcBlockCryptCBC)(ULONG dwCipher, ULONG dwInputLength, PUCHAR pbOutput, PUCHAR pbInput, PUCHAR pbKeyTable, ULONG dwOp, PUCHAR pbFeedback);
typedef ULONG (*pfXcCryptService)(ULONG dwOp, void* pArgs);

//
// Vector to store all ROM Crypto routines
//
typedef struct {
    pfXcSHAInit pXcSHAInit;
    pfXcSHAUpdate pXcSHAUpdate;
    pfXcSHAFinal pXcSHAFinal;
    pfXcRC4Key pXcRC4Key;
    pfXcRC4Crypt pXcRC4Crypt;
    pfXcHMAC pXcHMAC;
    pfXcPKEncPublic pXcPKEncPublic;
    pfXcPKDecPrivate pXcPKDecPrivate;
    pfXcPKGetKeyLen pXcPKGetKeyLen;
    pfXcVerifyPKCS1Signature pXcVerifyPKCS1Signature;
    pfXcModExp pXcModExp;
    pfXcDESKeyParity pXcDESKeyParity;
    pfXcKeyTable pXcKeyTable;
    pfXcBlockCrypt pXcBlockCrypt;
    pfXcBlockCryptCBC pXcBlockCryptCBC;
    pfXcCryptService pXcCryptService;
} CRYPTO_VECTOR, *PCRYPTO_VECTOR;

//
// Update the current set of crypto routines with updated ones.
// Also return back the original ROM routines if needed.
//
void
XcUpdateCrypto(
    IN PCRYPTO_VECTOR pNewVector,
    OUT OPTIONAL PCRYPTO_VECTOR pROMVector
    );

#ifdef __cplusplus
}      // extern "C"
#endif

#endif // _XCRYPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\crypto\swincryp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       wincrypt.h
//
//  Contents:   Cryptographic API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __SWINCRYP_H__
#define __SWINCRYP_H__

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
SCryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
BOOL
WINAPI
SCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
#ifdef UNICODE
#define SCryptAcquireContext  SCryptAcquireContextW
#else
#define SCryptAcquireContext  SCryptAcquireContextA
#endif // !UNICODE


BOOL
WINAPI
SCryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags);


BOOL
WINAPI
SCryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

BOOL
WINAPI
SCryptDuplicateKey(
    HCRYPTKEY hKey,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTKEY * phKey);

BOOL
WINAPI
SCryptDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);


BOOL
WINAPI
SCryptDestroyKey(
    HCRYPTKEY hKey);

BOOL
WINAPI
SCryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

BOOL
WINAPI
SCryptGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

BOOL
WINAPI
SCryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

BOOL
WINAPI
SCryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

BOOL
WINAPI
SCryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

BOOL
WINAPI
SCryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

BOOL
WINAPI
SCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

BOOL
WINAPI
SCryptDuplicateHash(
    HCRYPTHASH hHash,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTHASH * phHash);

BOOL
WINAPI
SCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen);

BOOL
WINAPI
SCryptDestroyHash(
    HCRYPTHASH hHash);

BOOL
WINAPI
SCryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

BOOL
WINAPI
SCryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

#ifdef UNICODE
#define SCryptSignHash  SCryptSignHashW
#else
#define SCryptSignHash  SCryptSignHashA
#endif // !UNICODE

BOOL
WINAPI
SCryptVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);

BOOL
WINAPI
SCryptVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);

#ifdef UNICODE
#define SCryptVerifySignature  SCryptVerifySignatureW
#else
#define SCryptVerifySignature  SCryptVerifySignatureA
#endif // !UNICODE

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __SWINCRYP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\ispu\wintrustp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       wintrustP.h
//
//  Contents:   Microsoft Internet Security Trust PRIVATE INCLUDE
//
//  History:    20-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WINTRUSTP_H
#define WINTRUSTP_H

#include    <wincrypt.h>

#ifdef __cplusplus
extern "C" 
{
#endif

#pragma pack(8)

typedef struct WINTRUST_PBCB_INFO_
{
    DWORD                       cbStruct;

    LPCWSTR                     pcwszFileName;
    HANDLE                      hFile;

    DWORD                       cbContent;
    BYTE                        *pbContent;

    struct WINTRUST_ADV_INFO_   *psAdvanced;    // optional

} WINTRUST_PBCB_INFO, *PWINTRUST_PBCB_INFO;

typedef struct WINTRUST_ADV_INFO_
{
    DWORD           cbStruct;

    DWORD           dwStoreFlags;
#                       define      WTCI_DONT_OPEN_STORES   0x00000001  // only open dummy "root" all other are in pahStores.
#                       define      WTCI_OPEN_ONLY_ROOT     0x00000002

    DWORD           chStores;       // number of stores in pahStores
    HCERTSTORE      *pahStores;     // array of stores to add to internal list

    GUID            *pgSubject;     // Optional: SIP to load

} WINTRUST_ADV_INFO, *PWINTRUST_ADV_INFO;

#pragma pack()

//////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrustEx
//----------------------------------------------------------------------------
//      *** DO NOT USE ***
//
//
extern HRESULT WINAPI WinVerifyTrustEx(HWND hwnd, GUID *pgActionID, 
                                       WINTRUST_DATA *pWinTrustData);

//////////////////////////////////////////////////////////////////////////////
//
// TrustFindIssuerCertificate
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern PCCERT_CONTEXT WINAPI TrustFindIssuerCertificate(IN PCCERT_CONTEXT pChildContext,
                                                        IN DWORD dwEncoding,
                                                        IN DWORD chStores,
                                                        IN HCERTSTORE  *pahStores,
                                                        IN FILETIME *psftVerifyAsOf,
                                                        OUT OPTIONAL DWORD *pdwConfidence,
                                                        OUT OPTIONAL DWORD *pdwError,
                                                        IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////////
//
// TrustOpenStores
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern BOOL WINAPI TrustOpenStores(IN HCRYPTPROV hProv,
                                   IN OUT DWORD *chStores,
                                   IN OUT OPTIONAL HCERTSTORE *pahStores,
                                   IN DWORD dwFlags);


//////////////////////////////////////////////////////////////////////////////
//
// TrustIsCertificateSelfSigned
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern BOOL WINAPI TrustIsCertificateSelfSigned(IN PCCERT_CONTEXT pContext,
                                                IN DWORD dwEncoding, 
                                                IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////////
//
// Exported "helper" functions
//----------------------------------------------------------------------------
//  

extern BOOL WINAPI WTHelperOpenKnownStores(CRYPT_PROVIDER_DATA *pProvData);

#define     WTH_ALLOC                       0x00000001
#define     WTH_FREE                        0x00000002
extern BOOL WINAPI                      WTHelperGetKnownUsages(DWORD fdwAction, 
                                                               PCCRYPT_OID_INFO **ppOidInfo);

extern HANDLE WINAPI                    WTHelperGetFileHandle(WINTRUST_DATA *pWintrustData);
extern WCHAR * WINAPI                   WTHelperGetFileName(WINTRUST_DATA *pWintrustData);
extern BOOL WINAPI                      WTHelperCertIsSelfSignedEx(DWORD dwEncoding, PCCERT_CONTEXT pContext);
extern BOOL WINAPI                      WTHelperOpenKnownStores(CRYPT_PROVIDER_DATA *pProvData);
extern BOOL WINAPI                      WTHelperCheckCertUsage(PCCERT_CONTEXT pCertContext, 
                                                               LPCSTR pszRequestedUsageOID);
extern BOOL WINAPI                      WTHelperIsInRootStore(CRYPT_PROVIDER_DATA *pProvData, 
                                                              PCCERT_CONTEXT pCertContext);
extern BOOL WINAPI                      WTHelperGetAgencyInfo(PCCERT_CONTEXT pCert, 
                                                              DWORD *pcbAgencyInfo, 
                                                              struct _SPC_SP_AGENCY_INFO *psAgencyInfo);


#define WVT_MODID_WINTRUST              0x00000001
#define WVT_MODID_SOFTPUB               0x00010000
#define WVT_MODID_MSSIP                 0x00001000
extern BOOL WINAPI TrustDecode(DWORD dwModuleId, BYTE **ppbRet, DWORD *pcbRet, DWORD cbHint,
                               DWORD dwEncoding, const char *pcszOID, const BYTE *pbEncoded, DWORD cbEncoded,
                               DWORD dwDecodeFlags);
extern BOOL WINAPI TrustFreeDecode(DWORD dwModuleId, BYTE **pbAllocated);




#ifdef __cplusplus
}
#endif

#endif // WINTRUSTP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\netdb.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  netdb.h

Abstract:

  This contains the #defines for the tcp/ip net database operations

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version

--*/

/*-
 * Copyright (c) 1980, 1983, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *      @(#)netdb.h     5.11 (Berkeley) 5/21/90
 */

#ifndef NETDB_INCLUDED
#define NETDB_INCLUDED

#define _PATH_HEQUIV    "/etc/hosts.equiv"
#define _PATH_HOSTS     "/etc/hosts"
#define _PATH_NETWORKS  "/etc/networks"
#define _PATH_PROTOCOLS "/etc/protocols"
#define _PATH_SERVICES  "/etc/services"

/*
 * Structures returned by network data base library.  All addresses are
 * supplied in host order, and returned in network order (suitable for
 * use in system calls).
 */
struct  hostent {
        char    *h_name;        /* official name of host */
        char    **h_aliases;    /* alias list */
        int     h_addrtype;     /* host address type */
        int     h_length;       /* length of address */
        char    **h_addr_list;  /* list of addresses from name server */
#define h_addr  h_addr_list[0]  /* address, for backward compatiblity */
};

/*
 * Assumption here is that a network number
 * fits in 32 bits -- probably a poor one.
 */
struct  netent {
        char            *n_name;        /* official name of net */
        char            **n_aliases;    /* alias list */
        int             n_addrtype;     /* net address type */
        unsigned long   n_net;          /* network # */
};

struct  servent {
        char    *s_name;        /* official service name */
        char    **s_aliases;    /* alias list */
        int     s_port;         /* port # */
        char    *s_proto;       /* protocol to use */
};

struct  protoent {
        char    *p_name;        /* official protocol name */
        char    **p_aliases;    /* alias list */
        int     p_proto;        /* protocol # */
};


//
// Network table access function prototypes
//

struct hostent *
gethostbyname(
    char *name
    );

struct hostent *
gethostbyaddr(
    char *addr,
    int   len,
    int   type
    );

void
sethostent(
    int stayopen
    );

void
endhostent(
    void
    );

struct netent *
getnetent(
    void
    );

struct netent *
getnetbyaddr(
    unsigned long net,
    int           type
    );

struct netent *
getnetbyname(
    char *name
    );

void
setnetent(
    int stayopen
    );

void
endnetent(
    void
    );

struct protoent *
getprotoent(
    void
    );

struct protoent *
getprotobynumber(
    int proto
    );

struct protoent *
getprotobyname(
    char *name
    );

void
setprotoent(
    int stayopen
    );

void
endprotoent(
    void
    );

struct servent *
getservent(
    void
    );

struct servent *
getservbyport(
    int   port,
    char *proto
    );

struct servent *
getservbyname(
    char *name,
    char *proto
    );

void
setservent(
    int stayopen
    );
	
void
endservent(
    void
    );

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (left in extern int h_errno).
 */

#define HOST_NOT_FOUND  1 /* Authoritative Answer Host not found */
#define TRY_AGAIN       2 /* Non-Authoritive Host not found, or SERVERFAIL */
#define NO_RECOVERY     3 /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define NO_DATA         4 /* Valid name, no data record of requested type */
#define NO_ADDRESS      NO_DATA         /* no address, look for MX record */

#endif  //NETDB_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\arpa\ftp.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  ftp.h

Abstract:

  ftp daemon definitions

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version

--*/

/******************************************************************
 *
 *  SpiderTCP Socket Utilities
 *
 *  Copyright 1987  Spider Systems Limited
 *
 *  FTP.H
 *
 *    FTP Daemon - Definitions (see RFC-765)
 *
 *
 ******************************************************************/

/*
 *       /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/arpa/0/s.ftp.h
 *      @(#)ftp.h       1.2
 *
 *      Last delta created      20:46:15 6/24/88
 *      This file extracted     08:53:49 7/10/91
 *
 *      Modifications:
 *
 *      PR 01/12/87     Integrated into Admin System II, all
 *                      projects
 */

#ifndef FTP_INCLUDED
#define FTP_INCLUDED

/*
 * Reply codes.
 */
#define PRELIM          1       /* positive preliminary */
#define COMPLETE        2       /* positive completion */
#define CONTINUE        3       /* positive intermediate */
#define TRANSIENT       4       /* transient negative completion */
#define FTP_ERROR       5       /* permanent negative completion */

/*
 * Type codes
 */
#define TYPE_A          1       /* ASCII */
#define TYPE_E          2       /* EBCDIC */
#define TYPE_I          3       /* image */
#define TYPE_L          4       /* local byte size */

/*
 * Form codes
 */
#define FORM_N          1       /* non-print */
#define FORM_T          2       /* telnet format effectors */
#define FORM_C          3       /* carriage control (ASA) */

/*
 * Structure codes
 */
#define STRU_F          1       /* file (no record structure) */
#define STRU_R          2       /* record structure */
#define STRU_P          3       /* page structure */

/*
 * Mode types
 */
#define MODE_S          1       /* stream */
#define MODE_B          2       /* block */
#define MODE_C          3       /* compressed */

/*
 * Record Tokens
 */
#define REC_ESC         '\377'  /* Record-mode Escape */
#define REC_EOR         '\001'  /* Record-mode End-of-Record */
#define REC_EOF         '\002'  /* Record-mode End-of-File */

/*
 * Block Header
 */
#define BLK_EOR         0x80    /* Block is End-of-Record */
#define BLK_EOF         0x40    /* Block is End-of-File */
#define BLK_ERRORS      0x20    /* Block is suspected of containing errors */
#define BLK_RESTART     0x10    /* Block is Restart Marker */

#define BLK_BYTECOUNT   2       /* Bytes in this block */

#endif  //FTP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\resolv.h ===
/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  RESOLV.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/0/s.resolv.h
 *  @(#)resolv.h    5.3
 *
 *  Last delta created  14:05:35 3/4/91
 *  This file extracted 11:19:25 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1987, 1989 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)resolv.h    5.10 (Berkeley) 6/1/90
 */

#ifndef _RESOLV_INCLUDED
#define _RESOLV_INCLUDED

/*
 * Global defines and variables for resolver stub.
 */
#define MAXNS            8  /* max # name servers we'll track per list */
#define MAXNSLIST        4  /* max # name servers lists we'll track */
#define MAXDFLSRCH       3  /* # default domain levels to try */
#define MAXDNSRCH        6  /* max # domains in search path */
#define LOCALDOMAINPARTS 2  /* min levels in name that is "local" */
#define RES_TIMEOUT      5  /* min. seconds between retries */

typedef struct _ADDR_LIST {
    u_long ServerCount;
    u_long Servers[MAXNS];

} ADDR_LIST, FAR * LPADDR_LIST;

struct state {
    long       options;             /* option flags - see below. */
    int        retrans;             /* retransmition time interval */
    u_short    retry;               /* number of times to retransmit */
    u_short    id;                  /* current packet id */
    ADDR_LIST  nslist[MAXNSLIST];   /* the server lists */
    char       defdname[MAXDNAME];  /* default domain */
    char      *dnsrch[MAXDNSRCH+1]; /* components of domain to search */
};

/*
 * Resolver options
 */
#define RES_INIT        0x0001      /* address initialized */
#define RES_DEBUG       0x0002      /* print debug messages */
#define RES_AAONLY      0x0004      /* authoritative answers only */
#define RES_USEVC       0x0008      /* use virtual circuit */
#define RES_PRIMARY     0x0010      /* query primary server only */
#define RES_IGNTC       0x0020      /* ignore trucation errors */
#define RES_RECURSE     0x0040      /* recursion desired */
#define RES_DEFNAMES    0x0080      /* use default domain name */
#define RES_STAYOPEN    0x0100      /* Keep TCP socket open */
#define RES_DNSRCH      0x0200      /* search up local domain tree */

#define RES_DEFAULT (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)


//
// Resolver function prototypes
//

int
dn_expand(
    IN  unsigned char *msg,
    IN  unsigned char *eomorig,
    IN  unsigned char *comp_dn,
    OUT unsigned char *exp_dn,
    IN  int            length
    );

int
dn_comp(
    IN      unsigned char  *exp_dn,
    OUT     unsigned char  *comp_dn,
    IN      int             length,
    IN      unsigned char **dnptrs,     OPTIONAL
    IN OUT  unsigned char **lastdnptr   OPTIONAL
    );

int
res_init(
    void
    );

int
res_send(
    IN  char *buf,
    IN  int buflen,
    OUT char *answer,
    IN  int anslen
    );

int
res_query(
    IN  char          *name,      /* domain name */
    IN  int            class,     /* class of query */
    IN  int            type,      /* type of query */
    OUT unsigned char *answer,    /* buffer to put answer */
    IN  int            anslen     /* size of answer buffer */
    );

int
res_search(
    IN  char           *name,     /* domain name */
    IN  int            class,     /* class of query */
    IN  int            type,      /* type of query */
    OUT unsigned char *answer,    /* buffer to put answer */
    IN  int            anslen     /* size of answer */
    );

int
res_mkquery(
    IN  int          op,             // opcode of query
    IN  char        *dname,          // domain name
    IN  int          class,                  // class of query
    IN  int          type,               // type of query
    IN  char        *data,    OPTIONAL       // resource record data
    IN  int          datalen, OPTIONAL       // length of data
    IN  struct rrec *newrr,   OPTIONAL       // new rr for modify or append
    OUT char        *buf,            // buffer to put query
    IN  int          buflen                  // size of buffer
    );

#endif    // _RESOLV_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\arpa\inet.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  inet.h

Abstract:

  ARPANet include file - network address defines and macros

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version

--*/

/******************************************************************
 *
 *  SpiderTCP Net Utilities
 *
 *  Copyright 1987  Spider Systems Limited
 *
 *  INET.H
 *
 *    ARPANet include file - network address defines and macros
 *
 ******************************************************************/

/*
 *       /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/arpa/0/s.inet.h
 *      @(#)inet.h      1.5
 *
 *      Last delta created      19:04:03 4/17/89
 *      This file extracted     08:53:50 7/10/91
 *
 *      Modifications:
 *
 *      IPH - 24/09/86  extend protocol table entries to include the
 *                        protocol number and the protocol receive &
 *                        transmit queues.
 *       PR - 01/12/87  Integrated into Admin System II, all projects
 */

#ifndef INET_INCLUDED
#define INET_INCLUDED

/*
 * External definitions for
 * functions in inet(3N)
 */
        
unsigned long
inet_netof(
    IN struct in_addr in
    );

unsigned long PASCAL
inet_addr(
    IN const char *cp
    );

unsigned long
inet_network(
    IN char *cp
    );

unsigned long
inet_lnaof(
    IN struct in_addr in
    );

char FAR *
PASCAL FAR inet_ntoa(
    IN struct in_addr in
    );

struct in_addr
inet_makeaddr(
        IN unsigned long net,
        IN unsigned long host
        );

#endif  //INET_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\arpa\bootp.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  bootp.h

Abstract:

  Include file for the bootp daemon.

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version

--*/

/******************************************************************
 *
 *  SpiderTCP Include Files
 *
 *  Copyright 1989  Spider Systems Limited
 *
 *  BOOTP.H
 *
 *  Include file for the booting daemon,
 *  which uses BOOTP (bootstrap protocol).
 *  See [SRI-NIC]<RFC>RFC951.TXT for a description of the protocol.
 *
 ******************************************************************/

/*
 *       /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/arpa/0/s.bootp.h
 *      @(#)bootp.h     1.1
 *
 *      Last delta created      16:45:42 6/14/89
 *      This file extracted     08:53:49 7/10/91
 *
 *      Modifications:
 *
 *              GSS     23 May 89       New File
 */

#ifndef BOOTP_INCLUDED
#define BOOTP_INCLUDED

struct bootp {
        unchar  bp_op;          /* packet opcode type */
#define BOOTREQUEST     1
#define BOOTREPLY       2
        unchar  bp_htype;       /* hardware addr type */
        unchar  bp_hlen;        /* hardware addr length */
        unchar  bp_hops;        /* gateway hops */
        ulong   bp_xid;         /* transaction ID */
        ushort  bp_secs;        /* seconds since boot began */
        ushort  bp_unused;
        iaddr_t bp_ciaddr;      /* client IP address */
        iaddr_t bp_yiaddr;      /* 'your' IP address */
        iaddr_t bp_siaddr;      /* server IP address */
        iaddr_t bp_giaddr;      /* gateway IP address */
        unchar  bp_chaddr[16];  /* client hardware address */
        unchar  bp_sname[64];   /* server host name */
        unchar  bp_file[128];   /* boot file name */
        unchar  bp_vend[64];    /* vendor-specific area */
};

#endif  //BOOTP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\sock_err.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  sock_err.h

Abstract:

   This module contains error codes for sockets and STREAMS sources.

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version  (in posix\sys\errno.h)
  9-19-91    mikemas  extracted these codes from posix\sys\errno.h

Notes:

--*/
/*
 *      Copyright (c) 1984 AT&T
 *      Copyright (c) 1987 Fairchild Semiconductor Corporation
 *      Copyright 1987 Lachman Associates, Incorporated (LAI)
 *        All Rights Reserved
 *
 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T,
 *      FAIRCHILD SEMICONDUCTOR CORPORATION,
 *      (AND LACHMAN ASSOCIATES)
 *      AND SPIDER SYSTEMS.
 *
 *      stcp copyright above and this notice must be preserved in all
 *      copies of this source code.  The copyright above does not
 *      evidence any actual or intended publication of this source
 *      code
 */

#ifndef SOCK_ERR_INCLUDED
#define SOCK_ERR_INCLUDED


// in CRT #define ENOTBLK 54      /* Block device required                */
// in CRT #define ETXTBSY 55      /* Text file busy                       */
#define ENOMSG  56      /* No message of desired type           */
#define EIDRM   57      /* Identifier removed                   */
#define ECHRNG  58      /* Channel number out of range          */
#define EL2NSYNC 59     /* Level 2 not synchronized             */
#define EL3HLT  60      /* Level 3 halted                       */
#define EL3RST  61      /* Level 3 reset                        */
#define ELNRNG  62      /* Link number out of range             */
#define EUNATCH 63      /* Protocol driver not attached         */
#define ENOCSI  64      /* No CSI structure available           */
#define EL2HLT  65      /* Level 2 halted                       */

/* Convergent Error Returns */
#define EBADE   66      /* invalid exchange                     */
#define EBADR   67      /* invalid request descriptor           */
#define EXFULL  68      /* exchange full                        */
#define ENOANO  69      /* no anode                             */
#define EBADRQC 70      /* invalid request code                 */
#define EBADSLT 71      /* invalid slot                         */
// in CRT #define EDEADLOCK 72    /* file locking deadlock error          */

#define EBFONT  73      /* bad font file fmt                    */

/* stream problems */
#define ENOSTR  74      /* Device not a stream                  */
#define ENODATA 75      /* no data (for no delay io)            */
#define ETIME   76      /* timer expired                        */
#define ENOSR   77      /* out of streams resources             */

#define ENONET  78      /* Machine is not on the network        */
#define ENOPKG  79      /* Package not installed                */
#define EREMOTE 80      /* The object is remote                 */
#define ENOLINK 81      /* the link has been severed */
#define EADV    82      /* advertise error */
#define ESRMNT  83      /* srmount error */

#define ECOMM   84      /* Communication error on send          */
#define EPROTO  85      /* Protocol error                       */
#define EMULTIHOP 86    /* multihop attempted */
#define ELBIN   87      /* Inode is remote (not really error)*/
#define EDOTDOT 88      /* Cross mount point (not really error)*/
#define EBADMSG 89      /* trying to read unreadable message    */

#define ENOTUNIQ 90     /* given log. name not unique */
#define EREMCHG  91     /* Remote address changed */

/* shared library problems */
#define ELIBACC 92      /* Can't access a needed shared lib.    */
#define ELIBBAD 93      /* Accessing a corrupted shared lib.    */
#define ELIBSCN 94      /* .lib section in a.out corrupted.     */
#define ELIBMAX 95      /* Attempting to link in too many libs. */
#define ELIBEXEC        96      /* Attempting to exec a shared library. */


/*
 * Additional error codes for the socket library
 */

#define EWOULDBLOCK     EAGAIN          /* Operation would block */

#define ENOTSOCK        100             /* Socket operation on non-socket */
#define EADDRNOTAVAIL   101             /* Can't assign requested address */
#define EADDRINUSE      102             /* Address already in use */
#define EAFNOSUPPORT    103
                        /* Address family not supported by protocol family */
#define ESOCKTNOSUPPORT 104             /* Socket type not supported */
#define EPROTONOSUPPORT 105             /* Protocol not supported */
#define ENOBUFS         106             /* No buffer space available */
#define ETIMEDOUT       107             /* Connection timed out */
#define EISCONN         108             /* Socket is already connected */
#define ENOTCONN        109             /* Socket is not connected */
#define ENOPROTOOPT     110             /* Bad protocol option */
#define ECONNRESET      111             /* Connection reset by peer */
#define ECONNABORT      112             /* Software caused connection abort */
#define ENETDOWN        113             /* Network is down */
#define ECONNREFUSED    114             /* Connection refused */
#define EHOSTUNREACH    115             /* Host is unreachable */
#define EPROTOTYPE      116             /* Protocol wrong type for socket */
#define EOPNOTSUPP      117             /* Operation not supported on socket */

#define ETIMEOUT        ETIMEDOUT

/*
 * these originate from the Internet Module
 */
#define ESUBNET         118             /* IP subnet table full */
#define ENETNOLNK       119             /* Subnet module not linked */
#define EBADIOCTL       120             /* Unknown ioctl call */
#define ERESOURCE       121             /* Failure in Streams buffer allocn */

#define EPROTUNR        122             /* ICMP Protocol unreachable    */
#define EPORTUNR        123             /* ICMP Port unreachable        */
#define ENETUNR         124             /* ICMP Network unreachable     */

#define ENETUNREACH     ENETUNR         /* ICMP Network unreachable     */

/*
 * Ethernet Driver Errors
 */

#define EPACKET         150             /* Invalid Ethernet Packet */
#define ETYPEREG        151             /* Type registration error */

/*
 * Socket library call
 */

#define ENOTINIT        152             /* Sockets library not initialized */


#endif  //SOCK_ERR_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\arpa\nameser.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nameser.h

Abstract:

    Definitions for the DNS resolver and nameserver.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  NAMESER.H
 *
 ******************************************************************/

/*
 *	 /usr/projects/tcp/SCCS.rel3/rel/src/include/arpa/0/s.nameser.h
 *	@(#)nameser.h	5.3
 *
 *	Last delta created	14:06:04 3/4/91
 *	This file extracted	11:19:28 3/8/91
 *
 *	Modifications:
 *
 *		GSS	20 Jul 90	New File
 */

/*
 * Copyright (c) 1983, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)nameser.h	5.24 (Berkeley) 6/1/90
 */

#ifndef _NAMESER_INCLUDED
#define _NAMESER_INCLUDED


/*
 * Define constants based on rfc883
 */
#define PACKETSZ	512		/* maximum packet size */
#define MAXDNAME	256		/* maximum domain name */
#define MAXCDNAME	255		/* maximum compressed domain name */
#define MAXLABEL	63		/* maximum length of domain label */
	/* Number of bytes of fixed size data in query structure */
#define QFIXEDSZ	4
	/* number of bytes of fixed size data in resource record */
#define RRFIXEDSZ	10

/*
 * Internet nameserver port number
 */
#define NAMESERVER_PORT	53

/*
 * Currently defined opcodes
 */
#define QUERY		0x0		/* standard query */
#define IQUERY		0x1		/* inverse query */
#define STATUS		0x2		/* nameserver status query */
/*#define xxx		0x3		/* 0x3 reserved */
	/* non standard */
#define UPDATEA		0x9		/* add resource record */
#define UPDATED		0xa		/* delete a specific resource record */
#define UPDATEDA	0xb		/* delete all nemed resource record */
#define UPDATEM		0xc		/* modify a specific resource record */
#define UPDATEMA	0xd		/* modify all named resource record */

#define ZONEINIT	0xe		/* initial zone transfer */
#define ZONEREF		0xf		/* incremental zone referesh */

/*
 * Currently defined response codes
 */
#ifndef NOERROR
#define NOERROR		0		/* no error */
#endif
#define FORMERR		1		/* format error */
#define SERVFAIL	2		/* server failure */
#define NXDOMAIN	3		/* non existent domain */
#define NOTIMP		4		/* not implemented */
#define REFUSED		5		/* query refused */
	/* non standard */
#define NOCHANGE	0xf		/* update failed to change db */

/*
 * Type values for resources and queries
 */
#define T_A	        1		/* host address */
#define T_NS		2		/* authoritative server */
#define T_MD		3		/* mail destination */
#define T_MF		4		/* mail forwarder */
#define T_CNAME		5		/* connonical name */
#define T_SOA		6		/* start of authority zone */
#define T_MB		7		/* mailbox domain name */
#define T_MG		8		/* mail group member */
#define T_MR		9		/* mail rename name */
#define T_NULL		10		/* null resource record */
#define T_WKS		11		/* well known service */
#define T_PTR		12		/* domain name pointer */
#define T_HINFO		13		/* host information */
#define T_MINFO		14		/* mailbox information */
#define T_MX		15		/* mail routing information */
#define T_TXT		16		/* text strings */
#define T_AFSDB		18		/* AFS database servers */
#define T_ATMA 		34		/* ATM endpoint address */
	/* non standard */
#define T_UINFO		100		/* user (finger) information */
#define T_UID		101		/* user ID */
#define T_GID		102		/* group ID */
#define T_UNSPEC	103		/* Unspecified format (binary data) */
	/* Query type values which do not appear in resource records */
#define T_AXFR		252		/* transfer zone of authority */
#define T_MAILB		253		/* transfer mailbox records */
#define T_MAILA		254		/* transfer mail agent records */
#define T_ANY		255		/* wildcard match */

/*
 * Values for class field
 */

#define C_IN		1		/* the arpa internet */
#define C_CHAOS		3		/* for chaos net at MIT */
#define C_HS		4		/* for Hesiod name server at MIT */
	/* Query class values which do not appear in resource records */
#define C_ANY		255		/* wildcard match */

/*
 * Status return codes for T_UNSPEC conversion routines
 */
#define CONV_SUCCESS 0
#define CONV_OVERFLOW -1
#define CONV_BADFMT -2
#define CONV_BADCKSUM -3
#define CONV_BADBUFLEN -4

#ifndef BYTE_ORDER
#define	LITTLE_ENDIAN	1234	/* least-significant byte first (vax) */
#define	BIG_ENDIAN	4321	/* most-significant byte first (IBM, net) */
#define	PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp) */

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || \
    defined(BIT_ZERO_ON_RIGHT)
#define BYTE_ORDER	LITTLE_ENDIAN

#endif
#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined (BIT_ZERO_ON_LEFT)
#define BYTE_ORDER	BIG_ENDIAN
#endif
#ifndef BYTE_ORDER		/* still not defined */
#if defined(u3b2) || defined(m68k)
#define BYTE_ORDER	BIG_ENDIAN
#endif
#if defined(i286) || defined(i386) || defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_) || defined(_IA64_)
#define BYTE_ORDER	LITTLE_ENDIAN
#endif
#endif /* ~BYTE_ORDER */
#endif /* BYTE_ORDER */

#ifndef BYTE_ORDER
	/* you must determine what the correct bit order is for your compiler */
	UNDEFINED_BIT_ORDER;
#endif
/*
 * Structure for query header, the order of the fields is machine and
 * compiler dependent, in our case, the bits within a byte are assignd
 * least significant first, while the order of transmition is most
 * significant first.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
	unsigned short	id;		/* query identification number */
#if BYTE_ORDER == BIG_ENDIAN
			/* fields in third byte */
	unsigned char	qr:1;		/* response flag */
	unsigned char	opcode:4;	/* purpose of message */
	unsigned char	aa:1;		/* authoritive answer */
	unsigned char	tc:1;		/* truncated message */
	unsigned char	rd:1;		/* recursion desired */
			/* fields in fourth byte */
	unsigned char	ra:1;		/* recursion available */
	unsigned char	pr:1;		/* primary server required (non standard) */
	unsigned char	unused:2;	/* unused bits */
	unsigned char	rcode:4;	/* response code */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
			/* fields in third byte */
	unsigned char	rd:1;		/* recursion desired */
	unsigned char	tc:1;		/* truncated message */
	unsigned char	aa:1;		/* authoritive answer */
	unsigned char	opcode:4;	/* purpose of message */
	unsigned char	qr:1;		/* response flag */
			/* fields in fourth byte */
	unsigned char	rcode:4;	/* response code */
	unsigned char	unused:2;	/* unused bits */
	unsigned char	pr:1;		/* primary server required (non standard) */
	unsigned char	ra:1;		/* recursion available */
#endif
			/* remaining bytes */
	unsigned short	qdcount;	/* number of question entries */
	unsigned short	ancount;	/* number of answer entries */
	unsigned short	nscount;	/* number of authority entries */
	unsigned short	arcount;	/* number of resource entries */
} HEADER;

/*
 * Defines for handling compressed domain names
 */
#define INDIR_MASK	0xc0

/*
 * Structure for passing resource records around.
 */
struct rrec {
	short	        r_zone;			/* zone number */
	short	        r_class;		/* class number */
	short	        r_type;			/* type number */
	unsigned long	r_ttl;			/* time to live */
	int	        r_size;			/* size of data area */
	char	       *r_data;		        /* pointer to data */
};

extern	unsigned short	_getshort();
extern	unsigned long	_getlong();

/*
 * Inline versions of get/put short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be unsigned char *.
 */
#define GETSHORT(s, cp) { \
	(s) = *(cp)++ << 8; \
	(s) |= *(cp)++; \
}

#define GETLONG(l, cp) { \
	(l) = *(cp)++ << 8; \
	(l) |= *(cp)++; (l) <<= 8; \
	(l) |= *(cp)++; (l) <<= 8; \
	(l) |= *(cp)++; \
}


#define PUTSHORT(s, cp) { \
	*(cp)++ = (s) >> 8; \
	*(cp)++ = (s); \
}

/*
 * Warning: PUTLONG destroys its first argument.
 */
#define PUTLONG(l, cp) { \
	(cp)[3] = l; \
	(cp)[2] = (l >>= 8); \
	(cp)[1] = (l >>= 8); \
	(cp)[0] = l >> 8; \
	(cp) += sizeof(unsigned long); \
}

#endif  // _NAMESER_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\netinet\in.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  in.h

Abstract:

  A version of the BSD 4.2 file <netinet/in.h> for NT tcp

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version

--*/

/******************************************************************
 *
 *  SpiderTCP Application Include Files
 *
 *  Spider Systems Limited
 *
 *  IN.H
 *
 *    A version of the BSD 4.2 file <netinet/in.h>
 *    for SpiderTCP
 *
 *
 ******************************************************************/

/*
 *       /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/netinet/0/s.in.h
 *      @(#)in.h        1.31
 *
 *      Last delta created      13:33:59 8/27/90
 *      This file extracted     08:53:51 7/10/91
 *
 *      Modifications:
 *
 */

#ifndef IN_INCLUDED
#define IN_INCLUDED


#ifdef PROJ8
/*
 *      BYTESWAP should be undef'ed if the machine's byte order
 *      is the same as network byte order - if it is the reverse
 *      it should be set to 1.
 */
#define BYTESWAP        1
#endif
#ifdef PROJ11
/*
 *      BYTESWAP should be undef'ed if the machine's byte order
 *      is the same as network byte order - if it is the reverse
 *      it should be set to 1.
 */
#define BYTESWAP        1
#endif

#ifdef PROJ9
/*
 *      BYTESWAP should be undef'ed if the machine's byte order
 *      is the same as network byte order - if it is the reverse
 *      it should be set to 1.
 */
#if m68k
#undef  BYTESWAP
#define EMBED           1
#else
#define BYTESWAP        1
#undef EMBED
#endif
#endif


#ifndef BYTESWAP
#    ifdef i386
#        define BYTESWAP 1
#    endif
#    ifdef MIPS
#        define BYTESWAP 1
#    endif
#    ifdef ALPHA
#        define BYTESWAP 1
#    endif
#    ifdef PPC
#        define BYTESWAP 1
#    endif
#    ifdef IA64
#        define BYTESWAP 1
#    endif
#endif


#define TLI_TCP         "/dev/tcp"      /* or else */
#define TLI_UDP         "/dev/udp"      /* or else */

/*
 * Protocols
 */
#define IPPROTO_IP            256               /* IP (for socket options etc) */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_EGP             8               /* exterior gateway protocol */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256


#define ICMP_PROT       IPPROTO_ICMP
#define GWAY_PROT       3
#define TCP_PROT        IPPROTO_TCP
#define UDP_PROT        IPPROTO_UDP


#include <sys\snet\ip_proto.h>

#if 0
/*
 * define structure for DARPA internet address
 * usually use "longs" to access but sometimes need to split into
 * components
 */

typedef union {
                char  typea[4]; /* 4 x 8 bit version */
                short typeb[2];  /* 2 x 16 bit */
                long  typec;     /* 1 x 32 bit */
} IN_ADDRESS;
#endif


/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

#define IPPORT_BIFFUDP          512
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_WHOSERVER        513
#define IPPORT_CMDSERVER        514

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158


/*
 * Internet address
 */
struct in_addr {
        union {
                struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { unsigned short s_w1,s_w2; } S_un_w;
                unsigned long S_addr;
        } S_un;
#define s_addr  S_un.S_addr     /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2        /* host on imp */
#define s_net   S_un.S_un_b.s_b1        /* network */
#define s_imp   S_un.S_un_w.s_w2        /* imp */
#define s_impno S_un.S_un_b.s_b4        /* imp # */
#define s_lh    S_un.S_un_b.s_b3        /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 */
#define IN_CLASSA(i)            ((((long)(i))&0x80000000)==0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            ((((long)(i))&0xc0000000)==0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            ((((long)(i))&0xe0000000)==0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              0x00000000
#define INADDR_BROADCAST        0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   		sin_family;
        unsigned short  sin_port;
        struct  in_addr sin_addr;
        char    		sin_zero[8];
};

/* Length of a SOCKADDR or SOCKADDR_IN structure */
#define SOCAD_LEN 16

#ifdef BYTESWAP

#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

//
//BUGBUG - we need to investigate this
//

#define	FUTURE	1
#ifdef FUTURE
/*
 * this macro should be used if its faster than the function
 * - measure it on the target machine
 */
#ifndef i386
#define htonl(x)        ((((x) >> 24) & 0x000000FFL) | \
                        (((x) >>  8) & 0x0000FF00L) | \
                        (((x) <<  8) & 0x00FF0000L) | \
                        (((x) << 24) & 0xFF000000L))
#else

__inline long
htonl(long x)
{
	return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L) |
                        (((x) << 24) & 0xFF000000L));
}

#endif /* i386 */
#else
extern long htonl();
#endif
#undef	FUTURE

#define ntohs(x)        htons(x)
#define ntohl(x)        htonl(x)

#define MASKA   0x000000FFL
#define MASKB   0x0000FFFFL
#define MASKC   0x00FFFFFFL
#define CLSHFT  5               /* Make C generate hyper-optimized case */

#else
/*
 * Macros for number representation conversion.
 */
#define ntohl(x)        (x)
#define ntohs(x)        (x)
#define htonl(x)        (x)
#define htons(x)        (x)

#define MASKA   0xFF000000L
#define MASKB   0xFFFF0000L
#define MASKC   0xFFFFFF00L
#define CLSHFT  29
#endif

#define CLA0    0               /* It takes the same arg; you mask it off, */
#define CLA1    1               /* shift, and then do a case statment with */
#define CLA2    2               /* some code having more than one label. */
#define CLA3    3               /* Values for class A */
#define CLB0    4
#define CLB1    5               /* B */
#define CLC     6               /* C */
#define CLI     7               /* Illegal */

#define BROADCAST 0x00000000L

#define CASTA   0x00FFFFFFL
#define CASTB   0x0000FFFFL
#define CASTC   0x000000FFL


/******************************************************************
 *
 * Type Codes for Ethernet packets
 *
 ******************************************************************/

#define TY_ETHER 1
#ifndef TYPE_HACK
#define TY_PUP          0x0200
#define TY_IDP          0x0600
#define TY_IP           0x0800
#define TY_X25          0x0805
#define TY_ARP          0x0806
#define TY_RARP         0x8035
#ifndef NOTRAILER
#define TY_TRAIL        0x1000
#define TY_TRAIL_LO     0x1001
#define TY_TRAIL_HI     0x1002
#endif
#define TY_ECHO         0x9000
#else /*TYPE_HACK*/
#define TY_PUP          0x0200
#define TY_IDP          0x0600
#define TY_IP           0x0807          /* modified */
#define TY_X25          0x0805
#define TY_ARP          0x0808          /* modified */
#ifndef NOTRAILER
#define TY_TRAIL        0x2000          /* modified */
#define TY_TRAIL_LO     0x2001          /* modified */
#define TY_TRAIL_HI     0x2002          /* modified */
#endif
#define TY_ECHO         0x9000
#endif /*TYPE_HACK*/

/******************************************************************
 *
 * Type Codes for Arcnet packets
 *
 ******************************************************************/

#define ARCNET_TY_IP   0xd4
#define ARCNET_TY_ARP  0xd5
#define ARCNET_TY_RARP 0xd6

/*
 * LOOPBACK Address - in host and network byte order
 */
#define LOOPBACK 0x7F000001L
#ifdef BYTESWAP
#define NLOOPBACK 0x0100007FL
#else
#define NLOOPBACK 0x7F000001L
#endif

/*
 * interface flags
 */
#define IFF_UP                  0x01
#define IFF_BROADCAST           0x02
#define IFF_LOOPBACK            0x04
#define IFF_POINTOPOINT         0x08
#define IFF_FORWARDBROADCAST    0x10
#define IFF_NOKEEPALIVE         0x20
#define IFF_SLOWLINK            0x40


/*
 * IP Options
 */

#define IPO_TTL         103
#define IPO_TOS         104
#define IPO_OPTS        105
#define IPO_RDOPTION    106
#define IPO_RDROUTE     IPO_RDOPTION
#define IPO_OPTCOUNT    107
#define IPO_RRCOUNT     IPO_OPTCOUNT


/*
 * IP Option values
 */

#define OPT_SECURITY    130
#define OPT_LSRR        131
#define OPT_SSRR        137
#define OPT_RR            7
#define OPT_STRID       136
#define OPT_TIMESTAMP    68

/*
 * Default Time to Live
 */

#define IHTTL   60

/*
 * Maximum number of hops stored in a recorded route packet
 */

#define TCP_RR_MAX      16

#define MAXOPTLEN 256

#ifndef GENERICE
/*
 * errors generated
 */
#define EFRGSZ  1
#define EDLTYPE 2
#define EPRIM   3
#define EBUF    4
#define EMSG    5
#endif /*~GENERICE*/

#endif  //IN_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\arpa\telnet.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  telnet.h

Abstract:

  User telnet, remote login utility - includes.  Taken directly from Spider's
  sources

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version

--*/

/******************************************************************
 *
 *  SpiderTCP Socket Utilities
 *
 *  Copyright 1987  Spider Systems Limited
 *
 *  TELNET.H
 *
 *    User telnet, remote login utility - includes
 *
 *
 ******************************************************************/

/*
 *       /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/arpa/0/s.telnet.h
 *      @(#)telnet.h    1.2
 *
 *      Last delta created      20:46:00 6/24/88
 *      This file extracted     08:53:50 7/10/91
 *
 *      Modifications:
 *
 *      PR 01/12/87     Integrated into Admin System II, all
 *                      projects
 */

#ifndef TELNET_INCLUDED
#define TELNET_INCLUDED

/*
 * Definitions for the TELNET protocol.
 */
#define IAC     255             /* interpret as command: */
#define DONT    254             /* you are not to use option */
#define DO      253             /* please, you use option */
#define WONT    252             /* I won't use option */
#define WILL    251             /* I will use option */
#define SB      250             /* interpret as subnegotiation */
#define GA      249             /* you may reverse the line */
#define EL      248             /* erase the current line */
#define EC      247             /* erase the current character */
#define AYT     246             /* are you there */
#define AO      245             /* abort output--but let prog finish */
#define IP      244             /* interrupt process--permanently */
#define BREAK   243             /* break */
#define DM      242             /* data mark--for connect. cleaning */
#define NOP     241             /* nop */
#define SE      240             /* end sub negotiation */

#define SYNCH   242             /* for telfunc calls */

/* Telnet options - Names have been truncated to be unique in 7 chars */


#define TO_BINARY       0       /* 8-bit data path */
#define TO_ECHO         1       /* echo */
#define TO_RCP          2       /* prepare to reconnect */
#define TO_SGA          3       /* suppress go ahead */
#define TO_NAMS         4       /* approximate message size */
#define TO_STATUS       5       /* give status */
#define TO_TM           6       /* timing mark */
#define TO_RCTE         7       /* remote controlled transmission and echo */
#define TO_NL           8       /* negotiate about output line width */
#define TO_NP           9       /* negotiate about output page size */
#define TO_NCRD         10      /* negotiate about CR disposition */
#define TO_NHTS         11      /* negotiate about horizontal tabstops */
#define TO_NHTD         12      /* negotiate about horizontal tab disposition */
#define TO_NFFD         13      /* negotiate about formfeed disposition */
#define TO_NVTS         14      /* negotiate about vertical tab stops */
#define TO_NVTD         15      /* negotiate about vertical tab disposition */
#define TO_NLFD         16      /* negotiate about output LF disposition */
#define TO_XASCII       17      /* extended ascic character set */
#define TO_LOGOUT       18      /* force logout */
#define TO_BM           19      /* byte macro */
#define TO_DET          20      /* data entry terminal */
#define TO_SUPDUP       21      /* supdup protocol */
#define TO_TERM_TYPE    24      /* terminal type */
#define TO_EXOPL        255     /* extended-options-list */

/* Define (real) long names to be the shorter ones */

#define TELOPT_BINARY   TO_BINARY
#define TELOPT_ECHO     TO_ECHO
#define TELOPT_RCP      TO_RCP
#define TELOPT_SGA      TO_SGA
#define TELOPT_NAMS     TO_NAMS
#define TELOPT_STATUS   TO_STATUS
#define TELOPT_TM       TO_TM
#define TELOPT_RCTE     TO_RCTE
#define TELOPT_NAOL     TO_NL
#define TELOPT_NAOP     TO_NP
#define TELOPT_NAOCRD   TO_NCRD
#define TELOPT_NAOHTS   TO_NHTS
#define TELOPT_NAOHTD   TO_NHTD
#define TELOPT_NAOFFD   TO_NFFD
#define TELOPT_NAOVTS   TO_NVTS
#define TELOPT_NAOVTD   TO_NVTD
#define TELOPT_NAOLFD   TO_NLFD
#define TELOPT_XASCII   TO_XASCII
#define TELOPT_LOGOUT   TO_LOGOUT
#define TELOPT_BM       TO_BM
#define TELOPT_DET      TO_DET
#define TELOPT_SUPDUP   TO_SUPDUP
#define TELOPT_EXOPL    TO_EXOPL

#ifdef TELCMDS
char *telcmds[] = {
        "SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC",
        "EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC",
};
#endif

#ifdef TELOPTS
char *telopts[] = {
        "BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME",
        "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
        "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
        "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
        "DATA ENTRY TERMINAL", "SUPDUP"
};
#endif

#endif  //TELNET_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\sys\psxsock.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  psxsock.h

Abstract:

	Types, prototypes and definitions for Win32 sockets.

Author:

  	Sam Patton (sampa)   September 11, 1991

Revision History:

  when        	who      what
  ----        	---      ----
  11-21-91      mikemas  intitial version - cloned from winsock.h

--*/

#ifndef PSXSOCK_INCLUDED
#define PSXSOCK_INCLUDED

//
// POSIX includes
//
// #include <posix.h>


//
// POSIX-specific defintions
//
#define INVALID_SOCKET_HANDLE  ((int) -1)
#define SOCKET_HANDLE          int


//
// common sockets include file
//
#include <sys\socket.h>


//
// Prototypes for all exported socket functions
//

SOCKET_HANDLE
accept(
    IN SOCKET_HANDLE,              //socket to accept on
    OUT struct sockaddr *,         //peer address
    OUT int *);                    //size of peer address

int
bind(
    IN SOCKET_HANDLE,              //socket to bind
    IN struct sockaddr *,          //address to bind to
    IN int);                       //size of address

int
connect(
    IN SOCKET_HANDLE,              //socket to connect from
    IN struct sockaddr *,          //address to connect to
    IN int);                       //size of address

int
listen(
    IN SOCKET_HANDLE,              //socket to listen with
    IN int);                       //length of listen queue

int
getpeername(
    IN SOCKET_HANDLE,              //connected socket to get peer of
    OUT struct sockaddr *,         //buffer to put peer address into
    OUT int *);                    //length of buffer

int
getsockname(
    IN SOCKET_HANDLE,              //socket to get the address of
    OUT struct sockaddr *,         //buffer to put my address into
    OUT int *);                    //length of buffer


int
poll(
    IN OUT struct pollfd *,
    IN unsigned int,
    IN int);

int
recv(
    IN SOCKET_HANDLE,              //socket to receive with
    IN char *,                     //buffer to receive into
    IN int,                        //size of buffer
    IN int);                       //receive flags

int
recvfrom(
    IN SOCKET_HANDLE,              //socket to receive with
    OUT char *,                    //buffer to receive into
    IN int,                        //size of buffer
    IN int,                        //receive flags
    OUT struct sockaddr *,         //address received from
    OUT int *);                    //size of address

int
send(
    IN SOCKET_HANDLE,              //socket to send from
    IN char *,                     //buffer to send
    IN int,                        //size of buffer
    IN int);                       //send flags

int
sendto(
    IN SOCKET_HANDLE,              //socket to send from
    IN char *,                     //buffer to send
    IN int,                        //size of buffer
    IN int,                        //send flags
    IN struct sockaddr *,          //address to send to
    IN int);                       //size of address

SOCKET_HANDLE
socket(
    IN int,                         //address family
    IN int,                         //socket type
    IN int);                        //protocol

int
so_recv(
    IN SOCKET_HANDLE,               //socket to receive with
    OUT char *,                     //buffer to receive into
    IN int,                         //size of buffer
    OUT int *);                     //receive flags

int
setsockopt(
	IN SOCKET_HANDLE,
	int,
	int,
	char *,
	int);

int
getsockopt(
	IN SOCKET_HANDLE,
	int,
	int,
	char *,
	int *);

int
shutdown(
	IN SOCKET_HANDLE,
	IN int);

	
//
// Host name control
//
	
int
gethostname(
    OUT char *name,
    IN int namelen
    );

int
sethostname (
    IN char *name,
    IN int   namelen
    );


//
//  Remote execution utilities
//

SOCKET_HANDLE
rcmd(
    IN OUT char         **ahost,
    IN unsigned short     inport,
    IN char              *locuser,
    IN char              *remuser,
    IN char              *cmd,
    IN OUT SOCKET_HANDLE        *fd2p      OPTIONAL
    );

SOCKET_HANDLE
rresvport(
    IN OUT unsigned short *port
    );

SOCKET_HANDLE
rexec(
    IN  char          **ahost,
    IN  unsigned short  rport,
    IN  char           *name,
    IN  char           *pass,
    IN  char           *cmd,
    OUT SOCKET_HANDLE         *fd2p      OPTIONAL
    );


//
//  Resolver error return utilities
//

DWORD
GetLastHError(
    VOID
    );

VOID
SetLastHError(
    DWORD ErrCode
    );


#endif //PSXSOCK_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\sys\winsock.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  winsock.h

Abstract:

	Types, prototypes and definitions for Win32 sockets.

Author:

  	Sam Patton (sampa)   September 11, 1991

Revision History:

  when        	who      what
  ----        	---      ----
   9-11-91      sampa    initial version
  11-21-91      mikemas  introduced socket type definitions, moved prototypes
                            into socket.h

--*/

#ifndef WINSOCK_INCLUDED
#define WINSOCK_INCLUDED


// Windows includes
#include <windows.h>


//
// Windows-specific defintions
//
#define INVALID_SOCKET_HANDLE  INVALID_HANDLE_VALUE
#define SOCKET_HANDLE          HANDLE


//
// common sockets include file
//
#include <sockets\sys\socket.h>


//
// Prototypes for all exported socket functions
//

SOCKET_HANDLE
accept(
    IN SOCKET_HANDLE,              //socket to accept on
    OUT struct sockaddr *,         //peer address
    OUT int *);                    //size of peer address

int
bind(
    IN SOCKET_HANDLE,              //socket to bind
    IN struct sockaddr *,          //address to bind to
    IN int);                       //size of address

int
connect(
    IN SOCKET_HANDLE,              //socket to connect from
    IN struct sockaddr *,          //address to connect to
    IN int);                       //size of address

int
listen(
    IN SOCKET_HANDLE,              //socket to listen with
    IN int);                       //length of listen queue

int
getpeername(
    IN SOCKET_HANDLE,              //connected socket to get peer of
    OUT struct sockaddr *,         //buffer to put peer address into
    OUT int *);                    //length of buffer

int
getsockname(
    IN SOCKET_HANDLE,              //socket to get the address of
    OUT struct sockaddr *,         //buffer to put my address into
    OUT int *);                    //length of buffer

int
recv(
    IN SOCKET_HANDLE,              //socket to receive with
    IN char *,                     //buffer to receive into
    IN int,                        //size of buffer
    IN int);                       //receive flags

int
recvfrom(
    IN SOCKET_HANDLE,              //socket to receive with
    OUT char *,                    //buffer to receive into
    IN int,                        //size of buffer
    IN int,                        //receive flags
    OUT struct sockaddr *,         //address received from
    OUT int *);                    //size of address

int
send(
    IN SOCKET_HANDLE,              //socket to send from
    IN char *,                     //buffer to send
    IN int,                        //size of buffer
    IN int);                       //send flags

int
sendto(
    IN SOCKET_HANDLE,              //socket to send from
    IN char *,                     //buffer to send
    IN int,                        //size of buffer
    IN int,                        //send flags
    IN struct sockaddr *,          //address to send to
    IN int);                       //size of address

SOCKET_HANDLE
socket(
    IN int,                         //address family
    IN int,                         //socket type
    IN int);                        //protocol

int
so_recv(
    IN SOCKET_HANDLE,               //socket to receive with
    OUT char *,                     //buffer to receive into
    IN int,                         //size of buffer
    OUT int *);                     //receive flags

int
setsockopt(
	IN SOCKET_HANDLE,
	int,
	int,
	char *,
	int);

int
getsockopt(
	IN SOCKET_HANDLE,
	int,
	int,
	char *,
	int *);

int
shutdown(
	IN SOCKET_HANDLE,
	IN int);

	
//
// Host name control
//
	
int
gethostname(
    OUT char *name,
    IN int namelen
    );

int
sethostname (
    IN char *name,
    IN int   namelen
    );


//
//  Remote execution utilities
//

SOCKET_HANDLE
rcmd(
    IN OUT char         **ahost,
    IN unsigned short     inport,
    IN char              *locuser,
    IN char              *remuser,
    IN char              *cmd,
    IN OUT SOCKET_HANDLE        *fd2p      OPTIONAL
    );

SOCKET_HANDLE
rresvport(
    IN OUT unsigned short *port
    );

SOCKET_HANDLE
rexec(
    IN  char          **ahost,
    IN  unsigned short  rport,
    IN  char           *name,
    IN  char           *pass,
    IN  char           *cmd,
    OUT SOCKET_HANDLE         *fd2p      OPTIONAL
    );


//
//  Resolver error return utilities
//

DWORD
GetLastHError(
    VOID
    );

VOID
SetLastHError(
    DWORD ErrCode
    );


#endif //WINSOCK_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\stropts.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stropts.h

Abstract:

    This module defines the STREAMS ioctl message interface.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/*
 * Streams ioctl message interface
 *
 * @(#)stropts.h	1.19 (Spider) 91/11/27
 */

#ifndef _SYS_STROPTS_
#define _SYS_STROPTS_

#ifndef _NTDDSTRM_
#include <ntddstrm.h>
#endif


/*
 * Read options
 */

#define RNORM	0x00			/* Normal - bytes stream */
#define RMSGD	0x01			/* Message, non-discard mode */
#define RMSGN	0x02			/* Message, discard mode */

#define RMASK	0x0F			/* mask for read options */

/*
 * Protocol read options
 */

#define	RPROTNORM	0x00		/* Fail reads with EBADMSG */
#define RPROTDIS	0x10		/* Discard proto part */
#define RPROTDAT	0x20		/* Turn proto part into data */

#define RPROTMASK	0xF0		/* mask for protocol read options */

/*
 * Values for I_ATMARK argument
 */

#define	ANYMARK		0		/* check if message is marked */
#define	LASTMARK	1		/* check if last one marked */

/*
 * Value for I_SWROPT argument
 */

#define	NOSNDZERO	0		/* disallow zero length sends */
#define	SNDZERO		1		/* permit zero length sends */

/*
 * STREAMS ioctl defines
 */

#define STR             ('S'<<8)
#define I_NREAD         (STR|1)
#define I_PUSH          (STR|2)
#define I_POP           (STR|3)
#define I_LOOK          (STR|4)
#define I_FLUSH         (STR|5)
#define I_SRDOPT        (STR|6)
#define I_GRDOPT        (STR|7)
#define I_STR           (STR|8)
#define I_SETSIG        (STR|9)
#define I_GETSIG        (STR|10)
#define I_FIND          (STR|11)
#define I_LINK          (STR|12)
#define I_UNLINK        (STR|13)
#define I_PEEK          (STR|15)
#define I_FDINSERT      (STR|16)
#define I_SENDFD        (STR|17)
#define I_RECVFD        (STR|18)
#ifdef SVR2
#define I_GETMSG        (STR|19)
#define I_PUTMSG        (STR|20)
#define I_GETID		(STR|21)
#define I_POLL		(STR|22)
#endif /*SVR2*/
#define	I_SWROPT	(STR|23)
#define	I_GWROPT	(STR|24)
#define	I_LIST		(STR|25)
#define	I_ATMARK	(STR|26)
#define	I_SETCLTIME	(STR|27)
#define	I_GETCLTIME	(STR|28)
#define	I_PLINK		(STR|29)
#define	I_PUNLINK	(STR|30)
#define I_DEBUG         (STR|31)
#define	I_CLOSE		(STR|32)


#define MUXID_ALL	-1

/*
 * Structure for I_FDINSERT ioctl
 */

struct strfdinsert {
        struct strbuf ctlbuf;
        struct strbuf databuf;
        long          flags;
        HANDLE        fildes;
        int           offset;
};


/*
 * Structures for I_DEBUG ioctl
 */
typedef enum _str_trace_options {
    MSG_TRACE_PRINT =      0x00000001,
    MSG_TRACE_FLUSH =      0x00000002,
    MSG_TRACE_ON =         0x00000004,
    MSG_TRACE_OFF =        0x00000008,
    POOL_TRACE_PRINT =     0x00000010,
    POOL_TRACE_FLUSH =     0x00000020,
    POOL_TRACE_ON =        0x00000040,
    POOL_TRACE_OFF =       0x00000080,
    POOL_FAIL_ON =         0x00000100,
    POOL_FAIL_OFF =        0x00000200,
    LOCK_TRACE_ON =        0x00000400,
    LOCK_TRACE_OFF =       0x00000800,
    QUEUE_PRINT =          0x00001000,
    BUFFER_PRINT =         0x00002000,
    POOL_LOGGING_ON =      0x00004000,
    POOL_LOGGING_OFF =     0x00008000
} str_trace_options;


struct strdebug {
    ULONG  trace_cmd;
};


/*
 * stream I_PEEK ioctl format
 */

struct strpeek {
	struct strbuf ctlbuf;
	struct strbuf databuf;
	long          flags;
};

/*
 * receive file descriptor structure
 */
struct strrecvfd {
#ifdef INKERNEL
        union {
                struct file *fp;
                int fd;
        } f;
#else
        int fd;
#endif
        unsigned short uid;
        unsigned short gid;
        char fill[8];
};

#define FMNAMESZ	8

struct str_mlist {
	char l_name[FMNAMESZ+1];
};

struct str_list {
	int sl_nmods;
	struct str_mlist *sl_modlist;
};

/*
 * get/putmsg flags
 */

#define RS_HIPRI	1	/* High priority message */

#define MORECTL		1
#define MOREDATA	2


/*
 * M_SETSIG flags
 */

#define S_INPUT		1
#define S_HIPRI		2
#define S_OUTPUT	4
#define S_MSG		8
#define S_ERROR		16
#define S_HANGUP	32

/*
 * Flags for MFLUSH messages
 */
#define FLUSHW		01	/* flush downstream */
#define FLUSHR		02	/* flush upstream */
#define FLUSHRW		(FLUSHR | FLUSHW)

#endif /* _SYS_STROPTS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\uio.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    uio.h

Abstract:

    I/O structure definitions for compatibility with BSD.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  Spider BSD Compatibility
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  UIO.H
 *
 ******************************************************************/

/*
 *       /usr/projects/tcp/SCCS.rel3/rel/src/include/bsd/sys/0/s.uio.h
 *      @(#)uio.h       5.3
 *
 *      Last delta created      14:41:47 3/4/91
 *      This file extracted     11:24:29 3/8/91
 *
 *      Modifications:
 *
 *              GSS     19 Jun 90       New File
 */

/*
 * Copyright (c) 1982, 1986 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *      @(#)uio.h       7.1 (Berkeley) 6/4/86
 */

#ifndef _UIO_
#define _UIO_

typedef long                   daddr_t;
typedef char FAR *             caddr_t;

struct iovec {
        caddr_t iov_base;
        int     iov_len;
};

struct uio {
        struct  iovec *uio_iov;
        int     uio_iovcnt;
        int     uio_offset;
        int     uio_segflg;
        int     uio_resid;
};

enum    uio_rw { UIO_READ, UIO_WRITE };

/*
 * Segment flag values (should be enum).
 */
#define UIO_USERSPACE   0               /* from user data space */
#define UIO_SYSSPACE    1               /* from system space */
#define UIO_USERISPACE  2               /* from user I space */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sockets\sys\socket.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  socket.h

Abstract:

  contains types and #defines for sockets.

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

  when        who     what
  ----        ---     ----
  7-26-91    sampa    initial version

--*/

/******************************************************************
 *
 *  SpiderTCP System Include Files
 *
 *  Copyright 1987  Spider Systems Limited
 *
 *  SOCKET.H
 *
 *    Definitions related to sockets:
 *    types, address families, options.
 *
 *
 ******************************************************************/


#ifndef SYS_SOCKET_INCLUDED
#define SYS_SOCKET_INCLUDED
/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x01            /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x02            /* socket has had listen() */
#define SO_REUSEADDR    0x04            /* allow local address reuse */
#define SO_KEEPALIVE    0x08            /* keep connections alive */
#define SO_DONTROUTE    0x10            /* just use interface addresses */
#define SO_BROADCAST    0x20            /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x40            /* bypass hardware when possible */
#define SO_LINGER       0x80            /* linger on close if data present */
#define SO_RDWR         0x100           /* User read/write for datagram sockets */
#define SO_NODELAY      0x200           /* Forward data expediently */
#define SO_URGENT       0x400           /* Notify urgent data */

#ifdef TESTOPT
#define SO_TESTOPT      0x800           /* option for testing internals */
#endif
#ifdef UNDEF
 /*
  * I don't think we use these?? NCF
  */

/*
 * Additional options, not kept in so_options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#endif

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        int     l_onoff;                /* option on/off */
        int     l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_NS           3               /* XNS -- not implemented */
#define AF_IMPLINK      4               /* IMP link layer -- not implemented */
#define AF_NETBIOS      5               /* NetBios, unique to NT */
#define AF_LOOPBACK     6               /* for testing only */

#ifdef ROUTED
#define AF_MAX          6               /* must be > 2 for ROUTED */
#else
#define AF_MAX          6
#endif

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        unsigned short  sa_family;      /* address family */
        char            sa_data[14];    /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        unsigned short  sp_family;              /* address family */
        unsigned short  sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET

#define PF_MAX          2

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */
#ifdef UNDEF
#define MSG_PEEK        0x2             /* peek at incoming message */
#endif

#define OOB_PEND        0x08            /* Urgent data pending */

#define MSG_MAXIOVLEN   16


#endif  //SYS_SOCKET_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\poll.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

  poll.h

Abstract:

  Contains #defines, types, and macros for poll

Author:

  Sam Patton (sampa)   July 26, 1991

Revision History:

--*/

#ifndef SYS_POLL_INCLUDED
#define SYS_POLL_INCLUDED

/*
 * Structure of file descriptor/event pairs supplied in
 * the poll arrays.
 */
struct pollfd {
#ifndef _POSIX_SOURCE
        HANDLE fd;                      /* file handle to poll */
#else
        int   fd;                       /* file desc to poll */
#endif
        short events;                   /* events of interest on fd */
        short revents;                  /* events that occurred on fd */
};

/*
 * Testable select events
 */
#define POLLIN          01              /* fd is readable */
#define POLLPRI         02              /* priority info at fd */
#define POLLOUT         04              /* fd is writeable (won't block) */
#define POLLMSG         0100            /* M_SIG or M_PCSIG arrived */

/*
 * Non-testable poll events (may not be specified in events field,
 * but may be returned in revents field).
 */
#define POLLERR         010             /* fd has error condition */
#define POLLHUP         020             /* fd has been hung up on */
#define POLLNVAL        040             /* invalid pollfd entry */

/*
 * Number of pollfd entries to read in at a time in poll.
 * The larger the value the better the performance, up to the
 * maximum number of open files allowed.  Large numbers will
 * use excessive amounts of kernel stack space.
 */
#define NPOLLFILE       20


/*
 * Poll function prototype
 *
 */

int
poll(
    IN OUT struct pollfd *,
    IN unsigned int,
    IN int);


#endif  //SYS_POLL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\adp_ctrl.h ===
/*
 *	 /redknee10/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.adp_control.h
 *	@(#)adp_control.h	1.1
 *
 *	Last delta created	09:32:52 11/13/91
 *	This file extracted	09:26:04 3/18/92
 *
 *	Modifications:
 *	
 *		RAE	13 Nov 1991	New File
 */

#define ADP_SETSNID (('A'<<8) | 1)	/* set ADP snid */

struct adp_snioc {
	uint8	adp_snid;
	uint32	adp_index;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\bsd_type.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bsd_type.h.h

Abstract:

    This module contains definitions for BSD compatibility for
    STREAMS drivers.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/*************************************************************************
 *
 *  SpiderTCP/SNMP
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  BSD_TYPES.H
 *
 *  some #defines for BSD compatibility
 *
 *
 *************************************************************************/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.bsd_types.h
 *	@(#)bsd_types.h	1.3
 *
 *	Last delta created	11:54:01 10/16/90
 *	This file extracted	08:53:46 7/10/91
 *
 *	Modifications:
 *
 *	GSS 01/03/90	put in Pbrain
 */

#ifndef _SYS_SNET_BSD_TYPE_
#define _SYS_SNET_BSD_TYPE_


#ifndef u_char
#define u_char	unsigned char
#define u_short unsigned short
#define u_long 	unsigned long
#define u_int 	unsigned int
#endif


/*
 * Select uses bit masks of file descriptors in integers.
 * These macros manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h). In the current implementation it should
 * not exceed 32 (sizeof int).
 */
#ifndef	FD_SETSIZE
#define	FD_SETSIZE	32
#endif

/* number of bits in a byte */
#define NBBY 8

typedef int	fd_mask;
#define NFDBITS	(sizeof(fd_mask) * NBBY)	/* bits per mask */
#ifndef howmany
#define	howmany(x, y)	(((x)+((y)-1))/(y))
#endif

typedef	struct fd_set {
 	fd_mask	fds_bits[howmany(FD_SETSIZE, NFDBITS)];
} fd_set;


#define	FD_SET(n, p)	((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
#define	FD_CLR(n, p)	((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
#define	FD_ISSET(n, p)	((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
#define FD_ZERO(p)	bzero((char *)(p), sizeof(*(p)))

#endif /* _SYS_SNET_BSD_TYPE_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\arp_ctrl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    arp_ctrl.h

Abstract:

    This file defines the user-level IOCTL interface to the ARP driver.

Author:

    Mike Massa (mikemas)           Jan 18, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-18-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP ARP Interface Primitives
 *
 *  Copyright 1988  Spider Systems Limited
 *
 *  arp_control.h
 *
 *  ARP Streams ioctl primitives for SpiderTCP
 *
 ******************************************************************/

/*
 *       /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.arp_control.h
 *      @(#)arp_control.h       1.5
 *
 *      Last delta created      19:19:24 11/1/91
 *      This file extracted     16:49:13 12/23/91
 *
 *      Modifications:
 *
 *
 */

#ifndef _SYS_SNET_ARP_CTRL_INCLUDED
#define _SYS_SNET_ARP_CTRL_INCLUDED


#define MAXHWLEN        6               /* max size of a hardware address */
#define MAXANAMLEN      64              /* max size of adaptername */



/*
 * M_IOCTL types
 */
#define ARP_INS         (('A'<<8) | 1)  /* put arp entry into table     */
#define ARP_DEL         (('A'<<8) | 2)  /* delete entry from table      */
#define ARP_GET         (('A'<<8) | 3)  /* return table entry           */
#define ARP_MGET        (('A'<<8) | 4)  /* return all table entries     */
#define ARP_TYPE        (('A'<<8) | 5)  /* cause a DL_TYPE transfer     */

/*
 * IOCTL structure definitions
 */

#ifdef COMPILE_UP_TCPIP

/*
 * Uniprocessor stack-specific definitions
 */

#define LONGLIFE 1      /* entry is permanent */
#define ARP_PENDING  2 /* ARP request pending */

struct arp_ins {
        long in_addr;
        char dl_add[6];
        short life;     /* lifetime in minutes; LONGLIFE for permanent */
};

struct arp_get {
        long in_addr;
        char dl_add[6];
        int  life;
        int  flag;
};

#else /* COMPILE_UP_TCPIP */

/*
 * Multiprocessor stack-specific definitions
 */

struct arp_ins {
        long in_addr;
        char hw_len;
        char dl_add[MAXHWLEN];
        time_t expiry;             /* relative expiration time in seconds */
};


struct arp_get {
        long in_addr;
        char hw_len;
        short hardware_type;
        char dl_add[MAXHWLEN];
        time_t expiry;            /* relative expiration time in seconds */
};

#endif /* COMPILE_UP_TCPIP */


struct arp_del {
        long in_addr;
};


struct arp_mget {
        long network;
        int num;
};


/*
 * IOCTL structure
 */
struct arp_req {
        int prim_type;
        union req {
                struct arp_ins arp_ins;
                struct arp_del arp_del;
                struct arp_get arp_get;
                struct arp_mget arp_mget;
        } req;
};

typedef struct arp_type {
    short   trailers;               /* are trailers used? */
    char    aname[MAXANAMLEN];      /* name of adapter, used by snmp */
} ARP_TYPES;

#define MAX_EXPIRY      0xFFFFFFFF      /* expiry time for permanent entries */
#define TIME_TIL_REUSE 15 /* time (secs) until entry reused */

#endif // _SYS_SNET_ARP_CTRL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\dl_ctrl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dl_proto.h

Abstract:

    This module defines some of the data types and manifests for the
    Spider Generic Ethernet Interface.

Author:

    Eric Chin (ericc)           August 9, 1991

Revision History:

    Sam Patton (sampa)          July 31, 1992  merge for snap/token ring

--*/
/*
 *  Spider STREAMS Data Link Interface Primitives
 *
 *  Copyright (c) 1989  Spider Systems Limited
 *
 *  This Source Code is furnished under Licence, and may not be
 *  copied or distributed without express written agreement.
 *
 *  All rights reserved.
 *
 *  Written by Mark Valentine
 *
 *  Made in Scotland.
 *
 *	@(#)dl_control.h	1.6
 *
 *	Last delta created	14:58:43 2/12/92
 *	This file extracted	09:26:06 3/18/92
 *
 *	Modifications:
 *
 *		28 Jan 1992	Modified for datalink version 2
 *
 */

#ifndef DL_CTRL_INCLUDED
#define DL_CTRL_INCLUDED

#include <sys\snet\uint.h>

/*
 *  This defines Version 2 of Spider's STREAMS Data Link protocol.
 *  Its main feature is its ability to cope with hardware addresses
 *  of length not equal to 6.
 */

/*
 *  Data Link ioctl commands.
 *
 *  To determine the version of the protocol in use, use the DATAL_VERSION
 *  command, and assume Version 0 if this fails with EINVAL.  (Yuk.)
 *
 *  The ETH_* commands will work for any current version of the protocol,
 *  but only for Ethernet drivers (hw_type == HW_ETHER).
 *
 *  Hardware types are defined in dl_proto.h.
 */

#define DATAL_STAT	('E'<<8|1)	/* gather data link statistics */
#define DATAL_ZERO	('E'<<8|2)	/* reset data link statistics */
#define DATAL_REGISTER	('E'<<8|3)	/* register data link type range */
#define DATAL_GPARM	('E'<<8|4)	/* determine data link parameters */
#define DATAL_VERSION	('E'<<8|5)	/* interrogate protocol version */
#define DATAL_SET_ADDR	('E'<<8|6)	/* set hardware address */
#define DATAL_DFLT_ADDR	('E'<<8|7)	/* restore default hardware address */
#define DATAL_IBIND     ('D'<<8|1)	/* bind card to stream */

/*
 *  Data Link statistics structure.
 */

struct datal_stat
{
	uint32	dl_tx;		/* packets transmitted */
	uint32	dl_rx;		/* packets received */
	uint32	dl_coll;	/* collisions detected */
	uint32	dl_lost;	/* packets lost */
	uint32	dl_txerr;	/* transmission errors */
	uint32	dl_rxerr;	/* receive errors */
	uint32	dl_pool_quota;	/* receive pool quota */
        uint32  dl_pool_used;	/* receive pool used */
};

struct datal_register
{
	uint8	version;	/* protocol version */
	uint8	hw_type;	/* hardware type */
	uint8	addr_len;	/* hardware address length */
	uint8	align;		/* don't use */
	uint16	lwb;		/* data link type (lower bound) */
	uint16	upb;		/* data link type (upper bound) */
};

struct datal_gparm
{
	uint8	version;	/* protocol version */
	uint8	hw_type;	/* hardware type */
	uint8	addr_len;	/* hardware address length */
	uint8	align;		/* don't use */
	uint16	frgsz;		/* max. packet size on net */
	uint8	addr[1];	/* hardware address (variable length) */
};

struct datal_version
{
	uint8	version;	/* protocol version number */
	uint8	hw_type;	/* hardware type */
};

struct datal_ibind
{
	ULONG	UseRawArcnet;	/* 0 if this open should use Encapsulated */
                                /*   Ethernet over arcnet                 */
                                /* 1 if it should use raw arcnet frames   */
	STRING	adapter_name;	/* adapter device driver string */
	char	buffer[80];	/* buffer to contain the name */
};

#endif //DL_CTRL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\inet_var.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    inet_var.h

Abstract:

    This module contains definitions for variable finding functions for
    the Internet MIB. Used by STREAMS drivers.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/*
 *   Copyright (c) 1988  Spider Systems Limited
 *
 *    /usr/users/bridge/sccs/appln/snmp/corecode/s.inet_var.h
 *   @(#)inet_var.h     1.4
 *
 *   Last delta created  10:33:41 12/13/90
 *   This file extracted 19:57:15 12/20/90
 */
/*************************************************************************
 *
 *  SpiderSNMP
 *
 *  Copyright 1989  Spider Systems Limited
 *
 *  INET_VAR.H
 *
 *    Definitions for variable finding functions for the Internet
 *    MIB
 *
 *    Peter Reid     @ Spider Systems Limited
 *    Ted Socolofsky @ Spider Systems Limited
 *
 *************************************************************************/

/*
 *      Modifications:
 *
 *       /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.inet_var.h
 *      @(#)inet_var.h  1.24
 *
 *      Last delta created      12:10:30 1/9/91
 *      This file extracted     08:53:47 7/10/91
 *
 *      PR               1 Jun 89       Built simulator
 *      PR/TS           31 Jun 89       Built remote box simulation
 *      GSS              2 Mar 90       Put in Pbrain
 */


#ifndef _SYS_SNET_INET_VAR_
#define _SYS_SNET_INET_VAR_


#ifndef SPIDER_ROUTER
#ifndef SPIDER_BRIDGE
#ifdef SNMP
#define SPIDER_TCP
#define SYSTEM_MIB
#define IF_MIB2
#define AT_MIB
#define IP_MIB
#define ICMP_MIB
#define TCP_MIB
#define UDP_MIB
#endif /* SNMP */
#endif /* ~SPIDER_BRIDGE */
#endif /* SPIDER_ROUTER */

#ifdef SYSTEM_MIB
#ifndef SHMEM


/*
 * Internet variables
 */
#define SYSDESCRLEN     80

#ifndef SYSOBJLEN
#define SYSOBJLEN       32
#endif

extern char             sysDescr[];
#ifdef SID_T
extern SID_T            sysObjectID[];
#endif

#ifdef DOS_COMPILE
#ifdef SPIDER_PROBE
#define sysUpTime       tod_tick
extern u_long   tod_tick;
#endif /* SPIDER_PROBE */
#endif /* DOS_COMPILE */

#ifndef SPIDER_PROBE
extern int              sysObjectIDLen;
#endif

#endif /* ~SHMEM */

#endif /* SYSTEM_MIB */

#ifdef IF_MIB2

struct mib_interface {
        long    version;                /* version number of the MIB         */
        long    ifNumber;               /* number of interfaces              */
};

#define         IFDESCRLEN      64
#define         IFPHYSADDRLEN   64

struct mib_ifEntry {
        long    version;                /* version number of the MIB         */
        long    ifIndex;                /* index of this interface           */
        char    ifDescr[IFDESCRLEN];    /* English description of interface  */
        long    ifType;                 /* network type of device            */
        long    ifMtu;                  /* size of largest packet in bytes   */
        u_long  ifSpeed;                /* bandwidth in bits/sec             */
        u_char  ifPhysAddress[IFPHYSADDRLEN];   /* interface's address       */
        u_char  PhysAddrLen;            /* length of physAddr                */
        long    ifAdminStatus;          /* desired state of interface        */
        long    ifOperStatus;           /* current operational status        */
        u_long  ifLastChange;           /* sysUpTime when curr state entered */
        u_long  ifInOctets;             /* # octets received on interface    */
        u_long  ifInUcastPkts;          /* # unicast packets delivered       */
        u_long  ifInNUcastPkts;         /* # broadcasts or multicasts        */
        u_long  ifInDiscards;           /* # packets discarded with no error */
        u_long  ifInErrors;             /* # packets containing errors       */
        u_long  ifInUnknownProtos;      /* # packets with unknown protocol   */
        u_long  ifOutOctets;            /* # octets transmittedwn protocol   */
        u_long  ifOutUcastPkts;         /* # unicast packets sent protocol   */
        u_long  ifOutNUcastPkts;        /* # broadcast or multicast pkts     */
        u_long  ifOutDiscards;          /* # packets discarded with no error */
        u_long  ifOutErrors;            /* # pkts discarded with an error    */
        u_long  ifOutQLen;              /* # packets in output queue         */
        u_char  ifSpecificLen;          /* length of object ID */
        u_long  ifSpecific[SYSOBJLEN];  /* object ID of product specific stuf*/
};

#ifndef SPIDER_TCP
#define         MAX_INTERFACES          2
#define         MAXDATA                 630
#endif /* SPIDER_TCP */

#endif /* IF_MIB2 */

#ifdef AT_MIB

#ifdef SPIDER_TCP
#define         ATPHYSADDRLEN   64

#endif
struct mib_atEntry {
#ifdef SPIDER_TCP
        long    version;                /* version number of the MIB         */
#endif /* SPIDER_TCP */
        long    atIfIndex;              /* interface on which entry maps     */
#ifdef SPIDER_TCP
        u_char  atPhysAddress[ATPHYSADDRLEN];   /* physical address of destination   */
#else
        u_char  atPhysAddress[IFPHYSADDRLEN];   /* physical address of destination   */
#endif
        u_char  PhysAddressLen;         /* length of atPhysAddress           */
        u_long  atNetAddress;           /* IP address of physical address    */
        long    atType;                 /* Type of Entry */
};
#endif /* AT_MIB */

#ifdef IP_MIB

struct mib_ip {
#ifdef SPIDER_TCP
        long    version;                /* version number of the MIB         */
#endif /* SPIDER_TCP */
        long    ipForwarding;           /* 1 if gateway, 2 if host           */
        long    ipDefaultTTL;           /* default TTL for pkts from here    */
        u_long  ipInReceives;           /* # IP packets rcvd from interfaces */
        u_long  ipInHdrErrors;          /* # pkts discarded - header errors  */
        u_long  ipInAddrErrors;         /* # pkts discarded - bad address    */
        u_long  ipForwDatagrams;        /* # pkts forwarded through entity   */
        u_long  ipInUnknownProtos;      /* # local-addr pkts w/unknown proto */
        u_long  ipInDiscards;           /* # error-free packets discarded    */
        u_long  ipInDelivers;           /* # pkts delivered to upper level   */
        u_long  ipOutRequests;          /* # IP pkts originating locally     */
        u_long  ipOutDiscards;          /* # valid output IP pkts dropped    */
        u_long  ipOutNoRoutes;          /* # IP pkts discarded - no route    */
        long    ipReasmTimeout;         /* fragment reassembly time (secs)   */
        u_long  ipReasmReqds;           /* # fragments needing reassembly    */
        u_long  ipReasmOKs;             /* # fragments reassembled           */
        u_long  ipReasmFails;           /* # failures in IP reassembly       */
        u_long  ipFragOKs;              /* # datagrams fragmented here       */
        u_long  ipFragFails;            /* # pkts unable to be fragmented    */
        u_long  ipFragCreates;          /* # IP fragments created here       */
        u_long  ipRoutingDiscards;      /* # IP Routing Discards             */
};

struct mib_ipAddrEntry {
#ifdef SPIDER_TCP
        long    version;                /* version number of the MIB         */
#endif /* SPIDER_TCP */
        u_long  ipAdEntAddr;            /* IP address of this entry          */
        long    ipAdEntIfIndex;         /* IF for this entry                 */
        u_long  ipAdEntNetMask;         /* subnet mask of this entry         */
        long    ipAdEntBcastAddr;       /* read the MIB for this one         */
        u_long  ipAdEntReasmMaxSize;    /* and this one */
};

struct mib_ipRouteEntry {
#ifdef SPIDER_TCP
        long    version;        /* version number of the MIB                 */
#endif /* SPIDER_TCP */
        u_long  ipRouteDest;    /* destination IP addr for this route        */
        long    ipRouteIfIndex; /* index of local IF for this route          */
        long    ipRouteMetric1; /* Primary routing metric                    */
        long    ipRouteMetric2; /* Alternate routing metric                  */
        long    ipRouteMetric3; /* Alternate routing metric                  */
        long    ipRouteMetric4; /* Alternate routing metric                  */
        u_long  ipRouteNextHop; /* IP addr of next hop                       */
        long    ipRouteType;    /* Type of this route                        */
        long    ipRouteProto;   /* How this route was learned                */
        long    ipRouteAge;     /* No. of seconds since updating this route  */
        u_long  ipRouteMask;    /* */
        long    ipRouteMetric5; /* Alternate routing metric                  */
        u_char  ipRouteInfoLen; /* length of object ID */
        u_long  ipRouteInfo[SYSOBJLEN];  /* object ID of product specific stuf*/
};

#if 0 /* MIB_II */
#define IPNTOMPHYSADDRLEN       16
struct mib_ipNetToMediaEntry {
        long    ipNtoMIfIndex;          /* interface on which entry maps     */
        u_char  ipNtoMPhysAddress[IPNTOMPHYSADDRLEN];   /* physical address of destination   */
        u_char  NtoMPhysAddressLen;     /* length of atPhysAddress           */
        u_long  ipNtoMNetAddress;       /* IP address of physical address    */
        u_long  ipNtoMMediaType;        /* */
};
#endif /* MIB_II */

#ifndef SPIDER_TCP
#define IPFRAGTTL               15
#define ROUTE_ENTRIES           2
#endif /* SPIDER_TCP */

#endif /* IP_MIB */
#ifdef ICMP_MIB


struct mib_icmp {
#ifdef SPIDER_TCP
        long    version;              /* version number of the MIB          */
#endif /* SPIDER_TCP */
        u_long  icmpInMsgs;           /* Total of ICMP msgs received        */
        u_long  icmpInErrors;         /* Total ICMP msgs rcvd with errors   */
        u_long  icmpInDestUnreachs;   /*                                    */
        u_long  icmpInTimeExcds;      /*                                    */
        u_long  icmpInParmProbs;      /*                                    */
        u_long  icmpInSrcQuenchs;     /*                                    */
        u_long  icmpInRedirects;      /*                                    */
        u_long  icmpInEchos;          /*                                    */
        u_long  icmpInEchoReps;       /*                                    */
        u_long  icmpInTimestamps;     /*                                    */
        u_long  icmpInTimestampReps;  /*                                    */
        u_long  icmpInAddrMasks;      /*                                    */
        u_long  icmpInAddrMaskReps;   /*                                    */
        u_long  icmpOutMsgs;          /*                                    */
        u_long  icmpOutErrors;        /*                                    */
        u_long  icmpOutDestUnreachs;  /*                                    */
        u_long  icmpOutTimeExcds;     /*                                    */
        u_long  icmpOutParmProbs;     /*                                    */
        u_long  icmpOutSrcQuenchs;    /*                                    */
        u_long  icmpOutRedirects;     /*                                    */
        u_long  icmpOutEchos;         /*                                    */
        u_long  icmpOutEchoReps;      /*                                    */
        u_long  icmpOutTimestamps;    /*                                    */
        u_long  icmpOutTimestampReps; /*                                    */
        u_long  icmpOutAddrMasks;     /*                                    */
        u_long  icmpOutAddrMaskReps;  /*                                    */
};

#define ICMP_MAXTYPE            18

#endif /* ICMP_MIB */
#ifdef TCP_MIB

struct mib_tcp {
#ifdef SPIDER_TCP
        long    version;        /* version number of the MIB                 */
#endif /* SPIDER_TCP */
        long    tcpRtoAlgorithm;/* retransmission timeout algorithm          */
        long    tcpRtoMin;      /* minimum retransmission timeout (mS)       */
        long    tcpRtoMax;      /* maximum retransmission timeout (mS)       */
        long    tcpMaxConn;     /* maximum tcp connections possible          */
        u_long  tcpActiveOpens; /* number of SYN-SENT -> CLOSED transitions  */
        u_long  tcpPassiveOpens;/* number of SYN-RCVD -> LISTEN transitions  */
        u_long  tcpAttemptFails;/* (SYNSENT,SYNRCV)->CLOSED, SYN-RCV->LISTEN */
        u_long  tcpEstabResets; /* (ESTABLISHED,CLOSE-WAIT) -> CLOSED        */
        u_long  tcpCurrEstab;   /* number in ESTABLISHED or CLOSE-WAIT state */
        u_long  tcpInSegs;      /* number of segments received               */
        u_long  tcpOutSegs;     /* number of segments sent                   */
        u_long  tcpRetransSegs; /* number of retransmitted segments          */
        u_long  tcpInErrs;      /* # rcved in err */
        u_long  tcpOutRsts;     /* # segs sent with RST flag */
};

struct mib_tcpConnEntry {
#ifdef SPIDER_TCP
        long    version;                /* version number of the MIB         */
#endif /* SPIDER_TCP */
        long    tcpConnState;           /* State of this conn                */
        u_long  tcpConnLocalAddress;    /* local IP address for this conn    */
        long    tcpConnLocalPort;       /* local port for this conn          */
        u_long  tcpConnRemAddress;      /* remote IP address for this conn   */
        long    tcpConnRemPort;         /* remote port for this conn         */
};

#endif /* TCP_MIB */
#ifdef UDP_MIB

struct mib_udp {
#ifdef SPIDER_TCP
        long    version;                /* version number of the MIB         */
#endif /* SPIDER_TCP */
        u_long  udpInDatagrams;         /* # UDP pkts delivered to users     */
        u_long  udpNoPorts;             /* # UDP pkts to unbound port        */
        u_long  udpInErrors;            /* # UDP pkts unable to be delivered */
        u_long  udpOutDatagrams;        /* # UDP pkts sent from this entity  */
};

struct mib_udpEntry {
#ifdef SPIDER_TCP
        long    version;                /* version number of the MIB         */
#endif /* SPIDER_TCP */
        u_long udpLocalAddress;         /* local IP adress */
        u_long udpLocalPort;            /* local port */
};
#endif /* UDP_MIB */
#ifdef EGP_MIB

struct mib_egp {
#ifdef SPIDER_TCP
        long    version;                /* version number of the MIB         */
#endif /* SPIDER_TCP */
        u_long  egpInMsgs;      /* No. of EGP msgs received without error    */
        u_long  egpInErrors;    /* No. of EGP msgs received with error       */
        u_long  egpOutMsgs;     /* No. of EGP msgs sent                      */
        u_long  egpOutErrors;   /* No. of EGP TX msgs dropped due to error   */
};

struct mib_egpNeighEntry {
#ifdef SPIDER_TCP
        long    version;                /* version number of the MIB         */
#endif /* SPIDER_TCP */
        long    egpNeighState;  /* local EGP state with entry's neighbor     */
        u_long  egpNeighAddr;   /* IP address of this entry's neighbor       */
};

#endif /* EGP_MIB */

#ifdef SYSTEM_MIB
#define SYS_SERVICE_PHYS        1
#define SYS_SERVICE_DATALINK    2
#define SYS_SERVICE_INTERNET    3
#define SYS_SERVICE_ENDTOEND    4
#define SYS_SERVICE_APPLIC      7
#endif

#ifdef IF_MIB2
#define MIB_IFTYPE_OTHER                    1
#define MIB_IFTYPE_REGULAR1822              2
#define MIB_IFTYPE_HDH1822                  3
#define MIB_IFTYPE_DDNX25                   4
#define MIB_IFTYPE_RFC877X25                5
#define MIB_IFTYPE_ETHERNETCSMACD           6
#define MIB_IFTYPE_ISO88023CSMACD           7
#define MIB_IFTYPE_ISO88024TOKENBUS         8
#define MIB_IFTYPE_ISO88025TOKENRING        9
#define MIB_IFTYPE_ISO88026MAN              10
#define MIB_IFTYPE_STARLAN                  11
#define MIB_IFTYPE_PROTEON10MBIT            12
#define MIB_IFTYPE_PROTEON80MBIT            13
#define MIB_IFTYPE_HYPERCHANNEL             14
#define MIB_IFTYPE_FDDI                     15
#define MIB_IFTYPE_LAPB                     16
#define MIB_IFTYPE_SDLC                     17
#define MIB_IFTYPE_T1CARRIER                18
#define MIB_IFTYPE_CEPT                     19
#define MIB_IFTYPE_BASICISDN                20
#define MIB_IFTYPE_PRIMARYISDN              21
#define MIB_IFTYPE_PROPPNTTOPNTSERIAL       22
#define MIB_IFTYPE_PPP                      23
#define MIB_IFTYPE_SOFTWARELOOPBACK         24
#define MIB_IFTYPE_EON                      25
#define MIB_IFTYPE_ETHERNET3MBIT            26
#define MIB_IFTYPE_NSIP                     27
#define MIB_IFTYPE_SLIP                     28
#define MIB_IFTYPE_ULTRA                    29
#define MIB_IFTYPE_DS3                      30
#define MIB_IFTYPE_SIP                      31
#define MIB_IFTYPE_FRAMERELAY               32


#define MIB_IFMTU_ETH           1514

#define MIB_IFSPEED_ETH         10000000L

#define MIB_PHYADDRLEN_ETH      6

#define MIB_IFSTATUS_UP         1
#define MIB_IFSTATUS_DOWN       2
#define MIB_IFSTATUS_TESTING    3

#endif /* IF_MIB2 */

#define AT_OTHER                1
#define AT_INVALID              2
#define AT_DYNAMIC              3
#define AT_STATIC               4

#ifdef IP_MIB
#define MIB_FORWARD_GATEWAY     1
#define MIB_FORWARD_HOST        2

#define MIB_IPROUTETYPE_OTHER   1
#define MIB_IPROUTETYPE_INVALID 2
#define MIB_IPROUTETYPE_DIRECT  3
#define MIB_IPROUTETYPE_REMOTE  4

#define MIB_IPROUTEPROTO_OTHER      1
#define MIB_IPROUTEPROTO_LOCAL      2
#define MIB_IPROUTEPROTO_NETMGMT    3
#define MIB_IPROUTEPROTO_ICMP       4
#define MIB_IPROUTEPROTO_EGP        5
#define MIB_IPROUTEPROTO_GGP        6
#define MIB_IPROUTEPROTO_HELLO      7
#define MIB_IPROUTEPROTO_RIP        8
#define MIB_IPROUTEPROTO_ISIS       9
#define MIB_IPROUTEPROTO_ESIS       10
#define MIB_IPROUTEPROTO_CISCOIGRP  11
#define MIB_IPROUTEPROTO_BBNSPFIGP  12
#define MIB_IPROUTEPROTO_OIGP       13

#endif /* IP_MIB */
#ifdef TCP_MIB

#define MIB_TCPRTOALG_OTHER     1
#define MIB_TCPRTOALG_CONSTANT  2
#define MIB_TCPRTOALG_RSRE      3
#define MIB_TCPRTOALG_VANJ      4

#define MIB_TCPCONNSTATE_CLOSED         1
#define MIB_TCPCONNSTATE_LISTEN         2
#define MIB_TCPCONNSTATE_SYNSENT        3
#define MIB_TCPCONNSTATE_SYNRECEIVED    4
#define MIB_TCPCONNSTATE_ESTABLISHED    5
#define MIB_TCPCONNSTATE_FINWAIT1       6
#define MIB_TCPCONNSTATE_FINWAIT2       7
#define MIB_TCPCONNSTATE_CLOSEWAIT      8
#define MIB_TCPCONNSTATE_LASTACK        9
#define MIB_TCPCONNSTATE_CLOSING        10
#define MIB_TCPCONNSTATE_TIMEWAIT       11

#endif /* TCP_MIB */
#ifdef EGP_MIB

#define MIB_EGPNEIGHSTATE_IDLE          1
#define MIB_EGPNEIGHSTATE_AQUISITION    2
#define MIB_EGPNEIGHSTATE_DOWN          3
#define MIB_EGPNEIGHSTATE_UP            4
#define MIB_EGPNEIGHSTATE_CEASE         5

#endif /* EGP_MIB */

#endif /* _SYS_SNET_INET_VAR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\ipdl_pro.h ===
#ident "@(#)ipdl_proto.h	1.7	3/18/92"

/******************************************************************
 *
 *  SpiderTCP Interface Primitives
 *
 *  Copyright (c) 1988  Spider Systems Limited
 *
 *  This Source Code is furnished under Licence, and may not be
 *  copied or distributed without express written agreement.
 *
 *  All rights reserved.
 *
 *  Written by 		Nick Felisiak, Ian Heavens, Peter Reid,
 *			Gavin Shearer, Mark Valentine
 *
 *  DL_PROTO.H
 *
 *  Datalink Streams proto primitives for TCP/IP on V.3 Streams
 *
 ******************************************************************/

/*
 *	 /redknee10/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.ipdl_proto.h
 *	@(#)ipdl_proto.h	1.7
 *
 *	Last delta created	17:44:27 10/22/91
 *	This file extracted	09:25:54 3/18/92
 *
 *	Modifications:
 *
 */

#define NET_TX		3	/* send ip pkt to sub-net */
#define BROAD_TX	15	/* send ip broadcast pkt to sub-net */
#define SN_FRGSZ	10	/* ip request sub net frag size */
#define IP_NETREG	11	/* ip send sub net addr to sub-net */
#define IP_RX		7	/* ip receives from sub net */
#define ARP_SNADDR	IP_NETREG	/* old, ARP specific defintion */	
#define SNMP_TRAP	1	/* trap info from lower driver */

/*
 * - IP sends data pkt to datalink module for transmission
 */
typedef struct net_tx {
	int prim_type;
	long src_inaddr;
	long dst_inaddr;
	short hdr_cnt;
#ifdef EMD
	char	padding[2];	/* make sizeof(net_tx) >= sizeof(eth_tx) */
#endif
} S_NET_TX;

/*
 * ip receives only primitive type, data unknown to lower layer
 */
typedef struct ip_rx {
	int prim_type;
} S_IP_RX;

union dl_proto {
	int type;
	S_NET_TX net_tx;
};

/*
 * datalink layer registration
 */
typedef struct ip_dl_reg {
	int prim_type;
	long inaddr;
	long subnet_mask;
	short int_flags;	/* flags to be filled in by lower module */
} IP_DL_REG;

/*
 * the old, ARP specific interface definition
 */
#define arp_snaddr	ip_dl_reg
#define S_ARP_SNADDR	IP_DL_REG

/*
 * datalink layer information (received after a IP_DLL_REG sent down)
 */
typedef struct sn_frgsz {
	int prim_type;
	int frgsz;
	int opt_size;
	short int_flags;
        unsigned long link_speed;
        unsigned long receive_buffer_size;
} S_SN_FRGSZ;

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\eth_prot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    eth_prot.h

Abstract:

    Definitions for the SNDIS upper protocol interface.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP Interface Primitives
 *
 *  Copyright (c) 1988  Spider Systems Limited
 *
 *  This Source Code is furnished under Licence, and may not be
 *  copied or distributed without express written agreement.
 *
 *  All rights reserved.
 *
 *  Written by 		Nick Felisiak, Ian Heavens, Peter Reid,
 *			Gavin Shearer, Mark Valentine
 *
 *  ETH_PROTO.H
 *
 *  Ethernet Streams proto primitives for TCP/IP on V.3 Streams
 *
 ******************************************************************/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.eth_proto.h
 *	@(#)eth_proto.h	1.9
 *
 *	Last delta created	11:03:25 10/29/90
 *	This file extracted	08:53:41 7/10/91
 */

#ifdef GENERICE

/*
 *  Primitive type values.
 */

#define DL_TYPE		ETH_TYPE	/* ethernet registration (old style) */
#define ETH_TYPE	'R'		/* ethernet registration */
#define ETH_PARAMS	'P'		/* ethernet parameters */
/*efine ETH_PACKET	'p'		/* ethernet packet */
#define ETH_TX		't'		/* packet for transmission */
#define ETH_RX		'r'		/* incoming packet */

/*
 *  Ethernet Type registration.
 */

#define dl_type eth_type
#define dl_lwb lwb
#define dl_upb upb
#define dl_ethaddr ethaddr
#define dl_frgsz frgsz
#define S_DL_TYPE S_ETH_TYPE

typedef struct eth_type {
	uint8	prim_type;	/* i.e. ETH_TYPE */
	uint8	aux_type;	/* unused in Ethernet Driver */
	uint16	pad;		/* compatibility with previous interface */
	uint16	lwb;		/* lower bound of type range */
	uint16	upb;		/* upper bound of type range */
	uint8	ethaddr[6];	/* ethernet address */
	uint16	frgsz;		/* max. packet size on net */
} S_ETH_TYPE;

typedef struct eth_params {
	uint8	prim_type;	/* i.e. ETH_PARAMS */
	uint8	aux_type;	/* unused in Ethernet Driver */
	uint16	pad;		/* compatibility with previous interface */
	uint8	ethaddr[6];	/* ethernet address */
	uint16	frgsz;		/* max. packet size on net */
} S_ETH_PARAMS;

/*
 *  Packet header data.
 */

typedef struct eth_packet {
	uint8	prim_type;	/* i.e. ETH_PACKET */
	uint8	aux_type;	/* unused in Ethernet Driver */
	uint16	pad;		/* compatibility with previous interface */
	uint16	eth_type;	/* ethernet type field */
	uint8	eth_src[6];	/* source ethernet address */
	uint8	eth_dst[6];	/* destination ethernet address */
} S_ETH_PACKET;

typedef struct eth_rx {
	uint8	prim_type;	/* i.e. ETH_RX */
	uint8	aux_type;	/* unused in Ethernet Driver */
	uint16	pad;		/* compatibility with previous interface */
	uint16	eth_type;	/* ethernet type field */
	uint8	eth_src[6];	/* source ethernet address */
} S_ETH_RX;

typedef struct eth_tx {
	uint8	prim_type;	/* i.e. ETH_TX */
	uint8	aux_type;	/* unused in Ethernet Driver */
	uint16	pad;		/* compatibility with previous interface */
	uint16	eth_type;	/* ethernet type field */
	uint8	eth_dst[6];	/* destination ethernet address */
} S_ETH_TX;

/*
 *  Generic ethernet protocol primitive
 */

typedef union eth_proto
{
	uint8 type;			/* variant tag */
	struct eth_type etype;		/* if type == ETH_TYPE */
	struct eth_params eparm;	/* if type == ETH_PARAMS */
	struct eth_rx erx;		/* if type == ETH_RX */
	struct eth_tx etx;		/* if type == ETH_TX */
} S_ETH_PROTO;

#else /* GENERICE */

/* type range we want to receive from ethernet */
typedef struct dl_type {
	int prim_type;
	unsigned short dl_lwb;
	unsigned short dl_upb;
} S_DL_TYPE;

/* M_PROTO Message primitives */

#define DL_RX		4	/* arp receives from eth */
#define DL_TYPE		5	/* arp send type field to eth */
#ifdef PROJ4
#define ETH_TX		1	/* packet for transmission */
#define ETH_RX		2	/* incoming packet */
#else
#define ETH_TX		6	/* packet for transmission */
#define ETH_RX		7	/* incoming packet */
#endif

/*
 * M_PROTO message formats
 */
#ifdef EMD
struct eth_tx {
	char	dl_dst[6];
	char	dl_src[6];
	short	dl_type;
};
#else
struct eth_tx {
	int prim_type;
	short dl_type;
	char dl_dst[6];
};
#endif

struct eth_rx {
	int prim_type;
	struct ethmessage *eth_msg;
};


union eth_proto {
	int type;
	struct eth_tx eth_tx;
	struct eth_rx eth_rx;
	struct dl_type dl_type;
};

/*
 * errors generated
 */
#define EFRGSZ	1
#define EDLTYPE 2
#define EPRIM	3
#define EBUF	4
#define EMSG	5

/*
 * arp receives datalink pkt from eth
 */
typedef struct dl_rx {
	int prim_type;
	unsigned short dl_type;
	char dl_src[6];
} S_DL_RX;

#endif /* GENERICE */


#ifdef PROJ4

/*
 * PROJ4 Attachment values
 */
#define A_LAN 9
#define A_IP  20
#define A_UDP 23
#define A_ARP 24

#define ATTACH          13      /* attach to driver */

/*
 * ATTACH struct - for communication with the lower
 * Driver
 */
typedef struct attach {
       int prim_type;
       unsigned short fromid;
       unsigned short toid;
       unsigned int fromvers;
       unsigned int tovers;
       int result;
       unsigned short type_upb0;
       unsigned short type_lwb0;
       unsigned short type_upb1;
       unsigned short type_lwb1;
       unsigned short type_upb2;
       unsigned short type_lwb2;
       unsigned short type_upb3;
       unsigned short type_lwb3;
} S_ATTACH;

#define DATAL_TX	ETH_TX
#define	S_DATAL_TX	struct eth_tx
#define	datal_tx	eth_tx

/*
 * Hardware types
 */

#define	HW_ETHERNET	1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\ll_ctrl.h ===
/*
 *	 /redknee10/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/35/s.ll_control.h
 *	@(#)ll_control.h	1.2
 *
 *	Last delta created	15:48:28 11/18/91
 *	This file extracted	09:26:04 3/18/92
 *
 *	Modifications:
 *	
 *		IS	Oct 1991	Ported for LLC1
 */


/* IOCTL commands */
#define L_SETSNID   ('L'<<8 | 1)    /* Set subnet identifier (use ll_snioc) */
#define L_GETSNID   ('L'<<8 | 2)    /* Get subnet identifier (use ll_snioc) */
#define L_SETTUNE   ('L'<<8 | 3)    /* Set tuning parameters (use ll_tnioc) */
#define L_GETTUNE   ('L'<<8 | 4)    /* Get tuning parameters (use ll_tnioc) */
#define L_GETSTATS  ('L'<<8 | 5)    /* Get statistics counts (use ll_stioc) */
#define L_ZEROSTATS ('L'<<8 | 6)    /* Zero statistics       (use ll_hdioc) */

/* Values for 'lli_type' (with names of corresponding structures) */
#define LI_PLAIN	0x01        /* Indicates 'struct ll_hdioc'  */
#define LI_SNID		0x02        /* Indicates 'struct ll_snioc'  */
#define LI_STATS	0x04        /* Indicates 'struct ll_stioc'  */


#define LI_LLC2TUNE	0x23        /* Indicates 'struct llc2_tnioc'*/


/* LLC1 tuning structure */
typedef struct llc2tune {
    uint16  Tbusy;          /* Remote busy check time   (unit 0.1 sec)  */
    uint16  Tidle;          /* Idle P/F cycle time	(unit 0.1 sec)  */
    uint16  tx_window;      /* Transmit window (if no XID received)	*/
    uint16  tx_probe;       /* P-bit position before end of Tx window   */
    uint16  xid_window;     /* XID window size (receive window)		*/
    uint16  xid_Ndup;       /* Duplicate MAC XID count  (0 => no test)  */
    uint16  xid_Tdup;       /* Duplicate MAC XID time   (unit 0.1 sec)  */
} llc2tune_t;

/* LLC2/LAPB stats structure */
typedef struct ll_stats {
    uint32  lls_txU;        /* Number of 'U' frames sent		*/
    uint32  lls_rxU;        /* Number of good 'U' frames received	*/
    uint32  lls_rxign;      /* Number of frames ignored			*/
    uint32  lls_rxbad;      /* Number of erroneous frames received	*/
    uint32  lls_rxdud;      /* Number of received and discarded frames  */
} llstats_t;

/* Header alone (for decoding and L_ZEROSTATS commands) */
struct ll_hdioc {
    uint8           lli_type;   /* Table type = LI_PLAIN		*/
    uint8           lli_snid;   /* Subnet ID character			*/
    uint16          lli_spare;  /*   (for alignment)			*/
};

/* Ioctl block for L_SETSNID and L_GETSNID commands */
struct ll_snioc {
    uint8           lli_type;   /* Table type = LI_SNID			*/
    uint8           lli_snid;   /* Subnet ID character			*/
    uint16          lli_spare;  /*   (for alignment)			*/

    uint32          lli_index;  /* Link index				*/
};


/* Ioctl block for LLC1 L_SETTUNE and L_GETTUNE commands */
struct llc2_tnioc {
    uint8           lli_type;   /* Table type = LI_LLC2TUNE		*/
    uint8           lli_snid;   /* Subnet ID character ('*' => 'all')   */
    uint16          lli_spare;  /*   (for alignment)			*/

    llc2tune_t      llc2_tune;  /* Table of tuning values               */
};

/* Ioctl block for L_GETSTATS command */
struct ll_stioc {
    uint8           lli_type;   /* Table type = LI_STATS		*/
    uint8           lli_snid;   /* Subnet ID character			*/
    uint16          lli_spare;  /*   (for alignment)			*/
    llstats_t       lli_stats;  /* Table of stats values		*/
};

/* Union of ioctl blocks */
typedef union lli_union {
    struct ll_hdioc	ll_hd;      /* Parameter-less command       */
    struct ll_snioc	ll_sn;      /* Set/get subnet identifier    */
    struct llc2_tnioc   llc2_tn;    /* Set/get LLC1 tuning          */
    struct ll_stioc	ll_st;      /* Get statistics		    */
} lliun_t;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\nbdebug.h ===
/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainD/dev/src/include/sys/snet/0/s.nbdebug.h
 *	@(#)nbdebug.h	1.3
 *
 *	Last delta created	12:37:27 3/11/91
 *	This file extracted	15:16:57 4/1/91
 *
 *	Modifications:
 *	
 *		6 Feb 1991 (RAE)	Ported to SpiderTCP
 */

#ifndef _NBDEBUG_INCLUDED
#define _NBDEBUG_INCLUDED

extern int nbtraceflag;

#define I_NBDEBUG 0x8000

/* debug_cmd */

#define DTRACE          1

/* flags for debug_cmd DTRACE */

#define D_STRM 0x0001
#define D_DEP  0x0002
#define D_SEP  0x0004
#define D_SIB  0x0008
#define D_NSRV 0x0010
#define D_SSRV 0x0020
#define D_DSRV 0x0040
#define D_CTRL 0x0080
#define D_LMH  0x0100

struct nb_debug {
   int debug_cmd;
   int debugflag;
};

#endif // _NBDEBUG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\ip_ctrl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ip_ctrl.h

Abstract:

    This file contains the user-level STREAMS ioctl interface definitions
    for the IP driver.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/******************************************************************
 *
 *  SpiderTCP Interface Primitives
 *
 *  Copyright (c) 1988  Spider Systems Limited
 *
 *  This Source Code is furnished under Licence, and may not be
 *  copied or distributed without express written agreement.
 *
 *  All rights reserved.
 *
 *  Written by          Nick Felisiak, Ian Heavens, Peter Reid,
 *                      Gavin Shearer, Mark Valentine
 *
 *  IP_CONTROL.H
 *
 *  IP Streams ioctl primitives for TCP/IP on V.3/V.4 Streams
 *
 ******************************************************************/

#ifndef _SYS_SNET_IP_CTRL_
#define _SYS_SNET_IP_CTRL_

#ifndef SYSOBJLEN
#define SYSOBJLEN       32
#endif


#define IP_NET_ADDR     (('I'<<8)+1)    /* IP registration from netd */
#define ICMP_CTRL       (('I'<<8)+2)    /* control ICMP redirects */
#define SET_IP_CTRL     (('I'<<8)+3)    /* set IP control information */
#define GET_IP_CTRL     (('I'<<8)+4)    /* get IP control information */
#ifdef MULTIH
#define ADD_IPNET       IP_NET_ADDR     /* add IP network to this interface */
#define SHOW_IPNET      (('I'<<8)+5)    /* dump IP network information */
#define DEL_IPNET       (('I'<<8)+6)    /* delete IP network from interface */
#define ADD_IPADDR      (('I'<<8)+7)    /* add IP address to this interface */
#define SHOW_IPADDR     (('I'<<8)+8)    /* dump IP address information */
#define DEL_IPADDR      (('I'<<8)+9)    /* delete IP address from interface */
#endif

#define GET_ALL_INTERFACES      1
#define GET_INTERFACE_INFO      2
#ifdef HOSTREQ_MAYBE
#define SET_INTERFACE_INFO      3
#endif
#define GATE_ACCESS             4



/*
 * ** netd registration **
 */

typedef struct net_addr {
    int muxid;
    long inaddr;
    long subnet_mask;
    char forward_bdcst;
    char keepalive;
    short mtu;
    short router_mtu;
    char if_broadcast;
} NET_ADDRS;



/*
 * ** routing cache access **
 */

/*
 * Gateway access structures etc.
 */
struct gate_access {
    char flush;
    char smart;
    short command;
    long dest;
    long gate;
};


/*
 * routing cache access command values (subcodes of GATE_ACCESS)
 */

#define GATE_PRINT 1
#define GATE_ADD 2
#define GATE_DEL 3
#define GATE_CHANGE 4

#define WILD_CARD -1L   /* to indicate that all networks should be acted on */

/*
 * routing cache definitions
 */

#ifdef COMPILE_UP_TCPIP

#define GWAY_TIMEOUT 30

typedef struct gw_hashentry {
    long from;                  /* network */
    long to;                    /* default gateway, if it exists */
    long redirect;              /* ICMP Redirect gateway, if it exists */
    long active_gw;             /* 1 = gateway is active, 0 = not active */
    short count;                /* Counter for timer */
    /*
     * "from" is equivalent to "ipRouteDest",
     * and "to" or "redirect" is equivalent to "ipRouteNextHop"
     */
    long saveProto;             /* saved protocol when doing a redirect */
    long ipRouteIfIndex;        /* index of local IF for this route */
    long ipRouteMetric1;        /* Primary routing metric */
    long ipRouteMetric2;        /* Alternate routing metric */
    long ipRouteMetric3;        /* Alternate routing metric */
    long ipRouteMetric4;        /* Alternate routing metric */
    long ipRouteMetric5;        /* Alternate routing metric */
    long ipRouteType;           /* Type of this route */
    long ipRouteProto;          /* How this route was learned */
    long ipRouteAge;            /* time this route was updated */
    long ipRouteMask;           /* Subnet Mask for Route */
    unsigned char  ipRouteInfoLen; /* length of object ID */
    unsigned long  ipRouteInfo[SYSOBJLEN];  /* object ID of product specific stuf*/
} GW_HASHENTRY;

#else  /* COMPILE_UP_TCPIP */

#define GWAY_LIFE       300     /* 5 minute timeout in seconds */

typedef struct gw_hashentry {
    long from;                  /* network */
    long to;                    /* default gateway, if it exists */
    long redirect;              /* ICMP Redirect gateway, if it exists */
    long active_gw;             /* 1 = gateway is active, 0 = not active */
    /*
     * "from" is equivalent to "ipRouteDest",
     * and "to" or "redirect" is equivalent to "ipRouteNextHop"
     */
    long saveProto;             /* saved protocol when doing a redirect */
    long ipRouteIfIndex;        /* index of local IF for this route */
    long ipRouteMetric1;        /* Primary routing metric */
    long ipRouteMetric2;        /* Alternate routing metric */
    long ipRouteMetric3;        /* Alternate routing metric */
    long ipRouteMetric4;        /* Alternate routing metric */
    long ipRouteMetric5;        /* Alternate routing metric */
    long ipRouteType;           /* Type of this route */
    long ipRouteProto;          /* How this route was learned */
    long ipRouteAge;            /* time this route was updated */
    long ipRouteMask;           /* Subnet Mask for Route */
    unsigned char  ipRouteInfoLen; /* length of object ID */
    unsigned long  ipRouteInfo[SYSOBJLEN];  /* object ID of product specific stuf*/
} GW_HASHENTRY;

#endif  /* COMPILE_UP_TCPIP */



/*
 * Subnet mux table entry data. This structure is a subset of the
 * kernel-level structure. They must match. This is a maintenance
 * headache, but to remedy it, the IP code would have to be modified
 * to make this structure a subfield of the real table structure.
 */

#ifdef COMPILE_UP_TCPIP

typedef struct net_interface_data {
    long inaddr;                /* network internet address */
    long net_num;               /* network number */
    long subnet_num;            /* subnet number */
    long subnet_mask;           /* subnet mask */
    long sn_bdcst1;             /* subnet broadcast :all zeroes  */
    long sn_bdcst2;             /* subnet broadcast :all 1's  */
    long net_bdcst1;            /* network broadcast :all zeroes  */
    long net_bdcst2;            /* network broadcast :all 1's  */
    int frag_size;              /* max allowable fragment size for subnet */
    int opt_size;               /* optimum size (may be same as frag_size) */
    short int_flags;            /* interface flags (see below) */
    short blocked;              /* true if interface is blocked */
#ifdef HOSTREQ_MAYBE
    union {
        long bdcast_addr;
        long dst_addr;
    } addr;                     /* broadcast address, or dest address for SLIP */
#   define if_broadcast addr.bdcast_addr
#   define if_destination       addr.dst_addr
#endif
    int lower_snmp;             /* true if lower interface supports SNMP */
    long status;                /* status: up, down, or testing */
    time_t change;              /* time state was entered */
    long  if_broadcast;         /* preferred network broadcast */
    long  if_snbroadcast;       /* preferred subnet broadcast */
} NET_INTERFACE_DATA;

#else  /* COMPILE_UP_TCPIP */

typedef struct net_interface_data {
    long inaddr;                /* network internet address */
    long net_num;               /* network number */
    long subnet_num;            /* subnet number */
    long subnet_mask;           /* subnet mask */
    long sn_bdcst1;             /* subnet broadcast :all zeroes  */
    long sn_bdcst2;             /* subnet broadcast :all 1's */
    long net_bdcst1;            /* network broadcast :all zeroes */
    long net_bdcst2;            /* network broadcast :all 1's */
    int frag_size;              /* max allowable fragment size for subnet */
    int opt_size;               /* optimum size (may be same as frag_size) */
    short int_flags;            /* interface flags */
    short user_flags;           /* user flags */
    short blocked;              /* true if interface is blocked */

#ifdef HOSTREQ_MAYBE
    union {
        long bdcast_addr;
        long dst_addr;
    } addr;                 /* broadcast address, or dest address for SLIP */
#   define if_broadcast addr.bdcast_addr
#   define if_destination       addr.dst_addr
#endif

    int lower_snmp;             /* true if lower interface supports SNMP */
    long status;                /* status: up, down, or testing */
    time_t change;              /* time state was entered */
    long if_broadcast;          /* preferred network broadcast */
    long if_snbroadcast;        /* preferred subnet broadcast */
} NET_INTERFACE_DATA;

#endif  /* COMPILE_UP_TCPIP */

#endif /* _SYS_SNET_IP_CTRL_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\ll_proto.h ===
/******************************************************************
 *
 *  Copyright 1991  Spider Systems Limited
 *
 *  LL_PROTO.C
 *
 ******************************************************************/
/*
 *	 /redknee10/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/35/s.ll_proto.h
 *	@(#)ll_proto.h	1.2
 *
 *	Last delta created	18:43:07 1/28/92
 *	This file extracted	09:26:05 3/18/92
 *
#ifdef MOD_HISTORY
 *
 *	Modifications:
 *
 *	JS	25 Sep 90	Added LAP classes.
 *	JS	17 Oct 90	Renamed LC_LAPB as LC_LAPBDTE and LC_LAPBX
 *				as LC_LAPBXDTE.
 *	JS	21 Nov 90	Moved ll_mymacaddr field in ll_reg structure
 *				to start on 4 byte boundary.
 *	IS	Oct 1991	Changed for LLC1
#endif
 */


#define MAXHWLEN 6
#define LL_MAXADDRLEN 8 

/* Interface structures */
struct ll_reg {
    uint8	ll_type;
    uint8	ll_class;
    uint8	ll_regstatus;
    uint8	ll_snid;
    uint8	ll_normalSAP;
    uint8	ll_loopbackSAP;
    uint8	ll_mactype;			/* type of hardware interface */
    uint8	ll_addrsize;			/* size of hardware address */
    uint16	ll_frgsz;			/* max fragment size of HW */
    uint8	ll_mymacaddr[LL_MAXADDRLEN];	/* hardware address */
};

struct ll_msg {
    uint8	ll_type;
    uint8	ll_command;
    uint16	ll_connID;
    uint32	ll_yourhandle;
    uint32	ll_status;
};

struct ll_msgc {
    uint8	ll_type;
    uint8	ll_command;
    uint16	ll_connID;
    uint32	ll_yourhandle;
    uint32	ll_myhandle;
    uint16	ll_service_class;
    uint8	ll_remsize;		/* semi-octect size of remote address */
    uint8	ll_locsize;		/* semi-octect size of local address */
    uint8	ll_route_length;	/* size of routing information */
    uint8	ll_locaddr[LL_MAXADDRLEN];	/* local address */
    uint8	ll_remaddr[LL_MAXADDRLEN];	/* remote address */
    uint8	ll_route_info[1];	/* optional routing info field MUST */
					/* follow ll_remaddr field */
};

/* Values for 'll_type' */
#define LL_REG		 50
#define LL_DAT		 52

/* Values for 'll_command' */

#define LC_UDATA          4
#define LC_DISC		  5
#define LC_DISCNF         6
#define LC_RESET          7
#define LC_RSTCNF         8
#define LC_REPORT         9


/* Values of 'll_class' in 'll_reg' */
#define LC_LLC1          15

/* Values in 'll_regstatus' and 'll_status' */
#define LS_SUCCESS        1
#define LS_RESETTING      2
#define LS_RESETDONE      3
#define LS_DISCONNECT     4
#define LS_FAILED         5
#define LS_CONFLICT       6
#define LS_RST_FAILED     7
#define LS_RST_REFUSED    8
#define LS_RST_DECLINED   9
#define LS_REM_BUSY      12
#define LS_REM_NOT_BUSY  13
#define LS_EXHAUSTED     14
#define LS_SSAPINUSE     15
#define LS_LSAPINUSE     16
#define LS_DUPLICATED    17
#define LS_LSAPWRONG     18
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\ip_proto.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ip_proto.h

Abstract:

    This module contains definitions for STREAMS IP

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/******************************************************************
 *
 *  SpiderTCP Interface Primitives
 *
 *  Copyright (c) 1988  Spider Systems Limited
 *
 *  This Source Code is furnished under Licence, and may not be
 *  copied or distributed without express written agreement.
 *
 *  All rights reserved.
 *
 *  Written by          Nick Felisiak, Ian Heavens, Peter Reid,
 *                      Gavin Shearer, Mark Valentine
 *
 *  IP_PROTO.H
 *
 *   IP Streams proto primitives for TCP/IP on V.3/V.4 Streams
 *
 ******************************************************************/

#ifndef _SYS_SNET_IP_PROTO_
#define _SYS_SNET_IP_PROTO_


#ifndef IPOPTS
#define IPOPTS
#endif

#define IP_TX           6       /* tcp/udp send pkt to ip */
#define PROT_RX         8       /* tcp/udp get pkt from ip */
#define IP_PROTQ        9       /* tcp/udp send prot q to ip */
#define ICMP_RX         12      /* upper layer rcv icmp pkt from ip */
#define ICMP_TX         13      /* upper layer send icmp pkt to ip */
#define ENQ_LOCAL       14      /* validate local address enquiry */
#define ENQ_REMOTE      15      /* validate remote address enquiry */
#define IP_FLOW         16      /* flow control interface to upper layers */
#define IP_PROT_REMOVEQ 17      /* tcp/udp deregister prot q to ip */

#ifdef TESTOPT
/*
 * TESTOPT driver field
 */
#define TCPTEST         1
#define UDPTEST         TCPTEST
#define IPTEST          2

/*
 * TESTOPT type field
 */

#define NEXT            1       /* carry out for next num packets */
#define ALL             2       /* carry out for all packets */
#define OFF             3       /* turn off option */
#define RANDOM          4       /* carry out for random packets, prob 1/num */

/*
 * TESTOPT option field
 */

#define BAD_CKSUM       1
#define SHORT_HDR       2
#define DROP            3       /* drop packet or fragment */
#define CONTROL         4       /* OR ctl field with subopt, TCP only */
#define BAD_TYPE        5       /* bad multiplexing type: port for TCP,
                                   protocol for IP */

typedef struct testopt {
    char driver;    /* option for which driver: TCP/UDP, IP */
    char option;    /* option */
    char subopt;    /* suboption if applicable */
    char type;      /* next, on, off */
    int  num;       /* number of packets - depends on */
} TEST_OPT;

#endif

/*
 * define structure for DARPA internet address
 * usually use "longs" to access but sometimes need to split into
 * components
 */

typedef union {
    char  typea[4]; /* 4 x 8 bit version */
    short typeb[2];  /* 2 x 16 bit */
    long  typec;     /* 1 x 32 bit */
} IN_ADDRESS;

/*
 * IP Option values
 */
#define OPT_EOL           0
#define OPT_NOP           1
#define OPT_SECURITY    130
#define OPT_LSRR        131
#define OPT_SSRR        137
#define OPT_RR            7
#define OPT_STRID       136
#define OPT_TIMESTAMP    68

/*
 * structure of pseudo-header used for communication
 * between IP and higher level processes
 */
typedef struct {
    short ps_pktid;            /* id to be used in inet header */
    short ps_status;           /* indicates status of requested action */
#define OK 0                       /* status for non-ICMP packet */
    IN_ADDRESS ps_src;         /* source address */
    IN_ADDRESS ps_dst;         /* destination address */
    unsigned short ps_txtlen;  /* length of text */
    short ps_offset;           /* Fragment Offset */
    short ps_if;               /* IP Interface number */
    unsigned char ps_prot;     /* Internet protocol number */
    char ps_df;                /* Don't Fragment flag */
    char ps_ttl;               /* Time to Live flag */
#ifdef TESTOPT
    int test;                  /* testing on for this packet */
    TEST_OPT testopt;          /* options for testing */
#endif
#ifdef IPOPTS
    char ps_pkt_type;          /* What's this packet doing? */
    char ps_optlen;            /* Length of options (in words) */
    char ps_tos;               /* Type of service */
    int ps_options[1];         /* Options */
#endif
} PSEUDO_HDR;

#define SIZ_PSEUDOHDR sizeof(PSEUDO_HDR)


/*
 * Types of pkt_type
 */

#define PS_FROM_ME      1       /* Started here */
#define PS_FOR_ME       2       /* Dest is this machine */
#define PS_THRU_ME      3       /* Just passing through */
#define PS_SS_ROUTING   4       /* Being strict source routed */
#define PS_LS_ROUTING   5       /* Being loose source routed */
#define PS_REPLY        6       /* response to another pkt (ie echo reply) */

typedef struct ip_protq {
    int prim_type;
    unsigned char prot;
} S_IP_PROTQ;

/*
 * status returned to upper layer in prot
 */
#define VALID   0
#define IN_USE  1
#define INVALID 2

/*
 * received from transport protocol when it sends a packet
 */
typedef struct ip_tx {
    int prim_type;
    short hdr_cnt;
    short unused1;       /* ensure structure is same size as S_PROT_RX */
    BOOLEAN unused2;     /* ensure structure is same size as S_PROT_RX */
    PSEUDO_HDR uph;
} S_IP_TX;

/*
 * sent to transport protocol when we receive a packet
 */
typedef struct prot_rx {
    int prim_type;
    IN_ADDRESS if_addr;
    BOOLEAN is_broadcast;
    PSEUDO_HDR uph;
} S_PROT_RX;


/*
 * The ICMP_RX struct
 */
struct icmp_rx {
    int prim_type;
    IN_ADDRESS if_addr;
    BOOLEAN is_broadcast;
    unsigned char type;
    unsigned char code;
    long src;
    long dst;
    unsigned long misc;
    PSEUDO_HDR uph;
};


/*
 * The ICMP_TX struct
 */
struct icmp_tx {
    int prim_type;
    unsigned char type;
    unsigned char code;
    long src;
    long dst;
    unsigned long misc;
    PSEUDO_HDR ph;
};



/*
 * The IP_ADDRENQ struct
 */

struct ip_addrenq {
    int           prim_type;           /* ENQ_LOCAL or ENQ_REMOTE */
    char         *handle;              /* Place holder for TCP */
    long          addr;                /* Remote address */
    long          local;               /* Returned local address */
    int           error;               /* Zero if OK, else errno */
    int           mss;                 /* Max seg size for this transfer */
    int           flags;               /* See below */
    int           ifno;                /* IP's interface number for this addr */
    int           broadcast;           /* Set if remote address is broadcast */
    unsigned long link_speed;          /* adapter link speed in kbits/second */
    unsigned long receive_buffer_size; /* bytes of adapter receive space */
};


#define ENQ_NO_KEEPALIVE        1       /* No keep-alives for this net */


/*
 * IP Flow control structure
 */

struct ip_flow_info {
    int prim_type;          /* IP_FLOW */
    int index;              /* IP Interface number */
    int info;               /* Blocked or unblocked */
};

/**************************************************************
 * ICMP constants:      types & codes
 **************************************************************/

#define ECHO_REPLY              0               /* echo reply */

#define DEST_UNR                3               /* destination unreachable: */

/* codes for DEST_UNR */
#define         NET_UNR                 0       /* net unreachable */
#define         HOST_UNR                1       /* host unreachable */
#define         PROT_UNR                2       /* protocol unreachable */
#define         PORT_UNR                3       /* port unreachable */
#define         FRAG_DF                 4       /* fragmentation needed + DF */
#define         SR_FAIL                 5       /* source route failed */
#define         DST_NET_UNKNOWN         6       /* dest network unknown */
#define         DST_HOST_UNKNOWN        7       /* dest host unknown */
#define         SRC_HOST_ISOLATED       8       /* source host isolated */
#define         NET_PROHIBITED          9       /* communication with dest
                                                   network administratively
                                                   prohibited */
#define         HOST_PROHIBITED         10      /* communication with dest
                                                   host administratively
                                                   prohibited */
#define         NET_UNR_FOR_TOS         11      /* network unreachable
                                                   for type of service */
#define         HOST_UNR_FOR_TOS        12      /* host unreachable
                                                   for type of service */

#define SRC_QUENCH              4               /* source quench */

#define REDIRECT                5               /* redirect message: */
#define         NET_RE                  0       /* redirect for network */
#define         HOST_RE                 1       /* redirect for host */
#define         TOSN_RE                 2       /* redirect for TOS/network */
#define         TOSH_RE                 3       /* redirect for TOS/host */

#define ICMP_ECHO               8               /* echo request */

#define TIME_EXCEEDED          11               /* time exceeded: */
#define         TTL_X                   0       /* time-to-live exceeded */
#define         FRAG_X                  1       /* frag reassem time excluded */

#define PARAMETER               12              /* parameter problem */
#define         PARAM_POINTER           0       /* pointer indicates error */
#define         PARAM_OPTION            1       /* required option missing */

#define TIME_STAMP              13              /* timestamp request */
#define STAMP_REPLY             14              /* timestamp reply */

#define INFO_REQ                15              /* information request */
#define INFO_REPLY              16              /* information reply */

#define MASK_REQ                17              /* address mask request */
#define MASK_REPLY              18              /* address mask reply */

#endif /* _SYS_SNET_IP_PROTO_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\nbtuser.h ===
/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainD/dev/src/include/sys/snet/0/s.nbtuser.h
 *	@(#)nbtuser.h	1.3
 *
 *	Last delta created	14:57:27 2/22/91
 *	This file extracted	15:16:56 4/1/91
 *
 *	Modifications:
 *	
 *		6 Feb 1991 (RAE)	Ported to SpiderTCP
 */

/*
 * NetBIOS specific error codes
 */
#define PROTO_SESSIONCLOSED 1
#define PROTO_SESSIONABORTED 2
#define ENAMEUNR 3

/* Netbios interface definitions */

/*	nbt open types */
#define O_CLTS		0x4000	/* flag used in open to specify a 
				 * connectionless transport endpoint */

//#define TLI_NBT		"/dev/nbt"

/*	Netbios names */
#define NBNAMSZ		16
#define MAXNBDG		512		/* maximum datagram size */
#define NBUNIQUENM	0x00	/* unique name flag, nb_type */
#define NBGROUPNM	0x01	/* group name flag, nb_type */
#define NBBROADCAST	0x40	/* broadcast flag, nb_type */

struct nbaddr {
	USHORT nb_type;		/* name type: group, unique */
	UCHAR nb_name[NBNAMSZ];
//	char nb_res;		/* reserved, unused */
};

/* Length's are passed as ioctl's: */
#define NBSTR	('N'<<8)
#define NBIOCTL_TSDUSZ	(NBSTR|0x1)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\nbt_ctrl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nbt_ctrl.h

Abstract:

    This file contains structure definitions for the user-level interface to
    the NBT driver.

Author:

    Mike Massa (mikemas)           Jan 30, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-30-92     created

Notes:

--*/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.nbt_control.h
 *	@(#)nbt_control.h	1.9
 *
 *	Last delta created	15:54:26 10/25/91
 *	This file extracted	16:49:25 12/23/91
 *
 *	Modifications:
 *	
 *		6 Feb 1991 (RAE)	Ported to SpiderTCP
 */

#ifndef _NBT_CTRL_INCLUDED_
#define _NBT_CTRL_INCLUDED_


typedef unsigned short word;
typedef unsigned char byte;
typedef unsigned int dword;

//
// #defines for debugging reference count problems
//

#if DBG

#define REFCOUNT_TRACE 1

#endif

#define REFCOUNT_TRACE_UNUSENAME 0
#define REFCOUNT_TRACE_USENAME   1
#define REFCOUNT_TRACE_FINDNAME  2
#define REFCOUNT_TRACE_PUTNEXT   3
#define REFCOUNT_TRACE_LINKREQ   4
#define REFCOUNT_TRACE_ACTIVE    5

#define NUM_REFCOUNT_TRACE 6

/*
 * XEB (Standard Object Block)
 */

#ifdef COMPILE_UP_TCPIP

typedef struct xeb {
        struct msgb  *msg;      /* the allocated stream msg */
        char blockname[4];      /* Debug name information */
	struct xeb *dnlink;	/* Debug link to next block) */
	struct xeb *dplink;	/* Debug link to previous block */
	struct xeb *nlink;	/* link to next block) */
	struct xeb *plink;	/* link to previous block */
        struct queue *uqptrRD;
        struct queue *uqptrWR;
        struct queue *lqptrRD;
        struct queue *lqptrWR;
        int state;
        int (*init_object)();   /* init_object procedure */
        void (*in_object)();    /* in_object procedure */
        int (*out_object)();    /* out_object procedure */
        int (*close_object)();  /* close_object procedure */
        int (*test_resource)(); /* procedure, test buf resources */
        int bufcall_flag;       /* object wait on buf resources */
        struct xeb *nmptr;      /* pointer to bound name */
	struct msgb *work_q;	/* queue of work to do */
} XEB;

#else  /* COMPILE_UP_TCPIP */

typedef struct xeb {
        struct msgb **msg;      /* the allocated stream msg */
        char blockname[4];      /* Debug name information */
	struct xeb *nlink;	/* link to next block) */
	struct xeb *plink;	/* link to previous block */
        struct queue *uqptrRD;
        struct queue *uqptrWR;
        struct queue *lqptrRD;
        struct queue *lqptrWR;
        int state;
        int ref_count;          /* reference count for the object */
                                /* each pending operation references the */
                                /* object and the completion deref's it */
                                /* when the ref count goes to zero, the */
                                /* object can be safely closed */
#ifdef REFCOUNT_TRACE
        int trace_count[NUM_REFCOUNT_TRACE];
                                /* each type of reference has a trace entry */
                                /* when a reference is made, it is made with */
                                /* a reference type that is incremented for */
                                /* the entry */
        int FindNamesAdded;     /* number of findname requests added to the */
                                /* FASTTIMQ for this xeb                    */
        int FindNamesRemoved;   /* number of findname requests taken from the */
                                /* FASTTIMQ for this xeb                      */
#endif
        KEVENT close_event;     /* This event is signalled when the ref count */
                                /* goes to zero.  It is waited on in nbtclose */
        int (*init_object)();   /* init_object procedure */
        void (*in_object)();    /* in_object procedure */
        int (*out_object)();    /* out_object procedure */
        int (*close_object)();  /* close_object procedure */
        int (*test_resource)(); /* procedure, test buf resources */
	int spl;                /* level at which per xeb lock was acquired */
	struct msgb *work_q;	/* work to do queue for deferred actions */
        int bufcall_flag;       /* object wait on buf resources */
        struct xeb *nmptr;      /* pointer to bound name */
} XEB;

#endif  /* COMPILE_UP_TCPIP */


typedef struct linkreq {
    unsigned int primtype;
    XEB *xeb;
    struct queue *toq;              /* who have asked */
    struct queue *l_qbot;
    int   l_index;
    struct msgb * mconind;       /* msg pointer  to message which have started */
                            /* this request */
} LINKREQ;



typedef struct confreq {
    unsigned int primtype;

  /* General */

    unsigned char  this_scope[240];          /* SCOPE_ID */
    unsigned char  name[17];                 /* permanent nb name   */
    unsigned long  broadcast_inaddr;         /* ip broadcast addr   */
    unsigned long  subnet_mask;              /* subnet mask for the ip addr */
    unsigned long  this_inaddr;              /* ip addr for the nbt */
    unsigned short bcast_req_retry_timeout;  /* 250 ms */
    unsigned short bcast_req_retry_count;    /* 3 */

  /* Name service */

    unsigned short conflict_timer;          /* 1000 ms */
    unsigned short namesrv_udpport;         /* 137 */

  /* Session service */

    unsigned short sessionsrv_tcpport;      /* 139 */
    unsigned short ssn_retry_count;         /* 4 */
    unsigned short ssn_close_timeout;       /* 30 sek */
    unsigned short ssn_keep_alive_timeout;  /* 60 sek */

  /* Datagram service */

    unsigned short datagramsrv_udpport;     /* 138 */
    unsigned short dgr_frag_timeout;        /* 2 sec */
} CONFREQ;


#define CONF_REQ            3001
#define NBT_LINK_REQ        3016
#define NBT_LINK_ACK        3017
#define NBT_LINK_NACK       3018
#define NBT_UNLINK_REQ      3019
#define NBT_UNLINK_ACK      3020
#define NBT_UNLINK_NACK     3021


#endif // _NBT_CTRL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\nbt_stat.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nbt_stat.h

Abstract:

    This file contains statistics structure declarations for the user-
    level interface to the NBT driver.

Author:

    Mike Massa (mikemas)           Jan 30, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-30-92     created

Notes:

--*/

/*
 *       /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.nbt_stat.h
 *      @(#)nbt_stat.h  1.2
 *
 *      Last delta created      14:05:19 10/2/91
 *      This file extracted     16:49:25 12/23/91
 *
 *      Modifications:
 *
 *              6 Feb 1991 (RAE)        Ported to SpiderTCP
 */

#ifndef _NBT_STAT_INCLUDED_
#define _NBT_STAT_INCLUDED_

#define MAX_XEB 32              /* max. no. of xebinfos in a message */

/* structure passed/returned in NBT_STAT/NBT_NAME ioctl command */
struct nbt_stat
{
    int    xeb_count;
        char   perm_name[17];   /* Permanent name of node */
        char   scope_id[240];   /* Scope identifier of node */
};


#define NBT_XEBINFO             1       /* primtype of nbt_xebinfo struct */
#define NBT_NAMEINFO    2       /* primtype of nbt_nameinfo struct */
#define NBT_CACHEINFO   3       /* primtype of nbt_cacheinfo struct */

struct nbt_info {
        int prim_type;          /* NBT_XEBINFO or _NAMEINFO or _CACHEINFO */
        int count;                  /* number of entries in message */
};

/*
 *  Per-Endpoint (XEB) Data.
 */
struct xebinfo
{
    long            addr;            /* XEB address */
    char            type[4];         /* type of XEB */
    int             xeb_state;       /* internal xeb state */
    char            local_name[17];  /* NetBIOS name of endpoint */
    char            remote_name[17]; /* NetBIOS name of endpoint */
    int             dev;             /* minor device number of endpoint */
    unsigned int    in_data;         /* received data bytes to endpoint */
    unsigned int    out_data;        /* transmitted data bytes from endpoint */
};

/*
 *  Name Data.
 */
struct nameinfo
{
        long    addr;            /* NEB address */
        int     type;            /* type of name */
        int     status;              /* name status */
        char    name[17];        /* NetBIOS name of endpoint */
};

/*
 *  Cache Data.
 */
struct cacheinfo
{
        long          addr;     /* CACHE_ELEM  address */
        unsigned int  type;     /* type of name */
        unsigned char name[17]; /* NetBIOS name */
        unsigned long ip_addr;  /* Internet Address of name */
        unsigned int  ttl;              /* Time To Live */
};


/*
 *  Ioctl(2) commands for NetBIOS Device.
 */
#define NBT_STAT        ('B'<<8|1)      /* generic status gathering */
#define NBT_RESET       ('B'<<8|2)      /* generic status reset */
#define NBT_NAME        ('B'<<8|3)      /* generic name gathering */
#define NBT_CACHE       ('B'<<8|4)      /* generic cache gathering */
#define NBT_RESYNC      ('B'<<8|5)      /* reread the lmhosts file */


/*
 * Name types and status
 */
#define UNIQUE 0x0000
#define GROUP  0x8000


#define INFINITE_TTL  ((unsigned int) -1)/* CACHE_ELEM.timeout, cacheinfo.ttl */


#define CONFLICT         1
#define REGISTERING      2
#define DEREGISTERING    3
#define REGISTERED       4


#endif // _NBT_STAT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\snmp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    snmp.h

Abstract:

    This module contains SNMP definitions for STREAMS TCP/IP drivers.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/*************************************************************************
 *
 *  SpiderSNMP
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  SNMP.H
 *
 *  Daemon/kernel interface
 *
 *
 *************************************************************************/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.snmp.h
 *	@(#)snmp.h	1.1
 *
 *	Last delta created	10:15:32 3/1/90
 *	This file extracted	08:53:47 7/10/91
 *
 *	Modifications:
 *
 *	GSS 01/03/90	put in Pbrain
 */

#ifndef _SYS_SNET_SNMP_
#define _SYS_SNET_SNMP_


/*
 * Values for the 'ic_cmd' field of I_STR ioctls.
 * These indicate the request to be performed.
 * These should be ored with the constants below, which specify
 * the variables on which the request should be performed.
 */

#define SNMPIOC			('M' << 8)

#define SNMP_GET_REQ		(SNMPIOC | (0 << 5))
#define SNMP_GETNEXT_REQ	(SNMPIOC | (1 << 5))
#define SNMP_SET_REQ		(SNMPIOC | (3 << 5))

#define SNMP_REQ_MASK		(SNMPIOC | (7 << 5))

/*
 * Values for the 'ic_cmd' field of I_STR ioctls.
 * These indicate the variables to be affected.
 * These should be ored with the constants above, which specify
 * the type of request.
 */

#define	SNMP_IF			0
#define	SNMP_IFENTRY		1
#define	SNMP_ATENTRY		2
#define	SNMP_IP			3
#define	SNMP_IPADDRENTRY	4
#define	SNMP_IPROUTEENTRY	5
#define	SNMP_ICMP		6
#define	SNMP_TCP		7
#define	SNMP_TCPCONNENTRY	8
#define	SNMP_UDP		9
#define	SNMP_UDPENTRY	10

#define SNMP_VAR_MASK		31

/*
 * Values for the 'ic_cmd' field of I_STR ioctls.
 * This indicates that an SNMP control message
 * is being sent.
 */

#define SNMP_CONTROL		(SNMPIOC | (7 << 5) | 0)

/*
 * init structure for SNMP
 */

struct snmp_init
{
        uint8 prim_type;
	u_long since;
};

#define SNMP_INIT		1

/*
 * trap structure for SNMP;
 * currently this is only used between drivers
 */

struct snmp_trap
{
	int prim_type;
	long generic_trap;
	long specific_trap;
	int info_len;			/* length of info in bytes */
	char info[1];			/* "interesting" information */
};

/*
 * values for "generic_trap"
 */

#define SNMP_TRAP_ENTSPEC	6

/*
 * values for "specific_trap" are the same as the interface status field
 * i.e. up(1), down(2), testing(3).
 */

#endif /* _SYS_SNET_SNMP_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\s_socket.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    s_socket.h

Abstract:

    This module contains socket definitions for STREAMS TCP/IP sockets.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/******************************************************************
 *
 *  S-TCP Socket Library
 *
 *  Copyright 1987  Spider Systems Limited
 *
 *  S_SOCKET.H
 *
 *  Contains socket definitions for SpiderTCP In-kernel socket
 *  code
 *
 *
 ******************************************************************/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.s_socket.h
 *	@(#)s_socket.h	1.4
 *
 *	Last delta created	15:05:38 6/20/89
 *	This file extracted	08:53:44 7/10/91
 *
 *	Modifications:
 *
 *	NCF 00/00/00	Written
 *
 *	PR  01/12/87	Integrated into Admin System II, all
 *			projects
 */


#ifndef _SYS_SNET_S_SOCKET_
#define _SYS_SNET_S_SOCKET_


/*
 * IOCTL types
 */
#define SO_IOCTL	'S'<<8
#define SO_ACCEPT	(SO_IOCTL | 'a')
#define SO_BIND		(SO_IOCTL | 'b')
#define SO_CONNECT	(SO_IOCTL | 'c')
#define SO_GETPEER	(SO_IOCTL | 'p')
#define SO_GETSOCK	(SO_IOCTL | 'h')
#define SO_GETSOPT	(SO_IOCTL | 'o')
#define SO_SETSOPT	(SO_IOCTL | 't')
#define SO_LISTEN	(SO_IOCTL | 'l')
#define SO_SHUTDOWN	(SO_IOCTL | 'x')


/*
 * Message types
 */
#define SO_DO_ACCEPT	(SO_IOCTL | 'A')
#define SO_EXRCV	(SO_IOCTL | 'U')
#define SO_EXSEND	(SO_IOCTL | 'X')
#define SO_RECV		(SO_IOCTL | 'r')
#define SO_RECVFROM	(SO_IOCTL | 'R')
#define SO_SEND		(SO_IOCTL | 's')
#define SO_SENDTO	(SO_IOCTL | 'S')

/*
 * Socket options structure
 */
struct s_sockopt {
	int	level;
	int	optnam;
	int	optval;	/* May be extended */
};

struct s_ctlhdr {
	long	prim_type;
	int	addrlen;
	char	addr[32];
};

/*
 * Socket SO_DO_ACCEPT structure
 */
struct acc_str {
	int	type;
	int	pad;
	int	*ptr;
};

#endif /* _SYS_SNET_S_SOCKET_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\stcp_opt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stcp_opt.h

Abstract:

    This module contains TCP/IP user options definitions for STREAMS TCP/IP.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/

/******************************************************************
 *
 *  SpiderTCP Application Definitions
 *
 *  Copyright 1987  Spider Systems Limited
 *
 *  STCP_OPT.H
 *
 *  User options for TCP/IP on V.3 Streams
 *
 *  PR@Spider     /\oo/\
 *
 ******************************************************************/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.stcp_opt.h
 *	@(#)stcp_opt.h	1.9
 *
 *	Last delta created	19:24:09 2/21/90
 *	This file extracted	08:53:45 7/10/91
 *
 *	Modifications:
 *
 *	PR 01/12/87	Integrated into Admin System II, all
 *			projects
 */

#ifndef _SYS_SNET_STCP_OPT_
#define _SYS_SNET_STCP_OPT_


/*
 * TCP Top level option.  These may be or'ed together in
 * the option word.  opt_level should be set to TOL_TLI
 * to set these parameters
 */

#define TOL_TLI		0xffff

#define TO_NO_OPTS	0x0000
#define TO_REUSE_ADDR	0x0001
#define TO_KEEPALIVE	0x0004
#define TO_DEBUG	0x0002
#define TO_LINGER	0x0008
#define TO_RDWR		0x0010
#define TO_NODELAY	0x0020

#ifdef TESTOPT
#define TO_TESTOPT	0x0040
#endif

#define TOL_RCVBUF  0x0001

/*
 * TCP/IP Option struct for use with the T_OPTMGMT
 * function.
 */

typedef struct tcp_opt {
	int opt_level;
	int opt_name;
	int opt_data[1];

} TOPT;

#endif /*  _SYS_SNET_STCP_OPT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\tftp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tftp.h

Abstract:

    Definitions for the tftp program.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP Socket Utilities
 *
 *  Copyright 1988  Spider Systems Limited
 *
 *  TFTP.H
 *
 *    Tftp and tftpd includes
 *
 *    CN_RQ, CN_LSTN, CN_RCV, CN_WAIT, CN_MKWRT, STRSAVE, UDP_ALLOC
 *    CN_ACK, LOGPKT, CN_SWAB, CN_CLOSE, CN_SEND, CN_RCVF, CN_ERR
 *    CN_LOG, CN_INFORM, TST_AND_CLR
 *
 *
 ******************************************************************/

/*
 *       /usr/projects/tcp/SCCS.rel3/rel/src/include/sys/snet/0/s.tftp.h
 *      @(#)tftp.h      5.3
 *
 *      Last delta created      14:07:57 3/4/91
 *      This file extracted     11:19:46 3/8/91
 *
 *      Modifications:
 *
 *      GSS 12/04/88    Integrated into Admin System II, all
 *                      projects
 */

/* This file contains the definitions for the TFTP connection control
 * block, which contains all the information pertaining to a connection.
 * A conn structure is allocated at connection open time and retained
 * until the connection is closed.  The routines in the file conn.c
 * are sufficient for dealing with connections.
 * It also contains the structure definition for tftp packets.
 */


/* A connection control block */

struct  conn    {
        SOCKET          netfd;          /* network file descriptor */
        int             type;           /* user or server connection */
        int             synced;         /* conn synchronized flag */
        unsigned int    block_num;      /* next block number */
        char *          last_sent;      /* previous packet sent */
        int             last_len;       /* size of previous packet */
        time_t          nxt_retrans;    /* when to retransmit */
        int             retrans;        /* number of retransmits */
        int             timeout;        /* retransmit timeout */
        char *          cur_pkt;        /* current packet (send or rcv) */
        int             cur_len;        /* current packet len */
        char *          last_rcv;       /* last received packet */
        int             rcv_len;        /* size of last rcvd. packet */
        char           *file;           /* file name */
        int             dir;            /* direction */
        int             mode;           /* transfer mode */
        char           *c_mode;         /* char. string mode */
        struct in_addr  fhost;          /* foreign host */
        int             fport;          /* foreign port for connection */
        int             lport;          /* local port for connection */
        int             intrace;        /* input packet trace flag */
        int             outtrace;       /* output packet trace flag */
        int             logging;        /* connection logging flag */
        int             our_blksize;    /* block size we want */
        int             blksize;        /* negotiated block size */
        int             base_timeout;   /* base timeout value */
        int             expecting_oack; /* we sent options in request */
};

/* connection constants */

#define TIMEOUT         1               /* initial retransmit timeout */
#define INITTIMEOUT     1               /* initial connection timeout */
#define MAX_TIMEOUT     30              /* max. retransmit timeout */
#define MAX_RETRANS     5               /* max. no. of retransmits */
#define DAEMON          0               /* a daemon connection */
#define USER            1               /* a user connection */
#define TMO             0               /* retransmitting due to timeout */
#define DUP             1               /* retransmitting due to duplicate */

#define DATALEN 1432                    /* size of data portion of tftp pkt */

/* tftp packet structure */

struct  tftp    {
        unsigned short  fp_opcode;      /* header */
        unsigned short  fp_blkno;       /* Block number */
        char            fp_blk[DATALEN];/* Data */
        char            dummy;
};

/* values for fp_opcode */

#define RRQ             1               /* Read Request */
#define WRQ             2               /* Write Request */
#define DATA            3               /* Data block */
#define DACK            4               /* Data Acknowledge */
#define ERROR           5               /* Error */
#define OACK            6               /* Options Acknowledge */

/* values for error codes in ERROR packets */

#define TEUNDEF         0               /* Not defined, see message (if any) */
#define TEFNF           1               /* File not found */
#define TEACESS         2               /* Access violation */
#define TEFULL          3               /* Disc full or allocation exceeded */
#define TETFTP          4               /* Illegal TFTP operation */
#define TETID           5               /* Unknown transfer ID */
#define TEEXISTS        6               /* File already exists */
#define TEUSER          7               /* No such user */
#define TEBADOPT        8               /* Bad options */

/* Random constants */

#define TFTPLEN sizeof(struct tftp)     /* max inet packet size */

#define READ            RRQ             /* read requested */
#define WRITE           WRQ             /* write requested */

#define NETASCII        0               /* netascii transfer mode */
#define IMAGE           1               /* image transfer mode */

#define INPKT           0               /* input packet */
#define OUTPKT          1               /* output packet */

#define TRUE            1
#define FALSE           0

/* extern declarations */


#include <stdio.h>

extern  struct  conn    *cn_rq();
extern  struct  conn    *cn_lstn();
extern  struct  tftp    *cn_rcv();
extern  struct  tftp    *cn_mkwrt();
extern  void            cn_ack();
extern  void            logpkt();
extern  void            cn_swab();
extern  void            cn_close();
extern  void            cn_send();
extern  void            cn_rcvf();
extern  void __cdecl   cn_log(const char *, int, ...);
extern  void __cdecl   cn_inform(const char *, ...);
extern  void            cn_err (register struct conn *, struct in_addr,
                                                        int, int, char *);
extern  char            *strsave();
extern  char            tst_and_clr();
extern  char *          udp_alloc();

struct tftp *
cn_wait(
        struct conn *cn,
        unsigned short opcode);

int
cn_parse(
        struct conn *,
        struct in_addr,
        int,
        char *,
        int);

int
cn_retrans(
        struct conn *,
        int
        );

int
cn_wrt(
        struct conn *,
        int);

int
cn_wrtf(
        struct conn *);

int
do_cmd(
        struct conn *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\tcp_ctrl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tcp_ctrl.h

Abstract:

    TCP interface declarations.

Author:

    Mike Massa (mikemas)           Jan 30, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-30-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP Interface Primitives
 *
 *  Copyright (c) 1988  Spider Systems Limited
 *
 *  This Source Code is furnished under Licence, and may not be
 *  copied or distributed without express written agreement.
 *
 *  All rights reserved.
 *
 *  Written by 		Nick Felisiak, Ian Heavens, Peter Reid,
 *			Gavin Shearer, Mark Valentine
 *
 *  TCP_CONTROL.H
 *
 *  TCP Streams ioctl primitives for TCP/IP on V.3 Streams
 *
 ******************************************************************/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.tcp_control.h
 *	@(#)tcp_control.h	1.4
 *
 *	Last delta created	11:56:46 11/1/91
 *	This file extracted	16:49:20 12/23/91
 *
 *	Modifications:
 *
 *	20/07/88 MV	Added tcp_proto to hold tcp_pcbinfo.
 */

#ifndef _SYS_SNET_TCP_CTRL_INCLUDED
#define _SYS_SNET_TCP_CTRL_INCLUDED


struct tcp_pcbinfo {
	int prim_type;
	int tcbcount;
};

typedef union tcp_proto {
	int type;
	struct tcp_pcbinfo pcbinfo;
} S_TCP_PROTO;

#define TCP_PCBINFO	1
#define TCP_TCBINFO 2


#endif  // _SYS_SNET_TCP_CTRL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\net_stat.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    net_stat.h

Abstract:

    This file defines the IOCTL interface to the TCP/IP drivers used by
    the netstat program.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.net_stat.h
 *	@(#)net_stat.h	1.9
 *
 *	Last delta created	12:04:31 3/6/90
 *	This file extracted	16:49:18 12/23/91
 *
 *	MV 08/06/88	Mods for Generic Ethernet Driver (GENERICE).
 *
 *	MV 18/07/88	To get over limits on STREAMS ioctl size, we now
 *			get connection information send up in separate
 *			messages, with the number of connections to expect
 *			passed up (along with protocol stats) in the initial
 *			ioctl.
 */

/*
 *  TCP statistics.
 */

struct tcp_stat
{
	long	net;		/* net to get stats on, 0L -> all nets */

	/* protocol statistics */
	int	tcp_small;	/* incomplete headers */
	int	tcp_cksum;	/* header checksum errors */

	/* connection information */
	int	tcp_conns;	/* number of active TCBs */
};

#define MAX_TCB	32		/* max. no. of tcp_conns in a message */

/*
 *  Per-Connection (TCB) Data.
 */

struct tcp_conn
{
	long	tcp_addr;	/* TCB address */
	int	tcp_rcvq;	/* packets on receive queue */
	int	tcp_sndq;	/* packets on send queue */
	long	tcp_laddr;	/* local address */
	long	tcp_faddr;	/* foreign address */
	short	tcp_lport;	/* local port */
	short	tcp_fport;	/* foreign port */
	int	tcp_state;	/* connection state */
};

/* possible values for tcp_state */

#define CLOSED		0		/* connection not in use */
#define LISTEN		1		/* listening for requests */
#define SYN_SEND	2		/* sent SYN, awaiting ACK */
#define SYN_RECV	3		/* received SYN, not ACKed */
#define ESTABLISHED	4		/* connection established */
#define FIN_WAIT_1	5		/* sent FIN, awaiting ACK */
#define FIN_WAIT_2	6		/* sent FIN, got ACK not FIN */
#define CLOSE_WAIT	7		/* received FIN, not ACKed */
#define LAST_ACK        8               /* waiting for final ACK */

/*
 *  UDP statistics.
 */

struct udp_stat
{
	long	net;		/* net to get stats on, 0L -> all nets */

	/* protocol statistics */
	int	udp_small;	/* packets smaller than minimum */
	int	udp_cksum;	/* header checksum errors */
	int	udp_header;	/* bad data length fields */

	/* connection information */
	int	udp_conns;	/* number of active UCBs */
};

#define MAX_UCB	32		/* max. no. of udp_conns in a message */

/*
 *  Per-Connection (UCB) Data.
 */

struct udp_conn
{
	long	udp_addr;	/* UCB address */
	int	udp_rcvq;	/* packets on receive queue */
	int	udp_sndq;	/* packets on send queue */
	long	udp_laddr;	/* local address */
	int	udp_lport;	/* local port */
	long	udp_faddr;	/* foreign address */
	int	udp_fport;	/* foreign port */
};

/*
 *  IP statistics
 */

struct ip_stat
{
	long	net;		/* net to get stats on, 0L -> all nets */

	int	ip_small;	/* packets smaller than minimum */
	int	ip_cksum;	/* header checksum errors */
	int	ip_header;	/* bad data length fields */
};

#ifndef GENERICE
/*
 *  Ethernet statistics
 */

struct eth_stat
{
	long	eth_tx;		/* packets transmitted */
	long	eth_rx;		/* packets received */
	long	eth_lost;	/* packets discarded */
	int	eth_crc;	/* CRC error packets */
	int	eth_align;	/* alignment error packets */
	int	eth_res;	/* 82586 resource errors */
	int	eth_over;	/* overrun error packets */
};
#endif /*~GENERICE*/

/*
 *  Ioctl(2) commands for Network Devices.
 */

#define NET_STAT	('N'<<8|1)	/* generic statistics gathering */
#define NET_RESET	('N'<<8|2)	/* generic statistics reset */

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\timer.h ===
/********************************************************/
/*							*/
/*	 /redknee10/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.timer.h						*/
/*	@(#)timer.h	1.2						*/
/*							*/
/*	Copyright (c) 1991 Spider Systems Limited	*/
/*							*/
/*	TIMER.H -   Multiple timer module heade		*/
/*							*/
/*	Last delta created	12:22:12 3/12/91			*/
/*	This file extracted	09:26:06 3/18/92			*/
/*							*/
/*	Modifications:					*/
/*							*/
/*							*/
/********************************************************/


/* Lock out clock ISR */
#define splclock()   splhi()

/* Timers header, used to process expiries */
typedef struct thead
{
    void         (*th_expfunc)();
    void *        th_exparg;
    struct timer  *th_expired;
} thead_t;

/* Individual timer */
typedef struct timer
{
    unsigned char  tm_id;
    unsigned char  tm_offset;
    unsigned short tm_left;
    struct timer  *tm_next;
    struct timer **tm_back;
} timer_t;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\udp_ctrl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    udp_ctrl.h

Abstract:

    UDP interface declarations

Author:

    Mike Massa (mikemas)           Jan 30, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-30-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP Interface Primitives
 *
 *  Copyright (c) 1988  Spider Systems Limited
 *
 *  This Source Code is furnished under Licence, and may not be
 *  copied or distributed without express written agreement.
 *
 *  All rights reserved.
 *
 *  Written by 		Nick Felisiak, Ian Heavens, Peter Reid,
 *			Gavin Shearer, Mark Valentine
 *
 *  UDP_CONTROL.H
 *
 *  UDP Streams ioctl primitives for TCP/IP on V.3 Streams
 *
 ******************************************************************/


/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.udp_control.h
 *	@(#)udp_control.h	1.1
 *
 *	Last delta created	16:21:22 1/16/89
 *	This file extracted	16:49:20 12/23/91
 *
 *	Modifications:
 *
 *	20/07/88 MV	New file for netstat protocol message.
 */

#ifndef _SYS_SNET_UDP_CTRL_INCLUDED
#define _SYS_SNET_UDP_CTRL_INCLUDED


struct udp_pcbinfo {
	int prim_type;
	int ucbcount;
};

typedef union udp_proto {
	int type;
	struct udp_pcbinfo pcbinfo;
} S_UDP_PROTO;

#define UDP_PCBINFO	1

#endif  // _SYS_SNET_UDP_CTRL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\common\compdefs.h ===
/*
 * common/compdefs.h
 *
 * Definitions for both encoder and decoder
 */

/*
 * Smallest allowable match length 
 */
#define MIN_MATCH 2

/* 
 * Maximum match length 
 */
#define MAX_MATCH (MIN_MATCH+255)

/*
 * Number of uncompressed symbols 
 */
#define NUM_CHARS 256

/*
 * Number of match lengths which are correlated with match positions 
 */
#define NUM_PRIMARY_LENGTHS     7

/*
 * Primary lengths plus the extension code
 */
#define NUM_LENGTHS             (NUM_PRIMARY_LENGTHS+1)

/*
 * Equals number of different possible match lengths minus primary lengths 
 */
#define NUM_SECONDARY_LENGTHS   ((MAX_MATCH-MIN_MATCH+1)-NUM_PRIMARY_LENGTHS)

/* NL_SHIFT = log2(NUM_LENGTHS) */
#define NL_SHIFT                3

/*
 * Number of repeated offsets 
 */
#define NUM_REPEATED_OFFSETS    3

/*
 * Number of elements in the aligned offset tree
 */
#define ALIGNED_NUM_ELEMENTS 8


/*
 * Repeat codes for outputting trees
 */

/* Minimum number of repetitions of anything we're interested in */
#define TREE_ENC_REP_MIN                4

/* Maximum repetitions for "type A" repetition of zeroes */
/* (min...min+REP_ZERO_FIRST) */
#define TREE_ENC_REP_ZERO_FIRST        16

/* Maximum repetitions for "type B" repetition of zeroes */
/* (min+REP_ZERO_FIRST...min+REP_ZERO_FIRST+REP_ZERO_SECOND) */
#define TREE_ENC_REP_ZERO_SECOND       32

/* Maximum repetitions for "type C" repetition of anything */
/* (min...min_REP_SAME_FIRST) */
#define TREE_ENC_REP_SAME_FIRST         2

/* Bits required to output the above numbers */
#define TREE_ENC_REPZ_FIRST_EXTRA_BITS  4
#define TREE_ENC_REPZ_SECOND_EXTRA_BITS 5
#define TREE_ENC_REP_SAME_EXTRA_BITS    1

/* Number of cfdata frames before E8's are turned off automatically */
#define E8_CFDATA_FRAME_THRESHOLD       32768


/*
 * Block types 
 */
typedef enum
{
		BLOCKTYPE_INVALID       = 0,
		BLOCKTYPE_VERBATIM      = 1, /* normal block */
		BLOCKTYPE_ALIGNED       = 2, /* aligned offset block */
		BLOCKTYPE_UNCOMPRESSED  = 3  /* uncompressed block */
} lzx_block_type;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\inc\sys\snet\uint.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    uint.h

Abstract:

    This file contains type definitions used by STREAMS drivers.

Author:

    Eric Chin (ericc)           July 18, 1991

Revision History:

--*/


/******************************************************************
 *
 *  Copyright 1991  Spider Systems Limited
 *
 *  UINT.H
 *
 ******************************************************************/

/*
 *	 /usr/projects/spare/PBRAIN/SCCS/pbrainG/dev/src/include/sys/snet/0/s.uint.h
 *	@(#)uint.h	1.2
 *
 *	UINT.H
 *
 *	Last delta created	12:22:31 3/12/91
 *	This file extracted	08:53:39 7/10/91
 *
#ifdef MOD_HISTORY
 *
 *	Modifications:
 *
 *	JS	14 Jan 91	Added signed types.
#endif
 */

#ifndef _SYS_SNET_UINT_
#define _SYS_SNET_UINT_


/*
 * Fixed-length types
 */

typedef unsigned char   uint8;
typedef unsigned short  uint16;
typedef unsigned long   uint32;

typedef char   int8;
typedef short  int16;
typedef long   int32;

#endif /* _SYS_SNET_UINT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\d16out.c ===
/*
 * d16out.c
 *
 * Outputting for 16-bit decoder
 */

#include "decoder.h"


void NEAR copy_data_to_output(
    t_decoder_context * context,
    long                amount,
    const byte *        data
)
{
    /*
     * Save pages before we transform
     *
     * Don't save pages if amount < CHUNK_SIZE, because that
     * means that this is our last chunk of data ever.
     * This will save a few page writes at the end.
     */
    if (amount >= CHUNK_SIZE)
        DComp_Save_Output_Pages(context, (uint) amount);

    /* perform jump translation */
    if (context->dec_current_file_size)
    {
        decoder_translate_e8(
            context,
            context->dec_output_buffer,
            amount
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\common\typedefs.h ===
/*
 * typedefs.h
 *
 * Type definitions for LZX
 */
#ifndef _TYPEDEFS_H

#define _TYPEDEFS_H

#include <basetsd.h>
 
/*
 * Definitions for LZX
 */
typedef unsigned char	byte;
typedef unsigned short	ushort;
typedef unsigned long	ulong;
typedef unsigned int    uint;

typedef enum
{
	false = 0,
	true = 1
} bool;


/*
 * Definitions for Diamond/CAB memory allocation
 */
typedef unsigned char   BYTE;
typedef unsigned short	USHORT;
typedef unsigned long	ULONG;
typedef unsigned int    UINT;


#ifdef BIT16

//** 16-bit build
#ifndef HUGE
#   define HUGE huge
#endif

#ifndef FAR
#   define FAR far
#endif

#ifndef NEAR
#   define NEAR near
#endif

#else // !BIT16

//** Define away for 32-bit (NT/Chicago) build
#ifndef HUGE
#	define HUGE
#endif

#ifndef FAR
#	define FAR
#endif

#ifndef NEAR
#   define NEAR
#endif

#endif // !BIT16

#ifndef DIAMONDAPI
#	define DIAMONDAPI __cdecl
#endif

typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)

typedef INT_PTR (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile,int oflag,int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (INT_PTR hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(INT_PTR hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(INT_PTR hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (INT_PTR hf, long dist, int seektype);

#endif /* _TYPEDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\d16uncmp.c ===
/*
 * d16uncmp.c
 *
 * Decoding uncompressed blocks
 */
#include "decoder.h"


int NEAR decode_uncompressed_block(
    t_decoder_context * context,
    long                bufpos,
    int                 amount_to_decode /* yes, it will equal 32768 */
)
{
    byte *p;

    p = context->dec_input_curpos;

    /*
     * Since this is a DO loop, we predecrement amount_to_decode,
     * so it's ok for it to come in with a value of 32768
     */
    do
	{
        if (p >= context->dec_end_input_pos)
            return -1;

        context->DComp_Token_Literal(
            context,
            *p++
        );
    } while (--amount_to_decode > 0);

    context->dec_input_curpos = p;

    return 0;
}


bool NEAR handle_beginning_of_uncompressed_block(t_decoder_context *context)
{
    int i;

    /*
     * we want to read the 16 bits already in bitbuf, so backtrack
     * the input pointer by 2 bytes
     */
    context->dec_input_curpos -= 2;

    if (context->dec_input_curpos + 4 >= context->dec_end_input_pos)
        return false;

	/*
	 * update LRU repeated offset list
	 */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
    {
        context->dec_last_matchpos_offset[i] =
            ((ulong) *(  (byte *) context->dec_input_curpos)    )        |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 1) << 8)  |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 2) << 16) |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 3) << 24);

        context->dec_input_curpos += 4; /* increment by 4 bytes */
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decalign.c ===
/*
 * decalign.c
 *
 * Decoding aligned offset block
 */
#include "decoder.h"


static long special_decode_aligned_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	temp_pos;
	long	bufpos_end;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
	char	dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	byte   *dec_mem_window;
	char	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = bufpos + amount_to_decode;

	while (bufpos < bufpos_end)
	{
		/*
		 * Decode an item
		 */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
			dec_mem_window[bufpos] = (byte) c;
			dec_mem_window[context->dec_window_size + bufpos] = (byte) c;
			bufpos++;
		}
		else
		{
	 		/*
	  		 * Get match length slot
	  		 */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

	 		/*
	  		 * Get match position slot
	  		 */
			m = c >> NL_SHIFT;

			if (m > 2)
			{
				if (dec_extra_bits[ m ] >= 3)
				{
					if (dec_extra_bits[m]-3)
					{
						/* no need to getbits17 */
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
					}
					else
					{
						temp_pos = 0;
					}

	    			match_pos = MP_POS_minus2[m] + (temp_pos << 3);

	    			DECODE_ALIGNED_NOEOFCHECK(temp_pos);
	    			match_pos += temp_pos;
				}
				else
				{
					if (dec_extra_bits[m])
					{
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

						match_pos += MP_POS_minus2[m];
					}
					else
					{
                        match_pos = 1; // MP_POS_minus2[m==3];
					}
				}

				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			match_length += MIN_MATCH;

			do
			{
                dec_mem_window[bufpos] = dec_mem_window[(bufpos-match_pos) & context->dec_window_mask];

				if (bufpos < MAX_MATCH)
					dec_mem_window[context->dec_window_size+bufpos] = dec_mem_window[bufpos];

				bufpos++;
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

    return bufpos;
}


#ifndef ASM_DECODE_ALIGNED_OFFSET_BLOCK
long fast_decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	temp_pos;
	long	bufpos_end;
	long	decode_residue;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
	char	dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	byte   *dec_mem_window;
	ulong	match_ptr;
	char	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = bufpos + amount_to_decode;

	while (bufpos < bufpos_end)
	{
		/*
		 * Decode an item
		 */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
			dec_mem_window[bufpos++] = (byte) c;
		}
		else
		{
	 		/*
	  		 * Get match length slot
	  		 */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

	 		/*
	  		 * Get match position slot
	  		 */
			m = c >> NL_SHIFT;

			if (m > 2)
			{
				if (dec_extra_bits[ m ] >= 3)
				{
					if (dec_extra_bits[m]-3)
					{
						/* no need to getbits17 */
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
					}
					else
					{
						temp_pos = 0;
					}

	    			match_pos = MP_POS_minus2[m] + (temp_pos << 3);

	    			DECODE_ALIGNED_NOEOFCHECK(temp_pos);
	    			match_pos += temp_pos;
				}
				else
				{
					if (dec_extra_bits[m])
					{
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

						match_pos += MP_POS_minus2[m];
					}
					else
					{
						match_pos = MP_POS_minus2[m];
					}
				}

				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			match_length += MIN_MATCH;
			match_ptr = (bufpos - match_pos) & context->dec_window_mask;

			do
			{
				dec_mem_window[bufpos++] = dec_mem_window[match_ptr++];
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

	/* should be zero */
	decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
	context->dec_bufpos = bufpos;

	return decode_residue;
}
#endif


int decode_aligned_offset_block(
    t_decoder_context * context, 
    long                BufPos, 
    int                 amount_to_decode
)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
    {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_aligned_block(
            context,
            BufPos,
            amount_to_slowly_decode
        );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
    }

    return fast_decode_aligned_offset_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decapi.c ===
/*
 * decapi.c
 *
 * API entry points.
 */

#define ALLOC_VARS
#include "decoder.h"
#include <stdio.h>


bool LZX_DecodeInit(
	t_decoder_context *	context,
	long				compression_window_size,
	PFNALLOC			pfnma,
    PFNFREE             pfnmf,
    PFNOPEN             pfnopen,
    PFNREAD             pfnread,
    PFNWRITE            pfnwrite,
    PFNCLOSE            pfnclose,
    PFNSEEK             pfnseek
)
{
	context->dec_malloc	= pfnma;
	context->dec_free	= pfnmf;

    /* used for 16-bit swap file only */
    context->dec_open   = pfnopen;
    context->dec_read   = pfnread;
    context->dec_write  = pfnwrite;
    context->dec_close  = pfnclose;
    context->dec_seek   = pfnseek;

	context->dec_window_size = compression_window_size;
	context->dec_window_mask = context->dec_window_size - 1;

	/*
	 * Window size must be a power of 2
	 */
	if (context->dec_window_size & context->dec_window_mask)
		return false;

	if (allocate_decompression_memory(context) == false)
		return false;

	LZX_DecodeNewGroup(context);

	return true;
}


void LZX_DecodeFree(t_decoder_context *context)
{
	free_decompression_memory(context);
}


void LZX_DecodeNewGroup(t_decoder_context *context)
{
	reset_decoder_trees(context);
	decoder_misc_init(context);
	init_decoder_translation(context);
    context->dec_num_cfdata_frames = 0;

#ifdef BIT16
    DComp_Reset(context);
#endif
}


int LZX_Decode(
	t_decoder_context *context,
	long	bytes_to_decode,
	byte *	compressed_input_buffer,
	long	compressed_input_size,
	byte *	uncompressed_output_buffer,
	long	uncompressed_output_size,
	long *	bytes_decoded
)
{
    long    result;

    context->dec_input_curpos   = compressed_input_buffer;
    context->dec_end_input_pos  = (compressed_input_buffer + compressed_input_size + 4);

    context->dec_output_buffer  = uncompressed_output_buffer;

#ifdef BIT16
    context->dec_output_curpos  = uncompressed_output_buffer;
    context->DComp.NumBytes = (unsigned short) uncompressed_output_size;
#endif

	init_decoder_input(context);

    result = decode_data(context, bytes_to_decode);

    context->dec_num_cfdata_frames++;

    if (result < 0)
    {
        *bytes_decoded = 0;
        return 1; /* failure */
    }
    else
    {
        *bytes_decoded = result;
        context->dec_position_at_start += result;
        return 0; /* success */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\d16align.c ===
/*
 * d16align.c
 *
 * Decoding aligned offset block
 */
#include "decoder.h"


int NEAR decode_aligned_offset_block(
    t_decoder_context * context,
    long                bufpos,
    int                 amount_to_decode /* yes, it will equal 32768 */
)
{
	ulong	match_pos;
	ulong	temp_pos;
	ulong	dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    MATCH   match_info;
	int		match_length;
	int		c;
	char	m;
	char	dec_bitcount;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;

    /*
     * see comment in d16verb.c about why this is a DO loop,
     * and why we allow a signed int to hold the value 32768.
     */
    do
	{
		/*
		 * Decode an item
		 */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
            context->DComp_Token_Literal(context, (byte) c);
            amount_to_decode--;
		}
		else
		{
	 		/*
	  		 * Get match length slot
	  		 */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

	 		/*
	  		 * Get match position slot
	  		 */
			m = c >> NL_SHIFT;

			if (m > 2)
			{
				if (dec_extra_bits[ m ] >= 3)
				{
					if (dec_extra_bits[m]-3)
					{
						/* no need to getbits17 */
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
					}
					else
					{
						temp_pos = 0;
					}

	    			match_pos = MP_POS_minus2[m] + (temp_pos << 3);

	    			DECODE_ALIGNED_NOEOFCHECK(temp_pos);
	    			match_pos += temp_pos;
				}
				else
				{
					if (dec_extra_bits[m])
					{
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

						match_pos += MP_POS_minus2[m];
					}
					else
					{
						match_pos = MP_POS_minus2[m];
					}
				}

				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

            match_length += MIN_MATCH;

            match_info.Len = match_length;
            match_info.Dist = match_pos;
            context->DComp_Token_Match(context, match_info);

            amount_to_decode -= match_length;
		}
    } while (amount_to_decode > 0);

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\d16verb.c ===
/*
 * d16verb.c
 *
 * Decoding verbatim-bit blocks
 */
#include "decoder.h"


int NEAR decode_verbatim_block(
    t_decoder_context * context,
    long                BufPos,
    int                 amount_to_decode /* yes, it will equal 32768 */
)
{
	ulong	match_pos;
	ulong	dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	int		match_length;
	int		c;
	char	dec_bitcount;
	char	m;
    MATCH   match_info;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;

    /*
     * amount_to_decode must never be > 32768
     *
     * As it stands, we do the (amount_to_decode >= 0) check
     * at the bottom of the DO loop, rather than at the top of
     * a WHILE loop, so that we can used a signed int; this way,
     * we decrement it by at least 1 by the time we check against
     * zero.
     */

    do
	{
		/* decode an item from the main tree */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
	 		/*	it's a character */
			/* note: c - 256 == c if c is a byte */
            context->DComp_Token_Literal(context, (int) ((byte) c));
            amount_to_decode--;
		}
		else
		{
	 		/* get match length header */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				/* get match length footer if necessary */
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

			/* get match position slot */
			m = c >> NL_SHIFT;

	  		/* read any extra bits for the match position */
			if (m > 2) 
			{
				if (m > 3) /* dec_extra_bits[m] != 0 */
				{
	    			GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
					match_pos += MP_POS_minus2[m];
				}
				else
				{
					match_pos = MP_POS_minus2[3];
				}

				/*
				 * Add match base to "extra bits".  Our match base
				 * table has 2 subtracted from all the elements.
				 *
				 * This is because encoded positions 0,1,2 denote
				 * repeated offsets.  Encoded position 3 denotes
				 * a match 1 character away, 4 encodes 2 away, etc.  
				 * Hence the subtraction of 2, which has been
				 * incorporated into the table.
				 */

				/* update LRU repeated offset list */
				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				/* positions 0, 1, 2 denote repeated offsets */
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			/* match lengths range from 2...257 */
			match_length += MIN_MATCH; 

            match_info.Len = match_length;
            match_info.Dist = match_pos;
            context->DComp_Token_Match(context, match_info);

            amount_to_decode -= match_length;
		}
    } while (amount_to_decode > 0);

    context->dec_bitcount = dec_bitcount;
    context->dec_bitbuf   = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decapi.h ===
/*
 * decapi.h
 * 
 * Decoder API definitions
 */

bool LZX_DecodeInit(
	t_decoder_context *context,
	long		compression_window_size,
	PFNALLOC	pfnma,
    PFNFREE     pfnmf,
    PFNOPEN     pfnopen,
    PFNREAD     pfnread,
    PFNWRITE    pfnwrite,
    PFNCLOSE    pfnclose,
    PFNSEEK     pfnseek
);

void LZX_DecodeFree(t_decoder_context *context);

void LZX_DecodeNewGroup(t_decoder_context *context);

int LZX_Decode(
	t_decoder_context *context,
	long	bytes_to_decode,
	byte *	compressed_input_buffer,
	long	compressed_input_size,
	byte *	uncompressed_output_buffer,
	long	uncompressed_output_size,
	long *	bytes_decoded
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decin.c ===
/*
 * decin.c
 *
 * Decoder inputting of compressed data
 */
#include "decoder.h"


/*
 * Initialises the bit buffer state
 */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context)
{
	byte *p;

    /*
     * If we're decoding an uncompressed block, don't use the
     * bit buffer; we're reading directly out of the input.
     */
    if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
        return;

    if ((context->dec_input_curpos + sizeof(ulong)) > context->dec_end_input_pos)
        return;

    p = context->dec_input_curpos;

	context->dec_bitbuf =
        ((ulong) p[2] | (((ulong) p[3]) << 8)) |
        ((((ulong) p[0] | (((ulong) p[1]) << 8))) << 16);

	context->dec_bitcount = 16;
    context->dec_input_curpos += 4;
}


/*
 * Initialise input buffer and bitwise i/o
 */
void NEAR init_decoder_input(t_decoder_context *context)
{
   initialise_decoder_bitbuf(context);
}


void NEAR fillbuf(t_decoder_context *context, int n)
{
	context->dec_bitbuf <<= n;            					
	context->dec_bitcount -= (char)n;
	
	if (context->dec_bitcount <= 0)      					
	{                                 				
		if (context->dec_input_curpos >= context->dec_end_input_pos)	
        {
            context->dec_error_condition = true;
            return;
        }

        context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
        context->dec_input_curpos += 2;
        context->dec_bitcount += 16;

		if (context->dec_bitcount <= 0)							
		{                                 				
            if (context->dec_input_curpos >= context->dec_end_input_pos)
            {
                context->dec_error_condition = true;
                return;
            }

            context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
            context->dec_input_curpos += 2;
			context->dec_bitcount += 16;               			
		}												
   }                                    				
}


ulong NEAR getbits(t_decoder_context *context, int n)
{
	ulong value;

	value = context->dec_bitbuf >> (32-(n));			
	fillbuf(context, n);

	return value;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decoder.h ===
/*
 * decoder.h
 *
 * Main decoder header file
 */

#ifndef DECODER_H
#define DECODER_H

#ifdef EXT
#	undef EXT
#endif

#ifdef ALLOC_VARS
#	define EXT
#else
#	define EXT extern
#endif

#ifdef USE_ASSEMBLY
#   define ASM_DECODE_VERBATIM_BLOCK
#   define ASM_TRANSLATE_E8
#   define ASM_MAKE_TABLE
#endif

#include <stdlib.h>
#include <string.h>
#include "../common/typedefs.h"
#include "../common/compdefs.h"  
#include "decmacro.h"
#include "decdefs.h"

#ifdef BIT16
#   include "ring16.h"
#endif

#include "decvars.h"
#include "decapi.h"
#include "decproto.h"

#endif /* DECODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decinit.c ===
/*
 * decinit.c
 *
 * Initialisation routines for LZX decoder
 */

#include "decoder.h"


/* 
 * Allocate memory for decompression 
 */
bool NEAR allocate_decompression_memory(t_decoder_context *context)
{
	ulong	pos_start;

	context->dec_num_position_slots	= 4;
	pos_start						= 4;

	while (1)
	{
        pos_start += 1L << dec_extra_bits[context->dec_num_position_slots];

		context->dec_num_position_slots++;

		if (pos_start >= context->dec_window_size)
			break;
	}

#ifdef BIT16
    if (DComp_Init(context))
        return false;
#else
	if (!(context->dec_mem_window = (byte *) context->dec_malloc(context->dec_window_size+(MAX_MATCH+4))))
		return false;
#endif

	return true; 
}


/*
 * Free decompression memory
 */
void NEAR free_decompression_memory(t_decoder_context *context)
{
#ifdef BIT16
    DComp_Close(context);
#else
	if (context->dec_mem_window)
	{
		context->dec_free(context->dec_mem_window);
		context->dec_mem_window = NULL;
	}
#endif
}


/*
 * Set/reset decoder trees to initial state
 */
void NEAR reset_decoder_trees(t_decoder_context *context)
{
	memset(context->dec_main_tree_len, 0, MAIN_TREE_ELEMENTS);
	memset(context->dec_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);

	memset(context->dec_secondary_length_tree_len, 0, NUM_SECONDARY_LENGTHS);
	memset(context->dec_secondary_length_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);
}


/*
 * Miscellaneous state initialisations
 */
void NEAR decoder_misc_init(t_decoder_context *context)
{
	context->dec_last_matchpos_offset[0]    	 = 1;
	context->dec_last_matchpos_offset[1]    	 = 1;
	context->dec_last_matchpos_offset[2]    	 = 1;

	context->dec_bufpos = 0;
    context->dec_position_at_start = 0;

	context->dec_decoder_state	= DEC_STATE_START_NEW_BLOCK;
	context->dec_block_size		= 0;

    /* so that initialise_decoder_bitbuf() will succeed */
    context->dec_block_type     = BLOCKTYPE_INVALID;

	context->dec_first_time_this_group	= true;
	context->dec_current_file_size		= 0;

    context->dec_error_condition = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decmacro.h ===
/*
 * decmacro.h
 *
 * Macros used by the decoder
 */


/*
 * decode an element from the aligned offset tree, without checking 
 * for the end of the input data
 */
#define DECODE_ALIGNED_NOEOFCHECK(j) \
	(j) = context->dec_aligned_table[dec_bitbuf >> (32-ALIGNED_TABLE_BITS)]; \
	FILL_BUF_NOEOFCHECK(context->dec_aligned_len[(j)]);


/*
 * Decode an element from the main tree
 * Check for EOF
 */
#define DECODE_MAIN_TREE(j) \
	j = context->dec_main_tree_table[dec_bitbuf >> (32-MAIN_TREE_TABLE_BITS)];	\
	if (j < 0)															\
	{																	\
        ulong mask = (1L << (32-1-MAIN_TREE_TABLE_BITS));               \
		do																\
		{																\
	 		j = -j;														\
	 		if (dec_bitbuf & mask)										\
                j = context->dec_main_tree_left_right[j*2+1];                   \
			else														\
                j = context->dec_main_tree_left_right[j*2];                     \
			mask >>= 1;													\
		} while (j < 0);												\
	}																	\
	FILL_BUF_FULLCHECK(context->dec_main_tree_len[j]);


/*
 * Decode an element from the secondary length tree
 * No checking for EOF
 */
#define DECODE_LEN_TREE_NOEOFCHECK(matchlen) \
    matchlen = context->dec_secondary_length_tree_table[dec_bitbuf >> (32-SECONDARY_LEN_TREE_TABLE_BITS)]; \
	if (matchlen < 0)                                                	\
	{                                                                	\
        ulong mask = (1L << (32-1-SECONDARY_LEN_TREE_TABLE_BITS));      \
		do                                                          	\
		{																\
	 		matchlen = -matchlen;                                      	\
	 		if (dec_bitbuf & mask)                                  	\
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2+1];\
			else                                                        \
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2];  \
			mask >>= 1;                                                 \
		} while (matchlen < 0);											\
	}																	\
    FILL_BUF_NOEOFCHECK(context->dec_secondary_length_tree_len[matchlen]);      \
	matchlen += NUM_PRIMARY_LENGTHS;


/*
 * read n bits from input stream into dest_var, but don't
 * check for EOF
 */
#define GET_BITS_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF_NOEOFCHECK((N));					\
}


/* same as above, but don't check for EOF */
#define GET_BITS17_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));			\
   FILL_BUF17_NOEOFCHECK((N));					\
}


/*
 * Remove n bits from the input stream
 * handles 1 <= n <= 17
 *
 * FORCE an EOF check ALWAYS, whether or not we read in more
 * bytes from memory.
 *
 * This is used to ensure that we always get an EOF check often enough
 * to not overrun the extra bytes in the buffer.
 *
 * This routine is used ONLY when decoding the main tree element,
 * where we know that the code we read in will be 16 bits or less
 * in length.  Therefore we don't have to check for bitcount going
 * less than zero, twice.
 */
#define FILL_BUF_FULLCHECK(N) \
{                                    		\
	if (dec_input_curpos >= dec_end_input_pos)	\
        return -1; \
	dec_bitbuf <<= (N);            			\
	dec_bitcount -= (N);                    \
	if (dec_bitcount <= 0)      			\
	{                                 		\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2;              \
		dec_bitcount += 16;               	\
    }                                       \
}

/*
 * Same as above, but no EOF check 
 *
 * This is used when we know we will not run out of input
 */
#define FILL_BUF_NOEOFCHECK(N) 			\
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
	}                                   \
}

/*
 * Same as above, but handles n=17 bits
 */
#define FILL_BUF17_NOEOFCHECK(N)        \
{                                    	\
	dec_bitbuf <<= (N);            		\
	dec_bitcount -= (N);                \
	if (dec_bitcount <= 0)      		\
	{                                 	\
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
		dec_bitcount += 16;				\
		if (dec_bitcount <= 0) \
		{ \
            dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
            dec_input_curpos += 2; \
			dec_bitcount += 16;         \
		} \
	}                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decdefs.h ===
/*
 * decdefs.h
 *
 * Structures and definitions used by the decoder
 */


typedef enum
{
	DEC_STATE_UNKNOWN,
	DEC_STATE_START_NEW_BLOCK,
	DEC_STATE_DECODING_DATA
} decoder_state;


/*
 * Size of uncompressed data chunks
 */
#define CHUNK_SIZE  32768


/*
 * Main tree decoding table parameters 
 */

/* # elements in main tree */
#define MAIN_TREE_ELEMENTS			(NUM_CHARS+(context->dec_num_position_slots<<NL_SHIFT))

/*
 * Decoding table size allows a direct lookup on the first 
 * MAIN_TREE_TABLE_BITS bits of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define MAIN_TREE_TABLE_BITS		10 

/*
 * Secondary length tree decoding table parameters
 * Decoding table size allows a direct lookup on the first
 * SECONDARY_LEN_TREE_TABLE_BITS of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define SECONDARY_LEN_TREE_TABLE_BITS	8 

/* 
 * Aligned offset tree decoding table parameters 
 */
#define ALIGNED_NUM_ELEMENTS	8

/*
 * Must be 7, since we do not use left/right for this tree;
 * everything is decoded in one lookup.
 */
#define ALIGNED_TABLE_BITS		7
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decout.c ===
/*
 * decout.c
 *
 * Decoder outputting
 */

#include "decoder.h"


void copy_data_to_output(t_decoder_context *context, long amount, const byte *data)
{
    if (context->dec_output_buffer == NULL)
        return;

    memcpy(
        context->dec_output_buffer,
        data,
        amount
    );

    /* perform jump translation */
    if ((context->dec_current_file_size != 0) && (context->dec_num_cfdata_frames < E8_CFDATA_FRAME_THRESHOLD))
    {
        decoder_translate_e8(
            context,
            context->dec_output_buffer,
            amount
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decblk.c ===
/*
 * decblk.c
 *
 * main decoder module
 */
#include "decoder.h"


/* local function prototypes */
static int decode_block(
	t_decoder_context	*context, 
	lzx_block_type		block_type, 
	long				bufpos, 
    long                amount_to_decode
);


/*
 * Decode a block type
 */
static int decode_block(
	t_decoder_context	*context, 
	lzx_block_type		block_type, 
	long				bufpos, 
    long                amount_to_decode
)
{
    int result;

	if (block_type == BLOCKTYPE_ALIGNED)
        result = decode_aligned_offset_block(context, bufpos, (int) amount_to_decode);
	else if (block_type == BLOCKTYPE_VERBATIM)
        result = decode_verbatim_block(context, bufpos, (int) amount_to_decode);
	else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        result = decode_uncompressed_block(context, bufpos, (int) amount_to_decode);
	else /* no other block types exist */
		result = -1;

	return result;
}



/*
 * Main decode entrypoint
 */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode)
{                                                                                                                                                                                                                                          
	ulong			amount_can_decode;
	long			total_decoded;

	total_decoded = 0;

	while (bytes_to_decode > 0)          
	{
		if (context->dec_decoder_state == DEC_STATE_START_NEW_BLOCK)
		{
			ulong	temp1;                                                                                           
			ulong	temp2;
			ulong	temp3;
			bool	do_translation;

			/*
			 * If this is the first time this group, then get the
			 * file size for translation.
			 */
			if (context->dec_first_time_this_group)
			{
				context->dec_first_time_this_group = false;

                do_translation = (bool) getbits(context, 1);

				if (do_translation)
				{
					ulong high, low;

					high = getbits(context, 16);
					low  = getbits(context, 16);
					context->dec_current_file_size = (high<<16)|low;
				}
				else
				{
					context->dec_current_file_size = 0;
				}
			}

            /*
             * If the last block we decoded was uncompressed, then
             * we need to skip the pad byte (if it exists), and
             * initialise the decoder's bit buffer
             */
            if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
            {
                /*
                 * If block size was odd, a pad byte is required
                 */
                if (context->dec_original_block_size & 1)
                {
                    if (context->dec_input_curpos < context->dec_end_input_pos)
                        context->dec_input_curpos++;
                }

                /* so that initialise_decoder_bitbuf() will succeed */
                context->dec_block_type = BLOCKTYPE_INVALID;

                initialise_decoder_bitbuf(context);
            }

			/* get the block type */
            context->dec_block_type = (lzx_block_type) getbits(context, 3);

			/* get size of block (in uncompressed bytes) to decode */
			temp1 = getbits(context, 8);
			temp2 = getbits(context, 8);
			temp3 = getbits(context, 8);

			/*
			 * How large is the block we're going to decode?
			 * It can be from 0...16777215 bytes (16MB)
			 */
            context->dec_block_size =
            context->dec_original_block_size = (temp1<<16) + (temp2<<8) + (temp3);

			/* if block is an aligned type, read the aligned offset tree */
			if (context->dec_block_type == BLOCKTYPE_ALIGNED)
				read_aligned_offset_tree(context);

			/* read trees */
			if (context->dec_block_type == BLOCKTYPE_VERBATIM || 
      			context->dec_block_type == BLOCKTYPE_ALIGNED)
			{
	 			/*	backup old trees */
	 			memcpy(
                    context->dec_main_tree_prev_len, 
                    context->dec_main_tree_len, 
	 				MAIN_TREE_ELEMENTS
	 			);

	 			memcpy(
                    context->dec_secondary_length_tree_prev_len,
                    context->dec_secondary_length_tree_len,
	 				NUM_SECONDARY_LENGTHS
	 			);

				read_main_and_secondary_trees(context);
			}
			else if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
			{
                if (handle_beginning_of_uncompressed_block(context) == false)
                    return -1;
			}
			else 
			{
				/* no other block types are supported at this time */
                return -1;
			}

			context->dec_decoder_state = DEC_STATE_DECODING_DATA;
		}

		/*
		 * Keep decoding until the whole block has been decoded
		 */
		while ((context->dec_block_size > 0) && (bytes_to_decode > 0))
		{
            int decode_residue;

			amount_can_decode = min(context->dec_block_size, bytes_to_decode);
		
	 		/* shouldn't happen */
	 		if (amount_can_decode == 0)
                return -1;

 			decode_residue = decode_block(
				context, 
				context->dec_block_type, 
				context->dec_bufpos, 
				amount_can_decode
			);

	 		/*
	 		 * We should have decoded exactly the amount we wanted,
			 * since the encoder makes sure that no matches span 32K
			 * boundaries.
			 *
	 		 * If the data was corrupted, it's possible that we decoded
			 * up to MAX_MATCH bytes more than we wanted to.
  			 */
	 		if (decode_residue != 0)
	    	{
				/* error, we didn't decode what we wanted! */
                return -1;
			}

	 		context->dec_block_size -= amount_can_decode;
			bytes_to_decode -= amount_can_decode;
			total_decoded += amount_can_decode;
		}

		if (context->dec_block_size == 0)
		{
			context->dec_decoder_state = DEC_STATE_START_NEW_BLOCK;
		}

		if (bytes_to_decode == 0)
		{
			initialise_decoder_bitbuf(context);
		}
	}

#ifdef BIT16
    copy_data_to_output(
        context,
        total_decoded,
        context->dec_output_buffer
    );
#else
    copy_data_to_output(
		context,
		total_decoded, 
		context->dec_bufpos ? 
			&context->dec_mem_window[context->dec_bufpos - total_decoded] : 
			&context->dec_mem_window[context->dec_window_size - total_decoded]
	);
#endif

    return total_decoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decproto.h ===
/* 
 * decproto.h
 *
 * Decoder function prototypes
 */

/* decblk.c */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode);

/* decin.c */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context);
void NEAR init_decoder_input(t_decoder_context *context);
void NEAR fillbuf(t_decoder_context *context, int n);
ulong NEAR getbits(t_decoder_context *context, int n);

/* decinit.c */
bool NEAR allocate_decompression_memory(t_decoder_context *context); 
void NEAR free_decompression_memory(t_decoder_context *context);
void NEAR decoder_misc_init(t_decoder_context *context);
void NEAR reset_decoder_trees(t_decoder_context *context);

/* decout.c */
void NEAR copy_data_to_output(t_decoder_context *context, long amount, const byte *data);

/* dectree.c */
bool NEAR read_main_and_secondary_trees(t_decoder_context *context);
bool NEAR read_aligned_offset_tree(t_decoder_context *context);

/* maketbl.c */
bool NEAR make_table(
	t_decoder_context *context, 
	int			nchar,
	const byte	*bitlen,
	byte		tablebits,
	short		*table,
	short		*leftright
);

bool NEAR make_table_8bit(t_decoder_context *context, byte *bitlen, byte *table);
	
/* decxlat.c */
void NEAR init_decoder_translation(t_decoder_context *context);
void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes);

/* decalign.c */
int NEAR decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decverb.c */
int NEAR decode_verbatim_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decuncmp.c */
int NEAR decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode);
bool NEAR handle_beginning_of_uncompressed_block(t_decoder_context *context);


/*
 * 16-bit stuff:
 */
#ifdef BIT16
void NEAR DComp_Close(t_decoder_context *context);
int  NEAR DComp_Init(t_decoder_context *context);
void NEAR DComp_Reset(t_decoder_context *context);
void NEAR DComp_Save_Output_Pages(t_decoder_context *context, uint bytes_decoded);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\dv.asm ===
;
; DV.ASM
;
; jforbes
;
	TITLE   DV.ASM
   .386P

.model FLAT

_TEXT SEGMENT

INCLUDE offsets.i

EXTRN   _MP_POS_minus2:DWORD
EXTRN   _dec_extra_bits:BYTE

local_32_minus_extra_bits:
DB      32,32,32,32,31,31,30,30
DB      29,29,28,28,27,27,26,26
DB      25,25,24,24,23,23,22,22
DB      21,21,20,20,19,19,18,18
DB      17,17,16,16,15,15,15,15
DB      15,15,15,15,15,15,15,15
DB      15,15,15

PUBLIC  _fast_decode_verbatim_block

;
; NOTES:
;
; last_offset uses 12 bytes; 4 for each of the 3 repeated offsets
;

$bitbuf=0
$bufposend=4
$context=8
$mem_window=12
$last_offset=16
$bitcount=28
$stackvars=32

;
; fast_decode_verbatim_block(context, bufpos, amount_to_decode)
;
_fast_decode_verbatim_block PROC NEAR

; save registers
    push    edx              
    push    ecx
    push    ebx
    push    edi
    push    esi
    push    ebp


; load parameters and initialise
    mov     edx, [esp + 28]  ; context
    mov     edi, [esp + 32]  ; bufpos

    mov     eax, [esp + 36]  ; amount_to_decode
    mov     esi, [edx + OFF_INPUT_CURPOS] ; input data ptr

    add     eax, edi         ; eax := bufpos_end = bufpos + amt
    sub     esp, $stackvars  ; allocate stack space for variables


; store variables on stack
    mov     [esp + $context], edx       ; u
    mov     [esp + $bufposend], eax     ; v

    mov     ecx, [edx + OFF_MEM_WINDOW] ; u
    mov     eax, [edx + OFF_BITBUF]     ; v

    mov     [esp + $mem_window], ecx    ; u
    mov     [esp + $bitbuf], eax        ; v


; copy repeated offsets onto stack for quicker accessing (<128 byte offset)
    mov     ecx, [edx + OFF_LAST_MATCHPOS_OFFSET]     ; u
    mov     ebx, [edx + OFF_LAST_MATCHPOS_OFFSET + 4] ; v

    mov     eax, [edx + OFF_LAST_MATCHPOS_OFFSET + 8] ; u
    mov     [esp + $last_offset], ecx                 ; v

    mov     [esp + $last_offset + 4], ebx             ; u
    mov     [esp + $last_offset + 8], eax             ; v


; store other variables
    xor     ecx, ecx
    mov     cl, BYTE PTR [edx + OFF_BITCOUNT]
    mov     [esp + $bitcount], ecx

    mov     edx, ecx

; start
    jmp     SHORT loop_top

;
; end of init
;



;
; Decoder input overflow error!
;
$fillbuf1:

; restore stack and return -1
    add     esp, $stackvars

    pop     ebp
    pop     esi
    pop     edi
    pop     ebx
    pop     ecx
    pop     edx

    mov     eax, -1

    ret     0


;
; Handle codes > table bits in length, for main tree
;
main_tree_long_code:
    mov     eax, [esp + $bitbuf]                   ; u
    shl     eax, MAIN_TREE_TABLE_BITS  ; u

; negation loop
$L19975:
    neg     ebx              ; NP

    add     ebx, ebx         ; u
    add     eax, eax         ; v  test MSB of eax

; ADC takes 3 clocks, which allows it to overshadow the 0F prefix
; in the next instruction (saving 1 clock)
    adc     ebx, 0           ; u

; won't pair
    movsx   ebx, WORD PTR [ecx + OFF_MAIN_TREE_LEFTRIGHT + ebx*2]

    test    ebx, ebx         ; u
    jl      SHORT $L19975    ; v

    jmp     SHORT back_main_tree_long_code



;
; Handle codes > table bits in length, for secondary tree
;
secondary_tree_long_code:
    mov     ecx, [esp + $bitbuf]
    shl     ecx, SECONDARY_LEN_TREE_TABLE_BITS

$L19990:
    neg     ebp

    add     ebp, ebp
    add     ecx, ecx

    adc     ebp, 0

; won't pair
    movsx   ebp, WORD PTR [eax + OFF_SECONDARY_TREE_LEFTRIGHT + ebp*2]

    test    ebp, ebp
    jl      SHORT $L19990

    jmp     back_secondary_tree_long_code


;
; loop top
;
loop_top:

; DECODE_DDMTREE(c);

; ebx = table[ bitbuf >> (32-MAIN_TREE_TABLE_BITS) ]
    mov     ecx, [esp + $context]  ; u1
    mov     eax, [esp + $bitbuf]   ; v1

    shr     eax, 32-MAIN_TREE_TABLE_BITS            ; u1
    mov     ebp, DWORD PTR [ecx + OFF_INPUT_ENDPOS] ; v1


loop_top_after_char:
    movsx   ebx, WORD PTR [ecx + OFF_MAIN_TREE_TABLE + eax*2] ; NP

    test    ebx, ebx                  ; u
    jl      SHORT main_tree_long_code ; v


back_main_tree_long_code:

; check for end of input
    cmp     ebp, esi               ; u1
    jbe     SHORT $fillbuf1        ; v1

    mov     cl, [ebx + ecx + OFF_MAIN_TREE_LEN] ; u1  cl = len[x]
    xor     eax, eax               ; v1

    shl     DWORD PTR [esp + $bitbuf], cl ; NP  bitbuf <<= len

    sub     dl, cl                 ; u1  bitcount -= len
    jg      SHORT bitcount_gt_0    ; v1

; otherwise fill buffer
    mov     al, [esi]              ; u1
    mov     cl, dl                 ; v1

    mov     ah, [esi+1]            ; u1
    xor     cl, -1                 ; v1

    add     esi, 2                 ; u1
    inc     cl                     ; v1

    shl     eax, cl                ; NP

    or      eax, [esp + $bitbuf]   ; u1
    add     dl, 16                 ; v1

    mov     [esp + $bitbuf], eax   ; u1
    nop                            ; v1

bitcount_gt_0:

;
; is it a match or a character?
;
    sub     ebx, 256               ; u1
    jns     SHORT $L19985          ; v1


;
; it's a character
;
    mov     ebp, [esp + $mem_window]     ; u1  get mem_window ptr
    inc     edi                          ; v1  bufpos++

    mov     eax, [esp + $bitbuf]         ; u1  for next iteration
    mov     ecx, [esp + $context]        ; v1  for next iteration

    shr     eax, 32-MAIN_TREE_TABLE_BITS ; u1  for next iteration

    mov     [ebp + edi - 1], bl          ; u1  store current character
    mov     ebp, DWORD PTR [ecx + OFF_INPUT_ENDPOS] ; v1 for next iteration

    cmp     [esp + $bufposend], edi      ; u1
    ja      SHORT loop_top_after_char    ; v1

    jmp     $cleanup


m_is_3:
    mov     ebx, 1 ; == _MP_POS_minus2[3*4]     
    jmp     skipover


m_not_zero:
    cmp     bl, 3              ; u1
    je      SHORT m_is_3       ; v1 

    mov     eax, [esp + $last_offset]         ; u1  eax = t = last[0]
    mov     ecx, [esp + $last_offset + ebx*4] ; v1  ecx = last[m]

    mov     [esp + $last_offset], ecx         ; u1  last[0] = last[m]
    mov     [esp + $last_offset + ebx*4], eax ; v1  last[m] = t 

    mov     ebx, ecx           ; u
    jmp     $L20003            ; too far, won't pair


;
; m = 0, 1, 2, 3
;
m_is_0123:
    test    ebx, ebx           ; u1
    jnz     SHORT m_not_zero   ; v1

; m == 0
    mov     ebx, [esp + $last_offset] ; 
    jmp     $L20003                   ; NP



$L19985:
    mov     ebp, ebx               ; u
    mov     eax, [esp + $context]  ; v

    shr     ebx, 3                 ; u
    and     ebp, 7                 ; v

    cmp     ebp, 7                 ; u
    jne     SHORT $L19987          ; v

    mov     ecx, [esp + $bitbuf]                  ; u

    shr     ecx, 32-SECONDARY_LEN_TREE_TABLE_BITS ; u

    movsx   ebp, WORD PTR [eax + OFF_SECONDARY_TREE_TABLE + ecx*2] ; NP

    test    ebp, ebp                 ; u1
    jnge    secondary_tree_long_code ; v1

back_secondary_tree_long_code:

    mov     cl, BYTE PTR [eax + OFF_SECONDARY_TREE_LEN + ebp] ; u1
    add     ebp, 7                 ; v1

    shl     DWORD PTR [esp + $bitbuf], cl ; NP bitbuf <<= len

; if (bitcount > 0) we're ok, otherwise fill buffer
    sub     dl, cl                 ; u1  bitcount -= len
    jg      SHORT $L19987          ; v1

    xor     eax, eax               ; u1
    mov     cl, dl                 ; v1

; NEG does not pair, so we replace it with XOR CL,-1 ; INC CL
    mov     al, [esi]              ; u1
    xor     cl, -1                 ; v1

    mov     ah, [esi+1]            ; u1
    inc     cl                     ; v1

    shl     eax, cl                ; NP

    or      eax, [esp + $bitbuf]   ; u2
    add     dl, 16                 ; v1

    add     esi, 2                 ; u1
    mov     [esp + $bitbuf], eax   ; v1

$L19987:

; if m == 3 then extra_bits == 0, and shifts don't work
; with a count of zero
    xor     eax, eax               ; u1
    cmp     bl, 3                  ; v1

    mov     al, bl                 ; u1
    jle     SHORT m_is_0123        ; v1

    mov     cl, BYTE PTR local_32_minus_extra_bits [eax] ; u1
    mov     ebx, [esp + $bitbuf]                ; v1

    shr     ebx, cl                             ; NP

    add     ebx, _MP_POS_minus2[eax*4]          ; u2
    mov     cl, _dec_extra_bits [eax]           ; v1

    shl     DWORD PTR [esp + $bitbuf], cl       ; NP

; now we can trash eax (m)
    sub     dl, cl                 ; u1
    jg      SHORT preskipover      ; v1

; otherwise fill buffer

; no need to xor eax, eax since everything but the low order
; byte is already zero
    mov     al, [esi]                            ; u1
    mov     cl, dl                               ; v1

    mov     ah, [esi+1]                          ; u1
    xor     cl, -1                               ; v1

    add     esi, 2                               ; u1
    inc     cl                                   ; v1

    shl     eax, cl                              ; NP

    or      eax, [esp + $bitbuf]                 ; u2
    add     dl, 16                               ; v1

; remember that this can execute twice, if we grab 17 bits
    mov     [esp + $bitbuf], eax                 ; u1
    jg      SHORT preskipover                    ; v1

;
; Second iteration
;
    xor     eax, eax                             ; u1
    mov     cl, dl                               ; v1

    mov     al, [esi]                            ; u1
    xor     cl, -1                               ; v1

    mov     ah, [esi+1]                          ; u1
    inc     cl                                   ; v1

    shl     eax, cl                              ; NP

    or      eax, [esp + $bitbuf]                 ; u2
    add     dl, 16                               ; v1

    mov     [esp + $bitbuf], eax                 ; u1
    add     esi, 2                               ; v1

preskipover:
skipover:
    mov     eax, [esp + $last_offset]     ; u   EAX = R0
    mov     ecx, [esp + $last_offset + 4] ; v   ECX = R1

    mov     [esp + $last_offset + 4], eax            ; u   R1 := R0
    mov     [esp + $last_offset + 8], ecx            ; v   R2 := R1

    mov     [esp + $last_offset], ebx                ; u   R0 := matchpos

$L20003:

;
; eax = dec_mem_window
; ebx = matchpos
; edi = bufpos
; ebp = matchlen (ebp=0 means "ML2", ebp=1 means "ML3", ...)
;

    mov     ecx, edi                  ; u1  ecx = bufpos
    mov     eax, [esp + $context]     ; v1  eax = context ptr

    inc     edi                       ; u1  bufpos++ for first character
    sub     ecx, ebx                  ; v1  ecx := bufpos - matchpos

    and     ecx, [eax + OFF_WINDOW_MASK] ; u1  ecx &= window_mask
    mov     eax, [eax + OFF_MEM_WINDOW]  ; v1  eax = mem_window

    mov     bl, [eax + ecx]              ; u1  AGI  bl = window[src]
    inc     ecx                          ; v1  for next iteration

    mov     [eax + edi - 1], bl          ; u   store in window[dst]
    nop                                  ; v

;
; second and later characters...
;
; eax = mem_window                  edx = bitbuf
; ebx = BL used for character       esi = input_pos
; ecx = bufpos - matchpos
; ebp = matchlen count
; edi = bufpos
;
copy_loop:
    inc     edi                 ; u1
    mov     bl, [eax + ecx]     ; v1   bl = dec_window[(bp-mp)&mask]

    inc     ecx                 ; u1
    dec     ebp                 ; v1

    mov     [eax + edi - 1], bl ; u1   dec_window[bufpos] = bl
    jge     SHORT copy_loop     ; v1

    cmp     [esp + $bufposend], edi ; u1
    ja      loop_top                ; NP


; fall through

$cleanup:
    mov     ebx, DWORD PTR [esp + $context]
    xor     eax, eax

    cmp     edi, [esp + $bufposend]
    je      SHORT successful

    mov     eax, -1 ; failure

successful:
    and     edi, [ebx + OFF_WINDOW_MASK]

    mov     [ebx + OFF_BITCOUNT], dl
    mov     [ebx + OFF_BUFPOS], edi

    mov     [ebx + OFF_INPUT_CURPOS], esi
    mov     edi, [esp + $bitbuf]

; copy repeated offsets into context structure
    mov     ecx, [esp + $last_offset]
    mov     ebp, [esp + $last_offset + 4]

    mov     esi, [esp + $last_offset + 8]
    mov     [ebx + OFF_LAST_MATCHPOS_OFFSET], ecx

    mov     [ebx + OFF_LAST_MATCHPOS_OFFSET+4], ebp
    mov     [ebx + OFF_LAST_MATCHPOS_OFFSET+8], esi

    mov     [ebx + OFF_BITBUF], edi

; restore stack
    add     esp, $stackvars

    pop     ebp
    pop     esi
    pop     edi
    pop     ebx
    pop     ecx
    pop     edx

    ret     0


_fast_decode_verbatim_block ENDP
_TEXT ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decvars.h ===
/*
 * decvars.h
 *
 * Variables for the decoder
 */

/*
 * MAX_MAIN_TREE_ELEMENTS should be >= 256 + 8*num_position_slots
 * (that comes out to 256 + 8*51 right now, for a 2 MB window).
 *
 * Make divisible by 4 so things are longword aligned.
 */
#define MAX_MAIN_TREE_ELEMENTS 672

typedef struct
{
    /* 16-bit version does not have one big window pointer */
#ifndef BIT16
	/* pointer to beginning of window buffer */
	byte        		*dec_mem_window;
#endif

	/* window/decoding buffer parameters */
	ulong               dec_window_size;
	ulong				dec_window_mask;

	/* previous match offsets */
    ulong               dec_last_matchpos_offset[NUM_REPEATED_OFFSETS];

	/* main tree table */
	short				dec_main_tree_table[1 << MAIN_TREE_TABLE_BITS];

	/* secondary length tree table */
	short               dec_secondary_length_tree_table[1 << SECONDARY_LEN_TREE_TABLE_BITS];

	/* main tree bit lengths */
	byte				dec_main_tree_len[MAX_MAIN_TREE_ELEMENTS];

	/* secondary tree bit lengths */
	byte                dec_secondary_length_tree_len[NUM_SECONDARY_LENGTHS];
	byte				pad1[3]; /* NUM_SECONDARY_LENGTHS == 249 */

	/* aligned offset table */
	char				dec_aligned_table[1 << ALIGNED_TABLE_BITS];
	byte				dec_aligned_len[ALIGNED_NUM_ELEMENTS];

	/* left/right pointers for main tree (2*n shorts left, 2*n shorts for right) */
    short               dec_main_tree_left_right[MAX_MAIN_TREE_ELEMENTS*4];

	/* left/right pointers for secondary length tree */
    short               dec_secondary_length_tree_left_right[NUM_SECONDARY_LENGTHS*4];

	/* input (compressed) data pointers */
    byte *              dec_input_curpos;
    byte *              dec_end_input_pos;

    /* output (uncompressed) data pointer */
    byte *              dec_output_buffer;

    /* position in data stream at start of this decode call */
    long                dec_position_at_start;

	/* previous lengths */
	byte				dec_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS];
	byte				dec_secondary_length_tree_prev_len[NUM_SECONDARY_LENGTHS];

	/* bitwise i/o */
	ulong               dec_bitbuf;
	signed char 		dec_bitcount;

	/* number of distinct position (displacement) slots */
	byte                dec_num_position_slots;

	bool				dec_first_time_this_group;
    bool                dec_error_condition;

	/* misc */
	long          		dec_bufpos;
	ulong				dec_current_file_size;
	ulong				dec_instr_pos;
    ulong               dec_num_cfdata_frames;

    /* original size of current block being decoded (in uncompressed bytes) */
    long                dec_original_block_size;

    /* remaining size of current block being decoded (in uncompressed bytes) */
	long				dec_block_size;

	/* type of current block being decoded */
	lzx_block_type		dec_block_type;

	/* current state of decoder */
	decoder_state		dec_decoder_state;

	/* memory allocation functions */
	PFNALLOC			dec_malloc;
	PFNFREE				dec_free;

    /* file i/o functions */
    PFNOPEN             dec_open;
    PFNREAD             dec_read;
    PFNWRITE            dec_write;
    PFNCLOSE            dec_close;
    PFNSEEK             dec_seek;

#ifdef BIT16
    byte *              dec_output_curpos;
    int                 dec_last_chance_page_to_use;
    int                 dec_pos_to_page[NUM_OUTPUT_BUFFER_PAGES];

    /*
     * Variables for big buffer
     */
    struct
    {
        BYTE HUGE *Buf;            /* history buffer: NULL -> using disk ring buffer */
        BYTE HUGE *BufEnd;         /* last byte in history buffer + 1 */
        BYTE HUGE *BufPos;         /* current position in output buffer */

        unsigned long  Cur;        /* current position in the history buffer */
        unsigned short NumBytes;   /* total number of bytes to decompress */
        int       fOutOverflow;    /* if too little space in output buffer */
        BYTE      WindowBits;      /* needed in DComp_Reset() */
        int       fRingFault;      /* if disk callbacks fail */
    } DComp;

    /*
     * Variables for ring buffer
     */
    struct
    {
        int       Handle;             /* ring file handle */
        PBUFFER   RingBuffer;         /* current output ring buffer */
        BYTE FAR *RingPointer;        /* current output pointer (into RingBuffer) */
        BYTE FAR *RingPointerLimit;   /* address of last byte of RingBuffer + 1 */
        int       RingPages;          /* how many pages there are total */
        PBUFFER   pNewest;            /* pointer to most recently used buffer */
        PBUFFER   pOldest;            /* pointer to least recently used buffer */
        PAGETABLEENTRY FAR *PageTable;    /* pointer to array of pointers */
    } Disk;

    void (NEAR *DComp_Token_Match)(void *context, MATCH Match);
    void (NEAR *DComp_Token_Literal)(void *context, int Chr);

#endif

} t_decoder_context;


/* declare arrays? */
#ifndef ALLOC_VARS

EXT const byte NEAR     dec_extra_bits[];
EXT const long NEAR     MP_POS_minus2[];

#else

const byte NEAR dec_extra_bits[] =
{
	0,0,0,0,1,1,2,2,
	3,3,4,4,5,5,6,6,
	7,7,8,8,9,9,10,10,
	11,11,12,12,13,13,14,14,
	15,15,16,16,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17                                        
};

/*
 * first (base) position covered by each slot
 * 2 subtracted for optimisation purposes (see decverb.c/decalign.c comments)
 */
const long NEAR MP_POS_minus2[sizeof(dec_extra_bits)] =   
{
    0-2,        1-2,        2-2,        3-2,        4-2,        6-2,        8-2,        12-2,
	16-2,       24-2,       32-2,       48-2,       64-2,       96-2,       128-2,      192-2,
	256-2,      384-2,      512-2,      768-2,      1024-2,     1536-2,     2048-2,     3072-2,
    4096-2,     6144-2,     8192-2,     12288-2,    16384-2,    24576-2,    32768-2,    49152-2,
	65536-2,    98304-2,    131072-2,   196608-2,   262144-2,   393216-2,   524288-2,   655360-2,
	786432-2,   917504-2,   1048576-2,  1179648-2,  1310720-2,  1441792-2,  1572864-2,  1703936-2, 
	1835008-2,  1966080-2,  2097152-2
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\dectree.c ===
/*
 * dectree.c
 *
 * Decoding the encoded tree structures
 *
 * To save much code size, the fillbuf()/getbits() calls have
 * been made into functions, rather than being inlined macros.
 * The macros actually take up a lot of space.  There is no
 * performance loss from doing so here.
 */
#include "decoder.h"

/* number of elements in pre-tree */
#define NUM_DECODE_SMALL	20

/* lookup table size */
#define DS_TABLE_BITS		8

/* macro to decode a pre-tree element */
#define DECODE_SMALL(item) \
{ \
	item = small_table[context->dec_bitbuf >> (32-DS_TABLE_BITS) ]; \
	if (item < 0)								\
	{											\
      mask = (1L << (32-1-DS_TABLE_BITS));      \
      do										\
      {											\
			item = -item;						\
            if (context->dec_bitbuf & mask)     \
				item = leftright_s[2*item+1];	\
			else								\
				item = leftright_s[2*item];		\
			mask >>= 1;							\
		} while (item < 0);						\
   }											\
   fillbuf(context, small_bitlen[item]);		\
}

/*
 * Reads a compressed tree structure
 */
static bool NEAR ReadRepTree(
	t_decoder_context	*context,
	int					num_elements,
	byte				*lastlen,
	byte				*len
)
{
	ulong	mask;
	int		i;
	int		consecutive;
	byte	small_bitlen[24];
	short	small_table[1 << DS_TABLE_BITS];
	short	leftright_s [2*(2 * 24 - 1)];
	short	Temp;

	/* Declare this inline to help compilers see the optimisation */
	static const byte Modulo17Lookup[] =
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
	};

	/* read pre-tree */
	for (i = 0; i < NUM_DECODE_SMALL; i++)
	{
		small_bitlen[i] = (byte) getbits(context, 4);
	}

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;

	/* make a table for this pre-tree */
	make_table(
		context,
		NUM_DECODE_SMALL, 
		small_bitlen, 
		DS_TABLE_BITS, 
		small_table, 
		leftright_s
	);

	for (i = 0; i < num_elements; i++)
	{
		DECODE_SMALL(Temp);

        /* exceeded input buffer? */
        if (context->dec_error_condition)
            return false;

		/* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1" zeroes */
		if (Temp == 17)
		{
			/* code 17 means "a small number of repeated zeroes" */
			consecutive = (byte) getbits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS);
			consecutive += TREE_ENC_REP_MIN;

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			while (consecutive-- > 0)
				len[i++] = 0;

			i--;
		}
		else if (Temp == 18)
		{
			/* code 18 means "a large number of repeated zeroes" */

			/* Repeat "TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1...<ditto>+(1<<TREE_ENC_REPZ_SECOND_EXTRA_BITS)-1" zeroes */
			consecutive = (byte) getbits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS);
			consecutive += (TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST);

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			while (consecutive-- > 0)
				len[i++] = 0;

			i--;
		}
		else if (Temp == 19)
		{
			byte	value;

			/* code 19 means "a small number of repeated somethings" */
			/* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REP_SAME_EXTRA_BITS)-1" elements */
			consecutive = (byte) getbits(context, TREE_ENC_REP_SAME_EXTRA_BITS);
			consecutive += TREE_ENC_REP_MIN;

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			/* get the element number to repeat */
			DECODE_SMALL(Temp);
			value = Modulo17Lookup[(lastlen[i] - Temp)+17];

			while (consecutive-- > 0)
				len[i++] = value;

			i--;
		}
		else
		{
			len[i] = Modulo17Lookup[(lastlen[i] - Temp)+17];
		}
	}

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;
    else
        return true;
}


bool NEAR read_main_and_secondary_trees(t_decoder_context *context)
{
	/* read first 256 elements (characters) of the main tree */
    if (false == ReadRepTree(
		context,
		256, 
        context->dec_main_tree_prev_len, 
        context->dec_main_tree_len))
    {
        return false;
    }

	/*
	 * read remaining elements (primary match lengths * positions)
	 * of the main tree
	 */
    if (false == ReadRepTree(
		context,
		context->dec_num_position_slots*NUM_LENGTHS, 
        &context->dec_main_tree_prev_len[256], 
        &context->dec_main_tree_len[256]))
    {
        return false;
    }

	/* create lookup table for the main tree */
    if (false == make_table(
		context,
		MAIN_TREE_ELEMENTS, 
        context->dec_main_tree_len, 
		MAIN_TREE_TABLE_BITS,
        context->dec_main_tree_table, 
        context->dec_main_tree_left_right))
    {
        return false;
    }

	/* read secondary length tree */
    if (false == ReadRepTree(
		context,
		NUM_SECONDARY_LENGTHS, 
        context->dec_secondary_length_tree_prev_len, 
        context->dec_secondary_length_tree_len))
    {
        return false;
    }

	/* create lookup table for the secondary length tree */
    if (false == make_table(
		context,
		NUM_SECONDARY_LENGTHS, 
        context->dec_secondary_length_tree_len, 
		SECONDARY_LEN_TREE_TABLE_BITS,
        context->dec_secondary_length_tree_table,
        context->dec_secondary_length_tree_left_right))
    {
        return false;
    }

    return true;
}


/* read 8 element aligned offset tree */
bool NEAR read_aligned_offset_tree(t_decoder_context *context)
{
	int		i;

	/* read bit lengths of the 8 codes */
	for (i = 0; i < 8; i++)
	{
        context->dec_aligned_len[i] = (byte) getbits(context, 3);
	}

    if (context->dec_error_condition)
        return false;

	/*
	 * Make table with no left/right, and byte Table[] instead of
	 * short Table[]
	 */
    if (false == make_table_8bit(
		context,
        context->dec_aligned_len, 
        (byte *) context->dec_aligned_table))
    {
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decxlat.c ===
/*
 * xlat.c
 *
 * Translate
 */
#include "decoder.h"


void NEAR init_decoder_translation(t_decoder_context *context)
{
	context->dec_instr_pos = 0;
}


#ifdef ASM_TRANSLATE_E8
ulong asm_decoder_translate_e8(ulong instr_pos, ulong file_size, byte *mem, long bytes);

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{     
	/*
	 * We don't want the ASM code to have to worry about where in the
	 * context structure a particular element is
	 */
	context->dec_instr_pos = asm_decoder_translate_e8(
		context->dec_instr_pos, 
		context->dec_current_file_size,
		mem, 
		bytes
	);
}

#else /* !ASM_TRANSLATE_E8 */

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
	ulong   end_instr_pos;
	byte    temp[6];
	byte    *mem_backup;

	if (bytes <= 6)
	{
		context->dec_instr_pos += bytes;
		return;
	}

	mem_backup = mem;

	/* backup these bytes */
	memcpy(temp, &mem[bytes-6], 6);

	/* overwrite them with 0xE8 */
	memset(&mem[bytes-6], 0xE8, 6);

	end_instr_pos = context->dec_instr_pos + bytes - 10;

	while (1)
	{
		unsigned long   absolute;
#if !defined(_X86_)
		unsigned long   offset;
#endif

		/*
		 * We are guaranteed to hit one of the 6 0xE8's we stuck at the
		 * end of the buffer, even if we ran into some corrupted data
		 * that resulted in our jumping over 5 bytes due to a translation
		 */
		while (*mem++ != 0xE8)
			context->dec_instr_pos++;

		if (context->dec_instr_pos >= end_instr_pos)
			break;

		/*
		 * There are 5 or more bytes in the buffer
		 * (i.e. E8 xx xx xx xx)
		 *
		 * We have a complete offset available to (potentially) translate
		 */

#if defined(_X86_)
		absolute = *(ulong *) mem;
#else
        absolute =  ( (ulong)mem[0])     | 
					(((ulong)mem[1])<<8) | 
                    (((ulong)mem[2])<<16)|  
					(((ulong)mem[3])<<24);
#endif

		if (absolute < context->dec_current_file_size)
		{
			/* absolute >= 0 && absolute < dec_current_file_size */

#if defined(_X86_)
			*(ulong *) mem = absolute - context->dec_instr_pos;
#else
			offset = absolute - context->dec_instr_pos;
			mem[0] = (byte) (offset & 255);
			mem[1] = (byte) ((offset >> 8) & 255);
			mem[2] = (byte) ((offset >> 16) & 255);
			mem[3] = (byte) ((offset >> 24) & 255);
#endif
		}
        else if ((ulong) (-(long) absolute) <= context->dec_instr_pos)
		{
            /* absolute >= -instr_pos && absolute < 0 */

#if defined(_X86_)
			*(ulong *) mem = absolute + context->dec_current_file_size;
#else
			offset = absolute + context->dec_current_file_size;
			mem[0] = (byte) (offset & 255);
			mem[1] = (byte) (offset >> 8) & 255;
			mem[2] = (byte) (offset >> 16) & 255;
			mem[3] = (byte) (offset >> 24) & 255;
#endif
		}

		mem += 4;
		context->dec_instr_pos += 5;
	}

	context->dec_instr_pos = end_instr_pos + 10;

	/* restore these bytes */
	memcpy(&mem_backup[bytes-6], temp, 6);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decverb.c ===
/*
 * decverb.c
 *
 * Decoding verbatim-bit blocks
 */
#include "decoder.h"


static long special_decode_verbatim_block(
    t_decoder_context   *context,
    long                BufPos,
    int                 amount_to_decode
)
{
	ulong	match_pos;
    long    bufpos_end;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
    byte    *dec_input_curpos;
    byte    *dec_end_input_pos;
	byte	*dec_mem_window;
	char	dec_bitcount;
	char	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    /*
     * We may overflow by up to MAX_MATCH
     */
    while (BufPos < bufpos_end)
	{
		/* decode an item from the main tree */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
	 		/*	it's a character */
			/* note: c - 256 == c if c is a byte */
            context->dec_mem_window[BufPos] = (byte) c;

            /* we know BufPos < bufpos_end here, so no need to check for overflow */
            context->dec_mem_window[context->dec_window_size+BufPos] = (byte) c;
            BufPos++;
		}
		else
		{
	 		/* get match length header */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				/* get match length footer if necessary */
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

			/* get match position slot */
			m = c >> NL_SHIFT;

	  		/* read any extra bits for the match position */
			if (m > 2) 
			{
				if (m > 3) /* dec_extra_bits[m] != 0 */
				{
	    			GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
					match_pos += MP_POS_minus2[m];
				}
				else
				{
                    match_pos = 1; // MP_POS_minus2[3];
				}

				/*
				 * Add match base to "extra bits".  Our match base
				 * table has 2 subtracted from all the elements.
				 *
				 * This is because encoded positions 0,1,2 denote
				 * repeated offsets.  Encoded position 3 denotes
				 * a match 1 character away, 4 encodes 2 away, etc.  
				 * Hence the subtraction of 2, which has been
				 * incorporated into the table.
				 */

				/* update LRU repeated offset list */
				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				/* positions 0, 1, 2 denote repeated offsets */
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			/* match lengths range from 2...257 */
			match_length += MIN_MATCH; 

			/* copy match data */
			do
			{
				context->dec_mem_window[BufPos] = context->dec_mem_window[(BufPos-match_pos) & context->dec_window_mask];

                /* replicate bytes */
                if (BufPos < MAX_MATCH)
                    context->dec_mem_window[context->dec_window_size+BufPos] = context->dec_mem_window[BufPos];

				BufPos++;
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

    return BufPos;
}


#ifdef ASM_DECODE_VERBATIM_BLOCK

long fast_decode_verbatim_block(
    t_decoder_context   *context,
    long                BufPos,
    int                 amount_to_decode
);

#else /* !ASM_DECODE_VERBATIM_BLOCK */

long fast_decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	match_ptr;
	long	bufpos_end;
	long	decode_residue;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	byte	*dec_mem_window;
	char	dec_bitcount;
	char	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = BufPos + amount_to_decode;

	while (BufPos < bufpos_end)
	{
		/* decode an item from the main tree */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
	 		/*	it's a character */
			/* note: c - 256 == c if c is a byte */
			context->dec_mem_window[BufPos++] = (byte) c;
		}
		else
		{
	 		/* get match length header */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				/* get match length footer if necessary */
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

			/* get match position slot */
			m = c >> NL_SHIFT;

	  		/* read any extra bits for the match position */
			if (m > 2) 
			{
				if (m > 3) /* dec_extra_bits[m] != 0 */
				{
	    			GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
					match_pos += MP_POS_minus2[m];
				}
				else
				{
					match_pos = MP_POS_minus2[3];
				}

				/*
				 * Add match base to "extra bits".  Our match base
				 * table has 2 subtracted from all the elements.
				 *
				 * This is because encoded positions 0,1,2 denote
				 * repeated offsets.  Encoded position 3 denotes
				 * a match 1 character away, 4 encodes 2 away, etc.  
				 * Hence the subtraction of 2, which has been
				 * incorporated into the table.
				 */

				/* update LRU repeated offset list */
				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				/* positions 0, 1, 2 denote repeated offsets */
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			/* match lengths range from 2...257 */
			match_length += MIN_MATCH; 
			
            match_ptr = (BufPos - match_pos) & context->dec_window_mask;

			/* copy match data */
			do
			{
                context->dec_mem_window[BufPos++] = context->dec_mem_window[match_ptr++];
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

	/* should be zero */
	decode_residue = BufPos - bufpos_end;

	BufPos &= context->dec_window_mask;
	context->dec_bufpos = BufPos;

	return decode_residue;
}
#endif /* ASM_DECODE_VERBATIM_BLOCK */


int decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
    {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_verbatim_block(
            context,
            BufPos,
            amount_to_slowly_decode
        );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
    }

    return fast_decode_verbatim_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\decuncmp.c ===
/*
 * decuncmp.c
 *
 * Decoding uncompressed blocks
 */
#include "decoder.h"


int decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	long	bytes_decoded = 0;
	long	bufpos_end;
	long	decode_residue;
    ulong   bufpos_start;
    ulong   end_copy_pos;
    byte *  p;

    bufpos_start = bufpos;
	bufpos_end = bufpos + amount_to_decode;

    p = context->dec_input_curpos;

	while (bufpos < bufpos_end)
	{
        if (p >= context->dec_end_input_pos)
            return -1; // input overflow

        context->dec_mem_window[bufpos++] = *p++;
	}

    context->dec_input_curpos = p;

    /*
     * Make sure the MAX_MATCH bytes starting at window[window_size]
     * are always the same as the first MAX_MATCH bytes starting at
     * window[0].  This is for our optimisation in decverb.c and
     * decalign.c which allows us to not have to & window_mask all the
     * time.
     */
    end_copy_pos = min(MAX_MATCH, bufpos_end);

    /*
     * Keep copying until we hit MAX_MATCH or the number of bytes
     * we decoded
     */
    while (bufpos_start < end_copy_pos)
    {
        context->dec_mem_window[bufpos_start + context->dec_window_size] =
            context->dec_mem_window[bufpos_start];
        bufpos_start++;
    }

	decode_residue = bufpos - bufpos_end;

	bufpos &= context->dec_window_mask;
	context->dec_bufpos = bufpos;

    return (int) decode_residue;
}


bool handle_beginning_of_uncompressed_block(t_decoder_context *context)
{
    int     i;

    /*
     * we want to read the 16 bits already in bitbuf, so backtrack
     * the input pointer by 2 bytes.
     */
    context->dec_input_curpos -= 2;

    if (context->dec_input_curpos+4 >= context->dec_end_input_pos)
        return false;

	/*
	 * update LRU repeated offset list
	 */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
    {
        context->dec_last_matchpos_offset[i] =
            ((ulong) *(  (byte *) context->dec_input_curpos)    )        |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 1) << 8)  |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 2) << 16) |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 3) << 24);

        context->dec_input_curpos += 4; /* increment by 4 bytes */
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\maketbl.c ===
/*
 * Table-building routines
 *
 * make_table() is based on ** Public Domain ** source "AR001.ZIP".
 */
#include "decoder.h"


/*
 * Make a decoding table for decoding nchar possible Huffman elements
 * with bit lengths given by bitlen.
 *
 * Output the main lookup table into table[] and use leftright[] for
 * supplementary information (for bitlengths > tablebits).
 *
 * The size of table[] is tablebits elements.
 */
#ifndef ASM_MAKE_TABLE
bool NEAR make_table(
	t_decoder_context	*context,
	int     			nchar,
	const byte			*bitlen,
	byte				tablebits,
	short  				*table,
	short  				*leftright
)
{
    uint    i;
	int		ch;
    short * p;
    uint    count[17], weight[17], start[18];
    int     avail;
    uint    nextcode;
    uint    k;
	byte	len;
	byte	jutbits;

	for (i = 1; i <= 16; i++)
		count[i] = 0;

	/* count the number of elements of each bit length */
    for (i = 0; i < (uint) nchar; i++)
		count[bitlen[i]]++;

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = start[i] + (count[i] << (16 - i));

#ifdef BIT16
    if (start[17])
    {
        return false; /* bad table */
    }
#else
    if (start[17] != 65536)
    {
        if (start[17] == 0)
        {
            /*
             * All elements are length zero
             */
            memset(table, 0, sizeof(ushort)*(1 << tablebits));
            return true; /* success */
        }
        else
        {
            return false; /* bad table */
        }
    }
#endif

	jutbits = 16 - tablebits;

	for (i = 1; i <= tablebits; i++)
	{
		start[i] >>= jutbits;
		weight[i] = 1 << (tablebits - i);
	}

	while (i <= 16)
	{
		weight[i] = 1 << (16 - i);
		i++;
	}
	
	i = start[tablebits+1] >> jutbits;

#ifdef BIT16
    if (i)
#else
	if (i != 65536)
#endif
	{
		memset(
            &table[i],
            0,
            sizeof(ushort)*((1 << tablebits)-i)
        );
	}

	avail = nchar;

	for (ch = 0; ch < nchar; ch++)
	{
		if ((len = bitlen[ch]) == 0)
			continue;

		nextcode = start[len] + weight[len];

		if (len <= tablebits)
		{
            if (nextcode > (uint) (1 << tablebits))
                return false; /* bad table */

			for (i = start[len]; i < nextcode; i++)
				table[i] = (short)ch;

   			start[len] = nextcode;
		}
		else
		{
			byte i;

			k = start[len];
   			start[len] = nextcode;
			p = &table[k >> jutbits];

			i = len - tablebits;
			k <<= tablebits;

			do
			{
				if (*p == 0)
				{
					leftright[avail*2] = leftright[avail*2+1] = 0;
					*p = (short) -avail;
					avail++;
				}

				if ((signed short) k < 0) // if (k & 32768)
					p = &leftright[-(*p)*2+1];
				else
					p = &leftright[-(*p)*2];

				k <<= 1;
				i--;
			} while (i);

			*p = (short)ch;
		}
	}

    return true;
}
#endif


/*
 * Specialised make table routine where it is known that there are
 * only 8 elements (nchar=8) and tablebits=7 (128 byte lookup table).
 *
 * Since there can be no overflow, this will be a direct lookup.
 *
 * Important difference; the lookup table returns a byte, not a ushort.
 */
bool NEAR make_table_8bit(t_decoder_context *context, byte bitlen[], byte table[])
{
	ushort count[17], weight[17], start[18];
	ushort i;
	ushort nextcode;
	byte   len;
	byte   ch;

	for (i = 1; i <= 16; i++)
		count[i] = 0;

	for (i = 0; i < 8; i++)
		count[bitlen[i]]++;

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = start[i] + (count[i] << (16 - i));

	if (start[17] != 0)
        return false; /* bad table */

	for (i = 1; i <= 7; i++)
	{
		start[i] >>= 9;
		weight[i]  = 1 << (7 - i);
	}

	while (i <= 16)
	{
		weight[i] = 1 << (16 - i);
		i++;
	}

	memset(table, 0, 1<<7);

	for (ch = 0; ch < 8; ch++)
	{
		if ((len = bitlen[ch]) == 0)
			continue;

		nextcode = start[len] + weight[len];

		if (nextcode > (1 << 7))
            return false; /* bad table */

		for (i = start[len]; i < nextcode; i++)
			table[i] = ch;

		start[len] = nextcode;
	}

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\ldi.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1996
 *  All Rights Reserved.
 *
 *  LDI.C: LZX Decompression Interface
 *
 *  History:
 *      03-Jul-1996     jforbes     Initial version.
 */

/* --- preprocessor ------------------------------------------------------- */

#include <stdio.h>          /* for NULL */

#include "decoder.h"
#include "decapi.h"

#include "ldi.h"            /* types, prototype verification, error codes */

#define MAX_GROWTH    6144  /* see encoder.h */

typedef ULONG SIGNATURE;    /* structure signature */

struct LDI_CONTEXT          /* private structure */
{
    SIGNATURE   signature;      /* for validation */
    PFNALLOC    pfnAlloc;       /* where the alloc() is */
    PFNFREE     pfnFree;        /* where the free() is */
    PFNOPEN     pfnOpen;        /* open a file callback or NULL */
    PFNREAD     pfnRead;        /* read a file callback */
    PFNWRITE    pfnWrite;       /* write a file callback */
    PFNCLOSE    pfnClose;       /* close a file callback */
    PFNSEEK     pfnSeek;        /* seek in file callback */
    UINT        cbDataBlockMax; /* promised max data size */
    UINT        fCPUtype;       /* CPU we're running on, QDI_CPU_xxx */
	t_decoder_context	*decoder_context;
};

typedef struct LDI_CONTEXT FAR *PMDC_CONTEXT;     /* a pointer to one */


/*  MAKE_SIGNATURE - Construct a structure signature
 *
 *  Entry:
 *      a,b,c,d - four characters
 *
 *  Exit:
 *      Returns constructed SIGNATURE
 *
 *  Example:
 *      strct->signature = MAKE_SIGNATURE('b','e','n','s')
 */

#define MAKE_SIGNATURE(a,b,c,d) (a + (b<<8) + (c<<16) + (d<<24))
#define BAD_SIGNATURE   (0L)
#define LDI_SIGNATURE   MAKE_SIGNATURE('L','D','I','C')

/* --- LDI context structure ---------------------------------------------- */

#define PMDCfromHMD(h) ((PMDC_CONTEXT)(h))          /* handle to pointer */
#define HMDfromPMDC(p) ((LDI_CONTEXT_HANDLE)(p))    /* pointer to handle */

/* --- LDICreateDecompression() ------------------------------------------- */
#include <stdio.h>

int FAR DIAMONDAPI LDICreateDecompression(
        UINT FAR *      pcbDataBlockMax,    /* max uncompressed data block */
        void FAR *      pvConfiguration,    /* implementation-defined */
        PFNALLOC        pfnma,              /* Memory allocation function */
        PFNFREE         pfnmf,              /* Memory free function */
        UINT FAR *      pcbSrcBufferMin,    /* gets required input buffer */
        LDI_CONTEXT_HANDLE FAR * pmdhHandle,  /* gets newly-created handle */
        PFNOPEN         pfnopen,            /* open a file callback */
        PFNREAD         pfnread,            /* read a file callback */
        PFNWRITE        pfnwrite,           /* write a file callback */
        PFNCLOSE        pfnclose,           /* close a file callback */
        PFNSEEK         pfnseek)            /* seek in file callback */
{
    PMDC_CONTEXT context;                   /* new context */
    PFLZXDECOMPRESS pConfig;            /* to get configuration details */

    pConfig = pvConfiguration;       /* get a pointer we can use */

    *pcbSrcBufferMin =                      /* we'll expand sometimes */
            *pcbDataBlockMax + MAX_GROWTH;

    if (pmdhHandle == NULL)                 /* if no context requested, */
    {
        return(MDI_ERROR_NO_ERROR);         /* return from query mode */
    }

    *pmdhHandle = (LDI_CONTEXT_HANDLE) 0;   /* wait until it's valid */

    context = pfnma(sizeof(struct LDI_CONTEXT));

    if (context == NULL)
    {
        return(MDI_ERROR_NOT_ENOUGH_MEMORY);    /* if can't allocate */
    }

	context->decoder_context = pfnma(sizeof(t_decoder_context));

	if (context->decoder_context == NULL)
	{
		pfnmf(context);
		return MDI_ERROR_NOT_ENOUGH_MEMORY;
	}

    context->pfnAlloc = pfnma;              /* remember where alloc() is */
    context->pfnFree = pfnmf;               /* remember where free() is */
    context->pfnOpen = pfnopen;             /* remember where pfnopen() is */
    context->pfnRead = pfnread;             /* remember where pfnread() is */
    context->pfnWrite = pfnwrite;           /* remember where pfnwrite() is */
    context->pfnClose = pfnclose;           /* remember where pfnclose() is */
    context->pfnSeek = pfnseek;             /* remember where pfnseek() is */
    context->cbDataBlockMax = *pcbDataBlockMax;   /* remember agreement */
    context->fCPUtype = (UINT) pConfig->fCPUtype;  /* remember CPU type */
    context->signature = LDI_SIGNATURE;     /* install signature */

	if (LZX_DecodeInit(
			context->decoder_context,
			pConfig->WindowSize, 
			pfnma,
            pfnmf,
            pfnopen,
            pfnread,
            pfnwrite,
            pfnclose,
            pfnseek) == false)
	{
		pfnmf(context);
		return (MDI_ERROR_NOT_ENOUGH_MEMORY);
	}

    /* pass context back to caller */
    *pmdhHandle = HMDfromPMDC(context);

    return(MDI_ERROR_NO_ERROR);             /* tell caller all is well */
}


/* --- LDIDecompress() ---------------------------------------------------- */
int FAR DIAMONDAPI LDIDecompress(
        LDI_CONTEXT_HANDLE  hmd,            /* decompression context */
        void FAR *          pbSrc,          /* source buffer */
        UINT                cbSrc,          /* source actual size */
        void FAR *          pbDst,          /* target buffer */
        UINT FAR *          pcbResult)      /* gets actual target size */
{
    PMDC_CONTEXT	context;                   /* pointer to the context */
    int				result;                             /* return code */
	long			bytes_to_decode;
	long			total_bytes_written = 0;

    context = PMDCfromHMD(hmd);             /* get pointer from handle */

    if (context->signature != LDI_SIGNATURE)
    {
        return(MDI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

    if (*pcbResult > context->cbDataBlockMax)
    {
		return(MDI_ERROR_BUFFER_OVERFLOW);  /* violated max block promise */
    }

#if 0
	if (cbSrc == 0)
		return MDI_ERROR_NO_ERROR;
#endif

	bytes_to_decode = (long) *pcbResult;

	result = LZX_Decode(
		context->decoder_context,
		bytes_to_decode, 
		pbSrc,
		cbSrc,
		pbDst,
		bytes_to_decode,
		&total_bytes_written
	);

    *pcbResult = (UINT) total_bytes_written;

	if (result)
		return MDI_ERROR_FAILED;
	else
		return MDI_ERROR_NO_ERROR;
}

/* --- LDIResetDecompression() -------------------------------------------- */

int FAR DIAMONDAPI LDIResetDecompression(LDI_CONTEXT_HANDLE hmd)
{
    PMDC_CONTEXT context;                   /* pointer to the context */

    context = PMDCfromHMD(hmd);             /* get pointer from handle */

    if (context->signature != LDI_SIGNATURE)
    {
        return(MDI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	LZX_DecodeNewGroup(context->decoder_context);

    return(MDI_ERROR_NO_ERROR);             /* if tag is OK */
}

/* --- LDIDestroyDecompression() ------------------------------------------ */

int FAR DIAMONDAPI LDIDestroyDecompression(LDI_CONTEXT_HANDLE hmd)
{
    PMDC_CONTEXT context;                   /* pointer to the context */

    context = PMDCfromHMD(hmd);             /* get pointer from handle */

    if (context->signature != LDI_SIGNATURE)
    {
        return(MDI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	LZX_DecodeFree(context->decoder_context);

    context->signature = BAD_SIGNATURE;     /* destroy signature */

	context->pfnFree(context->decoder_context);
    context->pfnFree(context);              /* self-destruct */

    return(MDI_ERROR_NO_ERROR);             /* success */
}

/* --- LDIGetWindow() ---------------------------------------------------- */
#ifndef BIT16
int FAR DIAMONDAPI LDIGetWindow(
        LDI_CONTEXT_HANDLE  hmd,            /* decompression context */
        BYTE FAR **         ppWindow,       /* pointer to window start */
        long *              pFileOffset,    /* offset in folder */
        long *              pWindowOffset,  /* offset in window */
        long *              pcbBytesAvail)   /* bytes avail from window start */
{
    PMDC_CONTEXT context;                   
    t_decoder_context *dec_context;

    context = PMDCfromHMD(hmd);             /* get pointer from handle */
    dec_context = context->decoder_context;

    *ppWindow = dec_context->dec_mem_window;

    // window is a circular buffer

    if ((ulong) dec_context->dec_position_at_start < dec_context->dec_window_size)
    {
        *pWindowOffset = 0; 
        *pFileOffset = 0;
        *pcbBytesAvail = dec_context->dec_position_at_start;
    }
    else
    {
        *pWindowOffset = dec_context->dec_position_at_start & (dec_context->dec_window_size - 1);
        *pcbBytesAvail = dec_context->dec_window_size;
        *pFileOffset = dec_context->dec_position_at_start - dec_context->dec_window_size;
    }

    return MDI_ERROR_NO_ERROR;
}
#endif

/* ------------------------------------------------------------------------ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\offsets.c ===
/*
 * Used by makefile to generate OFFSETS.I for ASM source files.
 *
 * Also creates some constants for tables.
 *
 * Outputs offsets into the context structure.
 */
#include "decoder.h"
#include <stdio.h>

t_decoder_context p;

void main(void)
{
    printf("MAIN_TREE_TABLE_BITS        EQU %d\n", MAIN_TREE_TABLE_BITS);
    printf("MAIN_TREE_TABLE_ELEMENTS    EQU %d\n", 1 << MAIN_TREE_TABLE_BITS);
    printf("SECONDARY_LEN_TREE_TABLE_BITS       EQU %d\n", SECONDARY_LEN_TREE_TABLE_BITS);
    printf("SECONDARY_TREE_TABLE_ELEMENTS       EQU %d\n", 1 << SECONDARY_LEN_TREE_TABLE_BITS);
    printf("NUM_SECONDARY_LENGTHS               EQU %d\n", NUM_SECONDARY_LENGTHS);
    printf("ALIGNED_TABLE_ELEMENTS              EQU %d\n", 1 << ALIGNED_TABLE_BITS);
    printf("ALIGNED_NUM_ELEMENTS                EQU %d\n", ALIGNED_NUM_ELEMENTS);

    printf("OFF_MEM_WINDOW              EQU %d\n", (byte *) &p.dec_mem_window - (byte *) &p);
    printf("OFF_WINDOW_SIZE             EQU %d\n", (byte *) &p.dec_window_size - (byte *) &p);
    printf("OFF_WINDOW_MASK             EQU %d\n", (byte *) &p.dec_window_mask - (byte *) &p);
    printf("OFF_LAST_MATCHPOS_OFFSET    EQU %d\n", (byte *) &p.dec_last_matchpos_offset[0] - (byte *) &p);
    printf("OFF_MAIN_TREE_TABLE         EQU %d\n", (byte *) &p.dec_main_tree_table[0] - (byte *) &p);
    printf("OFF_SECONDARY_TREE_TABLE    EQU %d\n", (byte *) &p.dec_secondary_length_tree_table[0] - (byte *) &p);
    printf("OFF_MAIN_TREE_LEN           EQU %d\n", (byte *) &p.dec_main_tree_len[0] - (byte *) &p);
    printf("OFF_SECONDARY_TREE_LEN      EQU %d\n", (byte *) &p.dec_secondary_length_tree_len[0] - (byte *) &p);
    printf("OFF_ALIGNED_TABLE           EQU %d\n", (byte *) &p.dec_aligned_table[0] - (byte *) &p);
    printf("OFF_ALIGNED_LEN             EQU %d\n", (byte *) &p.dec_aligned_len[0] - (byte *) &p);
    printf("OFF_MAIN_TREE_LEFTRIGHT     EQU %d\n", (byte *) &p.dec_main_tree_left_right[0] - (byte *) &p);
    printf("OFF_SECONDARY_TREE_LEFTRIGHT EQU %d\n", (byte *) &p.dec_secondary_length_tree_left_right[0] - (byte *) &p);
    printf("OFF_INPUT_CURPOS            EQU %d\n", (byte *) &p.dec_input_curpos - (byte *) &p);
    printf("OFF_INPUT_ENDPOS            EQU %d\n", (byte *) &p.dec_end_input_pos - (byte *) &p);
    printf("OFF_MAIN_TREE_PREV_LEN      EQU %d\n", (byte *) &p.dec_main_tree_prev_len[0] - (byte *) &p);
    printf("OFF_SECONDARY_TREE_PREV_LEN EQU %d\n", (byte *) &p.dec_secondary_length_tree_prev_len[0] - (byte *) &p);
    printf("OFF_BITBUF                  EQU %d\n", (byte *) &p.dec_bitbuf - (byte *) &p);
    printf("OFF_BITCOUNT                EQU %d\n", (byte *) &p.dec_bitcount - (byte *) &p);
    printf("OFF_NUM_POSITION_SLOTS      EQU %d\n", (byte *) &p.dec_num_position_slots - (byte *) &p);
    printf("OFF_BUFPOS                  EQU %d\n", (byte *) &p.dec_bufpos - (byte *) &p);

	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\ring16.h ===
/*
 * ring16.h
 */

/* ring buffer configuration */

#define     BUFFER_SIZE     (512)  /* must be 2^Nth */
#define     MIN_BUFFERS     3       /* minimum number we want */

#define     NUM_OUTPUT_BUFFER_PAGES    (CHUNK_SIZE/BUFFER_SIZE)

typedef struct aBuffer
{
  struct aBuffer FAR *pLinkNewer;   /* link to more recently used */
  struct aBuffer FAR *pLinkOlder;   /* link to less recently used */
  int BufferPage;                   /* what page this is, -1 -> invalid */
  int BufferDirty;                  /* NZ -> needs to be written */
  BYTE Buffer[BUFFER_SIZE];         /* content */
} BUFFER, FAR *PBUFFER;

typedef struct
{
  PBUFFER   pBuffer;            /* pointer to buffer, NULL if not present */
  int       last_chance_ptr;    /* index to last chance buffer table, or -1 */
  int       fDiskValid;         /* NZ -> this page has been written to disk */
} PAGETABLEENTRY;

typedef struct
{
    short Len;
    long  Dist;
} MATCH;

typedef struct
{
    char wildName[2];
    unsigned long fileSize;
} RINGNAME, FAR *PRINGNAME;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\blkinit.c ===
/*
 * blkinit.c
 *
 * Block outputting initialisation
 */

#include "encoder.h"


/*
 * Create lookup table for MP_SLOT() macro
 */
void create_slot_lookup_table(t_encoder_context *context)
{
   int			j;
   int 			p;
   int 			elements_to_init;
   byte   		slotnum;

   context->enc_slot_table[0] = 0;
   context->enc_slot_table[1] = 1;
   context->enc_slot_table[2] = 2;
   context->enc_slot_table[3] = 3;

   elements_to_init = 2;

   slotnum = 4;
   p       = 4;

   do
   {
      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;

      for (j = elements_to_init; j > 0; j--)
         context->enc_slot_table[p++] = slotnum;

      slotnum++;
      elements_to_init <<= 1;

   } while (p < 1024);
}


/*
 * Create lookup table for figuring out how many
 * ones there are in a given byte.
 */
void create_ones_table(t_encoder_context *context)
{
	int			i, j;
	byte		ones;

	for (i = 0; i < 256; i++)
	{
		ones = 0;

		for (j = i; j; j >>= 1)
		{
			if (j & 1)
				ones++;
		}

		context->enc_ones[i] = ones;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\tableasm.asm ===
;
; tableasm.asm
;
; Assembly version of make_table()
;
; jforbes   07/20/96
;
; Note, this is not optimised for the Pentium at all; very few
; instructions will execute two at a time.
;
   TITLE TABLEASM.ASM
	.386P
.model FLAT

PUBLIC  _make_table

;  COMDAT @_make_table
_TEXT   SEGMENT
$start      = 0
$weight     = $start + 72
$count      = $weight + 72
$nchar      = $count + 72
$bitlen     = $nchar + 4
$ch         = $bitlen + 4
$leftright  = $ch + 4
$avail      = $leftright + 4
$k          = $avail + 4
$table      = $k + 4
$tablebits  = $table + 4
$jutbits    = $tablebits + 4
$context    = $jutbits + 4
$last       = $context + 4
_make_table PROC NEAR             ; COMDAT


;
;void make_table(
;   t_decoder_context *context,
;   USHORT  nchar,
;   UBYTE  *bitlen,
;   USHORT  tablebits,
;   short  *table,
;   short  *leftright)

; count   [esp+72+68]
; weight  [esp+72]
; start   [esp]

; 6 regs * 4 = 24 bytes
   push  ebx
   push  ecx
   push  edx
   push  ebp
   push  esi
   push  edi

   sub   esp, $last


; how to access the parameters off the stack
; skip over 24 bytes of pushed registers, and $last local
; variables, and the 4 byte return address.
$parms = $last+28

   mov   eax, [esp + $parms + 4]
   and   eax, 65535
   mov   [esp + $nchar], eax

   mov   eax, [esp + $parms]
   mov   [esp + $context], eax

   mov   eax, [esp + $parms + 8]
   mov   [esp + $bitlen], eax

   mov   eax, [esp + $parms + 12]
   and   eax, 255
   mov   [esp + $tablebits], eax

   mov   eax, [esp + $parms + 16]
   mov   [esp + $table], eax

   mov   eax, [esp + $parms + 20]
   mov   [esp + $leftright], eax


;   for (i = 1; i <= 16; i++)
;      count[i] = 0;

; clear 64 bytes starting at &count[1]
   xor   eax, eax
   lea   edi, [esp + $count + 4]
   mov   ecx, 16
   rep   stosd


;   for (i = 0; i < nchar; i++)
;      count[bitlen[i]]++;

; Do it in reverse
   mov   ecx, [esp + $nchar]              ; u
   mov   esi, [esp + $bitlen]             ; v

   xor   ebx, ebx                         ; u
   dec   ecx                              ; v  ecx = i

loop1:
   mov   bl, [esi + ecx]                  ; bl = bitlen[i]
   inc   DWORD PTR [esp + $count + ebx*4] ; NP

   dec   ecx                              ; u
   jge   SHORT loop1                      ; v




;   start[1] = 0;
;
;   for (i = 1; i <= 16; i++)
;      start[i + 1] = start[i] + (count[i] << (16 - i));
;
   lea   ebp, [esp + $start + 4] ; u
   lea   esi, [esp + $count + 4] ; v

   xor   edx, edx                ; u  edx = start[i]
   mov   ecx, 15                 ; v  ecx = 16 - i

   mov   [ebp], edx              ; u  start[1] = 0
   nop                           ; v

loop2:
   mov   eax, [esi]              ; u  eax = count[i]
   add   ebp, 4                  ; v

   shl   eax, cl                 ; u
   add   esi, 4                  ; v
                                      
   add   eax, edx                ; u  edx = start[i]
; stall

   mov   [ebp], eax              ; u  start[i+1]
   mov   edx, eax                ; v  edx <- start[i+1]

   dec   ecx                     ; u
   jge   SHORT loop2             ; v


;   if (start[17] != 65536)
   mov   edx, [esp + 68 + $start]
   cmp   edx, 65536
   jne   not_65536



;   jutbits = 16 - tablebits;
;
;   for (i = 1; i <= tablebits; i++)
;   {
;      start[i] >>= jutbits;
;      weight[i] = 1 << (tablebits - i);
;   }

   mov   edx, [esp + $tablebits] ; u  edx = tablebits
   mov   eax, 1                  ; v  eax = i

   lea   ecx, [edx - 1]          ; u  ecx = tablebits - i(=1)
   mov   ebp, eax                ; v  ebp = 1

   shl   ebp, cl                 ; u  ebp = 1 << (tablebits - i)
   mov   ebx, ecx                ; v  ebx = tablebits - i(=1)

   mov   cl, 16                  ; upper bits of ecx are zero
   sub   ecx, edx                ; ecx = jutbits = 16 - tablebits
   mov   [esp + $jutbits], ecx

loop3:
   shr   DWORD PTR [esp + $start + eax*4], cl    ; u  start[i] >>= jutbits
   mov   DWORD PTR [esp + $weight + eax*4], ebp  ; v

   shr   ebp, 1         ; u
   inc   eax            ; v  i++

   cmp   eax, edx       ; u
   jle   SHORT loop3    ; v



;   while (i <= 16)
;   {
;      weight[i] = 1 << (16 - i);
;      i++;
;   }

   cmp   al, 16            ; u
   jg    SHORT exit_loop4  ; v

loop4:
   mov   ecx, 16           ; u
   mov   ebx, 1            ; v

   sub   ecx, eax          ; u   ecx = 16 - i
   inc   eax               ; v   WAR ok

   shl   ebx, cl           ; u  ebx = 1 << (16 - i)
   mov   DWORD PTR [esp + $weight + eax*4 - 4], ebx ; v

   cmp   al, 16            ; u
   jle   SHORT loop4       ; v

exit_loop4:



; i = start[tablebits+1] >> jutbits

; ecx = jutbits
   mov   ecx, [esp + $jutbits]

; edx = tablebits
   mov   edx, [esp + $tablebits]

; eax = start[tablebits+1]
   mov   eax, [esp + $start + 4 + edx*4]

; eax = start[tablebits+1] >> jutbits
   shr   eax, cl

; if (i != 65536)
   cmp   eax, 65536
   je    SHORT i_is_zero


;
;   memset(&table[i], 0, sizeof(ushort)*((1 << tablebits)-i);
;

; ecx = tablebits
   mov  ecx, edx

; edx = 1 << tablebits
   mov  edx, 1
   shl  edx, cl

; edx = (1 << tablebits) - i
   sub  edx, eax

; count = (1 << tablebits) - i words
   mov  ecx, edx

; dest = edi = &table[i]
   mov  edi, [esp + $table]
   lea  edi, [edi + eax*2]

; value = 0
   xor  eax, eax

   rep  stosw


i_is_zero:

;
;   avail = nchar;
;
   mov   eax, [esp + $nchar]          ; u
   xor   edi, edi                     ; v  edi = ch


;
;   for (ch = 0; ch < nchar; ch++)
;

   mov   [esp + $avail], eax          ; u
   jmp   SHORT main_loop              ; v


; for short jump
bad_table2:
   xor   eax, eax ; return failure
   jmp   cleanup


main_loop:

;      if ((len = bitlen[ch]) == 0)
;         continue;

; eax = &bitlen[0]
   mov   eax, [esp + $bitlen]

; ebp = len = bitlen[ch]
   movzx ebp, BYTE PTR [eax + edi] 

; if (len == 0)
;    continue
   test  ebp, ebp                   
   jz    loop_bottom                 


;      nextcode = start[len] + weight[len];

; ebx = start[len]
   mov   ebx, [esp + $start + ebp*4]  ; u
   mov   ecx, [esp + $tablebits]      ; v  ecx = tablebits

; ebx = nextcode = start[len] + weight[len]
   mov   eax, ebx                     ; u  eax = start[len]
   add   ebx, [esp + $weight + ebp*4] ; v  WAR ok

;      if (len <= tablebits)
   cmp   ebp, ecx                  ; u
   jg    SHORT len_g_tablebits     ; v

;         if (nextcode > (1 << tablebits))
;            bad_table();

; edx = 1 << tablebits
   mov   edx, 1

   shl   edx, cl   ; u
   mov   ecx, ebx  ; v  ecx = nextcode

; if (nextcode > (1 << tablebits))
   cmp   ebx, edx         ; u
   jg    SHORT bad_table2 ; v


;         for (i = start[len]; i < nextcode; i++)
;            table[i] = ch;


; ecx = nextcode - start[len]
    sub  ecx, eax         ; u
    add  eax, eax         ; v  WAR ok

; eax = &table[ start[len] ]
    add  eax, [esp + $table]            ; u

; start[len] = nextcode (moved up)
    mov  [esp + $start + ebp*4], ebx    ; v


; For this loop:
;  eax = &table[ start[len] ]
;  edi = ch
;  ecx = nextcode - start[len]
;
loop6:
   mov   WORD PTR [eax], di     ; table[i] = ch
   add   eax, 2                 ; i++

   dec   ecx
   jnz   SHORT loop6


; ch++
   inc   edi ; moved up

; loop bottom
   cmp   edi, [esp + $nchar]
   jl    SHORT main_loop

   mov   eax, 1 ; success
   jmp   cleanup


;
; len > tablebits
;
; on entry: eax = start[len]
;           ebx = nextcode
;           ecx = tablebits
;           ebp = len
;
len_g_tablebits:

   mov   esi, ebp        ; u  esi = len
   mov   edx, eax        ; v  edx = start[len]

   sub   esi, ecx        ; u  esi = len - tablebits
   add   cl, 16          ; v

; edx = k << tablebits
; shift left another 16 because we want to use a DWORD
; for testing the negative bit
   shl   edx, cl         ; u
   mov   [esp + $k], eax ; v

; start[len] = nextcode;
   mov   [esp + $start + ebp*4], ebx ; u
   nop                               ; v

; p = &table[k >> jutbits];
   mov   ecx, [esp + $jutbits]   ; u  ecx = jutbits
   mov   ebx, [esp + $k]         ; v  ebx = k >> jutbits

   shr   ebx, cl                 ; u
   mov   eax, [esp + $table]     ; v

   lea   ebx, [eax + ebx*2]      ; u  ebx = p = &table[k >> jutbits]
   mov   ebp, [esp + $avail]     ; v  ebp = avail

bottom_loop:

; if (*p == 0)

; eax = &leftright[0]
   mov   eax, [esp + $leftright]

; ecx = *p
   movsx ecx, WORD PTR [ebx]     ; NP

; *p == 0 ?
   test  ecx, ecx                ; u
   jne   SHORT p_not_zero        ; v

;  left_right[avail*2] = left_right[avail*2+1] = 0;
;  *p = -avail;
;  avail++;

   mov   WORD PTR [ebx], bp      ; *p = avail

; sets left and right to zero (remember that ecx == 0)
   mov   [eax + ebp*4], ecx      ; u
   inc   ebp                     ; v  avail++

;  *p = -avail
   neg   WORD PTR [ebx]


p_not_zero:

;  if ((signed short) k < 0)
;     p = &right[-(*p)];
;  else
;     p = &left[-(*p)];

; ecx = -(*p)
   movsx ecx, WORD PTR [ebx]
   neg   ecx

; ebx = p = &ptr[-(*p)]
   lea   ebx, [ecx*4 + eax]

; if (k becomes -ve when we shift out a bit)
   add   edx, edx
   jnc   SHORT go_left

; right
   add   ebx, 2

go_left:

   dec   esi  ; i--
   jnz   SHORT bottom_loop


;  *p = ch;
   mov   WORD PTR [ebx], di


; store avail
   mov   [esp + $avail], ebp



loop_bottom:

; ch++
   inc   edi

   cmp   edi, [esp + $nchar]
   jl    main_loop

   mov   eax, 1 ; success


cleanup:
   add   esp, $last

   pop   edi
   pop   esi
   pop   ebp
   pop   edx
   pop   ecx
   pop   ebx

   ret   0


not_65536:
   test  edx, edx
   jnz   SHORT bad_table

; memset(table, 0, sizeof(ushort)*(1<<tablebits))
   xor   eax, eax
   mov   edi, [esp + $table]

   mov   edx, 1
   mov   ecx, [esp + $tablebits]
   dec   ecx        ; subtract 1 because we're doing STOSD

   shl   edx, cl    ; edx := 1 << tablebits
   
   mov   ecx, edx   ; store in ecx

   rep   stosd

   mov   eax, 1     ; success
   jmp   SHORT cleanup



bad_table:
   xor   eax, eax ; failure
   jmp   cleanup

_make_table ENDP
_TEXT   ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\ring16.c ===
/*
 *  RING16.C: Ring buffer code
 *
 *  History:
 *      30-Oct-1996     jforbes     Cloned from QUANTUM\DECOMP.C
 */

#include <stdio.h>          /* for NULL */
#include <stdlib.h>         /* for disk ring buffer code (SEEK_SET) */
#include <fcntl.h>          /* for disk ring buffer code (_O_*) */
#include <sys\stat.h>       /* for disk ring buffer code (_S_I*) */
#include <io.h>
#include "decoder.h"


/* --- local function prototypes ------------------------------------------ */

static void NEAR    DComp_Internal_Literal(t_decoder_context *context, int Chr );
static void NEAR    DComp_Internal_Match(t_decoder_context *context, MATCH Match );

static void NEAR    DComp_Ring_Close(t_decoder_context *context);
static int NEAR     DComp_Ring_Init(t_decoder_context *context);
static void NEAR    DComp_Ring_Literal(t_decoder_context *context, int Chr );
static BYTE * NEAR  DComp_Ring_Load(t_decoder_context *context, int page,int fWrite);
static void NEAR    DComp_Ring_Match(t_decoder_context *context, MATCH Match );
static void NEAR    DComp_Ring_Reset(t_decoder_context *context);


#define Disk context->Disk

#define DComp context->DComp


/* --- DComp_Close() ------------------------------------------------------ */
void NEAR DComp_Close(t_decoder_context *context)
{
    if (DComp.Buf == NULL)
    {
        DComp_Ring_Close(context);     /* if using a disk-based ring buffer */
    }
    else
    {
        context->dec_free( DComp.Buf );  /* if using memory-based ring buffer */
    }
}


/* --- DComp_Init() ------------------------------------------------------- */
int NEAR DComp_Init(t_decoder_context *context)
{
    DComp.Cur = 0;
    DComp.fRingFault = 0;

    if( (DComp.Buf = context->dec_malloc( context->dec_window_size )) != NULL )
    {
        DComp.BufPos = DComp.Buf;
        DComp.BufEnd = DComp.Buf + context->dec_window_size;

        context->DComp_Token_Match = DComp_Internal_Match;     /* use internal buffering */
        context->DComp_Token_Literal = DComp_Internal_Literal;
    }
    else if (DComp_Ring_Init(context))                     /* try disk ring buffer */
    {
        context->DComp_Token_Match = DComp_Ring_Match;         /* use disk buffering */
        context->DComp_Token_Literal = DComp_Ring_Literal;
    }
    else
    {
        return (1);                              /* if can't create ring buffer */
    }

    return(0);
}

/* --- DComp_Internal_Literal() ------------------------------------------- */

static void NEAR DComp_Internal_Literal(t_decoder_context *context, int Chr)
{
    if (DComp.NumBytes)
    {
        DComp.NumBytes--;
        DComp.Cur++;

        *context->dec_output_curpos++ = *DComp.BufPos++ = (BYTE) Chr;

        if (DComp.BufPos == DComp.BufEnd)
            DComp.BufPos = DComp.Buf;
    }
}


/* --- DComp_Internal_Match() --------------------------------------------- */

static void NEAR DComp_Internal_Match(t_decoder_context *context, MATCH Match)
{
    BYTE HUGE *SrcPtr;

    if (DComp.NumBytes >= (unsigned) Match.Len)
    {
        SrcPtr = DComp.Buf +
            ((DComp.Cur - Match.Dist) & context->dec_window_mask);

        DComp.NumBytes -= Match.Len;
        DComp.Cur += Match.Len;

        while (Match.Len--)
        {
            *context->dec_output_curpos++ = *DComp.BufPos++ = *SrcPtr++;

            if (SrcPtr == DComp.BufEnd)
                SrcPtr = DComp.Buf;

            if (DComp.BufPos == DComp.BufEnd)
                DComp.BufPos = DComp.Buf;
        }
    }
    else  /* match too large to fit */
    {
        DComp.NumBytes = 0;
        DComp.fOutOverflow = 1;
    }
}

/* --- DComp_Reset() ------------------------------------------------------ */

void NEAR DComp_Reset(t_decoder_context *context)
{
    DComp.Cur = 0;
    DComp.fRingFault = 0;

    if (DComp.Buf != NULL)
        DComp.BufPos = DComp.Buf;   /* big buffer */
    else
        DComp_Ring_Reset(context);  /* ring buffer */
}

/* --- DComp_Ring_Close() ------------------------------------------------- */

static void NEAR DComp_Ring_Close(t_decoder_context *context)
{
    PBUFFER pBuffer, pNext;                   /* buffer walk pointer */

    context->dec_free(Disk.PageTable);                 /* discard page table */

    pBuffer = Disk.pNewest;

    while (pBuffer != NULL)                   /* discard buffer chain */
    {
        pNext = pBuffer->pLinkOlder;
        context->dec_free(pBuffer);
        pBuffer = pNext;
    }

    context->dec_close(Disk.Handle);       /* close that file (and delete) */
}


/* --- DComp_Ring_Init() -------------------------------------------------- */

static int NEAR DComp_Ring_Init(t_decoder_context *context)
{
    RINGNAME ringName;
    PBUFFER pBuffer;
    int cBuffers;

    ringName.wildName[0] = '*';
    ringName.wildName[1] = '\0';  
    ringName.fileSize = context->dec_window_size;

    Disk.Handle = context->dec_open(
        (char FAR *) &ringName,
        (_O_BINARY|_O_RDWR|_O_CREAT),
        (_S_IREAD|_S_IWRITE)
    );

    if (Disk.Handle == -1)
    {
        return(0);                              /* failed, can't make disk file */
    }

    Disk.RingPages = (int) (context->dec_window_size / BUFFER_SIZE);

    if (Disk.RingPages < MIN_BUFFERS)
    {
        Disk.RingPages = MIN_BUFFERS;  /* if DComp.WindowSize < BUFFER_SIZE */
    }

    Disk.PageTable = context->dec_malloc(sizeof(PAGETABLEENTRY) * Disk.RingPages);

    if (Disk.PageTable == NULL)
    {
        context->dec_close(Disk.Handle);     /* close the file */

        return(0);                              /* failed, can't get page table */
    }

    Disk.pNewest = NULL;

    /* DComp_Ring_Close() can be used to abort from this point on */

    for (cBuffers = 0; cBuffers < Disk.RingPages; cBuffers++)
    {
        pBuffer = context->dec_malloc(sizeof(BUFFER));

        if (pBuffer != NULL)
        {
            pBuffer->pLinkNewer = NULL;           /* none are newer */
            pBuffer->pLinkOlder = Disk.pNewest;   /* all the others older now */

            if (Disk.pNewest != NULL)
            {
                Disk.pNewest->pLinkNewer = pBuffer; /* old guy now knows about new */
            }
            else      /* if nobody else */
            {
                Disk.pOldest = pBuffer;             /* guess I'm the oldest too */
            }

            Disk.pNewest = pBuffer;               /* I'm the newest */
        } 
        else    /* if pBuffer == NULL */
        {
            if (cBuffers < MIN_BUFFERS)           /* less than minimum? */
            {
                DComp_Ring_Close(context);                 /* give it up */

                return(0);                          /* failed, can't get min buffers */
            }
            else  /* if we got the minimum */
            {
                break;                              /* got enough, quit trying */
            }
        }
    }

//    printf("Got %d of %d ring pages\n",cBuffers,Disk.RingPages);

    return(1);                                /* ring buffer created */
}


/* --- DComp_Ring_Literal() ----------------------------------------------- */
static void NEAR DComp_Ring_Literal(t_decoder_context *context, int Chr)
{
    if (DComp.NumBytes)
    {
        DComp.NumBytes--;
        DComp.Cur++;

        *context->dec_output_curpos++ = (BYTE) Chr;
    }
}


/*
 * Insert output buffer contents into the page table
 */
static void NEAR save_page(
    t_decoder_context * context,
    int                 page,
    byte *              data
)
{
    PBUFFER pBuffer;
    long    iPagefileOffset;

    pBuffer = Disk.PageTable[page].pBuffer;   /* look up this page */

    if (pBuffer != NULL)                      /* if it's in the table */
    {
        if (pBuffer != Disk.pNewest)            /* promote if not newest */
        {
            pBuffer->pLinkNewer->pLinkOlder = pBuffer->pLinkOlder;

            if (pBuffer->pLinkOlder != NULL)      /* if there is someone older */
            {
                pBuffer->pLinkOlder->pLinkNewer = pBuffer->pLinkNewer;
            }
            else
            {
                Disk.pOldest = pBuffer->pLinkNewer;
            }        

            /* link into head of chain */

            Disk.pNewest->pLinkNewer = pBuffer;   /* newest now knows one newer */
            pBuffer->pLinkNewer = NULL;           /* nobody's newer */
            pBuffer->pLinkOlder = Disk.pNewest;   /* everybody's older */
            Disk.pNewest = pBuffer;               /* I'm the newest */
        }

        memcpy(
            pBuffer->Buffer,
            data,
            BUFFER_SIZE
        );

        pBuffer->BufferDirty = 1;         /* might already be dirty */
        return;
    }

    pBuffer = Disk.pOldest;                   /* choose the oldest buffer */

    if (pBuffer->BufferPage != -1)            /* take it out of page table */
    {
        Disk.PageTable[pBuffer->BufferPage].pBuffer = NULL;  /* not here now */

        if (pBuffer->BufferDirty)                 /* write on eject, if dirty */
        {
            iPagefileOffset = (long) pBuffer->BufferPage * BUFFER_SIZE;

            if (context->dec_seek(Disk.Handle,iPagefileOffset,SEEK_SET) !=
                iPagefileOffset)
            {
                return;
            }

            if (context->dec_write(Disk.Handle,pBuffer->Buffer,BUFFER_SIZE) !=
                BUFFER_SIZE)
            {
                return;
            }

            Disk.PageTable[pBuffer->BufferPage].fDiskValid = 1;
        }
    }

    Disk.pOldest = Disk.pOldest->pLinkNewer;  /* newer is now oldest */
    Disk.pOldest->pLinkOlder = NULL;          /* oldest knows none older */

    Disk.pNewest->pLinkNewer = pBuffer;
    pBuffer->pLinkNewer = NULL;               /* link into head of chain */
    pBuffer->pLinkOlder = Disk.pNewest;
    Disk.pNewest = pBuffer;

    /* add new buffer to paging table */
    Disk.PageTable[page].pBuffer = pBuffer;   /* add new to paging table */

    memcpy(
        pBuffer->Buffer,
        data,
        BUFFER_SIZE
    );

    pBuffer->BufferDirty = 1;
    pBuffer->BufferPage = page;               /* our new page number */
}


static void NEAR init_last_chance_table(t_decoder_context *context)
{
    int i;

    for (i = 0; i < NUM_OUTPUT_BUFFER_PAGES; i++)
        context->dec_pos_to_page[i] = -1;

    context->dec_last_chance_page_to_use = NUM_OUTPUT_BUFFER_PAGES;
}


static byte * NEAR last_chance_retrieve(t_decoder_context *context, int page)
{
    int used_output_pages;
    int table_entry;

    /*
     * Where in the output buffer would our page be?
     */
    table_entry = Disk.PageTable[page].last_chance_ptr;

    /*
     * It's not there
     */
    if (table_entry == -1)
        return NULL;

    /*
     * It's now an invalid entry
     */
    if (context->dec_pos_to_page[table_entry] != page)
        return NULL;

    context->dec_pos_to_page[table_entry] = -1;
    Disk.PageTable[page].last_chance_ptr = -1;

    used_output_pages = (int) (((context->dec_output_curpos - context->dec_output_buffer) / BUFFER_SIZE) + 1);

    if (table_entry <= used_output_pages)
        return NULL;

    return (context->dec_output_buffer + (BUFFER_SIZE * table_entry));
}


static void NEAR last_chance_store(t_decoder_context *context, int page, byte *data)
{
    int used_output_pages;
    int prev_owner;
    int dest;

    used_output_pages = (int) (((context->dec_output_curpos - context->dec_output_buffer) / BUFFER_SIZE) + 1);

    if (used_output_pages >= NUM_OUTPUT_BUFFER_PAGES)
        return;

    context->dec_last_chance_page_to_use--;

    if (context->dec_last_chance_page_to_use < used_output_pages)
        context->dec_last_chance_page_to_use = NUM_OUTPUT_BUFFER_PAGES-1;

    dest = context->dec_last_chance_page_to_use;

    /*
     * If any other page was pointing to this area of the buffer
     * as a last chance page, toast them.
     */
    prev_owner = context->dec_pos_to_page[dest];

    if (prev_owner != -1)
    {
        Disk.PageTable[prev_owner].last_chance_ptr = -1;
    }

    /*
     * Now we own this area
     */
    Disk.PageTable[page].last_chance_ptr = dest;
    context->dec_pos_to_page[dest] = page;

    memcpy(
        context->dec_output_buffer + (BUFFER_SIZE*dest),
        data,
        BUFFER_SIZE
    );
}


void NEAR DComp_Save_Output_Pages(
    t_decoder_context * context,
    uint                bytes_decoded
)
{
    uint    pages_to_save;
    int     page_num;
    uint    i;
    byte *  data;

    /*
     * If we managed to allocate one big buffer in the first place, then
     * there are no ring pages to save.
     */
    if (DComp.Buf != NULL)
        return;

    pages_to_save = (bytes_decoded / BUFFER_SIZE);

    page_num = (int) ((context->dec_position_at_start & context->dec_window_mask) / (long) BUFFER_SIZE);
    data = context->dec_output_buffer;

    for (i = 0; i < pages_to_save; i++)
    {
        save_page(context, page_num, data);

        page_num++;

        if (page_num >= Disk.RingPages)
            page_num = 0;

        data += BUFFER_SIZE;
    }

    init_last_chance_table(context);
}


static int NEAR retrieve_page_from_disk(t_decoder_context *context, int page, byte *buffer)
{
    long iPagefileOffset;
    byte *data;

    data = last_chance_retrieve(context, page);

    if (data)
    {
        memcpy(buffer, data, BUFFER_SIZE);
        return 1;
    }

    iPagefileOffset = (long) page * BUFFER_SIZE;

    if (context->dec_seek(Disk.Handle,iPagefileOffset,SEEK_SET) !=
        iPagefileOffset)
    {
        return 0;
    }

    if (context->dec_read(Disk.Handle,buffer,BUFFER_SIZE) != 
        BUFFER_SIZE)
    {
        return 0;
    }

#ifdef DEBUG_VERIFY_LAST_CHANCE
    /*
     * verifies last chance data against disk page
     */
    if (data)
    {
        int i;

        for (i=0;i<BUFFER_SIZE;i++)
        {
            if (data[i] != buffer[i])
            {
                printf("page %3d, err@%5d: %3d vs %3d (real)\n",
                    page, i, data[i], buffer[i]);
            }
        }
    }
#endif

    return 1;
}


/* --- DComp_Ring_Load() -------------------------------------------------- */

/* Bring page into a buffer, return a pointer to that buffer.  fWrite */
/* indicates the caller's intentions for this buffer, NZ->consider it */
/* dirty now.  Returns NULL if there is a paging fault (callback      */
/* failed) or if any internal assertions fail. */

static BYTE * NEAR DComp_Ring_Load(
    t_decoder_context * context,
    int                 page,
    int                 fWrite
)
{
    PBUFFER pBuffer;
    long iPagefileOffset;

    pBuffer = Disk.PageTable[page].pBuffer;   /* look up this page */

    if (pBuffer != NULL)                      /* if it's in the table */
    {
        if (pBuffer != Disk.pNewest)            /* promote if not newest */
        {
            pBuffer->pLinkNewer->pLinkOlder = pBuffer->pLinkOlder;

            if (pBuffer->pLinkOlder != NULL)      /* if there is someone older */
            {
                pBuffer->pLinkOlder->pLinkNewer = pBuffer->pLinkNewer;
            }
            else
            {
                Disk.pOldest = pBuffer->pLinkNewer;
            }        

            /* link into head of chain */

            Disk.pNewest->pLinkNewer = pBuffer;   /* newest now knows one newer */
            pBuffer->pLinkNewer = NULL;           /* nobody's newer */
            pBuffer->pLinkOlder = Disk.pNewest;   /* everybody's older */
            Disk.pNewest = pBuffer;               /* I'm the newest */
        }

        pBuffer->BufferDirty |= fWrite;         /* might already be dirty */

        return(pBuffer->Buffer);
    }

    /* desired page is not in the table; discard oldest & use it */

    pBuffer = Disk.pOldest;                   /* choose the oldest buffer */

    if (pBuffer->BufferPage != -1)            /* take it out of page table */
    {
        Disk.PageTable[pBuffer->BufferPage].pBuffer = NULL;  /* not here now */

        if (pBuffer->BufferDirty)                 /* write on eject, if dirty */
        {
            iPagefileOffset = (long) pBuffer->BufferPage * BUFFER_SIZE;

            if (context->dec_seek(Disk.Handle,iPagefileOffset,SEEK_SET) !=
                iPagefileOffset)
            {
                return(NULL);
            }

            if (context->dec_write(Disk.Handle,pBuffer->Buffer,BUFFER_SIZE) !=
                BUFFER_SIZE)
            {
                return(NULL);
            }

            Disk.PageTable[pBuffer->BufferPage].fDiskValid = 1;
        }


        last_chance_store(context, pBuffer->BufferPage, pBuffer->Buffer);
    }

    Disk.pOldest = Disk.pOldest->pLinkNewer;  /* newer is now oldest */
    Disk.pOldest->pLinkOlder = NULL;          /* oldest knows none older */

    Disk.pNewest->pLinkNewer = pBuffer;
    pBuffer->pLinkNewer = NULL;               /* link into head of chain */
    pBuffer->pLinkOlder = Disk.pNewest;
    Disk.pNewest = pBuffer;

    /* add new buffer to paging table */

    Disk.PageTable[page].pBuffer = pBuffer;   /* add new to paging table */

    /* if this disk page is valid, load it */

    if (Disk.PageTable[page].fDiskValid)
    {
        if (retrieve_page_from_disk(context, page, pBuffer->Buffer) == 0)
            return NULL;
    }
    else if (!fWrite)
    {
        /* assertion failure, trying to load a never-written page from disk */
        return(NULL);
    }

    pBuffer->BufferDirty = fWrite;            /* might be dirty now */
    pBuffer->BufferPage = page;               /* our new page number */

    return(pBuffer->Buffer);                          /* return new handle */
}

/* --- DComp_Ring_Match() ------------------------------------------------- */
static void NEAR DComp_Ring_Match(t_decoder_context *context, MATCH Match)
{
    long    SrcOffset;               /* offset into output ring */
    int     SrcPage;                  /* page # where that offset lies */
    int     Chunk;                    /* number of bytes this pass */
    BYTE FAR *SrcPtr;             /* pointer to source bytes */
    BYTE *SrcBuffer;            /* buffer where source data is */
    int     SrcBufferOffset;          /* offset within the buffer */

    if (DComp.NumBytes >= (unsigned) Match.Len)
    {
        SrcOffset = (DComp.Cur - Match.Dist) & context->dec_window_mask;
        DComp.NumBytes -= Match.Len;
        DComp.Cur += Match.Len;

        while (Match.Len)
        {
            /* Limit: number of bytes requested */

            Chunk = Match.Len;        /* try for everything */

            /*
             * Match source inside current output buffer?
             */
            if (Match.Dist <= (long) (context->dec_output_curpos - context->dec_output_buffer))
            {
                SrcPtr = context->dec_output_curpos - Match.Dist;

                while (Chunk--)               /* copy this chunk */
                {
                    *context->dec_output_curpos++ = *SrcPtr++;
                }

                return;
            }
            else
            {
                SrcPage = (int) (SrcOffset / BUFFER_SIZE);
                SrcBufferOffset = (int) (SrcOffset % BUFFER_SIZE);

                SrcBuffer = DComp_Ring_Load(context,SrcPage,0);   /* for reading */

                if (SrcBuffer == NULL)
                {
                    DComp.NumBytes = 0;
                    DComp.fRingFault = 1;
                    return;
                }

                SrcPtr = SrcBuffer + SrcBufferOffset;

                /* Limit: number of source bytes on input page */

                if ((BUFFER_SIZE - SrcBufferOffset) < Chunk)
                    Chunk = (BUFFER_SIZE - SrcBufferOffset);

                SrcOffset += Chunk;
                SrcOffset &= context->dec_window_mask;
                Match.Len -= Chunk;

                while (Chunk--)               /* copy this chunk */
                {
                    *context->dec_output_curpos++ = *SrcPtr++;
                }
            }
        }     /* while Match.Len */
    }   /* if Match.Len size OK */
    else  /* match too large to fit */
    {
        DComp.NumBytes = 0;
        DComp.fOutOverflow = 1;
    }
}


/* --- DComp_Ring_Reset() ------------------------------------------------- */

static void NEAR DComp_Ring_Reset(t_decoder_context *context)
{
    PBUFFER walker;
    int     iPage;

    for (walker = Disk.pNewest; walker != NULL; walker = walker->pLinkOlder)
    {
        walker->BufferPage = -1;                /* buffer is not valid */
        walker->BufferDirty = 0;                /*   and doesn't need writing */
    }

    for (iPage = 0; iPage < Disk.RingPages; iPage++)
    {
        Disk.PageTable[iPage].pBuffer = NULL;   /* not in memory */
        Disk.PageTable[iPage].fDiskValid = 0;   /* not on disk */
        Disk.PageTable[iPage].last_chance_ptr = -1; /* not in last chance list */
    }

    init_last_chance_table(context);
    context->dec_last_chance_page_to_use = NUM_OUTPUT_BUFFER_PAGES;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\decoder\xlatasm.asm ===
;
; asm_decoder_translate_e8()
;
; Assembly implementation of this from decxlat.c
;
; 26-Jul-96  jforbes  Initial version
;
	TITLE	XLATASM.ASM
	.386P
.model FLAT

PUBLIC  _asm_decoder_translate_e8

OFFSET_INSTR_POS    equ 28
OFFSET_FILE_SIZE    equ 32
OFFSET_MEM          equ 36
OFFSET_BYTES        equ 40

;
; ulong asm_decoder_translate_e8(instr_pos, file_size, mem *, bytes)
;
; returns new instr_pos in EAX
;
_TEXT	SEGMENT
_asm_decoder_translate_e8 PROC NEAR

    push    ebx
    push    ecx
    push    edx
    push    esi
    push    edi
    push    ebp

; edx = bytes
    mov     edx, DWORD PTR [esp + OFFSET_BYTES]

; if (bytes >= 6)
    cmp     edx, 6
    jge     greater_than_6_bytes

;
; less than 6 bytes to translate, so don't translate
;

; instr_pos += bytes
    add     edx, [esp + OFFSET_INSTR_POS]

; return new instr_pos in eax
    mov     eax, edx

    pop     ebp
    pop     edi
    pop     esi
    pop     edx
    pop     ecx
    pop     ebx
    ret     0



greater_than_6_bytes:

; ebp = current_file_size
    mov     ebp, DWORD PTR [esp + OFFSET_FILE_SIZE]

; ebx = 0xE8, our magic number
    mov     ebx, 0E8h ; 232

; esi = instr_pos
    mov     esi, DWORD PTR [esp + OFFSET_INSTR_POS]

; ecx = mem
    mov     ecx, DWORD PTR [esp + OFFSET_MEM]

; edi = instr_pos + bytes - 10
    mov     edi, esi
    add     edi, edx
    sub     edi, 10

; backup the last 6 bytes in the buffer
    sub     esp, 6

; eax = &mem[bytes-6]
    mov     eax, ecx
    add     eax, edx
    sub     eax, 6

    mov     edx, [eax]
    mov     [esp], edx

    mov     dx, WORD PTR [eax+4]
    mov     WORD PTR [esp+4], dx

; now store 0xE8's in there
    mov     DWORD PTR [eax], 0E8E8E8E8h
    mov     WORD PTR [eax+4], 0E8E8h

; save &mem[bytes-6]
    push    eax


;
; main loop
;
; eax = temporary
; ebx = 0xE8
; ecx = source ptr
; edx = temporary
; esi = instr pos
; edi = end_instr_pos
; ebp = current_file_size
;

loop_top:

;
; while (*mem++ != 0xE8)
;     ;

; eax = mem before                  
    mov     eax, ecx                ; u1
    nop                             ; v1

main_subloop:
    cmp     bl, [ecx]               ; u2
    je      SHORT equals_e8         ; v1

    cmp     bl, [ecx+1]             ; u2
    je      SHORT pre1              ; v1

    cmp     bl, [ecx+2]             ; u2
    je      SHORT pre2              ; v1

    cmp     bl, [ecx+3]             ; u2
    je      SHORT pre3              ; v1

    add     ecx, 4                  ; u1
    jmp     SHORT main_subloop      ; v1


pre3:
    add     ecx, 3                  ; u1
    jmp     SHORT equals_e8         ; v1

pre2:
    add     ecx, 2                  ; u1
    jmp     SHORT equals_e8         ; v1

pre1:
    inc     ecx

equals_e8:

; instr_pos += bytes visited in above loop
; esi := esi + (ecx - eax)
    sub     esi, eax                ; u1
    add     esi, ecx                ; v1

;
; Here is the only place we check for the end.
;
; We can do this because we force an 0xE8 at the end
; of the buffer.
;
; We cannot overlap the MOV below in between the
; cmp/jge, because ecx+1 may point to invalid memory.
;
    cmp     esi, edi                ; u1
    jge     SHORT bottom            ; v1

; eax = absolute = *(long *) mem
    mov     eax, [ecx+1]            ; u1
    add     ecx, 5                  ; v1  memptr += 5

;
; if (absolute < current_file_size && absolute >= 0)
;
; use unsigned comparison here so that if absolute < 0
; then it seems like it's some huge number
;
; this way we only do one comparison, abs >= file_size
;
    cmp     eax, ebp                ; u1
    jae     SHORT second_check      ; v1

;
; instead of doing "offset = absolute - instr_pos" and
; then storing it, we just say *mem -= instr_pos
;
; instead of:
;
;    sub     eax, esi
;    mov     [ecx-4], eax
;
; we do:

    sub     [ecx-4], esi            ; u3
    add     esi, 5                  ; v1  instr_pos += 5

    mov     eax, ecx                ; u1  (copied from loop_top)
    jmp     SHORT main_subloop      ; v1


;
; we want (absolute < 0) && (absolute >= -instr_pos)
;
; which can be rewritten as:
;
;         (-absolute > 0) && (-absolute - instr_pos <= 0)
;
; then:
;
;         (-absolute > 0) && (-absolute <= instr_pos)
;
; we can do both of these checks by checking with
; unsigned arithmetic, since if absolute < 0 then it
; will seem like some huge number:
;
; if ((ulong) (-(long) absolute) <= instr_pos)
;
; note: absolute==0 is taken care of in the first case
;
second_check:

; edx = instr_pos + absolute

    neg     eax                 ; u

    cmp     eax, esi            ; u1
    ja      SHORT no_conversion ; v1

;
; instead of storing "offset = absolute + current_file_size"
; we can do *mem += file_size.
;
; instead of doing:
;
;    neg     eax
;    add     eax, ebp
;    mov     DWORD PTR [ecx-4], eax
;
; we do:

    add     [ecx-4], ebp         ; u3

no_conversion:

; instr_pos += 5
    add     esi, 5               ; v1    u1
    jmp     SHORT loop_top       ;       v1


bottom:

; instr_pos = end_instr_pos + 10
    add     edi, 10

; restore the 6 bytes

; get &mem[bytes-6]
    pop     eax

    mov     edx, DWORD PTR [esp]
    mov     DWORD PTR [eax], edx

    mov     dx, WORD PTR [esp+4]
    mov     WORD PTR [eax+4], dx

    add     esp, 6

; return new instr_pos in eax
    mov     eax, edi

    pop     ebp
    pop     edi
    pop     esi
    pop     edx
    pop     ecx
    pop     ebx
    ret     0
_asm_decoder_translate_e8 ENDP
_TEXT	ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\block.c ===
/*
 * block.c
 *
 * LZX block outputting
 */

#include "encoder.h"


/*
 * Internal function definitions
 */
static void do_block_output(
	t_encoder_context *context,
	long literal_to_end_at,
	long distance_to_end_at
);


static void do_block_output(
	t_encoder_context *context,
	long literal_to_end_at,
	long distance_to_end_at
)
{
	ulong			bytes_compressed;
	lzx_block_type	block_type;
	ulong			estimated_block_size;

	/*
	 * Calculate frequencies for all tree elements.
	 *
	 * How many uncompressed bytes does this account for?
	 */
	bytes_compressed = get_block_stats(
		context,
		0,
		0,
		literal_to_end_at
	);

	/*
	 * Determine whether we wish to output a verbatim block or an
	 * aligned offset block
	 */
	block_type = get_aligned_stats(context, distance_to_end_at);

	/*
	 * Create trees from the frequency data
	 */
	create_trees(context, true); /* we want to generate the codes too */

	/*
	 * Determine whether the block should be output as uncompressed
	 */
	estimated_block_size = estimate_compressed_block_size(context);

	if (estimated_block_size >= bytes_compressed)
	{
		if (context->enc_bufpos_at_last_block >= context->enc_earliest_window_data_remaining)
			block_type = BLOCKTYPE_UNCOMPRESSED;
	}

	output_bits(context, 3, (byte) block_type);

	/* output 24 bit number, number of bytes compressed here */
	output_bits(context, 8,  (bytes_compressed >> 16) & 255);
	output_bits(context, 8,  ((bytes_compressed >> 8) & 255));
	output_bits(context, 8,  (bytes_compressed & 255));

	if (block_type == BLOCKTYPE_VERBATIM)
	{
		encode_trees(context);
		encode_verbatim_block(context, literal_to_end_at);
		get_final_repeated_offset_states(context, distance_to_end_at);
	}
	else if (block_type == BLOCKTYPE_ALIGNED)
	{
		encode_aligned_tree(context);
		encode_trees(context);
		encode_aligned_block(context, literal_to_end_at);
		get_final_repeated_offset_states(context, distance_to_end_at);
	}
	else if (block_type == BLOCKTYPE_UNCOMPRESSED)
	{
		get_final_repeated_offset_states(context, distance_to_end_at);
		encode_uncompressed_block(context, context->enc_bufpos_at_last_block, bytes_compressed);
	}

	context->enc_bufpos_at_last_block += bytes_compressed;
}


/*
 * Returns the number of distances which correspond
 * to this number of literals
 */
ulong get_distances_from_literals(t_encoder_context *context, ulong literals)
{
	ulong	d = 0;
	ulong	i;

	for (i = 0; i < (literals >> 3); i++)
		d += context->enc_ones[ context->enc_ItemType[i] ];

	/*
	 * Handle remaining 0...7
	 */
	for (i = (literals & (~7)); i < literals; i++)
	{
		if (IsMatch(i))
			d++;
	}

	return d;
}


/*
 * Output a block
 *
 * If trees_only is true, then only the tree statistics are updated.
 */
void output_block(t_encoder_context *context)
{
	ulong	where_to_split;
	ulong	distances;

    //
    // We have now output a block.
    //
    // We set this here in case someone calls LCIFlushOutput, so that
    // we don't try to redo the first chunk of bytes in the file
    // (since we've been forced to output them)
    //
    context->enc_first_block = 0;

	(void) split_block(
		context,
		0,
		context->enc_literals,
		context->enc_distances,
		&where_to_split,
		&distances /* distances @ literal == where_to_split */
	);

	do_block_output(context, where_to_split, distances);

	if (where_to_split == context->enc_literals)
	{
		/*
		 * If we've output ALL of our literals, then clear the itemtype array
		 */
		memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);

		context->enc_literals	= 0;
		context->enc_distances	= 0;
	}
	else
	{
		/*
		 * If we didn't output all of our literals, then move the literals
		 * and distances we didn't use, to the beginning of the list
		 */
		memmove(    //purify
			&context->enc_ItemType[0],
			&context->enc_ItemType[where_to_split/8],
			(int)(&context->enc_ItemType[1+(context->enc_literals/8)] - &context->enc_ItemType[where_to_split/8])
		);

		memset(
			&context->enc_ItemType[1+(context->enc_literals-where_to_split)/8],
			0,
			(int)(&context->enc_ItemType[MAX_LITERAL_ITEMS/8] - &context->enc_ItemType[1+(context->enc_literals-where_to_split)/8])
		);

		memmove(    //purify
			&context->enc_LitData[0],
			&context->enc_LitData[where_to_split],
			context->enc_literals-where_to_split
		);

		memmove(    //purify
			&context->enc_DistData[0],
			&context->enc_DistData[distances],
			sizeof(ulong)*(context->enc_distances-distances)
		);

		context->enc_literals  -= where_to_split;
		context->enc_distances -= distances;
	}

	fix_tree_cost_estimates(context);
}


void flush_output_bit_buffer(t_encoder_context *context)
{
	byte temp;

	if (context->enc_bitcount < 32)
	{
		temp = context->enc_bitcount-16;

		output_bits(context, temp, 0);
	}
}


/*
 * Estimate how much it would take to output the compressed
 * data left in the buffer
 */
long estimate_buffer_contents(t_encoder_context *context)
{
	long			estimated_block_size;

	/*
	 * Use frequency data sitting around from last tree creation
	 */
	create_trees(context, false); /* don't generate codes */

	estimated_block_size = estimate_compressed_block_size(context);

	/* so the optimal parser doesn't get confused */
	fix_tree_cost_estimates(context);

	return estimated_block_size;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\bsearch.c ===
/*
 * bsearch.c
 *
 * Binary search for optimal encoder
 */
#include "encoder.h"


#define left    context->enc_Left
#define right   context->enc_Right


#ifdef __BOUNDSCHECKER__
#include "nmevtrpt.h"
#endif

/*
 * Define this to force checking that all search locations visited
 * are valid.
 *
 * For debugging purposes only.
 */
#ifdef DIAMOND_DEBUG
#   define VERIFY_SEARCHES
#endif

#define VERIFY_SEARCH_CODE(routine_name) \
{ \
	int debug_search; \
	for (debug_search = 0; debug_search < clen; debug_search++) \
	{ \
		if (context->enc_MemWindow[ptr+debug_search] != context->enc_MemWindow[BufPos+debug_search]) \
		{ \
			_RPT2( \
				_CRT_WARN, \
				routine_name \
				" char mismatch @%3d (clen=%d)\n", \
				debug_search, clen); \
			\
			_RPT3( \
				_CRT_WARN, \
				" ptr=%8d, bufpos=%8d, end_pos=%8d\n\n", \
				ptr, BufPos, end_pos); \
		} \
	} \
}

#define VERIFY_MULTI_TREE_SEARCH_CODE(routine_name) \
_ASSERTE (context->enc_MemWindow[BufPos] == context->enc_MemWindow[ptr]); \
_ASSERTE (context->enc_MemWindow[BufPos+1] == context->enc_MemWindow[ptr+1]);



/*
 * Finds the closest matches of all possible lengths, MIN_MATCH <= x <= MAX_MATCH,
 * at position BufPos.
 *
 * The positions of each match location are stored in context->enc_matchpos_table[]
 *
 * Returns the longest such match length found, or zero if no matches found.
 */

#ifndef ASM_BSEARCH_FINDMATCH
long binary_search_findmatch(t_encoder_context *context, long BufPos)
{
	ulong       ptr;
	ulong       a, b;
	ulong       *small_ptr, *big_ptr;
	ulong       end_pos;
	int         val; /* must be signed */
	int         bytes_to_boundary;
	int         clen;
	int         same;
	int         match_length;
	int         small_len, big_len;
	int         i, best_repeated_offset;
#ifdef MULTIPLE_SEARCH_TREES
	ushort      tree_to_use;

#ifdef __BOUNDSCHECKER__
    //
    //  we're going to pickup two bytes of uncompressed data and use them as a direct index
    //  to select a tree root.  If those two bytes just happen to be 0xBF, 0xBF, BC6 will
    //  think bad things are happening.  We don't always disable because we'd still like to
    //  see checks and it's faster to do it only when needed.
    //
    int fReenable = 0;

    if ((context->enc_RealMemWindow[BufPos - SLIDE] == BC_FILL_BYTE) &&
        (context->enc_RealMemWindow[BufPos - SLIDE + 1] == BC_FILL_BYTE))
    {
        fReenable = StopEvtReporting();
    }
#endif

	/*
	 * Retrieve root node of tree to search, and insert current node at
	 * the root.
	 */
#ifdef STRICT_POINTERS
    tree_to_use = *((ushort UNALIGNED *) &context->enc_RealMemWindow[BufPos - SLIDE]);
#else
	tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);
#endif
	
	ptr        = context->enc_tree_root[tree_to_use];
	context->enc_tree_root[tree_to_use] = BufPos;

#ifdef __BOUNDSCHECKER__
    if (fReenable)
    {
        StartEvtReporting();
    }
#endif

#else
	ptr = context->enc_single_tree_root;
	context->enc_single_tree_root = BufPos;
#endif
	/*
	 * end_pos is the furthest location back we will search for matches 
	 *
	 * Remember that our window size is reduced by 3 bytes because of
	 * our repeated offset codes.
	 *
	 * Since BufPos starts at context->enc_window_size when compression begins,
	 * end_pos will never become negative.  
	 */
	end_pos = BufPos - (context->enc_window_size-4);

	/*
	 * Root node is either NULL, or points to a really distant position.
	 */
	if (ptr <= end_pos)
	{
#ifdef STRICT_POINTERS
        context->enc_RealLeft[BufPos - SLIDE] = context->enc_RealRight[BufPos - SLIDE] = 0; //BC6
#else
		left[BufPos] = right[BufPos] = 0;
#endif
		return 0;
	}

#ifdef MULTIPLE_SEARCH_TREES
	/*
	 * confirmed length (no need to check the first clen chars in a search)
	 *
	 * note: clen is always equal to min(small_len, big_len)
	 */
	clen            = 2;

	/*
	 * current best match length
	 */
	match_length    = 2;

	/*
	 * longest match which is < our string
	 */
	small_len       = 2;

	/*
	 * longest match which is > our string
	 */
	big_len         = 2;

	/*
	 * record match position for match length 2
	 */
	context->enc_matchpos_table[2] = BufPos - ptr + 2;

#ifdef VERIFY_SEARCHES
	VERIFY_MULTI_TREE_SEARCH_CODE("binary_search_findmatch()");
#endif

#else /* !MULTIPLE_SEARCH_TREES */

	clen            = 0;
	match_length    = 0;
	small_len       = 0;
	big_len         = 0;

#endif /* MULTIPLE_SEARCH_TREES */

	/*
	 * pointers to nodes to check
	 */
#ifdef STRICT_POINTERS
	small_ptr             = &context->enc_RealLeft[BufPos - SLIDE];     //BC6
	big_ptr               = &context->enc_RealRight[BufPos - SLIDE];    //BC6
#else
	small_ptr             = &left[BufPos];
	big_ptr               = &right[BufPos];
#endif

	do
	{
		/* compare bytes at current node */
		same = clen;

#ifdef VERIFY_SEARCHES
		VERIFY_SEARCH_CODE("binary_search_findmatch()")
#endif

		/* don't need to check first clen characters */
		a    = ptr + clen;
		b    = BufPos + clen;

#ifdef STRICT_POINTERS
		while ((val = ((int) context->enc_RealMemWindow[a++ - SLIDE]) - ((int) context->enc_RealMemWindow[b++ - SLIDE])) == 0)  //BC6
#else
		while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
#endif
		{
			/* don't exceed MAX_MATCH */
			if (++same >= MAX_MATCH)
				goto long_match;
		}

		if (val < 0)
		{
			if (same > big_len)
			{
				if (same > match_length)
				{
long_match:
					do
					{
						context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
					} while (match_length < same);

					if (same >= BREAK_LENGTH)
					{
#ifdef STRICT_POINTERS
                        *small_ptr = context->enc_RealLeft[ptr - SLIDE];
                        *big_ptr   = context->enc_RealRight[ptr - SLIDE];
#else
						*small_ptr = left[ptr];
						*big_ptr   = right[ptr];
#endif
						goto end_bsearch;
					}
				}

				big_len = same;
				clen = min(small_len, big_len);
			}

			*big_ptr = ptr;
#ifdef STRICT_POINTERS
   			big_ptr  = &context->enc_RealLeft[ptr - SLIDE];
#else
			big_ptr  = &left[ptr];
#endif
			ptr      = *big_ptr;
		}
		else
		{
			if (same > small_len)
			{
				if (same > match_length)
				{
					do
					{
						context->enc_matchpos_table[++match_length] = BufPos-ptr+(NUM_REPEATED_OFFSETS-1);
					} while (match_length < same);

					if (same >= BREAK_LENGTH)
					{
#ifdef STRICT_POINTERS
                        *small_ptr = context->enc_RealLeft[ptr - SLIDE];
                        *big_ptr   = context->enc_RealRight[ptr - SLIDE];
#else
						*small_ptr = left[ptr];
						*big_ptr   = right[ptr];
#endif
						goto end_bsearch;
					}
				}

				small_len = same;
				clen = min(small_len, big_len);
			}
		
			*small_ptr = ptr;
#ifdef STRICT_POINTERS
			small_ptr  = &context->enc_RealRight[ptr - SLIDE];
#else
			small_ptr  = &right[ptr];
#endif
			ptr        = *small_ptr;
		}
	} while (ptr > end_pos); /* while we don't go too far backwards */

	*small_ptr = 0;
	*big_ptr   = 0;


end_bsearch:

	/*
	 * If we have multiple search trees, we are already guaranteed
	 * a minimum match length of 2 when we reach here.
	 *
	 * If we only have one tree, then we're not guaranteed anything.
	 */
#ifndef MULTIPLE_SEARCH_TREES
	if (match_length < MIN_MATCH)
		return 0;
#endif

	/*
	 * Check to see if any of our match lengths can 
	 * use repeated offsets.
	 */

	/*
	 * repeated offset 1 
	 */
	for (i = 0; i < match_length; i++)
	{
#ifdef STRICT_POINTERS
		if (context->enc_RealMemWindow[BufPos+i - SLIDE] != context->enc_RealMemWindow[BufPos-context->enc_last_matchpos_offset[0]+i - SLIDE])
#else
		if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[0]+i])
#endif
			break;
	}

	/*
	 * the longest repeated offset
	 */
	best_repeated_offset = i;

	if (i >= MIN_MATCH)
	{
		/*
		 * Yes, we can do a repeated offset for some match lengths; replace
		 * their positions with the repeated offset position
		 */
		do
		{
			context->enc_matchpos_table[i] = 0; /* first repeated offset position */
		} while (--i >= MIN_MATCH);

		/* A speed optimization to cope with long runs of bytes */
		if (best_repeated_offset > BREAK_LENGTH)
			goto quick_return;
	}

	/*
	 * repeated offset 2 
	 */
	for (i = 0; i < match_length; i++)
	{
#ifdef STRICT_POINTERS
		if (context->enc_RealMemWindow[BufPos+i - SLIDE] != context->enc_RealMemWindow[BufPos-context->enc_last_matchpos_offset[1]+i - SLIDE])
#else
		if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[1]+i])
#endif
			break;
	}
		
	/*
	 * Does the second repeated offset provide a longer match?
	 *
	 * If so, leave the first repeated offset alone, but fill out the
	 * difference in match lengths in the table with repeated offset 1.
	 */
	if (i > best_repeated_offset)
	{               
		do
		{
			context->enc_matchpos_table[++best_repeated_offset] = 1;
		} while (best_repeated_offset < i);
	}

	/* 
	 * repeated offset 3 
	 */
	for (i = 0; i < match_length; i++)
	{
#ifdef STRICT_POINTERS
		if (context->enc_RealMemWindow[BufPos+i - SLIDE] != context->enc_RealMemWindow[BufPos-context->enc_last_matchpos_offset[2]+i - SLIDE])
#else
		if (context->enc_MemWindow[BufPos+i] != context->enc_MemWindow[BufPos-context->enc_last_matchpos_offset[2]+i])
#endif
			break;
	}
		
	/*
	 * Does the third repeated offset provide a longer match?
	 */
	if (i > best_repeated_offset)
	{               
		do
		{
			context->enc_matchpos_table[++best_repeated_offset] = 2;
		} while (best_repeated_offset < i);
	}

quick_return:

	/*
	 * Don't let a match cross a 32K boundary
	 */
	bytes_to_boundary = (CHUNK_SIZE-1) - ((int) BufPos & (CHUNK_SIZE-1));

	if (match_length > bytes_to_boundary)
	{
		match_length = bytes_to_boundary;
		
		if (match_length < MIN_MATCH)
			match_length = 0;
	}

	return (long) match_length;
}
#endif


/*
 * Inserts the string at the current BufPos into the tree.
 *
 * Does not record all the best match lengths or otherwise attempt
 * to search for matches
 *
 * Similar to the above function.
 */
#ifndef ASM_QUICK_INSERT_BSEARCH_FINDMATCH
void quick_insert_bsearch_findmatch(t_encoder_context *context, long BufPos, long end_pos)
{
	long        ptr;
	ulong       a,b;
	ulong       *small_ptr, *big_ptr;
	int         val;
	int         small_len, big_len;
	int         same;
	int         clen;
#ifdef MULTIPLE_SEARCH_TREES
	ushort      tree_to_use;

#ifdef __BOUNDSCHECKER__
    //
    //  we're going to pickup two bytes of uncompressed data and use them as a direct index
    //  to select a tree root.  If those two bytes just happen to be 0xBF, 0xBF, BC6 will
    //  think bad things are happening.  We don't always disable because we'd still like to
    //  see checks and it's faster to do it only when needed.
    //
    int fReenable = 0;

    if ((context->enc_RealMemWindow[BufPos - SLIDE] == BC_FILL_BYTE) &&
        (context->enc_RealMemWindow[BufPos - SLIDE + 1] == BC_FILL_BYTE))
    {
        fReenable = StopEvtReporting();
    }
#endif

#ifdef STRICT_POINTERS
	tree_to_use = *((ushort UNALIGNED *) &context->enc_RealMemWindow[BufPos - SLIDE]);
#else
	tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);
#endif
	ptr        = context->enc_tree_root[tree_to_use];
	context->enc_tree_root[tree_to_use] = BufPos;

#ifdef __BOUNDSCHECKER__
    if (fReenable)
    {
        StartEvtReporting();
    }
#endif

#else
	ptr = context->enc_single_tree_root;
	context->enc_single_tree_root = BufPos;
#endif

	if (ptr <= end_pos)
	{
#ifdef STRICT_POINTERS
        context->enc_RealLeft[BufPos - SLIDE] = context->enc_RealRight[BufPos - SLIDE] = 0;
#else
		left[BufPos] = right[BufPos] = 0;
#endif
		return;
	}

#ifdef MULTIPLE_SEARCH_TREES
	clen            = 2;
	small_len       = 2;
	big_len         = 2;

#ifdef VERIFY_SEARCHES
	VERIFY_MULTI_TREE_SEARCH_CODE("quick_insert_bsearch_findmatch()");
#endif

#else
	clen            = 0;
	small_len       = 0;
	big_len         = 0;
#endif

#ifdef STRICT_POINTERS
    small_ptr       = &context->enc_RealLeft[BufPos - SLIDE];
    big_ptr         = &context->enc_RealRight[BufPos - SLIDE];
#else
	small_ptr       = &left[BufPos];
	big_ptr         = &right[BufPos];
#endif

	do
	{
		_ASSERTE ((ulong) ptr >= (ulong) (context->enc_RealLeft - context->enc_Left));

		same = clen;

		a    = ptr+clen;
		b    = BufPos+clen;

#ifdef VERIFY_SEARCHES
		VERIFY_SEARCH_CODE("quick_insert_bsearch_findmatch()")
#endif

#ifdef STRICT_POINTERS
		while ((val = ((int) context->enc_RealMemWindow[a++ - SLIDE]) - ((int) context->enc_RealMemWindow[b++ - SLIDE])) == 0)
#else
		while ((val = ((int) context->enc_MemWindow[a++]) - ((int) context->enc_MemWindow[b++])) == 0)
#endif
		{
			/*
			 * Here we break on BREAK_LENGTH, not MAX_MATCH
			 */
			if (++same >= BREAK_LENGTH) 
				break;
		}

		if (val < 0)
		{
			if (same > big_len)
			{
				if (same >= BREAK_LENGTH)
				{
#ifdef STRICT_POINTERS
                    *small_ptr = context->enc_RealLeft[ptr - SLIDE];
                    *big_ptr = context->enc_RealRight[ptr - SLIDE];
#else
					*small_ptr = left[ptr];
					*big_ptr = right[ptr];
#endif
					return;
				}

				big_len = same;
				clen = min(small_len, big_len);
			}
			
			*big_ptr = ptr;
#ifdef STRICT_POINTERS
            big_ptr  = &context->enc_RealLeft[ptr - SLIDE];
#else
			big_ptr  = &left[ptr];
#endif
			ptr      = *big_ptr;
		}
		else
		{
			if (same > small_len)
			{
				if (same >= BREAK_LENGTH)
				{
#ifdef STRICT_POINTERS
                    *small_ptr = context->enc_RealLeft[ptr - SLIDE];
                    *big_ptr = context->enc_RealRight[ptr - SLIDE];
#else
					*small_ptr = left[ptr];
					*big_ptr = right[ptr];
#endif
					return;
				}

				small_len = same;
				clen = min(small_len, big_len);
			}

			*small_ptr = ptr;
#ifdef STRICT_POINTERS
            small_ptr  = &context->enc_RealRight[ptr - SLIDE];
#else
			small_ptr  = &right[ptr];
#endif
			ptr        = *small_ptr;
		}
   } while (ptr > end_pos);

	*small_ptr = 0;
	*big_ptr   = 0;
}
#endif


/*
 * Remove a node from the search tree; this is ONLY done for the last
 * BREAK_LENGTH symbols (see optenc.c).  This is because we will have
 * inserted strings that contain undefined data (e.g. we're at the 4th
 * last byte from the file and binary_search_findmatch() a string into
 * the tree - everything from the 4th symbol onwards is invalid, and
 * would cause problems if it remained in the tree, so we have to
 * remove it).
 */
void binary_search_remove_node(t_encoder_context *context, long BufPos, ulong end_pos)
{
	ulong   ptr;
	ulong   left_node_pos;
	ulong   right_node_pos;
	ulong   *link;
#ifdef MULTIPLE_SEARCH_TREES
	ushort  tree_to_use;

#ifdef __BOUNDSCHECKER__
    //
    //  we're going to pickup two bytes of uncompressed data and use them as a direct index
    //  to select a tree root.  If those two bytes just happen to be 0xBF, 0xBF, BC6 will
    //  think bad things are happening.  We don't always disable because we'd still like to
    //  see checks and it's faster to do it only when needed.
    //
    int fReenable = 0;

    if ((context->enc_RealMemWindow[BufPos - SLIDE] == BC_FILL_BYTE) &&
        (context->enc_RealMemWindow[BufPos - SLIDE + 1] == BC_FILL_BYTE))
    {
        fReenable = StopEvtReporting();
    }
#endif

	/*
	 * The root node of tree_to_use should equal BufPos, since that is
	 * the most recent insertion into that tree - but if we never
	 * inserted this string (because it was a near match or a long
	 * string of zeroes), then we can't remove it.
	 */
#ifdef STRICT_POINTERS
	tree_to_use = *((ushort UNALIGNED *) &context->enc_RealMemWindow[BufPos - SLIDE]);
#else
	tree_to_use = *((ushort UNALIGNED *) &context->enc_MemWindow[BufPos]);
#endif


	/*
	 * If we never inserted this string, do not attempt to remove it
	 */

	if (context->enc_tree_root[tree_to_use] != (ulong) BufPos)
    {
#ifdef __BOUNDSCHECKER__
        if (fReenable)
        {
            StartEvtReporting();
        }
#endif

		return;
    }

	link = &context->enc_tree_root[tree_to_use];

#ifdef __BOUNDSCHECKER__
    if (fReenable)
    {
        StartEvtReporting();
    }
#endif

#else
	if (context->enc_single_tree_root != (ulong) BufPos)
		return;

	link = &context->enc_single_tree_root;
#endif

	/*
	 * If the last occurence was too far away
	 */
	if (*link <= end_pos)
	{
		*link = 0;
#ifdef STRICT_POINTERS
        context->enc_RealLeft[BufPos - SLIDE] = context->enc_RealRight[BufPos - SLIDE] = 0;
#else
		left[BufPos] = right[BufPos] = 0;
#endif
		return;
	}

	/*
	 * Most recent location of these chars
	 */
	ptr             = BufPos;

	/*
	 * Most recent location of a string which is "less than" it
	 */
#ifdef STRICT_POINTERS
    left_node_pos   = context->enc_RealLeft[ptr - SLIDE];
#else
	left_node_pos   = left[ptr];
#endif

	if (left_node_pos <= end_pos)
#ifdef STRICT_POINTERS
        left_node_pos = context->enc_RealLeft[ptr - SLIDE];
#else
		left_node_pos = left[ptr] = 0;
#endif

	/*
	 * Most recent location of a string which is "greater than" it
	 */
#ifdef STRICT_POINTERS
    right_node_pos  = context->enc_RealRight[ptr - SLIDE];
#else
	right_node_pos  = right[ptr];
#endif

	if (right_node_pos <= end_pos)
#ifdef STRICT_POINTERS
        right_node_pos = context->enc_RealRight[ptr - SLIDE] = 0;
#else
		right_node_pos = right[ptr] = 0;
#endif

	while (1)
	{
#ifdef VERIFY_SEARCHES
		_ASSERTE (left_node_pos < (ulong) BufPos);
		_ASSERTE (right_node_pos < (ulong) BufPos);
#endif

		/*
		 * If left node position is greater than right node position
		 * then follow the left node, since that is the more recent
		 * insertion into the tree.  Otherwise follow the right node.
		 */
		if (left_node_pos > right_node_pos)
		{
			/*
			 * If it's too far away, then store that it never happened
			 */
			if (left_node_pos <= end_pos)
				left_node_pos = 0;

			ptr = *link = left_node_pos;

			if (!ptr)
				break;

#ifdef STRICT_POINTERS
            left_node_pos   = context->enc_RealRight[ptr - SLIDE];
            link            = &context->enc_RealRight[ptr - SLIDE];
#else
			left_node_pos   = right[ptr];
			link            = &right[ptr];
#endif
		}
		else
		{
			/*
			 * If it's too far away, then store that it never happened
			 */
			if (right_node_pos <= end_pos)
				right_node_pos = 0;

			ptr = *link = right_node_pos;

			if (!ptr) 
				break;

#ifdef STRICT_POINTERS
            right_node_pos  = context->enc_RealLeft[ptr - SLIDE];
            link            = &context->enc_RealLeft[ptr - SLIDE];
#else
			right_node_pos  = left[ptr];
			link            = &left[ptr];
#endif
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encapi.c ===
/*
 * encapi.c
 *
 * Encoder API entrypoints.
 */

#define ALLOC_VARS
#include "encoder.h"


bool LZX_EncodeInit(

	t_encoder_context *context,

	long compression_window_size,
	long second_partition_size,

	PFNALLOC pfnma,
	PFNFREE pfnmf,
	
	int FAR (DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
    ),

    void *fci_data
)
{
#ifdef DIAMOND_DEBUG
	_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDOUT);
	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDOUT);
	_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
	_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDOUT);
#endif

    /* to pass back in lzx_output_callback() */
    context->enc_fci_data = fci_data;

	context->enc_window_size = compression_window_size;

	/*
	 * The second partition size must be a multiple of 32K
	 */
	if (second_partition_size & (CHUNK_SIZE-1))
		second_partition_size &= (~(CHUNK_SIZE-1));

	/*
	 * The minimum allowed is 32K because of the way that
	 * our translation works.
	 */
	if (second_partition_size < CHUNK_SIZE)
		second_partition_size = CHUNK_SIZE;

	/*
	 * Our window size must be at least 32K
	 */
	if (compression_window_size < CHUNK_SIZE)
		return false;

	context->enc_encoder_second_partition_size = second_partition_size;
	context->enc_output_callback_function = pfnlzx_output_callback;

	context->enc_malloc	= pfnma;
	context->enc_free	= pfnmf;

	/* Error allocating memory? */
	if (comp_alloc_compress_memory(context) == false)
		return false;

	LZX_EncodeNewGroup(context);

	return true;
}


/*
 * Cleanup (frees memory)
 */
void LZX_EncodeFree(t_encoder_context *context)
{
	comp_free_compress_memory(context);
}


/*
 * Sets up the encoder for a new group of files.
 *
 * All this does is reset the lookup table, re-initialise to the
 * default match estimation tables for the optimal parser, and
 * reset a few variables.
 */
void LZX_EncodeNewGroup(t_encoder_context *context)
{
	init_compression_memory(context);
}


long LZX_Encode(
	t_encoder_context *context,	
	byte *input_data,
	long input_size,
	long *estimated_bytes_compressed,
	long file_size_for_translation
)
{
	context->enc_input_ptr	= input_data;
	context->enc_input_left	= input_size;

	context->enc_file_size_for_translation = file_size_for_translation;

	/* perform the encoding */
	encoder_start(context);

    if (context->enc_output_overflow)
    {
        *estimated_bytes_compressed = 0;
        return ENCODER_WRITE_FAILURE;
    }

	*estimated_bytes_compressed = estimate_buffer_contents(context);

	return ENCODER_SUCCESS;
}


bool LZX_EncodeFlush(t_encoder_context *context)
{
	flush_all_pending_blocks(context);

    if (context->enc_output_overflow)
        return false;

    return true;
}


unsigned char *LZX_GetInputData(
    t_encoder_context *context,
    unsigned long *input_position,
    unsigned long *bytes_available
)
{
    unsigned long filepos;

    // note that BufPos-window_size is the real position in the file
    filepos = context->enc_BufPos - context->enc_window_size;

    if (filepos < context->enc_window_size)
    {
        *input_position = 0;
        *bytes_available = filepos;
#ifdef STRICT_POINTERS
        return &context->enc_RealMemWindow[context->enc_window_size - SLIDE];
#else
        return &context->enc_MemWindow[context->enc_window_size];
#endif
    }
    else
    {
        *input_position = filepos - context->enc_window_size;
        *bytes_available = context->enc_window_size;
#ifdef STRICT_POINTERS
        return &context->enc_RealMemWindow[context->enc_BufPos - context->enc_window_size - SLIDE];
#else
        return &context->enc_MemWindow[context->enc_BufPos - context->enc_window_size];
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encapi.h ===
/*
 * encapi.h
 *
 * Definitions for calling LZX apis (encapi.c)
 */

/*
 * Return codes for LZX_Encode()
 */
#define ENCODER_SUCCESS			0
#define ENCODER_READ_FAILURE 	1
#define ENCODER_WRITE_FAILURE 	2
#define ENCODER_CONSOLE_FAILURE	3


bool LZX_EncodeInit(

	t_encoder_context *	context,
	long				compression_window_size,
	long				second_partition_size,
	PFNALLOC			pfnma,
	PFNFREE				pfnmf,

	int FAR (DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
    ),

    void FAR *          fci_data
);

void LZX_EncodeFree(t_encoder_context *context);

void LZX_EncodeNewGroup(t_encoder_context *context);

long LZX_Encode(
	t_encoder_context *	context,
	byte *				input_data,
	long				input_size,
	long *				bytes_compressed,
	long				file_size_for_translation
);

bool LZX_EncodeFlush(t_encoder_context *context);

unsigned char *LZX_GetInputData(
    t_encoder_context *context,
    unsigned long *input_position,
    unsigned long *bytes_available
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encoder.h ===
/*
 * encoder.h
 *
 * Main header file; includes everything else
 */

#ifndef ENCODER_H
#define ENCODER_H


#ifdef USE_ASSEMBLY
#   define ASM_BSEARCH_FINDMATCH
//#   define ASM_QUICK_INSERT_BSEARCH_FINDMATCH
#endif

#ifndef UNALIGNED
#ifndef NEEDS_ALIGNMENT
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif

#include <stdlib.h>
#include <string.h>

#if 0 // #ifdef _X86_
#include <crtdbg.h>
#else
#define _ASSERTE(x) ;
#define _RPT2(a,b,c,d) ;
#define _RPT3(a,b,c,d,e) ;
#define _CrtSetReportMode(a,b) ;
#define _CrtSetReportFile(a,b) ;
#endif

#include "../common/typedefs.h"
#include "../common/compdefs.h"
#include "encdefs.h"
#include "encvars.h"
#include "encmacro.h"
#include "encapi.h"
#include "encproto.h"


#ifdef __BOUNDSCHECKER__

/* LZX uses mangled pointers throughout as an optimization.             */
/* Various buffers which are related to the sliding window get their    */
/* base addresses adjusted downward as the offsets increase, to avoid   */
/* wrap-around logic throughout.  Of course, BoundsChecker doesn't      */
/* understand this, and even though each dereference hits the intended  */
/* buffer, BoundsChecker can't determine what the buffer is or its      */
/* size.  Defining STRICT_POINTERS prevents the code from adjusting     */
/* buffer base addresses, so BoundsChecker will be able to follow it.   */

#ifndef STRICT_POINTERS
#define STRICT_POINTERS
#endif

/* The byte value BoundsChecker uses to signify "uninitialized" memory. */

#define BC_FILL_BYTE (0xBF)

#endif  __BOUNDSCHECKER__


#ifdef STRICT_POINTERS
/* SLIDE = how far the window has moved so far */
#define SLIDE (((ulong) (context->enc_RealMemWindow)) - ((ulong) (context->enc_MemWindow)))
#endif

#endif  /* ENCODER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encdefs.h ===
/*
 * encdefs.h
 *
 * Encoder #define's and structure definitions.
 */

/*
 * NOTES:
 *
 * To maximise compression one can set both BREAK_LENGTH
 * and FAST_DECISION_THRESHOLD to 250, define
 * INSERT_NEAR_LONG_MATCHES, and crank up EXTRA_SIZE to
 * a larger value (don't get too large, otherwise we
 * might overflow our ushort cumbits[]), but the improvement
 * is really  marginal; e.g. 3600 bytes on winword.exe
 * (3.9 MB compressed).  It really hurts performance too.
 */


/*
 * See optenc.c 
 *
 * EXTRA_SIZE is the amount of extra data we allocate in addition
 * to the window, and LOOK is the amount of data the optimal
 * parser will look ahead.  LOOK is dependent on EXTRA_SIZE.
 *
 * Changing EXTRA_SIZE to 8K doesn't really do anything for
 * compression.  4K is a fairly optimal value.
 *
 * Be careful; our cumbits[] array and counters are all
 * ushort's in optenc.c, so make sure they don't overflow
 * (e.g. outputting all LOOK bytes as 9 bit uncompressed
 * symbols, say).  If necessary, change the typedef in optenc.c
 * to ulong.
 */
#define EXTRA_SIZE   4096
#define LOOK		(EXTRA_SIZE-MAX_MATCH-2)


/* 
 * Number of search trees used (for storing root nodes)
 */
#define NUM_SEARCH_TREES 65536


/*
 * Chunk size required by FCI
 */
#define CHUNK_SIZE 32768


/*
 * The maximum amount of data we will allow in our output buffer before
 * calling lzx_output_callback() to get rid of it.  Since we do this
 * for every 32K of input data, the output buffer only has to be able
 * to contain 32K + some spillover, which won't be much, because we
 * output uncompressed blocks if we determine a block is going to be
 * too large.
 */
#define OUTPUT_BUFFER_SIZE (CHUNK_SIZE+MAX_GROWTH)


/*
 * Maximum allowable number of block splits per 32K of uncompressed
 * data; if increased, then MAX_GROWTH will have to be increased also.
 */
#define MAX_BLOCK_SPLITS    4


/*
 * Max growth is calculated as follows:
 *
 * TREE AND BLOCK INFO
 * ===================
 *
 * The very first time the encoder is run, it outputs a 32 bit
 * file translation size.
 *
 * 3 bits to output block type
 * 24 bits for block size in uncompressed bytes.
 *
 * Max size of a tree of n elements is 20*4 + 5*n bits
 *
 * There is a main tree of max 700 elements which is really encoded
 * as two separate trees of 256 and 444(max).  There is also a
 * secondary length tree of 249 elements.
 *
 * That is 1360 bits, plus 2300 bits, plus 1325 bits.
 *
 * There may also be an aligned offset tree, which is 24 bits.
 *
 * Flushing output bit buffer; max 16 bits.
 *
 * Grand total: 5084 bits/block.
 *
 *
 * PARSER INFO
 * ===========
 *
 * Parser worst case scenario is with 2 MB buffer (50 position slots),
 * all matches of length 2, distributed over slots 32 and 33 (since
 * matches of length 2 further away than 128K are prohibited).  These
 * slots have 15 verbatim bits.  Maximum size per code is then
 * 2 bits to say which slot (taking into account that there will be
 * at least another code in the tree) plus 15 verbatim bits, for a
 * total of 17 bits.  Max growth on 32K of input data is therefore
 * 1/16 * 32K, or 2K bytes.
 *
 * Alternatively, if there is only one match and everything else
 * is a character, then 255 characters will be length 8, and one
 * character and the match will be length 9.  Assume the true
 * frequency of the demoted character is almost a 1 in 2^7
 * probability (it got remoted from a 2^8, but it was fairly
 * close to being 2^7).  If there are 32768/256, or 128, occurrences
 * of each character, but, say, almost 256 for the demoted character,
 * then the demoted character will expand the data by less than
 * 1 bit * 256, or 256 bits.  The match will take a little to
 * output, but max growth for "all characters" is about 256 bits.
 *
 *
 * END RESULT
 * ==========
 *
 * The maximum number of blocks which can be output is limited to
 * 4 per 32K of uncompressed data.
 *
 * Therefore, max growth is 4*5084 bits, plus 2K bytes, or 4590
 * bytes.
 */
#define     MAX_GROWTH          6144

/*
 * Don't allow match length 2's which are further away than this
 * (see above)
 */
#define     MAX_LENGTH_TWO_OFFSET (128*1024)


/*
 * When we find a match which is at least this long, prematurely
 * exit the binary search.
 *
 * This avoids us inserting huge match lengths of 257 zeroes, for
 * example.  Compression will improve very *very* marginally by
 * increasing this figure, but it will seriously impact
 * performance.
 *
 * Don't make this number >= (MAX_MATCH-2); see bsearch.c.
 */
#define BREAK_LENGTH 50


/*
 * If this option is defined, the parser will insert all bytes of
 * matches with lengths >= 16 with a distance of 1; this is a bad
 * idea, since matches like that are generally zeroes, which we
 * want to avoid inserting into the search tree.
 */
//#define INSERT_NEAR_LONG_MATCHES


/*
 * If the optimal parser finds a match which is this long or
 * longer, it will take it automatically.  The compression
 * penalty is basically zero, and it helps performance.
 */
#define FAST_DECISION_THRESHOLD 50


/*
 * Every TREE_CREATE_INTERVAL items, recreate the trees from
 * the literals we've encountered so far, to update our cost
 * estimations.
 *
 * 4K seems pretty optimal.
 */
#define TREE_CREATE_INTERVAL 4096


/*
 * When we're forced to break in our parsing (we exceed
 * our span), don't output a match length 2 if it is
 * further away than this.
 *
 * Could make this a variable rather than a constant
 *
 * On a bad binary file, two chars    = 18 bits
 * On a good text file, two chars     = 12 bits
 *
 * But match length two's are very uncommon on text files.
 */
#define BREAK_MAX_LENGTH_TWO_OFFSET 2048


/*
 * When MatchPos >= MPSLOT3_CUTOFF, extra_bits[MP_SLOT(MatchPos)] >= 3
 *
 * matchpos:  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
 * extrabits: 0,0,0,0,1,1,1,1,2,2, 2, 2, 2, 2, 2, 2, 3, ...
 *
 * Used for aligned offset blocks and statistics.
 */
#define MPSLOT3_CUTOFF 16


/*
 * Number of elements in the main tree
 */
#define MAIN_TREE_ELEMENTS			(NUM_CHARS+(((long) context->enc_num_position_slots) << NL_SHIFT))


/*
 * Max number of literals to hold.
 *
 * Memory required is MAX_LITERAL_ITEMS for enc_LitData[] array,
 * plus MAX_LITERAL_ITEMS/8 for enc_ItemType[] array.
 *
 * Must not exceed 64K, since that will cause our ushort
 * frequencies to overflow.
 */
#define MAX_LITERAL_ITEMS  65536


/*
 * Max number of distances to hold
 *
 * Memory required is MAX_DIST_ITEMS*4 for enc_DistData[] array
 *
 * MAX_DIST_ITEMS should never be greater than MAX_LITERAL_ITEMS,
 * since that just wastes space.
 *
 * However, it's extremely unlikely that one will get 65536 match
 * length 2's!  In any case, the literal and distance buffers
 * are checked independently, and a block is output if either
 * overflows.
 *
 * Bitmaps are highly redundant, though; lots of matches.
 */
#define MAX_DIST_ITEMS     32768
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encproto.h ===
/*
 * encproto.h
 *
 * Encoder function prototypes
 */

/* blkinit.c */
void create_slot_lookup_table(t_encoder_context *context);
void create_ones_table(t_encoder_context *context);

/* block.c */
void output_block(t_encoder_context *context);
void flush_output_bit_buffer(t_encoder_context *context);
long estimate_buffer_contents(t_encoder_context *context);
ulong get_distances_from_literals(t_encoder_context *context, ulong literals);

/* bsearch.c */
long binary_search_findmatch(t_encoder_context *context, long BufPos);
void quick_insert_bsearch_findmatch(t_encoder_context *context, long BufPos, long endpos);
void binary_search_remove_node(t_encoder_context *context, long BufPos, ulong end_pos);

/* encdata.c */
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at);
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size);
void perform_flush_output_callback(t_encoder_context *context);
ulong estimate_compressed_block_size(t_encoder_context *context);
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances);

/* encstats.c */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at);

ulong get_block_stats(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
);

ulong update_cumulative_block_stats(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
);

bool split_block(
	t_encoder_context *context, 
	ulong literal_to_start_at,
	ulong literal_to_end_at,
	ulong distance_to_end_at,
	ulong *split_at_literal,
	ulong *split_at_distance	
);

/* enctree.c */
void create_trees(t_encoder_context *context, bool generate_codes);
void fix_tree_cost_estimates(t_encoder_context *context);
void encode_trees(t_encoder_context *context);
void encode_aligned_tree(t_encoder_context *context);
void prevent_far_matches(t_encoder_context *context);

/* init.c */
void init_compression_memory(t_encoder_context *context);
bool comp_alloc_compress_memory(t_encoder_context *context);
void comp_free_compress_memory(t_encoder_context *context);

/* io.c */
void output_bits(t_encoder_context *context, int n, ulong x);
void free_compressed_output_buffer(t_encoder_context *context);
bool init_compressed_output_buffer(t_encoder_context *context);
void flush_compressed_output_buffer(t_encoder_context *context);
void reset_translation(t_encoder_context *context);
long comp_read_input(t_encoder_context *context, ulong BufPos, long Size);

/* optenc.c */
void opt_encode_top(t_encoder_context *context, long BytesRead);
void reset_encoder_variables(t_encoder_context *context);
void flush_all_pending_blocks(t_encoder_context *context);
void encoder_start(t_encoder_context *context);

/* tree.c */
bool allocate_tree_building_data(t_encoder_context *context);
void free_tree_building_data(t_encoder_context *context);

void make_tree(
	t_encoder_context *context,
	int		nparm, 
	ushort	*freqparm, 
	byte	*lenparm, 
	ushort	*codeparm,
	bool	make_codes	
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encmacro.h ===
/*
 * encmacro.h
 *
 * Encoder macros
 */


/*
 * Returns the slot number of a match position (uses table lookup) 
 */
#define MP_SLOT(matchpos) \
   ((matchpos) < 1024 ?										\
		(byte) context->enc_slot_table[(matchpos)] :					\
			( (matchpos) < 524288L ?						\
				(byte) 18 + (byte) context->enc_slot_table[(matchpos) >> 9] :   \
				((byte) 34 + (byte) ((matchpos) >> 17))		\
		)													\
   )


/*
 * Is a given literal a match or an unmatched symbol?
 */
#define IsMatch(literal) (context->enc_ItemType[(literal) >> 3] & (1 << ((literal) & 7)))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encdata.c ===
/*
 * encdata.c
 *
 * Encode a block into the output stream
 */

#include "encoder.h"

#define OUT_CHAR						\
		  c = context->enc_LitData[l];	\
		  OUTPUT_BITS(context->enc_main_tree_len[c], context->enc_main_tree_code[c]);


/*
 * Macro to output bits into the encoding stream
 */
#define OUTPUT_BITS(N,X) \
{ \
   context->enc_bitbuf |= (((ulong) (X)) << (context->enc_bitcount-(N))); \
   context->enc_bitcount -= (N);				  \
   while (context->enc_bitcount <= 16)            \
   {                                              \
      if (context->enc_output_buffer_curpos >= context->enc_output_buffer_end)   \
      { \
          context->enc_output_overflow = true; \
          context->enc_output_buffer_curpos = context->enc_output_buffer_start; \
      } \
      *context->enc_output_buffer_curpos++ = (byte) ((context->enc_bitbuf >> 16) & 255); \
      *context->enc_output_buffer_curpos++ = (byte) (context->enc_bitbuf >> 24); \
      context->enc_bitbuf <<= 16;				  \
      context->enc_bitcount += 16;                \
   }                                              \
}


/*
 * Given the initial state of the repeated offset buffers at
 * the beginning of this block, calculate the final state of the
 * repeated offset buffers after outputting this block as if it
 * were compressed data.
 *
 * First try to do it the quick way, by starting at the last
 * match and working backwards, to find three consecutive matches
 * which don't use repeated offsets.  If this fails, we'll have
 * to take the initial state of the three offsets at the beginning
 * of the block, and evolve them to the end of the block.
 */
void get_final_repeated_offset_states(t_encoder_context *context, ulong distances)
{
	ulong			MatchPos;
	signed long		d; /* must be signed */
	byte			consecutive;

	consecutive = 0;

	for (d = distances-1; d >= 0; d--)
	{
		if (context->enc_DistData[d] > 2)
		{
			/* NOT a repeated offset */
			consecutive++;

			/* do we have three consecutive non-repeated-offsets? */
			if (consecutive >= 3)
				break;
		}
		else
		{
			consecutive = 0;
		}
	}

	/*
	 * If we didn't find three consecutive matches which
	 * don't use repeated offsets, then we have to start
	 * from the beginning and evolve the repeated offsets.
	 *
	 * Otherwise, we start at the first of the consecutive
	 * matches.
	 */
	if (consecutive < 3)
	{
		d = 0;
	}

	for (; d < (signed long) distances; d++)
	{
		MatchPos = context->enc_DistData[d];

		if (MatchPos == 0)
		{
		}
		else if (MatchPos <= 2)
		{
			ulong	temp;

			temp = context->enc_repeated_offset_at_literal_zero[MatchPos];
			context->enc_repeated_offset_at_literal_zero[MatchPos] = context->enc_repeated_offset_at_literal_zero[0];
			context->enc_repeated_offset_at_literal_zero[0] = temp;
		}
		else
		{
			context->enc_repeated_offset_at_literal_zero[2] = context->enc_repeated_offset_at_literal_zero[1];
			context->enc_repeated_offset_at_literal_zero[1] = context->enc_repeated_offset_at_literal_zero[0];
			context->enc_repeated_offset_at_literal_zero[0] = MatchPos-2;
		}
	}
}


/*
 * Encode a block with no compression
 *
 * bufpos is the position in the file from which the first
 * literal in this block starts.  To reference memory, we will
 * use enc_MemWindow[bufpos] (remember that enc_MemWindow is
 * moved backwards every time we copymem).
 *
 * Since this data was originally matched into the compressor,
 * our recent match offsets will have been changed; however,
 * since this is an uncompressed block, the decoder won't be
 * updating them.  Therefore, we need to tell the decoder
 * the state of the match offsets after it has finished
 * decoding the uncompressed data - we store these in this
 * block.
 */
void encode_uncompressed_block(t_encoder_context *context, ulong bufpos, ulong block_size)
{
    int     i;
    int     j;
    bool    block_size_odd;
    ulong   val;

    /*
     * Align on a byte boundary
     */
    output_bits(context, context->enc_bitcount-16, 0);

	/*
	 * Now output the contents of the repeated offset
	 * buffers, since we need to preserve the state of
	 * the encoder
	 */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
    {
        val = context->enc_repeated_offset_at_literal_zero[i];

        for (j = 0; j < sizeof(long); j++)
        {
            *context->enc_output_buffer_curpos++ = (byte) val;
            val >>= 8;
        }
    }

    block_size_odd = block_size & 1;

	/*
	 * Write out uncompressed data
	 */
	while (block_size > 0)
	{
#ifdef STRICT_POINTERS
        *context->enc_output_buffer_curpos++ = context->enc_RealMemWindow[bufpos - SLIDE];
#else
        *context->enc_output_buffer_curpos++ = context->enc_MemWindow[bufpos];
#endif

		bufpos++;
		block_size--;
		context->enc_input_running_total++;

		if (context->enc_input_running_total == CHUNK_SIZE)
        {
			perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
        }
	}

    /*
     * Add pad byte to keep the output word-aligned
     */
    if (block_size_odd)
    {
        *context->enc_output_buffer_curpos++ = 0;
    }

    context->enc_bitcount   = 32;
    context->enc_bitbuf     = 0;
}


/*
 * Estimate the size of the data in the buffer, in bytes
 */
ulong estimate_compressed_block_size(t_encoder_context *context)
{
	ulong			block_size = 0; /* output size in bits */
	ulong			i;
	byte			mpslot;

	/* Estimation of tree size */
	block_size = 150*8;

	/* Tally bits to output characters */
	for (i = 0; i < NUM_CHARS; i++)
		block_size += (context->enc_main_tree_len[i]*context->enc_main_tree_freq[i]);

	/* Tally bits to output matches */
	for (mpslot = 0; mpslot < context->enc_num_position_slots; mpslot++)
	{
		long	element;
		int		primary;

		element = NUM_CHARS + (mpslot << NL_SHIFT);

		/* For primary == NUM_PRIMARY_LENGTHS we have secondary lengths */
		for (primary = 0; primary <= NUM_PRIMARY_LENGTHS; primary++)
		{
			block_size += ((context->enc_main_tree_len[element] + enc_extra_bits[mpslot]) *
				context->enc_main_tree_freq[element]);
			element++;
		}
	}

	for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
		block_size += (context->enc_secondary_tree_freq[i] * context->enc_secondary_tree_len[i]);

	/* round up */
	return (block_size+7) >> 3;
}

/*
 * Encode block with NO special encoding of the lower 3
 * position bits
 */
void encode_verbatim_block(t_encoder_context *context, ulong literal_to_end_at)
{
	ulong           MatchPos;
	ulong			d = 0;
	ulong			l = 0;
	byte            MatchLength;
	byte            c;
	byte            mpSlot;

	while (l < literal_to_end_at)
	{
		if (!IsMatch(l))
		{
			OUT_CHAR;
			l++;
			context->enc_input_running_total++;
		}
		else
		{
			/* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
			MatchLength = context->enc_LitData[l++];

			/* Delta match pos */
			MatchPos = context->enc_DistData[d++];

			mpSlot = (byte) MP_SLOT(MatchPos);

			if (MatchLength < NUM_PRIMARY_LENGTHS)
			{
				OUTPUT_BITS(
					context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
					context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
				);
			}
			else
			{
				OUTPUT_BITS(
					context->enc_main_tree_len [(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
					context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
				);

				OUTPUT_BITS(
					context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
					context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
				);
			}

			if (enc_extra_bits[ mpSlot ])
			{
				OUTPUT_BITS(
					enc_extra_bits[mpSlot],
					MatchPos & enc_slot_mask[mpSlot]
				);
			}

			context->enc_input_running_total += (MatchLength+MIN_MATCH);
		}

		if (context->enc_input_running_total == CHUNK_SIZE)
        {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
        }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
	}
}


/*
 * aligned block encoding
 */
void encode_aligned_block(t_encoder_context *context, ulong literal_to_end_at)
{
	ulong	MatchPos;
	byte	MatchLength;
	byte	c;
	byte	mpSlot;
	byte	Lower;
	ulong	l = 0;
	ulong	d = 0;

	while (l < literal_to_end_at)
	{
		if (!IsMatch(l))
		{
			OUT_CHAR;
			l++;
			context->enc_input_running_total++;
		}
		else
		{
			/* Note, 0 means MatchLen=3, 1 means MatchLen=4, ... */
			MatchLength = context->enc_LitData[l++];

			/* Delta match pos */
			MatchPos = context->enc_DistData[d++];
		
			mpSlot = (byte) MP_SLOT(MatchPos);

			if (MatchLength < NUM_PRIMARY_LENGTHS)
			{
				OUTPUT_BITS(
					context->enc_main_tree_len[ NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength],
					context->enc_main_tree_code[NUM_CHARS+(mpSlot<<NL_SHIFT)+MatchLength]
				);
			}
			else
			{
				OUTPUT_BITS(
					context->enc_main_tree_len[ (NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)],
					context->enc_main_tree_code[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mpSlot<<NL_SHIFT)]
				);

				OUTPUT_BITS(
					context->enc_secondary_tree_len[ MatchLength - NUM_PRIMARY_LENGTHS],
					context->enc_secondary_tree_code[MatchLength - NUM_PRIMARY_LENGTHS]
				);
			}

			if (enc_extra_bits[ mpSlot ] >= 3)
			{
				if (enc_extra_bits[ mpSlot ] > 3)
				{
					OUTPUT_BITS(
						enc_extra_bits[mpSlot] - 3,
						(MatchPos >> 3) & ( (1 << (enc_extra_bits[mpSlot]-3)) -1)
					);
				}

      			Lower = (byte) (MatchPos & 7);

	   			OUTPUT_BITS(
	   	   			context->enc_aligned_tree_len[Lower],
	   	   			context->enc_aligned_tree_code[Lower]
	   			);
			}
			else if (enc_extra_bits[ mpSlot ])
			{
				OUTPUT_BITS(
					enc_extra_bits[mpSlot],
					MatchPos & enc_slot_mask[ mpSlot ]
				);
			}

			context->enc_input_running_total += (MatchLength+MIN_MATCH);
		}

		if (context->enc_input_running_total == CHUNK_SIZE)
        {
            perform_flush_output_callback(context);
            context->enc_num_block_splits = 0;
        }

        _ASSERTE (context->enc_input_running_total < CHUNK_SIZE);
	}
}


void perform_flush_output_callback(t_encoder_context *context)
{
	long	output_size;

    /*
     * Do this only if there is any input to account for, so we don't
     * end up outputting blocks where comp_size > 0 and uncmp_size = 0.
     */
    if (context->enc_input_running_total > 0)
    {
        flush_output_bit_buffer(context);

        output_size = (long)(context->enc_output_buffer_curpos - context->enc_output_buffer_start);

        if (output_size > 0)
        {
            (*context->enc_output_callback_function)(
                context->enc_fci_data,
                context->enc_output_buffer_start,
                (long)(context->enc_output_buffer_curpos - context->enc_output_buffer_start),
                context->enc_input_running_total
            );
        }
    }

	context->enc_input_running_total = 0;
	context->enc_output_buffer_curpos = context->enc_output_buffer_start;

	/* initialise bit buffer */
	context->enc_bitcount = 32;
	context->enc_bitbuf   = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\enctree.c ===
/*
 * enctree.c
 *
 * Encode trees into output data
 */

#define EXT extern
#include "encoder.h"

/*
 * Encode a tree
 */
static void WriteRepTree(
	t_encoder_context *context,
	byte    *pLen,
	byte    *pLastLen, 
	int		Num
)
{
	int			i;
	int			j;
	int			Same;
	ushort		SmallFreq[2*24];
	ushort		MiniCode[24];
	char		MiniLen[24];
	char		k;
	byte		temp_store;
    byte * z=context->enc_output_buffer_curpos;

	static const byte Modulo17Lookup[] =
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
	};

	memset(SmallFreq, 0, sizeof(SmallFreq));

	temp_store	= pLen[Num];
	pLen[Num]	= 123; 

	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, compress this information */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		/* Special case if they're zeroes */
	 		if (!pLen[i])
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
	       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			SmallFreq[17]++;
	    		else
	       			SmallFreq[18]++;
	 		}
		 	else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
	       			Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

				SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	    		SmallFreq[19]++;
	 		}

	 		i += Same-1;
      }
      else
			SmallFreq[ Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ] ]++;
	}

	make_tree(
		context,
		20, 
		SmallFreq, 
		(byte *) MiniLen, 
		MiniCode, 
		true
	);

	/* max 10 byte output overrun */
	for (i = 0; i < 20; i++)
	{
		output_bits(context, 4, MiniLen[i]);
	}

	/* Output original tree with new code */
	for (i = 0; i < Num; i++)
	{
		Same = 0;

		/* Count the number of consecutive elements which have the same length */
		/* No need to check against array boundary, because the last element has */
		/* a nonsense value */
		for (j = i+1; pLen[j] == pLen[i]; j++)
	 		Same++;

		/* If more than 3, we can do something */
		if (Same >= TREE_ENC_REP_MIN)
		{
	 		if (!pLen[i]) /* Zeroes */
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1)
		       		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST + TREE_ENC_REP_ZERO_SECOND - 1;

	    		if (Same <= TREE_ENC_REP_MIN + TREE_ENC_REP_ZERO_FIRST - 1)
	       			k = 17;
	    		else
		       		k = 18;
	 		}
	 		else
	 		{
	    		if (Same > TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1)
			   		Same = TREE_ENC_REP_MIN + TREE_ENC_REP_SAME_FIRST - 1;

	    		k = 19;
	 		}
		}
		else
	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];

		output_bits(context, MiniLen[k], MiniCode[k]);

		if (k == 17)
		{
	 		output_bits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS, Same-TREE_ENC_REP_MIN);
	 		i += Same-1;
		}
		else if (k == 18)
		{
	 		output_bits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS, Same-(TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST));
	 		i += Same-1;
		}
		else if (k == 19)
		{
	 		output_bits(context, TREE_ENC_REP_SAME_EXTRA_BITS, Same-TREE_ENC_REP_MIN);

	 		k = Modulo17Lookup[ pLastLen[i]-pLen[i]+17 ];
			output_bits(context, MiniLen[k], MiniCode[k]);

	 		i += Same-1;
		}
	}

	pLen[Num] = temp_store;

	memcpy(pLastLen, pLen, Num);
}


void create_trees(t_encoder_context *context, bool generate_codes)
{
	/*
	 * Assumption: We can trash PtrLen[NUM_CHARS+(NUM_POSITION_SLOTS*NUM_LENGTHS))], since
	 *             we allocated space for it earlier
	 */
	make_tree(
		context,
		NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)),
		context->enc_main_tree_freq, 
		context->enc_main_tree_len,  
		context->enc_main_tree_code,
		generate_codes
	);

	make_tree(
		context,
		NUM_SECONDARY_LENGTHS, 
		context->enc_secondary_tree_freq,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_code,
		generate_codes
	);

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);
}


void fix_tree_cost_estimates(t_encoder_context *context)
{
	/*
	 *  We're only creating trees for estimation purposes and we do not 
	 *  want to encode the tree.  However, the following loops will set
	 *  the frequency zero tree element lengths to values other than 
	 *  zero, so that the optimal encoder won't get confused when it
	 *  tries to estimate the number of bits it would take to output an
	 *  element.
     *
     *  We also set the bit lengths of match length 2's further away
     *  than MAX_LENGTH_TWO_OFFSET to a large number, so that the
     *  optimal parser will never select such matches.
	 */
	ulong  i;

	/* Set zero lengths to some value */
	for (i = 0; i< NUM_CHARS; i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 11;
	}

	for (; i < NUM_CHARS+(context->enc_num_position_slots*(NUM_PRIMARY_LENGTHS+1)); i++)
	{
		if (context->enc_main_tree_len[i] == 0)
			context->enc_main_tree_len[i] = 12;
	}		

	for (i = 0; i < NUM_SECONDARY_LENGTHS; i++)
	{
		if (context->enc_secondary_tree_len[i] == 0)
			context->enc_secondary_tree_len[i] = 8; 
	}

    prevent_far_matches(context);
}


void prevent_far_matches(t_encoder_context *context)
{
    ulong i;

    /*
     * Set far match length 2's to a high value so they will never
     * be chosen.
     *
     * See description of MAX_GROWTH in encdefs.h
     */
    for (   i = MP_SLOT(MAX_LENGTH_TWO_OFFSET);
            i < context->enc_num_position_slots;
            i++
        )
	{
        context->enc_main_tree_len[NUM_CHARS + (i << NL_SHIFT)] = 100;
	}		
}


/*
 * Encode the trees
 *
 * Assumes trees have already been created with create_trees().
 *
 * Warning, do not call update_tree_cost_estimates() before encoding
 * the trees, since that routine trashes some of the tree elements.
 */
void encode_trees(t_encoder_context *context)
{
	WriteRepTree(
		context,
		context->enc_main_tree_len, 
		context->enc_main_tree_prev_len,
		NUM_CHARS
	);

	WriteRepTree(
		context,
		&context->enc_main_tree_len[NUM_CHARS], 
		&context->enc_main_tree_prev_len[NUM_CHARS], 
		context->enc_num_position_slots * (NUM_PRIMARY_LENGTHS+1)
	);

	WriteRepTree(
		context,
		context->enc_secondary_tree_len,
		context->enc_secondary_tree_prev_len,
		NUM_SECONDARY_LENGTHS
	);
}


void encode_aligned_tree(t_encoder_context *context)
{
	int i;

	make_tree(
		context,
		ALIGNED_NUM_ELEMENTS, 
		context->enc_aligned_tree_freq, 
		context->enc_aligned_tree_len, 
		context->enc_aligned_tree_code, 
		true
	);

	/* Output original tree with new code */
	for (i = 0; i < 8; i++)
	{
		output_bits(context, 3, context->enc_aligned_tree_len[i]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encstats.c ===
/*
 * encstats.c
 *
 * Routines for calculating statistics on a block of data which
 * has been compressed, but not yet output.
 *
 * These routines are used to determine which encoding method to use
 * to output the block.
 */

#include "encoder.h"



static void tally_aligned_bits(t_encoder_context *context, ulong dist_to_end_at)
{
	ulong	*dist_ptr;
	ulong	i;
	ulong	match_pos;

	/*
     * Tally the lower 3 bits
     */
	dist_ptr = context->enc_DistData;

	for (i = dist_to_end_at; i > 0; i--)
	{
		match_pos = *dist_ptr++;

		/*
		 * Only for matches which have >= 3 extra bits 
		 */
		if (match_pos >= MPSLOT3_CUTOFF)
			context->enc_aligned_tree_freq[match_pos & 7]++;
	}
}


/*
 * Determine whether it is advantageous to use aligned block
 * encoding on the block.
 */
lzx_block_type get_aligned_stats(t_encoder_context *context, ulong dist_to_end_at)
{
	byte		i;
	ulong		total_L3 = 0;
	ulong		largest_L3 = 0;

	memset(
		context->enc_aligned_tree_freq, 
		0, 
		ALIGNED_NUM_ELEMENTS * sizeof(context->enc_aligned_tree_freq[0])
	);

	tally_aligned_bits(context, dist_to_end_at);

	for (i = 0; i < ALIGNED_NUM_ELEMENTS; i++)
	{
		if (context->enc_aligned_tree_freq[i] > largest_L3)
			largest_L3 = context->enc_aligned_tree_freq[i];

		total_L3 += context->enc_aligned_tree_freq[i];
	}

	/*
	 * Do aligned offsets if the largest frequency accounts for 20%
	 * or more (as opposed to 12.5% for non-aligned offset blocks).
	 *
	 * Not worthwhile to do aligned offsets if we have < 100 matches
	 */
	if ((largest_L3 > total_L3/5) && dist_to_end_at >= 100)
		return BLOCKTYPE_ALIGNED;
	else
		return BLOCKTYPE_VERBATIM;
}


/*
 * Calculates the frequency of each literal, and returns the total
 * number of uncompressed bytes compressed in the block.
 */
static ulong tally_frequency(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
)
{
	ulong   i;
	ulong	d;
	ulong   compressed_bytes = 0;

	d = distance_to_start_at;

	for (i = literal_to_start_at; i < literal_to_end_at; i++)
	{
		if (!IsMatch(i))
		{
			/* Uncompressed symbol */
			context->enc_main_tree_freq[context->enc_LitData[i]]++;
			compressed_bytes++;
		}
		else
		{
			/* Match */
			if (context->enc_LitData[i] < NUM_PRIMARY_LENGTHS)
			{
				context->enc_main_tree_freq[ NUM_CHARS + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT) + context->enc_LitData[i]] ++;
			}
			else
			{
				context->enc_main_tree_freq[ (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[d])<<NL_SHIFT)] ++;
				context->enc_secondary_tree_freq[context->enc_LitData[i] - NUM_PRIMARY_LENGTHS] ++;
			}

			compressed_bytes += context->enc_LitData[i]+MIN_MATCH;
			d++;
		}
	}

	return compressed_bytes;
}


/*
 * Get statistics
 */
ulong get_block_stats(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
)
{
	memset(
		context->enc_main_tree_freq, 
		0, 
		MAIN_TREE_ELEMENTS * sizeof(context->enc_main_tree_freq[0])
	);

	memset(
		context->enc_secondary_tree_freq, 
		0, 
		NUM_SECONDARY_LENGTHS * sizeof(context->enc_secondary_tree_freq[0])
	);

	return tally_frequency(
		context,
		literal_to_start_at, 
		distance_to_start_at,
		literal_to_end_at
	);
}


/*
 * Update cumulative statistics
 */
ulong update_cumulative_block_stats(
	t_encoder_context *context, 
	ulong literal_to_start_at, 
	ulong distance_to_start_at,
	ulong literal_to_end_at
)
{
	return tally_frequency(
		context,
		literal_to_start_at, 
		distance_to_start_at,
		literal_to_end_at
	);
}



/*
 * Used in block splitting
 *
 * This routine calculates the "difference in composition" between 
 * two different sections of compressed data.
 *
 * Resolution must be evenly divisible by STEP_SIZE, and must be
 * a power of 2.
 */
#define RESOLUTION				1024

/*
 * Threshold for determining if two blocks are different
 *
 * If enough consecutive blocks are this different, the block
 * splitter will start investigating, narrowing down the
 * area where the change occurs.
 *
 * It will then look for two areas which are 
 * EARLY_BREAK_THRESHOLD (or more) different.
 *
 * If THRESHOLD is too small, it will force examination
 * of a lot of blocks, slowing down the compressor.
 *
 * The EARLY_BREAK_THRESHOLD is the more important value.
 */
#define THRESHOLD				1400

/*
 * Threshold for determining if two blocks are REALLY different
 */
#define EARLY_BREAK_THRESHOLD	1700

/*
 * Must be >= 8 because ItemType[] array is in bits
 *
 * Must be a power of 2.
 *
 * This is the step size used to narrow down the exact
 * best point to split the block.
 */
#define STEP_SIZE               64

/*
 * Minimum # literals required to perform block
 * splitting at all.
 */
#define MIN_LITERALS_REQUIRED	6144

/*
 * Minimum # literals we will allow to be its own block.
 *
 * We don't want to create blocks with too small numbers
 * of literals, otherwise the static tree output will
 * take up too much space.
 */
#define MIN_LITERALS_IN_BLOCK	4096


static const long square_table[17] =
{
	0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256
};


/*
 * log2(x) = x < 256 ? log2_table[x] : 8 + log2_table[(x >> 8)]
 *
 * log2(0)   = 0
 * log2(1)   = 1
 * log2(2)   = 2
 * log2(3)   = 2
 * log2(4)   = 3
 * log2(255) = 8
 * log2(256) = 9
 * log2(511) = 9
 * log2(512) = 10
 *
 * It's not a real log2; it's off by one because we have
 * log2(0) = 0.
 */
static const byte log2_table[256] =
{
	0,1,2,2,3,3,3,3,
	4,4,4,4,4,4,4,4,
	5,5,5,5,5,5,5,5,
	5,5,5,5,5,5,5,5,
	6,6,6,6,6,6,6,6,
	6,6,6,6,6,6,6,6,
	6,6,6,6,6,6,6,6,
	6,6,6,6,6,6,6,6,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	7,7,7,7,7,7,7,7,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8,
	8,8,8,8,8,8,8,8
};


/*
 * Return the difference between two sets of matches/distances
 */
static ulong return_difference(
	t_encoder_context *context, 
	ulong item_start1,
	ulong item_start2,
	ulong dist_at_1,
	ulong dist_at_2,
	ulong size
)
{
	ushort	freq1[800];
	ushort	freq2[800];
	ulong	i;
	ulong	cum_diff;
	int		element;

	/*
	 * Error!  Too many main tree elements
	 */
	if (MAIN_TREE_ELEMENTS >= (sizeof(freq1)/sizeof(freq1[0])))
		return 0;

	memset(freq1, 0, sizeof(freq1[0])*MAIN_TREE_ELEMENTS);
	memset(freq2, 0, sizeof(freq2[0])*MAIN_TREE_ELEMENTS);

	for (i = 0; i < size; i++)
	{
		if (!IsMatch(item_start1))
		{
			element = context->enc_LitData[item_start1];
		}
		else
		{
			if (context->enc_LitData[item_start1] < NUM_PRIMARY_LENGTHS)
				element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_1])<<NL_SHIFT) + context->enc_LitData[item_start1];
			else
				element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_1]) << NL_SHIFT);

			dist_at_1++;
		}

		item_start1++;
		freq1[element]++;

		if (!IsMatch(item_start2))
		{
			element = context->enc_LitData[item_start2];
		}
		else
		{
			if (context->enc_LitData[item_start2] < NUM_PRIMARY_LENGTHS)
				element = NUM_CHARS + (MP_SLOT(context->enc_DistData[dist_at_2])<<NL_SHIFT) + context->enc_LitData[item_start2];
			else
				element = (NUM_CHARS + NUM_PRIMARY_LENGTHS) + (MP_SLOT(context->enc_DistData[dist_at_2]) << NL_SHIFT);

			dist_at_2++;
		}

		item_start2++;
		freq2[element]++;
	}

	cum_diff = 0;

	for (i = 0; i < (ulong) MAIN_TREE_ELEMENTS; i++) 
	{
		ulong log2a, log2b, diff;

#define log2(x) ((x) < 256 ? log2_table[(x)] : 8+log2_table[(x) >> 8])

		log2a = (ulong) log2(freq1[i]);
		log2b = (ulong) log2(freq2[i]);

		/* diff = (log2a*log2a) - (log2b*log2b); */
		diff = square_table[log2a] - square_table[log2b];

		cum_diff += abs(diff);
	}

	return cum_diff;
}


/*
 * Calculates where and if a block of compressed data should be split.
 *
 * For example, if we have just compressed text data, audio data, and
 * more text data, then the composition of matches and unmatched
 * symbols will be different between the text data and audio data.
 * Therefore we force an end of block whenever the compressed data
 * looks like it's changing in composition.
 *
 * This routine currently cannot tell the difference between blocks
 * which should use aligned offsets, and blocks which should not.
 * However, there is little to be gained from looking for this change,
 * since it the match finder doesn't make an effort to look for
 * aligned offsets either.
 *
 * Returns whether we split the block or not.
 */
bool split_block(
	t_encoder_context *context, 
	ulong literal_to_start_at,
	ulong literal_to_end_at,
	ulong distance_to_end_at,	/* corresponds to # distances at literal_to_end_at */
	ulong *split_at_literal,
	ulong *split_at_distance	/* optional parameter (may be NULL) */
)
{
	ulong	i, j, d;
	int		nd;

	/*
	 * num_dist_at_item[n] equals the cumulative number of matches
	 * at literal "n / STEP_SIZE".
	 */
	ushort	num_dist_at_item[(MAX_LITERAL_ITEMS/STEP_SIZE)+8]; /* +8 is slop */

	/*
	 * default return
	 */
	*split_at_literal	= literal_to_end_at;

	if (split_at_distance)
		*split_at_distance	= distance_to_end_at;

	/* Not worth doing if we don't have many literals */
	if (literal_to_end_at - literal_to_start_at < MIN_LITERALS_REQUIRED)
		return false;

    /* Not allowed to split blocks any more, so we don't overflow MAX_GROWTH? */
    if (context->enc_num_block_splits >= MAX_BLOCK_SPLITS)
        return false;

	/*
	 * Keep track of the number of distances (matches) we've had,
	 * at each step of STEP_SIZE literals.
	 *
	 * Look at 8 items at a time, and ignore the last
	 * 0..7 items if they exist.
	 */
	nd = 0;
	d = 0;

	for (i = 0; i < (literal_to_end_at >> 3); i++)
	{
		/*
		 * if (i % (STEP_SIZE >> 3)) == 0
		 */
		if ((i & ((STEP_SIZE >> 3)-1)) == 0)
			num_dist_at_item[nd++] = (ushort) d;

		d += context->enc_ones[ context->enc_ItemType[i] ];
	}

	/*
	 * Must be a multiple of STEP_SIZE
	 */
	literal_to_start_at = (literal_to_start_at + (STEP_SIZE-1)) & (~(STEP_SIZE-1));

	/*
	 * See where the change in composition occurs
	 */
	for (	i = literal_to_start_at + 2*RESOLUTION; 
			i < literal_to_end_at - 4*RESOLUTION; 
			i += RESOLUTION)
	{
		/*
		 * If there appears to be a significant variance in composition
		 * between
		 *                    ___________
		 *                   /           \
		 *                A  B  i     X  Y  Z
		 *                \      \___/      /
		 *                 \_______________/
		 */
		if (
			return_difference(
				context,
				i,
				i+1*RESOLUTION, 
				(ulong) num_dist_at_item[i/STEP_SIZE], 
				(ulong) num_dist_at_item[(i+1*RESOLUTION)/STEP_SIZE], 
				RESOLUTION) > THRESHOLD
			&& 
			
			return_difference(
				context,
				i-RESOLUTION,   
				i+2*RESOLUTION, 
				(ulong) num_dist_at_item[(i-RESOLUTION)/STEP_SIZE], 
				(ulong) num_dist_at_item[(i+2*RESOLUTION)/STEP_SIZE], 
				RESOLUTION) > THRESHOLD
			 
			&& 
			
			return_difference(
				context,
				i-2*RESOLUTION, 
				i+3*RESOLUTION, 
				(ulong) num_dist_at_item[(i-2*RESOLUTION)/STEP_SIZE], 
				(ulong) num_dist_at_item[(i+3*RESOLUTION)/STEP_SIZE], 
				RESOLUTION) > THRESHOLD
			)
		{
			ulong max_diff = 0;
			ulong literal_split;

			/*
			 * Narrow down the best place to split block
			 *
			 * This really could be done much better; we could end up
			 * doing a lot of stepping;
			 *
			 * basically ((5/2 - 1/2) * RESOLUTION) / STEP_SIZE
			 *
			 * which is (2 * RESOLUTION) / STEP_SIZE,
			 * which with RESOLUTION = 1024 and STEP_SIZE = 32,
			 * equals 2048/32 = 64 steps.
			 */
			for (j = i+RESOLUTION/2; j<i+(5*RESOLUTION)/2; j += STEP_SIZE)
			{
				ulong	diff;

				diff = return_difference(
					context,
					j - RESOLUTION, 
					j, 
					(ulong) num_dist_at_item[(j-RESOLUTION)/STEP_SIZE], 
					(ulong) num_dist_at_item[j/STEP_SIZE], 
					RESOLUTION
				);

				/* Get largest difference */
				if (diff > max_diff)
				{
					/*
					 * j should not be too small, otherwise we'll be outputting
					 * a very small block
					 */
					max_diff = diff;
					literal_split = j;
				}
			}

			/*
			 * There could be multiple changes in the data in our literals,
			 * so if we find something really weird, make sure we break the
			 * block now, and not on some later change.
			 */
			if (max_diff >= EARLY_BREAK_THRESHOLD && 
				(literal_split-literal_to_start_at) >= MIN_LITERALS_IN_BLOCK)
			{
                context->enc_num_block_splits++;

				*split_at_literal = literal_split;

				/* 
				 * Return the associated # distances, if required.
				 * Since we split on a literal which is % STEP_SIZE, we
				 * can read the # distances right off
				 */
				if (split_at_distance)
					*split_at_distance = num_dist_at_item[literal_split/STEP_SIZE];

				return true;
			}
		}
	}

	/*
	 * No good place found to split
	 */
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\offsets.c ===
/*
 * offsets.c
 *
 * Used by makefile to generate ASM include file OFFSET.I
 * which contains numbers for offsets into the context structure.
 */
#include "encoder.h"
#include <stdio.h>

t_encoder_context p;

void main(void)
{
    printf("OFF_MEM_WINDOW              EQU %d\n", (byte *) &p.enc_MemWindow - (byte *) &p);
    printf("OFF_WINDOW_SIZE             EQU %d\n", (byte *) &p.enc_window_size - (byte *) &p);
#ifdef MULTIPLE_SEARCH_TREES
    printf("OFF_TREE_ROOT               EQU %d\n", (byte *) &p.enc_tree_root - (byte *) &p);
#else
    printf("OFF_SINGLE_TREE_ROOT        EQU %d\n", (byte *) &p.enc_single_tree_root - (byte *) &p);
#endif
    printf("OFF_LEFT                    EQU %d\n", (byte *) &p.enc_Left - (byte *) &p);
    printf("OFF_RIGHT                   EQU %d\n", (byte *) &p.enc_Right - (byte *) &p);
    printf("OFF_MATCHPOS_TABLE          EQU %d\n", (byte *) &p.enc_matchpos_table - (byte *) &p);
    printf("OFF_LAST_MATCHPOS_OFFSET    EQU %d\n", (byte *) &p.enc_last_matchpos_offset - (byte *) &p);
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\encvars.h ===
/*
 * encvars.h
 *
 * Variables for the compressor
 */

#ifdef ALLOC_VARS
#	undef EXT
#	define EXT
#else
#   undef EXT
#   define EXT extern
#endif


/*
 * For the optimal parser
 *
 * Uses less memory if it's ushort, but then we're forcing the CPU
 * to do 16 bit operations.  
 *
 * Change this to ulong if you don't mind a small memory hit.
 * Also, if you make LOOK too large, this number may cause the
 * cost estimation to overflow; e.g. 10000 uncompressed symbols
 * @ 8 bits each > 65535 bits.
 */
typedef ulong		numbits_t;


/*
 * For the optimal parser
 */
typedef struct
{
	ulong			link;
	ulong			path;
	ulong			repeated_offset[NUM_REPEATED_OFFSETS];
	numbits_t		numbits;
} decision_node;


/*
 * 8 * max_position_slots(50) = 656
 */
#define MAX_MAIN_TREE_ELEMENTS 700

typedef struct
{
	/* "fake" window pointer, based on enc_RealMemWindow */
	byte				*enc_MemWindow;

	ulong				enc_window_size;

#ifdef MULTIPLE_SEARCH_TREES
	/* root node pointers for our search trees */
	ulong				*enc_tree_root;
#else /* !MULTIPLE_SEARCH_TREES */
	ulong				 enc_single_tree_root;
#endif /* MULTIPLE_SEARCH_TREES */

	/* "fake" start of left nodes */
	ulong				*enc_Left;

	/* "fake" start of right nodes */
	ulong				*enc_Right;

	/* bitwise outputting */
	ulong               enc_bitbuf;
	signed char			enc_bitcount;
    bool                enc_output_overflow;
    char                pad1[2];

	/* used to record literals and displacements */
	ulong               enc_literals;    /* current number of literals */
	ulong               enc_distances;   /* current number of displacements */
	ulong              *enc_DistData;		/* match displacement array */
	byte               *enc_LitData;     /* contains a character or a matchlength */
	byte               *enc_ItemType;  /* bitmap for whether it's a character or matchlength */
	ulong				enc_repeated_offset_at_literal_zero[NUM_REPEATED_OFFSETS];

	/*
	 * the last three match offsets (displacements) encoded, the most recent
	 * one being enc_last_matchpos_offset[0]. 
	 */
	ulong				enc_last_matchpos_offset[NUM_REPEATED_OFFSETS];

	/* used for optimal parsing */
	ulong               enc_matchpos_table[MAX_MATCH+1];

	/* current encoding position in data */
	ulong				enc_BufPos;

	/* lookup table for converting a match position into a slot */
	byte                enc_slot_table[1024];

	/* buffering the output data */
	byte                *enc_output_buffer_start; 
	byte                *enc_output_buffer_curpos; 
	byte                *enc_output_buffer_end; 
	ulong				enc_input_running_total;
	ulong				enc_bufpos_last_output_block;

	/* number of distinct position slots */
	ulong               enc_num_position_slots;

	/* misc */
	ulong               enc_file_size_for_translation;

	bool                enc_allocated_compression_memory;

    /* number of block splits for this 32K of uncompressed data */
    byte                enc_num_block_splits;

	/* the number of 1 bits in any given integer */
	byte				enc_ones[256];

	/* compression parameters */
	byte				enc_first_block;
	bool				enc_need_to_recalc_stats;
	bool				enc_first_time_this_group;
	ulong				enc_encoder_second_partition_size;
	ulong				enc_earliest_window_data_remaining;
	ulong				enc_bufpos_at_last_block;
	byte				*enc_input_ptr;
	long				enc_input_left;
	ulong				enc_instr_pos;

	/* for tree.c */
	ushort				*enc_tree_freq;
	ushort				*enc_tree_sortptr;
	byte				*enc_len;
	short				enc_tree_heap[MAX_MAIN_TREE_ELEMENTS + 2];
	ushort				enc_tree_leftright[2*(2*MAX_MAIN_TREE_ELEMENTS-1)];
	ushort				enc_tree_len_cnt[17];
	int					enc_tree_n;
	short				enc_tree_heapsize;
	char				enc_depth;

	ulong				enc_next_tree_create;
	ulong				enc_last_literals;
	ulong				enc_last_distances;
	decision_node		*enc_decision_node;

	/* trees */
	byte				enc_main_tree_len[MAX_MAIN_TREE_ELEMENTS+1];
	byte				enc_secondary_tree_len[NUM_SECONDARY_LENGTHS+1];

	ushort				enc_main_tree_freq[MAX_MAIN_TREE_ELEMENTS*2];
	ushort				enc_main_tree_code[MAX_MAIN_TREE_ELEMENTS];
	byte				enc_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS+1];

	ushort				enc_secondary_tree_freq[NUM_SECONDARY_LENGTHS*2];
	ushort				enc_secondary_tree_code[NUM_SECONDARY_LENGTHS];
	byte				enc_secondary_tree_prev_len[NUM_SECONDARY_LENGTHS+1];

	ushort				enc_aligned_tree_freq[ALIGNED_NUM_ELEMENTS*2];
	ushort				enc_aligned_tree_code[ALIGNED_NUM_ELEMENTS];
	byte				enc_aligned_tree_len[ALIGNED_NUM_ELEMENTS];
	byte				enc_aligned_tree_prev_len[ALIGNED_NUM_ELEMENTS];

	/* start of allocated window memory */
	byte				*enc_RealMemWindow;

	/* start of allocated left nodes */
	ulong				*enc_RealLeft;

	/* start of allocated right nodes */
	ulong				*enc_RealRight;

    /* # cfdata frames this folder */
    ulong               enc_num_cfdata_frames;

	/* misc */
    void                *enc_fci_data;

	PFNALLOC			enc_malloc;
	PFNFREE				enc_free;

	int FAR (DIAMONDAPI *enc_output_callback_function)(
		void *			pfol,
		unsigned char *	compressed_data,
		long			compressed_size,
		long			uncompressed_size
	);


} t_encoder_context;


/*
 * Declare arrays? 
 */

#ifdef ALLOC_VARS

/*
 * (1 << extra_bits[n])-1 
 */
const ulong enc_slot_mask[] =
{
	     0,      0,      0,      0,     1,       1,      3,      3,
	     7,      7,     15,     15,    31,      31,     63,     63,
	   127,    127,    255,    255,   511,     511,   1023,   1023,
	  2047,   2047,   4095,   4095,  8191,    8191,  16383,  16383,
	 32767,  32767,  65535,  65535, 131071, 131071, 131071, 131071,
	131071, 131071, 131071, 131071, 131071, 131071, 131071, 131071,
	131071, 131071, 131071
};

const byte enc_extra_bits[] =   
{
	0,0,0,0,1,1,2,2,
	3,3,4,4,5,5,6,6,
	7,7,8,8,9,9,10,10,
	11,11,12,12,13,13,14,14,
	15,15,16,16,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17
};

#else

extern const ulong enc_slot_mask[];
extern const byte enc_extra_bits[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\io.c ===
/*
 * io.c
 */
#include "encoder.h"

#ifdef __BOUNDSCHECKER__
#include "..\..\nmevtrpt.h"
#endif

/*
 * Similar to the optimisation we have for the decoder.
 *
 * Allow the encoder to "overrun" output buffer by up to X bytes
 * so that we don't have to check for the end of the buffer every
 * single time we call outbits() in encdata.c
 */
#define OUTPUT_EXTRA_BYTES 64


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes);


void output_bits(t_encoder_context *context, int n, ulong x)
{
	context->enc_bitbuf |= (((ulong) x) << (context->enc_bitcount - n));
	context->enc_bitcount -= (char)n;

	while (context->enc_bitcount <= 16)
	{
		if (context->enc_output_buffer_curpos >= context->enc_output_buffer_end)
        {
            context->enc_output_overflow = true;
            context->enc_output_buffer_curpos = context->enc_output_buffer_start;
        }

        *context->enc_output_buffer_curpos++ = (byte) ((context->enc_bitbuf >> 16) & 255);
        *context->enc_output_buffer_curpos++ = (byte) (context->enc_bitbuf >> 24);

		context->enc_bitbuf <<= 16;
		context->enc_bitcount += 16;
	}
}


/*
 * Initialises output buffering
 */
bool init_compressed_output_buffer(t_encoder_context *context)
{
	if (!(context->enc_output_buffer_start = (byte *) context->enc_malloc(OUTPUT_BUFFER_SIZE)))
		return false;

	context->enc_output_buffer_curpos = context->enc_output_buffer_start;

	context->enc_output_buffer_end =
		context->enc_output_buffer_start+(OUTPUT_BUFFER_SIZE-OUTPUT_EXTRA_BYTES);

	return true;
}


void free_compressed_output_buffer(t_encoder_context *context)
{
   if (context->enc_output_buffer_start)
   {
	  context->enc_free(context->enc_output_buffer_start);
	  context->enc_output_buffer_start = NULL;
   }
}


void reset_translation(t_encoder_context *context)
{
	context->enc_instr_pos = 0;
}


static long read_input_data(t_encoder_context *context, byte *mem, long amount)
{
	if (amount <= context->enc_input_left)
	{
		memcpy(mem, context->enc_input_ptr, amount);
		context->enc_input_left -= amount;
		context->enc_input_ptr += amount;

		return amount;
	}
	else
	{
		long bytes_read;

		if (context->enc_input_left <= 0)
			return 0;

		bytes_read = context->enc_input_left;

		memcpy(mem, context->enc_input_ptr, context->enc_input_left);
		context->enc_input_ptr += context->enc_input_left;
		context->enc_input_left = 0;

		return bytes_read;
	}
}


long comp_read_input(t_encoder_context *context, ulong BufPos, long Size)
{
	long    bytes_read;

	if (Size <= 0)
		return 0;

	bytes_read = read_input_data(
		context,
		&context->enc_RealMemWindow[BufPos],
		Size
	);

	if (bytes_read < 0)
        return 0;

	/*
	 * If no translation being performed for this file
	 */
    if (context->enc_file_size_for_translation == 0 ||
        context->enc_num_cfdata_frames >= E8_CFDATA_FRAME_THRESHOLD)
    {
        context->enc_num_cfdata_frames++;
		return bytes_read;
    }

	encoder_translate_e8(
		context,
		&context->enc_RealMemWindow[BufPos],
		bytes_read
	);

    context->enc_num_cfdata_frames++;

	return bytes_read;
}


static void encoder_translate_e8(t_encoder_context *context, byte *mem, long bytes)
{
	long    offset;
	long    absolute;
	ulong   end_instr_pos;
	byte    temp[6];
	byte    *mem_backup;

	if (bytes <= 6)
	{
		context->enc_instr_pos += bytes;
		return;
	}

#ifdef __BOUNDSCHECKER__
    {
        int fReporting = StopEvtReporting();
#endif

	mem_backup = mem;

	/* backup these bytes */
	memcpy(temp, &mem[bytes-6], 6);

	/* overwrite them with 0xE8 */
	memset(&mem[bytes-6], 0xE8, 6);

	end_instr_pos = context->enc_instr_pos + bytes - 10;

	while (1)
	{
		while (*mem++ != 0xE8)
			context->enc_instr_pos++;

		if (context->enc_instr_pos >= end_instr_pos)
			break;

#if defined(_X86_)
	offset = *(long *) mem;
#else
		offset   = (long) (
						((ulong)  mem[0])               |
						(((ulong) mem[1])<<8)   |
						(((ulong) mem[2])<<16)  |
						(((ulong) mem[3])<<24)
						);
#endif

		absolute = context->enc_instr_pos + offset;

	if (absolute >= 0)
		{
			if ((ulong) absolute < context->enc_file_size_for_translation+context->enc_instr_pos)
			{
				if ((ulong) absolute >= context->enc_file_size_for_translation)
					absolute = offset - context->enc_file_size_for_translation;

#if defined(_X86_)
				*(ulong *) mem = (ulong) absolute;
#else
				mem[0] = (byte) ((ulong) absolute & 255);
				mem[1] = (byte) (( ((ulong) absolute) >> 8) & 255);
				mem[2] = (byte) (( ((ulong) absolute) >> 16) & 255);
				mem[3] = (byte) (( ((ulong) absolute) >> 24) & 255);
#endif
			}
		}

		mem += 4;
		context->enc_instr_pos += 5;
	}

	/* restore the bytes */
	memcpy(&mem_backup[bytes-6], temp, 6);

	context->enc_instr_pos = end_instr_pos + 10;

#ifdef __BOUNDSCHECKER__
        if (fReporting)
        {
            StartEvtReporting();
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\init.c ===
/*
 * init.c
 *
 * Initialise encoder
 */
#include "encoder.h"


#define MEM_WINDOW_ALLOC_SIZE   \
	(context->enc_window_size+(MAX_MATCH+EXTRA_SIZE)+context->enc_encoder_second_partition_size)

/*
 * Initialise encoder
 */
void init_compression_memory(t_encoder_context *context)
{
	/* set all root pointers to NULL */
#ifdef MULTIPLE_SEARCH_TREES
	memset(
   		context->enc_tree_root, 
   		0, 
   		NUM_SEARCH_TREES * sizeof(context->enc_tree_root[0])
	);
#else
	context->enc_single_tree_root = 0;
#endif

	context->enc_MemWindow	= context->enc_RealMemWindow - context->enc_window_size;
	context->enc_Left		= context->enc_RealLeft		 - context->enc_window_size;
	context->enc_Right		= context->enc_RealRight	 - context->enc_window_size;
	context->enc_BufPos		= context->enc_window_size;

	/* 
	 * Set initial state of repeated match offsets 
	 */
	context->enc_last_matchpos_offset[0] = 1;
	context->enc_last_matchpos_offset[1] = 1;
	context->enc_last_matchpos_offset[2] = 1;

	/* 
	 * repeated offset states the last time we output a block 
	 * see block.c/encdata.c 
	 */
	context->enc_repeated_offset_at_literal_zero[0] = 1;
	context->enc_repeated_offset_at_literal_zero[1] = 1;
	context->enc_repeated_offset_at_literal_zero[2] = 1;

	/* this is the first compressed block in the file */
	context->enc_first_block = true;

	/* we don't have any cumulative stats yet */
	context->enc_need_to_recalc_stats = true;

	/* bufpos @ last time we output a block */
	context->enc_bufpos_last_output_block = context->enc_BufPos;

	/* initialise bit buffer */
	context->enc_bitcount = 32;
	context->enc_bitbuf   = 0;
    context->enc_output_overflow = false;

	/*
	 * The last lengths are zeroed in both the encoder and decoder,
	 * since our tree representation is delta format.
	 */
	memset(context->enc_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);
	memset(context->enc_secondary_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);

	/* 
	 * Set the default last tree lengths for cost estimation 
	 */
	memset(context->enc_main_tree_len, 8, NUM_CHARS);
	memset(&context->enc_main_tree_len[NUM_CHARS], 9, MAIN_TREE_ELEMENTS-NUM_CHARS);
	memset(context->enc_secondary_tree_len, 6, NUM_SECONDARY_LENGTHS);
	memset(context->enc_aligned_tree_len, 3, ALIGNED_NUM_ELEMENTS);
    prevent_far_matches(context); /* prevent far match 2's from being taken */

	context->enc_bufpos_at_last_block			= context->enc_BufPos;
	context->enc_earliest_window_data_remaining	= context->enc_BufPos;
	context->enc_input_running_total			= 0;
	context->enc_first_time_this_group			= true;

	/* Clear the literal types array */
	memset(context->enc_ItemType, 0, MAX_LITERAL_ITEMS/8);
	
	/* No literals or distances encoded yet */
	context->enc_literals      = 0;
	context->enc_distances     = 0;

    /* No block splits yet */
    context->enc_num_block_splits = 0;

	context->enc_repeated_offset_at_literal_zero[0] = 1;
	context->enc_repeated_offset_at_literal_zero[1] = 1;
	context->enc_repeated_offset_at_literal_zero[2] = 1;

	/* reset instruction pointer (for translation) to zero */
	reset_translation(context);

    context->enc_num_cfdata_frames = 0;

    //BC6: no frequency data yet
    memset(context->enc_main_tree_freq, 0, sizeof(context->enc_main_tree_freq));
    memset(context->enc_secondary_tree_freq, 0, sizeof(context->enc_secondary_tree_freq));
    memset(context->enc_aligned_tree_freq, 0, sizeof(context->enc_aligned_tree_freq));

	memset(context->enc_RealMemWindow, 0, MEM_WINDOW_ALLOC_SIZE);
}


/*
 * Allocate memory for the compressor
 *
 * Returns true if successful, false otherwise
 */
bool comp_alloc_compress_memory(t_encoder_context *context)
{
	ulong	pos_start;

#ifdef MULTIPLE_SEARCH_TREES
	context->enc_tree_root		= NULL;
#endif
	context->enc_RealLeft		= NULL;
	context->enc_RealRight		= NULL;
	context->enc_MemWindow		= NULL;
	context->enc_decision_node	= NULL;
	context->enc_LitData		= NULL;
	context->enc_DistData		= NULL;
	context->enc_ItemType		= NULL;
    context->enc_output_buffer_start = NULL;

	/* ALSO NULLIFY BUFFERS! */

	/*
	 * Determine the number of position slots in the main tree
	 */
	context->enc_num_position_slots	= 4;
	pos_start				= 4;

	while (1)
	{
		pos_start += 1 << enc_extra_bits[context->enc_num_position_slots];

		context->enc_num_position_slots++;

		if (pos_start >= context->enc_window_size)
			break;
	}

#ifdef MULTIPLE_SEARCH_TREES
	context->enc_tree_root = (ulong *) context->enc_malloc(
		sizeof(context->enc_tree_root[0]) * NUM_SEARCH_TREES
	);

	if (context->enc_tree_root == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}
#endif

	context->enc_RealLeft = (ulong *) context->enc_malloc(
   		sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
	);

	if (context->enc_RealLeft == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_RealRight = (ulong *) context->enc_malloc(
   		sizeof(ulong) * MEM_WINDOW_ALLOC_SIZE
	);
	
	if (context->enc_RealRight == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_RealMemWindow = (byte *) context->enc_malloc(MEM_WINDOW_ALLOC_SIZE);
	
	if (context->enc_RealMemWindow == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_MemWindow = context->enc_RealMemWindow;

	context->enc_LitData = (byte *) context->enc_malloc(MAX_LITERAL_ITEMS * sizeof(*context->enc_LitData));

	if (context->enc_LitData == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_DistData = (ulong *) context->enc_malloc(MAX_DIST_ITEMS * sizeof(*context->enc_DistData));

	if (context->enc_DistData == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_ItemType = (byte *) context->enc_malloc(MAX_LITERAL_ITEMS/8);

	if (context->enc_ItemType == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	create_slot_lookup_table(context);
	create_ones_table(context);

	if (init_compressed_output_buffer(context) == false)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_decision_node = context->enc_malloc(
		sizeof(decision_node) * (LOOK+MAX_MATCH+16)
	);

	if (context->enc_decision_node == NULL)
	{
		comp_free_compress_memory(context);
		return false;
	}

	context->enc_allocated_compression_memory = true;
	
	/* success */
	return true;
}


void comp_free_compress_memory(t_encoder_context *context)
{
#ifdef MULTIPLE_SEARCH_TREES
	if (context->enc_tree_root)
	{
		context->enc_free((byte *) context->enc_tree_root);
		context->enc_tree_root = NULL;
	}
#endif

	if (context->enc_RealLeft)
	{
		context->enc_free((byte *) context->enc_RealLeft);
		context->enc_RealLeft = NULL;
	}

	if (context->enc_RealRight)
	{
		context->enc_free((byte *) context->enc_RealRight);
		context->enc_RealRight = NULL;
	}

	if (context->enc_RealMemWindow)
	{
		context->enc_free((byte *) context->enc_RealMemWindow);
		context->enc_RealMemWindow = NULL;
		context->enc_MemWindow = NULL;
	}

	if (context->enc_LitData)
	{
		context->enc_free(context->enc_LitData);
		context->enc_LitData = NULL;
	}

	if (context->enc_DistData)
	{
		context->enc_free((byte *) context->enc_DistData);
		context->enc_DistData = NULL;
	}

	if (context->enc_ItemType)
	{
		context->enc_free(context->enc_ItemType);
		context->enc_ItemType = NULL;
	}

	if (context->enc_decision_node)
	{
		context->enc_free((byte *) context->enc_decision_node);
		context->enc_decision_node = NULL;
	}

	free_compressed_output_buffer(context);

	context->enc_allocated_compression_memory = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\search.asm ===
;
; search.asm
;
; 08/16/96  jforbes  ASM implementation of binary_search_findmatch()
;
; There is a fair amount of optimisation towards instruction-scheduling.
;
; About 58% of the time is spent in the binary_search_findmatch()
; routine.  Around 31% is spent in the optimal parser.
;
    TITLE   SEARCH.ASM
    .386P
.model FLAT

PUBLIC  _binary_search_findmatch

_TEXT   SEGMENT

INCLUDE offsets.i

$match_length   EQU 0
$small_len      EQU 4
$small_ptr      EQU 8
$big_ptr        EQU 12
$end_pos        EQU 16
$clen           EQU 20
$left           EQU 24
$right          EQU 28
$mem_window     EQU 32
$matchpos_table EQU 36
$context        EQU 40
$best_repeat    EQU 44
LOCAL_STACK     EQU 48


MIN_MATCH       EQU 2
MAX_MATCH       EQU 257
BREAK_LENGTH    EQU 50

;
; binary_search_findmatch(t_encoder_context *context, long BufPos)
;
_binary_search_findmatch PROC NEAR

    push    ebx
    push    ecx

    push    edx
    push    esi

    push    edi
    push    ebp

    mov     ebp, [esp + 28] ; context
    mov     esi, [esp + 32] ; bufpos

; tree_to_use = *((ushort *) &enc_MemWindow[BufPos])
    mov     edi, [ebp + OFF_MEM_WINDOW]     ; edi = _enc_MemWindow

    xor     eax, eax
    mov     ax, WORD PTR [edi + esi]        ; eax = tree_to_use

    sub     esp, LOCAL_STACK                ; allocate space for stack vars

    mov     [esp + $mem_window], edi
    mov     [esp + $context], ebp

    lea     ecx, [ebp + OFF_MATCHPOS_TABLE] 
    mov     [esp + $matchpos_table], ecx

    mov     ecx, [ebp + OFF_TREE_ROOT]
    mov     ebx, [ecx + eax*4]              ; ebx = tree_root[tree_to_use]
    mov     [ecx + eax*4], esi              ; tree_root[tree_to_use] = bufpos

    lea     edx, [esi + 4]                  ; edx = BufPos+4
    sub     edx, [ebp + OFF_WINDOW_SIZE]    ; endpos = BufPos-(ws-4)
    mov     [esp + $end_pos], edx



; if (ptr <= endpos)
; have a short "stub" jump so that the jump is paired
    cmp     ebx, edx
    jle     SHORT close_ptr_le_endpos


;
; for main loop:
;
; eax = scratch
; ebx = ptr
; ecx = same
; edx = scratch
; esi = BufPos
; edi = scratch
; ebp = big_len
;

;
; The following instructions have been carefully
; interleaved for simultaneous execution on a Pentium's
; U and V pipelines.
;

    mov     edi, 2 ; commonly used constant here
    mov     edx, [ebp + OFF_LEFT]
    mov     [esp + $left], edx

    mov     [esp + $clen], edi                       ; clen = 2
    lea     edx, [edx + esi*4]                       ; edx = &Left[BufPos]

    lea     eax, [esi + edi]                         ; eax = BufPos+2
    mov     [esp + $small_ptr], edx                  ; smallptr=&Left[BufPos]

    mov     [esp + $match_length], edi               ; match_length = 2
    mov     edx, [ebp + OFF_RIGHT]
    mov     [esp + $right], edx

    sub     eax, ebx                                 ; eax = BufPos-ptr+2
    lea     edx, [edx + esi*4]                       ; edx = &Right[BufPos]

    mov     [esp + $small_len], edi                  ; small_len = 2

    mov     [esp + $big_ptr], edx                    ; bigptr=&Right[BufPos]
    mov     ecx, edi                                 ; same = 2 (first iter)

; enc_matchpos_table[2] = BufPos - ptr + 2
    mov     edi, [esp + $mem_window]
    mov     [ebp + OFF_MATCHPOS_TABLE + 8], eax

    add     edi, ecx         ; u    edi = &enc_MemWindow[clen]
    mov     ebp, 2           ; v    big_len = 2

    mov     eax, [edi + esi] ; u   *(DWORD*) enc_MemWindow[b] (bufpos+clen)
    jmp     SHORT main_loop  ; v


close_ptr_le_endpos:
    jmp     ptr_le_endpos



;
; same <= big_len
;
; this code is actually replicated much later in this file,
; but it's too far away for a SHORT jump, which will cause
; pipeline stalls.
;
close_same_le_biglen:
    mov     edx, [esp + $left]                       ; u
    mov     eax, [esp + $big_ptr]                    ; v

    lea     edi, [edx + ebx*4]                       ; u  edi=&Left[ptr]
    mov     [eax], ebx                               ; v  *big_ptr=ptr

    mov     [esp + $big_ptr], edi                    ; u  big_ptr=&left[ptr]
    mov     ecx, DWORD PTR [esp + $clen]             ; v  clen (next iter.)

    mov     ebx, [edi]                               ; u  ptr = *big_ptr
    mov     edi, [esp + $mem_window]                 ; v  (next iter.)

; bottom of main loop
    add     edi, ecx                          ; u  edi = &enc_MemWindow[clen]
    cmp     ebx, [esp + $end_pos]             ; v  

; for next iteration
    mov     eax, [edi + esi] ; u   *(DWORD*) enc_MemWindow[b] (bufpos+clen)
    ja      SHORT main_loop  ; v

; fall through

close_exit_main_loop:
    jmp     exit_main_loop 


;
; same <= small_len
;
; ditto - see above
;
close_same_le_smalllen:
    mov     edx, [esp + $right]
    mov     eax, [esp + $small_ptr]

    lea     edi, [edx + ebx*4]  ; u  edi = &Right[ptr]
    mov     [eax], ebx          ; v  *small_ptr = ptr

    mov     [esp + $small_ptr], edi ; u  small_ptr = &right[ptr]
    mov     ecx, [esp + $clen]      ; v  for next iteration

    mov     ebx, [edi]              ; u  ptr = *small_ptr
    mov     edi, [esp + $mem_window] ; v  (next iter.)

; bottom of main loop
    add     edi, ecx                ; u  (next iter.)
    cmp     ebx, [esp + $end_pos]   ; v

    mov     eax, [edi + esi]        ; u  (next iter.)
    jna     SHORT close_exit_main_loop        ; v


; fall through to main loop


;
; at the bottom of the main loop, we goto here
;
main_loop:

;
; If the first characters don't match, then we know for
; certain that we have not exceeded small_len or big_len,
; and therefore clen won't change either.  We can therefore
; skip some of the checks.
;
; This is the most common case.
;
; These jumps must be SHORT to be paired.
;
    cmp     [edi + ebx], al              ; u
    ja      SHORT close_same_le_smalllen ; v

    jb      SHORT close_same_le_biglen   ; u

    shr     eax, 8                       ; u
    inc     ecx ; same++                 ; v

;
; second and further iterations
;
; we only check same (ecx) against MAX_MATCH
; every 4 characters
;
; operations paired for U and V pipeline
; simultaneous execution
;
; notes:
;    SHR must be on the U pipeline
;

unrolled_loop:

; 1
    cmp     [edi + ebx + 1], al    ; u
    jne     SHORT not_eq           ; v

    shr     eax, 8                 ; u
    inc     ecx                    ; v

; 2
    cmp     [edi + ebx + 2], al
    jne     SHORT not_eq

    shr     eax, 8
    inc     ecx

; 3
    cmp     [edi + ebx + 3], al
    jne     SHORT not_eq

    mov     eax, [edi + esi + 4]   ; u
    inc     ecx                    ; v

    mov     dl, [edi + ebx + 4]    ; u
    add     edi, 4                 ; v

; 4
    cmp     dl, al
    jne     SHORT not_eq

    shr     eax, 8
    inc     ecx

    cmp     ecx, MAX_MATCH
    jl      SHORT unrolled_loop

;
; clen >= MAX_MATCH
;
; ecx could be larger than MAX_MATCH right now,
; so correct it
;
    mov     edx, [esp + $match_length]
    mov     ecx, MAX_MATCH
    jmp     SHORT long_match



same1_ge_break_length:
same2_ge_break_length:

; can trash clen (ecx)
    
; ecx = left
    mov     ecx, [esp + $left]

; eax = small_ptr
    mov     eax, [esp + $small_ptr]

; ecx = Left[ptr]
    mov     ecx, [ecx + ebx*4]

; edx = Right
    mov     edx, [esp + $right]

; *small_ptr = left[ptr]
    mov     [eax], ecx

; *big_ptr = right[ptr]
    mov     edx, [edx + ebx*4]

; *big_ptr = right[ptr]
    mov     eax, [esp + $big_ptr]
    mov     [eax], edx

; goto end_bsearch
    jmp     end_bsearch


;
; warning, "same" (ecx) could be larger than
; MAX_MATCH, so we will have to correct it
;
not_eq:
    ja      val_greater_than_0


;
; -----------------------------------------
; VAL < 0
; -----------------------------------------
;
val_less_than_0:

; if (same > big_len)
    cmp     ecx, ebp
    jle     SHORT same_le_biglen

; if (same > match_length)
    cmp     ecx, [esp + $match_length]
    jle     SHORT same1_le_ml

; here's where we truncate ecx to MAX_MATCH if it
; was too large
    cmp     ecx, MAX_MATCH
    jg      SHORT trunc_same1

back_from_trunc1:
long_match:
    mov     edi, [esp + $matchpos_table]
    lea     eax, [esi + 2]

; eax = BufPos-ptr+2
    mov     edx, [esp + $match_length]
    sub     eax, ebx

; do
; {
;    enc_matchpos_table[++match_length] = BufPos-ptr+2
; } while (match_length < same);

; store match_length
    mov     [esp + $match_length], ecx

loop1:

; match_length++
    inc     edx

; enc_matchpos_table[match_length] = BufPos-ptr+2
    mov     [edi + edx*4], eax

; while (match_length < same) 
    cmp     edx, ecx
    jl      SHORT loop1

; if (same >= BREAK_LENGTH)
    cmp     ecx, BREAK_LENGTH
    jge     SHORT same1_ge_break_length


; same <= match_length

same1_le_ml:

; clen = min(small_len, big_len=same)
    cmp     [esp + $small_len], ecx

; big_len = same
    mov     ebp, ecx

; small_len >= same?
    jge     SHORT over1

; no, small_len < same
; therefore clen := small_len
; (otherwise clen stays at big_len which ==same)
    mov     ecx, [esp + $small_len]

over1:
    mov     [esp + $clen], ecx


;
; same <= big_len
;
same_le_biglen:

    mov     edx, [esp + $left]                       ; u
    mov     eax, [esp + $big_ptr]                    ; v

    lea     edi, [edx + ebx*4]                       ; u  edi=&Left[ptr]
    mov     [eax], ebx                               ; v  *big_ptr=ptr

    mov     [esp + $big_ptr], edi                    ; u  big_ptr=&left[ptr]
    mov     ecx, DWORD PTR [esp + $clen]             ; v  clen (next iter.)

    mov     ebx, [edi]                               ; u  ptr = *big_ptr
    mov     edi, [esp + $mem_window]                 ; v  (next iter.)

; bottom of main loop
    add     edi, ecx                          ; u  edi = &enc_MemWindow[clen]
    cmp     ebx, [esp + $end_pos]             ; v  

; for next iteration
    mov     eax, [edi + esi] ; u   *(DWORD*) enc_MemWindow[b] (bufpos+clen)
    ja      main_loop        ; v 

    jmp     exit_main_loop


trunc_same1:
    mov     ecx, MAX_MATCH
    jmp     SHORT back_from_trunc1


trunc_same2:
    mov     ecx, MAX_MATCH
    jmp     SHORT back_from_trunc2


; -----------------------------------------
; VAL > 0
; -----------------------------------------
val_greater_than_0:

; if (same > small_len)
    cmp     ecx, [esp + $small_len]
    jle     SHORT same_le_smalllen

; if (same > match_length)
    cmp     ecx, [esp + $match_length]
    jle     SHORT same2_le_ml

; here's where we truncate ecx to MAX_MATCH if it
; was too large
    cmp     ecx, MAX_MATCH
    jg      SHORT trunc_same2

; can trash clen
; ecx = BufPos-ptr+2
back_from_trunc2:
    mov     edi, [esp + $matchpos_table]
    lea     eax, [esi + 2]

    mov     edx, [esp + $match_length]
    sub     eax, ebx

    mov     [esp + $match_length], ecx

; do
; {
;    enc_matchpos_table[++match_length] = BufPos-ptr+2
; } while (match_length < same);

loop2:

    inc     edx        ; match_length++

; enc_matchpos_table[match_length] = BufPos-ptr+2
    mov     [edi + edx*4], eax

    cmp     edx, ecx
    jl      SHORT loop2

; if (same >= BREAK_LENGTH)
    cmp     ecx, BREAK_LENGTH
    jge     same2_ge_break_length


same2_le_ml:

    mov     edx, [esp + $small_len]

; clen = min(small_len=ecx, big_len)
    cmp     ebp, ecx

; small_len = same
    mov     [esp + $small_len], ecx

    jge     SHORT over2

; same = big_len
    mov     ecx, ebp

over2:
    mov     [esp + $clen], ecx


same_le_smalllen:

    mov     edx, [esp + $right]
    mov     eax, [esp + $small_ptr]

    lea     edi, [edx + ebx*4]  ; u  edi = &Right[ptr]
    mov     [eax], ebx          ; v  *small_ptr = ptr

    mov     [esp + $small_ptr], edi ; u  small_ptr = &right[ptr]
    mov     ecx, [esp + $clen]      ; v  for next iteration

    mov     ebx, [edi]              ; u  ptr = *small_ptr
    mov     edi, [esp + $mem_window] ; v  (next iter.)

; bottom of main loop
    add     edi, ecx                ; u  (next iter.)
    cmp     ebx, [esp + $end_pos]   ; v

    mov     eax, [edi + esi]        ; u  (next iter.)
    ja      main_loop


exit_main_loop:

    mov     eax, [esp + $small_ptr]
    mov     edx, [esp + $big_ptr]

; *small_ptr = 0
    mov     DWORD PTR [eax], 0

; *big_ptr = 0
    mov     DWORD PTR [edx], 0


end_bsearch:

;
; now check for repeated offsets
;

;
; FIRST REPEATED OFFSET
;
    mov     eax, [esp + $match_length]

; for (i = 0; i < match_length; i++)
;   compare bufpos+i vs. bufpos+i-enc_last_matchpos_offset[0]

    mov     edi, [esp + $mem_window]

; ebx = bufpos
    mov     ebx, esi

; repeated offset zero
; ebx = bufpos - repeated_offset[0]
    mov     ecx, [esp + $context]
    sub     ebx, [ecx + OFF_LAST_MATCHPOS_OFFSET]

; i = 0
    xor     ecx, ecx

rp1_loop:
    mov     dl, [edi + esi]
    cmp     dl, [edi + ebx]
    jne     SHORT rp1_mismatch

; i++
    inc     ecx

; inc window pointer
    inc     edi

; i < match_length?
    cmp     ecx, eax
    jl      SHORT rp1_loop


;
; i == match_length
;
; therefore force ourselves to take rp1
;
; (this code is not in the C source, since it is
;  messy to do)
;
    mov     ebx, [esp + $matchpos_table]

force_rp1_copy:
    mov     DWORD PTR [ebx + ecx*4], 0
    dec     ecx

    cmp     ecx, MIN_MATCH
    jge     SHORT force_rp1_copy

    jmp     boundary_check


;
; i < match_length
;
rp1_mismatch:

; best_repeated_offset = i
    mov     [esp + $best_repeat], ecx

; if (i >= MIN_MATCH)
    cmp     ecx, MIN_MATCH
    jl      SHORT try_rp2

; for (; i >= MIN_MATCH; i--)
;    enc_matchpos_table[i] = 0
    mov     ebx, [esp + $matchpos_table]

rp1_copy:
    mov     DWORD PTR [ebx + ecx*4], 0
    dec     ecx
    cmp     ecx, MIN_MATCH
    jge     SHORT rp1_copy

; quick check
    cmp     DWORD PTR [esp + $best_repeat], BREAK_LENGTH
    jg      boundary_check



;
; SECOND REPEATED OFFSET
;
try_rp2:

; for (i = 0; i < match_length; i++)
;   compare bufpos+i vs. bufpos+i-enc_last_matchpos_offset[1]

    mov     edi, [esp + $mem_window]

; ebx = bufpos
    mov     ebx, esi

; repeated offset zero
; ebx = bufpos - repeated_offset[1]
    mov     ecx, [esp + $context]
    sub     ebx, [ecx + OFF_LAST_MATCHPOS_OFFSET + 4]

; i = 0
    xor     ecx, ecx

rp2_loop:
    mov     dl, [edi + esi]

    cmp     dl, [edi + ebx]
    jne     SHORT rp2_mismatch

; i++
    inc     ecx

; inc window pointer
    inc     edi

; i < match_length?
    cmp     ecx, eax
    jl      SHORT rp2_loop

;
; i == match_length
;                                                                     
; therefore force ourselves to take rp2
;
; (this code is not in the C source, since it is
;  messy to do)
;
    mov     ebx, [esp + $matchpos_table]

force_rp2_copy:
    mov     DWORD PTR [ebx + ecx*4], 1
    dec     ecx
    cmp     ecx, MIN_MATCH
    jge     SHORT force_rp2_copy
    jmp     SHORT boundary_check


rp2_mismatch:

; if (i > best_repeated_offset)
    cmp     ecx, [esp + $best_repeat]
    jle     SHORT try_rp3

; do
;    enc_matchpos_table[++best_repeated_offset] =  1
; while (best_repeated_offset < i)

    mov     edi, [esp + $best_repeat]
    mov     ebx, [esp + $matchpos_table]

rp2_copy:                     
    inc     edi               ; ++best_repeated_offset
    mov     DWORD PTR [ebx + edi*4], 1
    cmp     edi, ecx          ; best_repeated_offset < i ? 
    jl      SHORT rp2_copy

; best_repeat = i
    mov     [esp + $best_repeat], ecx


;
; THIRD REPEATED OFFSET
;
try_rp3:

; for (i = 0; i < match_length; i++)
;   compare bufpos+i vs. bufpos+i-enc_last_matchpos_offset[2]

    mov     edi, [esp + $mem_window]

; ebx = bufpos
    mov     ebx, esi

; repeated offset zero
; ebx = bufpos - repeated_offset[2]
    mov     ecx, [esp + $context]
    sub     ebx, [ecx + OFF_LAST_MATCHPOS_OFFSET + 8]

; i = 0
    xor     ecx, ecx

rp3_loop:
    mov     dl, [edi + esi]

    cmp     dl, [edi + ebx]
    jne     SHORT rp3_mismatch

; i++
    inc     ecx

; inc window pointer
    inc     edi

; i < match_length?
    cmp     ecx, eax
    jl      SHORT rp3_loop

;
; i == match_length
;
; therefore force ourselves to take rp3
;
; (this code is not in the C source, since it is
;  messy to do)
;
    mov     ebx, [esp + $matchpos_table]

force_rp3_copy:
    mov     DWORD PTR [ebx + ecx*4], 2
    dec     ecx
    cmp     ecx, MIN_MATCH
    jge     SHORT force_rp3_copy
    jmp     SHORT boundary_check


rp3_mismatch:

; if (i > best_repeated_offset)
    cmp     ecx, [esp + $best_repeat]
    jle     SHORT boundary_check

; do
;    enc_matchpos_table[++best_repeated_offset] = 2
; while (best_repeated_offset < i)

    mov     edi, [esp + $best_repeat]
    mov     ebx, [esp + $matchpos_table]

rp3_copy:                     
    inc     edi               ; ++best_repeated_offset
    mov     DWORD PTR [ebx + edi*4], 2
    cmp     edi, ecx          ; best_repeated_offset < i ? 
    jl      SHORT rp3_copy


;
; Check that our match length does not cause us
; to cross a 32K boundary, and truncate if necessary.
;

; bytes_to_boundary = 32767 - (BufPos & 32767)
boundary_check:

    mov     edx, 32767
    and     esi, 32767
    mov     eax, [esp + $match_length]
    sub     edx, esi   ; edx = 32767 - (BufPos & 32767)

;
; if (matchlength <= bytes_to_boundary)
;    then we're ok
;
    cmp     eax, edx
    jle     SHORT does_not_cross

;
; otherwise we have to truncate the match
;
    mov     eax, edx

;
; if we truncate the match, does it become
; smaller than MIN_MATCH?
;
    cmp     edx, MIN_MATCH
    jge     SHORT ge_min_match

;
; yes, so we return that no matches at all
; were found
;
    xor     eax, eax

ge_min_match:
does_not_cross:

;
; return our match length in eax
;

cleanup:
    add     esp, LOCAL_STACK

    pop     ebp
    pop     edi
    pop     esi
    pop     edx
    pop     ecx
    pop     ebx

    ret     0



;
; ptr <= endpos
;
ptr_le_endpos:

;
; left[BufPos] = right[BufPos] = 0
;
    xor     eax, eax ; return match length zero

    mov     ecx, [ebp + OFF_LEFT]
    mov     edx, [ebp + OFF_RIGHT]

    mov     [ecx + esi*4], eax
    mov     [edx + esi*4], eax

; cleanup
    add     esp, LOCAL_STACK

    pop     ebp
    pop     edi

    pop     esi
    pop     edx

    pop     ecx
    pop     ebx

    ret     0


_binary_search_findmatch ENDP
_TEXT ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\optenc.c ===
/*
 * optenc.c
 *
 * Encoder for optimal parser
 *
 *
 * Future Improvements:
 *
 * When two estimations are equal, for example, "should I output a
 * character or a match?" there should be some way of deciding
 * which to take.  Right now we force it to output a match, but
 * for text files, outputting a character results in a small
 * savings.  Even when comparing two matches, we might want to
 * force it to take one type of match over another.
 */

#include "encoder.h"

#define copymem(src,dst,size) memmove(dst,src,size)


static bool			redo_first_block(t_encoder_context *context, long *bufpos_ptr);
static void			block_end(t_encoder_context *context, long BufPos);


/*
 * encode a match of length <len> (where <len> >=2), and position <pos>
 */
#define OUT_MATCH(len,pos) \
{ \
   context->enc_ItemType[(context->enc_literals >> 3)] |= (1 << (context->enc_literals & 7));	\
   context->enc_LitData [context->enc_literals++]  = (byte) (len-2);							\
   context->enc_DistData[context->enc_distances++] = pos;										\
}


/* encode a character */																		
#define OUT_CHAR(ch) \
	context->enc_LitData [context->enc_literals++] = ch;


#define TREE_CREATE_CHECK()						\
if (context->enc_literals >= context->enc_next_tree_create)			\
{												\
	update_tree_estimates(context);\
	context->enc_next_tree_create += TREE_CREATE_INTERVAL;	\
}												


/*
 * Returns an estimation of how many bits it would take to output
 * a given character
 */
#define CHAR_EST(c) (numbits_t) (context->enc_main_tree_len[(c)])


/*
 * Returns an estimation of how many bits it would take to output
 * a given match.
 *
 * <ml> is the match length, where ml >= 2
 * <mp> is the match position
 *
 * The result is stored in <result>
 */
#define MATCH_EST(ml,mp,result) \
{ \
	byte mp_slot;														\
	mp_slot = (byte) MP_SLOT(mp);										\
	if (ml < (NUM_PRIMARY_LENGTHS+2))									\
	{																	\
		result = (numbits_t)											\
			(context->enc_main_tree_len[(NUM_CHARS-2)+(mp_slot<<NL_SHIFT)+ml] +	\
			enc_extra_bits[mp_slot]);									\
	}																	\
	else																\
	{																	\
		result = (numbits_t)											\
			(context->enc_main_tree_len[(NUM_CHARS+NUM_PRIMARY_LENGTHS)+(mp_slot<<NL_SHIFT)] + \
			context->enc_secondary_tree_len[ml-(NUM_PRIMARY_LENGTHS+2)] +	\
			enc_extra_bits[mp_slot]);									\
	}																	\
}


#ifdef DIAMOND_DEBUG
static void VERIFY_MATCH(
    t_encoder_context   *context,
    long                bufpos,
    int                 largest_match_len
)
{
    int     i, j;
    ulong   match_pos;

    /*
     * Ensure match does not cross boundary
     */
    _ASSERTE(
        largest_match_len <=
        (CHUNK_SIZE-1) - (bufpos & (CHUNK_SIZE-1))
    );

    for (i = MIN_MATCH; i <= largest_match_len; i++)
    {
        match_pos = context->enc_matchpos_table[i];

        if (match_pos < NUM_REPEATED_OFFSETS)
            match_pos = context->enc_last_matchpos_offset[match_pos];
		else
			match_pos -= (NUM_REPEATED_OFFSETS-1);

        _ASSERTE (match_pos <= context->enc_window_size-4);

        for (j = 0; j < i; j++)
        {
            _ASSERTE (
                context->enc_MemWindow[bufpos+j] ==
                context->enc_MemWindow[bufpos-match_pos+j]
            );
        }
    }
}
#else
#   define VERIFY_MATCH(a,b,c) ;
#endif


void flush_all_pending_blocks(t_encoder_context *context)
{
	/*
	 * Force all blocks to be output
	 */
	while (context->enc_literals > 0)
		output_block(context);

	/*
	 * Flush compressed data out to the caller
	 */
	perform_flush_output_callback(context);
}


void encoder_start(t_encoder_context *context)
{
	long BytesRead, RealBufPos;

	/*
	 * RealBufPos is our position in the window,
	 * and equals [0...window_size + second_partition_size - 1]
	 */
#ifdef STRICT_POINTERS
	RealBufPos = context->enc_BufPos - (long)((((ulong) context->enc_RealMemWindow) - ((ulong) context->enc_MemWindow)));   //BC6
#else
	RealBufPos = context->enc_BufPos - (long)(context->enc_RealMemWindow - context->enc_MemWindow);
#endif

	BytesRead = comp_read_input(context, RealBufPos, CHUNK_SIZE);

	if (BytesRead > 0)
		opt_encode_top(context, BytesRead);
}


static void update_tree_estimates(t_encoder_context *context)
{
	if (context->enc_literals)
	{
		/*
		 * Get stats on literals from 0...context->enc_literals
		 */
		if (context->enc_need_to_recalc_stats)
		{
			/*
			 * Cumulative total was destroyed, so need to
			 * recalculate
			 */
			get_block_stats(
				context,
				0,
				0,
				context->enc_literals
			);

			context->enc_need_to_recalc_stats = false;
		}
		else
		{
			/*
			 * Add stats from last_literals...context->enc_literals
			 * to cumulative total
			 */
			update_cumulative_block_stats(
				context,
				context->enc_last_literals,
				context->enc_last_distances,
				context->enc_literals
			);
		}

		create_trees(context, false); /* don't generate codes */

		fix_tree_cost_estimates(context);

		/*
		 * For cumulative total
		 */
		context->enc_last_literals = context->enc_literals;
		context->enc_last_distances = context->enc_distances;
	}
}


void opt_encode_top(t_encoder_context *context, long BytesRead)
{
	ulong	BufPos;
	ulong	RealBufPos;
	ulong	BufPosEnd;
	ulong	BufPosEndThisChunk;
	ulong	MatchPos;
	ulong	i;
	ulong	end_pos;
	int		EncMatchLength; /* must be a signed number */

	/*
	 * Current position in encoding window
	 */
	BufPos          = context->enc_BufPos;

	/*
	 * Stop encoding when we reach here
	 */
	BufPosEnd       = context->enc_BufPos + BytesRead;

	/*
	 * If this is our first time in here (since a new group), then
	 * when we reach this many literals, update our tree cost
	 * estimates.
	 *
	 * Also, output the file size we're using for translation
	 * (0 means no translation at all, which will speed things up
	 * for the decoder).
	 */
	if (context->enc_first_time_this_group)
	{
		context->enc_first_time_this_group = false;

		/*
		 * Recreate trees when we reach this many literals
		 */
		context->enc_next_tree_create = 10000;

		if (context->enc_file_size_for_translation)
		{
			output_bits(context, 1, 1); /* translation */

			output_bits(context, 16, context->enc_file_size_for_translation >> 16);
			output_bits(context, 16, context->enc_file_size_for_translation & 65535);
		}
		else
		{
			output_bits(context, 1, 0); /* no translation */
		}
	}
	else
	{
		/*
		 * If this is our second or later time in here, then add in the
		 * strings we removed last time.
		 *
         * We have to be careful here, though, because end_pos is
         * equal to our current BufPos - window_size, not
         * BufPos - i - window_size; we don't have that much history
         * around.
		 */
		for (i = BREAK_LENGTH; i > 0; i--)
            quick_insert_bsearch_findmatch(
                context,
                BufPos - (long) i,
                BufPos - context->enc_window_size+4
            );
	}

	while (1)
	{

top_of_main_loop:

		/*
		 * While we haven't reached the end of the data
		 */
		while (BufPos < BufPosEnd)
		{
			/*
			 * tommcg -- BufPos can "back up" when redo_first_block() is
			 *           called, leaving a larger-than-32K difference between
			 *           BufPos and BufPosEnd.  To prevent matches from
			 *           spanning this 32K boundary, use BufPosEndThisChunk
			 *           to mark the end of the "current" 32K chunk.
			 */

			BufPosEndThisChunk = ( BufPos + CHUNK_SIZE ) & ~( CHUNK_SIZE - 1 );

			if (BufPosEndThisChunk > BufPosEnd) {
				BufPosEndThisChunk = BufPosEnd;
				}

			/*
			 * Search for matches of all different possible lengths, at BufPos
			 */
			EncMatchLength = binary_search_findmatch(context, BufPos);

			if (EncMatchLength < MIN_MATCH)
			{

output_literal:

				/*
				 * No match longer than 1 character exists in the history
				 * window, so output the character at BufPos as a symbol.
				 */
#ifdef STRICT_POINTERS
				OUT_CHAR(context->enc_RealMemWindow[BufPos - SLIDE]); //BC6
#else
				OUT_CHAR(context->enc_MemWindow[BufPos]);
#endif
				BufPos++;

				/*
				 * Check for exceeding literal buffer
				 */
				if (context->enc_literals >= (MAX_LITERAL_ITEMS-8))
					block_end(context, BufPos);

				continue;
			}

			/*
			 * Found a match.
			 *
			 * Make sure it cannot exceed the end of the buffer.
			 */
			if ((ulong) EncMatchLength + BufPos > BufPosEndThisChunk)
			{
				EncMatchLength = BufPosEndThisChunk - BufPos;

				/*
				 * Oops, not enough for even a small match, so we
				 * have to output a literal
				 */
				if (EncMatchLength < MIN_MATCH)
					goto output_literal;
			}

            VERIFY_MATCH(context, BufPos, EncMatchLength);

			if (EncMatchLength < FAST_DECISION_THRESHOLD)
			{
				/*
				 *  A match has been found that is between MIN_MATCH and
				 *  FAST_DECISION_THRESHOLD bytes in length.  The following
				 *  algorithm is the optimal encoder that will determine the
				 *  most efficient order of matches and unmatched characters
				 *  over a span area defined by LOOK.
				 *
				 *  The code is essentially a shortest path determination
				 *  algorithm.  A stream of data can be encoded in a vast number
				 *  of different ways depending on the match lengths and offsets
				 *  chosen.  The key to good compression ratios is to chose the
				 *  least expensive path.
				 */
				ulong		span;
				ulong		epos, bpos, NextPrevPos, MatchPos;
				decision_node *decision_node_ptr;
				long		iterations;

				/*
				 * Points to the end of the area covered by this match; the span
				 * will continually be extended whenever we find more matches
				 * later on.  It will stop being extended when we reach a spot
				 * where there are no matches, which is when we decide which
				 * path to take to output the matches.
				 */
				span = BufPos + EncMatchLength;

				/*
				 * The furthest position into which we will do our lookahead parsing
				 */
				epos = BufPos + LOOK;

				/*
				 * Temporary BufPos variable
				 */
				bpos = BufPos;


				/*
				 * Calculate the path to the next character if we output
				 * an unmatched symbol.
				 */

				/* bits required to get here */
#ifdef STRICT_POINTERS
				context->enc_decision_node[1].numbits = CHAR_EST(context->enc_RealMemWindow[BufPos - SLIDE]);
#else
				context->enc_decision_node[1].numbits = CHAR_EST(context->enc_MemWindow[BufPos]);
#endif
				
				/* where we came from */
				context->enc_decision_node[1].path    = BufPos;


				/*
				 * For the match found, estimate the cost of encoding the match
				 * for each possible match length, shortest offset combination.
				 *
				 * The cost, path and offset is stored at BufPos + Length.
				 */
				for (i = MIN_MATCH; i <= (ulong) EncMatchLength; i++)
				{
					/*
					 * Get estimation of match cost given match length = i,
					 * match position = context->enc_matchpos_table[i], and store
					 * the result in context->enc_numbits[i]
					 */
					MATCH_EST(i, context->enc_matchpos_table[i], context->enc_decision_node[i].numbits);

					/*
					 * Where we came from
					 */
					context->enc_decision_node[i].path = BufPos;

					/*
					 * Associated match position with this path
					 */
					context->enc_decision_node[i].link = context->enc_matchpos_table[i];
				}


				/*
				 * Set bit counter to zero at the start
				 */
				context->enc_decision_node[0].numbits = 0;

				/*
				 * Initialise relative match position tables
				 *
				 * Really context->enc_repeated_offset_table[BufPos-bpos][x], but here
				 * BufPos == bpos
				 */
				context->enc_decision_node[0].repeated_offset[0] = context->enc_last_matchpos_offset[0];
				context->enc_decision_node[0].repeated_offset[1] = context->enc_last_matchpos_offset[1];
				context->enc_decision_node[0].repeated_offset[2] = context->enc_last_matchpos_offset[2];

#ifdef STRICT_POINTERS
				decision_node_ptr = &context->enc_decision_node[0];

#define rpt_offset_ptr(where,which_offset) decision_node_ptr[(where) - bpos].repeated_offset[(which_offset)]
#else
				decision_node_ptr = &context->enc_decision_node[-(long) bpos];

#define rpt_offset_ptr(where,which_offset) decision_node_ptr[(where)].repeated_offset[(which_offset)]
#endif

				while (1)
				{
					numbits_t est, cum_numbits;

					BufPos++;
	

					/*
					 *  Set the proper repeated offset locations depending on the
					 *  shortest path to the location prior to searching for a
					 *  match.
					 */


					/*
					 * If this is a match (i.e. path skips over more
					 * than one character).
					 */
#ifdef STRICT_POINTERS
					if (decision_node_ptr[BufPos - bpos].path != (ulong) (BufPos-1))
					{
						ulong LastPos = decision_node_ptr[BufPos - bpos].path;
#else
					if (decision_node_ptr[BufPos].path != (ulong) (BufPos-1))
					{
						ulong LastPos = decision_node_ptr[BufPos].path;
#endif

						/*
						 * link_ptr[BufPos] is the match position for this
						 * location
						 */
#ifdef STRICT_POINTERS
						if (decision_node_ptr[BufPos - bpos].link >= NUM_REPEATED_OFFSETS)
#else
						if (decision_node_ptr[BufPos].link >= NUM_REPEATED_OFFSETS)
#endif
						{
#ifdef STRICT_POINTERS
							context->enc_last_matchpos_offset[0] = decision_node_ptr[BufPos - bpos].link-(NUM_REPEATED_OFFSETS-1);
#else
							context->enc_last_matchpos_offset[0] = decision_node_ptr[BufPos].link-(NUM_REPEATED_OFFSETS-1);
#endif
							context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
							context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,1);
						}
#ifdef STRICT_POINTERS
						else if (decision_node_ptr[BufPos - bpos].link == 0)
#else
						else if (decision_node_ptr[BufPos].link == 0)
#endif
						{
							context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,0);
							context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
							context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
						}
#ifdef STRICT_POINTERS
						else if (decision_node_ptr[BufPos - bpos].link == 1)
#else
						else if (decision_node_ptr[BufPos].link == 1)
#endif
						{
							context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,1);
							context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,0);
							context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,2);
						}
						else /* == 2 */
						{
							context->enc_last_matchpos_offset[0] = rpt_offset_ptr(LastPos,2);
							context->enc_last_matchpos_offset[1] = rpt_offset_ptr(LastPos,1);
							context->enc_last_matchpos_offset[2] = rpt_offset_ptr(LastPos,0);
						}
					}

					rpt_offset_ptr(BufPos,0) = context->enc_last_matchpos_offset[0];
					rpt_offset_ptr(BufPos,1) = context->enc_last_matchpos_offset[1];
					rpt_offset_ptr(BufPos,2) = context->enc_last_matchpos_offset[2];

					/*
					 * The following is one of the two possible break points from
					 * the inner encoding loop.  This break will exit the loop if
					 * a point is reached that no match can incorporate; i.e. a
					 * character that does not match back to anything is a point
					 * where all possible paths will converge and the longest one
					 * can be chosen.
					 */
					if (span == BufPos)
						break;
					
					/*
					 * Search for matches at BufPos
					 */
					EncMatchLength = binary_search_findmatch(context, BufPos);

					/*
					 * Make sure that the match does not exceed the stop point
					 */
					if ((ulong) EncMatchLength + BufPos > BufPosEndThisChunk)
					{
						EncMatchLength = BufPosEndThisChunk - BufPos;
						
						if (EncMatchLength < MIN_MATCH)
							EncMatchLength = 0;
					}

                    VERIFY_MATCH(context, BufPos, EncMatchLength);

					/*
					 * If the match is very long or it exceeds epos (either
					 * surpassing the LOOK area, or exceeding past the end of the
					 * input buffer), then break the loop and output the path.
					 */
					if (EncMatchLength > FAST_DECISION_THRESHOLD ||
						BufPos + (ulong) EncMatchLength >= epos)
					{
						MatchPos = context->enc_matchpos_table[EncMatchLength];

#ifdef STRICT_POINTERS
						decision_node_ptr[BufPos+EncMatchLength - bpos].link = MatchPos;
						decision_node_ptr[BufPos+EncMatchLength - bpos].path = BufPos;
#else
						decision_node_ptr[BufPos+EncMatchLength].link = MatchPos;
						decision_node_ptr[BufPos+EncMatchLength].path = BufPos;
#endif

						/*
						 * Quickly insert data into the search tree without
						 * returning match positions/lengths
						 */
#ifndef INSERT_NEAR_LONG_MATCHES
						if (MatchPos == 3 && EncMatchLength > 16)
						{
							/*
							 * If we found a match 1 character away and it's
							 * length 16 or more, it's probably a string of
							 * zeroes, so don't insert that into the search
							 * engine, since doing so can slow things down
							 * significantly!
							 */
							quick_insert_bsearch_findmatch(
                                context,
                                BufPos + 1,
                                BufPos - context->enc_window_size + (1 + 4) /* bp+1 -(ws-4) */
                            );
						}
						else
						{
#endif
							for (i = 1; i < (ulong) EncMatchLength; i++)
								quick_insert_bsearch_findmatch(
                                    context,
                                    BufPos + i,
                                    BufPos + i - context->enc_window_size + 4
                                 );
						}

						BufPos += EncMatchLength;

						/*
						 * Update the relative match positions
						 */
						if (MatchPos >= NUM_REPEATED_OFFSETS)
						{
							context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
							context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
							context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
						}
						else if (MatchPos)
						{
							ulong t = context->enc_last_matchpos_offset[0];
							context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
							context->enc_last_matchpos_offset[MatchPos] = t;
						}

						break;
					}


					/*
					 * The following code will extend the area spanned by the
					 * set of matches if the current match surpasses the end of
					 * the span.  A match of length two that is far is not
					 * accepted, since it would normally be encoded as characters,
					 * thus allowing the paths to converge.
					 */
					if (EncMatchLength > 2 ||
                        (EncMatchLength == 2 && context->enc_matchpos_table[2] < BREAK_MAX_LENGTH_TWO_OFFSET))
					{
						if (span < (ulong) (BufPos + EncMatchLength))
						{
							long end;
							long i;

							end = min(BufPos+EncMatchLength-bpos, LOOK-1);

							/*
							 * These new positions are undefined for now, since we haven't
							 * gone there yet, so put in the costliest value
							 */
							for (i = span-bpos+1; i <= end; i++)
								context->enc_decision_node[i].numbits = (numbits_t) -1;

							span = BufPos + EncMatchLength;
						}
					}


					/*
					 *  The following code will iterate through all combinations
					 *  of match lengths for the current match.  It will estimate
					 *  the cost of the path from the beginning of LOOK to
					 *  BufPos and to every locations spanned by the current
					 *  match.  If the path through BufPos with the found matches
					 *  is estimated to take fewer number of bits to encode than
					 *  the previously found match, then the path to the location
					 *  is altered.
					 *
					 *  The code relies on accurate estimation of the cost of
					 *  encoding a character or a match.  Furthermore, it requires
					 *  a search engine that will store the smallest match offset
					 *  of each possible match length.
					 *
					 *  A match of length one is simply treated as an unmatched
					 *  character.
					 */

					/*
					 *  Get the estimated number of bits required to encode the
					 *  path leading up to BufPos.
					 */
#ifdef STRICT_POINTERS
					cum_numbits = decision_node_ptr[BufPos - bpos].numbits;
#else
					cum_numbits = decision_node_ptr[BufPos].numbits;
#endif


					/*
					 *  Calculate the estimated cost of outputting the path through
					 *  BufPos and outputting the next character as an unmatched byte
					 */
#ifdef STRICT_POINTERS
					est = cum_numbits + CHAR_EST(context->enc_RealMemWindow[BufPos - SLIDE]);
#else
					est = cum_numbits + CHAR_EST(context->enc_MemWindow[BufPos]);
#endif


					/*
					 *  Check if it is more efficient to encode the next character
					 *  as an unmatched character rather than the previously found
					 *  match.  If so, then update the cheapest path to BufPos + 1.
					 *
					 *  What happens if est == numbits[BufPos-bpos+1]; i.e. it
					 *  works out as well to output a character as to output a
					 *  match?  It's a tough call; however, we will push the
					 *  encoder to use matches where possible.
					 */
#ifdef STRICT_POINTERS
					if (est < decision_node_ptr[BufPos+1 - bpos].numbits)
#else
					if (est < decision_node_ptr[BufPos+1].numbits)
#endif
					{
#ifdef STRICT_POINTERS
						decision_node_ptr[BufPos+1 - bpos].numbits = est;
						decision_node_ptr[BufPos+1 - bpos].path    = BufPos;
#else
						decision_node_ptr[BufPos+1].numbits = est;
						decision_node_ptr[BufPos+1].path    = BufPos;
#endif
					}


					/*
					 *	Now, iterate through the remaining match lengths and
					 *  compare the new path to the existing.  Change the path
					 *  if it is found to be more cost effective to go through
					 *  BufPos.
					 */
					for (i = MIN_MATCH; i <= (ulong) EncMatchLength; i++)
					{
						MATCH_EST(i, context->enc_matchpos_table[i], est);
						est += cum_numbits;

						/*
						 * If est == numbits[BufPos+i] we want to leave things
						 * alone, since this will tend to force the matches
						 * to be smaller in size, which is beneficial for most
						 * data.
						 */
#ifdef STRICT_POINTERS
						if (est < decision_node_ptr[BufPos+i - bpos].numbits)   //BC6: uninitialized  BUGBUG2
						{
							decision_node_ptr[BufPos+i - bpos].numbits	= est;
							decision_node_ptr[BufPos+i - bpos].path	= BufPos;
							decision_node_ptr[BufPos+i - bpos].link	= context->enc_matchpos_table[i];
						}
#else
						if (est < decision_node_ptr[BufPos+i].numbits)
						{
							decision_node_ptr[BufPos+i].numbits	= est;
							decision_node_ptr[BufPos+i].path	= BufPos;
							decision_node_ptr[BufPos+i].link	= context->enc_matchpos_table[i];
						}
#endif
					}
				} /* continue to loop through span of matches */


				/*
				 *  Here BufPos == span, ie. a non-matchable character found.  The
				 *  following code will output the path properly.
				 */


				/*
				 *  Unfortunately the path is stored in reverse; how to get from
				 *  where we are now, to get back to where it all started.
				 *
				 *  Traverse the path back to the original starting position
				 *  of the LOOK span.  Invert the path pointers in order to be
				 *  able to traverse back to the current position from the start.
				 */

				/*
				 * Count the number of iterations we did, so when we go forwards
				 * we'll do the same amount
				 */
				iterations = 0;

#ifdef STRICT_POINTERS
				NextPrevPos = decision_node_ptr[BufPos - bpos].path;
#else
				NextPrevPos = decision_node_ptr[BufPos].path;
#endif

   				do
				{
					ulong	PrevPos;

      				PrevPos = NextPrevPos;

#ifdef STRICT_POINTERS
      				NextPrevPos = decision_node_ptr[PrevPos - bpos].path;   //BUGBUG BC6 says uninitialized!
      				decision_node_ptr[PrevPos - bpos].path = BufPos;        // (when PrevPos == bpos)
#else
      				NextPrevPos = decision_node_ptr[PrevPos].path;
      				decision_node_ptr[PrevPos].path = BufPos;
#endif

      				BufPos = PrevPos;
      				iterations++;
   				} while (BufPos != bpos);


                /*
                 *  There's no assurance that block_end will make enough space, so
                 *  we may need to repeat the call until there is.
                 */
				while (context->enc_literals + iterations >= (MAX_LITERAL_ITEMS-8) ||
					context->enc_distances + iterations >= (MAX_DIST_ITEMS-8))
				{
					block_end(context, BufPos);
				}

				/*
				 * Traverse from the beginning of the LOOK span to the end of
				 * the span along the stored path, outputting matches and
				 * characters appropriately.
				 */
   				do
   				{
#ifdef STRICT_POINTERS
      				if (decision_node_ptr[BufPos - bpos].path > BufPos+1)
#else
      				if (decision_node_ptr[BufPos].path > BufPos+1)
#endif
      				{
						/*
						 * Path skips over more than 1 character; therefore it's a match
						 */
#ifdef STRICT_POINTERS
						OUT_MATCH(
							decision_node_ptr[BufPos - bpos].path - BufPos,
							decision_node_ptr[ decision_node_ptr[BufPos - bpos].path  - bpos].link
						);

						BufPos = decision_node_ptr[BufPos - bpos].path;
#else
						OUT_MATCH(
							decision_node_ptr[BufPos].path - BufPos,
							decision_node_ptr[ decision_node_ptr[BufPos].path ].link
						);

						BufPos = decision_node_ptr[BufPos].path;
#endif
					}
      				else
      				{
						/*
						 * Path goes to the next character; therefore it's a symbol
						 */
#ifdef STRICT_POINTERS
						OUT_CHAR(context->enc_RealMemWindow[BufPos - SLIDE]);
#else
						OUT_CHAR(context->enc_MemWindow[BufPos]);
#endif
						BufPos++;
					}
   				} while (--iterations != 0);

				TREE_CREATE_CHECK();

				/*
				 * If we're filling up, and are close to outputting a block,
				 * and it's the first block, then recompress the first N
				 * literals using our accumulated stats.
				 */
				if (context->enc_first_block &&
					(context->enc_literals >= (MAX_LITERAL_ITEMS-512)
					|| context->enc_distances >= (MAX_DIST_ITEMS-512)))
				{
					if (redo_first_block(context, &BufPos))
						goto top_of_main_loop;

					/*
					 * Unable to redo, so output the block
					 */
					block_end(context, BufPos);
				}
			}
			else  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
			{
				/*
				 *  This code reflects a speed optimization that will always take
				 *  a match of length >= FAST_DECISION_THRESHOLD characters.
				 */

				/*
				 * The position associated with the match we found
				 */
				MatchPos = context->enc_matchpos_table[EncMatchLength];

				/*
				 * Quickly insert match substrings into search tree
				 * (don't look for new matches; just insert the strings)
				 */
#ifndef INSERT_NEAR_LONG_MATCHES
				if (MatchPos == 3 && EncMatchLength > 16)
				{
					quick_insert_bsearch_findmatch(
                        context,
                        BufPos + 1,
                        BufPos - context->enc_window_size + 5 /* bp+1 -(ws-4) */
                    );
				}
				else
#endif
				{
					for (i = 1; i < (ulong) EncMatchLength; i++)
						quick_insert_bsearch_findmatch(
                            context,
                            BufPos + i,
                            BufPos + i - context->enc_window_size + 4
                         );
				}

				/*
				 * Advance our position in the window
				 */
				BufPos += EncMatchLength;

				/*
				 * Output the match
				 */
				OUT_MATCH(EncMatchLength, MatchPos);

				if (MatchPos >= NUM_REPEATED_OFFSETS)
				{
					context->enc_last_matchpos_offset[2] = context->enc_last_matchpos_offset[1];
					context->enc_last_matchpos_offset[1] = context->enc_last_matchpos_offset[0];
					context->enc_last_matchpos_offset[0] = MatchPos-(NUM_REPEATED_OFFSETS-1);
				}
				else if (MatchPos)
				{
					ulong t = context->enc_last_matchpos_offset[0];
					context->enc_last_matchpos_offset[0] = context->enc_last_matchpos_offset[MatchPos];
					context->enc_last_matchpos_offset[MatchPos] = t;
				}

				/*
				 * Check to see if we're close to overflowing our output arrays, and
				 * output a block if this is the case
				 */
				if (context->enc_literals >= (MAX_LITERAL_ITEMS-8) ||
					context->enc_distances >= (MAX_DIST_ITEMS-8))
					block_end(context, BufPos);

			}  /* EncMatchLength >= FAST_DECISION_THRESHOLD */

		} /* end while ... BufPos <= BufPosEnd */

		/*
         * Value of BufPos corresponding to earliest window data
		 */
		context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

		/*
		 * We didn't read 32K, so we know for sure that
		 * this was our last block of data.
		 */
		if (BytesRead < CHUNK_SIZE)
		{
			/*
			 * If we have never output a block, and we haven't
			 * recalculated the stats already, then recalculate
			 * the stats and recompress.
			 */
			if (context->enc_first_block)
			{
				if (redo_first_block(context, &BufPos))
					goto top_of_main_loop;
			}

			break;
		}

		/*
		 * Remove the last BREAK_LENGTH nodes from the binary search tree,
		 * since we have been inserting strings which contain undefined
		 * data at the end.
		 */
		end_pos = BufPos - (context->enc_window_size-4-BREAK_LENGTH);

		for (i = 1; (i <= BREAK_LENGTH); i++)
			binary_search_remove_node(context, BufPos-i, end_pos);

		/*
		 * If we're still in the first window_size + second partition size
		 * bytes in the file then we don't need to copymem() yet.
		 *
		 * RealBufPos is the real position in the file.
		 */
#ifdef STRICT_POINTERS
		RealBufPos = BufPos - (((ulong) (context->enc_RealMemWindow)) - ((ulong) (context->enc_MemWindow)));
#else
		RealBufPos = BufPos - (ulong)(context->enc_RealMemWindow - context->enc_MemWindow);
#endif
		
		if (RealBufPos < context->enc_window_size + context->enc_encoder_second_partition_size)
			break;

		/*
		 * We're about to trash a whole bunch of history with our copymem,
		 * so we'd better redo the first block now if we are ever going to.
		 */
		if (context->enc_first_block)
		{
			if (redo_first_block(context, &BufPos))
				goto top_of_main_loop;
		}

		/*
		 *  We're about to remove a large number of symbols from the window.
		 *  Test to see whether, if we were to output a block now, our compressed
		 *  output size would be larger than our uncompressed data.  If so, then
		 *  we will output an uncompressed block.
		 *
		 *  The reason we have to do this check here, is that data in the
		 *  window is about to be destroyed.  We can't simply put this check in
		 *  the block outputting code, since there is no guarantee that the
		 *  memory window contents corresponding to everything in that block,
		 *  are still around - all we'd have would be a set of literals and
		 *  distances, when we need all the uncompressed literals to output
		 *  an uncompressed block.
		 */

		/*
		 *  What value of bufpos corresponds to the oldest data we have in the
		 *  buffer?
		 *
		 *  After the memory copy, that will be the current buffer position,
		 *  minus window_size.
		 */

		/*
		 * The end of the data buffer is reached, more data needs to be read
		 * and the existing data must be shifted into the history window.
		 *
		 * MSVC 4.x generates code which does REP MOVSD so no need to
		 * write this in assembly.
		 */
		copymem(
			&context->enc_RealMemWindow[context->enc_encoder_second_partition_size],
			&context->enc_RealMemWindow[0],
			context->enc_window_size
		);

		copymem(
			&context->enc_RealLeft[context->enc_encoder_second_partition_size],
			&context->enc_RealLeft[0],
			sizeof(ulong)*context->enc_window_size
		);

		copymem(
			&context->enc_RealRight[context->enc_encoder_second_partition_size],
			&context->enc_RealRight[0],
			sizeof(ulong)*context->enc_window_size
		);

		context->enc_earliest_window_data_remaining = BufPos - context->enc_window_size;

		/*
		 *   The following bit of code is CRUCIAL yet unorthodox in function
		 *   and serves as a speed and syntax optimization and makes the code
		 *   easier to understand once grasped.
		 *
		 *   The three main buffers, context->enc_MemWindow, context->enc_Left and context->enc_Right,
		 *   are referensed by BufPos and SearchPos relative to the current
		 *   compression window locations.  When the encoder reaches the end
		 *   of its block of input memory, the data in the input buffer is
		 *   shifted into the compression history window and the new input
		 *   stream is loaded.  Typically the BufPos pointer would be reduced
		 *   to signify the replaced data.  However, this code reduces the
		 *   base pointers to reflect the shift of data, and leaves the BufPos
		 *   pointer in its current state.  Therefore, the BufPos pointer is
		 *   an absolute pointer reflecting the position in the input stream,
		 *   and NOT the position in the buffer.  The base pointers will point
		 *   to invalid memory locations with addresses smaller than the
		 *   actual array base pointers.  However, when the two pointers are
		 *   added together, &(context->enc_MemWindow+BufPos), it will point to the
		 *   correct and valid position in the buffer.
		 */

#ifdef STRICT_POINTERS
        /*
         *  we have to maintain these as in the non-STRICT_POINTERS case because
         *  the ASM code still depends on them, and because of how we defined SLIDE
         */

		(ulong) context->enc_MemWindow -= context->enc_encoder_second_partition_size * sizeof(context->enc_MemWindow[0]);
		(ulong) context->enc_Left      -= context->enc_encoder_second_partition_size * sizeof(context->enc_Left[0]);
		(ulong) context->enc_Right     -= context->enc_encoder_second_partition_size * sizeof(context->enc_Right[0]);
#else
		context->enc_MemWindow -= context->enc_encoder_second_partition_size;
		context->enc_Left      -= context->enc_encoder_second_partition_size;
		context->enc_Right     -= context->enc_encoder_second_partition_size;
#endif

		break;
	}

	/*
	 * Store BufPos in global variable
	 */
	context->enc_BufPos = BufPos;
}


static void block_end(t_encoder_context *context, long BufPos)
{
	context->enc_first_block			= false;
	context->enc_need_to_recalc_stats	= true;

	output_block(context);

	if (context->enc_literals < TREE_CREATE_INTERVAL)
	{
		context->enc_next_tree_create = TREE_CREATE_INTERVAL;
	}
	else
	{
		context->enc_next_tree_create = context->enc_literals + TREE_CREATE_INTERVAL; /* recreate right away */
	}

	context->enc_bufpos_last_output_block = BufPos;
}


static bool redo_first_block(t_encoder_context *context, long *bufpos_ptr)
{
	long	start_at;
	long	earliest_can_start_at;
	long	pos_in_file;
	long	history_needed;
	long	history_avail;
	long	BufPos;
	long	split_at_literal;

	context->enc_first_block = false;

	BufPos = *bufpos_ptr;

	/*
	 * For the first context->enc_window size bytes in the file, we don't
	 * need to have context->enc_window size bytes around.
	 *
	 * For anything after that, though, we do need to have window_size
	 * previous bytes to look into.
	 */

	/*
	 * How many bytes are we into the file?
	 */
	pos_in_file = BufPos - context->enc_window_size;

	/*
	 * First let's figure out the total history required from
	 * BufPos backwards.  For starters, we need all the bytes
	 * we're going to recompress.  We get that by seeing the
	 * last time we output a block.
	 */
	history_needed = BufPos - context->enc_bufpos_last_output_block;

	/*
	 * Plus we will need window_size bytes before that (for matching
	 * into) unless we're looking within the first window_size
	 * bytes of the file.
	 */
	if (context->enc_bufpos_last_output_block-context->enc_window_size < context->enc_window_size)
		history_needed += context->enc_bufpos_last_output_block - context->enc_window_size;
	else
		history_needed += context->enc_window_size;

#ifdef STRICT_POINTERS
	history_avail = (long)(&context->enc_RealMemWindow[BufPos - SLIDE] - &context->enc_RealMemWindow[0]);
#else
	history_avail = (long)(&context->enc_MemWindow[BufPos] - &context->enc_RealMemWindow[0]);
#endif

	if (history_needed <= history_avail)
	{
		earliest_can_start_at = context->enc_bufpos_last_output_block;
	}
	else
	{
		/*
		 * Not enough history available
		 */
		return false;
	}

	start_at = earliest_can_start_at;

	(void) split_block(
		context,
		0,
		context->enc_literals,
		context->enc_distances,
		&split_at_literal,
		NULL /* don't need # distances returned */
	);

	get_block_stats(
		context,
		0,
		0,
		split_at_literal
	);

	create_trees(context, false); /* don't generate codes */
	fix_tree_cost_estimates(context);

#ifdef MULTIPLE_SEARCH_TREES
	/*
	 * Now set all the tree root pointers to NULL
	 * (don't need to reset the left/right pointers).
	 */
	memset(context->enc_tree_root, 0, NUM_SEARCH_TREES * sizeof(ulong));
#else
	context->enc_single_tree_root = 0;
#endif

	/*
	 * Clear item array and reset literal and distance
	 * counters
	 */
	memset(context->enc_ItemType, 0, (MAX_LITERAL_ITEMS/8));

	/*
	 * Reset encoder state
	 */
	context->enc_last_matchpos_offset[0] = 1;
	context->enc_last_matchpos_offset[1] = 1;
	context->enc_last_matchpos_offset[2] = 1;

	context->enc_repeated_offset_at_literal_zero[0] = 1;
	context->enc_repeated_offset_at_literal_zero[1] = 1;
	context->enc_repeated_offset_at_literal_zero[2] = 1;

	context->enc_input_running_total = 0;

	context->enc_literals      = 0;
	context->enc_distances     = 0;

	context->enc_need_to_recalc_stats = true;

	context->enc_next_tree_create = split_at_literal;

	*bufpos_ptr = start_at;

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\lci.c ===
/*
 * LCI.C
 */

/* --- preprocessor ------------------------------------------------------- */

#include <stdio.h>          /* for NULL */
#include <string.h>         /* for memcpy() */

#include "encoder.h"
#include "lci.h"            /* types, prototype verification, error codes */


/*
 * Default file size for E8 translation
 */
#define DEFAULT_FILE_XLAT_SIZE 12000000


/*  MAKE_SIGNATURE - Construct a structure signature
 *
 *  Entry:
 *      a,b,c,d - four characters
 *
 *  Exit:
 *      Returns constructed SIGNATURE
 *
 *  Example:
 *      strct->signature = MAKE_SIGNATURE('b','e','n','s')
 */

#define MAKE_SIGNATURE(a,b,c,d) (a + (b<<8) + (c<<16) + (d<<24))
#define BAD_SIGNATURE   (0L)
#define LCI_SIGNATURE   MAKE_SIGNATURE('L','C','I','C')

/* --- LCI context structure ---------------------------------------------- */

typedef ULONG SIGNATURE;    /* structure signature */

struct LCI_CONTEXT          /* private structure */
{
    SIGNATURE signature;    /* for validation */
    PFNALLOC pfnAlloc;      /* memory alloc function */
    PFNFREE pfnFree;        /* memory free function */
    UINT cbDataBlockMax;    /* promised max data size */
    unsigned long file_translation_size;
	t_encoder_context *encoder_context;
};

typedef struct LCI_CONTEXT FAR *PMCC_CONTEXT;       /* a pointer to one */

#define PMCCfromHMC(h) ((PMCC_CONTEXT)(h))          /* handle to pointer */
#define HMCfromPMCC(p) ((LCI_CONTEXT_HANDLE)(p))    /* pointer to handle */


/* --- local variables ---------------------------------------------------- */

int DIAMONDAPI LCICreateCompression(
        UINT *          pcbDataBlockMax,    /* max uncompressed data block */
        void FAR *      pvConfiguration,    /* implementation-defined */
        PFNALLOC        pfnma,              /* Memory allocation function */
        PFNFREE         pfnmf,              /* Memory free function */
        UINT *          pcbDstBufferMin,    /* gets required output buffer */
        LCI_CONTEXT_HANDLE * pmchHandle,    /* gets newly-created handle */
		int FAR (DIAMONDAPI *pfnlzx_output_callback)(
			void *			pfol,
			unsigned char *	compressed_data,
			long			compressed_size,
			long			uncompressed_size
        ),
       void FAR *      fci_data
)

{
    PMCC_CONTEXT			context;                   /* new context */
	FAR PLZXCONFIGURATION	plConfiguration;

    *pmchHandle = (LCI_CONTEXT_HANDLE) 0;   /* wait until it's valid */

	plConfiguration = (PLZXCONFIGURATION) pvConfiguration;

    context = pfnma(sizeof(struct LCI_CONTEXT));

    if (context == NULL)
        return(MCI_ERROR_NOT_ENOUGH_MEMORY);    /* if can't allocate */

    context->file_translation_size = DEFAULT_FILE_XLAT_SIZE;

	context->encoder_context = pfnma(sizeof(*context->encoder_context));

	if (context->encoder_context == NULL)
	{
		pfnmf(context);
        return(MCI_ERROR_NOT_ENOUGH_MEMORY);    /* if can't allocate */
	}

	if (LZX_EncodeInit(
			context->encoder_context,
			plConfiguration->WindowSize, 
			plConfiguration->SecondPartitionSize,
			pfnma,
			pfnmf,
            pfnlzx_output_callback,
            fci_data
			) == false)
	{
		pfnmf(context->encoder_context);
		pfnmf(context);
		return MCI_ERROR_NOT_ENOUGH_MEMORY;
	}

    context->pfnAlloc = pfnma;
    context->pfnFree  = pfnmf;
    context->cbDataBlockMax = *pcbDataBlockMax;   /* remember agreement */
    context->signature = LCI_SIGNATURE;

    *pcbDstBufferMin =                      /* we'll expand sometimes */
            *pcbDataBlockMax + MAX_GROWTH;

#ifdef __BOUNDSCHECKER__
    {
        static void * p;
        p = context;        //BC6 thinks we'll lose our cookies
    }
#endif

    /* pass context back to caller */
    *pmchHandle = HMCfromPMCC(context);

    return(MCI_ERROR_NO_ERROR);             /* tell caller all is well */
}


int DIAMONDAPI LCICompress(
        LCI_CONTEXT_HANDLE  hmc,            /* compression context */
        void FAR *          pbSrc,          /* source buffer */
        UINT                cbSrc,          /* source actual size */
        void FAR *          pbDst,          /* target buffer */
        UINT                cbDst,          /* size of target buffer */
        ULONG *             pcbResult)      /* gets target actual size */
{
    PMCC_CONTEXT context;                   /* pointer to the context */
	long	estimated_leftover_bytes;

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

    if (cbSrc > context->cbDataBlockMax)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* violated max block promise */
    }

    if (cbDst < (context->cbDataBlockMax + MAX_GROWTH))
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* violated min buffer request */
    }

	if (ENCODER_SUCCESS == LZX_Encode(
		context->encoder_context,
		pbSrc,
		cbSrc,
		&estimated_leftover_bytes,
        context->file_translation_size))
	{
		*pcbResult = estimated_leftover_bytes;
		return MCI_ERROR_NO_ERROR;
	}
	else
	{
		*pcbResult = 0;
		return MCI_ERROR_FAILED;
	}
}


int DIAMONDAPI LCIFlushCompressorOutput(LCI_CONTEXT_HANDLE hmc)
{
    PMCC_CONTEXT context;                   /* pointer to context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	(void) LZX_EncodeFlush(context->encoder_context);

	return MCI_ERROR_NO_ERROR;
}



/* --- LCIResetCompression() ---------------------------------------------- */

int DIAMONDAPI LCIResetCompression(LCI_CONTEXT_HANDLE hmc)
{
    PMCC_CONTEXT context;                   /* pointer to the context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
		return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	LZX_EncodeNewGroup(context->encoder_context);

    return(MCI_ERROR_NO_ERROR);             /* if tag is OK */
}


/* --- LCIDestroyCompression() -------------------------------------------- */

int DIAMONDAPI LCIDestroyCompression(LCI_CONTEXT_HANDLE hmc)
{
    PMCC_CONTEXT context;                   /* pointer to context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }

	LZX_EncodeFree(context->encoder_context);
	context->pfnFree(context->encoder_context);

    context->signature = BAD_SIGNATURE;     /* destroy signature */

    context->pfnFree(context);              /* self-destruct */

    return(MCI_ERROR_NO_ERROR);             /* success */
}


int DIAMONDAPI LCISetTranslationSize(LCI_CONTEXT_HANDLE hmc, unsigned long size)
{
    PMCC_CONTEXT context;                   /* pointer to context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        return(MCI_ERROR_BAD_PARAMETERS);   /* missing signature */
    }
       
    context->file_translation_size = size;
    return(MCI_ERROR_NO_ERROR);             /* success */
}


unsigned char * FAR DIAMONDAPI LCIGetInputData(
    LCI_CONTEXT_HANDLE hmc,
    unsigned long *input_position,
    unsigned long *bytes_available
)
{
    PMCC_CONTEXT context;                   /* pointer to context */

    context = PMCCfromHMC(hmc);             /* get pointer from handle */

    if (context->signature != LCI_SIGNATURE)
    {
        *bytes_available = 0;
        return (unsigned char *) NULL;
    }

    return LZX_GetInputData(context->encoder_context, input_position, bytes_available);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\lzx\encoder\tree.c ===
/*
 * tree.c
 *
 * Tree building routines.
 *
 * These routines are originally from the Public Domain source "AR001".
 *
 * However, they have been modified for use in LZX.
 */

#include "encoder.h"


/* Function prototypes */
static void downheap(t_encoder_context *context, short i);
static void make_tree2(t_encoder_context *context, short avail, ushort freqparm[], ushort codeparm[]);
static void make_len(t_encoder_context *context, short root);
static void make_code(t_encoder_context *context, int n, char len[], ushort code[]);


static void count_len(t_encoder_context *context, short i)  /* call with i = root */
{
	if (i < context->enc_tree_n)
		context->enc_tree_len_cnt[(context->enc_depth < 16) ? context->enc_depth : 16]++; /* NOTE: 16 is max len allowed */
	else
	{
		context->enc_depth++;
		count_len(context, context->enc_tree_leftright[i*2]);
		count_len(context, context->enc_tree_leftright[i*2+1]);
		context->enc_depth--;
	}
}


static void make_len(t_encoder_context *context, short root)
{
	signed short	k;
	ushort			cum;
	byte			i;

	for (i = 0; i <= 16; i++)
		context->enc_tree_len_cnt[i] = 0;

	count_len(context, root);

	cum = 0;

	for (i = 16; i > 0; i--)
		cum += (ushort) (context->enc_tree_len_cnt[i] << (16 - i));

	/* cum should equal 1<<16, which is 0 since cum is a ushort */
	while (cum)
	{
		context->enc_tree_len_cnt[16]--;

		for (i = 15; i > 0; i--)
		{
			if (context->enc_tree_len_cnt[i])
			{
				context->enc_tree_len_cnt[i]--;
				context->enc_tree_len_cnt[i+1] += 2;
				break;
			}
		}

		cum--;
	}

	for (i = 16; i > 0; i--)
	{
		k = context->enc_tree_len_cnt[i];

		while (--k >= 0)
			context->enc_len[*context->enc_tree_sortptr++] = (byte) i;
	}
}


static void __inline downheap(t_encoder_context *context, short i)
	/* priority queue; send i-th entry down heap */
{
	short  j, k;

	k = context->enc_tree_heap[i];

	while ((j = (i<<1)) <= context->enc_tree_heapsize)
	{
		if (j < context->enc_tree_heapsize &&
			context->enc_tree_freq[context->enc_tree_heap[j]] > context->enc_tree_freq[context->enc_tree_heap[j + 1]])
		 	j++;

		if (context->enc_tree_freq[k] <= context->enc_tree_freq[context->enc_tree_heap[j]])
			break;

		context->enc_tree_heap[i] = context->enc_tree_heap[j];
		i = j;
	}

	context->enc_tree_heap[i] = k;
}


static void make_code(t_encoder_context *context, int n, char len[], ushort code[])
{
    int    i;
	ushort start[18];

	start[0] = 0;   //BC6 we don't care about 0-length codes anyway
	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = (start[i] + context->enc_tree_len_cnt[i]) << 1;

	for (i = 0; i < n; i++)
	{
		code[i] = start[len[i]]++;
	}
}


void make_tree(
	t_encoder_context *context,
	int		nparm,
	ushort	*freqparm,
	byte	*lenparm,
	ushort	*codeparm,
	bool	make_codes	/* for estimations, we only want the lengths */
)
{
	short i, avail;

REDO_TREE:
	context->enc_tree_n			= nparm;
	context->enc_tree_freq		= freqparm;
	context->enc_len			= lenparm;
	avail				        = (short)context->enc_tree_n;
    context->enc_depth          = 0;
	context->enc_tree_heapsize	= 0;
	context->enc_tree_heap[1]	= 0;

	for (i = 0; i < nparm; i++)
	{
		context->enc_len[i] = 0;

		if (freqparm[i])
         context->enc_tree_heap[++context->enc_tree_heapsize] = i;
	}

	if (context->enc_tree_heapsize < 2)
	{
		if (!context->enc_tree_heapsize)
		{
			codeparm[context->enc_tree_heap[1]] = 0;
			return;
		}

		if (!context->enc_tree_heap[1])
			freqparm[1] = 1;
		else
			freqparm[0] = 1;

		goto REDO_TREE;
	}

	make_tree2(context, avail, freqparm, codeparm);

	if (make_codes)
		make_code(context, nparm, lenparm, codeparm);
}


static void make_tree2(
	t_encoder_context *context,
	short avail,
	ushort freqparm[],
	ushort codeparm[]
)
{
	short i, j, k;

	for (i = context->enc_tree_heapsize >> 1; i >= 1; i--)
		downheap(context, i);  /* make priority queue */

	context->enc_tree_sortptr = codeparm;

	do
	{	/* while queue has at least two entries */
		i = context->enc_tree_heap[1];  /* take out least-freq entry */

		if (i < context->enc_tree_n)
			*context->enc_tree_sortptr++ = i;

		context->enc_tree_heap[1] = context->enc_tree_heap[context->enc_tree_heapsize--];
		downheap(context, 1);

		j = context->enc_tree_heap[1];  /* next least-freq entry */

		if (j < context->enc_tree_n)
			*context->enc_tree_sortptr++ = j;

		k = avail++;  /* generate new node */

		freqparm[k] = freqparm[i] + freqparm[j];
		context->enc_tree_heap[1] = k;
		downheap(context, 1);  /* put into queue */

		context->enc_tree_leftright[k*2] = i;
		context->enc_tree_leftright[k*2+1] = j;

	} while (context->enc_tree_heapsize > 1);

	context->enc_tree_sortptr = codeparm;
	make_len(context, k);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\bootsnd.h ===
struct	DSPpatch {
	unsigned short *Start;				// address of start of sample
	unsigned short	Length;				// length of sample
	unsigned short	LoopStart;			// bytes from beg of sound to loop point 
	unsigned short	LoopLength;			// bytes form loop start to loop end
	unsigned short	LoopEnable;			// loop sound? T or F
	LPDSENVELOPEDESC		lpAmpEnvelope;
	LPDSENVELOPEDESC		lpMultiEnvelope;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\BlobRenderer.h ===
///////////////////////////////////////////////////////////////////////////////
// File: BlobRenderer.h
//
// Copyright 2001 Pipeworks Software
//
// WORK HALTED: Patent issues
//
///////////////////////////////////////////////////////////////////////////////
#ifndef BLOBRENDERER_H
#define BLOBRENDERER_H

#include "render_object.h"


// Adapted from: http://www.gamasutra.com/features/20000523/lander_01.htm
// Possibly in violation of US Patent #4,710,876
// http://164.195.100.11/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=/netahtml/search-bool.html&r=1&f=G&l=50&co1=AND&d=pall&s1='4710876'.WKU.&OS=PN/4710876&RS=PN/4710876



struct BlobVertex
{
	D3DVECTOR pos;
    D3DVECTOR normal;	// not normalized, do it in the GPU
	// Diffuse color is set as a constant.
};








class BlobSource
{
public:
	D3DVECTOR		ptPosition;
	float			fStrength;
	float			fConsiderationRadius;
	float			fConsiderationRadius2;
	int				dAffiliation;	// affiliation of -1 is never rendered, but does repulse

	inline float	calculate(int affiliation, const D3DVECTOR& pos) const
	{
		float dist2 = Distance2(ptPosition, pos);
		if (dist2 > fConsiderationRadius2) return 0.0f;
		float falloff = 1.0f - (dist2/fConsiderationRadius2);
		return ((affiliation==dAffiliation) ? 1.0f : -1.0f) * fStrength * falloff*falloff;
	}
};




class BlobRenderer : public RenderObject
{
protected:
	const BlobSource*		m_pSources;
	int m_NumBlobs;

	float					m_Threshhold;

    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;

    LPDIRECT3DVERTEXBUFFER8 m_pBlobVB;
    LPDIRECT3DINDEXBUFFER8  m_pBlobIB;
	


	float*		m_pField;
	int*		m_pVertexIndices;	// circular fifo which stores one layer of vertex indices
	int			m_FieldX, m_FieldY, m_FieldXY, m_FieldZ;		// number of entries in each field coord

	D3DVECTOR	m_LowerLeftCorner;
	D3DVECTOR	m_FieldToWorld;
	D3DVECTOR	m_WorldToField;

	int			getCoords(const D3DVECTOR& pos, int* p_x, int* p_y, int* p_z, D3DVECTOR* p_remainder=NULL);
	void		getWorldPos(D3DVECTOR* pos, int x, int y, int z);

public:
	BlobRenderer();
	~BlobRenderer();

	virtual bool isVisible() { return true; }
	virtual void destroy();

	virtual void render();
	virtual void advanceTime(float fElapsedTime, float fDt) {}

	
	void init(	const BlobSource* p_blob_sources, int num_blobs,
				float xy_spacing, float z_spacing,
				const D3DVECTOR& center, const D3DVECTOR& half_dim);

	void	getThreshhold() const	{ return m_Threshhold; }
	void	setThreshhold(float th)	{ m_Threshhold = th; }
};


class TestBlobRenderer : public BlobRenderer
{
protected:
	enum { NUM_BLOBS = 6 };
	BlobSource m_Sources[NUM_BLOBS];

public:
	TestBlobRenderer();
	~TestBlobRenderer();

	virtual void create();
	virtual void advanceTime(float fElapsedTime, float fDt);
};



#endif // BLOBRENDERER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\Blobs.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: Blobs.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include <xtl.h>
#include "xbs_math.h"
#include "xbs_app.h"
#include "qrand.h"
#include "Blobs.h"


const LavaLampInterior* LLBlob::spLL = NULL;
QRand LavaLampInterior::m_QRand;


void LavaLampInterior::destroy()
{
//MTS	m_BlobRenderer.destroy();

	for (int i=0; i<NUM_LLBLOBS; i++)
	{
		m_Blobs[i].destroy();
	}


    if( m_dwPixelShader )
    {
        gpd3dDev->DeletePixelShader( m_dwPixelShader );
        m_dwPixelShader = 0;
    }

	if ( m_dwVertexShader )
	{
		gpd3dDev->DeleteVertexShader( m_dwVertexShader );
		m_dwVertexShader = 0;
	}
}



LLBlob::LLBlob()
{
	m_pBlobVB = NULL;
	m_pBlobIB = NULL;
	m_Temperature = 0.5f;
	Set(&m_Accel, 0.0f, 0.0f, 0.0f);
	Set(&m_Velocity, 0.0f, 0.0f, 0.0f);
	m_DeformationInertia = 0.3f;
}



void LLBlob::destroy()
{
	if (m_pBlobVB)
	{
		m_pBlobVB->Release();
		m_pBlobVB = NULL;
	}

	if (m_pBlobIB)
	{
		m_pBlobIB->Release();
		m_pBlobIB = NULL;
	}
}


void LavaLampInterior::InitPixelShader()
{
    if( m_dwPixelShader )
    {
        gpd3dDev->DeletePixelShader( m_dwPixelShader );
        m_dwPixelShader = 0;
    }

	m_dwPixelShader = gApp.loadPixelShader("D:\\Shaders\\blob.xpu");
}







void LavaLampInterior::create()
{
	LLBlob::spLL = this;


	m_ConicSectionCenterX = +0.04f;
	m_ConicSectionCenterY = -0.082f;

	m_NumConicSections = 2;
	m_ConicSectionBotZ[0] = -0.47f;
	m_ConicSectionBotZ[1] = -0.25f;
	m_ConicSectionBotZ[2] = +0.35f;

	m_ConicSectionRadius[0] = 0.11f;
	m_ConicSectionRadius[1] = 0.25f;
	m_ConicSectionRadius[2] = 0.12f;


	int i;
	for (i=0; i<m_NumConicSections; i++)
	{
		m_ConicSectionSlope[i] =	(m_ConicSectionRadius[i+1] - m_ConicSectionRadius[i+0]) /
									(m_ConicSectionBotZ[i+1]   - m_ConicSectionBotZ[i+0]);
		float norm = 1.0f / sqrtf(1 + m_ConicSectionSlope[i]*m_ConicSectionSlope[i]);
		m_ConicSectionNormalR[i] = norm * -1.0f;
		m_ConicSectionNormalZ[i] = norm * m_ConicSectionSlope[i];
	}


    // Initialize pixel shader
    InitPixelShader();

    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),    // Position
        D3DVSD_END()
    };


	m_dwVertexShader = gApp.loadVertexShader("D:\\Shaders\\blob.xvu", dwShaderVertexDecl);



	float bot = m_ConicSectionBotZ[0];
	float sx = m_ConicSectionCenterX - 0.1f;
	float sy = m_ConicSectionCenterY - 0.1f;
	for (i=0; i<NUM_LLBLOBS; i++)
	{
		D3DVECTOR pos;
		D3DVECTOR4 color, base_color;
		Set(&pos, m_ConicSectionCenterX, m_ConicSectionCenterY, m_ConicSectionBotZ[m_NumConicSections>>1] );
		Set(&color, (i&0x04) ? 0.0f : 1.0f, (i&0x02) ? 0.0f : 1.0f, (i&0x01) ? 0.0f : 1.0f, 1.0f);
		Set(&base_color, 0.724f, 0.732f, 0.556f, 1.0f);
		
//MTS		m_Blobs[i].create(pos, color*0.1f + base_color*0.9f);
		m_Blobs[i].create(pos, base_color);
		m_Blobs[i].setSpecies(i);
	}


//MTS	m_BlobRenderer.create();
//MTS	m_BlobRenderer.init(this, &m_Blobs[0], NUM_LLBLOBS, 0.01f, 0.01f, m_ConicSectionCenterX, m_ConicSectionCenterY);

    return;
};


void LLBlob::calcFacePoint(D3DVECTOR* ppos, int face, int u, int v)
{
	float fu = (u==m_Subdivisions) ? +1.0f : -1.0f + m_fDivisionStep * ((float)u);
	float fv = (v==m_Subdivisions) ? +1.0f : -1.0f + m_fDivisionStep * ((float)v);
	switch(face)
	{
		case 0: Set(ppos, -1.0f, -fu, +fv); break;
		case 1: Set(ppos, +fv, -1.0f, -fu); break;
		case 2: Set(ppos, -fu, +fv, -1.0f); break;
		case 3: Set(ppos, +1.0f, +fu, +fv); break;
		case 4: Set(ppos, +fv, +1.0f, +fu); break;
		case 5: Set(ppos, +fu, +fv, +1.0f); break;
	}
}


void LLBlob::create(D3DVECTOR pos, D3DVECTOR4 color)
{
	// A blob is modeled as a subdivided cube.

	m_BlobColor = color;
	m_Pos = pos;
	Set(&m_Scale, 0.9f, 0.9f, 0.9f);
	m_DeformationInertia = spLL->fRand11() * 0.1f;


	m_fRadius = LavaLampInterior::fRand01();
	m_fRadius = 0.5f * (m_fRadius*m_fRadius + LavaLampInterior::fRand01());
	m_fRadius = 0.03f + 0.05f * m_fRadius;
	m_TemperatureAbsorbance = 0.05f / m_fRadius;	// is just representational

	m_Temperature = 0.5f + 0.2f * LavaLampInterior::fRand11();


	m_Subdivisions = 4;	// face is a grid of sd+1 quads square
	m_fDivisionStep = 2.0f / m_Subdivisions;

//MTS	m_dwNumVertices = 2*(subdivisions+2)*(subdivisions+2) + 4*subdivisions*(subdivisions+1);	// number of unique vertices
	m_dwNumVertices = 6*(m_Subdivisions+1)*(m_Subdivisions+1);
	m_dwNumIndices = 6*(m_Subdivisions)*(m_Subdivisions)*2*3;


	gpd3dDev->CreateVertexBuffer( m_dwNumVertices * sizeof(BlobVertex), 0, 0, 0, &m_pBlobVB);
	gpd3dDev->CreateIndexBuffer(  m_dwNumIndices  * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pBlobIB);


	BlobVertex* p_verts;
	WORD* p_indices;

	m_pBlobVB->Lock(0, 0, (BYTE**)&p_verts, 0);
	m_pBlobIB->Lock(0, 0, (BYTE**)&p_indices, 0);



	// Create vertices.
	BlobVertex* p_vert = &p_verts[0];
	for (int k=0; k<6; k++)
	{
		for (int j=0; j<=m_Subdivisions; j++)
		{
			for (int i=0; i<=m_Subdivisions; i++)
			{
				calcFacePoint(&p_vert->pos, k, i, j);
				float oo_dist = 1.0f / sqrtf(p_vert->pos.x*p_vert->pos.x + p_vert->pos.y*p_vert->pos.y + p_vert->pos.z*p_vert->pos.z);
				p_vert->pos.x *= oo_dist;
				p_vert->pos.y *= oo_dist;
				p_vert->pos.z *= oo_dist;
				p_vert++;
			}
		}
	}


	// Create indices.
	WORD* p_index = &p_indices[0];
	for (int k=0; k<6; k++)
	{
		int face_start = k*(m_Subdivisions+1)*(m_Subdivisions+1);
		for (int j=0; j<m_Subdivisions; j++)
		{
			for (int i=0; i<m_Subdivisions; i++)
			{
				*(p_index++) = face_start + (j+0)*(m_Subdivisions+1) + (i+0);
				*(p_index++) = face_start + (j+0)*(m_Subdivisions+1) + (i+1);
				*(p_index++) = face_start + (j+1)*(m_Subdivisions+1) + (i+0);

				*(p_index++) = face_start + (j+1)*(m_Subdivisions+1) + (i+1);
				*(p_index++) = face_start + (j+1)*(m_Subdivisions+1) + (i+0);
				*(p_index++) = face_start + (j+0)*(m_Subdivisions+1) + (i+1);
			}
		}
	}



	m_pBlobVB->Unlock();
	m_pBlobIB->Unlock();
}




void LavaLampInterior::advanceTime(float fElapsedTime, float fDt)
{
	if (fDt < 0.0f) fDt = 0.0f;
	if (fDt > 0.1f) fDt = 0.1f;

//MTS	m_BlobRenderer.advanceTime(fElapsedTime, fDt);

	for (int i=0; i<NUM_LLBLOBS; i++)
	{
		m_Blobs[i].advanceTime(fElapsedTime, fDt);
	}

	recomputeSpecie();
}


void LLBlob::advanceTime(float fElapsedTime, float fDt)
{
	float ambient_temp = spLL->getTemperature(m_Pos.z);
	float scale = 0.002f * m_TemperatureAbsorbance*m_TemperatureAbsorbance * fDt;
	m_Temperature += scale * (ambient_temp - m_Temperature);

	// For purposes of the simulation, water stays at a constant density.
	// A blob's density is equal to water at temperature 0.5f. For each unit
	// of temperature difference, an acceleration of 1.0 m/s/s is applied.
	m_Velocity.z += fDt * 1.0f * (m_Temperature-0.5f);

	m_Accel.x += LavaLampInterior::fRand11() * fDt;
	m_Accel.y += LavaLampInterior::fRand11() * fDt;
	m_Accel.z += LavaLampInterior::fRand11() * fDt;
//MTS	m_Velocity.x += LavaLampInterior::fRand11() * fDt * fDt;
//MTS	m_Velocity.y += LavaLampInterior::fRand11() * fDt * fDt;
//MTS	m_Velocity.z += LavaLampInterior::fRand11() * fDt * fDt;

	m_Accel.x = min(+0.05f, max(-0.05f, m_Accel.x));
	m_Accel.y = min(+0.05f, max(-0.05f, m_Accel.y));
	m_Accel.z = min(+0.05f, max(-0.05f, m_Accel.z));

	if (Length2(m_Accel) > 1.0f) Scale(&m_Accel, 0.96f);

	// Friction moving through water.
	AddScaled(&m_Velocity, m_Accel, fDt);
	float vel2 = Length2(m_Velocity);
	Scale(&m_Velocity, 1.0f - fDt * 120.0f * vel2);

	AddScaled(&m_Pos, m_Velocity, fDt);


	// Do collisions.
	spLL->collide(this, m_Pos.x, m_Pos.y, m_Pos.z, m_fRadius, fDt);


	// Adjust render wobble.
	m_Scale.x += m_DeformationInertia * fDt * m_TemperatureAbsorbance;
	m_Scale.y += m_DeformationInertia * fDt * m_TemperatureAbsorbance;
	m_Scale.z = 0.9f - (m_Scale.x - 0.9f) * (0.9f+0.9f)*0.9f / (0.9f*0.9f);

	float accel;
	if (m_DeformationInertia > 0.0f)
	{
		accel = 0.91f - m_Scale.x;
	}
	else
	{
		accel = 0.89f - m_Scale.x;
	}

	m_DeformationInertia += 20.0f * accel * fDt;
	m_DeformationInertia = max(-0.3f, min(+0.3f, m_DeformationInertia));
}


float LavaLampInterior::getTemperature(float z) const
{
	float dz = -0.5f + (z - m_ConicSectionBotZ[0]) / (m_ConicSectionBotZ[m_NumConicSections] - m_ConicSectionBotZ[0]);
	dz *= 2.6f;
	dz *= dz*dz;
	return max(0.0f, min(1.0f, 0.5f - dz));
}


bool LavaLampInterior::collideWithCaps(LLBlob* pllb, float x, float y, float z, float radius) const
{
	if (z - radius < m_ConicSectionBotZ[0])
	{
		D3DVECTOR pos, norm;
		Set(&pos, x, y, m_ConicSectionBotZ[0] + radius + 0.001f);
		Set(&norm, 0.0f, 0.0f, +1.0f);
		pllb->collided(pos, norm);
		return true;
	}

	if (z + radius > m_ConicSectionBotZ[m_NumConicSections])
	{
		D3DVECTOR pos, norm;
		Set(&pos, x, y, m_ConicSectionBotZ[m_NumConicSections] - radius - 0.001f);
		Set(&norm, 0.0f, 0.0f, -1.0f);
		pllb->collided(pos, norm);
		return true;
	}
	return false;
}


void LavaLampInterior::collide(LLBlob* pllb, float x, float y, float z, float radius, float dt) const
{
	// Bounce off the caps.
	if (collideWithCaps(pllb, x, y, z, radius))
	{
		z = pllb->getPos().z;
	}

	x -= m_ConicSectionCenterX;
	y -= m_ConicSectionCenterY;
	float r = sqrtf( x*x + y*y );

	// Check the conic sections. Check the surfaces first, the corners will be checked afterwards.
	int i;
	bool b_hit_wall = false;
	for (i=0; i<m_NumConicSections; i++)
	{
		if (m_ConicSectionBotZ[i+1] < z - radius) continue;
		if (m_ConicSectionBotZ[i+0] > z + radius) break;

		// Sphere overlaps the section at least somewhat. Find the nearest
		// point on the cone surface and see if that is within the range.
		float dz = z - m_ConicSectionBotZ[i];
		float dr = r - m_ConicSectionRadius[i];

		float overlap = radius - (dr*m_ConicSectionNormalR[i] + dz*m_ConicSectionNormalZ[i]);
		if (overlap < 0.0f) continue;

		// Calculate distance along surface to the nearest point of collision.
		float s = dr*m_ConicSectionNormalZ[i] - dz*m_ConicSectionNormalR[i];
		if (s<0.0f) continue;
		float height = m_ConicSectionBotZ[i+1]-m_ConicSectionBotZ[i];
		if (s*s > height*height * (1.0f + m_ConicSectionSlope[i]*m_ConicSectionSlope[i])) continue;

		// Collision.
		float nz = m_ConicSectionNormalZ[i];
		float oo_r = 1.0f / max(0.001f, r);
		float nx = x * oo_r * m_ConicSectionNormalR[i];
		float ny = y * oo_r * m_ConicSectionNormalR[i];

		D3DVECTOR pos, norm;
		x += nx*overlap;
		y += ny*overlap;
		z += nz*overlap;
		r = sqrtf( x*x + y*y );	// recompute radius
		Set(&pos, m_ConicSectionCenterX + x, m_ConicSectionCenterY + y, z);
		Set(&norm, nx, ny, nz);
		pllb->collided(pos, norm);
		b_hit_wall = true;
	}


	// Check the corners.
	if (!b_hit_wall) for (i=0; i<m_NumConicSections; i++)
	{
		if (m_ConicSectionBotZ[i+1] < z - radius) continue;
		if (m_ConicSectionBotZ[i+0] > z + radius) break;

		float dz = z - m_ConicSectionBotZ[i];
		float dr = r - m_ConicSectionRadius[i];

		if (dz*dz + dr*dr > radius*radius) continue;
		float dist = sqrtf(dz*dz + dr*dr);
		float overlap =  radius - dist;

		float f_norm = 1.0f / max(0.001f, dist);
		float nz = -dz * f_norm;
		float nr = -dr * f_norm;

		float oo_r = 1.0f / max(0.001f, r);
		float nx = x * oo_r * nr;
		float ny = y * oo_r * nr;

		D3DVECTOR pos, norm;
		x += nx*overlap;
		y += ny*overlap;
		z += nz*overlap;
		r = sqrtf( x*x + y*y );	// recompute radius
		Set(&pos, m_ConicSectionCenterX + x, m_ConicSectionCenterY + y, z);
		Set(&norm, nx, ny, nz);
		pllb->collided(pos, norm);
		b_hit_wall = true;
	}


	// Check other blobs.
	for (i=0; i<NUM_LLBLOBS; i++)
	{
		if (&m_Blobs[i] == pllb) continue;
		D3DVECTOR delta;
		Sub(m_Blobs[i].getPos(), pllb->getPos(), &delta);
		float rad = (m_Blobs[i].getRadius() + pllb->getRadius());

		if (Length2(delta) > rad*rad) continue;
		pllb->interactWithBlob(&m_Blobs[i], dt);
	}

	if (collideWithCaps(pllb, x + m_ConicSectionCenterX, y + m_ConicSectionCenterY, z, radius))
	{
		// Should never happen with convex hull.
		z = pllb->getPos().z;
	}
}


void LLBlob::collided(D3DVECTOR pos, D3DVECTOR normal)
{
	D3DVECTOR diff;
	Sub(pos, m_Pos, &diff);
	if (Length2(diff) > 0.5f * m_fRadius * m_fRadius)
	{
		int a = 0;
	}

	float dot;
	dot = Dot(normal, m_Accel);
	if (dot<0.0f) AddScaled(&m_Accel, normal, -dot);

	dot = Dot(normal, m_Velocity);
	if (dot<0.0f) AddScaled(&m_Velocity, normal, -dot);

	m_Pos = pos;
}


void LLBlob::interactWithBlob(const LLBlob* pllb, float dt)
{
	// Attract at range, repel when close.

	float mass_b = pllb->m_fRadius;
	mass_b *= mass_b*mass_b;

	D3DVECTOR delta;
	Sub(pllb->getPos(), getPos(), &delta);
	float dist2 = Length2(delta);
	if (dist2 < 0.000001f) return;

	D3DVECTOR delta_v;
	Sub(pllb->m_Velocity, m_Velocity, &delta_v);
	float f_part_mag = Dot(delta_v, delta);


	if (getSpecies() == pllb->getSpecies())
	{
		// Same species.
		float extreme_rad = (m_fRadius + pllb->m_fRadius);
		float attract = mass_b * dt * 10000.0f * ((f_part_mag > 0.0f) ? 1.0f : 0.5f);
		AddScaled(&m_Velocity, delta, attract);
//MTS		float attract = ((1.0f / dist2) - (1.0f / (extreme_rad*extreme_rad))) * mass_b * dt * 5.0f;
//MTS		AddScaled(&m_Accel, delta, attract);

		// Should try adding to the velocity directly...

		extreme_rad *= 0.6f;
		float extreme_rad2 = extreme_rad*extreme_rad;
		float repel = ((1.0f / min(extreme_rad2*0.04f, dist2)) - (1.0f / extreme_rad2)) * mass_b * dt * 5.0f;
		repel *=  ((f_part_mag > 0.0f) ? 0.3f : 1.0f);
		if (repel > 0.0f) AddScaled(&m_Velocity, delta, -repel);
//MTS		float repel = ((1.0f / min(extreme_rad2*0.04f, dist2)) - (1.0f / extreme_rad2)) * mass_b * dt * 500.0f;
//MTS		if (repel > 0.0f) AddScaled(&m_Accel, delta, -repel);
	}
	else
	{
		// Different specie.
		float extreme_rad2 = (m_fRadius + pllb->m_fRadius);
		extreme_rad2 *= extreme_rad2;
		float repel = ((1.0f / min(extreme_rad2*0.04f, dist2)) - (1.0f / extreme_rad2)) * mass_b * dt * 1.0f;
		repel *=  ((f_part_mag > 0.0f) ? 0.3f : 1.0f);
		AddScaled(&m_Velocity, delta, -repel);
//MTS		float repel = ((1.0f / min(extreme_rad2*0.04f, dist2)) - (1.0f / extreme_rad2)) * mass_b * dt * 50.0f;
//MTS		AddScaled(&m_Accel, delta, -repel);
	}
}



void LavaLampInterior::recomputeSpecie()
{
	int prev_species[NUM_LLBLOBS];
	int i;
	for (i=0; i<NUM_LLBLOBS; i++)
	{
		prev_species[i] = m_Blobs[i].getSpecies();
		m_Blobs[i].setSpecies(i);
	}

	for (i=0; i<NUM_LLBLOBS-1; i++)
	{
		for (int j=i+1; j<NUM_LLBLOBS; j++)
		{
			D3DVECTOR diff;
			Sub(m_Blobs[i].getPos(), m_Blobs[j].getPos(), &diff);
			float dist2 = Length2(diff);
			if (prev_species[i] == prev_species[j])
			{
				// Were connected.
				float radii2 = m_Blobs[i].getRadius() + m_Blobs[j].getRadius();
				radii2 *= radii2;
				if (dist2 < 0.9f*0.9f * radii2)
				{
					// Are still touching. Maintain the same specie.
					m_Blobs[j].setSpecies( m_Blobs[i].getSpecies() );
				}
			}
			else
			{
				// Were not connected.
				float check_rad = max(m_Blobs[i].getRadius(), m_Blobs[j].getRadius());
				check_rad += 0.7f * min(m_Blobs[i].getRadius(), m_Blobs[j].getRadius());
				if (dist2 < check_rad*check_rad)
				{
					// Connect them only if they are in the top or bottom.
					bool b_close_to_end = false;
					float z = m_Blobs[i].getPos().z;
					float r = m_Blobs[i].getRadius();
					b_close_to_end = b_close_to_end || (z - m_ConicSectionBotZ[0] < 1.5f * r);
					b_close_to_end = b_close_to_end || (m_ConicSectionBotZ[m_NumConicSections] - z < 1.5f * r);
					z = m_Blobs[j].getPos().z;
					r = m_Blobs[j].getRadius();
					b_close_to_end = b_close_to_end || (z - m_ConicSectionBotZ[0] < 1.5f * r);
					b_close_to_end = b_close_to_end || (m_ConicSectionBotZ[m_NumConicSections] - z < 1.5f * r);

					if (b_close_to_end)
					{
						m_Blobs[j].setSpecies( m_Blobs[i].getSpecies() );
					}
				}
			}
		}
	}

	for (i=0; i<NUM_LLBLOBS; i++)
	{
		m_Blobs[i].setSpecies( m_Blobs[m_Blobs[i].getSpecies()].getSpecies() );
	}


	// For debug purposes, color code the blobs based on specie.
	for (i=0; i<NUM_LLBLOBS; i++)
	{
		D3DVECTOR4 color, base_color;
		int s = m_Blobs[i].getSpecies();
		Set(&color, (s&0x04) ? 0.0f : 1.0f, (s&0x02) ? 0.0f : 1.0f, (s&0x01) ? 0.0f : 1.0f, 1.0f);
		Set(&base_color, 0.724f, 0.732f, 0.556f, 1.0f);
		color.x = color.x*0.05f + base_color.x*0.95f;
		color.y = color.y*0.05f + base_color.y*0.95f;
		color.z = color.z*0.05f + base_color.z*0.95f;
		color.w = color.w*0.05f + base_color.w*0.95f;
//MTS		m_Blobs[i].setColor(color);
	}
}




void LavaLampInterior::render()
{
    // Set default states
    gpd3dDev->SetRenderState( D3DRS_LIGHTING, FALSE );
    gpd3dDev->SetRenderState( D3DRS_ZENABLE,  TRUE );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    gpd3dDev->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
    gpd3dDev->SetRenderState( D3DRS_ALPHAFUNC,       D3DCMP_GREATEREQUAL );
    gpd3dDev->SetRenderState( D3DRS_ALPHAREF,        0x00000001 );
    gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
//MTS    gpd3dDev->SetRenderState( D3DRS_FILLMODE,         D3DFILL_WIREFRAME );

    gpd3dDev->SetTexture( 0, gApp.pNormalCubeMap );


    gpd3dDev->SetVertexShader( m_dwVertexShader );
    gpd3dDev->SetPixelShader( m_dwPixelShader );



    // Note: when passing matrices to a vertex shader, we transpose them, since
    // matrix multiplies are done with dot product operations on the matrix rows.

	D3DMATRIX matFinal,matTmp;
	MulMats(gApp.theCamera.matWTC,gApp.theCamera.matProj,&matTmp);
	SetTranspose(matTmp,&matFinal);
	gpd3dDev->SetVertexShaderConstant(4,(CONST void *)&matFinal,4);


	//; Expected vertex shaders constants
	//;    c0-c3    = Transpose of world matrix
	//;    c4-c7    = Transpose of view*projection matrix
	//;    c8       = some constants, x=0, y=1, z=2, w=0.5
	D3DVECTOR4 val;

	// Constants
	Set(&val, 0.0f, 1.0f, 2.0f, 0.5f);
	gpd3dDev->SetVertexShaderConstant( 8, &val, 1 );



//MTS	m_BlobRenderer.render();

    
	for (int i=0; i<NUM_LLBLOBS; i++)
	{
		m_Blobs[i].render();
	}


    // Restore the state
    gpd3dDev->SetPixelShader( NULL );
    gpd3dDev->SetVertexShader( NULL );

	gpd3dDev->SetTexture(0, NULL);
}



void LLBlob::render()
{
	// Make the object to World transform. Transpose it.
    D3DMATRIX matT, mat;

	SetIdentity( &mat );
	mat.m[0][0] = m_Scale.x * m_fRadius;
	mat.m[1][1] = m_Scale.y * m_fRadius;
	mat.m[2][2] = m_Scale.z * m_fRadius;
	mat.m[3][0] = m_Pos.x;
	mat.m[3][1] = m_Pos.y;
	mat.m[3][2] = m_Pos.z;

	SetTranspose( mat, &matT );
    gpd3dDev->SetVertexShaderConstant( 0, &matT, 4 );


	// Expected pixel shader constants
	//; c0          = light 1 direction
	//; c1          = light 2 direction
	//; c2          = base blob color
	//; c3          = ambient color
	D3DVECTOR4 val;
	Set(&val, 0.5f, 0.6f, 0.5f, 1.0f );
	gpd3dDev->SetPixelShaderConstant( 0, &val, 1 );

	Set(&val, 0.5f, 0.4f, 0.5f, 1.0f );
	gpd3dDev->SetPixelShaderConstant( 1, &val, 1 );

	// Blob color
	gpd3dDev->SetPixelShaderConstant( 2, &m_BlobColor, 1 );

	// Ambient light
	val = m_BlobColor;
	val.x *= 0.6f;
	val.y *= 0.6f;
	val.z *= 0.6f;
	gpd3dDev->SetPixelShaderConstant( 3, &val, 1 );


    // This could be set in the lava lamp, but we might have blobs with different numbers of vertices.
	gpd3dDev->SetIndices( m_pBlobIB, 0 );
    gpd3dDev->SetStreamSource( 0, m_pBlobVB, sizeof(BlobVertex) );

    gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, m_dwNumVertices, 
                                        0, m_dwNumIndices/3 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\BlobRenderer.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: BlobRenderer.cpp
//
// Copyright 2001 Pipeworks Software
//
// WORK HALTED: Patent issues
//
///////////////////////////////////////////////////////////////////////////////
#include <xtl.h>
#include "xbs_math.h"
#include "xbs_app.h"
#include "Blobs.h"
#include "BlobRenderer.h"


///////////////////////////////////////////////////////////////////////////////
#define LLI_RAND_MAX  0x00010000
#define LLI_RAND_MASK 0x0000FFFF
///////////////////////////////////////////////////////////////////////////////
float FRand01()
{
	static QRand qrand;
	static float mul = 1.0f / ((float)LLI_RAND_MAX);
	return ((float)(qrand.Rand()&LLI_RAND_MASK)) * mul;
}
///////////////////////////////////////////////////////////////////////////////
float FRand11()
{
	static QRand qrand;
	static float mul = 2.0f / ((float)LLI_RAND_MAX);
	return (((float)(qrand.Rand()&LLI_RAND_MASK)) * mul) - 1.0f;
}
///////////////////////////////////////////////////////////////////////////////
BlobRenderer::BlobRenderer()
{
	m_pLLI = NULL;
	m_pBlobArray = NULL;
	m_NumBlobs = 0;

	m_Threshhold = 1.0f;

    m_dwNumVertices = 0;
    m_dwNumIndices = 0;
    m_pBlobVB = NULL;
    m_pBlobIB = NULL;

	m_pField = NULL;
	m_pVertexIndices = NULL;
}
///////////////////////////////////////////////////////////////////////////////
BlobRenderer::~BlobRenderer()
{
	destroy();
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::destroy()
{
	if (m_pBlobVB) m_pBlobVB->Release();
	if (m_pBlobIB) m_pBlobIB->Release();
	delete m_pField;
	delete m_pVertexIndices;

	m_pBlobArray = NULL;

	m_pLLI = NULL;
	m_pBlobArray = NULL;
	m_NumBlobs = 0;

    m_dwNumVertices = 0;
    m_dwNumIndices = 0;
    m_pBlobVB = NULL;
    m_pBlobIB = NULL;

	m_pField = NULL;
	m_pVertexIndices = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::render()
{
	int next_affiliation = m_pSources[0]->dAffiliation;
	int i;
	for (i=1; i<m_NumBlobs; i++)
	{
		next_affiliation = min(next_affiliation, m_pSources[i]->dAffiliation);
	}

	for (int affiliation = next_affiliation; affiliation < m_NumBlobs; affiliation = next_affiliation)
	{
		next_affiliation = m_NumBlobs;
		D3DVECTOR pt_min, pt_max;
		pt_min = pt_max = bs.ptPosition;
		bool b_unset = true;

		// For this affiliation, iterate through all the sources, adjusting
		// the min/max for any blobs with the correct affiliation.
		for (int i=0; i<m_NumBlobs; i++)
		{
			BlobSource& bs = m_pSources[i];

			// Keep track of what the smallest affiliation larger than the current affiliation is.
			int aff = bs.dAffiliation;
			if (aff > affiliation) next_affiliation = min(aff, next_affiliation);

			if (aff == affiliation)
			{
				if (b_unset)
				{
					b_unset = false;
					pt_min = pt_max = bs.ptPosition;
					pt_min.x -= bs.fConsiderationRadius;
					pt_min.y -= bs.fConsiderationRadius;
					pt_min.z -= bs.fConsiderationRadius;
					pt_max.x += bs.fConsiderationRadius;
					pt_max.y += bs.fConsiderationRadius;
					pt_max.z += bs.fConsiderationRadius;
				}
				else
				{
					pt_min.x = min(pt_min.x, bs.ptPosition.x - bs.fConsiderationRadius);
					pt_min.y = min(pt_min.y, bs.ptPosition.y - bs.fConsiderationRadius);
					pt_min.z = min(pt_min.z, bs.ptPosition.z - bs.fConsiderationRadius);

					pt_max.x = min(pt_max.x, bs.ptPosition.x + bs.fConsiderationRadius);
					pt_max.y = min(pt_max.y, bs.ptPosition.y + bs.fConsiderationRadius);
					pt_max.z = min(pt_max.z, bs.ptPosition.z + bs.fConsiderationRadius);
				}
			}
		}

		// Now have the boundaries for the rendering region. Blobs outside the area may
		// affect the energy threshold, but no polygons will be drawn outside it.
		int sx, sy, sz, ex, ey, ez;
		getCoords(pt_min, &sx, &sy, &sz);
		getCoords(pt_max, &ex, &ey, &ez);
		ex++; ey++; ez++;

		int len_x = ex - sx + 1;
		int len_y = ey - sy + 1;
		int len_z = ez - sz + 1;
		int len_xy = len_x*len_y;
		int len_xyz = len_xy * len_z;

		if (len_x*len_y*len_z > m_FieldX*m_FieldY*m_FieldZ)
		{
			continue;	// can't render it, it is too big
		}


		// Clear the part of the field that will be used. Note that this does not
		// share the rows/columns/levels that would be used if the entire field
		// was used. Instead, the minimum amount of memory is used in a contiguous
		// fashion.
		for (i=0; i<len_xyz; i++) m_pField[i] = 0.0f;


		// For each blob, isolate the box within influence and iterate for each point.
		// The box of influence can (and must) be clipped to the previously determined
		// region.
		for (i=0; i<m_NumBlobs; i++)
		{
			BlobSource& bs = m_pSources[i];
			D3DVECTOR pt_start, pt_end;
			Set(&pt_start,
				max(pt_min.x, bs.ptPosition.x - bs.fConsiderationRadius),
				max(pt_min.y, bs.ptPosition.y - bs.fConsiderationRadius),
				max(pt_min.z, bs.ptPosition.z - bs.fConsiderationRadius)
				);
			Set(&pt_end,
				min(pt_max.x, bs.ptPosition.x + bs.fConsiderationRadius),
				min(pt_max.y, bs.ptPosition.y + bs.fConsiderationRadius),
				min(pt_max.z, bs.ptPosition.z + bs.fConsiderationRadius)
				);

			int bsx, bsy, bsz, bex, bey, bez;
			getCoords(pt_start, &bsx, &bsy, &bsz);
			getCoords(pt_end  , &bex, &bey, &bez);
			bex++; bey++; bez++;
			// The coordinates have already been capped to the rendering region.

			if ( (bsx<=bex) && (bsy<=bey) && (bsz<=bez) )
			{
				D3DVECTOR pos, posll;
				getWorldPos(&posll, bsx, bsy, bsz);
				pos.z = posll.z;
				for (int w=bsz; w<=bez; w++, pos.z += m_FieldToWorld.z)
				{
					pos.y = posll.y;
					for (int v=bsy; v<=bey; v++, pos.y += m_FieldToWorld.y)
					{
						pos.x = posll.x;
						float* p_field = &m_pField[w*len_xy + v*len_x + bsx];
						for (int u=bsx; u<=bex; u++, pos.x += m_FieldToWorld.x)
						{
							*(p_field++) += bs.calculate(affiliation, pos);
						}
					}
				}
			}
		}
		// It is legitimate for the outermost points to have a negative energy accumulation,
		// but nothing should be giving it a positive value. It would be nice to enforce this,
		// but I'm not sure it's worth the trouble.

		// Woohoo! The field is complete for this affiliation. Start rendering.

		// Lock the buffers.
		int max_tris = len_xyz * 5 * 2;		// for a Sierpinski cube relative, maybe...
		BlobVertex* p_verts;
		u16* p_indices;
		if (D3D_OK != m_pBlobVB->Lock(0, len_xyz*6, (BYTE**) &pbv_buf, D3DLOCK_DISCARD))
		{
			continue;
		}
		if (D3D_OK != m_pBlobIB->Lock(0, max_tris*3, (BYTE**) &pbv_buf, D3DLOCK_DISCARD))
		{
			m_pBlobVB->Unlock();
			continue;
		}

		int num_tris = 0;
		int num_verts = 0;
		BlobVertex* p_vert = p_verts;
		u16* p_index = p_indices;


		// This buffer stores the vertex indices (or -1) for the vertex on each segment
		// of a voxel. The offsets march through the buffer, returning to zero when they
		// reach the voxel_wrap value. m_pVertexIndices[voxel_offset] is for the voxel
		// with the current point in the max_pt position.
		int voxel_offset = 0;
		int voxel_offset_x = 6*1;
		int voxel_offset_y = 6*len_x;
		int voxel_offset_z = 6*len_xy;
		int voxel_wrap = 6*(len_xy+1);
		memset(m_pVertexIndices, -1, sizeof(int) * voxel_wrap);



		D3DVECTOR pos;
		pos.z = pt_min.z;
		for (int w=sz; w<ez; w++, pos.z += m_FieldToWorld.z)
		{
			pos.y = pt_min.y;
			for (int v=sy; v<ey; v++, pos.y += m_FieldToWorld.y)
			{
				pos.x = pt_min.x;
				p_field = &m_pField[w*len_xy + v*len_x];
				for (int u=sx; u<ex; u++, pos.x += m_FieldToWorld.x)
				{
					u32 in_or_out;
					if (p_field[             0] > m_Threshhold) in_or_out |= 0x0001;
					if (p_field[             1] > m_Threshhold) in_or_out |= 0x0002;
					if (p_field[       len_x  ] > m_Threshhold) in_or_out |= 0x0004;
					if (p_field[       len_x+1] > m_Threshhold) in_or_out |= 0x0008;
					if (p_field[len_xy        ] > m_Threshhold) in_or_out |= 0x0010;
					if (p_field[len_xy+      1] > m_Threshhold) in_or_out |= 0x0020;
					if (p_field[len_xy+len_x  ] > m_Threshhold) in_or_out |= 0x0040;
					if (p_field[len_xy+len_x+1] > m_Threshhold) in_or_out |= 0x0080;

					if ((in_or_out!=0) && (in_or_out!=0x00FF))
					{
						// Not all corners are the same. Analyze the five tetrahedrons.
						// The five tetrahedrons are defined as corners:
						const int  odd_tetrahedrons[20] = { 0,1,2,4,  5,1,4,7,  3,1,2,7,  6,2,7,4,  1,2,4,7 };
						const int even_tetrahedrons[20] = { 1,0,5,3,  7,3,5,6,  2,0,6,3,  4,0,6,5,  0,6,5,3 };
						const int* tetrahedrons = ((u+v+w)&0x01) ? odd_tetrahedrons : even_tetrahedrons;
						
						for (int tet=0; tet<5; tet++)
						{
							int mask = 0;
							mask |= (1<<(tetrahedrons[4*tet+0]));
							mask |= (1<<(tetrahedrons[4*tet+1]));
							mask |= (1<<(tetrahedrons[4*tet+2]));
							mask |= (1<<(tetrahedrons[4*tet+3]));

							int masked = in_or_out & mask;
							if ((masked!=0) && (masked!=mask))
							{
								// Mixed corners for this tetrahedron. Triangles are needed.
								int ins[4];
								int outs[4];
								int num_in = 0;
								int num_out = 0;
								if (mask & 0x0001) ins[num_in++] = 0;
								if (mask & 0x0002) ins[num_in++] = 1;
								if (mask & 0x0004) ins[num_in++] = 2;
								if (mask & 0x0008) ins[num_in++] = 3;
								if (mask & 0x0010) ins[num_in++] = 4;
								if (mask & 0x0020) ins[num_in++] = 5;
								if (mask & 0x0040) ins[num_in++] = 6;
								if (mask & 0x0080) ins[num_in++] = 7;

								if (num_in==1)
								{
									// One is in, three are out.
									D3DVECTOR pos_in = pos;
									if (ins[0] & 0x01) pos_in.x += m_FieldToWorld.x * 0.5f;
									if (ins[0] & 0x02) pos_in.y += m_FieldToWorld.y * 0.5f;
									if (ins[0] & 0x04) pos_in.z += m_FieldToWorld.z * 0.5f;
								}
							}
						}
					}
				}
			}
		}


		// Render.


		m_pBlobIB->Unlock();
		m_pBlobVB->Unlock();
	}	
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::init(	const BlobSource* p_blob_sources, int num_blobs,
							float xy_spacing, float z_spacing,
							const D3DVECTOR& center, const D3DVECTOR& half_dim)
{
	m_FieldX = (int)((half_dim.x * 2.0f / xy_spacing) + 2.0f);
	m_FieldY = (int)((half_dim.y * 2.0f / xy_spacing) + 2.0f);
	m_FieldZ = (int)((half_dim.z * 2.0f /  z_spacing) + 2.0f);
	m_FieldXY = m_FieldX * m_FieldY;
	m_pField = new float[m_FieldXY * m_FieldZ];
	m_pVertexIndices = new int[(m_FieldXY+1) * 6];

	Sub(&m_LowerLeftCorner, center, half_dim);
	m_FieldToWorld.x = xy_spacing;
	m_FieldToWorld.y = xy_spacing;
	m_FieldToWorld.z =  z_spacing;
	m_WorldToField.x = 1.0f / xy_spacing;
	m_WorldToField.y = 1.0f / xy_spacing;
	m_WorldToField.z = 1.0f /  z_spacing;

	// Create a vertex buffer, too.
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::getCoords(const D3DVECTOR& pos, int* p_x, int* p_y, int* p_z, D3DVECTOR* p_remainder)
{
	float fx = (pos.x - m_LowerLeftCorner.x) * m_WorldToField.x;
	float fy = (pos.y - m_LowerLeftCorner.y) * m_WorldToField.y;
	float fz = (pos.z - m_LowerLeftCorner.z) * m_WorldToField.z;
	*p_x = (int) (fx);
	*p_y = (int) (fy);
	*p_z = (int) (fz);

	if (p_remainder)
	{
		p_remainder->x = fx - ((float)*p_x);
		p_remainder->y = fy - ((float)*p_y);
		p_remainder->z = fz - ((float)*p_z);
	}
	return (*p_z * m_FieldXY) + (*p_y * m_FieldX) + (*p_x);
}
///////////////////////////////////////////////////////////////////////////////
void BlobRenderer::getWorldPos(D3DVECTOR* pos, int x, int y, int z)
{
	pos->x = m_LowerLeftCorner.x + ((float)x) * m_FieldToWorld.x;
	pos->y = m_LowerLeftCorner.y + ((float)y) * m_FieldToWorld.y;
	pos->z = m_LowerLeftCorner.z + ((float)z) * m_FieldToWorld.z;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
TestBlobRenderer::TestBlobRenderer()
{
}
///////////////////////////////////////////////////////////////////////////////
TestBlobRenderer::~TestBlobRenderer()
{
	destroy();
}
///////////////////////////////////////////////////////////////////////////////
void TestBlobRenderer::create()
{
	for (int i=0; i<NUM_BLOBS; i++)
	{
		Set(&m_Sources[i].ptPosition, FRand01() * 0.2f, FRand01() * 0.2f, FRand01() * 0.2f);
		m_Sources[i].fStrength = 1.0f;
		m_Sources[i].fConsiderationRadius = 0.09f;
		m_Sources[i].fConsiderationRadius2 = m_Sources[i].fConsiderationRadius * m_Sources[i].fConsiderationRadius;
		m_Sources[i].dAffiliation = 0;
	}

	D3DVECTOR center, hd;
	Set(&center, 0.0f, 0.0f, 0.0f);
	Set(&hd, 1.0f, 1.0f, 1.0f);
	init(&m_Sources[i], NUM_BLOBS, 0.005f, 0.005f, center, hd);
}
///////////////////////////////////////////////////////////////////////////////
void TestBlobRenderer::advanceTime(float fElapsedTime, float fDt)
{
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\animate.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    animate.c

Abstract:

    Startup animation implementation.

--*/

#include <stddef.h>

#pragma code_seg("INIT")
#pragma data_seg("INIT_RW")
#pragma const_seg("INIT_RD")

#include "ntos.h"
#include "stdio.h"
#include "stdlib.h"
#include "wtypes.h"

#include "ani.h"

// Tell linker to put startup animation code and data into INIT section
#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")
#pragma comment(linker, "/merge:D3D=INIT")
#pragma comment(linker, "/merge:D3D_RD=INIT")
#pragma comment(linker, "/merge:D3D_RW=INIT")
#pragma comment(linker, "/merge:XGRPH=INIT")
#pragma comment(linker, "/merge:XGRPH_RD=INIT")

// We always want to link with the animation code, so that we can
// keep the build from breaking. Thats why we use a global to
// decide whether to run the animation or not. The global tricks
// the linker into linking in all the code the animation uses.

#ifdef NOANI
BOOL gBootAnimation_DoAnimation = FALSE;
#else
BOOL gBootAnimation_DoAnimation = TRUE;
#endif

#ifdef BOOTSOUND
BOOL gBootAnimation_DoSound = TRUE;
#else
BOOL gBootAnimation_DoSound = FALSE;
#endif

// Background animation thread.
HANDLE g_hThread;

// Entrypoing into the animation thread.
VOID AnipStartAnimationThread(PKSTART_ROUTINE StartRoutine, PVOID StartContext);

// Main animation routine as defined in the animation library.
VOID AnipRunAnimation();

#define CONTIGUOUS_BLOCK_SIZE           (5 * 1024 * 1024 / 2)
#define AGP_APERTURE_BYTES              (64*1024*1024)
#define INSTANCE_MEM_MAXSIZE            (20*1024)
#define NV_INSTANCE_SIZE                (INSTANCE_MEM_MAXSIZE)

//------------------------------------------------------------------------
// Starts the animation which will run on a background thread.  This API
// returns immediately.
//

BOOL g_bShortVersion;

void AniStartAnimation(BOOLEAN fShort)
{
    NTSTATUS Status;

    if (gBootAnimation_DoAnimation){

        g_bShortVersion = fShort;

        Status = PsCreateSystemThreadEx(&g_hThread,
                                        0,
                                        0x4000,  // Stack size, 16K
                                        0,
                                        NULL,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        FALSE,
                                        AnipStartAnimationThread);

        if (!NT_SUCCESS(Status))
        {
            // RIP(("AniStartAnimation - Unable to create thread."));
            g_hThread = NULL;
        }
    }
}

//------------------------------------------------------------------------
// Shut down the animation.  This will block until the animation finishes.
//
void AniTerminateAnimation()
{
    if (g_hThread)
    {
        NTSTATUS Status;
#if DBG
        int start = NtGetTickCount();
#endif

        // Wait for it to go away.
        Status = NtWaitForSingleObjectEx(g_hThread, KernelMode, FALSE, NULL);

#if DBG
        DbgPrint("Boot animation wait %d\n", NtGetTickCount() - start);

        if (Status == STATUS_TIMEOUT)
        {
            //RIP(("AniTerminateAnimation - Animation is stuck!"));
        }
#endif

        NtClose(g_hThread);

        g_hThread = NULL;
    }
}

void AnipBreak()
{
#if DBG
   _asm int 3;
#endif
}

#if DBG
int gcMemAllocsContiguous = 0;
#endif

//------------------------------------------------------------------------
// Blocks until the animation has completed (until the animation is ready
// to display the Microsoft logo).
//
void AniBlockOnAnimation(void)
{
    extern KEVENT g_EventLogoWaiting;

    NTSTATUS status;
    PETHREAD ThreadObject;
    PVOID WaitObjects[2];
    KWAIT_BLOCK WaitBlocks[2];

    if (g_hThread)
    {
        status = ObReferenceObjectByHandle(g_hThread, &PsThreadObjectType,
            (PVOID*)&ThreadObject);

        if (NT_SUCCESS(status))
        {
            WaitObjects[0] = ThreadObject;
            WaitObjects[1] = &g_EventLogoWaiting;

            KeWaitForMultipleObjects(2, WaitObjects, WaitAny, Executive,
                KernelMode, FALSE, NULL, WaitBlocks);

            ObDereferenceObject(ThreadObject);
        }
    }
}

//------------------------------------------------------------------------
// MemAllocContiguous
//
void *MemAllocContiguous(size_t Size, DWORD Alignment)
{
#if DBG
    gcMemAllocsContiguous++;
#endif

    return MmAllocateContiguousMemoryEx(
            Size,
            0,
            AGP_APERTURE_BYTES - NV_INSTANCE_SIZE,
            Alignment,
            PAGE_READWRITE | PAGE_WRITECOMBINE);
}

//------------------------------------------------------------------------
// MemFreeContiguous
//
void MemFreeContiguous(void *pv)
{
#if DBG
    if (gcMemAllocsContiguous <= 0)
    {
        AnipBreak();
    }
    gcMemAllocsContiguous--;
#endif

    MmFreeContiguousMemory(pv);
}

//------------------------------------------------------------------------
// Main animation procedure.  Defers to the startup animation library.
//
VOID AnipStartAnimationThread(
    PKSTART_ROUTINE StartRoutine, 
    PVOID StartContext
    )
{
    AnipRunAnimation();

    // Make this thread go away.
    PsTerminateSystemThread(0);
}

///////////////////////////////////////////////////////////////////////////////
// Defined so we don't have to pull libc in
typedef void (__cdecl *_PVFV)(void);

int __cdecl atexit(_PVFV func)
{
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
// Define a couple of debug-only methods used in XGRAPHICS that normally
// are implemented in XTL.

#ifdef STARTUPANIMATION

long __cdecl _ftol2(float x)
{
    DWORD result[2];
    unsigned short oldcw;
    unsigned short newcw;

    _asm
    {
        fstcw   [oldcw]         ; get control word
        fwait                   ; synchronize

        mov ax, [oldcw]         ; round mode saved
        or  ah, 0ch             ; set chop rounding mode
        mov [newcw], ax         ; back to memory

        fldcw   [newcw]         ; reset rounding
        fistp   qword ptr [result]  ; store chopped integer
        fldcw   [oldcw]         ; restore rounding

        mov eax, dword ptr [result]
        mov edx, dword ptr [result+4]
    }
}

#define D_EXP(x) ((unsigned short *)&(x)+3)
#define D_HI(x) ((unsigned long *)&(x)+1)
#define D_LO(x) ((unsigned long *)&(x))

#define IS_D_QNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff8)
#define IS_D_SNAN(x)    ((*D_EXP(x) & 0x7ff8) == 0x7ff0 && \
                         (*D_HI(x) << 13 || *D_LO(x)))
                         
int __cdecl _isnan(double x)
{
    if (IS_D_SNAN(x) || IS_D_QNAN(x)) {
        return 1;
    }
    return 0;
}

VOID
XDebugError(PCHAR Module, PCHAR Format, ...)
{
    _asm int 3;
}

void Sleep(DWORD Milliseconds)
{
    _asm int 3;
}

VOID
OutputDebugStringA(
    IN LPCSTR lpOutputString
    )
{
    DbgPrint((PSTR)lpOutputString);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\bootsound.cpp ===
//depot/xbox/private/ntos/ani2/bootsound.cpp#7 - edit change 15970 (text)
/*
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 */



#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>
#include <pci.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include "xtl.h"
#include "xdbg.h"
#include "bootsound.h"

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

#if DBG
EXTERN_C g_dwDirectSoundPoolMemoryUsage;
EXTERN_C g_dwDirectSoundPhysicalMemoryUsage;
#endif

EXTERN_C SHORT system_clock_music;

KTIMER    g_BootSoundTimer;
KDPC      g_BootSoundDpc;

VOID
BootSoundDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
	system_clock_music++;
	sos_main();
    return;
}


void BootSound_Start(){
    LARGE_INTEGER dueTime;

    dueTime.QuadPart = 0;

  	do_sos_init_return();

    KeInitializeTimerEx(&g_BootSoundTimer,NotificationTimer);
    KeInitializeDpc(&g_BootSoundDpc,BootSoundDpc,NULL);

    KeSetTimerEx(&g_BootSoundTimer,
                 dueTime,
                 5,
                 &g_BootSoundDpc);
}


// 
// here's our main sos worker thread.  This needs to get called regularly
// it does all the sequencing and writing to the sound chip to make noise
//
// not true...we create a worker thread instead in the init routine



void BootSound_Stop(void){

    KeCancelTimer(&g_BootSoundTimer);

    //
    // free dsound objects
    //

    dev_cleanup();

#if DBG
    //
    // check if we leaked any mem
    //

    ASSERT(g_dwDirectSoundPoolMemoryUsage == 0);
    ASSERT(g_dwDirectSoundPhysicalMemoryUsage == 0);

#endif

}


extern "C" int _cdecl _purecall(
	void
	)
{
	_asm int 3; return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\bootsound.h ===
/*
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 */



extern "C"  do_sos_init_return(void);
extern "C"	sos_main(void);
extern "C"  put_fifo(unsigned char);
extern "C"  dev_cleanup(void);

#ifdef  __cplusplus
extern "C" {
#endif

// All boot sound functions must be called at passive level

void BootSound_Start(); // Call once to start boot sound
void BootSound_Stop(void); // Call once to stop boot sound





#ifdef  __cplusplus
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\Blobs.h ===
///////////////////////////////////////////////////////////////////////////////
// File: Blobs.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef BLOBS_H
#define BLOBS_H


#include "render_object.h"
#include "qrand.h"



struct BlobVertex
{
	D3DVECTOR pos;
    // D3DVECTOR normal;		// sphere with radius 1, normal is the pos!
	// Diffuse color is set as a constant.
};

   
class LavaLampInterior;


class LLBlob : public RenderObject
{
protected:
    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;

    LPDIRECT3DVERTEXBUFFER8 m_pBlobVB;
    LPDIRECT3DINDEXBUFFER8  m_pBlobIB;

	D3DVECTOR4				m_BlobColor;


	D3DVECTOR				m_Pos;
	D3DVECTOR				m_Scale;
	float					m_DeformationInertia;
	FLOAT					m_fRadius;


	float					m_Temperature;
	float					m_TemperatureAbsorbance;
	D3DVECTOR				m_Velocity;
	D3DVECTOR				m_Accel;


	int						m_Subdivisions;		// number of quads in a direction for each face
	float					m_fDivisionStep;	// distance on cube face that a division spans

	int						m_Species;

	// Cube has dimensions from -1 to +1.
	void					calcFacePoint(D3DVECTOR* ppos, int face, int u, int v);


public:
	LLBlob();

	void					create(D3DVECTOR pos, D3DVECTOR4 color);

	virtual void create() {}
	virtual void destroy();

	virtual void render();
	virtual void advanceTime(float fElapsedTime, float fDt);


	void			collided(D3DVECTOR pos, D3DVECTOR normal);
	void			interactWithBlob(const LLBlob* pllb, float dt);

	D3DVECTOR		getPos() const { return m_Pos; }
	float			getRadius() const { return m_fRadius; }
	float			getRadius2() const { return m_fRadius*m_fRadius; }

	int				getSpecies() const { return m_Species; }
	void			setSpecies(int s) { m_Species = s; }

	void			setColor(D3DVECTOR4 color) { m_BlobColor = color; }
	const D3DVECTOR4& getColor() const { return m_BlobColor; }


	static const LavaLampInterior* spLL;
};


class LavaLampInterior : public RenderObject
{
protected:
	enum { NUM_LLBLOBS = 64 };
	LLBlob m_Blobs[NUM_LLBLOBS];

    DWORD                   m_dwVertexShader;   // Vertex shader handle
    DWORD					m_dwPixelShader;	// Handle for pixel shader

	LPDIRECT3DCUBETEXTURE8	m_pNormCubemap;
	LPDIRECT3DDEVICE8		m_pd3dDevice;

	void					InitPixelShader();

	enum { MAX_CONIC_SECTIONS = 32 };
	int						m_NumConicSections;
	float					m_ConicSectionCenterX, m_ConicSectionCenterY;
	float					m_ConicSectionBotZ[MAX_CONIC_SECTIONS+1];
	float					m_ConicSectionRadius[MAX_CONIC_SECTIONS+1];
	float					m_ConicSectionSlope[MAX_CONIC_SECTIONS];	// dr/dz
	float					m_ConicSectionNormalR[MAX_CONIC_SECTIONS];	// -1, normalized
	float					m_ConicSectionNormalZ[MAX_CONIC_SECTIONS];	// slope, normalized

	static QRand			m_QRand;



public:

	virtual bool isVisible() { return true; }
	virtual void create();
	virtual void destroy();

	virtual void render();
	virtual void advanceTime(float fElapsedTime, float fDt);


	float	getBottom() const { return m_ConicSectionBotZ[0]; }
	float	getTop() const { return m_ConicSectionBotZ[m_NumConicSections+1]; }

	float	getRadius(float z) const
	{
		if (z < m_ConicSectionBotZ[0]) return 0.0f;
		for (int i=1; i<=m_NumConicSections; i++)
		{
			if (m_ConicSectionBotZ[i+1] < z) continue;
			float diff = m_ConicSectionBotZ[i+1] - m_ConicSectionBotZ[i];
			float s = (z - m_ConicSectionBotZ[i]) / diff;
			return m_ConicSectionRadius[i] + s*(m_ConicSectionRadius[i+1] - m_ConicSectionRadius[i]);
		}
		return 0.0f;
	}


	// Temperature is 1.0f at bottom, ramps to 0.0f at top.
	float getTemperature(float z) const;

	void collide(LLBlob* pllb, float x, float y, float z, float radius, float dt) const;
	bool collideWithCaps(LLBlob* pllb, float x, float y, float z, float radius) const;


	void recomputeSpecie();

	static inline float fRand01();
	static inline float fRand11();
};


#define LLI_RAND_MAX  0x00010000
#define LLI_RAND_MASK 0x0000FFFF

float LavaLampInterior::fRand01()
{
	static float mul = 1.0f / ((float)LLI_RAND_MAX);
	return ((float)(m_QRand.Rand()&LLI_RAND_MASK)) * mul;
}

float LavaLampInterior::fRand11()
{
	static float mul = 2.0f / ((float)LLI_RAND_MAX);
	return (((float)(m_QRand.Rand()&LLI_RAND_MASK)) * mul) - 1.0f;
}



#endif // BLOBS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\camera.cpp ===
//
//	camera.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "camera.h"
#include "renderer.h"

///////////////////////////////////////////////////////////////////////////////
void Camera::Init()
{
	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::UnInit()
{
}
///////////////////////////////////////////////////////////////////////////////
void Camera::lookAt(const D3DVECTOR &cam_pos, const D3DVECTOR &look_pt, const D3DVECTOR &up)
{
	SetLookAt(cam_pos,look_pt,up,&matWTC);

	vPos = cam_pos;
	vLook = look_pt;
	vUp = up;
	SetInverse(matWTC,&matCTW);
	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::setProjection(float fov_in_y, float aspect, float near_plane, float far_plane)
{
	SetProjection(fov_in_y,aspect,near_plane,far_plane,&matProj);
	fNearPlane = near_plane;
	fFarPlane = far_plane;
	fAspectRatio = aspect;
	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::translate(const D3DVECTOR &rv)
{
	matCTW._41 += rv.x;
	matCTW._42 += rv.y;
	matCTW._43 += rv.z;

	SetInverse(matCTW,&matWTC);

	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::setCTW(const D3DMATRIX &ctw)
{
	matCTW = ctw;
	SetInverse(matCTW,&matWTC);

	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
void Camera::setWTC(const D3DMATRIX &wtc)
{
	matWTC = wtc;
	SetInverse(matWTC,&matCTW);

	bClipPlanesSet = false;
	bWTPValid = false;
}
///////////////////////////////////////////////////////////////////////////////
bool Camera::sphereVisCheck(const D3DVECTOR &pos, float rad)
{
	D3DVECTOR dv;

	Set(&dv,pos.x-matCTW._41,pos.y-matCTW._42,pos.z-matCTW._43);
	float dot = Dot(dv,*((D3DVECTOR *)&matCTW._31));

	if(dot+rad < fNearPlane)
		return false;
	if(dot-rad > fFarPlane)
		return false;

	if(!bClipPlanesSet)
	{
		updateClipPlanes();
	}

	for(int i=0; i<4; i++)
	{
		dot = Dot(pos,clipPlanes[i]);
		if(dot - clipPlanes[i].w > rad)
			return false;
	}
	
	return true;		
}
///////////////////////////////////////////////////////////////////////////////
void Camera::updateClipPlanes()
{
	D3DVECTOR pts[4];
	Set(&pts[0], 1.f, 1.f, 1.f);
	Set(&pts[1], 1.f,-1.f, 1.f);
	Set(&pts[2],-1.f, 1.f, 1.f);
	Set(&pts[3],-1.f,-1.f, 1.f);

	int ids[] =
	{
		0,1, 
		3,2, 
		2,0, 
		1,3, 
	};

	for(int i=0; i<4; i++)
	{
		D3DVECTOR norm,v;
		Sub(pts[ids[i*2+1]],pts[ids[i*2]],&v);
		Cross(pts[ids[i*2]],v,&norm);
		Normalize(&norm);

		TransformVector(norm,matCTW,&clipPlanes[i]);
		clipPlanes[i].w = Dot(clipPlanes[i],*(D3DVECTOR *)&matCTW._41);
	}

	bClipPlanesSet = true;
}
///////////////////////////////////////////////////////////////////////////////
float Camera::getPixelScaleForZ(float z) const
{
	float v = z / (matProj._11 * 320.f);
	return v;
}
///////////////////////////////////////////////////////////////////////////////
D3DMATRIX & Camera::getWTP()
{
	if( !bWTPValid )
	{
		MulMats(matWTC,matProj,&matWTP);
		bWTPValid = true;
	}

	return matWTP;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\CamControl.h ===
///////////////////////////////////////////////////////////////////////////////
// File: CamControl.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef CAMCONTROL_H
#define CAMCONTROL_H

#include "xbs_math.h"



/*
Uses Hermite interpolation, from page 54 of "Real-Time Rendering" (Moeller, Haines)


The finish nodes are:
	0: before the beginning of the slash, anything before this doesn't need to render the slash
	1: after exiting slash
	2: translated down, but still looking at center (but it is eclipsed by slash geometry) after this, only render slash
	3: partly rotated to final position, looking at slash center now
	4: final position
	5: final position, with high time value (the endcap)

*/


struct CamControlNodeData
{
public:
	unsigned char	ucTime;					// Time when the camera arrives here (0 indicates start of new path, 100 is start of finalization)
	signed char		scTension, scBias;		// Tension and bias of point, from -100 to +100
	D3DVECTOR		ptPosition;				// Position of node
	D3DVECTOR		vecLookAt;				// Position the camera looks at
};




struct CamControlNode
{
public:
	float		fTime;			// Time when the camera arrives here (0 indicates start of new path)
	D3DVECTOR	ptPosition;		// Position of node
	D3DVECTOR	vecVelocity;	// Velocity at this point
	D3DVECTOR	vecLookAt;		// Position the camera looks at
	D3DVECTOR	vecLookAtW;		// Velocity of what the camera looks at
	float		tension, bias;
};


class CameraController
{
protected:
	static CamControlNodeData	svCameraListData[];
	static CamControlNode		svCameraList[];

	enum { NUM_FINISH_NODES = 8 };
	CamControlNode		finishNodes[NUM_FINISH_NODES];
	D3DMATRIX	xfSlash;
	D3DVECTOR	ptSlashCenter;
	D3DVECTOR	ptFinalLookAt;

	int			numNodes;
	int			numPaths;


	int			curPathNum;
	int			curStartNode;
	int			curNumNodes;
	int			curVariableNodes;
	
	float		fCameraLookatInterpStart, fOOCameraLookatInterpDelta;


	CamControlNode*			getNode(int i)			{ return (i<curVariableNodes) ? &svCameraList[i+curStartNode] : &finishNodes[i-curVariableNodes]; }
	const CamControlNode*	getNode(int i)	const	{ return (i<curVariableNodes) ? &svCameraList[i+curStartNode] : &finishNodes[i-curVariableNodes]; }

public:
	void Init();
	void UnInit() {}

	void		buttonPressed();


	void		pickPath(int path = -1);	// negative indicates random


	void		getPosition(float t, D3DVECTOR* p_pos, D3DVECTOR* p_look, bool* pb_render_geom, bool* pb_render_slash);

	const D3DMATRIX&	getSlashTransform()	const	{ return xfSlash; }
};



#endif // CAMCONTROL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\camera.h ===
//
//	camera.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __CAMERA_H__
#define __CAMERA_H__

#include "xbs_math.h"

///////////////////////////////////////////////////////////////////////////////
class Camera
{
protected:

	

	D3DVECTOR4   clipPlanes[4];
	bool         bClipPlanesSet;
	float        fNearPlane;
	float        fFarPlane;
	float		 fAspectRatio;

	bool         bWTPValid;

	float        fTime;

	D3DVECTOR    vPos;
	D3DVECTOR    vLook;
	D3DVECTOR    vUp;

	D3DMATRIX    matWTP;

public:

	D3DMATRIX    matCTW;
	D3DMATRIX    matWTC;
	D3DMATRIX    matProj;


	void Init();
	void UnInit();

	void lookAt(const D3DVECTOR &cam_pos, const D3DVECTOR &look_pt, const D3DVECTOR &up);
	void setProjection(float fov_in_y, float aspect, float near_plane, float far_plane);
	void setCTW(const D3DMATRIX &ctw);
	void setWTC(const D3DMATRIX &wtc);
	void translate(const D3DVECTOR &relative_vector);

	bool sphereVisCheck(const D3DVECTOR &pos, float r);
	void updateClipPlanes();

	float getPixelScaleForZ(float z) const ;
	D3DMATRIX & getWTP();
	void		getCameraPos (D3DVECTOR* p_pos)		const	{ *p_pos = vPos; }
	void		getCameraLook(D3DVECTOR* p_look)	const	{ *p_look= vLook; }
	float		getFarPlane()						const	{ return fFarPlane; }
	float		getAspectRatio()					const	{ return fAspectRatio; }
};
#endif // __BS_CAMERA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\defines.h ===
//
//	defines.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __DEFINES_H__
#define __DEFINES_H__


//#define FINAL_BUILD



const float DEMO_TOTAL_TIME = 8.0f;
const float FINAL_HOLD_TIME	= 2.0f;
const float FINISH_TRANSITION_TIME = 0.8f;

#define TEXT_ANIM_START_TIME                (DEMO_TOTAL_TIME - FINAL_HOLD_TIME)
const float TEXT_ANIM_LEN = 0.25f;


const float BLOB_STATIC_END_TIME = 0.6f;
#define OO_BLOB_STATIC_END_TIME				(1.0f / BLOB_STATIC_END_TIME)
#define BLOB_ZERO_INTENSE_END_TIME			(BLOB_STATIC_END_TIME + 0.5f)
const float BLOB_BASE_INTENSITY = 0.3f;

#define FINISH_START_TIME					(DEMO_TOTAL_TIME - FINAL_HOLD_TIME - FINISH_TRANSITION_TIME)
#define FINISH_STOP_TIME					(DEMO_TOTAL_TIME - FINAL_HOLD_TIME)
#define OO_FINISH_DELTA						(1.0f / FINISH_TRANSITION_TIME)

#define MAX_INTENSITY_TIME					(FINISH_START_TIME - 0.0f)
#define MAX_INTENSITY_DELTA					(MAX_INTENSITY_TIME - BLOB_ZERO_INTENSE_END_TIME)
#define OO_MAX_INTENSITY_DELTA				(1.0f / MAX_INTENSITY_DELTA)
const float DEMO_START_INTENSITY = 0.0f;


// For timing the blob pulses.
#define BLOB_PULSE_START					(BLOB_STATIC_END_TIME)
#define BLOB_PULSE_END						(FINISH_STOP_TIME - 0.4f)
#define BLOB_PULSE_ELAPSED					(BLOB_PULSE_END - BLOB_PULSE_START)

#define BLOB_JITTER_START					(BLOB_STATIC_END_TIME)
#define BLOB_JITTER_DELTA					(FINISH_START_TIME)
#define OO_BLOB_JITTER_DELTA				(1.0f / BLOB_JITTER_DELTA)


const float SCENE_ANIM_LEN = 4.5f;
#define SCENE_ANIM_START_TIME				(BLOB_STATIC_END_TIME + 0.25f)


const float START_PUSHOUT_RADIUS = 0.0f;
const float PUSHOUT_START_TIME = 0.5f;
const float PUSHOUT_DELTA = 2.7f;
#define OO_PUSHOUT_DELTA					(1.0f / PUSHOUT_DELTA)


#define SHIELD_FADE_IN_START_TIME			(BLOB_STATIC_END_TIME)
const float SHIELD_FADE_IN_DELTA = 1.2f;
#define OO_SHIELD_FADE_IN_DELTA				(1.0f / SHIELD_FADE_IN_DELTA)
#define SHIELD_FADE_OUT_START_TIME			(FINISH_START_TIME - 0.1f)
#define SHIELD_FADE_OUT_DELTA				(FINISH_TRANSITION_TIME * 0.2f)
#define OO_SHIELD_FADE_OUT_DELTA			(1.0f / SHIELD_FADE_OUT_DELTA)


#define GLOW_FADE_CIRCLE_START				(FINISH_START_TIME - 0.5f)
#define GLOW_FADE_CIRCLE_MUL				(1.0f / 0.3f)

#define GLOW_FADE_SCREEN_START				(GLOW_FADE_CIRCLE_START + 0.3f)
#define GLOW_FADE_SCREEN_MUL				(1.0f / 0.25f)


#define SLASH_GRADIENT_TRANSITION_START		(FINISH_START_TIME - 0.5f)
//MTS#define SLASH_GRADIENT_TRANSITION_END		(FINISH_STOP_TIME + 0.75f)
#define SLASH_GRADIENT_TRANSITION_END		(FINISH_STOP_TIME)
#define SLASH_GRADIENT_TRANSITION_MUL		(1.0f / (SLASH_GRADIENT_TRANSITION_END - SLASH_GRADIENT_TRANSITION_START))

#define SCENE_LO_DETAIL_START               (FINISH_START_TIME)

#ifdef STARTUPANIMATION
#define FINAL_BUILD
#endif // STARTUPANIMATION




#ifndef FINAL_BUILD

#define INCLUDE_PLACEMENT_DOODAD
#define INCLUDE_INPUT

#endif






#endif // __DEFINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\CF.C ===
/*************************************************************************
*                                                                        *
* 	Here live the sound call processing functions			  *
*                                                                        *
*************************************************************************/

#include "sos.h"
#include "protos.h"
#include "externs.h"
#include <dsound.h>

extern	unsigned char	sound_call;	
extern struct timer_music music_timers[];
extern	unsigned char	n_timers;


#ifdef	BIGOS
unsigned char	restore_volume;

#endif

/*************************************************************************
*                                                                        *
* 	New Music Call:							  *
*	Note that if no tracks are specified, this is a silence call	  *
*									  *
* 	1.  Remove all current process for this level			  *
* 	2.  For each track in the new sound, create a new process	  *
* 	    for it.							  *
*                                                                        *
*************************************************************************/


	
void call_silence()
{
	struct process *tpp;
	struct process *pp;
	uchar	i;

	pp = process_queue->next;
	while (pp != NULL) {
	    tpp = pp->next;
	    kill_process(pp);
	    pp = tpp;
	}
	current_timer_priority = 0;
	for (i = 0; i < max_tracks; i++) {
	    channel_level[i] = 0;
		init_track_status(LEVEL_MUSIC,i);
		init_track_status(LEVEL_EFFECT,i);
	    nosound(i);
	}

	user_silence_function();
}


void call_music()
{
	ushort	const **track_ptr;		/* pointer to addr's of tracks */
	uchar	i;
	ushort	mask;
	ushort	track_map;

	marker = 0;	
	last_music_call = sound_call;

	remove_processes_by_level(LEVEL_MUSIC);
	track_map = current_call->track_map;
	track_ptr = current_call->tbl_ptr;
	for (i = 0,mask = 1; i < max_tracks; i++,mask <<= 1) {
	    if (track_map & mask) {	/* got a track to pl*/
			init_track_status(LEVEL_MUSIC,i);
			create_process((ushort *)*(track_ptr++),LEVEL_MUSIC,i);	
			if (channel_level[i] < LEVEL_EFFECT) {
				nosound(i);
			    channel_level[i] = LEVEL_MUSIC;
			}
	    }
	}

}

void call_play_timer()
{

}

void call_timer()
{

}

void call_end_timer()
{


}
void call_ignore()
{

}

extern	flash_yellow();
void call_effect()
{
	ushort	const **track_ptr;		/* pointer to addr's of tracks */
	uchar	i;
	ushort	mask;
	ushort	track_map;

	track_ptr = current_call->tbl_ptr;
	track_map = current_call->track_map;
	for (i = 0,mask = 1; i < max_tracks; i++,mask <<= 1) {
	    if (track_map & mask) {	/* got a track to pl*/
			remove_processes_by_level_and_channel(LEVEL_EFFECT,i);
			channel_level[i] = LEVEL_EFFECT;
			init_track_status(LEVEL_EFFECT,i);
			create_process((ushort *)*(track_ptr++),LEVEL_EFFECT,i);
	    }
	}
}

/*************************************************************************
*                                                                        *
* 	kill fx on all tracks											  *
*                                                                        *
*************************************************************************/

void call_kill_effect()
{

}



/*************************************************************************
*                                                                        *
* 	Send a byte to the yamaha										  *
* 	WARNING:  This routine blocks until it recieves both the		  *
* 	address AND data												  *
*                                                                        *
*************************************************************************/
#define	CALL_WAITING  (fifo.fifo_read != fifo.fifo_write)

void call_senddev()
{
#ifdef	BIGOS

	while (!CALL_WAITING)
		;
	b_value = get_fifo();
	while (!CALL_WAITING)
		;
	a_value = get_fifo();
	send_dev_function();
#endif
}
/*************************************************************************
*                                                                        *
* 	VOLUME SOUND CALL						  *
* 	byte 1:("type")	       	3 -> volume call			  *
* 	byte 2:("priority")	1 -> music volume; 2 -> fx volume	  *
* 	byte 3,4:("track_map")	level 					  *
* 	byte 5,6:		not used (MUST BE THERE)		  *
*                                                                        *
*************************************************************************/

void call_volume()
{

}


/************************************************************************
*                                                                      *
* 	MARK SOUND CALL
* 	byte 1:("type")	       	6 -> mark call							*
* 	byte 2:("priority")	marker #
* 	byte 3,4:("track_map")	NOT USED				  				*
* 	byte 5,6:		not used (MUST BE THERE)		  				*
*                                                                      *
*************************************************************************/

void call_mark()
{
	marker = current_call->priority;
}
		
init_track_status(uchar level, uchar channel)
{
	struct	track_info	*ti;
	ti = get_track_info_block2(level,channel);
/*	ti = get_track_info_block();*/
	
	ti->patch = 0;
	ti->loop_level = 0;
	ti->mux_level = 0;
	ti->transpose = 0;
	ti->filtercutoff = 0;
	ti->volume = 127;  /* */
	ti->pan = 0;
}


/*
 *	stop sound on channel chan
 */

void nosound(uchar chan)
{
	if (chan < max_tracks)
		silence_functions[chan](chan);
}

/*
 *	Remove all processes of level, 'level' from process queue
 */


remove_processes_by_level(uchar level)
{
	struct process *tpp;
	struct process *pp;

	pp = process_queue->next;

	while (pp != NULL) {
	    tpp = pp->next;
	    if (pp->level == level)
	        kill_process(pp);
	    pp = tpp;
	}
}
void remove_processes_by_level_and_channel(uchar level, uchar channel)
{
	struct process *tpp;
	struct process *pp;

	pp = process_queue->next;

	while (pp != NULL) {
	    tpp = pp->next;
	    if (pp->level == level) {
			if (pp->hard_channel == channel) {
		    	kill_process(pp);
			}
	    }
	    pp = tpp;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\dsptables.h ===
#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION


unsigned const short pitch_table_dsp[] = {
		0x80
};



unsigned short	FM32768[32768];

unsigned short	Sin128[128];


unsigned short	Saw128[128];



unsigned short Noise8192[8192];

unsigned short	ThunEl16[0x5540];	// size from thunel16k.equ
unsigned short	ReverseThunEl16[0x5540]; // reversed version

unsigned const char	ThunEl16Data[] = {
#include "thunel16.x00"
};


unsigned short	Glock[3768];	// size from glock.equ

unsigned const char	GlockData[] = {
#include "glock.x00"
};


unsigned short	Bubble[6719];	// size from bubble.equ

unsigned const char	BubbleData[] = {
#include "Bubble.x00"
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\CamControl.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: CamControl.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "xbs_math.h"
#include "xbs_app.h"
#include "CamControl.h"
///////////////////////////////////////////////////////////////////////////////
// Negative tension is rounder, Positive tension is sharper (and comes
// to more of a stop at the point).
// Negative bias favors direction from previous to current, positive
// favors direction from current to next.
CamControlNodeData CameraController::svCameraListData[] =
{
//MTS	// Focusing on widgets, passing past blob.
//MTS    {  0,   +00, +00,        +3.2f,   -17.4f,   +13.0f,       -1.9f,    +7.8f,   -15.3f },
//MTS    { 20,   +00, +00,        +2.1f,   -12.1f,    +6.15f,      -1.9f,    +7.8f,   -15.3f },
//MTS    { 40,   +00, +00,        +1.0f,    -6.8f,    -0.7f,       -1.9f,    +7.8f,   -15.3f },
//MTS    { 55,   +00, +00,        -7.2f,    -3.6f,    -7.5f,       -1.9f,    +7.8f,   -15.3f },
//MTS    { 70,   +00, +00,       -18.5f,   +14.1f,   -18.4f,       -1.9f,    +7.8f,   -15.3f },
//MTS    { 85,   +00, +00,       -16.2f,   +29.2f,   -23.1f,       -5.1f,    +8.4f,   -10.3f },
//MTS    { 95,   +00, +00,       -10.6f,   +49.3f,   -21.2f,       -5.1f,    +8.4f,   -10.3f },
//MTS
//MTS    // "drunken"
//MTS	{  0,   +00, +00,        -1.5f,    +2.8f,   -14.0f,       -0.0f,    -1.3f,    +0.0f },
//MTS    { 20,   +00, +00,        -3.8f,   +16.9f,   -22.8f,       -0.0f,    -1.3f,    +0.0f },
//MTS    { 45,   +00, +00,       +20.7f,   +27.6f,   -21.6f,       -0.0f,    -1.3f,    +0.0f },
//MTS    { 75,   +00, +00,       +18.1f,   +46.8f,   -27.0f,       -0.0f,    -1.3f,    +0.0f },
//MTS    { 95,   +00, +00,       +28.9f,   +75.1f,   -36.7f,       -0.0f,    -1.3f,    +0.0f },

	// Top, pan down, pull out.
    {  0,   +00, +00,       +11.4f,   -32.1f,   +33.0f,       +0.0f,    +0.0f,    +0.0f },
    { 20,   +00, +00,       +13.4f,   -37.7f,   +25.6f,       +0.0f,    +0.0f,    +0.0f },
    { 40,   +00, +00,       +15.6f,   -43.9f,    +8.8f,       +0.0f,    +0.0f,    +0.0f },
    { 60,   +00, +00,       +16.0f,   -45.0f,   -12.8f,       +0.0f,    +0.0f,    +0.0f },
    { 90,   +00, +00,       +18.2f,   -51.2f,   -29.6f,       +0.0f,    +0.0f,    +0.0f },

//MTS	// Low, looking up, pull out, and pan up.
//MTS    {  0,   +00, +00,       +15.2f,    -3.3f,   -15.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 20,   +00, +00,       +26.2f,    -5.7f,   -20.5f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 45,   +00, +00,       +40.2f,    -8.7f,   -23.6f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 65,   +00, +00,       +61.2f,   -13.3f,    -3.6f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 85,   +00, +00,       +84.4f,    -4.8f,   +11.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    { 95,   +00, +00,      +120.4f,    -8.8f,   +14.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Looking low, closeup on the bottom, pull out and pan up.
//MTS    {  0,   +00, +00,       -20.5f,   +48.8f,   +12.0f,       +0.0f,    +0.0f,   -18.6f },
//MTS    { 35,   +00, +00,       -10.4f,   +24.6f,    -2.4f,       +0.0f,    +0.0f,   -18.6f },
//MTS    { 70,   +00, +00,       -10.4f,   +24.6f,    -2.4f,       +0.0f,    +0.0f,   -18.6f },
//MTS    { 85,   +00, +00,       -16.5f,   +39.3f,    +4.2f,       -0.3f,    +0.1f,    -5.3f },
//MTS    { 95,   +00, +00,       -26.3f,   +75.4f,    -4.6f,       -0.3f,    +0.1f,    -0.5f },
//MTS
//MTS	// Somewhat high, rotate left, recenter, pause, and pull out.
//MTS    {  00,   +0, +0,       -92.5f,   -10.1f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  15,   +0, +0,       -88.0f,   +30.4f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  30,   +0, +0,       -64.7f,   +67.0f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  45,   +0, +0,       -22.6f,   +90.3f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  60,   +0, +0,       +21.7f,   +90.5f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  72,   +0, +0,       +65.4f,   +66.2f,   +20.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  85,   +0, +0,       +97.5f,   +23.7f,   +16.1f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,      +110.8f,    -6.1f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// start a little low, slowly move up, drift right, pull out.
//MTS    {  00,   +0, +0,       +62.3f,   -28.5f,   -20.2f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  30,   +0, +0,       +62.3f,   -28.5f,   -20.2f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  50,   +0, +0,       +55.2f,   -25.3f,   -10.1f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  75,   +0, +0,       +56.7f,   -12.9f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       +73.9f,   -13.0f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Towards top, tube to the right, move down and left.
//MTS    {  00,   +0, +0,       +50.4f,   +33.2f,   +25.3f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  30,   +0, +0,       +50.4f,   +33.2f,   +25.3f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  45,   +0, +0,       +55.7f,    +9.3f,   +15.9f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  65,   +0, +0,       +39.1f,   -35.8f,    +3.3f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  90,   +0, +0,        +7.1f,   -53.7f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       -16.8f,   -78.0f,    +0.0f,       +0.0f,    +0.0f,    +0.0f },

	// Start low near tube, pause, quickly go up and to the right, pause, pull out.
    {  00,   +0, +0,       -55.4f,   +19.7f,   -31.5f,       +0.0f,    +0.0f,    +0.0f },
    {  30,   +0, +0,       -55.4f,   +19.7f,   -31.5f,       +0.0f,    +0.0f,    +0.0f },
    {  45,   +0, +0,       -39.5f,    -0.6f,    -7.8f,       +0.0f,    +0.0f,    +0.0f },
    {  60,   +0, +0,        -4.3f,   -35.5f,   +16.6f,       +0.0f,    +0.0f,    +0.0f },
    {  70,   +0, +0,       +31.1f,   -32.6f,   +17.6f,       +0.0f,    +0.0f,    +0.0f },
    {  80,   +0, +0,       +57.7f,    -7.2f,    +3.3f,       +0.0f,    +0.0f,    +0.0f },
    {  95,   +0, +0,       +70.9f,    +1.8f,    +3.1f,       +0.0f,    +0.0f,    +0.0f },

	// Low, move up, go left, pull out.
//MTS    {  00,   +0, +0,       -51.7f,    -2.4f,   -32.4f,       +0.0f,    +0.0f,   +12.0f },
//MTS    {  25,   +0, +0,       -51.7f,    -2.4f,   -32.4f,       +0.0f,    +0.0f,   +12.0f },
//MTS    {  40,   +0, +0,       -54.4f,    -2.6f,   -23.3f,       +0.0f,    +0.0f,   +10.0f },
//MTS    {  50,   +0, +0,       -53.2f,    +6.7f,   -14.3f,       +0.0f,    +0.0f,    +7.0f },
//MTS    {  60,   +0, +0,       -41.8f,   +21.2f,    -9.3f,       +0.0f,    +0.0f,    +4.5f },
//MTS    {  70,   +0, +0,       -27.1f,   +34.2f,    -9.3f,       +0.0f,    +0.0f,    +2.0f },
//MTS    {  80,   +0, +0,        -6.9f,   +47.5f,    -9.3f,       +0.0f,    +0.0f,    +1.0f },
//MTS    {  88,   +0, +0,       +11.3f,   +52.3f,    -9.2f,       +0.0f,    +0.0f,    +0.5f },
//MTS    {  95,   +0, +0,       +24.2f,   +62.8f,    -9.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Orbit right (a little up).
//MTS    {  00,   +0, +0,        -2.6f,   -85.0f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  20,   +0, +0,       +48.1f,   -70.1f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  40,   +0, +0,       +80.1f,   -28.6f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  60,   +0, +0,       +81.4f,   +24.8f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  80,   +0, +0,       +56.5f,   +63.6f,   +17.7f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       +27.9f,   +86.5f,    +8.2f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Orbit left.
//MTS    {  00,   +0, +0,       +47.3f,   -76.6f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  25,   +0, +0,       +11.5f,   -89.3f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  50,   +0, +0,       -35.7f,   -82.6f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  75,   +0, +0,       -71.9f,   -54.2f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       -89.5f,    -9.6f,   -10.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS
//MTS	// Move down and to the right.
//MTS    {  00,   +0, +0,       -11.2f,   -42.9f,   +17.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  20,   +0, +0,        +2.6f,   -46.9f,    +7.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  40,   +0, +0,       +24.3f,   -40.5f,    -4.2f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  60,   +0, +0,       +38.7f,   -24.8f,    -9.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  80,   +0, +0,       +44.3f,   -12.1f,    -7.0f,       +0.0f,    +0.0f,    +0.0f },
//MTS    {  95,   +0, +0,       +52.4f,    +6.3f,    +2.0f,       +0.0f,    +0.0f,    +0.0f },

	// Rotate to left, fairly close.
    {  00,   +0, +0,       +34.7f,   +25.9f,   +12.3f,       +0.0f,    +0.0f,    +0.0f },
    {  25,   +0, +0,       +42.3f,    +9.3f,   +12.3f,       +0.0f,    +0.0f,    +0.0f },
    {  50,   +0, +0,       +42.4f,    -8.8f,   +12.3f,       +0.0f,    +0.0f,    +0.0f },
    {  75,   +0, +0,       +34.4f,   -26.3f,   +12.3f,       +0.0f,    +0.0f,    +0.0f },
    {  95,   +0, +0,       +30.7f,   -48.1f,   +14.3f,       +0.0f,    +0.0f,    +0.0f },

	// Start out low, pause, rotate up slightly and pull out.
	{  0,   +00, +00,       -50.1f,    -0.3f,   -51.5f,       +0.0f,    +0.0f,    +0.0f },
	{  25,  +00, +00,       -50.1f,    -0.3f,   -51.5f,       +0.0f,    +0.0f,    +0.0f },
	{  75,  +00, +00,       -50.1f,    -0.3f,   -51.5f,       +0.0f,    +0.0f,    +0.0f },
    {  95,  +00, +00,       -62.2f,    -0.4f,   -12.0f,       +0.0f,    +0.0f,    +0.0f },
};

#define NUM_CC_NODES  (sizeof(CameraController::svCameraListData)/sizeof(CamControlNodeData))

CamControlNode CameraController::svCameraList[NUM_CC_NODES];
///////////////////////////////////////////////////////////////////////////////
void CameraController::Init()
{
	numNodes = NUM_CC_NODES;
	numPaths = 0;
	curPathNum = -1;
	for (int i=0; i<numNodes; i++)
	{
		if (svCameraListData[i].ucTime == (unsigned char) 0) numPaths++;

		svCameraList[i].fTime = FINISH_START_TIME * ((float)svCameraListData[i].ucTime) * 0.01f;
		svCameraList[i].ptPosition = svCameraListData[i].ptPosition;
		svCameraList[i].vecLookAt = svCameraListData[i].vecLookAt;
		svCameraList[i].tension = ((float)svCameraListData[i].scTension) * 0.01f;
		svCameraList[i].bias = ((float)svCameraListData[i].scBias) * 0.01f;

//MTS		char buf[1024];
//MTS		D3DVECTOR pos = svCameraList[i].ptPosition;
//MTS		D3DVECTOR la = svCameraList[i].vecLookAt;
//MTS		sprintf(buf, "    {  %02d,   %+02d, %+02d,    %+8.1ff,%+8.1ff,%+8.1ff,   %+8.1ff,%+8.1ff,%+8.1ff },\n",
//MTS						(int) svCameraListData[i].ucTime, (int) svCameraListData[i].scTension, (int) svCameraListData[i].scBias,
//MTS						pos.x, pos.y, pos.z, la.x, la.y, la.z);
//MTS		if (svCameraListData[i].ucTime==0) OutputDebugString("\n");
//MTS		OutputDebugString(buf);
	}

	pickPath(-1);
}
///////////////////////////////////////////////////////////////////////////////
// negative indicates random
void CameraController::pickPath(int path)
{
	if (path<0)
	{
		path = ((unsigned int) (gApp.rand() & 0x7FFFFFFF));
	}
	if (path >= numPaths) path = path % numPaths;


	// The following line cycles the selected path. Without it, path selection is random.
//MTS	path = (curPathNum + 1) % numPaths;


//MTS	path = 1;

	curPathNum = path;



//MTS	char buf[1024];
//MTS	sprintf(buf, "Picked path %d\n", path);
//MTS	OutputDebugString(buf);


	int i;
	for (i=0; i<numNodes; i++)
	{
		if (svCameraList[i].fTime == 0.0f)
		{
			if (!path) break;
			path--;
		}
	}
	curStartNode = i;

	for (i=curStartNode+1; i<numNodes; i++)
	{
		if (svCameraList[i].fTime == 0.0f) break;
	}
	curVariableNodes = i - curStartNode;
	curNumNodes = curVariableNodes + NUM_FINISH_NODES;


	// Calculate the finishNodes.
	int j;
	for (j=0; j<NUM_FINISH_NODES; j++)
	{
		finishNodes[j].fTime = FINISH_START_TIME + FINISH_TRANSITION_TIME * ((float)j) / ((float)(NUM_FINISH_NODES-1));
		finishNodes[j].tension = +0.0f;
		finishNodes[j].bias = 0.0f;
	}

	fCameraLookatInterpStart = finishNodes[2].fTime;
	fOOCameraLookatInterpDelta = 1.0f / (finishNodes[5].fTime - fCameraLookatInterpStart);




	const CamControlNode* plast = &svCameraList[curStartNode + curVariableNodes - 1];
	CamControlNode* pthis = &finishNodes[0];
	
	float start_time = plast->fTime;

//MTS	const float slash_start_rad = -185.0f;
	const float slash_start_rad = -95.0f;
	const float slash_end_rad = 132.14f;

//MTS	const float cfYPositions[NUM_FINISH_NODES] = { 185.0f, 117.548f, -8.819f, -150.298f, -220.64f, -243.021f, -261.441f, -287.773f };
	const float cfYPositions[NUM_FINISH_NODES] = { +95.0f, +30.548f, -70.819f, -150.298f, -220.64f, -243.021f, -261.441f, -287.773f };
	const float cfZPositions[NUM_FINISH_NODES] = { 0.0f,   0.322f,   1.821f, 2.323f,    -11.926f,  -39.973f,  -60.774f,  -90.795f };
	const float camera_end_coord_y = cfYPositions[NUM_FINISH_NODES-1];
	const float camera_end_coord_z = cfZPositions[NUM_FINISH_NODES-1];

	const float lookat_offset = slash_end_rad * camera_end_coord_z / camera_end_coord_y;
	const float cfSlashDist = slash_end_rad - slash_start_rad;
	const float cfMinStartDist = 100.0f;






	
	// First finish node is at the entrance of the slash. Take the last nodes
	// velocity, move along it for a little bit, and then push it out to the
	// appropriate radius, about 200 units.
	// The slash's transform will also be set now.

	pthis->ptPosition = plast->ptPosition;

	D3DVECTOR vel;
	if (curVariableNodes >= 2)
	{
		Sub(getNode(curVariableNodes-1)->ptPosition, getNode(curVariableNodes-2)->ptPosition, &vel);
		Scale(&vel, 1.0f / (getNode(curVariableNodes-1)->fTime - getNode(curVariableNodes-2)->fTime));
	}
	else
	{
		Set(&vel, 0.0f, 0.0f, 0.0f);
	}

	AddScaled(&pthis->ptPosition, vel, (pthis->fTime - plast->fTime) * 0.7f);
	float vel_adj_len = Length(pthis->ptPosition);
	Scale(&pthis->ptPosition, 1.0f / vel_adj_len);	// normalizes

	D3DVECTOR slash_dir = pthis->ptPosition;
	float slash_y_offset = max(cfMinStartDist - slash_start_rad, vel_adj_len * 1.2f - slash_start_rad);
	Scale(&pthis->ptPosition, slash_y_offset + slash_start_rad);

	Set(&pthis->vecLookAt, 0.0f, 0.0f, 0.0f);



//MTS// Matches slash with barry's coordinates.
//MTSSet(&pthis->ptPosition, 0.0f, -1.0f, 0.0f);
//MTSSet(&slash_dir, 0.0f, -1.0f, 0.0f);
//MTSslash_y_offset = 0.0f;



	// Now do the slash xform.

	D3DVECTOR origin, up, x_dir, y_dir, z_dir;
	Set(&origin, 0.0f, 0.0f, 0.0f);
	Set(&up, 0.0f, 0.0f, 1.0f);

	// The shape has negative y going away from core.
	// Negative Y is normalized vector from slash_pos to origin
	y_dir = slash_dir;
	Scale(&y_dir, -1.0f);

	// X is y_dir crossed with up and normalized.
	Cross(y_dir, up, &x_dir);
	Normalize(&x_dir);

	// Z is x_dir cross y_dir.
	Cross(x_dir, y_dir, &z_dir);		// I think this is the wrong cross order...

	SetIdentity(&xfSlash);
	*((D3DVECTOR*)(&xfSlash._11)) = x_dir;
	*((D3DVECTOR*)(&xfSlash._21)) = y_dir;
	*((D3DVECTOR*)(&xfSlash._31)) = z_dir;
	*((D3DVECTOR*)(&xfSlash._41)) = y_dir;
	Scale((D3DVECTOR*)(&xfSlash._41), -slash_y_offset);
	ptSlashCenter = y_dir;
	Scale(&ptSlashCenter, - slash_end_rad - slash_y_offset);

//MTS	AddScaled(&pthis->ptPosition, z_dir, -7.0f);



	//const float cfYPositions[NUM_FINISH_NODES] = { 185.0f, 177.548f, 58.819f, -170.298f, -220.871f, -243.021f, -260.364f, -277.299f };
	float y_basis = slash_end_rad;
	for (j=1; j<NUM_FINISH_NODES; j++)
	{
		plast = pthis++;
		D3DVECTOR pt_in_slash;
		Set(&pt_in_slash, 0.0f, cfYPositions[j] + y_basis , cfZPositions[j]);
		TransformVector(pt_in_slash, xfSlash, &pthis->ptPosition);
		Add(pthis->ptPosition, ptSlashCenter, &pthis->ptPosition);
		Set(&pthis->vecLookAt, 0.0f, 0.0f, 0.0f);
	}






	// Set the final lookat point
	D3DVECTOR t;
	Set(&t, 0.0f, slash_end_rad, 25.0f);
	TransformVector(t, xfSlash, &ptFinalLookAt);
	Add(ptFinalLookAt, ptSlashCenter, &ptFinalLookAt);


	
	// Set the "m" parameters implicitly.

	for (j=0; j<curNumNodes; j++)
	{
		CamControlNode* pthis = getNode(j);
		Set(&pthis->vecVelocity, 0.0f, 0.0f, 0.0f);
		Set(&pthis->vecLookAtW, 0.0f, 0.0f, 0.0f);

		if (j)
		{
			D3DVECTOR delta;
			Sub(pthis->ptPosition, getNode(j-1)->ptPosition, &delta);
			AddScaled(&pthis->vecVelocity, delta, (1.0f - pthis->tension) * (1.0f + pthis->bias) * 0.5f);

			Sub(pthis->vecLookAt, getNode(j-1)->vecLookAt, &delta);
			AddScaled(&pthis->vecLookAtW, delta, (1.0f - pthis->tension) * (1.0f + pthis->bias) * 0.5f);
		}
		if (j<curNumNodes-1)
		{
			D3DVECTOR delta;
			Sub(getNode(j+1)->ptPosition, pthis->ptPosition, &delta);
			AddScaled(&pthis->vecVelocity, delta, (1.0f - pthis->tension) * (1.0f - pthis->bias) * 0.5f);

			Sub(getNode(j+1)->vecLookAt, pthis->vecLookAt, &delta);
			AddScaled(&pthis->vecLookAtW, delta, (1.0f - pthis->tension) * (1.0f - pthis->bias) * 0.5f);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
void CameraController::getPosition(float t, D3DVECTOR* p_pos, D3DVECTOR* p_look, bool* pb_render_geom, bool* pb_render_slash)
{

	if (t > FINISH_STOP_TIME)
	{
		*p_pos = finishNodes[NUM_FINISH_NODES-1].ptPosition;
		*p_look = ptFinalLookAt;
		*pb_render_slash = true;
		*pb_render_geom = false;
		return;
	}

	int i;
	for (i=1; i<curNumNodes; i++)
	{
		if (getNode(i)->fTime > t) break;
	}
	if (i==curNumNodes)
	{
		*p_pos = getNode(curNumNodes-1)->ptPosition;
		*p_look = ptFinalLookAt;
		*pb_render_slash = true;
		*pb_render_geom = false;
		return;
	}
	if (i==0)
	{
		// Should never happen, but something is causing a lock...
		Set(p_pos, 0.0f, -90.0f, 0.0f);
		Set(p_look, 0.0f, 0.0f, 0.0f);
		*pb_render_slash = true;
		*pb_render_geom = false;
		return;
	}


	const CamControlNode* pprev = getNode(i-1);
	const CamControlNode* pnext = getNode(i);

	float dtc = max(0.001f, pnext->fTime - pprev->fTime);
	float dtp = max(0.001f, (i>=2) ? pprev->fTime - getNode(i-2)->fTime : dtc);
	float dtn = max(0.001f, (i<curNumNodes-1) ? getNode(i+1)->fTime - pnext->fTime : dtc);

	float uts = min(1.0f, max(0.0f, (t - pprev->fTime) / dtc));	// un-tweaked s
	float utss = uts*uts;
	float utsss = utss*uts;
	float frac = -2.0f*utsss + 3.0f*utss;
	float s = (t - pprev->fTime) / ((1.0f-frac)*dtp + frac*dtc);


	float ss = s*s;
	float sss = ss*s;
	float cA = 2.0f * sss - 3.0f * ss + 1.0f;
	float cB = sss - 2.0f * ss + s;
	float cC = sss - ss;
	float cD = -2.0f * sss + 3.0f * ss;

	p_pos->x = cA * pprev->ptPosition.x + cB * pprev->vecVelocity.x + cC * pnext->vecVelocity.x + cD * pnext->ptPosition.x;
	p_pos->y = cA * pprev->ptPosition.y + cB * pprev->vecVelocity.y + cC * pnext->vecVelocity.y + cD * pnext->ptPosition.y;
	p_pos->z = cA * pprev->ptPosition.z + cB * pprev->vecVelocity.z + cC * pnext->vecVelocity.z + cD * pnext->ptPosition.z;

	p_look->x = cA * pprev->vecLookAt.x + cB * pprev->vecLookAtW.x + cC * pnext->vecLookAtW.x + cD * pnext->vecLookAt.x;
	p_look->y = cA * pprev->vecLookAt.y + cB * pprev->vecLookAtW.y + cC * pnext->vecLookAtW.y + cD * pnext->vecLookAt.y;
	p_look->z = cA * pprev->vecLookAt.z + cB * pprev->vecLookAtW.z + cC * pnext->vecLookAtW.z + cD * pnext->vecLookAt.z;


	float sl = max(0.0f, min(1.0f, (t - fCameraLookatInterpStart) * fOOCameraLookatInterpDelta));
	
	float _sin,_cos;
	SinCos(sl * Pi,&_sin,&_cos);
	float interp = 0.5f*(1.0f - _cos);

	Scale(p_look, 1.0f - interp);
	AddScaled(p_look, ptFinalLookAt, interp);



	*pb_render_slash = (i > curVariableNodes - 1);
	*pb_render_geom  = (i < curNumNodes - 1);
}
///////////////////////////////////////////////////////////////////////////////
void CameraController::buttonPressed()
{
#ifndef STARTUPANIMATION
#ifdef INCLUDE_PLACEMENT_DOODAD	
	char buf[1024];
	D3DVECTOR pos;
	D3DVECTOR la = gApp.getLookatPoint();
	gApp.theCamera.getCameraPos(&pos);
	sprintf(buf, "    {  0,   +00, +00,    %+8.1ff,%+8.1ff,%+8.1ff,   %+8.1ff,%+8.1ff,%+8.1ff },\n",
					pos.x, pos.y, pos.z, la.x, la.y, la.z);
	OutputDebugString(buf);
#endif
#endif // STARTUPANIMATION
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\DEV.C ===
/*************************************************************************
*                                                                        *
*   This file contains the tables and definitions for                 *
*   the synthesis specific DEVice                                     *
*      The device tables are in devtab.c                                  *
**************************************************************************
*
*   The following variables and tables must be defined:
*
*   max_tracks:     1 byte, max # of synthesis channels
*   dev_init:       function called to initialize device
*   do_watchdog     function called to  kick watchdog timer
*   dtimer_int      function called to  disable timer interrupt
*   etimer_int      function called to  enable timer interrupt
*   send_dev_function:
*       function called to send a byte of data to the synthesis
*       device (sound call callable)
*       The data is in the global, "a_value" and the address is
*       in the global, "b_value."
**************************************************************************/

#define _base_

extern  struct DSPpatch *Patches[];
extern  unsigned short  Noise8192[];

#include    <dsound.h>
#include "sosdsp.h"
#include "sos.h"
#include "bootsnd.h"
#include    <xtl.h>
#include "dsptables.h"

#define MAX_BUFFERS 16

#ifdef STARTUPANIMATION
#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif

LPDIRECTSOUND8          m_pDSound;                          // DirectSound object
LPDIRECTSOUNDBUFFER8    m_pDSBuffer[MAX_BUFFERS];           // DirectSoundBuffer
extern WCHAR    StringBuffer[];

#define MIN(a,b) (((signed) a) < ((signed) b) ? (a) : (b))

/*
 *  track_status has the necessary items to restore the state of
 *  a track after a track of a higher level on the same channel
 *  ends
 */

#define MAX_TRACKS  16
#define MAX_PROCESSES       30
#define MAX_LEVELS      2

uchar       channel_level[MAX_TRACKS];/* current level for each chan*/
struct track_info track_status[(MAX_LEVELS) * MAX_TRACKS];
struct process queue_list[MAX_PROCESSES]; /* pre-allocated process packets */
extern      struct sound    * _base_ current_call;      /* pointer to current sound call */
extern  uchar   sound_call_table;


const   unsigned short  max_processes = MAX_PROCESSES;

extern          uchar       a_value, b_value;
unsigned int    dsp_address;
unsigned int    dsp_data;   
extern  ushort      value_16_bit;
extern  uchar   current_channel;
extern  uchar       master_music_volume;    /* main attenuation for music   */
extern  uchar       master_effect_volume;   /* main attenuation for f/x */
extern  uchar       music_atten;            /* music attenuation */
extern  uchar   init_call;
extern  uchar   current_level;      /* global level of current process */
extern  struct  track_info  * _base_ ti;    /* track info pointer */
extern  uchar   pan_table[];                    /* panning table (8-bit) */
void    put_dsp(void);
extern  reset_dsp();
void    init_dsp(void);
void    put_fifo(unsigned char);
const   unsigned char   max_tracks = MAX_TRACKS;

extern void (* const call_fcns[])();

int volume_dsp(uchar, uchar, uchar *,uchar);
int silence_dsp(uchar);
int note_on_dsp();
int slur_dsp();
int note_off_dsp();
int patch_dsp(unsigned short);
int pan_dsp(uchar , signed char, uchar *);
int vp_filter();



int (* const filter_functions[])() = {
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter,
    vp_filter   
};


int (* const silence_functions[])() = {
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    silence_dsp,
    
};

/**************************************************************************
*                                                                        *
*   The note_on functions turn a note on.  They assume that           *
*   the global, "a_value" has the current channel # and that          *
*   the global "value_16_bit" has the 16 bit pitch (iiiiiiii.ffffffff *
*      and "b_value" has the integer part of the pitch                    *
*************************************************************************/
int (* const note_on_functions[])() = {
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
    note_on_dsp,
};



int (* const slur_functions[])() = {
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
    slur_dsp,
};


/*************************************************************************
*                                                                        *
*   The note_off functions turn a note off.  They assume that         *
*   the global, "a_value" has the current channel.                    *
*************************************************************************/
int (* const note_off_functions[])() = {
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
    note_off_dsp,
};
int (* const patch_functions[]) () = {
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,
    patch_dsp,

};


int (* const volume_functions[])() = {
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,
    volume_dsp,

};
int (* const pan_functions[])() = {
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,
    pan_dsp,

};


int (* const user_1_var_evf_functions[])() = {
    pan_dsp
};
int (* const user_2_var_evf_functions[])() = {
    pan_dsp
};

//
// write data from global var dsp_data to x memory space "dsp_address"
//

void put_dsp()
{

//  LPVOID pvXramBuffer;
//  pvXramBuffer = (LPVOID) (dsp_address);

//    memcpy(pvXramBuffer,pvData,dwDataSize);

//  *(PDWORD) (GPXMEM + dsp_address) = dsp_data;
    
}


WriteDSPDatablock
(
    DWORD                   dwDSPAddress, 
    LPCVOID                 pvData, 
    DWORD                   dwDataSize
)
{
    LPVOID pvXramBuffer;

        //
        // poke directly the XRAM offset
        //

    pvXramBuffer = (LPVOID) (GPXMEM + dwDSPAddress);
    memcpy(pvXramBuffer,pvData,dwDataSize);

 
    return 1;

}

ReadDSPDatablock
(
    DWORD                   dwDSPAddress, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    LPVOID pvXramBuffer;
    //
    // copy fx data
    //
    pvXramBuffer = (LPVOID) (GPXMEM + dwDSPAddress);
    memcpy(pvData,pvXramBuffer,dwDataSize);

    return 1;
}

ReadDSPProgblock
(
    DWORD                   dwDSPAddress, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    LPVOID pvXramBuffer;
    //
    // copy fx data
    //
    pvXramBuffer = (LPVOID) (GPPMEM + dwDSPAddress);
    memcpy(pvData,pvXramBuffer,dwDataSize);

    return 1;
}

// return dsp data
int get_dsp(unsigned int addr)
{
//  return( (*PDWORD) (GPXMEM + dsp_address) );
    return(1);
}

silence_dsp(unsigned char chan)
{

    return(1);
}   


note_on_dsp()
{
    DWORD   dwFreq;
    struct DSPpatch *addr;

#if DBG

//  dwFreq = pitch_table_dsp[value_16_bit>>8];
//  swprintf( StringBuffer, L"Current Pitch: 0x%x", dwFreq);

#endif

    dwFreq = (DWORD) ( ((value_16_bit >> 8) - 60) * (4096/12) );
    dwFreq += ((((DWORD) value_16_bit & 0xff) * 341) / 255);
//  IDirectSoundBuffer_StopEx(m_pDSBuffer[current_channel], 0, DSBSTOPEX_ENVELOPE);
    IDirectSoundBuffer_SetPitch(m_pDSBuffer[current_channel], dwFreq);

    addr = Patches[ti->patch];
    if (addr->LoopEnable) 
        IDirectSoundBuffer_Play(m_pDSBuffer[current_channel], 0,0,DSBPLAY_LOOPING);
    else
        IDirectSoundBuffer_Play(m_pDSBuffer[current_channel], 0,0,0);

    return(1);

}
slur_dsp()
{
    DWORD   dwFreq;

    dwFreq = (DWORD) ( ((value_16_bit >> 8) - 60) * (4096/12) );
    dwFreq += ((((DWORD) value_16_bit & 0xff) * 341) / 255);

#if DBG
//  swprintf( StringBuffer, L"Current Pitch Slur: 0x%x", dwFreq);
#endif

    IDirectSoundBuffer_SetPitch(m_pDSBuffer[current_channel], dwFreq);

    return(1);
}

note_off_dsp()
{
    IDirectSoundBuffer_StopEx(m_pDSBuffer[current_channel], 0, DSBSTOPEX_ENVELOPE);
    return(1);

}

vp_filter()
{
    DSFILTERDESC    fdesc;


    fdesc.dwMode = DSFILTER_MODE_DLS2;
    fdesc.dwQCoefficient = 0;
    fdesc.adwCoefficients[0] = ti->filtercutoff + 32768;
    fdesc.adwCoefficients[1] = ti->filterres;
    fdesc.adwCoefficients[2] = ti->filtercutoff + 32768;
    fdesc.adwCoefficients[3] = ti->filterres;
    IDirectSoundBuffer_SetFilter(m_pDSBuffer[current_channel], &fdesc);
    return(1);
}



patch_dsp(unsigned short pat)
{
    struct DSPpatch *addr;

    addr = Patches[pat];

    IDirectSoundBuffer_SetEG(m_pDSBuffer[current_channel], addr->lpAmpEnvelope);
    IDirectSoundBuffer_SetEG(m_pDSBuffer[current_channel], addr->lpMultiEnvelope);
    IDirectSoundBuffer_SetBufferData(m_pDSBuffer[current_channel], addr->Start, addr->Length );
    IDirectSoundBuffer_SetLoopRegion( m_pDSBuffer[current_channel],0, addr->Length );
    IDirectSoundBuffer_SetCurrentPosition(m_pDSBuffer[current_channel], 0 );
    
    return(1);
}



pan_dsp(uchar chan, signed char pan, uchar *patch)
{
    uchar   mod;
    unsigned int    vol_mul;
    unsigned int    tmp;
    char            tmp_pan;

    vol_mul = 0x7fff;
    if (current_level >= 1) {           
/*      mod = master_effect_volume;*/
//      vol_mul = volume_table_dsp[master_music_volume];
    }
    else {
/*      mod = 0;*/
//      tmp = volume_table_dsp[music_atten];
//      vol_mul = volume_table_dsp[master_music_volume];

//      vol_mul = (long)((long)tmp * (long)vol_mul) >>15;
    
    }

    mod = 0;

    tmp_pan = ti->pan >> 3;

    tmp_pan += 16;                      /* set range 0 - 31 */
    tmp = 1;    
//  tmp = volume_table_dsp[MIN(127,ti->volume + mod)];
    tmp = (long)((long)tmp * (long)vol_mul) >>15;

/*  tmp >>= 7;*/
    dsp_data = (long) ((long)tmp * (long)pan_table[tmp_pan]) >> 7;
/*  dsp_data = (char)tmp * pan_table[tmp_pan];*/
//  a_value = VOLUME_L_ADDRESS(chan);
    put_dsp();

    dsp_data = (long) ((long)tmp * (long)pan_table[31 - tmp_pan]) >> 7;
/*  dsp_data = (char)tmp * pan_table[31 - tmp_pan];*/
//  a_value = VOLUME_R_ADDRESS(chan);
    put_dsp();

    return(1);

}


// initialize stuff for the dsp.
// write sine wave into high x memory.
// also create 16 dsound buffers that we'll use
// for our sounds.


static long holdrand = 1L;

void __cdecl srand(unsigned int seed)
{
    holdrand = (long)seed;
}

int __cdecl rand(void)
{
    return(((holdrand = holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
}

dev_init()
{
    
    DSBUFFERDESC dsbdesc;
    WAVEFORMATEX wfFirst;
    DWORD       dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FXSEND_0;
    long        lVolumes[3];
    int j;
    double  dtmp;
    double  FMc = 4.0;
    double  FMm = 2.0;


    int i;

    srand(1003);
    for (i = 0; i < 8192; i++) {
        Noise8192[i] = (unsigned short) rand();
    }

    for (i = 0; i < 128; i++) {
        Sin128[i] = (unsigned short)(32767*sin(2.0*3.14159*(double)i/128.0));
    }
    j = 0;
    for (i = 0; i < 32768; i++) {
        if (i < 16384)
            j++;
        else
            j--;
        dtmp = (double)j/16384.0  * sin(FMm * 2.0*3.14159*(double)i/128.0);
        FM32768[i] = (unsigned short)(32767*sin(dtmp + FMc * 2.0*3.14159*(double)i/128.0));
    }

    for (i = 0; i < 128; i++) {         // create sawtooth wave
        Saw128[i] = (unsigned short) (65536 * ((float)(i-64) /128.0));
    }

    for (i = 0; i < 0x5540; i++) {      // size of glock sound..make 16-bit
        ThunEl16[i] = (ThunEl16Data[i]) << 8;
    }
    for (i = 0,j=0x5540; i < 0x5540; i++,j--) {     // size of glock sound..make 16-bit
        ReverseThunEl16[i] = ThunEl16[j];
    }

    

    for (i = 0; i < 3768; i++) {        // size of glock sound..make 16-bit
        Glock[i] = (GlockData[i]^0x80) << 8;
    }
        
    for (i = 0; i < 6719; i++) {        // size of glock sound..make 16-bit
        Bubble[i] = (BubbleData[i]^0x80) << 8;
    }


    if( FAILED( DirectSoundCreate( NULL, &m_pDSound, NULL ) ) )
        return (0);


    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );

    wfFirst.wFormatTag = WAVE_FORMAT_PCM;
    wfFirst.nChannels = 1;
    wfFirst.nSamplesPerSec = 48000;
    wfFirst.wBitsPerSample = 16;
    wfFirst.nBlockAlign = wfFirst.nChannels * wfFirst.wBitsPerSample/8;
    wfFirst.nAvgBytesPerSec = wfFirst.nSamplesPerSec * wfFirst.nBlockAlign;

    dsbdesc.dwFlags = 0;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = &wfFirst;
    dsbdesc.dwMixBinMask = dwMixBinMask;


    for (i = 0; i < MAX_BUFFERS; i++) {


        if (i%2) {
        lVolumes[0] = -600;
        lVolumes[1] = 0;
        lVolumes[2] = -2800;
        dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT;  
            dsbdesc.dwMixBinMask = dwMixBinMask;        
        }
        else {
        lVolumes[0] = 0;
        lVolumes[1] = -600;
        lVolumes[2] = -2800;
        dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT;  
            dsbdesc.dwMixBinMask = dwMixBinMask;    
        }
        if ((i == 3) || (i == 5)) {
        lVolumes[0] = 0;
        lVolumes[1] = -100;
        lVolumes[2] = 00;
        dwMixBinMask = DSMIXBIN_FRONT_LEFT | DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FXSEND_0;
            dsbdesc.dwMixBinMask = dwMixBinMask;
        }

            if( FAILED( DirectSoundCreateBuffer( &dsbdesc, &m_pDSBuffer[i]) ) )
                return E_FAIL;

            IDirectSoundBuffer_SetMixBinVolumes(m_pDSBuffer[i], dwMixBinMask, lVolumes);
    }

//  ReadDSPDatablock(0xa00*4, databack, sizeof(databack) );

     put_fifo(0x1);
     return(1);
}
//
// free dsound buffers and dsound object we created
//
dev_cleanup()
{
    int i;

    for (i = 0; i < MAX_BUFFERS; i++) {
        IDirectSoundBuffer_Release(m_pDSBuffer[i]);
    }
    IDirectSound_Release(m_pDSound);

}


do_watchdog()
{
}
dtimer_int()
{
}
etimer_int()
{
}
send_dev_function()
{
}
/*************************************************************************
*                                                                        *
*   Adjust the volume of that patch, "patch_addr" on channel,     *
*   "chan" by the amount volume + whatever the global volume is   *
*   for "level"                           *
*                                                                        *
*************************************************************************/

volume_dsp(
uchar op_level, 
uchar sound_level,
uchar *patch_addr,
uchar   chan)
{

    IDirectSoundBuffer_SetVolume(m_pDSBuffer[current_channel], (-1*op_level*30) + 200);
    return(1);
}

call_user_function()
{

}

extern  f_end();


user_silence_function()
{
#if DBG
//  swprintf( StringBuffer, L"Current Sound: %S", "SilenceFunction");
#endif
}

uchar pan_table[] = {
    1,2,3,4,5,6,7,8
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\EXTERNS.H ===
/*************************************************************************
*                                                                        *
* 	External Variables						  *
*                                                                        *
*************************************************************************/
#define _base_

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")


#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

extern		struct process	* _base_ process_queue;		/* pointer to process queue */
extern		struct sound	* _base_ current_call;		/* pointer to current sound call */
extern		struct sound	sound_calls[];
extern		struct sound	sound_calls2[];				/* alternate sound call table */
extern		struct process 	* _base_ current_process;	/* pointer to current s. proc */
extern		struct fifo	fifo;

extern		_base_ uchar hcount;			/* counter for oki nmi		*/
extern		_base_ uchar voice_state;		/* current nmi voice state	*/
extern		uchar * _base_ voice_data_pointer;	/* pointer to cur. voice data	*/
extern		uchar * _base_ voice_data_end;	/* pointer to end of v data	*/

extern		_base_ uchar 	a_value;		/* byte for register a data */
extern		_base_ uchar 	b_value;		/* byte for register b data */
extern		struct track_info * _base_ ti;/* global pointer to current track info*/
extern		_base_ ushort 	value_16_bit;		/* tmp value for passing */


extern _base_ short 		system_clock_music ;/* global music system timer     	*/
extern _base_ uchar		system_clock_mlow;  /* for 3 byte clocks		*/
extern _base_ short 		system_clock_fx; /* global fx system timer	    	*/
extern _base_ uchar		system_clock_fxlow; /* for 3-byte clocks	*/

extern		_base_ uchar 	clock_cntr[2];		/* timer count-downer	*/
extern		_base_ uchar 	clock_cntr_value[2];	/* timer count-downer	*/
extern		_base_ uchar	clock_cntr_save;	/* save val of clock cntr */
extern 	_base_ uchar 	master_music_volume;	/* main attenuation for music	*/
extern 	_base_ uchar 	master_effect_volume;	/* main attenuation for f/x	*/
extern		_base_ uchar	music_atten;		/* music attenuateion */
extern 	_base_ uchar 	master_music_amd;	/* main amp mod depth for music	*/
extern 	_base_ uchar 	master_effect_amd;	/* main amp mod depth for effect*/
extern 	_base_ uchar 	master_music_pmd;	/* main phase mod depth/music	*/
extern 	_base_ uchar 	master_effect_pmd;	/* main phase mod depth/effect	*/
extern		_base_ uchar 	marker;
extern		_base_ uchar	current_level;		/* global level of current process */
extern		_base_ uchar	current_channel;	/* global chan of current process */

extern	_base_	ushort		int_vars[12];		/* variables 2-byte */
extern	_base_ uchar		byte_vars[12];		/* variables 1-byte */

extern	_base_	uchar		dp_byte1;			/* temp var */
extern	_base_	uchar		dp_byte2;			/* temp var */
extern	_base_	uchar		dp_byte3;			/* temp var */
extern	_base_	uchar		dp_byte4;			/* temp var */
extern	_base_	uchar		dp_byte5;			/* temp var */
extern	_base_	ushort		dp_word1;			/* temp var */
extern	_base_	ushort		dp_word2;			/* temp var */
extern	_base_	ushort		dp_word3;			/* temp var */
extern	_base_	ushort		dp_word4;			/* temp var */
extern	_base_	ushort		dp_word5;			/* temp var */
extern	_base_ uchar		last_music_call;	/* last music call made		*/
extern _base_ uchar 	current_timer_priority;	/* priority of last timer call */
extern	uchar		music_timer_status[]; 
extern _base_ uchar	sos_only;
extern _base_ uchar		sound_call_table;	/* which soundtable are we on ?*/
extern	ushort		global_fxpose;		/* global transpose value */

extern	uchar		channel_level[];	/* current level for each chan*/
extern	struct track_info track_status[];
extern	struct process 	queue_list[]; 	/* pre-allocated process packets */


extern	const uchar	max_tracks;				/* from dev.c		*/
extern	void	do_watchdog(void);			/* from dev.c		*/
extern			dtimer_int();			/* from dev.c		*/
extern			etimer_int();			/* from dev.c		*/
extern			send_dev_function();	/* from dev.c		*/
extern	int	(*silence_functions[])();	/* from dev.c		*/
extern	int	(*note_on_functions[])();	/* from dev.c 		*/
extern	int	(*slur_functions[])();		/* from dev.c 		*/
extern	int	(*note_off_functions[])();	/* from dev.c		*/
extern	int	(*patch_functions[])();		/* from dev.c		*/
extern	int	(*volume_functions[])();   	/* from dev.c		*/
extern	int	(*pan_functions[])();		/* from dev.c		*/
extern	int	(*filter_functions[])();	/* from dev.c		*/
extern	int	dev_init();					/* from dev.c		*/
extern  int dev_cleanup();              /* from dev.c       */

extern	int	(*user_1_var_evf_functions[])();		/* from dev.c		*/
extern	int	(*user_2_var_evf_functions[])();		/* from dev.c		*/
extern	int   user_silence_function();				/* from dev.c		*/
extern int signal_function();			/* from dev.c */


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\GreenFog.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: GreenFog.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "xbs_math.h"
#include "xbs_app.h"
#include "qrand.h"
#include "GreenFog.h"
#include "tex_gen.h"
///////////////////////////////////////////////////////////////////////////////
#define PLASMA_SIZE		(256)
// 1024x512 appears to be only .1 fps slower than 512x256.
#define INTENSITY_TEX_X	(1024)
#define INTENSITY_TEX_Y (512)
//MTS#define INTENSITY_TEX_X	(512)
//MTS#define INTENSITY_TEX_Y (256)
const float MUL_SCALE = 0.005f;
const float MAIN_FOG_RAD = 40.0f;
///////////////////////////////////////////////////////////////////////////////
void GreenFog::Init()
{
	pQuadVB = NULL;
	pIntensityQuadVB = NULL;
	for (int i=0; i<NUM_PLASMAS; i++) pPlasmaTexture[i] = NULL;
	pIntensityTextureU = pIntensityTextureR = NULL;
	pIntensityZ = NULL;
	dwFogPShader = dwFogVShader = 0;
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::create()
{
	destroy();


	const float f_plasma_dim = ((float)PLASMA_SIZE);

	gpd3dDev->CreateTexture(INTENSITY_TEX_X, INTENSITY_TEX_Y, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, 0, &pIntensityTextureU);
	gpd3dDev->CreateTexture(INTENSITY_TEX_X, INTENSITY_TEX_Y, 1, D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, 0, &pIntensityTextureR);
	gpd3dDev->CreateDepthStencilSurface(INTENSITY_TEX_X,INTENSITY_TEX_Y,D3DFMT_LIN_D24S8, D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR , &pIntensityZ);



	gpd3dDev->CreateVertexBuffer(4*sizeof(GreenFogVertexBuffer), 0, 0, 0, &pQuadVB);

	GreenFogVertexBuffer* p_verts;
	pQuadVB->Lock(0, 0, (BYTE**) &p_verts, 0);

	Set(&p_verts[0].pos, -1.0f, -1.0f, 1.0f);
	Set(&p_verts[1].pos, -1.0f, +1.0f, 1.0f);
	Set(&p_verts[2].pos, +1.0f, +1.0f, 1.0f);
	Set(&p_verts[3].pos, +1.0f, -1.0f, 1.0f);

	p_verts[0].tu0 = 0.0f;	p_verts[0].tv0 = 1.0f;
	p_verts[1].tu0 = 0.0f;	p_verts[1].tv0 = 0.0f;
	p_verts[2].tu0 = 1.0f;	p_verts[2].tv0 = 0.0f;
	p_verts[3].tu0 = 1.0f;	p_verts[3].tv0 = 1.0f;

	for (int i=0; i<4; i++)
	{
		p_verts[i].tv1 = -(2.0f*p_verts[i].tu0 - 1.0f) * 640.0f/f_plasma_dim;
		p_verts[i].tu1 = -(2.0f*p_verts[i].tv0 - 1.0f) * 480.0f/f_plasma_dim;
//MTS		p_verts[i].tu1 = (2.0f*p_verts[i].tu0 - 1.0f) * 640.0f/f_plasma_dim;
//MTS		p_verts[i].tv1 = (2.0f*p_verts[i].tv0 - 1.0f) * 480.0f/f_plasma_dim;
	}

	pQuadVB->Unlock();



	// These are used to render the backdrop.
	gpd3dDev->CreateVertexBuffer(4*sizeof(BaseStream), 0, 0, 0, &pIntensityQuadVB);
	BaseStream* p_bs_verts;
	pIntensityQuadVB->Lock(0, 0, (BYTE**) &p_bs_verts, 0);

	Set(&p_bs_verts[0].p, -1.0f, -1.0f, 1.0f);
	Set(&p_bs_verts[1].p, -1.0f, +1.0f, 1.0f);
	Set(&p_bs_verts[2].p, +1.0f, +1.0f, 1.0f);
	Set(&p_bs_verts[3].p, +1.0f, -1.0f, 1.0f);

	pIntensityQuadVB->Unlock();



    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),	// position
        D3DVSD_REG( 1, D3DVSDT_FLOAT2 ),	// intensity texture
        D3DVSD_REG( 2, D3DVSDT_FLOAT2 ),	// plasma 0
        D3DVSD_END()
    };

#ifndef BINARY_RESOURCE
	dwFogPShader = gApp.loadPixelShader( "d:\\shaders\\greenfog.xpu" );
	dwFogVShader = gApp.loadVertexShader( "d:\\shaders\\greenfog.xvu", dwShaderVertexDecl );
#else // BINARY_RESOURCE
	dwFogPShader = gApp.loadPixelShader( g_greenfog_xpu );
	dwFogVShader = gApp.loadVertexShader( g_greenfog_xvu, dwShaderVertexDecl );
#endif // BINARY_RESOURCE

	restart();	// renders the texture
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void GreenFog::destroy()
{
#define XBS_RESOURCE_RELEASE(a) if (a) a->Release(); a = NULL;
	XBS_RESOURCE_RELEASE(pQuadVB);
	XBS_RESOURCE_RELEASE(pIntensityQuadVB);
	for (int i=0; i<NUM_PLASMAS; i++) { XBS_RESOURCE_RELEASE(pPlasmaTexture[i]); }
	XBS_RESOURCE_RELEASE(pIntensityTextureU);
	XBS_RESOURCE_RELEASE(pIntensityTextureR);
	XBS_RESOURCE_RELEASE(pIntensityZ);
#undef XBS_RESOURCE_RELEASE
	if (dwFogPShader) gpd3dDev->DeletePixelShader( dwFogPShader );
	if (dwFogVShader) gpd3dDev->DeleteVertexShader( dwFogVShader );
	dwFogPShader = dwFogVShader = 0;
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::advanceTime(float fElapsedTime, float fDt)
{
	renderIntensityTexture();
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::render(bool b_cmp_to_one)
{
	int i;

	gpd3dDev->SetVertexShader( dwFogVShader );
	gpd3dDev->SetPixelShader ( dwFogPShader );

	// Swap render and update textures.
	LPDIRECT3DTEXTURE8 p_swap = pIntensityTextureR;
	pIntensityTextureR = pIntensityTextureU;
	pIntensityTextureU = p_swap;

	// Use what was the update(d) texture.
	gpd3dDev->SetTexture(0, pIntensityTextureR);



    gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

	for (i=0; i<NUM_PLASMAS; i++)
	{
		gpd3dDev->SetTexture(i+1, pPlasmaTexture[i]);
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_MIPFILTER, D3DTEXF_NONE );
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
		gpd3dDev->SetTextureStageState( i+1, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	}
	
    gpd3dDev->SetRenderState( D3DRS_ALPHATESTENABLE,	TRUE );
//MTS    gpd3dDev->SetRenderState( D3DRS_ZFUNC,				D3DCMP_GREATEREQUAL );
    gpd3dDev->SetRenderState( D3DRS_ZFUNC,				(b_cmp_to_one) ? D3DCMP_EQUAL : D3DCMP_ALWAYS );

    gpd3dDev->SetRenderState( D3DRS_ALPHAREF,			0x00000001 );
    gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ONE );
//MTS    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ONE );		// Just render intensity
//MTS    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ZERO );	// Just render intensity
    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		FALSE );


	D3DVECTOR4 val[2*NUM_PLASMAS];
	float f_intensity = max(0.0f, gApp.getBlobIntensity() * 0.7f - 0.1f);
	Set(&val[0], 0.0f*f_intensity, f_intensity, 0.0f*f_intensity, 1.0f);

	
	float f_glow = 0.75f * max(0.0f, min(1.0f, (gApp.getElapsedTime() - GLOW_FADE_SCREEN_START) * GLOW_FADE_SCREEN_MUL));
//MTS	Set(&val[1], f_glow*0.625f, f_glow*1.0f, f_glow*0.0625f, 0.0f);
	Set(&val[1], f_glow*0.625f, f_glow, f_glow * 0.4f, 0.0f);

	
	gpd3dDev->SetPixelShaderConstant(0, &val[0], 2);




	D3DVECTOR4 origin, origin_scr;
	Set(&origin, 0.0f, 0.0f, 0.0f, 1.0f);
	TransformPoint(origin, gApp.theCamera.getWTP(), &origin_scr);
	Scale(&origin_scr, 1.0f / origin_scr.w);


	const float f_plasma_dim = ((float)PLASMA_SIZE);

	// Set the transforms for the plasma texture coordinates.
	for (i=0; i<NUM_PLASMAS; i++)
	{
		float rad = 0.6f * (((float)(NUM_PLASMAS-i-1)) / ((float)NUM_PLASMAS) - 0.2f);
		float x_mul = 0.5f * gApp.getCameraRadiusFromBlob() * MUL_SCALE;
		float y_mul = 1.0f * gApp.theCamera.getAspectRatio() * gApp.getCameraRadiusFromBlob() * MUL_SCALE;

		float x_add =  rad * gApp.getCameraTheta() - origin_scr.x * x_mul * 640.0f/f_plasma_dim;
		float y_add = -rad * gApp.getCameraPhi()   + origin_scr.y * y_mul * 480.0f/f_plasma_dim;
		// I don't know why y_mul is 1.0f* and x_mul is 0.5f*, but it looks less stretched in y this way.


		Set(&val[2*i+0], y_add, x_add, 0.0f, 0.0f);
		Set(&val[2*i+1], -y_mul, -x_mul, 1.0f, 1.0f);
//MTS		Set(&val[2*i+0], x_add, y_add, 0.0f, 0.0f);
//MTS		Set(&val[2*i+1], x_mul, y_mul, 1.0f, 1.0f);
	}

	gpd3dDev->SetVertexShaderConstant(0, &val[0], 2*NUM_PLASMAS);


	gpd3dDev->SetStreamSource(0, pQuadVB, sizeof(GreenFogVertexBuffer));
	gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);

	gpd3dDev->SetPixelShader (NULL);
	gpd3dDev->SetVertexShader(NULL);

	for (i=0; i<1+NUM_PLASMAS; i++) gpd3dDev->SetTexture(i, NULL);


	// Render fade to yellow.

	f_glow = max(0.0f, min(1.0f, (gApp.getElapsedTime() - GLOW_FADE_CIRCLE_START) * GLOW_FADE_CIRCLE_MUL));

	if (gApp.getElapsedTime() < BLOB_STATIC_END_TIME)
	{
		float t = gApp.getElapsedTime();
		f_glow = (t < BLOB_STATIC_END_TIME * 0.2f) ? (t / (BLOB_STATIC_END_TIME*0.2f)) : (1.0f - (t-BLOB_STATIC_END_TIME * 0.2f)/BLOB_STATIC_END_TIME);
	}

	int alpha = max(0, min( 255, (int) ((255.0f * f_glow))));
//MTS	alpha >>= 1;
	alpha = min(196, alpha*2);


	if (alpha)
	{
//MTS		DWORD glow_factor = 0x00a0ff10 | (alpha << 24);
		DWORD glow_factor = 0x00A0FF60 | (alpha << 24);


		gpd3dDev->SetRenderState(D3DRS_TEXTUREFACTOR, glow_factor);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG2,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_MODULATE);
		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG2,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,D3DTOP_MODULATE);


		// Correct center.
		float x_mul = gApp.getCameraRadiusFromBlob() * MUL_SCALE;
		float y_mul = gApp.getCameraRadiusFromBlob() * MUL_SCALE * gApp.theCamera.getAspectRatio();

		D3DVECTOR4 origin, origin_screen;
		Set(&origin, 0.0f, 0.0f, 0.0f, 1.0f);
		TransformPoint(origin, gApp.theCamera.getWTP(), &origin_screen);
		Scale(&origin_screen, 1.0f / origin_screen.w);
		//origin_screen.x = 0.5f - x_mul * origin_screen.x;
		//origin_screen.y = 0.5f - y_mul * origin_screen.y;


		D3DMATRIX mat_tex;
		float mul = 0.33f / f_glow;

		if (gApp.getElapsedTime() < BLOB_STATIC_END_TIME)
		{
			mul = gApp.getCameraRadiusFromBlob() * BLOB_STATIC_END_TIME / (gApp.getElapsedTime() * 8.0f);
		}

		SetScale(mul, mul, 1.0f, &mat_tex);
		mat_tex._31 = 0.5f*(1.0f-mul) - 0.5f * origin_screen.x * mul * 1.33f;
		mat_tex._32 = 0.5f*(1.0f-mul) + 0.5f * origin_screen.y * mul;




		
		D3DMATRIX iden,scaled;
		SetIdentity(&iden);
		SetScale(1.0f / mul, 1.0f / mul, 0.0f, &scaled);
		scaled._43 = 1.0f;
		gpd3dDev->SetTransform(D3DTS_WORLD, &scaled);
		gpd3dDev->SetTransform(D3DTS_VIEW, &iden);
		gpd3dDev->SetTransform(D3DTS_PROJECTION, &iden);


		gpd3dDev->SetTexture(0,gApp.pGlowMap);

		gpd3dDev->SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX2);

		
		gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	}
    
	gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_INVSRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_ZFUNC,				D3DCMP_LESSEQUAL );
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::restart()
{
	int tffonp = 255 / NUM_PLASMAS;
	for (int i=0; i<NUM_PLASMAS; i++)
	{
		if (pPlasmaTexture[i]) pPlasmaTexture[i]->Release();
	}
	CreateIntensityTexture_8Bit(pPlasmaTexture, NUM_PLASMAS, PLASMA_SIZE, 5 * tffonp, gApp.rand(),
					((tffonp*3)/4) << 8, 255/max(1,NUM_PLASMAS-0));
}
///////////////////////////////////////////////////////////////////////////////
void GreenFog::renderIntensityTexture()
{
	// Get camera position and render geometry into background.

	// Store old render targets.
	LPDIRECT3DSURFACE8 pOldRT,pOldZ;
	gpd3dDev->GetRenderTarget(&pOldRT);
	gpd3dDev->GetDepthStencilSurface(&pOldZ);


	// Leave the camera position where it is.
	LPDIRECT3DSURFACE8 p_update_surf;
	pIntensityTextureU->GetSurfaceLevel(0, &p_update_surf);
	gpd3dDev->SetRenderTarget(p_update_surf, pIntensityZ);

	if( gpd3dDev->BeginScene() == D3D_OK )
	{
		gpd3dDev->Clear(0,NULL,
						D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET,
						0xffff0000,
						1.f,
						0 );

		// Render a backdrop.

		gpd3dDev->SetRenderState( D3DRS_ALPHATESTENABLE,	TRUE );
		gpd3dDev->SetRenderState( D3DRS_ALPHAFUNC,			D3DCMP_GREATEREQUAL );
		gpd3dDev->SetRenderState( D3DRS_ALPHAREF,			0x00000001 );
		gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
		gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ONE );
		gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ZERO );

		gpd3dDev->SetVertexShader(gApp.dwVShader[st_Depth]);
		gpd3dDev->SetPixelShader (gApp.dwPShader[st_Depth]);


		//#define Z_ADD			c16
		//#define Z_MUL			c17
		//#define POS_MUL		c18
		//#define POS_SHIFT		c19


		D3DVECTOR4 val[4];
		float max_color_dist = 2.0f * MAIN_FOG_RAD;
		float z_mul = 1.0f;	// set later on for the geometry case, this is just the backdrop
		float z_add = 0.0f;

		Set(&val[0], z_mul, z_mul, z_mul, 1.0f );
		Set(&val[1], z_add, z_add, z_add, 1.0f );

		float x_mul = gApp.getCameraRadiusFromBlob() * MUL_SCALE;
		float y_mul = gApp.getCameraRadiusFromBlob() * MUL_SCALE * gApp.theCamera.getAspectRatio();

		Set(&val[2], x_mul, y_mul, 0.0f, 1.0f);


		D3DVECTOR4 origin;
		Set(&origin, 0.0f, 0.0f, 0.0f, 1.0f);
		TransformPoint(origin, gApp.theCamera.getWTP(), &val[3]);
		Scale(&val[3], 1.0f / val[3].w);
		val[3].x = 0.5f - val[2].x * val[3].x;
		val[3].y = 0.5f - val[2].y * val[3].y;
		val[3].z = 0.5f;
		val[3].w = 0.0f;
		// If looking at origin, then Set(&val[3], 0.5f, 0.5f, 0.5f, 0.0f);
//MTS		Set(&val[3], 0.5f, 0.5f, 0.5f, 0.0f);
		gpd3dDev->SetVertexShaderConstant(16, &val[0], 4);


		D3DMATRIX iden;
		SetIdentity(&iden);
		iden._43 = 1.0f;
		iden._44 = 0.0f;
		gpd3dDev->SetVertexShaderConstant(0, &iden, 4);


		gpd3dDev->SetStreamSource(0, pIntensityQuadVB, sizeof(BaseStream));
		gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);


		gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE);
		gpd3dDev->SetRenderState( D3DRS_ZENABLE,			TRUE);

		z_add = MAIN_FOG_RAD - gApp.getCameraRadiusFromBlob();
		z_mul = 1.0f / max_color_dist;
		Set(&val[0], z_mul, z_mul, z_mul, 1.0f );
		Set(&val[1], z_add, z_add, z_add, 1.0f );
		gpd3dDev->SetVertexShaderConstant(16, &val, 2);

		gApp.sceneGeom.renderZ();

		// Without NULLing the pixel shader, the shields aren't transparent. Dunno why.
		gpd3dDev->SetPixelShader (NULL);
		gpd3dDev->SetVertexShader(NULL);


		// Clear stencil and depth buffer, but not the "target", or ARGB values.
		gpd3dDev->Clear(0,NULL,
						D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER,
						0xffffffff,
						1.f,
						0 );



		gpd3dDev->EndScene();
	}
	else
	{
		int a = 0;
	}

	gpd3dDev->SetRenderTarget(pOldRT,pOldZ);
	p_update_surf->Release();
	pOldRT->Release();
	pOldZ->Release();
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\fastmath.cpp ===
/*--
Copyright (c) 2000  Microsoft Corporation - Xbox SDK

Module Name:

    fastmath.cpp
--*/

#include "precomp.h"
//#include "Debug.h"

//----------------------------------------------------------------------------
// Katmai and MMX(TM) constants implementation
#define _MM_ALIGN16 __declspec(align(16))

#define SC_OPT

#if !defined(M128)
#define M128(x) (*(__m128*)&(x))
#endif

typedef unsigned long DWORD;

#define _M128_CONST(Name, Val) \
static const _MM_ALIGN16 float _m128const_##Name[4] = { Val, Val, Val, Val }

#define _M128_CONST4(Name, Val0, Val1, Val2, Val3) \
static const _MM_ALIGN16 float _m128const_##Name[4] = { Val0, Val1, Val2, Val3 }

#define M128_EXTERN_CONST(Name, Val) \
static const _MM_ALIGN16 float _m128const_##Name[4] = { Val, Val, Val, Val }; \
const __m128* p##Name = (__m128*)_m128const_##Name

#define M128_EXTERN_CONST_TYPE(Name, Val, Type) \
static const _MM_ALIGN16 Type _m128const_##Name[4] = { Val, Val, Val, Val }; \
const __m128* p##Name = (__m128*)_m128const_##Name

#define M128_CONST(Name, Val) \
static const _MM_ALIGN16 float _m128const_##Name[4] = { Val, Val, Val, Val }; \
const __m128 Name = M128(_m128const_##Name)

M128_EXTERN_CONST(am_0, 0.0f);
M128_EXTERN_CONST(am_1, 1.0f);
M128_EXTERN_CONST(am_minus_1, -1.0f);
M128_EXTERN_CONST(am_0p5, 0.5f);
M128_EXTERN_CONST(am_1p5, 1.5f);
M128_EXTERN_CONST(am_3_over_2, 3.0f / 2.0f);
M128_EXTERN_CONST(am_pi, PI);
M128_EXTERN_CONST(am_pi_over_2, (PI / 2.0f));
M128_EXTERN_CONST(am_2_over_pi, (2.0f / PI));
M128_EXTERN_CONST_TYPE(am_sign_mask, 0x80000000, DWORD);
M128_EXTERN_CONST_TYPE(am_inv_sign_mask, ~0x80000000, DWORD);
M128_EXTERN_CONST_TYPE(am_min_pos_norm, 0x00800000, DWORD);
M128_EXTERN_CONST_TYPE(am_mant_mask, 0x7f800000, DWORD);
M128_EXTERN_CONST_TYPE(am_inv_mant_mask, ~0x7f800000, DWORD);


//----------------------------------------------------------------------------
// Katmai and MMX(TM) constants implementation
static const float p0 = 0.15707963267948963959e1f;
static const float p1 = -0.64596409750621907082e0f;
static const float p2 = 0.7969262624561800806e-1f;
static const float p3 = -0.468175413106023168e-2f;

static const float t0 = -0.91646118527267623468e-1f;
static const float t1 = -0.13956945682312098640e1f;
static const float t2 = -0.94393926122725531747e2f;
static const float t3 =  0.12888383034157279340e2f;
static const float s0 =  0.12797564625607904396e1f;
static const float s1 =  0.21972168858277355914e1f;
static const float s2 =  0.68193064729268275701e1f;
static const float s3 =  0.28205206687035841409e2f;

static const float p0exp = 1.26177193074810590878e-4f;
static const float p1exp = 3.02994407707441961300e-2f;

static const float q0 = 3.00198505138664455042e-6f;
static const float q1 = 2.52448340349684104192e-3f;
static const float q2 = 2.27265548208155028766e-1f;
static const float q3 = 2.00000000000000000009e0f;

static const float rln2 = 1.4426950408889634073599f;
static const float c1 = 6.93145751953125e-1f;
static const float c2 = 1.42860682030941723212e-6f;

	const float at3613 = 2.7692309f;
	const float at2511 = 2.2727273f;
	const float at36 = 36.0f;
	const float at25 = 25.0f;
	const float at16 = 16.0f;
	const float at11 = 11.0f;
	const float at9 = 9.0f;
	const float at7 = 7.0f;
	const float at5 = 5.0f;
	const float at4 = 4.0f;
	const float at3 = 3.0f;
	const float at1 = 1.0f;
	const float at_p2 = PI_DIV_2;
	const float mp2 = -PI_DIV_2;

	const float as2 = FLOAT_SMALL;

	const float SQ2 = 1.4142136f;
	const float SQ3 = 0.3333333f;
	const float SQ5 = 1.4000000f;
	const float SQ7 = 0.1428571f;
	const float LOG2 = 0.3465736f;

    static const float log_p0 = -7.89580278884799154124e-1f;
    static const float log_p1 = 1.63866645699558079767e1f;
    static const float log_p2 = -6.41409952958715622951e1f;

    static const float log_q0 = -3.56722798256324312549e1f;
    static const float log_q1 = 3.12093766372244180303e2f;
    static const float log_q2 = -7.69691943550460008604e2f;

    static const float log_rsqrt2 = 7.07106781186547524401e-1f;
    static const float log_c0 = 0.693147180559945f;

    static const float fmax = 88.0f;
    static const float fmin = -88.0f;

    static const float pow_p0 = -7.89580278884799154124e-1f;
    static const float pow_p1 = 1.63866645699558079767e1f;
    static const float pow_p2 = -6.41409952958715622951e1f;

    static const float pow_q0 = -3.56722798256324312549e1f;
    static const float pow_q1 = 3.12093766372244180303e2f;
    static const float pow_q2 = -7.69691943550460008604e2f;

    static const float pow_rsqrt2 = 7.07106781186547524401e-1f;
    static const float pow_c0 = 1.44269504088896340735992f;

    static const float pow_r0 = 2.30933477057345225087e-2f;
    static const float pow_r1 = 2.02020656693165307700e1f;
    static const float pow_r2 = 1.51390680115615096133e3f;

    static const float pow_s0 = 2.33184211722314911771e2f;
    static const float pow_s1 = 4.36821166879210612817e3f;

    static const float pow_fmax = 128.0f;
    static const float pow_fmin = -127.0f;

	const float th1 = 1.0f;
	const float th2p = 2.0f;
	const float th2m = -2.0f;
	const float th3 = 0.3333333f;


	const float sh1 = 1.0f;
	const float sh5 = 0.5f;
	const float sh6 = 0.1666667f;

	const float t_as[49] = {
		0.9698000f,
		0.9691796f, 0.9685330f, 0.9678589f, 0.9671551f, 0.9664199f, 0.9656509f, 0.9648460f, 0.9640023f,
		0.9631173f, 0.9621876f, 0.9612098f, 0.9601802f, 0.9590943f, 0.9579477f, 0.9567349f, 0.9554501f,
		0.9540865f, 0.9526370f, 0.9510929f, 0.9494448f, 0.9476817f, 0.9457912f, 0.9437591f, 0.9415686f,
		0.9392007f, 0.9366328f, 0.9338384f, 0.9307863f, 0.9274390f, 0.9237517f, 0.9196697f, 0.9151261f,
		0.9100379f, 0.9043011f, 0.8977833f, 0.8903134f, 0.8816667f, 0.8715416f, 0.8595238f, 0.8450292f,
		0.8272059f, 0.8047620f, 0.7756411f, 0.7363636f, 0.6805556f, 0.5952381f, 0.4500000f, 0.1666667f
	};

//----------------------------------------------------------------------------
// atan
float fast_atan
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 154 cycles
    return atanf(x);

#else
#if defined(SC_OPT)
	_asm {
		mov		eax, x
		movss	xmm0, x
		cmp		eax, 0bf800000h
		jnc		minus1
		cmp		eax, 3f800000h
		jnc		plus1
		movss	xmm1, xmm0
		mulss	xmm1, xmm1
		movss	xmm2, xmm1
		movss	xmm3, xmm1
		movss	xmm4, xmm1
		movss	xmm5, xmm1
		mulss	xmm2, at2511
		mulss	xmm3, at16
		mulss	xmm4, at9
		mulss	xmm5, at4
		addss	xmm2, at9
		rcpss	xmm6, xmm2
		mulss	xmm6, xmm3
		addss	xmm6, at7
		rcpss	xmm2, xmm6
		mulss	xmm2, xmm4
		addss	xmm2, at5
		rcpss	xmm6, xmm2
		mulss	xmm6, xmm5
		addss	xmm6, at3
		rcpss	xmm2, xmm6
		mulss	xmm1, xmm2
		addss	xmm1, at1
		rcpss	xmm2, xmm1
		movss	xmm7, xmm2
		addss	xmm2, xmm2
		mulss	xmm7, xmm7
		mulss	xmm7, xmm1
		subss	xmm2, xmm7

		mulss	xmm0, xmm2
		movss	x, xmm0
	}
	return x;
	_asm {
		ALIGN 16
minus1:
		rcpss	xmm0, xmm0
		movss	xmm1, xmm0
		mulss	xmm1, xmm1
		movss	xmm2, xmm1
		movss	xmm3, xmm1
		movss	xmm4, xmm1
		movss	xmm5, xmm1
		movss	xmm6, xmm1
		mulss	xmm2, at3613
		mulss	xmm3, at25
		mulss	xmm4, at16
		mulss	xmm5, at9
		mulss	xmm6, at4
		addss	xmm2, at11
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm3
		addss	xmm2, at9
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm4
		addss	xmm2, at7
		rcpss	xmm2, xmm2
		movss	xmm3, mp2
		mulss	xmm2, xmm5
		addss	xmm2, at5
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm6
		addss	xmm2, at3
		rcpss	xmm2, xmm2
		mulss	xmm1, xmm2
		addss	xmm1, at1
		rcpss	xmm2, xmm1
		movss	xmm7, xmm2
		addss	xmm2, xmm2
		mulss	xmm7, xmm7
		mulss	xmm7, xmm1
		subss	xmm2, xmm7
		mulss	xmm0, xmm2
		subss	xmm3, xmm0
		movss	x, xmm3
	}
	return x;
	_asm {
		ALIGN 16
plus1:
		rcpss	xmm0, xmm0
		movss	xmm1, xmm0
		mulss	xmm1, xmm1
		movss	xmm2, xmm1
		movss	xmm3, xmm1
		movss	xmm4, xmm1
		movss	xmm5, xmm1
		movss	xmm6, xmm1
		mulss	xmm2, at3613
		mulss	xmm3, at25
		mulss	xmm4, at16
		mulss	xmm5, at9
		mulss	xmm6, at4
		addss	xmm2, at11
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm3
		addss	xmm2, at9
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm4
		addss	xmm2, at7
		rcpss	xmm2, xmm2
		movss	xmm3, at_p2
		mulss	xmm2, xmm5
		addss	xmm2, at5
		rcpss	xmm2, xmm2
		mulss	xmm2, xmm6
		addss	xmm2, at3
		rcpss	xmm2, xmm2
		mulss	xmm1, xmm2
		addss	xmm1, at1
		rcpss	xmm2, xmm1
		movss	xmm7, xmm2
		addss	xmm2, xmm2
		mulss	xmm7, xmm7
		mulss	xmm7, xmm1
		subss	xmm2, xmm7
		mulss	xmm0, xmm2
		subss	xmm3, xmm0
		movss	x, xmm3
	}
    return x;
#else	// SC_OPT
    // 60 cycles
    __asm
    {
        movss   xmm0, x

        movss   xmm1, xmm0
        rcpss   xmm4, xmm0
        orps    xmm1, _m128const_am_sign_mask
        movss   xmm6, xmm4
        comiss  xmm1, _m128const_am_minus_1
        jc      l_big  // 'c' is 'lt' for comiss

        movss   xmm3, t0
        movss   xmm2, xmm0
        mulss   xmm2, xmm2

        movss   xmm1, s0
        addss   xmm1, xmm2

        movss   xmm7, s1
        rcpss   xmm1, xmm1
        mulss   xmm1, xmm3
        movss   xmm3, t1
        addss   xmm7, xmm2
        addss   xmm1, xmm7

        movss   xmm7, s2
        rcpss   xmm1, xmm1
        mulss   xmm1, xmm3
        movss   xmm3, t2
        addss   xmm7, xmm2
        addss   xmm1, xmm7

        movss   xmm7, s3
        rcpss   xmm1, xmm1
        mulss   xmm1, xmm3
        movss   xmm3, t3
        addss   xmm7, xmm2
        mulss   xmm0, xmm3
        addss   xmm1, xmm7

        rcpss   xmm1, xmm1
        mulss   xmm0, xmm1

        jmp l_done

l_big:
        movss   xmm3, t0
        mulss   xmm6, xmm6

        movss   xmm5, s0
        addss   xmm5, xmm6

        movss   xmm7, s1
        rcpss   xmm5, xmm5
        mulss   xmm5, xmm3
        movss   xmm3, t1
        addss   xmm7, xmm6
        addss   xmm5, xmm7

        movss   xmm7, s2
        rcpss   xmm5, xmm5
        mulss   xmm5, xmm3
        movss   xmm3, t2
        addss   xmm7, xmm6
        addss   xmm5, xmm7

        movss   xmm7, s3
        rcpss   xmm5, xmm5
        mulss   xmm5, xmm3
        movss   xmm3, t3
        addss   xmm7, xmm6
        mulss   xmm4, xmm3
        addss   xmm5, xmm7

        movss   xmm2, _m128const_am_sign_mask
        rcpss   xmm5, xmm5
        mulss   xmm5, xmm4

        movss   xmm7, _m128const_am_pi_over_2
        andps   xmm0, xmm2
        orps    xmm0, xmm7
        subss   xmm0, xmm5

l_done:
        movss   x, xmm0
    }
    return x;
#endif	// !SC_OPT

#endif // !USE_C
}


//----------------------------------------------------------------------------
// atan2
float fast_atan2
(
    float x,
    float y
)
//--------------------------------------
{
#if defined(USE_C)

    // 154 cycles
    return atan2f(x, y);

#else
#if defined(SC_OPT)
	_asm {
		movss	xmm0, x
		rcpss	xmm1, y
		movss	xmm2, xmm1
		addss	xmm1, xmm1
		mulss	xmm2, xmm2
		mulss	xmm2, y
		subss	xmm1, xmm2
		mulss	xmm0, xmm1
		movss	x, xmm0
	}
	return fast_atan( x );
#else	// SC_OPT

    // 77 cycles
    fast_atan(x * y);

    __asm
    {
        // We assume fast_atan leaves the return value in xmm0

        xorps   xmm7, xmm7
        movss   xmm1, y //[esp - 20 - 8]
        comiss  xmm1, xmm7
        movss   xmm4, x //[esp - 20 - 4]
        jnc     l_pos   // 'nc' is 'ge' for comiss

        andps   xmm4, _m128const_am_sign_mask
        orps    xmm4, _m128const_am_pi

        addss   xmm0, xmm4

l_pos:
        movss   x, xmm0
    }

    return x;

#endif	// !SC_OPT
#endif // !USE_C
}

//----------------------------------------------------------------------------
// acos
float fast_acos
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)
    // 273 cycles
    return acosf(x);
#else
	_asm {
		mov		eax, x;
		test	eax, 080000000h
		jnz		acminus
		or		eax, eax		; == 0.0
		jz		acretz
		cmp		eax, 3f800000h	; >= 1.0
		jnc		acretp
		jmp		acculc
acminus:
		and		eax, 7fffffffh	;Just in case.  it may be not need.
		jz		acretz			; == -0.0
		cmp		eax, 0bf800000h	; <= -1.0
		jnc		acretm
acculc:
	}
	return PI_DIV_2 - fast_asin( x );
acretz:
	return PI_DIV_2;
acretp:
	return 0.0f;
acretm:
	return PI;
#endif
}


//----------------------------------------------------------------------------
// asin
float fast_asin
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)
    // 279 cycles
    return asinf(x);
#else
	const unsigned long as1 = FP_ONE_BITS;
	const unsigned long* pt_as = (unsigned long*) &t_as[0];

	_asm {
		mov		eax, x;
		test	eax, 080000000h
		jnz		asminus
		or		eax, eax		; == 0.0
		jz		asretz
		cmp		eax, 3f800000h	; >= 1.0
		jnc		asretp
		cmp		eax, 3f3504f3h	; >= SQRT2 / 2
		jnc		asrett
		jmp		asculc
asminus:
		and		eax, 7fffffffh	;Just in case.  it may be not need.
		jz		asretz			; == -0.0
		cmp		eax, 0bf800000h	; <= -1.0
		jnc		asretm
		cmp		eax, 0bf3504f3h	; <= -SQRT2 / 2
		jnc		asrett
asculc:
		movss	xmm0, as1		;xmm0 = factor
		movss	xmm1, xmm0		;xmm1 = sum
		movss	xmm2, xmm0		;xmm2 = power
		movss	xmm3, x			;xmm3 = x
		movss	xmm4, xmm3
		mulss	xmm4, xmm4		;xmm4 = y
		movss	xmm5, as2		;xmm5 = FLOAT_SMALL
		mov		edx, pt_as
		mov		ecx, 48
asloop:
		movss	xmm6, dword ptr[edx + ecx * 4]
		mulss	xmm0, xmm6
		mulss	xmm2, xmm4
		movss	xmm6, xmm0
		mulss	xmm6, xmm2
		addss	xmm1, xmm6
		comiss	xmm6, xmm5
		dec		ecx
		ja		asloop
		mulss	xmm1, xmm3
		movss	x, xmm1
	}
	return x;
asretz:
	return 0.0f;
asretp:
	return PI_DIV_2;
asretm:
	return -PI_DIV_2;
asrett:
	_asm {
		movss	xmm1, x
		mulss	xmm1, xmm1
		movss	xmm0, as1
		subss	xmm0, xmm1
		rsqrtss	xmm1, xmm0
		movss	xmm2, xmm0
		mulss	xmm0, xmm1
		mulss	xmm0, xmm1
		mulss	xmm0, xmm1
		mulss	xmm0, _m128const_am_0p5
		mulss	xmm1, _m128const_am_3_over_2
		subss	xmm1, xmm0
		mulss	xmm1, x
		movss	x, xmm1
	}
	// quality of fast_atan is too bad.
	return fast_atan( x );
#endif
}


//----------------------------------------------------------------------------
// log
float fast_log
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 106 cycles
    return logf(x);

#else
#if defined(SC_OPT)

    // 58 cycles
	_asm {
		mov			eax, x
		mov			edx, eax
		and			eax, 7fffffh
		movss		xmm2, SQ2
		and			edx, 7f800000h
		or			eax, 3f800000h
		shr			edx, 22
		mov			x, eax
		movss		xmm1, x
		movss		xmm0, xmm1
		movss		xmm3, SQ5
		addss		xmm1, xmm2
		subss		xmm0, xmm2
		sub			edx, 253

		rcpss		xmm2, xmm1
		movss		xmm3, xmm2			;Newton-Raphson
		addss		xmm3, xmm3
		mulss		xmm2, xmm2
		mulss		xmm2, xmm1
		subss		xmm3, xmm2			;complete Newton-Raphson
		mulss		xmm0, xmm3

		movss		xmm2, SQ7
		movss		xmm1, xmm0
		mulss		xmm0, xmm0
		mulss		xmm2, xmm0
		addss		xmm3, xmm0
		mulss		xmm2, xmm3
		addss		xmm2, SQ3
		mulss		xmm0, xmm1
		mulss		xmm0, xmm2
		cvtsi2ss	xmm3, edx
		addss		xmm0, xmm1
		mulss		xmm3, LOG2
		addss		xmm0, xmm0
		addss		xmm0, xmm3
		movss		x, xmm0
	}
#else	// !SC_OPT

    // 66 cycles
    __asm
    {
        movss   xmm0, x

        maxss   xmm0, _m128const_am_min_pos_norm  // Cut off denormalized stuff
        movss   xmm7, _m128const_am_inv_mant_mask
        movss   xmm1, _m128const_am_1
        movss   [esp - 4], xmm0

        andps   xmm0, xmm7
        orps    xmm0, xmm1  // xmm1 == 1.0
        comiss  xmm0, log_rsqrt2
        movss   xmm7, xmm0

        jc      l_lt  // 'c' is 'lt' for comiss
//l_ge:
        xor     ecx, ecx
        movss   xmm2, xmm1  // xmm1 == 1.0
        jmp     l_continue

l_lt:
        mov     ecx, 1
        movss   xmm2, _m128const_am_0p5

l_continue:
        addss   xmm7, xmm2
        subss   xmm0, xmm2
        mov     edx, x
        rcpss   xmm7, xmm7
        mulss   xmm0, xmm7
        addss   xmm0, xmm0

        shr     edx, 23

        movss   xmm2, xmm0
        sub     edx, 0x7f
        mulss   xmm2, xmm2

        movss   xmm4, log_p0
        movss   xmm6, log_q0

        mulss   xmm4, xmm2
        movss   xmm5, log_p1
        sub     edx, ecx
        mulss   xmm6, xmm2
        movss   xmm7, log_q1

        addss   xmm4, xmm5
        addss   xmm6, xmm7

        movss   xmm5, log_p2
        mulss   xmm4, xmm2
        cvtsi2ss    xmm1, edx
        movss   xmm7, log_q2
        mulss   xmm6, xmm2

        addss   xmm4, xmm5
        addss   xmm6, xmm7

        movss   xmm5, log_c0
        mulss   xmm4, xmm2
        rcpss   xmm6, xmm6

        mulss   xmm4, xmm0
        mulss   xmm1, xmm5
        mulss   xmm4, xmm6

        addss   xmm0, xmm1
        addss   xmm0, xmm4

        movss   x, xmm0
    }
#endif	// SC_OPT
    return x;
#endif // !USE_C
}


//----------------------------------------------------------------------------
// log10
float fast_log10
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 106 cycles
    return log10f(x);

#else
    // 74 cycles
	// fixed coefficient 7/3/2000 Shinji Chiba
	return fast_log( x ) * 0.4342945f;

#endif // !USE_C
}


//----------------------------------------------------------------------------
// exp
float fast_exp
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 151 cycles
    return expf(x);

#else

    // 90 cycles
    __asm
    {
        movss   xmm0, x

        maxss   xmm0, fmin
        minss   xmm0, fmax

        movss   xmm1, rln2
        mulss   xmm1, xmm0
        movss   xmm7, _m128const_am_0
        addss   xmm1, _m128const_am_0p5
        xor     ecx, ecx

        mov     edx, 1
        comiss  xmm1, xmm7
        cvttss2si   eax, xmm1
        cmovc   ecx, edx    // 'c' is 'lt' for comiss
        sub     eax, ecx

        cvtsi2ss    xmm1, eax
        add     eax, 0x7f

        movss   xmm2, xmm1
        mulss   xmm1, c1
        and     eax, 0xff   // Optional, just for sanity
        mulss   xmm2, c2
        subss   xmm0, xmm1
        shl     eax, 23
        subss   xmm0, xmm2

        movss   xmm2, xmm0
        mov     x, eax
        mulss   xmm2, xmm2

        movss   xmm6, q0
        movss   xmm4, p0exp

        mulss   xmm6, xmm2
        movss   xmm7, q1
        mulss   xmm4, xmm2
        movss   xmm5, p1exp

        addss   xmm6, xmm7
        addss   xmm4, xmm5

        movss   xmm7, q2
        mulss   xmm6, xmm2
        mulss   xmm4, xmm2

        addss   xmm6, xmm7
        mulss   xmm4, xmm0

        movss   xmm7, q3
        mulss   xmm6, xmm2
        addss   xmm4, xmm0
        addss   xmm6, xmm7
        movss   xmm0, x

        subss   xmm6, xmm4
        rcpss   xmm6, xmm6
        movss   xmm7, _m128const_am_1
        mulss   xmm4, xmm6
        addss   xmm4, xmm4
        addss   xmm4, xmm7

        mulss   xmm0, xmm4

        movss   x, xmm0
    }

    return x;

#endif // !USE_C
}


float fast_sqrt( float x )
{
	_asm {
		mov		eax, x
		or		eax, eax
		jz		SQRTZERO
		movss	xmm0, x
		// approximate sqrt reciprocal -- |Max Error| <= 1.5x2^-12
		rsqrtss	xmm1, xmm0                  // 1/(x^.5)

		// this does the Newton-Raphson iteration to get up
		// to 22 bits of precision
		movss	xmm2, xmm0					// x
		mulss	xmm0, xmm1					// 9 * 1/sqr(9)
		mulss	xmm0, xmm1					// 9 * 1/sqr(9) * 1/sqr(9)
		mulss	xmm0, xmm1					// 9 * 1/sqr(9) * 1/sqr(9) * 1/sqr(9)
		mulss	xmm0, _m128const_am_0p5		// 1/2 * 9 * 1/sqr(9) * 1/sqr(9) * 1/sqr(9)
		mulss	xmm1, _m128const_am_1p5		// 3/2 * 1/sqr(9)
		subss	xmm1, xmm0					// 3/2 * 1/sqr(9) - 1/2 * 9 * 1/sqr(9) * 1/sqr(9) * 1/sqr(9)
		mulss	xmm1, xmm2					// x * 1/(x^.5)
		movss	x, xmm1
SQRTZERO:
	}
	return x;
}

//----------------------------------------------------------------------------
// sqrt
float fast_inversesqrt
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 61 cycles
    return 1.0f / sqrtf(x);

#else
    // 35 cycles
	_asm {
		movss	xmm0, x
		rsqrtss	xmm1, xmm0
		mulss	xmm0, xmm1
		mulss	xmm0, xmm1
		mulss	xmm0, xmm1
		mulss	xmm0, _m128const_am_0p5
		mulss	xmm1, _m128const_am_3_over_2
		subss	xmm1, xmm0
		movss	x, xmm1
	}
	return x;

#endif // !USE_C
}


//----------------------------------------------------------------------------
// fabs
float fast_fabs
(
    float x
)
//--------------------------------------
{

#if defined(USE_C)

    // 7 cycles
    return fabsf(x);

#else

    // 6 cyles
    __asm
    {
        mov     eax, x          // starting with
        and     eax, 0x7fffffff // And out the sign bit
        mov     x, eax          // result in x
    }

    return x;

#endif // !USE_C

}


//----------------------------------------------------------------------------
// sincos computes both sin and cos simultaneously.
void fast_sincos
(
    float        x,
    SinCosPair*  v
)
//--------------------------------------
{

#if defined(USE_C)

    // 133 cycles
    v->fCos = fast_cos(x);
    v->fSin = fast_sin(x);

#else

    // 68 cycles
    __asm
    {
        movss   xmm0, x

        andps   xmm0, _m128const_am_inv_sign_mask
        mulss   xmm0, _m128const_am_2_over_pi

        mov     eax, x          // sin
        and     eax, 0x80000000 // sin

        movaps  xmm4, xmm0      // sin

        addss   xmm0, _m128const_am_1

        cvttss2si   ecx, xmm0
        cvttss2si   esi, xmm4   // sin

        mov     edx, ecx
        shl     edx, (31 - 1)

        mov     edi, esi        // sin
        shl     edi, (31 - 1)   // sin

        cvtsi2ss    xmm1, ecx
        and     edx, 0x80000000

        cvtsi2ss    xmm5, esi   // sin
        and     edi, 0x80000000 // sin

        and     ecx, 0x1
        subss   xmm0, xmm1

        jz      l_contcos
        movss   xmm1, _m128const_am_1
        subss   xmm1, xmm0
        movss   xmm0, xmm1
l_contcos:

        and     esi, 0x1        // sin
        subss   xmm4, xmm5      // sin

        jz      l_contsin       // sin
        movss   xmm5, _m128const_am_1      // sin
        subss   xmm5, xmm4      // sin
        movss   xmm4, xmm5      // sin
l_contsin:                      // sin

        mov     ecx, v

        movss   xmm1, xmm0
        mulss   xmm0, xmm0

        movss   xmm5, xmm4      // sin
        mulss   xmm4, xmm4      // sin

        mov     [ecx]v.fCos, edx
        movss   xmm2, xmm0
        mulss   xmm0, p3

        xor     eax, edi        // sin
        movss   xmm6, xmm4      // sin
        mulss   xmm4, p3        // sin

        addss   xmm0, p2

        mov     [ecx]v.fSin, eax    // sin
        addss   xmm4, p2         // sin

        mulss   xmm0, xmm2
        movss   xmm3, [ecx]v.fCos

        mulss   xmm4, xmm6      // sin
        movss   xmm7, [ecx]v.fSin  // sin

        addss   xmm0, p1
        addss   xmm4, p1        // sin

        mulss   xmm0, xmm2
        orps    xmm1, xmm3

        mulss   xmm4, xmm6      // sin
        orps    xmm5, xmm7      // sin

        addss   xmm0, p0
        addss   xmm4, p0        // sin

        mulss   xmm0, xmm1
        mulss   xmm4, xmm5      // sin

        movss   dword ptr [ecx]v.fCos, xmm0
        movss   dword ptr [ecx]v.fSin, xmm4
    }

#endif // !USE_C

}

//----------------------------------------------------------------------------
// sin
float fast_sin
(
    float x
)
//--------------------------------------
{

#if defined(USE_C)

    // 111 cycles
    return sinf(x);

#else

    // 62 cycles
    __asm
    {
        movss   xmm0, x

        andps   xmm0, _m128const_am_inv_sign_mask   // xmm0 = abs(x)
        mov     eax, x                              // eax = x
        mulss   xmm0, _m128const_am_2_over_pi       // xmm0 = abs(x) * 2/PI
        and     eax, 0x80000000                     // eax = sign(x)

        cvttss2si   ecx, xmm0                       // ecx = int(xmm0)
        mov     edx, ecx                            // edx = ecx
        shl     edx, (31 - 1)                       // edx = edx << 30
        cvtsi2ss    xmm1, ecx                       // xmm1 = ecx
        and     edx, 0x80000000                     // edx = sign(edx)

        and     ecx, 0x1                            // ecx = ecx & 0x1 (set ZF according to result)
        subss   xmm0, xmm1                          // xmm0 = xmm0 - xmm1

        jz      l_cont                              // jump if 0 / ZF = 1

        movss   xmm1, _m128const_am_1               // xmm1 = 1
        subss   xmm1, xmm0                          // xmm1 = xmm1 - xmm0
        movss   xmm0, xmm1                          // xmm0 = xmm1

l_cont:
        movss   xmm1, xmm0                          // xmm1 = xmm0
        mulss   xmm0, xmm0                          // xmm0 = xmm0 * xmm0
        xor     eax, edx                            // eax = edx | eax
        movss   xmm2, xmm0                          // xmm2 = xmm0
        mulss   xmm0, p3                            // xmm0 = xmm0 * p3
        mov     x, eax                              // x = eax
        addss   xmm0, p2                            // xmm0 = xmm0 + p2
        mulss   xmm0, xmm2                          // xmm0 = xmm0 * xmm2
        movss   xmm3, x                             // xmm3 = x
        addss   xmm0, p1                            // xmm0 = xmm0 + p1
        mulss   xmm0, xmm2                          // xmm0 = xmm0 * xmm2
        orps    xmm1, xmm3                          // xmm1 = xmm1 | xmm3
        addss   xmm0, p0                            // xmm0 = xmm0 + p0
        mulss   xmm0, xmm1                          // xmm0 = xmm0 * xmm1

        movss   x, xmm0
    }

    return x;

#endif // !USE_C

}


//----------------------------------------------------------------------------
// cos
float fast_cos
(
    float x
)
//--------------------------------------
{

#if defined(USE_C)

    // 97 cycles
    return cosf(x);

#else


    // 68 cycles
    __asm
    {
        movss   xmm0, x

        andps   xmm0, _m128const_am_inv_sign_mask   // abs(x)
        mulss   xmm0, _m128const_am_2_over_pi       // x * (2 / pi)
        addss   xmm0, _m128const_am_1               // x * (2 / pi) + 1

        cvttss2si   ecx, xmm0                       // Trancate into ecx.
        mov     edx, ecx                            // Store ecx.
        shl     edx, (31 - 1)                       // Shift left 30 bits.
        cvtsi2ss    xmm1, ecx                       // Store ecx into xmm1.
        and     edx, 0x80000000                     // Get sign bit.

        and     ecx, 0x1
        subss   xmm0, xmm1

        jz      l_cont
        movss   xmm1, _m128const_am_1
        subss   xmm1, xmm0
        movss   xmm0, xmm1
l_cont:
        movss   xmm1, xmm0
        mulss   xmm0, xmm0
        mov     x, edx
        movss   xmm2, xmm0
        mulss   xmm0, p3
        addss   xmm0, p2
        mulss   xmm0, xmm2
        movss   xmm3, x
        addss   xmm0, p1
        mulss   xmm0, xmm2
        orps    xmm1, xmm3
        addss   xmm0, p0
        mulss   xmm0, xmm1

        movss   x, xmm0
    }

    return x;

#endif // !USE_C
}


//----------------------------------------------------------------------------
// fast_atan
float fast_tan
(
    float x
)
//--------------------------------------
{
#if defined(USE_C)

    // 148 cycles
    return tanf(x);

#else

    // 75 cycles
    __asm
    {
        movss   xmm0, x

        andps   xmm0, _m128const_am_inv_sign_mask
        mulss   xmm0, _m128const_am_2_over_pi
        movss   xmm7, xmm0
        addss   xmm0, _m128const_am_1

        cvttss2si   ecx, xmm0
        mov     edx, ecx
        shl     edx, (31 - 1)
        cvtsi2ss    xmm1, ecx
        and     edx, 0x80000000

        and     ecx, 0x1
        subss   xmm0, xmm1

        jz      l_cont
        movss   xmm1, _m128const_am_1
        subss   xmm1, xmm0
        movss   xmm0, xmm1
l_cont:
        mov     eax, x
        and     eax, 0x80000000

        cvttss2si   ecx, xmm7
        xor     eax, edx
        mov     edx, ecx
        shl     edx, (31 - 1)
        cvtsi2ss    xmm3, ecx
        and     edx, 0x80000000

        and     ecx, 0x1
        subss   xmm7, xmm3

        jz      l_cont2
        movss   xmm3, _m128const_am_1
        subss   xmm3, xmm7
        movss   xmm7, xmm3
l_cont2:
        movss   xmm1, xmm0
        movss   xmm3, xmm7
        movss   xmm6, p3
        mulss   xmm0, xmm0
        mulss   xmm7, xmm7
        xor     eax, edx
        movss   xmm2, xmm0
        movss   xmm4, xmm7
        mulss   xmm0, xmm6
        mulss   xmm7, xmm6
        movss   xmm6, p2
        mov     x, eax
        addss   xmm0, xmm6
        addss   xmm7, xmm6
        mulss   xmm0, xmm2
        movss   xmm6, p1
        mulss   xmm7, xmm4
        movss   xmm5, x
        addss   xmm0, xmm6
        addss   xmm7, xmm6
        mulss   xmm0, xmm2
        mulss   xmm7, xmm4
        movss   xmm6, p0
        orps    xmm3, xmm5
        addss   xmm0, xmm6
        addss   xmm7, xmm6
        mulss   xmm0, xmm1
        mulss   xmm7, xmm3
        rcpss   xmm0, xmm0

        mulss   xmm0, xmm7

        movss   x, xmm0
    }

    return x;

#endif // !USE_C
}


//----------------------------------------------------------------------------
// pow
float fast_pow
(
    float x,
    float y
)
//--------------------------------------
{
#if defined(USE_C)

    // 303 cycles
    return powf(x, y);

#else

    // 133 cycles
    __asm
    {
        movss   xmm0, x
        movss   xmm1, y

        xorps   xmm7, xmm7
        comiss  xmm7, xmm0
        movss   xmm7, _m128const_am_inv_mant_mask
        maxss   xmm0, _m128const_am_min_pos_norm  // Cut off denormalized stuff.
        jnc     l_zerobase
        movss   xmm3, _m128const_am_1
        movss   x, xmm0

        andps   xmm0, xmm7
        orps    xmm0, xmm3  // xmm3 == 1.0
        comiss  xmm0, pow_rsqrt2
        movss   xmm7, xmm0

        jc      l_lt  // 'c' is 'lt' for comiss
//l_ge:
        xor     ecx, ecx
        movss   xmm2, xmm3  // xmm3 == 1.0
        jmp     l_continue

l_lt:
        mov     ecx, 1
        movss   xmm2, _m128const_am_0p5

l_continue:
        addss   xmm7, xmm2
        subss   xmm0, xmm2
        mov     edx, x
        rcpss   xmm7, xmm7
        mulss   xmm0, xmm7
        addss   xmm0, xmm0

        shr     edx, 23

        movss   xmm4, pow_p0
        movss   xmm6, pow_q0

        sub     edx, 0x7f
        movss   xmm2, xmm0
        mulss   xmm2, xmm2

        mulss   xmm4, xmm2
        sub     edx, ecx
        movss   xmm5, pow_p1
        mulss   xmm6, xmm2
        cvtsi2ss    xmm3, edx
        movss   xmm7, pow_q1

        addss   xmm4, xmm5
        mulss   xmm3, xmm1
        addss   xmm6, xmm7

        movss   xmm5, pow_p2
        mulss   xmm4, xmm2
        movss   xmm7, pow_q2
        mulss   xmm6, xmm2

        addss   xmm4, xmm5
        mulss   xmm1, pow_c0
        addss   xmm6, xmm7

        mulss   xmm4, xmm2
        rcpss   xmm6, xmm6

        mulss   xmm6, xmm0
        movss   xmm5, _m128const_am_0p5
        mulss   xmm4, xmm6
        addss   xmm0, xmm4
        xorps   xmm7, xmm7
        mulss   xmm0, xmm1

        addss   xmm0, xmm3

        maxss   xmm0, pow_fmin
        minss   xmm0, pow_fmax

        xor     ecx, ecx
        addss   xmm5, xmm0

        mov     edx, 1
        comiss  xmm5, xmm7
        cvttss2si   eax, xmm5
        cmovc   ecx, edx  // 'c' is 'lt' for comiss
        sub     eax, ecx

        cvtsi2ss    xmm5, eax
        add     eax, 0x7f

        subss   xmm0, xmm5

        movss   xmm2, xmm0
        mulss   xmm2, xmm2

        movss   xmm6, pow_s0
        movss   xmm4, pow_r0

        mulss   xmm6, xmm2
        movss   xmm7, pow_s1
        and     eax, 0xff  // Optional, just for sanity
        mulss   xmm4, xmm2
        movss   xmm5, pow_r1

        shl     eax, 23
        addss   xmm6, xmm7
        addss   xmm4, xmm5

        movss   xmm5, pow_r2
        mulss   xmm4, xmm2

        addss   xmm4, xmm5

        mulss   xmm4, xmm0

        mov     x, eax
        subss   xmm6, xmm4
        movss   xmm7, _m128const_am_1
        rcpss   xmm6, xmm6
        mulss   xmm4, xmm6
        movss   xmm0, x
        addss   xmm4, xmm4
        addss   xmm4, xmm7

        mulss   xmm0, xmm4

        jmp l_done

l_zerobase:
        xorps   xmm0, xmm0

l_done:
        movss   x, xmm0
    }

    return x;

#endif // !USE_C
}

float fast_hypot( float x, float y )
{
#if defined(USE_C)
	return (float) _hypot( x, y );
#else
	// 15.38x faster
	_asm {
		movss		xmm0, x
		movss		xmm1, y
		mulss		xmm0, xmm0
		mulss		xmm1, xmm1
		addss		xmm0, xmm1
		rsqrtss		xmm1, xmm0
		movss		xmm2, xmm0
		mulss		xmm0, xmm1
		mulss		xmm0, xmm1
		mulss		xmm0, xmm1
		mulss		xmm0, _m128const_am_0p5
		mulss		xmm1, _m128const_am_3_over_2
		subss		xmm1, xmm0
		mulss		xmm1, xmm2
		movss		x, xmm1
	}
	return x;
#endif // !USE_C
}

float fast_ceil( float x )
{
#if defined(USE_C)
	return ceilf( x );
#else
	// 2.01x faster
	unsigned long m32;
	_asm {
		movss		xmm0, x
		stmxcsr		m32
		mov			edx, m32
		mov			eax, 0ffff9fffh
		and			eax, edx
		or			eax, 4000h
		mov			m32, eax
		ldmxcsr		m32
		cvtss2si	eax, xmm0
		cvtsi2ss	xmm0, eax
		mov			m32, edx
		ldmxcsr		m32
		movss		x, xmm0
	}
	return x;
#endif // !USE_C
}

float fast_floor( float x )
{
#if defined(USE_C)
	return floorf( x );
#else
	// 1.99x faster
	unsigned long m32;
	_asm {
		movss		xmm0, x
		stmxcsr		m32
		mov			edx, m32
		mov			eax, 0ffff9fffh
		and			eax, edx
		or			eax, 2000h
		mov			m32, eax
		ldmxcsr		m32
		cvtss2si	eax, xmm0
		cvtsi2ss	xmm0, eax
		mov			m32, edx
		ldmxcsr		m32
		movss		x, xmm0
	}
	return x;
#endif // !USE_C
}

float fast_tanh( float x )
{
#if defined(USE_C)
	return tanhf( x );
#else
	// 3.26x faster
	_asm {
		mov			eax, x
		cmp			eax, 0ba83126fh
		ja			rettanhm
		cmp			eax, 3a83126fh
		ja			rettanhp

		movss		xmm1, x
		movss		xmm0, th1
		mulss		xmm1, xmm1
		mulss		xmm1, th3
		subss		xmm0, xmm1
		mulss		xmm0, x
		movss		x, xmm0
	}
	return x;
	_asm {
		ALIGN 16
rettanhm:
		movss		xmm0, x
		mulss		xmm0, th2p
		maxss		xmm0, fmin
		minss		xmm0, fmax
		movss		xmm1, rln2
		mulss		xmm1, xmm0
		movss		xmm6, _m128const_am_0
		addss		xmm1, _m128const_am_0p5
		xor			ecx, ecx
		mov			edx, 1
		comiss		xmm1, xmm6
		cvttss2si	eax, xmm1
		cmovc		ecx, edx
		sub			eax, ecx
		cvtsi2ss	xmm1, eax
		add			eax, 7fh
		movss		xmm2, xmm1
		mulss		xmm1, c1
		and			eax, 0ffh
		mulss		xmm2, c2
		subss		xmm0, xmm1
		shl			eax, 23
		subss		xmm0, xmm2
		movss		xmm2, xmm0
		mov			x, eax
		mulss		xmm2, xmm2
		movss		xmm5, q0
		movss		xmm3, p0exp
		mulss		xmm5, xmm2
		movss		xmm6, q1
		mulss		xmm3, xmm2
		movss		xmm4, p1exp
		addss		xmm5, xmm6
		addss		xmm3, xmm4
		movss		xmm6, q2
		mulss		xmm5, xmm2
		mulss		xmm3, xmm2
		addss		xmm5, xmm6
		mulss		xmm3, xmm0
		movss		xmm6, q3
		mulss		xmm5, xmm2
		addss		xmm3, xmm0
		addss		xmm5, xmm6
		movss		xmm0, x
		subss		xmm5, xmm3
		rcpss		xmm5, xmm5
		movss		xmm6, _m128const_am_1
		mulss		xmm3, xmm5
		addss		xmm3, xmm3
		addss		xmm3, xmm6
		mulss		xmm0, xmm3
		addss		xmm0, th1
		rcpss		xmm1, xmm0
		movss		xmm2, xmm1
		addss		xmm2, xmm2
		mulss		xmm1, xmm1
		mulss		xmm1, xmm0
		subss		xmm2, xmm1
		mulss		xmm2, th2p
		movss		xmm1, th1
		subss		xmm1, xmm2
		movss		x, xmm1
	}
	return x;
	_asm {
		ALIGN 16
rettanhp:
		movss		xmm0, x
		mulss		xmm0, th2m
		maxss		xmm0, fmin
		minss		xmm0, fmax
		movss		xmm1, rln2
		mulss		xmm1, xmm0
		movss		xmm6, _m128const_am_0
		addss		xmm1, _m128const_am_0p5
		xor			ecx, ecx
		mov			edx, 1
		comiss		xmm1, xmm6
		cvttss2si	eax, xmm1
		cmovc		ecx, edx
		sub			eax, ecx
		cvtsi2ss	xmm1, eax
		add			eax, 7fh
		movss		xmm2, xmm1
		mulss		xmm1, c1
		and			eax, 0ffh
		mulss		xmm2, c2
		subss		xmm0, xmm1
		shl			eax, 23
		subss		xmm0, xmm2
		movss		xmm2, xmm0
		mov			x, eax
		mulss		xmm2, xmm2
		movss		xmm5, q0
		movss		xmm3, p0exp
		mulss		xmm5, xmm2
		movss		xmm6, q1
		mulss		xmm3, xmm2
		movss		xmm4, p1exp
		addss		xmm5, xmm6
		addss		xmm3, xmm4
		movss		xmm6, q2
		mulss		xmm5, xmm2
		mulss		xmm3, xmm2
		addss		xmm5, xmm6
		mulss		xmm3, xmm0
		movss		xmm6, q3
		mulss		xmm5, xmm2
		addss		xmm3, xmm0
		addss		xmm5, xmm6
		movss		xmm0, x
		subss		xmm5, xmm3
		rcpss		xmm5, xmm5
		movss		xmm6, _m128const_am_1
		mulss		xmm3, xmm5
		addss		xmm3, xmm3
		addss		xmm3, xmm6
		mulss		xmm0, xmm3
		addss		xmm0, th1
		rcpss		xmm1, xmm0
		movss		xmm2, xmm1
		addss		xmm2, xmm2
		mulss		xmm1, xmm1
		mulss		xmm1, xmm0
		subss		xmm2, xmm1
		mulss		xmm2, th2p
		subss		xmm2, th1
		movss		x, xmm2
	}
	return x;
#endif // !USE_C
}

float fast_cosh( float x )
{
#if defined(USE_C)
	return coshf( x );
#else
	// 3.96x faster

	_asm {
		movss		xmm0, x
		maxss		xmm0, fmin
		minss		xmm0, fmax
		movss		xmm1, rln2
		mulss		xmm1, xmm0
		movss		xmm6, _m128const_am_0
		addss		xmm1, _m128const_am_0p5
		xor			ecx, ecx
		mov			edx, 1
		comiss		xmm1, xmm6
		cvttss2si	eax, xmm1
		cmovc		ecx, edx
		sub			eax, ecx
		cvtsi2ss	xmm1, eax
		add			eax, 7fh
		movss		xmm2, xmm1
		mulss		xmm1, c1
		and			eax, 0ffh
		mulss		xmm2, c2
		subss		xmm0, xmm1
		shl			eax, 23
		subss		xmm0, xmm2
		movss		xmm2, xmm0
		mov			x, eax
		mulss		xmm2, xmm2
		movss		xmm5, q0
		movss		xmm3, p0exp
		mulss		xmm5, xmm2
		movss		xmm6, q1
		mulss		xmm3, xmm2
		movss		xmm4, p1exp
		addss		xmm5, xmm6
		addss		xmm3, xmm4
		movss		xmm6, q2
		mulss		xmm5, xmm2
		mulss		xmm3, xmm2
		addss		xmm5, xmm6
		mulss		xmm3, xmm0
		movss		xmm6, q3
		mulss		xmm5, xmm2
		addss		xmm3, xmm0
		addss		xmm5, xmm6
		movss		xmm0, x
		subss		xmm5, xmm3
		rcpss		xmm5, xmm5
		movss		xmm6, _m128const_am_1
		mulss		xmm3, xmm5
		addss		xmm3, xmm3
		addss		xmm3, xmm6
		mulss		xmm0, xmm3

		rcpss		xmm1, xmm0
		movss		xmm2, xmm1
		addss		xmm2, xmm2
		mulss		xmm1, xmm1
		mulss		xmm1, xmm0
		subss		xmm2, xmm1
		addss		xmm0, xmm2
		mulss		xmm0, sh5
		movss		x, xmm0
	}
	return x;
#endif // !USE_C
}

float fast_sinh( float x )
{
#if defined(USE_C)
	return sinhf( x );
#else
	// 3.30x faster

	_asm {
		mov			eax, x
		and			eax, 7fffffffh
		cmp			eax, 3a83126fh
		jg			culcsinh
		movss		xmm0, x
		mulss		xmm0, xmm0
		mulss		xmm0, sh6
		addss		xmm0, sh1
		mulss		xmm0, x
		movss		x, xmm0
	}
	return x;
	_asm {
		ALIGN 16
culcsinh:
		movss		xmm0, x
		maxss		xmm0, fmin
		minss		xmm0, fmax
		movss		xmm1, rln2
		mulss		xmm1, xmm0
		movss		xmm6, _m128const_am_0
		addss		xmm1, _m128const_am_0p5
		xor			ecx, ecx
		mov			edx, 1
		comiss		xmm1, xmm6
		cvttss2si	eax, xmm1
		cmovc		ecx, edx
		sub			eax, ecx
		cvtsi2ss	xmm1, eax
		add			eax, 7fh
		movss		xmm2, xmm1
		mulss		xmm1, c1
		and			eax, 0ffh
		mulss		xmm2, c2
		subss		xmm0, xmm1
		shl			eax, 23
		subss		xmm0, xmm2
		movss		xmm2, xmm0
		mov			x, eax
		mulss		xmm2, xmm2
		movss		xmm5, q0
		movss		xmm3, p0exp
		mulss		xmm5, xmm2
		movss		xmm6, q1
		mulss		xmm3, xmm2
		movss		xmm4, p1exp
		addss		xmm5, xmm6
		addss		xmm3, xmm4
		movss		xmm6, q2
		mulss		xmm5, xmm2
		mulss		xmm3, xmm2
		addss		xmm5, xmm6
		mulss		xmm3, xmm0
		movss		xmm6, q3
		mulss		xmm5, xmm2
		addss		xmm3, xmm0
		addss		xmm5, xmm6
		movss		xmm0, x
		subss		xmm5, xmm3
		rcpss		xmm5, xmm5
		movss		xmm6, _m128const_am_1
		mulss		xmm3, xmm5
		addss		xmm3, xmm3
		addss		xmm3, xmm6
		mulss		xmm0, xmm3

		rcpss		xmm1, xmm0
		movss		xmm2, xmm1
		addss		xmm2, xmm2
		mulss		xmm1, xmm1
		mulss		xmm1, xmm0
		subss		xmm2, xmm1
		subss		xmm0, xmm2
		mulss		xmm0, sh5
		movss		x, xmm0
	}
	return x;
#endif // !USE_C
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\fastmath.h ===
/*--
Copyright (c) 1999 - 2000 Microsoft Corporation - Xbox SDK Framework

Module Name:

    FastMath.h

Abstract:

    General math support including fast replacements for the standard math
    library. These fast replacements use SSE/SIMD instructions.

Revision History:

	7/1/2000	added fast_acos and fast_asin for SSE.
	7/3/2000	Fixed fast_log10 and fast_inversesqrt.
	7/4/2000	Fixed fast_atan2 bug.
	7/5/2000	improved quality of fast_acos and fast_asin.
	7/6/2000	improved algorithm of fast_log.
	8/1/2000	implemented hypot.
	8/8/2000	implemented fast_ceil and fast_floor.
	8/21/2000	implemented 3 fast hyperbolic functions.


TODO:
	Fix up arc-tangent quality.

--*/

#if !defined(SDK_HEADER_FASTMATH)
#define SDK_HEADER_FASTMATH


#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include "xmmintrin.h"
#include "math.h"

//------------------------------------------------------------------------------
#define PI              3.14159265358979323846f             // Pi
#define PI_MUL_2        6.28318530717958623200f             // 2 * Pi
#define PI_DIV_2        1.57079632679489655800f             // Pi / 2
#define PI_DIV_4        0.78539816339744827900f             // Pi / 4
#define INV_PI          0.31830988618379069122f             // 1 / Pi
#define DEGTORAD        0.01745329251994329547f             // Degrees to Radians
#define RADTODEG        57.29577951308232286465f            // Radians to Degrees
#define FLOAT_SMALL     1.0e-6f                             // Small number for floats
#define FLOAT_HUGE      1.0e+38f                            // Huge number for floats
#define FLOAT_EPSILON   1.0e-5f                             // Tolerance for floats
#define FLOAT_INFINITY  ((float)3.40282346638528860e+38)    // Infinity value for float


//----------------------------------------------------------------------------
// Flaoting point manipulation macros, used by the inline functions below.
#define FP_BITS(fp) (*(DWORD *)&(fp))
#define FP_ABS_BITS(fp) (FP_BITS(fp)&0x7FFFFFFF)
#define FP_SIGN_BIT(fp) (FP_BITS(fp)&0x80000000)
#define FP_ONE_BITS     0x3F800000
#define FP_HALFH        0x3f000000
#define FP_EXP_BITS     0x7f800000
#define FP_SMAN_BITS    0x807fffff

//----------------------------------------------------------------------------
// Define a C structure to hold a pair of floats.
struct SinCosPair
{
    float   fCos;
    float   fSin;
};


//----------------------------------------------------------------------------
extern float fast_atan(float x);
extern float fast_atan2(float x, float y);
extern float fast_acos(float x);
extern float fast_asin(float x);
extern float fast_log(float x);
extern float fast_log10(float x);
extern float fast_exp(float x);
extern float fast_sqrt(float x);
extern float fast_inversesqrt(float x);
extern float fast_fabs(float x);
extern void fast_sincos(float x, SinCosPair* v);
extern float fast_sin(float x);
extern float fast_cos(float x);
extern float fast_tan(float x);
extern float fast_pow(float x, float y);

extern float fast_hypot(float x, float y);
extern float fast_ceil(float x);
extern float fast_floor(float x);
extern float fast_tanh(float x);
extern float fast_cosh(float x);
extern float fast_sinh(float x);

#endif //SDK_HEADER_FASTMATH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\GLOBALS.C ===
#include "sos.h"
#include "error.h"
#include "protos.h"

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")


#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

struct	process	*  process_queue;		/* pointer to process queue 	*/
struct sound	*  current_call;		/* pointer to current sound call*/
struct process *  current_process;	/* pointer to current s. proc 	*/

struct	fifo fifo;			/* sound call fifo		*/

struct	track_info	*  ti;   	/* global pointer to current track info*/
 ushort		value_16_bit;	/* value to pass to asm routine */

short 		system_clock_music ;/* global music system timer     	*/
uchar		system_clock_mlow;  /* for 3 byte clocks		*/
short 		system_clock_fx; /* global fx system timer	    	*/
uchar		system_clock_fxlow; /* for 3-byte clocks	*/
uchar 		clock_cntr[2];	/* clock count-downer		*/
uchar 		clock_cntr_value[2];	/* clock count-downer reset val	*/
uchar		clock_cntr_save;	/* save value of clock count-downer */
ushort 		global_music_xpose;	/* master transposition for mus	*/
ushort		global_effect_xpose;	/* master transposition for f/x	*/
uchar		a_value;		/* byte for register a data 	*/
uchar		b_value;		/* byte for register b data 	*/
uchar		master_music_volume;	/* main attenuation for music	*/
uchar		master_effect_volume;	/* main attenuation for f/x	*/
uchar		music_atten;		/* music attenuation control */

uchar		marker;					/* tune transition marker	*/
uchar		current_level;		/* global level of current process */
uchar		current_channel;	/* global chan of current process */


ushort		dp_word1;			/* temp var */

uchar		gtifbtmp;			/* temp var for get_info_block */
uchar		last_music_call;	/* last music call made		*/
uchar		current_timer_priority;	/* priority of last timer call */
uchar		sos_only;			/* 1 to loop forever, 0 to return */
uchar		sound_call_table;	/* which soundtable are we on ?*/
ushort		global_fxpose;		/* global transpose value */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\FTABLES.H ===
/*************************************************************************
*                                                                        *
* 	Function tables for event functions and sound call functions	  *
*                                                                        *
*************************************************************************/

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

extern int	f_note(void);
extern int	f_rest(void);
extern int	f_jumpto(void);
extern int	f_loop(void);
extern int	f_endloop(void);
extern int	f_patch(void);
extern	int	f_pan(void);
extern	int	f_mux(void);
extern	int	f_demux(void);
extern	int	f_volume(void);
extern	int	f_xpose(void);
extern	int	f_xset(void);
extern	int	f_slur(void);
extern	int	f_ring(void);
extern	int	f_clockset(void);
extern	int	f_end(void);
extern	int	f_filterset(void);
extern	int	f_filterinc(void);


extern	int	f_mark(void);
extern	int	f_sound_call(void);
extern	int	f_srest(void);
extern	int	f_intvarset(void);
extern	int	f_intvarinc(void);
extern	int	f_user_1_var_evf(void);
extern	int	f_user_2_var_evf(void);
extern int f_sig(void);
extern	int	f_gliss(void);
extern	int	f_clockinc(void);
extern	int	f_paninc(void);
extern int f_musicclockinc(void);
extern	int	f_MidiNoteOn(void);
extern	int	f_MidiNoteOff(void);
extern	int	f_MidiProgram(void);
extern	int	f_MidiVolume(void);
extern	int	f_MidiTempo(void);
extern	int	f_MidiControl(void);
extern	int	f_MidiEOT(void);

extern	int	f_fxset(void);

extern void	call_silence(void);
extern void	call_music(void);
extern void	call_effect(void);
extern	void	call_volume(void);
extern	void	call_senddev(void);
extern	void	call_mark(void);
extern	void	call_ignore(void);
extern	void	call_user_function(void);
extern	void	call_timer(void);
extern	void	call_end_timer(void);
extern void	call_play_timer(void);
extern void call_kill_effect(void);

int	(* const event_fcns[])() = {
	f_rest,				//0
	f_note,				//1
	f_jumpto,			//2
	f_loop,				//3
	f_endloop,			//4
	f_patch,			//5
	f_pan,				//6
	f_mux,				//7
	f_demux,			//8
	f_volume,			//9
	f_xpose,			//10
	f_xset,				//11
	f_slur,				//12
	f_ring,				//13
	f_clockset,			//14
	f_end,				//15
	f_filterinc,		//16
	f_filterset,		//17
	f_gliss,			//18

	f_mark,
	f_sound_call,
	f_srest,
	f_intvarset,
	f_intvarinc,
	f_user_1_var_evf,
	f_user_2_var_evf,
	f_sig,

	f_clockinc,
	f_paninc,
	f_musicclockinc,
	f_MidiNoteOn,	/* 35 */
	f_MidiNoteOff,	/* 36 */
	f_MidiProgram,	/* 37 */
	f_MidiVolume,	/* 38 */
	f_MidiTempo,	/* 39 */
	f_MidiControl,	/* 40 */
	f_MidiEOT,		/* 41 */
	f_fxset,


};

/*
 *	NOTE:
 *	call music is used for BOTH forground sounds and background music
 *	This is becuase the code is essentially the same so it saves space
 */


void	(* const call_fcns[])() = {
	call_silence,		/* 0 sound call type 0 (silence)*/
	call_music,			/* 1 sound call type 1 (music)  */
	call_effect,		/* 2 sound call type 2 (effect) */
	call_volume, 		/* 3 sound call type 3 (volume) */
	call_ignore,  		/* 4 formerly call_oki	*/
	call_senddev,		/* 5 send data directly to yamaha chip */
	call_mark,			/* 6 leave a marker				*/
	call_ignore,		/* 7 ignore sound call		*/
	call_user_function,	/* 8 user defined function 	*/
	call_timer,			/* 9 make a music timer call	*/
	call_end_timer,		/* 10 stop timer, go back to prev back music */
	call_play_timer,		/* 11 sound table entry for timer */
	call_kill_effect	/* 12 kill all forground fx		*/
};
	

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\EVF.C ===
/*************************************************************************
*                                                                        *
* 	Here live the event functions					  *
*                                                                        *
*************************************************************************/
#include	"sos.h"
#include	"protos.h"
#include	"externs.h"

#define	c_p 	current_process		/* shorthand */


ushort	* ptr;				/* pointer to cur. voice data	*/


unsigned short	un_int;
uchar			un_char;

int	f_MidiNoteOn()
{
	return(1);
}
int	f_MidiNoteOff()
{
	return(1);
}
int	f_MidiProgram()
{
	return(1);
}
int	f_MidiVolume()
{
	return(1);
}
int	f_MidiTempo()
{
	return(1);
}
int	f_MidiControl()
{
	return(1);
}
int	f_MidiEOT()
{
	return(1);
}


int f_note()
{
	ptr = ++current_process->mem_ptr.i;	/* get past func byte */
	b_value = (uchar) *(ushort *)ptr++; 		/* point to delay */
	if (b_value	& 0x80) {			/* 1 byte duration */
		dp_word1 = *(uchar *) ptr;
		b_value &= 0x7f;
	}
	else {

	dp_word1 = *(unsigned short *)ptr++;

	}
	current_process->function = *(ptr);
	current_process->mem_ptr.i = ptr;
	current_process->timer += dp_word1;
	ti->pitch = value_16_bit = (b_value << 8) + ti->transpose;
	if (current_level == LEVEL_EFFECT) {
		ti->pitch += global_fxpose;
	}
/*		ti->pitch += global_fxpose;*/
		value_16_bit = ti->pitch;

	if (current_level < channel_level[current_channel]) 
	    return(1);
	note_on_functions[current_channel]();
	return(1);
}

f_gliss()
{
#ifdef GLISS
/*#ifdef	BIGOS*/
	uchar	*tmp_ptr;

	tmp_ptr = c_p->mem_ptr.c++;
	if (c_p->type == 0) {		/* first time						*/
		c_p->type = 1;			/* set not first time flag			*/
		c_p->data1 = *c_p->mem_ptr.i++;		/* get base pitch	*/
		c_p->mem_ptr.i++;					/* pass delta		*/
		c_p->data2 = *c_p->mem_ptr.i;		/* get counter		*/
		c_p->mem_ptr.c = tmp_ptr;		
	}
	else {
		if (c_p->data2-- == 0) {
			c_p->mem_ptr.c = tmp_ptr + 7;		/* point to xtra time	*/
			c_p->type = 0;
			c_p->timer += *c_p->mem_ptr.i++;	/* get xtra time*/
			c_p->data1 += *c_p->mem_ptr.i++;		/* get xtra frac	*/
			c_p->function = *c_p->mem_ptr.c;

		}
		else {
			c_p->data1 += *(++c_p->mem_ptr.i);
			c_p->timer += 4;
			c_p->mem_ptr.c = tmp_ptr;			/* point back to us	*/
	    }
		ti->pitch = value_16_bit = c_p->data1 + ti->transpose;
		if (current_level < channel_level[current_channel]) 
		    return(1);
		slur_functions[current_channel]();
	}		
	return(1);
#endif
	return(1);
}

int f_rest()
{
/*	unsigned int	del;*/

	ptr = ++current_process->mem_ptr.i;
	un_int  = *(unsigned short *)ptr++;
	current_process->function = *ptr;
	current_process->timer += un_int;
	current_process->mem_ptr.i = ptr;

	if (current_level < channel_level[current_channel]) 
	    return(1);
	note_off_functions[current_channel]();
	return(1);
}



int f_srest()
{

	return(1);
}

int f_jumpto()
{

/*	uchar	*addr;*/

	current_process->mem_ptr.i++;		/* get past func byte */
	ptr = *(ushort **)current_process->mem_ptr.i++;  /* point to next func */
	current_process->mem_ptr.i = ptr;
	current_process->function = *ptr;	/* get function */
	return(1);
}

int f_loop()
{
	ti->loop_counter[ti->loop_level] = *(++c_p->mem_ptr.i);
	ti->loop_addr[(ti->loop_level)++] = (ushort *) ++c_p->mem_ptr.i;
	c_p->function = *c_p->mem_ptr.i;
	return(1);
}

int f_endloop()
{
	if (--(ti->loop_counter[ti->loop_level-1]) != 0) {
	  c_p->mem_ptr.i = (ushort *)ti->loop_addr[ti->loop_level-1];
	}
	else {					/* done looping */
	    c_p->mem_ptr.i++;
	    ti->loop_level--;
	}
	c_p->function = *c_p->mem_ptr.i;
	return(1);
}



int f_patch()
{
	ushort	pat;

    ptr = ++current_process->mem_ptr.i;		/* get past func byte */
	pat = *(ushort *)ptr++;  /* point to patch # */
	current_process->function = *(ptr);
	current_process->mem_ptr.i = ptr;
	ti->patch = pat;
	ti->pan = ti->volume = 0;

	if (current_level < channel_level[current_channel]) 
	    return(1);
	patch_functions[current_channel](pat);
	return(1);
}

int f_pan()
{
      	ptr = ++current_process->mem_ptr.i;		  /* get past func byte */
	a_value = *(uchar *)ptr++; /* point to pan */
	current_process->function = *ptr;
	current_process->mem_ptr.i = ptr;
	ti->pan = a_value;
	if (current_level < channel_level[current_channel]) 
	    return(1);
	pan_functions[current_channel](current_channel,a_value,ti->patch);
	return(1);
}
int f_paninc()
{
/*#ifdef	BIGOS */
      	ptr = ++current_process->mem_ptr.i;		  /* get past func byte */
	a_value = *(char *)ptr++; /* point to pan */
	current_process->function = *ptr;
	current_process->mem_ptr.i = ptr;
	ti->pan += (signed char) a_value;
	if (current_level < channel_level[current_channel]) 
	    return(1);
	pan_functions[current_channel](current_channel,ti->pan,ti->patch);
	return(1);
/*#endif*/
}



int f_mux()
{
	ti->mux_addr[(ti->mux_level)++] = (ushort *) (++c_p->mem_ptr.c + 2);
	c_p->mem_ptr.c = (uchar *)*(ushort *)(c_p->mem_ptr.c);
	c_p->function = *c_p->mem_ptr.c;
	return(1);
}
int f_demux()
{
/*	uchar	tmp;*/

	un_char = --(ti->mux_level);
	c_p->mem_ptr.c = (uchar *)ti->mux_addr[un_char];
	c_p->function = *c_p->mem_ptr.c;
	return(1);
}

int f_volume()
{
	un_char = ti->volume + *(short *)++current_process->mem_ptr.i; /* point to vol */
	current_process->function = *++current_process->mem_ptr.i;
	ti->volume = un_char;
	if (current_level < channel_level[current_channel]) 
	    return(1);
	volume_functions[current_channel](un_char,current_level,ti->patch,current_channel);
	return(1);
}



int f_fxset()
{
	c_p->mem_ptr.c++;
	global_fxpose = *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.c;
	return(1);
}


int f_xpose()
{
	c_p->mem_ptr.i++;
	ti->transpose += *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.i;
	return(1);
}

int f_xset()
{
	c_p->mem_ptr.i++;
	ti->transpose = *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.i;
	return(1);
}


int f_filterinc()
{
	c_p->mem_ptr.i++;
	ti->filtercutoff += *c_p->mem_ptr.i++;
	ti->filterres = *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.i;
	filter_functions[current_channel]();
	return(1);
}

int f_filterset()
{
	c_p->mem_ptr.i++;
	ti->filtercutoff = *c_p->mem_ptr.i++;
	ti->filterres = *c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.i;
	filter_functions[current_channel]();
	return(1);
}


int f_slur()
{
/*	unsigned int	del;*/

	ptr = ++current_process->mem_ptr.i;	/* get past func byte */
	b_value = (uchar) *(ushort *)ptr++; 		/* point to delay */
	if (b_value	& 0x80) {			/* 1 byte duration */
		dp_word1 = *(uchar *) ptr;
		b_value &= 0x7f;
	}
	else {

	dp_word1 = *(unsigned short *)ptr++;

	}
	current_process->function = *(ptr);
	current_process->mem_ptr.i = ptr;
	current_process->timer += dp_word1;
	ti->pitch = value_16_bit = (b_value << 8) + ti->transpose;
	if (current_level == LEVEL_EFFECT) {
		ti->pitch += global_fxpose;
	}
/*		ti->pitch += global_fxpose;*/
		value_16_bit = ti->pitch;

	if (current_level < channel_level[current_channel]) 
	    return(1);
	slur_functions[current_channel]();
	return(1);
	//

}


int f_ring()
{

	ptr = ++current_process->mem_ptr.i;
	un_int = *(unsigned short *)ptr++;
	current_process->function = *ptr;
	current_process->timer += un_int;
	current_process->mem_ptr.i = ptr;
	return(1);
}


f_clockset()
{
	current_process->mem_ptr.c++;		/* get past func byte */
	clock_cntr_value[c_p->level] = *(uchar *)current_process->mem_ptr.c++;/* point to next func */
	current_process->function = *current_process->mem_ptr.c;
	return(1);
}

f_clockinc()
{
	return(1);
}


f_musicclockinc()
{
	return(1);
}



/*************************************************************************
*                                                                        *
* 	Used to end a track of music or a sound effect			  *
*                                                                        *
*************************************************************************/

int f_end()
{
/*	un_char = c_p->hard_channel;*/
//	nosound(current_channel);
//	ti = get_music_info_block();
//	remove_processes_by_level_and_channel(LEVEL_EFFECT,current_channel);
//	channel_level[current_channel] = LEVEL_MUSIC;
//	current_level = LEVEL_MUSIC;
//	if (ti->patch == NULL)
//		return(0);
//	ptr = ti->patch;
//	patch_functions[current_channel](ptr);
//	pan_functions[current_channel](current_channel,ti->pan,ptr);
//	volume_functions[current_channel](ti->volume,current_level,ptr,current_channel);
	return(0);
}


	







int f_mark()
{
#ifdef	BIGOS
	uchar	m_value;
	uchar	dest;
	
	c_p->mem_ptr.c++;
	m_value = *c_p->mem_ptr.c++;	/* get marker # */
	dest =  *c_p->mem_ptr.c++;	/* get destination */
	c_p->function = *c_p->mem_ptr.c;
	if (m_value == marker) {
		DINT;
		put_fifo(dest);
		EINT;
		marker = 0;
	}
#endif
	return(1);
}


int f_sound_call()
{
/*#ifdef	BIGOS*/
	uchar	dest;
	
	c_p->mem_ptr.c++;
	dest =  *c_p->mem_ptr.c++;	/* get destination */
	c_p->function = *c_p->mem_ptr.c;
/*	DINT;*/
	put_fifo(dest);
/*	EINT;*/
	return(1);
/*#endif*/
}

int f_intvarset()
{
#ifdef	BIGOS
	uchar	index;
	c_p->mem_ptr.c++;
	index = *c_p->mem_ptr.c++;
	int_vars[index] = *(ushort *)c_p->mem_ptr.i++;
	c_p->function = *c_p->mem_ptr.c;
	return(1);
#endif
	return(1);
}
int f_intvarinc()
{
#ifdef	BIGOS
	uchar	index;
	c_p->mem_ptr.c++;
	index = *c_p->mem_ptr.c++;
	int_vars[index] += *(char *)c_p->mem_ptr.c++;
	c_p->function = *c_p->mem_ptr.c;
	return(1);
#endif
	return(1);
}



int f_user_1_var_evf()
{
/*#ifdef	BIGOS*/

	a_value = *(++c_p->mem_ptr.c);		/* get parameter in a_value */
	c_p->function = *++c_p->mem_ptr.c;
	user_1_var_evf_functions[current_channel]();
	return(1);
/*#endif*/
}
int f_user_2_var_evf()
{
	a_value = *(++c_p->mem_ptr.c);		/* get parameter in a_value */
	b_value = *(++c_p->mem_ptr.c);		/* get 2nd parameter in b_value */
	c_p->function = *++c_p->mem_ptr.c;
	user_2_var_evf_functions[current_channel]();
	return(1);

}


f_sig()
{
	a_value = *(++c_p->mem_ptr.c);		/* get parameter in a_value */
	c_p->function = *++c_p->mem_ptr.c;
//	signal_function();
	return(1);
}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\logo_geometry.h ===
/*

xbl.h

*/
#ifndef __xbl_h__
#define __xbl_h__

#include "d3d8types.h"

#define FVF_xbl D3DFVF_XYZ|D3DFVF_TEX1

struct xbl_vertex
{
	float x,y,z;
	float u0;
	float v0;
};


#define xbl_OO_POS_SCALE 0.009876f
#define xbl_POS_DELTA 161.715363f
#define xbl_OO_TEX_SCALE 0.000058f
#define xbl_TEX_DELTA 0.947661f


///////////////////////////////////////////////////////////////////////////////
const int vertex_count_xboxlogointerior_0 = 501;
short verts_xboxlogointerior_0C[] = 
{
		-12386,-26498,-20838, //	x,y,z
		-14730,-203, //	u,v
		-12260,-26498,-20920, //	x,y,z
		-14871,-127, //	u,v
		-12836,-29287,-20290, //	x,y,z
		-16049,-10475, //	u,v
		-12386,-26498,-20838, //	x,y,z
		-14730,-203, //	u,v
		-12845,-26498,-20558, //	x,y,z
		-14226,-477, //	u,v
		-7807,1871,-26421, //	x,y,z
		-10529,-261, //	u,v
		-12985,-26498,-20445, //	x,y,z
		-14057,-569, //	u,v
		-12845,-26498,-20558, //	x,y,z
		-14226,-477, //	u,v
		-13340,-29287,-19982, //	x,y,z
		-15380,-11167, //	u,v
		-12985,-26498,-20445, //	x,y,z
		-14057,-569, //	u,v
		-13493,-26498,-20080, //	x,y,z
		-13469,-888, //	u,v
		-9371,1871,-25156, //	x,y,z
		-8637,-1288, //	u,v
		-13640,-26498,-19948, //	x,y,z
		-13283,-989, //	u,v
		-13493,-26498,-20080, //	x,y,z
		-13469,-888, //	u,v
		-13898,-29287,-19581, //	x,y,z
		-14598,-11977, //	u,v
		-13640,-26498,-19948, //	x,y,z
		-13283,-989, //	u,v
		-14175,-26498,-19498, //	x,y,z
		-12626,-1346, //	u,v
		-11017,1871,-23682, //	x,y,z
		-6564,-2414, //	u,v
		-14323,-26498,-19360, //	x,y,z
		-12437,-1449, //	u,v
		-14175,-26498,-19498, //	x,y,z
		-12626,-1346, //	u,v
		-14485,-29287,-19087, //	x,y,z
		-13726,-12881, //	u,v
		-14323,-26498,-19360, //	x,y,z
		-12437,-1449, //	u,v
		-14859,-26498,-18900, //	x,y,z
		-11773,-1809, //	u,v
		-12666,1871,-22138, //	x,y,z
		-4448,-3563, //	u,v
		-14996,-26498,-18770, //	x,y,z
		-11596,-1905, //	u,v
		-14859,-26498,-18900, //	x,y,z
		-11773,-1809, //	u,v
		-15074,-29287,-18582, //	x,y,z
		-12844,-13793, //	u,v
		-14996,-26498,-18770, //	x,y,z
		-11596,-1905, //	u,v
		-15497,-26498,-18314, //	x,y,z
		-10961,-2250, //	u,v
		-14205,1871,-20682, //	x,y,z
		-2466,-4639, //	u,v
		-15612,-26498,-18208, //	x,y,z
		-10814,-2330, //	u,v
		-15624,-29287,-18082, //	x,y,z
		-12002,-14666, //	u,v
		-16030,-26498,-17821, //	x,y,z
		-10280,-2619, //	u,v
		-15493,1871,-19492, //	x,y,z
		-823,-5531, //	u,v
		-12678,-26498,-20424, //	x,y,z
		-14435,-7413, //	u,v
		-12793,-26498,-20278, //	x,y,z
		-14363,-7531, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15384,-8200, //	u,v
		-12678,-26498,-20424, //	x,y,z
		-14275,-451, //	u,v
		-12260,-26498,-20920, //	x,y,z
		-14871,-127, //	u,v
		-6396,1871,-27339, //	x,y,z
		-12110,596, //	u,v
		-13188,-26498,-19747, //	x,y,z
		-13507,-867, //	u,v
		-13297,-26498,-19592, //	x,y,z
		-13337,-960, //	u,v
		-13729,-29287,-19161, //	x,y,z
		-14462,-12118, //	u,v
		-13188,-26498,-19747, //	x,y,z
		-13507,-867, //	u,v
		-12793,-26498,-20278, //	x,y,z
		-14105,-543, //	u,v
		-7683,1871,-25712, //	x,y,z
		-10218,-430, //	u,v
		-13674,-26498,-19048, //	x,y,z
		-12745,-1281, //	u,v
		-13778,-26498,-18889, //	x,y,z
		-12576,-1373, //	u,v
		-14143,-29287,-18564, //	x,y,z
		-13675,-12933, //	u,v
		-13674,-26498,-19048, //	x,y,z
		-12745,-1281, //	u,v
		-8899,1871,-23976, //	x,y,z
		-8318,-1462, //	u,v
		-16113,-26498,-17741, //	x,y,z
		-10173,-2678, //	u,v
		-16030,-26498,-17821, //	x,y,z
		-10280,-2619, //	u,v
		-16083,-29287,-17657, //	x,y,z
		-11292,-15400, //	u,v
		-16113,-26498,-17741, //	x,y,z
		-10173,-2678, //	u,v
		-16411,-26498,-17468, //	x,y,z
		-9794,-2884, //	u,v
		-16411,1871,-18598, //	x,y,z
		373,-6181, //	u,v
		-16493,-26498,-17548, //	x,y,z
		-11372,-5060, //	u,v
		-16411,-26498,-17468, //	x,y,z
		-11290,-5173, //	u,v
		-16411,-29287,-17356, //	x,y,z
		-11563,-15959, //	u,v
		-16493,-26498,-17548, //	x,y,z
		-11372,-5060, //	u,v
		-16791,-26498,-17821, //	x,y,z
		-11663,-4659, //	u,v
		-17328,1871,-19492, //	x,y,z
		-1061,-5456, //	u,v
		-16906,-26498,-17927, //	x,y,z
		-11776,-4504, //	u,v
		-16738,-29287,-17657, //	x,y,z
		-11998,-15360, //	u,v
		-17325,-26498,-18314, //	x,y,z
		-12187,-3939, //	u,v
		-18616,1871,-20682, //	x,y,z
		-2446,-4556, //	u,v
		-17463,-26498,-18445, //	x,y,z
		-12323,-3751, //	u,v
		-17198,-29287,-18082, //	x,y,z
		-12611,-14516, //	u,v
		-17463,-26498,-18445, //	x,y,z
		-12323,-3751, //	u,v
		-17963,-26498,-18900, //	x,y,z
		-12810,-3080, //	u,v
		-20155,1871,-22138, //	x,y,z
		-4119,-3470, //	u,v
		-18110,-26498,-19038, //	x,y,z
		-12956,-2880, //	u,v
		-17963,-26498,-18900, //	x,y,z
		-12810,-3080, //	u,v
		-17747,-29287,-18582, //	x,y,z
		-13339,-13514, //	u,v
		-18110,-26498,-19038, //	x,y,z
		-12956,-2880, //	u,v
		-18647,-26498,-19498, //	x,y,z
		-13465,-2179, //	u,v
		-21805,1871,-23682, //	x,y,z
		-5903,-2311, //	u,v
		-18794,-26498,-19630, //	x,y,z
		-13608,-1983, //	u,v
		-18647,-26498,-19498, //	x,y,z
		-13465,-2179, //	u,v
		-18336,-29287,-19087, //	x,y,z
		-14100,-12467, //	u,v
		-18794,-26498,-19630, //	x,y,z
		-13608,-1983, //	u,v
		-19329,-26498,-20080, //	x,y,z
		-14112,-1289, //	u,v
		-23451,1871,-25156, //	x,y,z
		-7651,-1176, //	u,v
		-19469,-26498,-20193, //	x,y,z
		-14242,-1110, //	u,v
		-19329,-26498,-20080, //	x,y,z
		-14112,-1289, //	u,v
		-18924,-29287,-19581, //	x,y,z
		-14853,-11430, //	u,v
		-19469,-26498,-20193, //	x,y,z
		-14242,-1110, //	u,v
		-19977,-26498,-20558, //	x,y,z
		-14693,-489, //	u,v
		-25014,1871,-26421, //	x,y,z
		-9244,-141, //	u,v
		-20103,-26498,-20640, //	x,y,z
		-14801,-340, //	u,v
		-19977,-26498,-20558, //	x,y,z
		-14693,-489, //	u,v
		-19482,-29287,-19982, //	x,y,z
		-15526,-10503, //	u,v
		-20103,-26498,-20640, //	x,y,z
		-14801,-340, //	u,v
		-20562,-26498,-20920, //	x,y,z
		-15186,189, //	u,v
		-26426,1871,-27339, //	x,y,z
		-10572,720, //	u,v
		-20447,-26498,-20775, //	x,y,z
		-15056,9, //	u,v
		-20562,-26498,-20920, //	x,y,z
		-15186,189, //	u,v
		-19986,-29287,-20290, //	x,y,z
		-16101,-9712, //	u,v
		-20447,-26498,-20775, //	x,y,z
		-15056,9, //	u,v
		-20028,-26498,-20278, //	x,y,z
		-14596,-623, //	u,v
		-25138,1871,-25712, //	x,y,z
		-8970,-319, //	u,v
		-19919,-26498,-20123, //	x,y,z
		-14464,-804, //	u,v
		-20028,-26498,-20278, //	x,y,z
		-14596,-623, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15414,-10658, //	u,v
		-19919,-26498,-20123, //	x,y,z
		-14464,-804, //	u,v
		-19524,-26498,-19592, //	x,y,z
		-14002,-1440, //	u,v
		-23923,1871,-23976, //	x,y,z
		-7358,-1366, //	u,v
		-19421,-26498,-19433, //	x,y,z
		-13872,-1620, //	u,v
		-19524,-26498,-19592, //	x,y,z
		-14002,-1440, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-14724,-11607, //	u,v
		-19421,-26498,-19433, //	x,y,z
		-13872,-1620, //	u,v
		-19044,-26498,-18889, //	x,y,z
		-13414,-2250, //	u,v
		-22764,1871,-22195, //	x,y,z
		-5759,-2404, //	u,v
		-14136,-26498,-18352, //	x,y,z
		-12002,-1685, //	u,v
		-14234,-26498,-18195, //	x,y,z
		-11839,-1773, //	u,v
		-14537,-29287,-17974, //	x,y,z
		-12912,-13723, //	u,v
		-14136,-26498,-18352, //	x,y,z
		-12002,-1685, //	u,v
		-10058,1871,-22195, //	x,y,z
		-6435,-2484, //	u,v
		-18945,-26498,-18731, //	x,y,z
		-13288,-2424, //	u,v
		-19044,-26498,-18889, //	x,y,z
		-13414,-2250, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-14041,-12548, //	u,v
		-18945,-26498,-18731, //	x,y,z
		-13288,-2424, //	u,v
		-18587,-26498,-18195, //	x,y,z
		-12843,-3035, //	u,v
		-21662,1871,-20439, //	x,y,z
		-4208,-3412, //	u,v
		-14568,-26498,-17685, //	x,y,z
		-11298,-2067, //	u,v
		-14660,-26498,-17536, //	x,y,z
		-11144,-2150, //	u,v
		-14903,-29287,-17415, //	x,y,z
		-12195,-14466, //	u,v
		-14568,-26498,-17685, //	x,y,z
		-11298,-2067, //	u,v
		-14234,-26498,-18195, //	x,y,z
		-11839,-1773, //	u,v
		-11160,1871,-20439, //	x,y,z
		-4608,-3476, //	u,v
		-18495,-26498,-18045, //	x,y,z
		-12724,-3199, //	u,v
		-18587,-26498,-18195, //	x,y,z
		-12843,-3035, //	u,v
		-18285,-29287,-17974, //	x,y,z
		-13377,-13461, //	u,v
		-18495,-26498,-18045, //	x,y,z
		-12724,-3199, //	u,v
		-18162,-26498,-17536, //	x,y,z
		-12306,-3774, //	u,v
		-20635,1871,-18772, //	x,y,z
		-2747,-4361, //	u,v
		-14957,-26498,-17076, //	x,y,z
		-10660,-2413, //	u,v
		-15038,-26498,-16941, //	x,y,z
		-10522,-2488, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-11551,-15132, //	u,v
		-14957,-26498,-17076, //	x,y,z
		-10660,-2413, //	u,v
		-14660,-26498,-17536, //	x,y,z
		-11144,-2150, //	u,v
		-12187,1871,-18772, //	x,y,z
		-2889,-4409, //	u,v
		-18080,-26498,-17401, //	x,y,z
		-12200,-3921, //	u,v
		-18162,-26498,-17536, //	x,y,z
		-12306,-3774, //	u,v
		-17919,-29287,-17415, //	x,y,z
		-12753,-14320, //	u,v
		-18080,-26498,-17401, //	x,y,z
		-12200,-3921, //	u,v
		-17783,-26498,-16941, //	x,y,z
		-11825,-4437, //	u,v
		-19722,1871,-17265, //	x,y,z
		-1436,-5212, //	u,v
		-15255,-26498,-16549, //	x,y,z
		-10137,-2697, //	u,v
		-15323,-26498,-16435, //	x,y,z
		-10020,-2761, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-11039,-15662, //	u,v
		-15255,-26498,-16549, //	x,y,z
		-10137,-2697, //	u,v
		-15038,-26498,-16941, //	x,y,z
		-10522,-2488, //	u,v
		-13099,1871,-17265, //	x,y,z
		-1346,-5247, //	u,v
		-15011,-26498,-16109, //	x,y,z
		-9545,-6003, //	u,v
		-14916,-26498,-16014, //	x,y,z
		-9611,-5890, //	u,v
		-15124,-29287,-16122, //	x,y,z
		-14320,-16076, //	u,v
		-15011,-26498,-16109, //	x,y,z
		-9545,-6003, //	u,v
		-15323,-26498,-16435, //	x,y,z
		-9323,-6380, //	u,v
		-13863,1871,-15983, //	x,y,z
		-2130,429, //	u,v
		-14561,-26498,-15655, //	x,y,z
		-9861,-5466, //	u,v
		-14464,-26498,-15550, //	x,y,z
		-9931,-5347, //	u,v
		-14734,-29287,-15727, //	x,y,z
		-14665,-15944, //	u,v
		-14561,-26498,-15655, //	x,y,z
		-9861,-5466, //	u,v
		-12806,1871,-14918, //	x,y,z
		-3592,442, //	u,v
		-14109,-26498,-15168, //	x,y,z
		-10187,-4912, //	u,v
		-14011,-26498,-15056, //	x,y,z
		-10259,-4790, //	u,v
		-14344,-29287,-15308, //	x,y,z
		-15019,-15808, //	u,v
		-14109,-26498,-15168, //	x,y,z
		-10187,-4912, //	u,v
		-11713,1871,-13743, //	x,y,z
		-5143,455, //	u,v
		-13667,-26498,-14666, //	x,y,z
		-10512,-4360, //	u,v
		-13573,-26498,-14552, //	x,y,z
		-10584,-4238, //	u,v
		-13967,-29286,-14880, //	x,y,z
		-15369,-15673, //	u,v
		-13667,-26498,-14666, //	x,y,z
		-10512,-4360, //	u,v
		-10620,1871,-12494, //	x,y,z
		-6734,469, //	u,v
		-13252,-26498,-14167, //	x,y,z
		-10826,-3827, //	u,v
		-13164,-26498,-14054, //	x,y,z
		-10894,-3711, //	u,v
		-13614,-29286,-14456, //	x,y,z
		-15704,-15545, //	u,v
		-13252,-26498,-14167, //	x,y,z
		-10826,-3827, //	u,v
		-9563,1871,-11217, //	x,y,z
		-8310,483, //	u,v
		-12878,-26498,-13687, //	x,y,z
		-11117,-3334, //	u,v
		-12799,-26498,-13579, //	x,y,z
		-11180,-3227, //	u,v
		-13300,-29286,-14054, //	x,y,z
		-16012,-15427, //	u,v
		-12878,-26498,-13687, //	x,y,z
		-11117,-3334, //	u,v
		-8577,1871,-9956, //	x,y,z
		-9818,496, //	u,v
		-12558,-26498,-13245, //	x,y,z
		-11374,-2898, //	u,v
		-12492,-26498,-13147, //	x,y,z
		-11429,-2804, //	u,v
		-13036,-29286,-13686, //	x,y,z
		-16280,-15324, //	u,v
		-12558,-26498,-13245, //	x,y,z
		-11374,-2898, //	u,v
		-7696,1871,-8755, //	x,y,z
		-11204,508, //	u,v
		-12823,-26498,-13403, //	x,y,z
		-11217,-3163, //	u,v
		-12914,-26498,-13477, //	x,y,z
		-11158,-3263, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-15988,-15436, //	u,v
		-12823,-26498,-13403, //	x,y,z
		-11217,-3163, //	u,v
		-12492,-26498,-13147, //	x,y,z
		-11429,-2804, //	u,v
		-6957,1872,-7660, //	x,y,z
		-12415,519, //	u,v
		-13334,-26498,-13761, //	x,y,z
		-10901,-3700, //	u,v
		-13449,-26498,-13845, //	x,y,z
		-10829,-3822, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-15633,-15572, //	u,v
		-13334,-26498,-13761, //	x,y,z
		-10901,-3700, //	u,v
		-12914,-26498,-13477, //	x,y,z
		-11158,-3263, //	u,v
		-7974,1871,-8497, //	x,y,z
		-11109,508, //	u,v
		-13927,-26498,-14137, //	x,y,z
		-10545,-4304, //	u,v
		-14058,-26498,-14223, //	x,y,z
		-10466,-4439, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-15240,-15723, //	u,v
		-13927,-26498,-14137, //	x,y,z
		-10545,-4304, //	u,v
		-13449,-26498,-13845, //	x,y,z
		-10829,-3822, //	u,v
		-9266,1871,-9427, //	x,y,z
		-9521,494, //	u,v
		-14561,-26498,-14505, //	x,y,z
		-10174,-4934, //	u,v
		-14699,-26498,-14588, //	x,y,z
		-10092,-5073, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-14836,-15878, //	u,v
		-14561,-26498,-14505, //	x,y,z
		-10174,-4934, //	u,v
		-14058,-26498,-14223, //	x,y,z
		-10466,-4439, //	u,v
		-10735,1871,-10384, //	x,y,z
		-7769,478, //	u,v
		-15196,-26498,-14840, //	x,y,z
		-9811,-5550, //	u,v
		-15333,-26498,-14913, //	x,y,z
		-9733,-5684, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-14447,-16027, //	u,v
		-15196,-26498,-14840, //	x,y,z
		-9811,-5550, //	u,v
		-14699,-26498,-14588, //	x,y,z
		-10092,-5073, //	u,v
		-12282,1871,-11308, //	x,y,z
		-5970,463, //	u,v
		-15790,-26498,-15116, //	x,y,z
		-9481,-6110, //	u,v
		-15917,-26498,-15176, //	x,y,z
		-9411,-6229, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-14100,-16161, //	u,v
		-15790,-26498,-15116, //	x,y,z
		-9481,-6110, //	u,v
		-15333,-26498,-14913, //	x,y,z
		-9733,-5684, //	u,v
		-13809,1871,-12133, //	x,y,z
		-4240,447, //	u,v
		-16304,-26498,-15310, //	x,y,z
		-9209,-6572, //	u,v
		-16411,-26498,-15349, //	x,y,z
		-9153,-6668, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-13820,-16268, //	u,v
		-16304,-26498,-15310, //	x,y,z
		-9209,-6572, //	u,v
		-15917,-26498,-15176, //	x,y,z
		-9411,-6229, //	u,v
		-15218,1871,-12796, //	x,y,z
		-2697,434, //	u,v
		-16798,-26498,-15215, //	x,y,z
		-12696,-8315, //	u,v
		-16904,-26498,-15176, //	x,y,z
		-12520,-8145, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-5988,-12294, //	u,v
		-16798,-26498,-15215, //	x,y,z
		-12696,-8315, //	u,v
		-16411,-26498,-15349, //	x,y,z
		-13329,-8926, //	u,v
		-16411,1871,-13235, //	x,y,z
		-15802,-6256, //	u,v
		-17361,-26498,-14973, //	x,y,z
		-11741,-7392, //	u,v
		-17486,-26498,-14913, //	x,y,z
		-11523,-7182, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-5179,-11513, //	u,v
		-17361,-26498,-14973, //	x,y,z
		-11741,-7392, //	u,v
		-16904,-26498,-15176, //	x,y,z
		-12520,-8145, //	u,v
		-17601,1871,-12796, //	x,y,z
		-15029,-5510, //	u,v
		-17981,-26498,-14661, //	x,y,z
		-10653,-6342, //	u,v
		-18117,-26498,-14588, //	x,y,z
		-10410,-6108, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-4277,-10641, //	u,v
		-17981,-26498,-14661, //	x,y,z
		-10653,-6342, //	u,v
		-17486,-26498,-14913, //	x,y,z
		-11523,-7182, //	u,v
		-19006,1871,-12133, //	x,y,z
		-14074,-4587, //	u,v
		-18619,-26498,-14306, //	x,y,z
		-9508,-5236, //	u,v
		-18757,-26498,-14223, //	x,y,z
		-9256,-4993, //	u,v
		-18431,-29286,-14600, //	x,y,z
		-3341,-9737, //	u,v
		-18619,-26498,-14306, //	x,y,z
		-9508,-5236, //	u,v
		-18117,-26498,-14588, //	x,y,z
		-10410,-6108, //	u,v
		-20528,1871,-11308, //	x,y,z
		-13007,-3556, //	u,v
		-19234,-26498,-13930, //	x,y,z
		-8379,-4146, //	u,v
		-19366,-26498,-13845, //	x,y,z
		-8133,-3909, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-2431,-8859, //	u,v
		-19234,-26498,-13930, //	x,y,z
		-8379,-4146, //	u,v
		-22072,1871,-10384, //	x,y,z
		-11898,-2486, //	u,v
		-19787,-26498,-13561, //	x,y,z
		-7339,-3142, //	u,v
		-19903,-26498,-13477, //	x,y,z
		-7117,-2927, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-1608,-8064, //	u,v
		-19787,-26498,-13561, //	x,y,z
		-7339,-3142, //	u,v
		-19366,-26498,-13845, //	x,y,z
		-8133,-3909, //	u,v
		-23540,1871,-9427, //	x,y,z
		-10820,-1444, //	u,v
		-20237,-26498,-13222, //	x,y,z
		-6464,-2297, //	u,v
		-20329,-26498,-13147, //	x,y,z
		-6281,-2120, //	u,v
		-19785,-29286,-13686, //	x,y,z
		-931,-7409, //	u,v
		-20237,-26498,-13222, //	x,y,z
		-6464,-2297, //	u,v
		-19903,-26498,-13477, //	x,y,z
		-7117,-2927, //	u,v
		-24837,1871,-8497, //	x,y,z
		-9843,-501, //	u,v
		-20093,-26498,-13478, //	x,y,z
		-6857,-2676, //	u,v
		-20028,-26498,-13574, //	x,y,z
		-7020,-2834, //	u,v
		-19526,-29286,-14049, //	x,y,z
		-1528,-7987, //	u,v
		-20093,-26498,-13478, //	x,y,z
		-6857,-2676, //	u,v
		-20329,-26498,-13147, //	x,y,z
		-6281,-2120, //	u,v
		-25865,1872,-7660, //	x,y,z
		-9038,276, //	u,v
		-19743,-26498,-13940, //	x,y,z
		-7689,-3480, //	u,v
		-19665,-26498,-14047, //	x,y,z
		-7878,-3662, //	u,v
		-19213,-29286,-14450, //	x,y,z
		-2222,-8657, //	u,v
		-19743,-26498,-13940, //	x,y,z
		-7689,-3480, //	u,v
		-20028,-26498,-13574, //	x,y,z
		-7020,-2834, //	u,v
		-25138,1871,-8742, //	x,y,z
		-9755,-415, //	u,v
		-19344,-26498,-14432, //	x,y,z
		-8612,-4371, //	u,v
		-19256,-26498,-14545, //	x,y,z
		-8819,-4571, //	u,v
		-18861,-29286,-14874, //	x,y,z
		-2983,-9392, //	u,v
		-19344,-26498,-14432, //	x,y,z
		-8612,-4371, //	u,v
		-19665,-26498,-14047, //	x,y,z
		-7878,-3662, //	u,v
		-24262,1871,-9938, //	x,y,z
		-10585,-1218, //	u,v
		-18911,-26498,-14937, //	x,y,z
		-9591,-5316, //	u,v
		-18816,-26498,-15051, //	x,y,z
		-9808,-5527, //	u,v
		-18482,-29287,-15304, //	x,y,z
		-3783,-10165, //	u,v
		-18911,-26498,-14937, //	x,y,z
		-9591,-5316, //	u,v
		-19256,-26498,-14545, //	x,y,z
		-8819,-4571, //	u,v
		-23275,1871,-11200, //	x,y,z
		-11496,-2097, //	u,v
		-18459,-26498,-15434, //	x,y,z
		-10590,-6281, //	u,v
		-18361,-26498,-15547, //	x,y,z
		-10810,-6494, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-4594,-10948, //	u,v
		-18459,-26498,-15434, //	x,y,z
		-10590,-6281, //	u,v
		-18816,-26498,-15051, //	x,y,z
		-9808,-5527, //	u,v
		-22213,1871,-12481, //	x,y,z
		-12452,-3021, //	u,v
		-18004,-26498,-15907, //	x,y,z
		-11574,-7232, //	u,v
		-17906,-26498,-16013, //	x,y,z
		-11789,-7440, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-5386,-11713, //	u,v
		-18004,-26498,-15907, //	x,y,z
		-11574,-7232, //	u,v
		-18361,-26498,-15547, //	x,y,z
		-10810,-6494, //	u,v
		-21115,1871,-13736, //	x,y,z
		-13420,-3956, //	u,v
		-17589,-26498,-16339, //	x,y,z
		-12472,-8099, //	u,v
		-17495,-26498,-16435, //	x,y,z
		-12675,-8295, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-6095,-12397, //	u,v
		-17906,-26498,-16013, //	x,y,z
		-11789,-7440, //	u,v
		-20018,1871,-14916, //	x,y,z
		-14366,-4869, //	u,v
		-17715,-26498,-16826, //	x,y,z
		-11734,-4561, //	u,v
		-17783,-26498,-16941, //	x,y,z
		-11825,-4437, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-12193,-15091, //	u,v
		-17715,-26498,-16826, //	x,y,z
		-11734,-4561, //	u,v
		-17495,-26498,-16435, //	x,y,z
		-11433,-4976, //	u,v
		-18959,1871,-15983, //	x,y,z
		-329,-5931, //	u,v
		-6396,1871,-27339, //	x,y,z
		-12110,596, //	u,v
		-7807,1871,-26421, //	x,y,z
		-10529,-261, //	u,v
		-13340,-29287,-19982, //	x,y,z
		-15380,-11167, //	u,v
		-12836,-29287,-20290, //	x,y,z
		-16049,-10475, //	u,v
		-7807,1871,-26421, //	x,y,z
		-10529,-261, //	u,v
		-9371,1871,-25156, //	x,y,z
		-8637,-1288, //	u,v
		-13898,-29287,-19581, //	x,y,z
		-14598,-11977, //	u,v
		-13340,-29287,-19982, //	x,y,z
		-15380,-11167, //	u,v
		-9371,1871,-25156, //	x,y,z
		-8637,-1288, //	u,v
		-11017,1871,-23682, //	x,y,z
		-6564,-2414, //	u,v
		-14485,-29287,-19087, //	x,y,z
		-13726,-12881, //	u,v
		-13898,-29287,-19581, //	x,y,z
		-14598,-11977, //	u,v
		-11017,1871,-23682, //	x,y,z
		-6564,-2414, //	u,v
		-12666,1871,-22138, //	x,y,z
		-4448,-3563, //	u,v
		-15074,-29287,-18582, //	x,y,z
		-12844,-13793, //	u,v
		-14205,1871,-20682, //	x,y,z
		-2466,-4639, //	u,v
		-15074,-29287,-18582, //	x,y,z
		-12844,-13793, //	u,v
		-16083,-29287,-17657, //	x,y,z
		-11292,-15400, //	u,v
		-7683,1871,-25712, //	x,y,z
		-3982,-732, //	u,v
		-6396,1871,-27339, //	x,y,z
		-12110,596, //	u,v
		-7683,1871,-25712, //	x,y,z
		-10218,-430, //	u,v
		-12678,-26498,-20424, //	x,y,z
		-14275,-451, //	u,v
		-12836,-29287,-20290, //	x,y,z
		-16049,-10475, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15256,-11296, //	u,v
		-7683,1871,-25712, //	x,y,z
		-10218,-430, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15256,-11296, //	u,v
		-13729,-29287,-19161, //	x,y,z
		-14462,-12118, //	u,v
		-8899,1871,-23976, //	x,y,z
		-8318,-1462, //	u,v
		-14143,-29287,-18564, //	x,y,z
		-13675,-12933, //	u,v
		-15493,1871,-19492, //	x,y,z
		-823,-5531, //	u,v
		-16411,1871,-18598, //	x,y,z
		373,-6181, //	u,v
		-16411,-29287,-17356, //	x,y,z
		-10789,-15922, //	u,v
		-16411,1871,-18598, //	x,y,z
		-50,-6112, //	u,v
		-17328,1871,-19492, //	x,y,z
		-1061,-5456, //	u,v
		-16411,-29287,-17356, //	x,y,z
		-11563,-15959, //	u,v
		-20155,1871,-22138, //	x,y,z
		-4119,-3470, //	u,v
		-17747,-29287,-18582, //	x,y,z
		-13339,-13514, //	u,v
		-17198,-29287,-18082, //	x,y,z
		-12611,-14516, //	u,v
		-21805,1871,-23682, //	x,y,z
		-5903,-2311, //	u,v
		-18336,-29287,-19087, //	x,y,z
		-14100,-12467, //	u,v
		-17747,-29287,-18582, //	x,y,z
		-13339,-13514, //	u,v
		-21805,1871,-23682, //	x,y,z
		-5903,-2311, //	u,v
		-23451,1871,-25156, //	x,y,z
		-7651,-1176, //	u,v
		-18924,-29287,-19581, //	x,y,z
		-14853,-11430, //	u,v
		-23451,1871,-25156, //	x,y,z
		-7651,-1176, //	u,v
		-25014,1871,-26421, //	x,y,z
		-9244,-141, //	u,v
		-19482,-29287,-19982, //	x,y,z
		-15526,-10503, //	u,v
		-18924,-29287,-19581, //	x,y,z
		-14853,-11430, //	u,v
		-25014,1871,-26421, //	x,y,z
		-9244,-141, //	u,v
		-26426,1871,-27339, //	x,y,z
		-10572,720, //	u,v
		-19986,-29287,-20290, //	x,y,z
		-16101,-9712, //	u,v
		-19482,-29287,-19982, //	x,y,z
		-15526,-10503, //	u,v
		-26426,1871,-27339, //	x,y,z
		-10572,720, //	u,v
		-25138,1871,-25712, //	x,y,z
		-8970,-319, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15414,-10658, //	u,v
		-19986,-29287,-20290, //	x,y,z
		-16101,-9712, //	u,v
		-25138,1871,-25712, //	x,y,z
		-8970,-319, //	u,v
		-23923,1871,-23976, //	x,y,z
		-7358,-1366, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-14724,-11607, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15414,-10658, //	u,v
		-23923,1871,-23976, //	x,y,z
		-7358,-1366, //	u,v
		-22764,1871,-22195, //	x,y,z
		-5759,-2404, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-14041,-12548, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-14724,-11607, //	u,v
		-11160,1871,-20439, //	x,y,z
		-4608,-3476, //	u,v
		-10058,1871,-22195, //	x,y,z
		-6435,-2484, //	u,v
		-14537,-29287,-17974, //	x,y,z
		-12912,-13723, //	u,v
		-22764,1871,-22195, //	x,y,z
		-5759,-2404, //	u,v
		-21662,1871,-20439, //	x,y,z
		-4208,-3412, //	u,v
		-18285,-29287,-17974, //	x,y,z
		-13377,-13461, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-14041,-12548, //	u,v
		-12187,1871,-18772, //	x,y,z
		-2889,-4409, //	u,v
		-14903,-29287,-17415, //	x,y,z
		-12195,-14466, //	u,v
		-20635,1871,-18772, //	x,y,z
		-2747,-4361, //	u,v
		-17919,-29287,-17415, //	x,y,z
		-12753,-14320, //	u,v
		-13099,1871,-17265, //	x,y,z
		-1346,-5247, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-11551,-15132, //	u,v
		-19722,1871,-17265, //	x,y,z
		-1436,-5212, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-12193,-15091, //	u,v
		-13863,1871,-15983, //	x,y,z
		-44,-5954, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-11551,-15132, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-11039,-15662, //	u,v
		-13863,1871,-15983, //	x,y,z
		-2130,429, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-14012,-16194, //	u,v
		-15124,-29287,-16122, //	x,y,z
		-14320,-16076, //	u,v
		-12806,1871,-14918, //	x,y,z
		-3592,442, //	u,v
		-14734,-29287,-15727, //	x,y,z
		-14665,-15944, //	u,v
		-11713,1871,-13743, //	x,y,z
		-5143,455, //	u,v
		-14344,-29287,-15308, //	x,y,z
		-15019,-15808, //	u,v
		-10620,1871,-12494, //	x,y,z
		-6734,469, //	u,v
		-13967,-29286,-14880, //	x,y,z
		-15369,-15673, //	u,v
		-9563,1871,-11217, //	x,y,z
		-8310,483, //	u,v
		-13614,-29286,-14456, //	x,y,z
		-15704,-15545, //	u,v
		-8577,1871,-9956, //	x,y,z
		-9818,496, //	u,v
		-13300,-29286,-14054, //	x,y,z
		-16012,-15427, //	u,v
		-6957,1872,-7660, //	x,y,z
		-12415,519, //	u,v
		-7696,1871,-8755, //	x,y,z
		-11204,508, //	u,v
		-13036,-29286,-13686, //	x,y,z
		-16280,-15324, //	u,v
		-7974,1871,-8497, //	x,y,z
		-11109,508, //	u,v
		-6957,1872,-7660, //	x,y,z
		-12415,519, //	u,v
		-13036,-29286,-13686, //	x,y,z
		-16280,-15324, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-15988,-15436, //	u,v
		-9266,1871,-9427, //	x,y,z
		-9521,494, //	u,v
		-7974,1871,-8497, //	x,y,z
		-11109,508, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-15988,-15436, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-15633,-15572, //	u,v
		-10735,1871,-10384, //	x,y,z
		-7769,478, //	u,v
		-9266,1871,-9427, //	x,y,z
		-9521,494, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-15633,-15572, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-15240,-15723, //	u,v
		-12282,1871,-11308, //	x,y,z
		-5970,463, //	u,v
		-10735,1871,-10384, //	x,y,z
		-7769,478, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-15240,-15723, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-14836,-15878, //	u,v
		-13809,1871,-12133, //	x,y,z
		-4240,447, //	u,v
		-12282,1871,-11308, //	x,y,z
		-5970,463, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-14836,-15878, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-14447,-16027, //	u,v
		-15218,1871,-12796, //	x,y,z
		-2697,434, //	u,v
		-13809,1871,-12133, //	x,y,z
		-4240,447, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-14447,-16027, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-14100,-16161, //	u,v
		-16411,1871,-13235, //	x,y,z
		-1456,423, //	u,v
		-15218,1871,-12796, //	x,y,z
		-2697,434, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-14100,-16161, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-13820,-16268, //	u,v
		-17601,1871,-12796, //	x,y,z
		-15029,-5510, //	u,v
		-16411,1871,-13235, //	x,y,z
		-15802,-6256, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-6644,-12927, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-5988,-12294, //	u,v
		-19006,1871,-12133, //	x,y,z
		-14074,-4587, //	u,v
		-17601,1871,-12796, //	x,y,z
		-15029,-5510, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-5988,-12294, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-5179,-11513, //	u,v
		-20528,1871,-11308, //	x,y,z
		-13007,-3556, //	u,v
		-19006,1871,-12133, //	x,y,z
		-14074,-4587, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-5179,-11513, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-4277,-10641, //	u,v
		-20528,1871,-11308, //	x,y,z
		-13007,-3556, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-4277,-10641, //	u,v
		-18431,-29286,-14600, //	x,y,z
		-3341,-9737, //	u,v
		-23540,1871,-9427, //	x,y,z
		-10820,-1444, //	u,v
		-22072,1871,-10384, //	x,y,z
		-11898,-2486, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-2431,-8859, //	u,v
		-24837,1871,-8497, //	x,y,z
		-9843,-501, //	u,v
		-23540,1871,-9427, //	x,y,z
		-10820,-1444, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-2431,-8859, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-1608,-8064, //	u,v
		-25865,1872,-7660, //	x,y,z
		-9038,276, //	u,v
		-24837,1871,-8497, //	x,y,z
		-9843,-501, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-1608,-8064, //	u,v
		-19785,-29286,-13686, //	x,y,z
		-931,-7409, //	u,v
		-25138,1871,-8742, //	x,y,z
		-9755,-415, //	u,v
		-25865,1872,-7660, //	x,y,z
		-9038,276, //	u,v
		-19785,-29286,-13686, //	x,y,z
		-931,-7409, //	u,v
		-19526,-29286,-14049, //	x,y,z
		-1528,-7987, //	u,v
		-24262,1871,-9938, //	x,y,z
		-10585,-1218, //	u,v
		-25138,1871,-8742, //	x,y,z
		-9755,-415, //	u,v
		-19526,-29286,-14049, //	x,y,z
		-1528,-7987, //	u,v
		-19213,-29286,-14450, //	x,y,z
		-2222,-8657, //	u,v
		-23275,1871,-11200, //	x,y,z
		-11496,-2097, //	u,v
		-24262,1871,-9938, //	x,y,z
		-10585,-1218, //	u,v
		-19213,-29286,-14450, //	x,y,z
		-2222,-8657, //	u,v
		-18861,-29286,-14874, //	x,y,z
		-2983,-9392, //	u,v
		-22213,1871,-12481, //	x,y,z
		-12452,-3021, //	u,v
		-23275,1871,-11200, //	x,y,z
		-11496,-2097, //	u,v
		-18861,-29286,-14874, //	x,y,z
		-2983,-9392, //	u,v
		-18482,-29287,-15304, //	x,y,z
		-3783,-10165, //	u,v
		-21115,1871,-13736, //	x,y,z
		-13420,-3956, //	u,v
		-22213,1871,-12481, //	x,y,z
		-12452,-3021, //	u,v
		-18482,-29287,-15304, //	x,y,z
		-3783,-10165, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-4594,-10948, //	u,v
		-20018,1871,-14916, //	x,y,z
		-14366,-4869, //	u,v
		-21115,1871,-13736, //	x,y,z
		-13420,-3956, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-4594,-10948, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-5386,-11713, //	u,v
		-18959,1871,-15983, //	x,y,z
		-15257,-5729, //	u,v
		-18959,1871,-15983, //	x,y,z
		-329,-5931, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-11744,-15710, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-12193,-15091, //	u,v
};
const int index_count_xboxlogointerior_0 = 1008;
char indices_xboxlogointerior_0C[] = 
{
	2,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-3,2,
	3,-1,-2,
	6,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-9,8,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-3,2,
	3,-1,-2,
	5,-3,2,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-71,70,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-9,8,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	4,-8,7,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-9,8,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
	4,-1,-3,
	7,-1,-1,
	5,-1,-1,
	126,-2,-61,126,1,64,126,-2,-65,
	0,126,1,65,1,
	126,-2,-62,126,1,63,126,-2,-64,
	0,126,1,64,1,
	126,-2,-61,126,1,62,126,-2,-63,
	0,126,1,63,1,
	126,-2,-60,126,1,61,126,-2,-62,
	0,126,1,62,1,
	126,-2,-59,126,1,60,126,-2,-61,
	0,126,1,61,1,
	126,-2,-58,126,1,59,126,-2,-60,
	0,126,1,60,1,
	126,-2,-57,126,1,58,126,-2,-59,
	0,126,1,59,1,
	126,-2,-56,126,1,57,126,-2,-58,
	0,126,1,58,-4,
	126,-2,-50,126,1,53,126,-2,-54,
	0,126,1,54,2,
	126,-2,-52,3,-4,
	0,4,126,1,50,
	126,-2,-53,1,1,
	0,-1,4,
	-1,126,1,50,126,-2,-52,
	0,126,1,52,126,-2,-51,
	4,126,1,48,126,-2,-49,
	126,1,52,-1,-1,
	126,-2,-46,126,1,49,126,-2,-50,
	0,126,1,50,1,
	126,-2,-47,9,-10,
	0,10,126,1,39,
	126,-2,-45,126,1,46,126,-2,-47,
	0,126,1,47,1,
	126,-2,-44,71,-72,
	0,72,126,0,-26,
	126,-2,-51,1,7,
	0,-7,126,1,51,
	126,-2,-41,126,1,42,126,-2,-43,
	0,126,1,43,1,
	126,-2,-40,126,1,41,126,-2,-42,
	0,126,1,42,-14,
	126,-2,-24,126,1,39,126,-2,-40,
	0,126,1,40,1,
	126,-2,-37,3,-4,
	0,4,126,1,35,
	126,-2,-38,1,1,
	0,-1,4,
	-1,3,-5,
	0,5,-4,
	1,1,1,
	0,-1,126,1,34,
	126,-2,-30,126,1,31,126,-2,-32,
	0,126,1,32,1,
	126,-2,-29,126,1,27,126,-2,-28,
	0,126,1,28,3,
	126,-2,-27,126,1,28,126,-2,-29,
	0,126,1,29,1,
	126,-2,-26,126,1,27,126,-2,-28,
	0,126,1,28,1,
	126,-2,-25,126,1,26,126,-2,-27,
	0,126,1,27,-4,
	126,-2,-19,126,1,24,126,-2,-25,
	0,126,1,25,1,
	126,-2,-22,126,1,23,126,-2,-24,
	0,126,1,24,1,
	126,-2,-21,126,1,22,126,-2,-23,
	0,126,1,23,1,
	126,-2,-20,126,1,21,126,-2,-22,
	0,126,1,22,1,
	126,-2,-19,126,1,20,126,-2,-21,
	0,126,1,21,1,
	126,-2,-18,126,1,19,126,-2,-20,
	0,126,1,20,1,
	126,-2,-17,126,1,18,126,-2,-19,
	0,126,1,19,1,
	126,-2,-16,126,1,17,126,-2,-18,
	0,126,1,18,1,
	126,-2,-15,126,1,16,126,-2,-17,
	0,126,1,17,1,
	126,-2,-14,126,1,15,126,-2,-16,
	0,126,1,16,1,
	126,-2,-13,126,1,14,126,-2,-15,
	0,126,1,15,1,
	126,-2,-83,1,69,
	0,-69,126,1,83,
	126,-2,-11,126,1,12,126,-2,-13,
	0,126,1,13,1,
	126,-2,-10,126,1,11,126,-2,-12,
	0,126,1,12,1,
	126,-2,-9,126,1,10,126,-2,-11,
	0,126,1,11,-7,
	126,-1,0,126,1,2,126,-2,-3,
	0,126,1,3,6,
	126,-2,-5,126,1,1,126,-2,-2,
	0,126,1,2,5,
	126,-2,-3,126,1,4,126,-2,-5,
	0,126,1,5,-5,
	126,-1,4,126,1,2,126,-2,-3,
	0,126,1,3,-4,
	126,-1,5,126,0,-4,126,-1,3,
	0,126,0,-3,4,
	126,-1,3,126,0,-6,126,-1,5,
	0,126,0,-5,4,
	126,-1,5,126,0,-4,126,-1,3,
	0,126,0,-3,-4,
	126,-1,11,126,0,-6,126,-1,5,
	0,126,0,-5,-4,
	126,-1,13,126,0,-8,126,-1,7,
	0,126,0,-7,1,
	126,-1,10,9,-10,
	0,10,126,0,-18,
	126,-1,12,126,0,-11,126,-1,10,
	0,126,0,-10,1,
	126,-1,13,8,-9,
	0,9,126,0,-20,
	126,-1,6,1,7,
	0,-7,126,0,-6,
	126,-1,16,8,-9,
	0,9,126,0,-23,
	126,-1,10,1,6,
	0,-6,126,0,-10,
	126,-1,19,8,-9,
	0,9,126,0,-26,
	126,-1,13,1,6,
	0,-6,126,0,-13,
	126,-1,22,8,-9,
	0,9,126,0,-29,
	126,-1,16,1,6,
	0,-6,126,0,-16,
	126,-1,25,8,-9,
	0,9,126,0,-32,
	126,-1,19,1,6,
	0,-6,126,0,-19,
	126,-1,28,126,0,-27,126,-1,26,
	0,126,0,-26,1,
	126,-1,21,1,6,
	0,-6,126,0,-21,
	126,-1,30,126,0,-29,126,-1,28,
	0,126,0,-28,1,
	126,-1,31,126,0,-30,126,-1,29,
	0,126,0,-29,1,
	126,-1,32,126,0,-31,126,-1,30,
	0,126,0,-30,1,
	126,-1,33,126,0,-32,126,-1,31,
	0,126,0,-31,1,
	126,-1,34,126,0,-33,126,-1,32,
	0,126,0,-32,1,
	126,-1,35,126,0,-34,126,-1,33,
	0,126,0,-33,1,
	126,-1,36,126,0,-35,126,-1,34,
	0,126,0,-34,1,
	126,-1,37,126,0,-36,126,-1,35,
	0,126,0,-35,1,
	126,-1,38,126,0,-37,126,-1,36,
	0,126,0,-36,1,
	126,-1,39,126,0,-38,126,-1,37,
	0,126,0,-37,1,
	126,-1,40,126,0,-39,126,-1,38,
	0,126,0,-38,1,
	126,-1,41,126,0,-40,126,-1,39,
	0,126,0,-39,1,
	126,-1,42,126,0,-41,126,-1,40,
	0,126,0,-40,1,
	126,-1,43,126,0,-42,126,-1,41,
	0,126,0,-41,1,
	126,-1,44,126,0,-43,126,-1,42,
	0,126,0,-42,1,
	126,-1,45,126,0,-44,126,-1,43,
	0,126,0,-43,1,
	126,-1,46,126,0,-45,126,-1,44,
	0,126,0,-44,1,
	126,-1,47,126,0,-46,126,-1,45,
	0,126,0,-45,1,
	126,-1,48,126,0,-47,126,-1,46,
	0,126,0,-46,1,
	126,-1,49,126,0,-48,126,-1,47,
	0,126,0,-47,1,
	126,-1,50,9,-10,
	0,10,126,0,-58,
	126,-1,52,126,0,-51,126,-1,50,
	0,126,0,-50,1,
	126,-1,53,126,0,-52,126,-1,51,
	0,126,0,-51,1,
	126,-1,45,1,7,
	0,-7,126,0,-45,
	126,-1,55,126,0,-54,126,-1,53,
	0,126,0,-53,1,
	126,-1,56,126,0,-55,126,-1,54,
	0,126,0,-54,1,
	126,-1,57,126,0,-56,126,-1,55,
	0,126,0,-55,1,
	126,-1,58,126,0,-57,126,-1,56,
	0,126,0,-56,1,
	126,-1,59,126,0,-58,126,-1,57,
	0,126,0,-57,1,
	126,-1,60,126,0,-59,126,-1,58,
	0,126,0,-58,1,
	126,-1,61,126,0,-60,126,-1,59,
	0,126,0,-59,1,
	126,-1,62,126,0,-61,126,-1,60,
	0,126,0,-60,1,
	126,-1,63,126,0,-62,126,-1,61,
	0,126,0,-61,1,
	126,-1,64,126,0,-63,126,-1,62,
	0,126,0,-62,1,
	126,-1,65,126,0,-64,126,-1,63,
	0,126,0,-63,1,
	126,-1,66,126,0,-65,126,-1,64,
	0,126,0,-64,1,
	126,-1,67,126,0,-66,126,-1,65,
	0,126,0,-65,1,
	126,-1,68,126,0,-67,126,-1,66,
	0,126,0,-66,1,
	126,-1,69,126,0,-68,126,-1,67,
	0,126,0,-67,1,
	126,-1,70,126,0,-69,126,-1,68,
	0,126,0,-68,1,
	126,-1,71,126,0,-70,126,-1,69,
	0,126,0,-69,126,-1,73,
	-1,126,0,-73,126,-1,70,
	0,126,0,-70,126,-1,72,
	4,82,-83,
	0,83,100,
	126,-1,77,126,0,-76,126,-1,75,
	0,126,0,-75,1,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_xboxlogolip_0 = 210;
short verts_xboxlogolip_0C[] = 
{
		-13340,-29287,-19982, //	x,y,z
		381,-1307, //	u,v
		-12836,-29287,-20290, //	x,y,z
		297,895, //	u,v
		-12836,-29754,-20290, //	x,y,z
		-16366,889, //	u,v
		-13340,-29754,-19982, //	x,y,z
		-16282,-1313, //	u,v
		-13898,-29287,-19581, //	x,y,z
		477,-3961, //	u,v
		-13340,-29287,-19982, //	x,y,z
		381,-1307, //	u,v
		-13340,-29754,-19982, //	x,y,z
		-16282,-1313, //	u,v
		-13898,-29754,-19581, //	x,y,z
		-16186,-3967, //	u,v
		-14485,-29287,-19087, //	x,y,z
		577,-6847, //	u,v
		-13898,-29287,-19581, //	x,y,z
		477,-3961, //	u,v
		-13898,-29754,-19581, //	x,y,z
		-16186,-3967, //	u,v
		-14485,-29754,-19087, //	x,y,z
		-16085,-6853, //	u,v
		-15074,-29287,-18582, //	x,y,z
		676,-9748, //	u,v
		-15074,-29754,-18582, //	x,y,z
		-15987,-9754, //	u,v
		-15624,-29287,-18082, //	x,y,z
		766,-12446, //	u,v
		-15074,-29287,-18582, //	x,y,z
		676,-9748, //	u,v
		-15074,-29754,-18582, //	x,y,z
		-15987,-9754, //	u,v
		-15624,-29754,-18082, //	x,y,z
		-15897,-12452, //	u,v
		-16083,-29287,-17657, //	x,y,z
		842,-14723, //	u,v
		-16083,-29754,-17657, //	x,y,z
		-15821,-14729, //	u,v
		-12836,-29287,-20290, //	x,y,z
		-15877,717, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15877,-3694, //	u,v
		-13296,-29754,-19744, //	x,y,z
		407,-3694, //	u,v
		-12836,-29754,-20290, //	x,y,z
		407,717, //	u,v
		-13296,-29287,-19744, //	x,y,z
		-15877,-3694, //	u,v
		-13729,-29287,-19161, //	x,y,z
		-15877,-7725, //	u,v
		-13729,-29754,-19161, //	x,y,z
		407,-7725, //	u,v
		-13296,-29754,-19744, //	x,y,z
		407,-3694, //	u,v
		-13729,-29287,-19161, //	x,y,z
		-15877,-7725, //	u,v
		-14143,-29287,-18564, //	x,y,z
		-15877,-9784, //	u,v
		-14143,-29754,-18564, //	x,y,z
		407,-9784, //	u,v
		-13729,-29754,-19161, //	x,y,z
		407,-7725, //	u,v
		-16411,-29287,-17356, //	x,y,z
		895,-16360, //	u,v
		-16411,-29754,-17356, //	x,y,z
		-15768,-16366, //	u,v
		-16738,-29287,-17657, //	x,y,z
		513,-14543, //	u,v
		-16411,-29287,-17356, //	x,y,z
		561,-16133, //	u,v
		-16411,-29754,-17356, //	x,y,z
		-15643,-16139, //	u,v
		-16738,-29754,-17657, //	x,y,z
		-15690,-14549, //	u,v
		-17198,-29287,-18082, //	x,y,z
		447,-12333, //	u,v
		-17198,-29754,-18082, //	x,y,z
		-15756,-12338, //	u,v
		-17747,-29287,-18582, //	x,y,z
		370,-9713, //	u,v
		-17747,-29754,-18582, //	x,y,z
		-15833,-9719, //	u,v
		-18336,-29287,-19087, //	x,y,z
		289,-6896, //	u,v
		-17747,-29287,-18582, //	x,y,z
		370,-9713, //	u,v
		-17747,-29754,-18582, //	x,y,z
		-15833,-9719, //	u,v
		-18336,-29754,-19087, //	x,y,z
		-15914,-6902, //	u,v
		-18924,-29287,-19581, //	x,y,z
		211,-4094, //	u,v
		-18924,-29754,-19581, //	x,y,z
		-15993,-4100, //	u,v
		-19482,-29287,-19982, //	x,y,z
		142,-1518, //	u,v
		-18924,-29287,-19581, //	x,y,z
		211,-4094, //	u,v
		-18924,-29754,-19581, //	x,y,z
		-15993,-4100, //	u,v
		-19482,-29754,-19982, //	x,y,z
		-16062,-1524, //	u,v
		-19986,-29287,-20290, //	x,y,z
		89,620, //	u,v
		-19482,-29287,-19982, //	x,y,z
		142,-1518, //	u,v
		-19482,-29754,-19982, //	x,y,z
		-16062,-1524, //	u,v
		-19986,-29754,-20290, //	x,y,z
		-16114,614, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15801,-265, //	u,v
		-19986,-29287,-20290, //	x,y,z
		-15801,590, //	u,v
		-19986,-29754,-20290, //	x,y,z
		331,590, //	u,v
		-19526,-29754,-19744, //	x,y,z
		331,-265, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-15801,-1151, //	u,v
		-19526,-29287,-19744, //	x,y,z
		-15801,-265, //	u,v
		-19526,-29754,-19744, //	x,y,z
		331,-265, //	u,v
		-19092,-29754,-19161, //	x,y,z
		331,-1151, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-15801,-2400, //	u,v
		-19092,-29287,-19161, //	x,y,z
		-15801,-1151, //	u,v
		-19092,-29754,-19161, //	x,y,z
		331,-1151, //	u,v
		-18678,-29754,-18564, //	x,y,z
		331,-2400, //	u,v
		-14143,-29287,-18564, //	x,y,z
		-15877,-9784, //	u,v
		-14537,-29287,-17974, //	x,y,z
		-15877,-11729, //	u,v
		-14537,-29754,-17974, //	x,y,z
		407,-11729, //	u,v
		-14143,-29754,-18564, //	x,y,z
		407,-9784, //	u,v
		-18285,-29287,-17974, //	x,y,z
		-15801,-3495, //	u,v
		-18678,-29287,-18564, //	x,y,z
		-15801,-2400, //	u,v
		-18678,-29754,-18564, //	x,y,z
		331,-2400, //	u,v
		-18285,-29754,-17974, //	x,y,z
		331,-3495, //	u,v
		-14903,-29287,-17415, //	x,y,z
		-15877,-13400, //	u,v
		-14903,-29754,-17415, //	x,y,z
		407,-13400, //	u,v
		-17919,-29287,-17415, //	x,y,z
		-15801,-4613, //	u,v
		-17919,-29754,-17415, //	x,y,z
		331,-4613, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-15877,-14908, //	u,v
		-15229,-29754,-16909, //	x,y,z
		407,-14908, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-15801,-5829, //	u,v
		-17593,-29754,-16909, //	x,y,z
		331,-5829, //	u,v
		-15229,-29287,-16909, //	x,y,z
		-15877,-14908, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-15877,-16118, //	u,v
		-15501,-29754,-16479, //	x,y,z
		407,-16205, //	u,v
		-15501,-29754,-16479, //	x,y,z
		407,-16205, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-8006,-14045, //	u,v
		-15124,-29287,-16122, //	x,y,z
		-6755,-11969, //	u,v
		-15124,-29753,-16122, //	x,y,z
		-13617,-11615, //	u,v
		-15124,-29753,-16122, //	x,y,z
		-13617,-11615, //	u,v
		-15501,-29754,-16479, //	x,y,z
		-14868,-13691, //	u,v
		-15466,-29287,-16479, //	x,y,z
		-8006,-14045, //	u,v
		-15124,-29287,-16122, //	x,y,z
		-6755,-11969, //	u,v
		-14734,-29287,-15727, //	x,y,z
		-5434,-9778, //	u,v
		-14734,-29753,-15727, //	x,y,z
		-12296,-9424, //	u,v
		-15124,-29753,-16122, //	x,y,z
		-13617,-11615, //	u,v
		-14734,-29287,-15727, //	x,y,z
		-5434,-9778, //	u,v
		-14344,-29287,-15308, //	x,y,z
		-4088,-7547, //	u,v
		-14344,-29753,-15308, //	x,y,z
		-10950,-7193, //	u,v
		-14734,-29753,-15727, //	x,y,z
		-12296,-9424, //	u,v
		-14344,-29287,-15308, //	x,y,z
		-4088,-7547, //	u,v
		-13967,-29286,-14880, //	x,y,z
		-2762,-5349, //	u,v
		-13967,-29753,-14880, //	x,y,z
		-9623,-4995, //	u,v
		-14344,-29753,-15308, //	x,y,z
		-10950,-7193, //	u,v
		-13967,-29286,-14880, //	x,y,z
		-2762,-5349, //	u,v
		-13614,-29286,-14456, //	x,y,z
		-1501,-3260, //	u,v
		-13614,-29753,-14456, //	x,y,z
		-8362,-2906, //	u,v
		-13967,-29753,-14880, //	x,y,z
		-9623,-4995, //	u,v
		-13614,-29286,-14456, //	x,y,z
		-1501,-3260, //	u,v
		-13300,-29286,-14054, //	x,y,z
		-349,-1354, //	u,v
		-13300,-29753,-14054, //	x,y,z
		-7211,-1000, //	u,v
		-13614,-29753,-14456, //	x,y,z
		-8362,-2906, //	u,v
		-13300,-29286,-14054, //	x,y,z
		-349,-1354, //	u,v
		-13036,-29286,-13686, //	x,y,z
		646,294, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-6214,648, //	u,v
		-13300,-29753,-14054, //	x,y,z
		-7211,-1000, //	u,v
		-13036,-29286,-13686, //	x,y,z
		-16034,727, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-16026,-1379, //	u,v
		-13399,-29753,-13967, //	x,y,z
		536,-1379, //	u,v
		-13036,-29753,-13686, //	x,y,z
		528,727, //	u,v
		-13399,-29286,-13967, //	x,y,z
		-16026,-1379, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-16019,-3692, //	u,v
		-13860,-29753,-14279, //	x,y,z
		543,-3692, //	u,v
		-13399,-29753,-13967, //	x,y,z
		536,-1379, //	u,v
		-13860,-29286,-14279, //	x,y,z
		-16019,-3692, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-16012,-5992, //	u,v
		-14385,-29753,-14600, //	x,y,z
		549,-5992, //	u,v
		-13860,-29753,-14279, //	x,y,z
		543,-3692, //	u,v
		-14385,-29286,-14600, //	x,y,z
		-16012,-5992, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-16007,-8224, //	u,v
		-14937,-29753,-14910, //	x,y,z
		555,-8224, //	u,v
		-14385,-29753,-14600, //	x,y,z
		549,-5992, //	u,v
		-14937,-29287,-14910, //	x,y,z
		-16007,-8224, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-16002,-10920, //	u,v
		-15482,-29753,-15187, //	x,y,z
		560,-10920, //	u,v
		-14937,-29753,-14910, //	x,y,z
		555,-8224, //	u,v
		-15482,-29287,-15187, //	x,y,z
		-16002,-10920, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-16000,-13359, //	u,v
		-15985,-29753,-15409, //	x,y,z
		562,-13359, //	u,v
		-15482,-29753,-15187, //	x,y,z
		560,-10920, //	u,v
		-15985,-29287,-15409, //	x,y,z
		-16000,-13359, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-15998,-15361, //	u,v
		-16411,-29754,-15557, //	x,y,z
		563,-15361, //	u,v
		-15985,-29753,-15409, //	x,y,z
		562,-13359, //	u,v
		-16411,-29287,-15557, //	x,y,z
		-16079,-16196, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-16080,-14202, //	u,v
		-16836,-29753,-15409, //	x,y,z
		643,-14202, //	u,v
		-16411,-29754,-15557, //	x,y,z
		644,-16196, //	u,v
		-16836,-29287,-15409, //	x,y,z
		-16080,-14202, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-16083,-12066, //	u,v
		-17337,-29753,-15187, //	x,y,z
		640,-12066, //	u,v
		-16836,-29753,-15409, //	x,y,z
		643,-14202, //	u,v
		-17337,-29287,-15187, //	x,y,z
		-16083,-12066, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-16087,-9713, //	u,v
		-17881,-29753,-14910, //	x,y,z
		636,-9713, //	u,v
		-17337,-29753,-15187, //	x,y,z
		640,-12066, //	u,v
		-17881,-29287,-14910, //	x,y,z
		-16087,-9713, //	u,v
		-18431,-29286,-14600, //	x,y,z
		-16093,-7360, //	u,v
		-18431,-29753,-14600, //	x,y,z
		630,-7360, //	u,v
		-17881,-29753,-14910, //	x,y,z
		636,-9713, //	u,v
		-18431,-29286,-14600, //	x,y,z
		-16093,-7360, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-16100,-4976, //	u,v
		-18956,-29753,-14279, //	x,y,z
		623,-4976, //	u,v
		-18431,-29753,-14600, //	x,y,z
		630,-7360, //	u,v
		-18956,-29286,-14279, //	x,y,z
		-16100,-4976, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-16107,-2569, //	u,v
		-19418,-29753,-13967, //	x,y,z
		616,-2569, //	u,v
		-18956,-29753,-14279, //	x,y,z
		623,-4976, //	u,v
		-19418,-29286,-13967, //	x,y,z
		-16107,-2569, //	u,v
		-19785,-29286,-13686, //	x,y,z
		-16114,518, //	u,v
		-19785,-29753,-13686, //	x,y,z
		608,518, //	u,v
		-19418,-29753,-13967, //	x,y,z
		616,-2569, //	u,v
		-19785,-29286,-13686, //	x,y,z
		645,635, //	u,v
		-19526,-29286,-14049, //	x,y,z
		511,-1067, //	u,v
		-19526,-29753,-14049, //	x,y,z
		-15266,-1056, //	u,v
		-19785,-29753,-13686, //	x,y,z
		-15132,646, //	u,v
		-19526,-29286,-14049, //	x,y,z
		511,-1067, //	u,v
		-19213,-29286,-14450, //	x,y,z
		365,-3049, //	u,v
		-19213,-29753,-14450, //	x,y,z
		-15412,-3039, //	u,v
		-19526,-29753,-14049, //	x,y,z
		-15266,-1056, //	u,v
		-19213,-29286,-14450, //	x,y,z
		365,-3049, //	u,v
		-18861,-29286,-14874, //	x,y,z
		214,-5230, //	u,v
		-18861,-29753,-14874, //	x,y,z
		-15563,-5220, //	u,v
		-19213,-29753,-14450, //	x,y,z
		-15412,-3039, //	u,v
		-18861,-29286,-14874, //	x,y,z
		214,-5230, //	u,v
		-18482,-29287,-15304, //	x,y,z
		63,-7527, //	u,v
		-18482,-29753,-15304, //	x,y,z
		-15715,-7516, //	u,v
		-18861,-29753,-14874, //	x,y,z
		-15563,-5220, //	u,v
		-18482,-29287,-15304, //	x,y,z
		63,-7527, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-82,-9857, //	u,v
		-18090,-29753,-15725, //	x,y,z
		-15860,-9847, //	u,v
		-18482,-29753,-15304, //	x,y,z
		-15715,-7516, //	u,v
		-18090,-29287,-15725, //	x,y,z
		-82,-9857, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-217,-12140, //	u,v
		-17698,-29753,-16121, //	x,y,z
		-15995,-12130, //	u,v
		-18090,-29753,-15725, //	x,y,z
		-15860,-9847, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-217,-12140, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-335,-14293, //	u,v
		-17320,-29754,-16479, //	x,y,z
		-16113,-14283, //	u,v
		-17320,-29754,-16479, //	x,y,z
		-16113,-14283, //	u,v
		-17698,-29753,-16121, //	x,y,z
		-15995,-12130, //	u,v
		-17698,-29287,-16121, //	x,y,z
		-217,-12140, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-15801,-6895, //	u,v
		-17593,-29287,-16909, //	x,y,z
		-15801,-5829, //	u,v
		-17593,-29754,-16909, //	x,y,z
		331,-5829, //	u,v
		-17593,-29754,-16909, //	x,y,z
		331,-5829, //	u,v
		-17320,-29754,-16479, //	x,y,z
		331,-6971, //	u,v
		-17351,-29287,-16479, //	x,y,z
		-15801,-6895, //	u,v
};
const int index_count_xboxlogolip_0 = 336;
char indices_xboxlogolip_0C[] = 
{
	2,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	1,-3,4,
	0,1,-2,
	5,-1,-1,
	0,3,-1,
	1,-3,4,
	0,1,-2,
	5,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	-11,-1,14,
	0,1,-14,
	17,-1,-1,
	0,3,-1,
	1,-3,4,
	0,1,-2,
	2,-1,2,
	0,1,-2,
	5,-1,-1,
	0,3,-1,
	1,-3,4,
	0,1,-2,
	5,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	3,-1,-7,
	0,1,7,
	-2,-3,6,
	0,1,-4,
	6,-1,-4,
	0,1,4,
	-2,-1,4,
	0,1,-4,
	7,-1,-1,
	-4,1,6,
	3,-1,-1,
	5,-1,-1,
	5,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	0,3,-1,
	4,-1,-1,
	5,-1,-1,
	5,-1,-1,
	5,-1,-1,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_xboxlogosurfacetop_0 = 34;
short verts_xboxlogosurfacetop_0C[] = 
{
		-13399,-29753,-13967, //	x,y,z
		-12037,-16047, //	u,v
		-16411,-29754,-7827, //	x,y,z
		-7734,-31845, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-12555,-16770, //	u,v
		-13860,-29753,-14279, //	x,y,z
		-11378,-15245, //	u,v
		-14385,-29753,-14600, //	x,y,z
		-10629,-14418, //	u,v
		-14937,-29753,-14910, //	x,y,z
		-9840,-13490, //	u,v
		-15482,-29753,-15187, //	x,y,z
		-9061,-12344, //	u,v
		-15539,-29753,-14734, //	x,y,z
		-8980,-13943, //	u,v
		-15985,-29753,-15409, //	x,y,z
		-8343,-11144, //	u,v
		-16005,-29753,-15058, //	x,y,z
		-8315,-12675, //	u,v
		-16411,-29754,-15057, //	x,y,z
		-7735,-12677, //	u,v
		-16028,-29754,-14642, //	x,y,z
		-8281,-14179, //	u,v
		-16836,-29753,-15409, //	x,y,z
		-7128,-11144, //	u,v
		-16411,-29754,-15557, //	x,y,z
		-7735,-10269, //	u,v
		-17337,-29753,-15187, //	x,y,z
		-6412,-12344, //	u,v
		-17289,-29753,-14757, //	x,y,z
		-6480,-13882, //	u,v
		-16794,-29753,-14661, //	x,y,z
		-7187,-14129, //	u,v
		-17881,-29753,-14910, //	x,y,z
		-5635,-13490, //	u,v
		-18431,-29753,-14600, //	x,y,z
		-4848,-14418, //	u,v
		-18956,-29753,-14279, //	x,y,z
		-4100,-15245, //	u,v
		-19418,-29753,-13967, //	x,y,z
		-3439,-16047, //	u,v
		-19785,-29753,-13686, //	x,y,z
		-2914,-16770, //	u,v
		-27768,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-19785,-29753,-13686, //	x,y,z
		-16374,904, //	u,v
		-27768,-29287,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29287,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-14622, //	x,y,z
		-7735,-14232, //	u,v
		-16822,-29753,-15089, //	x,y,z
		-7147,-12595, //	u,v
};
const int index_count_xboxlogosurfacetop_0 = 105;
char indices_xboxlogosurfacetop_0C[] = 
{
	2,-1,-1,
	0,1,2,
	0,-2,3,
	0,-3,4,
	0,2,-1,
	0,3,-1,
	3,-1,-1,
	4,-3,2,
	4,-1,-1,
	0,1,2,
	0,-16,17,
	0,-17,18,
	0,-18,19,
	0,-19,20,
	3,-1,-1,
	5,-1,-1,
	0,4,-1,
	-3,3,-1,
	4,-1,-7,
	-16,-6,10,
	-6,-4,6,
	0,2,-3,
	2,1,4,
	19,-31,15,
	-5,-10,31,
	0,1,-23,
	2,21,-19,
	1,-14,16,
	-1,-15,14,
	-6,1,3,
	-6,4,-2,
	1,23,-21,
	-1,21,-22,
	23,-17,-2,
	18,-16,17,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_xboxlogosurface_0 = 77;
short verts_xboxlogosurface_0C[] = 
{
		-13296,-29754,-19744, //	x,y,z
		-15182,-3867, //	u,v
		-5054,-29754,-16500, //	x,y,z
		-31514,-8048, //	u,v
		-12836,-29754,-20290, //	x,y,z
		-16093,-3163, //	u,v
		-12836,-29754,-20290, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-13340,-29754,-19982, //	x,y,z
		-16374,904, //	u,v
		-13898,-29754,-19581, //	x,y,z
		-16374,904, //	u,v
		-14485,-29754,-19087, //	x,y,z
		-16374,904, //	u,v
		-15074,-29754,-18582, //	x,y,z
		-16374,904, //	u,v
		-15624,-29754,-18082, //	x,y,z
		-16374,904, //	u,v
		-16083,-29754,-17657, //	x,y,z
		-16374,904, //	u,v
		-13729,-29754,-19161, //	x,y,z
		-14322,-4618, //	u,v
		-14143,-29754,-18564, //	x,y,z
		-13503,-5388, //	u,v
		-14537,-29754,-17974, //	x,y,z
		-12625,-6148, //	u,v
		-16411,-29754,-17356, //	x,y,z
		-16374,904, //	u,v
		-16738,-29754,-17657, //	x,y,z
		-16374,904, //	u,v
		-17198,-29754,-18082, //	x,y,z
		-16374,904, //	u,v
		-17747,-29754,-18582, //	x,y,z
		-16374,904, //	u,v
		-18336,-29754,-19087, //	x,y,z
		-16374,904, //	u,v
		-18924,-29754,-19581, //	x,y,z
		-16374,904, //	u,v
		-19482,-29754,-19982, //	x,y,z
		-16374,904, //	u,v
		-19986,-29754,-20290, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-16480, //	x,y,z
		-16374,904, //	u,v
		-19526,-29754,-19744, //	x,y,z
		-16374,904, //	u,v
		-19092,-29754,-19161, //	x,y,z
		-16374,904, //	u,v
		-18678,-29754,-18564, //	x,y,z
		-16374,904, //	u,v
		-14903,-29754,-17415, //	x,y,z
		-11458,-6869, //	u,v
		-14375,-29754,-17366, //	x,y,z
		-12945,-6932, //	u,v
		-18285,-29754,-17974, //	x,y,z
		-16374,904, //	u,v
		-15229,-29754,-16909, //	x,y,z
		-10298,-7521, //	u,v
		-14703,-29754,-16888, //	x,y,z
		-11856,-7548, //	u,v
		-17919,-29754,-17415, //	x,y,z
		-16374,904, //	u,v
		-15501,-29754,-16479, //	x,y,z
		-9758,-8075, //	u,v
		-14953,-29754,-16480, //	x,y,z
		-10845,-8074, //	u,v
		-17593,-29754,-16909, //	x,y,z
		-16374,904, //	u,v
		-15124,-29754,-16122, //	x,y,z
		-10506,-8536, //	u,v
		-14645,-29754,-16138, //	x,y,z
		-11969,-8515, //	u,v
		-14606,-29754,-16481, //	x,y,z
		-12047,-8073, //	u,v
		-14734,-29753,-15727, //	x,y,z
		-11793,-9044, //	u,v
		-14290,-29753,-15749, //	x,y,z
		-13113,-9017, //	u,v
		-14344,-29753,-15308, //	x,y,z
		-13007,-9584, //	u,v
		-13967,-29753,-14880, //	x,y,z
		-13852,-10137, //	u,v
		-13614,-29753,-14456, //	x,y,z
		-14550,-10682, //	u,v
		-13300,-29753,-14054, //	x,y,z
		-15173,-11201, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-15696,-11675, //	u,v
		-5054,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-16500, //	x,y,z
		-16374,904, //	u,v
		-13036,-29753,-13686, //	x,y,z
		-16374,904, //	u,v
		-19526,-29753,-14049, //	x,y,z
		-16374,904, //	u,v
		-19785,-29753,-13686, //	x,y,z
		-16374,904, //	u,v
		-19213,-29753,-14450, //	x,y,z
		-16374,904, //	u,v
		-18861,-29753,-14874, //	x,y,z
		-16374,904, //	u,v
		-18482,-29753,-15304, //	x,y,z
		-16374,904, //	u,v
		-18090,-29753,-15725, //	x,y,z
		-16374,904, //	u,v
		-17698,-29753,-16121, //	x,y,z
		-16374,904, //	u,v
		-17320,-29754,-16479, //	x,y,z
		-16374,904, //	u,v
		-5054,-29287,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29287,-30877, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-16500, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-5054,-29287,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29287,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-16411,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-5054,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29287,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29287,-7827, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-16480, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-30877, //	x,y,z
		-16374,904, //	u,v
		-27768,-29754,-7827, //	x,y,z
		-16374,904, //	u,v
		-14268,-29754,-16150, //	x,y,z
		-13156,-8499, //	u,v
		-14282,-29754,-16481, //	x,y,z
		-13130,-8072, //	u,v
		-14316,-29754,-16872, //	x,y,z
		-13061,-7568, //	u,v
};
const int index_count_xboxlogosurface_0 = 225;
char indices_xboxlogosurface_0C[] = 
{
	2,-1,-1,
	5,-1,-1,
	2,-2,3,
	-1,1,1,
	-2,2,1,
	-3,3,1,
	-4,4,1,
	-5,5,1,
	-11,1,11,
	0,-11,12,
	0,-12,13,
	-9,6,4,
	-10,10,1,
	-11,11,1,
	-12,12,1,
	-13,13,1,
	-14,14,1,
	-15,15,1,
	-16,16,1,
	2,-1,-1,
	2,-2,3,
	-1,1,1,
	-2,2,1,
	-13,15,-1,
	-4,3,3,
	-2,4,-1,
	-7,6,3,
	-2,4,-1,
	-10,9,3,
	3,-1,-1,
	1,3,-1,
	0,1,1,
	0,-41,42,
	0,-42,43,
	0,-43,44,
	0,-44,45,
	3,-1,-1,
	4,-27,26,
	0,-26,28,
	0,-28,29,
	0,-29,30,
	0,-30,31,
	0,-31,32,
	0,-32,33,
	0,-33,12,
	24,-1,-1,
	0,4,-1,
	4,-1,-1,
	0,4,-1,
	4,-1,-1,
	0,4,-1,
	-13,3,-1,
	-57,1,44,
	20,3,-1,
	3,-49,27,
	12,3,-1,
	-42,-18,17,
	19,-40,41,
	-5,1,2,
	34,-73,40,
	-7,1,2,
	38,-74,73,
	-43,1,3,
	41,-75,74,
	-47,1,47,
	-47,-28,75,
	-62,-13,28,
	10,36,-1,
	2,-1,-36,
	37,-37,-7,
	3,4,-2,
	1,36,-33,
	-2,35,-36,
	-6,7,-4,
	-7,48,-44,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_tm_slash_0 = 4;
short verts_tm_slash_0C[] = 
{
		-12770,-29763,-13794, //	x,y,z
		-16034,563, //	u,v
		-12410,-29763,-13794, //	x,y,z
		563,563, //	u,v
		-12410,-29763,-13435, //	x,y,z
		563,-16034, //	u,v
		-12770,-29763,-13435, //	x,y,z
		-16034,-16034, //	u,v
};
const int index_count_tm_slash_0 = 6;
char indices_tm_slash_0C[] = 
{
	0,1,1,
	1,-3,2,
};

///////////////////////////////////////////////////////////////////////////////
const int vertex_count_tm_wordmark_0 = 4;
short verts_tm_wordmark_0C[] = 
{
		-11684,-29763,-21238, //	x,y,z
		-16034,563, //	u,v
		-11379,-29763,-21238, //	x,y,z
		563,563, //	u,v
		-11379,-29763,-20934, //	x,y,z
		563,-16034, //	u,v
		-11684,-29763,-20934, //	x,y,z
		-16034,-16034, //	u,v
};
const int index_count_tm_wordmark_0 = 6;
char indices_tm_wordmark_0C[] = 
{
	0,1,1,
	1,-3,2,
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\GreenFog.h ===
///////////////////////////////////////////////////////////////////////////////
// File: GreenFog.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef GREENFOG_H
#define GREENFOG_H



class GreenFog
{
public:
	void Init();
	void UnInit() { destroy(); }

	
	void create();
	void destroy();

	void advanceTime(float fElapsedTime, float fDt);

	void render(bool b_cmp_to_one);

	void restart();


	LPDIRECT3DVERTEXBUFFER8 borrowScreenQuad() { return pQuadVB; }

protected:
	enum { NUM_PLASMAS = 3 };
	LPDIRECT3DVERTEXBUFFER8		pQuadVB;
	LPDIRECT3DVERTEXBUFFER8		pIntensityQuadVB;
	LPDIRECT3DTEXTURE8			pPlasmaTexture[NUM_PLASMAS];
	LPDIRECT3DTEXTURE8			pIntensityTextureR;		// for rendering (swapped in render)
	LPDIRECT3DTEXTURE8			pIntensityTextureU;		// for updating
	LPDIRECT3DSURFACE8			pIntensityZ;

	DWORD		dwFogPShader, dwFogVShader;


	void renderIntensityTexture();
};
///////////////////////////////////////////////////////////////////////////////
struct GreenFogVertexBuffer
{
	D3DVECTOR	pos;
	FLOAT		tu0, tv0;	// texture coordinate in intensity lookup
	FLOAT		tu1, tv1;	// texture coordinate in plasma, which wraps
};



#endif // GREENFOG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\Macros.h ===
#define	F_NOTE	1
#define	F_REST	0
#define	F_JUMPTO	2
#define	F_LOOP	3
#define	F_ENDLOOP	4
#define	F_PATCH	5
#define	F_PAN	6
#define	F_MUX	7
#define	F_DEMUX	8
#define	F_VOLUME	9
#define	F_XPOSE	10
#define	F_XSET	11
#define	F_SLUR	12
#define	F_RING	13
#define	F_CLOCKSET	14
#define	F_END	15

#define	F_FILTERINC	16
#define	F_FILTERSET	17



#define	note(pitch,dur)	F_NOTE,pitch,dur
#define	rest(dur)		F_REST,dur
#define	jumpto(label)	F_JUMPTO,label
#define	loop(n)			F_LOOP,n
#define	endloop			F_ENDLOOP
#define	patch(num)		F_PATCH,num
#define	pan(value)		F_PAN,value
#define	mux(label)		F_MUX,label
#define	demux			F_DEMUX
#define	volume(val)		F_VOLUME,val
#define	xpose(val)		F_XPOSE,val
#define	xset(val)		F_XSET,val
#define	slur(pitch,dur)	F_SLUR,pitch,dur
#define	ring(dur)		F_RING,dur
#define	clockset(val)	F_CLOCKSET,val
#define	sosend			F_END
#define	finc(f,res)		F_FILTERINC,f,res
#define	fset(f,res)		F_FILTERSET,f,res
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\logo_renderer.cpp ===
//
//	logo_renderer.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "xbs_app.h"
#include "logo_renderer.h"
#include "logo_geometry.h"
#include "text_geometry.h"
#include "tm_pixels.h"
#include "renderer.h"
#include "tex_gen.h"
#include "xbs_app.h"


///////////////////////////////////////////////////////////////////////////////
float * LogoRenderer::decompressPosData(short *pdata,int ncount,float f_oo_scale,float f_delta)
{
	float * p_data = (float *)MemAlloc(ncount * sizeof(float) * 3);
	for(int i = 0; i < ncount * 3;i++)
	{
		p_data[i] = ( (float)pdata[i] ) * f_oo_scale + f_delta;
	}
	return p_data;
}
///////////////////////////////////////////////////////////////////////////////
float * LogoRenderer::decompressPosTexData(short *pdata,int ncount,
										   float f_oo_pos_scale,float f_pos_delta,
										   float f_oo_tex_scale,float f_tex_delta )
{
	float * p_data = (float *)MemAlloc(ncount * sizeof(float) * 5);
	for(int i = 0; i < ncount*5;i+=5)
	{
		p_data[i  ] = ( (float)pdata[i  ] ) * f_oo_pos_scale + f_pos_delta;
		p_data[i+1] = ( (float)pdata[i+1] ) * f_oo_pos_scale + f_pos_delta;
		p_data[i+2] = ( (float)pdata[i+2] ) * f_oo_pos_scale + f_pos_delta;
		p_data[i+3] = ( (float)pdata[i+3] ) * f_oo_tex_scale + f_tex_delta;
		p_data[i+4] = ( (float)pdata[i+4] ) * f_oo_tex_scale + f_tex_delta;
	}
	return p_data;	
}															
///////////////////////////////////////////////////////////////////////////////
WORD * LogoRenderer::decompressIndexData(char *pdata,int ncount)
{
	WORD * p_data = (WORD *)MemAlloc(ncount * sizeof(WORD));
	
	p_data[0] = (WORD)pdata[0];

	char * pbytes = pdata;
	for(int i = 1; i < ncount; i++)
	{
		if(pbytes[i] == 126)
		{
			char hi = pbytes[i+1];
			char lo = pbytes[i+2];

			p_data[i] = ((((short)hi)&0xff)<<8) | (((short)lo)&0xff);
			p_data[i] += p_data[i-1];
			pbytes += 2;
		}
		else
		{
			p_data[i] = p_data[i-1] + pbytes[i];
		}
	}
	return p_data;
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::create()
{
	decompressData();
	createSlash();
	createText();
	createTMs();

	pSlashTexture = NULL;

#ifndef BINARY_RESOURCE
	dwInteriorPShader = gApp.loadPixelShader ("d:\\shaders\\slash_interior.xpu");
#else // BINARY_RESOURCE
	dwInteriorPShader = gApp.loadPixelShader ( g_slash_interior_xpu );
#endif // BINARY_RESOURCE
	
	DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
		D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),
		D3DVSD_REG( 1, D3DVSDT_FLOAT2 ),     
		D3DVSD_END()
    };

#ifndef BINARY_RESOURCE
	dwInteriorVShader = gApp.loadVertexShader("d:\\shaders\\slash_interior.xvu",dwDecl);
#else // BINARY_RESOURCE
	dwInteriorVShader = gApp.loadVertexShader ( g_slash_interior_xvu,dwDecl );
#endif // BINARY_RESOURCE
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::decompressData()
{
	indices_xboxlogolip_0 = decompressIndexData(indices_xboxlogolip_0C,index_count_xboxlogolip_0);
	verts_xboxlogolip_0 = decompressPosTexData(verts_xboxlogolip_0C,
											   vertex_count_xboxlogolip_0,
											   xbl_OO_POS_SCALE,xbl_POS_DELTA,
											   xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_xboxlogosurface_0 = decompressIndexData(indices_xboxlogosurface_0C,index_count_xboxlogosurface_0);
	verts_xboxlogosurface_0 = decompressPosTexData(verts_xboxlogosurface_0C,
												   vertex_count_xboxlogosurface_0,
												   xbl_OO_POS_SCALE,xbl_POS_DELTA,
												   xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_xboxlogosurfacetop_0 = decompressIndexData(indices_xboxlogosurfacetop_0C,index_count_xboxlogosurfacetop_0);
	verts_xboxlogosurfacetop_0 = decompressPosTexData(verts_xboxlogosurfacetop_0C,
												      vertex_count_xboxlogosurfacetop_0,
												      xbl_OO_POS_SCALE,xbl_POS_DELTA,
												      xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_xboxlogointerior_0 = decompressIndexData(indices_xboxlogointerior_0C,index_count_xboxlogointerior_0);
	verts_xboxlogointerior_0 = decompressPosTexData(verts_xboxlogointerior_0C,
												    vertex_count_xboxlogointerior_0,
												    xbl_OO_POS_SCALE,xbl_POS_DELTA,
												    xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_tm_slash_0 = decompressIndexData(indices_tm_slash_0C,index_count_tm_slash_0);
	verts_tm_slash_0 = decompressPosTexData(verts_tm_slash_0C,
										    vertex_count_tm_slash_0,
											xbl_OO_POS_SCALE,xbl_POS_DELTA,
											xbl_OO_TEX_SCALE,xbl_TEX_DELTA );

	indices_tm_wordmark_0 = decompressIndexData(indices_tm_wordmark_0C,index_count_tm_wordmark_0);
	verts_tm_wordmark_0 = decompressPosTexData(verts_tm_wordmark_0C,
											   vertex_count_tm_wordmark_0,
											   xbl_OO_POS_SCALE,xbl_POS_DELTA,
											   xbl_OO_TEX_SCALE,xbl_TEX_DELTA );
	
	indices_text_0 = decompressIndexData(indices_text_0C,index_count_text_0);
	verts_text_0 = decompressPosData(verts_text_0C,vertex_count_text_0,xbt_OO_POS_SCALE,xbt_POS_DELTA );
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::createSlash()
{
	xbl_vertex *pv = NULL;

	nLipIndices = index_count_xboxlogolip_0;
	nLipVerts = vertex_count_xboxlogolip_0;
	pLipIndices = indices_xboxlogolip_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nLipVerts,NULL,FVF_xbl,NULL,&pLipVB);
	pLipVB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_xboxlogolip_0,sizeof(xbl_vertex) * nLipVerts);
	pLipVB->Unlock();
	pLipTex = CreateGradientTexture(16,128,0xff000100,0xff4b9b4b);

	nSurfaceIndices = index_count_xboxlogosurface_0;
	nSurfaceVerts = vertex_count_xboxlogosurface_0;
	pSurfaceIndices = indices_xboxlogosurface_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nSurfaceVerts,NULL,FVF_xbl,NULL,&pSurfaceVB);
	pSurfaceVB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_xboxlogosurface_0,sizeof(xbl_vertex) * nSurfaceVerts);
	pSurfaceVB->Unlock();
	pSurfaceTex = CreateHighlightTexture(256,6,false,0.5f,0.5f);

	nSurfaceTopIndices = index_count_xboxlogosurfacetop_0;
	nSurfaceTopVerts = vertex_count_xboxlogosurfacetop_0;
	pSurfaceTopIndices = indices_xboxlogosurfacetop_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nSurfaceVerts,NULL,FVF_xbl,NULL,&pSurfaceTopVB);
	pSurfaceTopVB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_xboxlogosurfacetop_0,sizeof(xbl_vertex) * nSurfaceTopVerts);

	// HACK to enforce border color.
	for(int i=0; i < (int)nSurfaceTopVerts;i++)
	{
		if(fast_fabs(pv[i].v0-1.f) <= 0.01f) 
			pv[i].v0 = -1.f;
	}

	pSurfaceTopVB->Unlock();
	pSurfaceTopTex = CreateGradientTexture(16,128,0xff000000,0xffffffff);

	nInteriorIndices = index_count_xboxlogointerior_0;
	nInteriorVerts = vertex_count_xboxlogointerior_0;
	pInteriorIndices = indices_xboxlogointerior_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nInteriorVerts,NULL,FVF_xbl,NULL,&pInteriorVB);
	pInteriorVB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_xboxlogointerior_0,sizeof(xbl_vertex) * nInteriorVerts);
	pInteriorVB->Unlock();
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::createText()
{ 	
	xbt_vertex *pv;

	nText_Verts = vertex_count_text_0;
	nText_Indices = index_count_text_0;
	pText_Indices = indices_text_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbt_vertex) * nText_Verts,NULL,FVF_xbt,NULL,&pText_VB);
	pText_VB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_text_0,sizeof(xbt_vertex) * nText_Verts);
	pText_VB->Unlock();
	SetIdentity(&matText_Anim);

	bRenderText = false;
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::createTMs()
{
	xbl_vertex *pv;

	nSlashTM_Verts = vertex_count_tm_slash_0;
	nSlashTM_Indices = index_count_tm_slash_0;
	pSlashTM_Indices = indices_tm_slash_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nSlashTM_Verts,NULL,FVF_xbl,NULL,&pSlashTM_VB);
	pSlashTM_VB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_tm_slash_0,sizeof(xbl_vertex) * nSlashTM_Verts);
	pSlashTM_VB->Unlock();

	nTextTM_Verts = vertex_count_tm_wordmark_0;
	nTextTM_Indices = index_count_tm_wordmark_0;
	pTextTM_Indices = indices_tm_wordmark_0;
	gpd3dDev->CreateVertexBuffer(sizeof(xbl_vertex) * nTextTM_Verts,NULL,FVF_xbl,NULL,&pTextTM_VB);
	pTextTM_VB->Lock(0,0,(BYTE **)&pv,0);
	memcpy(pv,verts_tm_wordmark_0,sizeof(xbl_vertex) * nTextTM_Verts);
	pTextTM_VB->Unlock();

	gpd3dDev->CreateTexture( 16,16,1,0,D3DFMT_A8R8G8B8,0,&pTMTex);
	
	D3DLOCKED_RECT rc;
	pTMTex->LockRect(0,&rc,NULL,0);
	XGSwizzleRect( tm_pixels,
				   0,
				   NULL,
				   rc.pBits,
				   16,
				   16,
				   NULL,
				   sizeof(DWORD) );

	pTMTex->UnlockRect(0);

	fTMAlpha = 0.f;
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::createSlashSurface()
{
	bool b_want_wordmark = (gApp.getElapsedTime() >= TEXT_ANIM_START_TIME + TEXT_ANIM_LEN);
	if (pSlashTexture && (b_want_wordmark == bHasWordmark)) return;

	LPDIRECT3DSURFACE8		pSlashSurface;
	LPDIRECT3DSURFACE8		pSlashDepthBuf;

	D3DFORMAT fmt = D3DFMT_A8R8G8B8;
	DWORD mst = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR;
	int x_dim = 1024;	
	int y_dim = 1024;
	gpd3dDev->CreateRenderTarget(x_dim, y_dim, fmt, mst, TRUE, &pSlashSurface);
	gpd3dDev->CreateDepthStencilSurface(x_dim,y_dim,D3DFMT_LIN_D24S8, mst, &pSlashDepthBuf);
	if (!pSlashTexture) gpd3dDev->CreateTexture(x_dim, y_dim, 1, 0, fmt, 0, &pSlashTexture);


	LPDIRECT3DSURFACE8 pOldRT,pOldZ;
	gpd3dDev->GetRenderTarget(&pOldRT);
	gpd3dDev->GetDepthStencilSurface(&pOldZ);

	gpd3dDev->SetRenderTarget(pSlashSurface, pSlashDepthBuf);

	if( gpd3dDev->BeginScene() == D3D_OK )
	{
		gpd3dDev->Clear(0,NULL,
						D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL,
						0xff000000,
						1.f,
						0 );

		bool b_old_render_text = bRenderText;
		bRenderText = b_want_wordmark;

		render(gApp.camController.getSlashTransform(), true);

		bRenderText = b_old_render_text;

		gpd3dDev->EndScene();


		LPDIRECT3DSURFACE8 p_tex_surf;
		pSlashTexture->GetSurfaceLevel(0, &p_tex_surf);

		gpd3dDev->CopyRects(pSlashSurface, NULL, 0, p_tex_surf, NULL);
		p_tex_surf->Release();

		bHasWordmark = b_want_wordmark;
	}

	pSlashSurface->Release();
	pSlashDepthBuf->Release();

	gpd3dDev->SetRenderTarget(pOldRT,pOldZ);
	pOldRT->Release();
	pOldZ->Release();
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::destroy()
{
	pLipVB->Release();
	pLipTex->Release();
	pSurfaceVB->Release();
	pSurfaceTex->Release();
	pSurfaceTopVB->Release();
	pSurfaceTopTex->Release();
	pInteriorVB->Release();
	pText_VB->Release();
	pSlashTM_VB->Release();
	pTextTM_VB->Release();
	pTMTex->Release();
	pSlashTexture->Release();

	MemFree(indices_xboxlogolip_0);
	MemFree(verts_xboxlogolip_0);
	MemFree(indices_xboxlogosurface_0);
	MemFree(verts_xboxlogosurface_0);
	MemFree(indices_xboxlogosurfacetop_0);
	MemFree(verts_xboxlogosurfacetop_0);
	MemFree(indices_xboxlogointerior_0);
	MemFree(verts_xboxlogointerior_0);
	MemFree(indices_tm_wordmark_0);
	MemFree(verts_tm_wordmark_0);
	MemFree(indices_tm_slash_0);
	MemFree(verts_tm_slash_0);
	MemFree(indices_text_0);
	MemFree(verts_text_0);

	gpd3dDev->DeleteVertexShader(dwInteriorVShader);
	gpd3dDev->DeletePixelShader (dwInteriorPShader);
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::advanceTime(float fElapsedTime, float fDt)
{
	if(fElapsedTime >= TEXT_ANIM_START_TIME)
	{
		bRenderText = true;

		int n_samples = sizeof(pos_anim_text)/sizeof( D3DVECTOR );

		float f_norm_pos = (fElapsedTime - TEXT_ANIM_START_TIME) / TEXT_ANIM_LEN;
		float f_pos = f_norm_pos * (n_samples-1);

		int pos_idx;

		 __asm
		{
			cvttss2si eax, f_pos
			mov pos_idx, eax
		}

		if(f_norm_pos <= 0.f)
		{
			matText_Anim._41 = pos_anim_text[0].x;
			matText_Anim._42 = pos_anim_text[0].y;
			matText_Anim._43 = pos_anim_text[0].z;
		}
		else if(f_norm_pos >= 1.f)
		{
			int last_pos = n_samples - 1;
			
			matText_Anim._41 = pos_anim_text[last_pos].x;
			matText_Anim._42 = pos_anim_text[last_pos].y;
			matText_Anim._43 = pos_anim_text[last_pos].z;
		}
		else
		{
			float f_frac = f_pos - ((float)pos_idx);

			D3DVECTOR &s = pos_anim_text[pos_idx];
			D3DVECTOR &e = pos_anim_text[pos_idx+1];

			matText_Anim._41 = s.x * (1.f-f_frac) + e.x * f_frac;
			matText_Anim._42 = s.y * (1.f-f_frac) + e.y * f_frac;
			matText_Anim._43 = s.z * (1.f-f_frac) + e.z * f_frac;
		}

		
		fTMAlpha = (fElapsedTime - (TEXT_ANIM_START_TIME)) / (TEXT_ANIM_LEN);
		fTMAlpha = max(0.f,min(1.f,fTMAlpha));
		fTMAlpha *= 255.f;
	}
	else
	{
		bRenderText = false;
		fTMAlpha = 0.f;
	}

	if (fElapsedTime >= FINISH_STOP_TIME)
	{
		createSlashSurface();
	}
}
///////////////////////////////////////////////////////////////////////////////
void LogoRenderer::render(const D3DMATRIX &mat_otw, bool b_force_3d_render)
{
	gpd3dDev->SetVertexShader(FVF_xbl);
	gpd3dDev->SetPixelShader (NULL);

	if (b_force_3d_render || (gApp.getElapsedTime() < FINISH_STOP_TIME))
	{
		Camera &cam = gApp.theCamera;

		gpd3dDev->SetTransform(D3DTS_WORLD,&mat_otw);
		gpd3dDev->SetTransform(D3DTS_VIEW,&cam.matWTC);
		gpd3dDev->SetTransform(D3DTS_PROJECTION,&cam.matProj);

		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);

		gpd3dDev->SetTextureStageState(0,D3DTSS_ADDRESSU,    D3DTADDRESS_BORDER );
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ADDRESSV,    D3DTADDRESS_BORDER );
  		gpd3dDev->SetTextureStageState(0,D3DTSS_BORDERCOLOR, 0xff000000 );
  
  		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
  		gpd3dDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
  		gpd3dDev->SetRenderState(D3DRS_CULLMODE,D3DCULL_CW);


		gpd3dDev->SetStreamSource(0,pLipVB,sizeof(xbl_vertex));
		gpd3dDev->SetTexture(0,pLipTex);
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nLipIndices,pLipIndices);

		gpd3dDev->SetStreamSource(0,pSurfaceVB,sizeof(xbl_vertex));
		gpd3dDev->SetTexture(0,pSurfaceTex);
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nSurfaceIndices,pSurfaceIndices);

		gpd3dDev->SetStreamSource(0,pSurfaceTopVB,sizeof(xbl_vertex));
		gpd3dDev->SetTexture(0,pSurfaceTopTex);
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nSurfaceTopIndices,pSurfaceTopIndices);

		gpd3dDev->SetStreamSource(0,pInteriorVB,sizeof(xbl_vertex));

		float fmag = -1.0f + 2.0f * (gApp.getElapsedTime() - SLASH_GRADIENT_TRANSITION_START) * SLASH_GRADIENT_TRANSITION_MUL;
		float w1 = max(0.f, min(1.f,-fmag));
		float w3 = max(0.f, min(1.f,+fmag));
		float w2 = max(0.f, min(1.f,1.f - w1 - w3));

		gpd3dDev->SetVertexShader(dwInteriorVShader);
		gpd3dDev->SetPixelShader (dwInteriorPShader);

		D3DMATRIX mat_final,tmp;
		MulMats(mat_otw,cam.getWTP(),&tmp);
		SetTranspose(tmp,&mat_final);
		gpd3dDev->SetVertexShaderConstant(0,(void *)&mat_final,4);

		D3DVECTOR4 vals[5];
		if(fmag < 0.f)
		{
			Set(&vals[0],0.81568f,1.f,0.5921f,1.f);
			Set(&vals[1],0.81568f,1.f,0.5921f,1.f);
			Set(&vals[2],0.81568f,1.f,0.5294f,1.f);
			Set(&vals[3],0.81568f,1.f,0.5294f,1.f);
			Set(&vals[4],w1,w1,w1,1.f);
		}
		else
		{
			Set(&vals[0],0.81568f,1.f,0.5294f,1.f);
			Set(&vals[1],0.81568f,1.f,0.5294f,1.f);
			Set(&vals[2],0.796f,0.8745f,0.0039f,1.f);
			Set(&vals[3],0.1294f,0.4168f,0.0901f,1.f);
			Set(&vals[4],w2,w2,w2,1.f);
		}

		gpd3dDev->SetVertexShaderConstant(4,(void *)&vals,5);
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nInteriorIndices,pInteriorIndices);
	}

	else
	{				
		gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE);
   		gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ONE );
   		gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ZERO );
   		gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		FALSE );
   
   		D3DMATRIX iden;
   		SetIdentity(&iden);
   		gpd3dDev->SetTransform(D3DTS_WORLD, &iden);
   		gpd3dDev->SetTransform(D3DTS_VIEW, &iden);
   		gpd3dDev->SetTransform(D3DTS_PROJECTION, &iden);
   
  		gpd3dDev->SetRenderState(D3DRS_TEXTUREFACTOR, 0xFFFFFFFF);
   		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
   		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TEXTURE);
  		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG2,D3DTA_TEXTURE);
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,D3DTOP_SELECTARG1);
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,D3DTA_TFACTOR);
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG2,D3DTA_TFACTOR);
  		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);
  
   		gpd3dDev->SetTextureStageState(0,D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
   		
   
   		gpd3dDev->SetTexture(0,pSlashTexture);
   
   		gpd3dDev->SetVertexShader(D3DFVF_XYZ | D3DFVF_TEX2);
   
   		
   		gpd3dDev->SetStreamSource(0, gApp.greenFog.borrowScreenQuad(), sizeof(GreenFogVertexBuffer));
   		gpd3dDev->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
   
  		gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
  
   		// Prepare for rendering text...
   		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
   		gpd3dDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
  		gpd3dDev->SetRenderState(D3DRS_CULLMODE,D3DCULL_CW);
 		gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,TRUE );
   
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ADDRESSU,    D3DTADDRESS_BORDER );
  		gpd3dDev->SetTextureStageState(0,D3DTSS_ADDRESSV,    D3DTADDRESS_BORDER );
  		gpd3dDev->SetTextureStageState(0,D3DTSS_BORDERCOLOR, 0xff000000 );
     
   		gpd3dDev->SetTransform(D3DTS_WORLD,&mat_otw);
   		gpd3dDev->SetTransform(D3DTS_VIEW,&gApp.theCamera.matWTC);
   		gpd3dDev->SetTransform(D3DTS_PROJECTION,&gApp.theCamera.matProj);

	}

	if(bRenderText && !bHasWordmark)
	{
		gpd3dDev->SetVertexShader(FVF_xbl);
		gpd3dDev->SetPixelShader (NULL);

		gpd3dDev->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);

		DWORD dw_alpha;
		float f_alpha = fTMAlpha;

		__asm
		{
			cvttss2si eax, f_alpha
			shl eax,24
			mov dw_alpha,eax
		}

		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
		gpd3dDev->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);
		gpd3dDev->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_INVSRCALPHA);

		gpd3dDev->SetRenderState(D3DRS_TEXTUREFACTOR,dw_alpha);

		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG2,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,D3DTOP_MODULATE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,D3DTA_TEXTURE);
		gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG2,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);
		gpd3dDev->SetTexture(0,pTMTex);

		gpd3dDev->SetStreamSource(0,pSlashTM_VB,sizeof(xbl_vertex));
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nSlashTM_Indices,pSlashTM_Indices);

		gpd3dDev->SetStreamSource(0,pTextTM_VB,sizeof(xbl_vertex));
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nTextTM_Indices,pTextTM_Indices);

		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);

		gpd3dDev->SetRenderState(D3DRS_TEXTUREFACTOR,0xff62ca13);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TFACTOR);

		D3DMATRIX anim_otw;

		D3DMATRIX flip;
		SetXRotation(Pi/2.f,&flip);

		D3DMATRIX tmp;

		MulMats(flip,matText_Anim,&tmp);
		MulMats(tmp,mat_otw,&anim_otw);

		gpd3dDev->SetVertexShader(FVF_xbt);

		gpd3dDev->SetTransform(D3DTS_WORLD,&anim_otw);
		gpd3dDev->SetStreamSource(0,pText_VB,sizeof(xbt_vertex));
		gpd3dDev->DrawIndexedVertices(D3DPT_TRIANGLELIST,nText_Indices,pText_Indices);

		gpd3dDev->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
	}

	gpd3dDev->SetRenderState(D3DRS_CULLMODE,D3DCULL_CCW);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\mslogo.h ===
#ifndef __MSLOGO_H__
#define __MSLOGO_H__

void WaitOnMicrosoftLogo();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\logo_renderer.h ===
///////////////////////////////////////////////////////////////////////////////
// File: logo_renderer.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef __LOGO_RENDERER_H__
#define __LOGO_RENDERER_H__

class LogoRenderer
{
private:

	LPDIRECT3DVERTEXBUFFER8  pLipVB;
	WORD                    *pLipIndices;
	DWORD					 nLipVerts;
	DWORD					 nLipIndices;		
	LPDIRECT3DTEXTURE8       pLipTex;

	LPDIRECT3DVERTEXBUFFER8  pSurfaceVB;
	WORD					*pSurfaceIndices;
	DWORD					 nSurfaceVerts;
	DWORD					 nSurfaceIndices;
	LPDIRECT3DTEXTURE8       pSurfaceTex;
	

	LPDIRECT3DVERTEXBUFFER8  pSurfaceTopVB;
	WORD					*pSurfaceTopIndices;
	DWORD					 nSurfaceTopVerts;
	DWORD					 nSurfaceTopIndices;
	LPDIRECT3DTEXTURE8       pSurfaceTopTex;

	LPDIRECT3DVERTEXBUFFER8  pInteriorVB;
	WORD					*pInteriorIndices;
	DWORD					 nInteriorVerts;
	DWORD					 nInteriorIndices;

	bool					 bRenderText;

	LPDIRECT3DVERTEXBUFFER8  pText_VB;
	WORD					*pText_Indices;
	DWORD					 nText_Verts;
	DWORD					 nText_Indices;
	D3DMATRIX				 matText_Anim;

	LPDIRECT3DVERTEXBUFFER8  pSlashTM_VB;
	WORD					*pSlashTM_Indices;
	DWORD					 nSlashTM_Verts;
	DWORD					 nSlashTM_Indices;

	LPDIRECT3DVERTEXBUFFER8  pTextTM_VB;
	WORD					*pTextTM_Indices;
	DWORD					 nTextTM_Verts;
	DWORD					 nTextTM_Indices;

	LPDIRECT3DTEXTURE8       pTMTex;
	float					 fTMAlpha;

	DWORD					 dwInteriorPShader;
	DWORD					 dwInteriorVShader;

	void createSlash();
	void createText();
	void createTMs();


	LPDIRECT3DTEXTURE8		pSlashTexture;
	bool					bHasWordmark;
	void createSlashSurface();	// don't call until camera is in final position


	// Decompressed slash data.
	WORD		* indices_xboxlogolip_0;
	float		* verts_xboxlogolip_0;
	WORD		* indices_xboxlogosurface_0;
	float		* verts_xboxlogosurface_0;
	WORD		* indices_xboxlogosurfacetop_0;
	float	    * verts_xboxlogosurfacetop_0;
	WORD        * indices_xboxlogointerior_0;
	float		* verts_xboxlogointerior_0;
	WORD		* indices_tm_wordmark_0;
	float		* verts_tm_wordmark_0;
	WORD		* indices_tm_slash_0;
	float		* verts_tm_slash_0;

	// Decompressed wordmark data.
	WORD		* indices_text_0;
	float		* verts_text_0;
	
	void decompressData();

	float * decompressPosData(short *pdata,int ncount,float f_oo_pos_scale,float f_pos_delta );
	float * decompressPosTexData(short *pdata,int ncount,float f_oo_pos_scale,float f_pos_delta,
														 float f_oo_tex_scale,float f_tex_delta );
	WORD  * decompressIndexData(char *pdata,int ncount);

public:

	void create();
	void destroy();

	void advanceTime(float fElapsedTime, float fDt);
	void render(const D3DMATRIX &mat_otw, bool b_force_3d_render = false);
};

#endif // __LOGO_RENDERER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\mslogo.cpp ===
#ifdef STARTUPANIMATION

#include "ntos.h"

#include "precomp.h"
#include "mslogo.h"
#include "renderer.h"
#include "xbs_app.h"
#include "xbs_math.h"

#pragma pack(1)

typedef struct _IMAGE_RUN1 {
    UINT fOne : 1;
    UINT Size : 3;
    UINT Intensity : 4;
} IMAGE_RUN1;

typedef struct _IMAGE_RUN2 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 10;
    UINT Intensity : 4;
} IMAGE_RUN2;

#pragma pack()

// MS Logo sync event
extern "C" {
INITIALIZED_KEVENT(g_EventLogo, NotificationEvent, FALSE);
INITIALIZED_KEVENT(g_EventLogoWaiting, NotificationEvent, FALSE);
}

IDirect3DVertexBuffer8 *g_pVBMicrosoftLogo;
IDirect3DTexture8* g_pTexMicrosoftLogo;
PBYTE g_ImageLogo;
UINT g_ImageLogoSize;

typedef struct _TheVerts {
    float x,y,z,w;
    float u, v;
} TheVerts;

const TheVerts Verts[] =
{
    {270.0f,  400.0f, 0.5f, 1.0f,   0.0f,   0.0f},
    {370.0f,  417.0f, 0.5f, 1.0f, 100.0f,  17.0f},
    {270.0f,  417.0f, 0.5f, 1.0f,   0.0f,  17.0f},
    {370.0f,  400.0f, 0.5f, 1.0f, 100.0f,   0.0f},
    {370.0f,  417.0f, 0.5f, 1.0f, 100.0f,  17.0f},
    {270.0f,  400.0f, 0.5f, 1.0f,   0.0f,   0.0f},
};

BOOL InitVB(IDirect3DDevice8 *pDev)
{
    IDirect3DVertexBuffer8 *pVB;
    void *pVerts;

    if (FAILED(IDirect3DDevice8_CreateVertexBuffer(pDev,
            sizeof(Verts),
            D3DUSAGE_WRITEONLY,
            D3DFVF_XYZRHW | D3DFVF_TEX1,
            D3DPOOL_MANAGED,
            &pVB)))
    {
        return FALSE;
    }

    g_pVBMicrosoftLogo = pVB;

    IDirect3DVertexBuffer8_Lock(pVB, 0, sizeof(Verts), (BYTE **)(&pVerts), 0);
    memcpy((void*)pVerts, (void*)Verts, sizeof(Verts));
    IDirect3DVertexBuffer8_Unlock(pVB);

    return TRUE;
}

const float F_15 = 15.0f;
const float F_P_5 = 0.5f;

COLORREF ColorFromIntensity(UINT intensity4bits)
{
    UINT Base = 0xCC;

    UINT cr = (UINT)((Base * intensity4bits) / F_15 + F_P_5);

    return D3DCOLOR_ARGB(0xFF, cr, cr, cr);
}

BOOL InitTexture(IDirect3DDevice8 *pDev)
{
    IDirect3DTexture8* pTex;
    D3DLOCKED_RECT lock;
    UINT x = 0, i, j;
    DWORD dwLine;
    DWORD dwAddr;
    IMAGE_RUN1 *pRun1;
    IMAGE_RUN2 *pRun2;
    UINT Size;
    UINT Intensity;

    if (FAILED(IDirect3DDevice8_CreateTexture(pDev,
            100,
            17,
            1,
            0,
            D3DFMT_LIN_X8R8G8B8,
            0,
            &pTex)))
    {
        return FALSE;
    }

    g_pTexMicrosoftLogo = pTex;

    IDirect3DTexture8_LockRect(pTex, 0, &lock, NULL, 0);
    dwLine = (DWORD)lock.pBits;
    dwAddr = dwLine;
    i = 0;

    while(i < g_ImageLogoSize)
    {
        Size = 0;
        Intensity = 0;

        pRun1 = (IMAGE_RUN1*)&g_ImageLogo[i];
        if (pRun1->fOne)
        {
            Size = pRun1->Size;
            Intensity = pRun1->Intensity;
            i += 1;
        }
        else
        {
            pRun2 = (IMAGE_RUN2*)&g_ImageLogo[i];
            if (pRun2->fTwo)
            {
                Size = pRun2->Size;
                Intensity = pRun2->Intensity;
                i += 2;
            }
        }

        for (j = 0; j < Size; j++)
        {
            if (Intensity == 0)
            {
                *(DWORD*)dwAddr = 0xFF000000;
            }
            else
            {
                *(DWORD*)dwAddr = ColorFromIntensity(Intensity);
            }
            if (x >= 99)
            {
                x = 0;
                dwLine += lock.Pitch;
                dwAddr = dwLine;
            }
            else
            {
                x++;
                dwAddr += sizeof(DWORD);
            }
        }
    }

    IDirect3DTexture8_UnlockRect(pTex, 0);

    return TRUE;
}

void UnInitMicrosoftLogo()
{
    if (g_ImageLogo != NULL)
    {
        MemFree(g_ImageLogo);
    }

    if (g_pVBMicrosoftLogo != NULL)
    {
        g_pVBMicrosoftLogo->Release();
    }

    if (g_pTexMicrosoftLogo != NULL)
    {
        g_pTexMicrosoftLogo->Release();
    }
}

void RenderMicrosoftLogo()
{
    if (g_ImageLogo == NULL)
    {
        return;
    }

    if (!InitVB(gpd3dDev) || !InitTexture(gpd3dDev))
    {
        UnInitMicrosoftLogo();
        return;
    }

    IDirect3DDevice8 *pDev = gpd3dDev;
    IDirect3DSurface8 *pSurface;
    pDev->GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pSurface);
    pDev->SetRenderTarget(pSurface, NULL);

    const DWORD RenderStates[] =
    {
        D3DRS_FILLMODE,         D3DFILL_SOLID,
        D3DRS_BACKFILLMODE,     D3DFILL_SOLID,
        D3DRS_CULLMODE,         D3DCULL_NONE,
        D3DRS_DITHERENABLE,     TRUE,
        D3DRS_ALPHATESTENABLE,  FALSE,
        D3DRS_ALPHABLENDENABLE, FALSE,
        D3DRS_FOGENABLE,        FALSE,
        D3DRS_EDGEANTIALIAS,    FALSE,
        D3DRS_STENCILENABLE,    FALSE,
        D3DRS_LIGHTING,         FALSE,
        D3DRS_MULTISAMPLEMASK,  0xffffffff,
        D3DRS_LOGICOP,          D3DLOGICOP_NONE,
        D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL,
        D3DRS_YUVENABLE,        FALSE,
    };
    
    const DWORD TextureStates[] =
    {
        D3DTSS_COLOROP,         D3DTOP_SELECTARG1,
        D3DTSS_COLORARG1,       D3DTA_TEXTURE,
        D3DTSS_ALPHAOP,         D3DTOP_DISABLE,
        D3DTSS_TEXCOORDINDEX,   0,
        D3DTSS_ADDRESSU,        D3DTADDRESS_CLAMP,
        D3DTSS_ADDRESSV,        D3DTADDRESS_CLAMP,
        D3DTSS_COLORKEYOP,      D3DTCOLORKEYOP_DISABLE,
        D3DTSS_COLORSIGN,       0,
        D3DTSS_ALPHAKILL,       D3DTALPHAKILL_DISABLE,
        D3DTSS_MINFILTER,       D3DTEXF_LINEAR,
        D3DTSS_MAGFILTER,       D3DTEXF_LINEAR,
    };

    int i;

    for (i = 0; i < sizeof(RenderStates) / (sizeof(DWORD) * 2); i++)
    {
        pDev->SetRenderState((D3DRENDERSTATETYPE)RenderStates[2*i],
                RenderStates[2*i + 1]);
    }

    for (i = 0; i < sizeof(TextureStates) / (sizeof(DWORD) * 2); i++)
    {
        pDev->SetTextureStageState(0,
                (D3DTEXTURESTAGESTATETYPE)TextureStates[2*i],
                TextureStates[2*i + 1]);
    }

    IDirect3DDevice8_SetStreamSource(pDev, 0, g_pVBMicrosoftLogo, sizeof(Verts[0]));
    IDirect3DDevice8_SetVertexShader(pDev, D3DFVF_XYZRHW | D3DFVF_TEX1);
    IDirect3DDevice8_SetTexture(pDev, 0, (D3DBaseTexture*)g_pTexMicrosoftLogo);

    IDirect3DDevice8_DrawPrimitive(pDev,
            D3DPT_TRIANGLELIST,
            0,
            2);

    pSurface->Release();
    UnInitMicrosoftLogo();
    pDev->PersistDisplay();
}

extern "C"
VOID AniSetLogo(PVOID pv, ULONG Size)
{
    if (KeReadStateEvent(&g_EventLogo) == 0)
    {
        if (gpd3dDev != NULL && pv != NULL && Size <= PAGE_SIZE)
        {
            g_ImageLogo = (PBYTE)MemAlloc(Size);
            if (g_ImageLogo != NULL)
            {
                memcpy(g_ImageLogo, pv, Size);
                g_ImageLogoSize = Size;
            }
        }

        KeSetEvent(&g_EventLogo, EVENT_INCREMENT, FALSE);
    }
}

void WaitOnMicrosoftLogo()
{
    // Signal the initialization thread that we're waiting for the logo.  Note
    // that this returns with the dispatcher database lock held, which the
    // following wait call will release.  This avoids an unnecessary context
    // switch.
    KeSetEvent(&g_EventLogoWaiting, EVENT_INCREMENT, TRUE);

    KeWaitForSingleObject(&g_EventLogo, Executive, KernelMode, FALSE, NULL);
    RenderMicrosoftLogo();
}

#endif // STARTUPANIMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\Pitches.h ===
#define	cc0 	0
#define	cs0		1
#define	dd0		2
#define	ds0		3
#define	ee0		4
#define	ff0		5
#define	fs0		6
#define	gg0		7
#define	gs0		8
#define	aa0		9
#define	as0		10
#define	bb0		11
#define	cc1		12

#define	cs1		13
#define	dd1		14
#define	ds1		15
#define	ee1		16
#define	ff1		17
#define	fs1		18
#define	gg1		19
#define	gs1		20
#define	aa1		21
#define	as1		22
#define	bb1		23
#define	cc2		24

#define	cs2		25
#define	dd2		26
#define	ds2		27
#define	ee2		28
#define	ff2		29
#define	fs2		30
#define	gg2		31
#define	gs2		32
#define	aa2		33
#define	as2		34
#define	bb2		35
#define	cc3		36

#define	cs3		37
#define	dd3		38
#define	ds3		39
#define	ee3		40
#define	ff3		41
#define	fs3		42
#define	gg3		43
#define	gs3		44
#define	aa3		45
#define	as3		46
#define	bb3		47
#define	cc4		48

#define	cs4		49
#define	dd4		50
#define	ds4		51
#define	ee4		52
#define	ff4		53
#define	fs4		54
#define	gg4		55
#define	gs4		56
#define	aa4		57
#define	as4		58
#define	bb4		59
#define	cc5		60

#define	cs5		61
#define	dd5		62
#define	ds5		63
#define	ee5		64
#define	ff5		65
#define	fs5		66
#define	gg5		67
#define	gs5		68
#define	aa5		69
#define	as5		70
#define	bb5		71
#define	cc6		72

#define	cs6		73
#define	dd6		74
#define	ds6		75
#define	ee6		76
#define	ff6		77
#define	fs6		78
#define	gg6		79
#define	gs6		80
#define	aa6		81
#define	as6		82
#define	bb6		83
#define	cc7		84

#define	cs7		85
#define	dd7		86
#define	ds7		87
#define	ee7		88
#define	ff7		89
#define	fs7		90
#define	gg7		91
#define	gs7		92
#define	aa7		93
#define	as7		94
#define	bb7		95
#define	cc8		96

#define	cs8		87
#define	dd8		88
#define	ds8		89
#define	ee8		90
#define	ff8		91
#define	fs8		92
#define	gg8		93
#define	gs8		94
#define	aa8		95
#define	as8		96
#define	bb8		97
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\PlacementDoodad.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: PlacementDoodad.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "defines.h"
#ifdef INCLUDE_PLACEMENT_DOODAD

#include "xbs_math.h"
#include "renderer.h"
#include "PlacementDoodad.h"
///////////////////////////////////////////////////////////////////////////////
#define FVF_xyzrgba (D3DFVF_XYZ|D3DFVF_DIFFUSE)
struct xyzrgba_vertex
{
	float x,y,z;
	DWORD diffuse;
};
///////////////////////////////////////////////////////////////////////////////
void PlacementDoodad::Init()
{
    m_pVB = NULL;
    m_pIB = NULL;
    m_dwNumVertices = 0;
    m_dwNumIndices = 0;
}
///////////////////////////////////////////////////////////////////////////////
void PlacementDoodad::create()
{
	m_dwNumVertices = 6;
	m_dwNumIndices = 6;
	
	gpd3dDev->CreateVertexBuffer(sizeof(xyzrgba_vertex) * m_dwNumVertices, NULL, FVF_xyzrgba,NULL, &m_pVB);
	gpd3dDev->CreateIndexBuffer(m_dwNumIndices, D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB);

	xyzrgba_vertex* p_vb;
	m_pVB->Lock(0, 0, (BYTE**) &p_vb, 0);

	int i;
	for (i=0; i<3; i++)
	{
		p_vb[2*i+0].x = (i==0) ? -100.0f : 0.0f;
		p_vb[2*i+1].x = (i==0) ? +100.0f : 0.0f;
		p_vb[2*i+0].y = (i==1) ? -100.0f : 0.0f;
		p_vb[2*i+1].y = (i==1) ? +100.0f : 0.0f;
		p_vb[2*i+0].z = (i==2) ? -100.0f : 0.0f;
		p_vb[2*i+1].z = (i==2) ? +100.0f : 0.0f;
		p_vb[2*i+0].diffuse = p_vb[2*i+1].diffuse = 0xFFFFFFFF;
	}

	m_pVB->Unlock();


	WORD* p_ib;
	m_pIB->Lock(0, 0, (BYTE**) &p_ib, 0);

	for (i=0; i<6; i++) p_ib[i] = (WORD)i;

	m_pIB->Unlock();
}
///////////////////////////////////////////////////////////////////////////////
void PlacementDoodad::destroy()
{
	m_pVB->Release();
	m_pIB->Release();
	m_pVB = NULL;
	m_pIB = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void PlacementDoodad::render(const D3DVECTOR* p_pos, const D3DMATRIX* view_mat, const D3DMATRIX* proj_mat)
{
    // Set default states
    gpd3dDev->SetRenderState( D3DRS_LIGHTING,			FALSE );
    gpd3dDev->SetRenderState( D3DRS_ZENABLE,			TRUE );
    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		FALSE );

	gpd3dDev->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_INVSRCALPHA );

	gpd3dDev->SetVertexShader(FVF_xyzrgba);

	D3DMATRIX iden;
	SetIdentity(&iden);
	*((D3DVECTOR*)(&iden._41)) = *p_pos;
	gpd3dDev->SetTransform(D3DTS_WORLD, &iden);

	if (view_mat) gpd3dDev->SetTransform(D3DTS_VIEW, view_mat);
	if (proj_mat) gpd3dDev->SetTransform(D3DTS_PROJECTION, proj_mat);
	
	gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,	D3DTOP_SELECTARG1);
	gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,	D3DTA_DIFFUSE);
	gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAOP,	D3DTOP_SELECTARG1);
	gpd3dDev->SetTextureStageState(0,D3DTSS_ALPHAARG1,	D3DTA_DIFFUSE);
	gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,	D3DTOP_DISABLE);

	gpd3dDev->SetIndices( m_pIB, 0 );
	gpd3dDev->SetStreamSource(0, m_pVB, sizeof(xyzrgba_vertex));
	gpd3dDev->DrawIndexedPrimitive(D3DPT_LINELIST, 0, m_dwNumVertices, 0, m_dwNumIndices / 2);

	gpd3dDev->SetPixelShader(NULL);
	gpd3dDev->SetVertexShader(NULL);

    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
	gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,	D3DTOP_DISABLE);
}
///////////////////////////////////////////////////////////////////////////////
#endif // INCLUDE_PLACEMENT_DOODAD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\PlacementDoodad.h ===
///////////////////////////////////////////////////////////////////////////////
// File: PlacementDoodad.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef __PLACEMENTDOODAD_H__
#define __PLACEMENTDOODAD_H__


#include "defines.h"

#ifdef INCLUDE_PLACEMENT_DOODAD


// Renders a visible item at a specific location.
   

class PlacementDoodad
{
protected:
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    LPDIRECT3DINDEXBUFFER8  m_pIB;
    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;


public:
	void Init();
	void UnInit()
    {
        destroy();
    }

	void create();
	void destroy();

	void render(const D3DVECTOR* p_pos, const D3DMATRIX* view_mat, const D3DMATRIX* proj_mat);
};


#endif // INCLUDE_PLACEMENT_DOODAD
#endif // __PLACEMENTDOODAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\prim_types.h ===
//
//	prim_types.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __PRIM_TYPES_H__
#define __PRIM_TYPES_H__


enum PrimitiveTypes
{
	pt_Sphere    = 0,
	pt_Cylinder  = 1,
	pt_Box       = 2,
	pt_Torus     = 3,
	pt_Cone      = 4,
	pt_SurfOfRev = 5,
	pt_NoTypes   = 6
};

const float OO_PRIM_TRANS_SCALE_X = 0.004131f;
const float OO_PRIM_TRANS_SCALE_Y = 0.008252f;
const float OO_PRIM_TRANS_SCALE_Z = 0.004421f;
const float PRIM_TRANS_DELTA_X =    -27.844984f;
const float PRIM_TRANS_DELTA_Y =    -0.228729f;
const float PRIM_TRANS_DELTA_Z =    0.497086f;

struct SphereInst
{
	short tx,ty,tz;
	char idVersion;
	char idPosAnim;
	char idRotAnim;
	float fRad;
};

struct SphereVers
{
	char nSegs;
};

struct CylinderInst
{
	char  idQuat;
	short tx,ty,tz;
	char  idVersion;
	char  idPosAnim;
	char  idRotAnim;
	float fRad;
	float fHalfHeight;
};

struct CylinderVers
{
	char nHeightSeg;
	char nSides;
};

struct BoxInst
{
	char  idQuat;
	short tx,ty,tz;
	char  idVersion;
	char  idPosAnim;
	char  idRotAnim;
	float fLen;
	float fHeight;
	float fWidth;
};

struct TorusInst
{
	char idQuat;
	short tx,ty,tz;
	char idVersion;
	char idPosAnim;
	char idRotAnim;
	float fRad1;
};

struct TorusVers
{
	float fRatio;
	char nSegs;
	char nSides;
};

struct ConeInst
{
	char idQuat;
	short tx,ty,tz;
	char idVersion;
	char idPosAnim;
	char idRotAnim;
};

struct ConeVers
{
	float fRad1;
	float fRad2;
	float fHeight;
	char nHeightSeg;
	char nSides;
};

#define MAX_SOR_PTS 19
struct SurfOfRevInst
{
	char idQuat;
	short tx,ty,tz;
	char idVersion;
	char idPosAnim;
	char idRotAnim;
};

struct SurfOfRevPt
{
	float x,y,z;
	char flags;
};

struct SurfOfRevVers
{
	SurfOfRevPt pts[MAX_SOR_PTS];
	float ax,ay,az;
	float px,py,pz;
	char nSegs;
	char nPts;
};

enum SurfOfRevPtFlags
{
	sr_Smooth = 1
};

#define MAX_POS_SAMPLES 30
#define NUM_POS_SEQ 32
const float OO_POS_ANIM_SCALE_X = 0.002755f;
const float OO_POS_ANIM_SCALE_Y = 0.002755f;
const float OO_POS_ANIM_SCALE_Z = 0.002440f;
const float POS_ANIM_DELTA_X = -0.159046f;
const float POS_ANIM_DELTA_Y = -0.741611f;
const float POS_ANIM_DELTA_Z = 2.155624f;

struct PosAnimSeq
{
	char posIds[MAX_POS_SAMPLES*3];
};

#define MAX_ROT_SAMPLES 30
#define NUM_ROT_SEQ 29
struct RotAnimSeq
{
	char quatIds[MAX_ROT_SAMPLES*3];
};

#endif // __PRIM_TYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\precomp.h ===
#pragma once

#ifdef STARTUPANIMATION

#pragma code_seg("INIT")
#pragma data_seg("INIT_RW")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

extern "C"
{
    #include <ntos.h>
    #include <nturtl.h>
};

#endif // STARTUPANIMATION

#include <xtl.h>
#include <xgraphics.h>

#include <stdio.h>

#ifdef _DEBUG
extern int gcMemAllocs;

#ifdef STARTUPANIMATION
extern "C" int gcMemAllocsContiguous;
#endif // STARTUPANIMATION
#endif

inline void* MemAlloc(UINT cBytes)
{
#ifdef _DEBUG
    gcMemAllocs++;
#endif

#ifndef STARTUPANIMATION
    void* p = LocalAlloc(LMEM_FIXED, cBytes);
    if (p)
    {
        ZeroMemory(p, cBytes);
    }
    return p;
#else // STARTUPANIMATION
    void* p = ExAllocatePoolWithTag(cBytes, 'KD3D');
    if (p)
    {
        // Last-minute hack to fix start-up animation hangs [andrewgo]
        ZeroMemory(p, cBytes);
    }
    return p;
#endif // STARTUPANIMATION
}

inline void* MemAllocNoZero(ULONG cBytes)
{
    return MemAlloc(cBytes);
}

inline void MemFree(void* pv)
{
#ifdef _DEBUG
    if (gcMemAllocs <= 0)
    {
        __asm int 3;
    }
    gcMemAllocs--;
#endif

#ifndef STARTUPANIMATION
    LocalFree(pv);
#else // STARTUPANIMATION
    ExFreePool(pv);
#endif // STARTUPANIMATION
}

#ifdef STARTUPANIMATION
extern "C"
void *MemAllocContiguous(size_t Size, DWORD Alignment);
extern "C"
void MemFreeContiguous(void *pv);
#endif // STARTUPANIMATION

#ifdef BINARY_RESOURCE
#include "shaders.h"
#endif // BINARY_RESOURCE

#include "fastmath.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\PROTOS.H ===
#ifndef _PROTOS_H_
#define _PROTOS_H_ 


init_track_status(uchar level, uchar channel);
remove_processes_by_level(uchar level);


void	do_sos_init_return();

void	sos_main(void);
void	sos_error(int);
int	create_process(ushort * p, uchar l, uchar c);
struct process * get_process_packet();
int	free_process_packet(struct process *pp);
struct track_info *get_track_info_block();
struct track_info *get_track_info_block2(uchar, uchar);
struct track_info *get_music_info_block();
struct track_info *get_music_info_block_i(uchar);
uchar	read_sound_call();
void	put_fifo(uchar);
void	nosound(uchar);
void	kill_process( struct process *pp);
uchar	get_fifo(void);
void do_volume_adjust(uchar volume,uchar level,uchar *patch_addr,uchar chan);
void	remove_processes_by_level_and_channel(uchar, uchar);
int	init_queuelist();
void	do_watchdog(void);


int	f_note(void);
int	f_rest(void);
int	f_jumpto(void);
int	f_loop(void);
int	f_endloop(void);
int	f_patch(void);
int	f_pan(void);
int	f_mux(void);
int	f_demux(void);
int	f_volume(void);
int	f_xpose(void);
int	f_xset(void);
int	f_slur(void);
int	f_ring(void);
int	f_clockset(void);
int	f_end(void);
int	f_filterset(void);
int	f_filterinc(void);


int	f_mark(void);
int	f_sound_call(void);
int	f_srest(void);
int	f_intvarset(void);
int	f_intvarinc(void);
int	f_user_1_var_evf(void);
int	f_user_2_var_evf(void);
int 	f_sig(void);
int	f_gliss(void);
int	f_clockinc(void);
int	f_paninc(void);
int 	f_musicclockinc(void);
int	f_MidiNoteOn(void);
int	f_MidiNoteOff(void);
int	f_MidiProgram(void);
int	f_MidiVolume(void);
int	f_MidiTempo(void);
int	f_MidiControl(void);
int	f_MidiEOT(void);

int	f_fxset(void);

void	call_silence(void);
void	call_music(void);
void	call_effect(void);
void	call_volume(void);
void	call_senddev(void);
void	call_mark(void);
void	call_ignore(void);
void	call_user_function(void);
void	call_timer(void);
void	call_end_timer(void);
void	call_play_timer(void);
void 	call_kill_effect(void);

#endif //protos_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\qrand.h ===
//
//	qrand.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __QRAND__
#define __QRAND__

class QRand
{
private:
	
	int seed;

public:
	
	void Init(int initSeed=0x76543210) { seed = initSeed; }
	void	SetSeed(int newSeed)   { seed = newSeed;  }
	int		Rand(int scale);	
	int		Rand();
};


#endif  //__QRAND__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\renderer.h ===
//
//	renderer.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __RENDERER_H__
#define __RENDERER_H__

///////////////////////////////////////////////////////////////////////////////
class Renderer
{
private:

	IDirect3D8				*pD3D8;
	IDirect3DDevice8		*pD3DDev8;
	D3DPRESENT_PARAMETERS	d3dPresentParams;

public:

	void Init();
	void UnInit();

	bool init(int width,int height);
	void shutdown();
};

extern IDirect3DDevice8 *gpd3dDev;
/////////////////////////////////////////////////////////////////////////////// 


#endif // __RENDERER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\qrand.cpp ===
//
//	qrand.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
#include "precomp.h"
#include "qrand.h"

int	QRand::Rand(int scale)
{
	_asm
	{
		mov		edi,this
		mov		eax,[edi]
		mov		ebx,eax
		ror		eax,13
		sub		ebx,11
		sub		eax,ebx
		mov		[edi],eax
		mul		scale
		mov		eax,edx
	}
}

int	QRand::Rand()
{

	_asm
	{
		mov		edi,this
		mov		eax,[edi]
		mov		ebx,eax
		ror		eax,13
		sub		ebx,11
		sub		eax,ebx
		mov		[edi],eax
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\PROC.C ===
/*************************************************************************
*                                                                        *
* 	Routines for process creation and control			  *
*                                                                        *
*************************************************************************/

#include "error.h"
#include "sos.h"
#include "protos.h"
#include "externs.h"

extern	int	(*event_fcns[])();

/*
 *	return a new process or NULL if error
 *	Put the process in the process queue
 */

struct process *pp;

int create_process(
ushort	*mem_ptr,			/* pointer to event list */
uchar	level,				/* sound level */
uchar	channel)			/* channel for this process */
{
 	struct process	*tpp;		

	pp = get_process_packet();

	pp->mem_ptr.i = mem_ptr;		/* get event-list pointer */
	pp->level = level;		/* get level		  */
	pp->timer = 0;		/* timer for process 	  */
	pp->hard_channel = channel;	/* get hardware channel   */
	pp->function = *mem_ptr;	/* get function byte	  */
	pp->type = 0;				/* clear type field			*/
	pp->prev = process_queue;	/* put process at head of q */

	if (level == 0)
		pp->prev_timer = system_clock_music;  /* make us current	  */
	else
		pp->prev_timer = system_clock_fx;  /* make us current	  */

	pp->next = tpp = process_queue->next;
	if (tpp != (struct process *)NULL) {
	    tpp->prev = pp;
	}
	process_queue->next = pp;
	return(1);
}

/*
 * 	remove a process from the process queue and free up the memory
 */

void kill_process(struct process *pp)
{
	pp->prev->next = pp->next;
	if (pp->next != (struct process *)NULL)
	   pp->next->prev = pp->prev;		/* remove ourselves */

	pp->next = queue_list[0].next;
	pp->prev = &(queue_list[0]);
/*	pp->function = 0;*/
	queue_list[0].next = pp;
	if (pp->next == (struct process *)NULL)
	    return;
	pp->next->prev = pp;
}

struct process *get_process_packet()
{
	struct process * pp;

	pp = queue_list[0].next;
	queue_list[0].next = pp->next;
	if (pp->next == (struct process *)NULL)
	    return(pp);
	pp->next->prev = &(queue_list[0]);
	return(pp);
}


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\renderer.cpp ===
//
//	renderer.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "renderer.h"
#include "xbs_app.h"

#ifdef STARTUPANIMATION
#include "mslogo.h"
extern "C" {
#include "av.h"
}
#endif // STARTUPANIMATION

IDirect3DDevice8 *gpd3dDev = NULL;
///////////////////////////////////////////////////////////////////////////////
void Renderer::Init()
{
	pD3D8 = NULL;
	pD3DDev8 = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void Renderer::UnInit()
{
}
///////////////////////////////////////////////////////////////////////////////
bool Renderer::init(int width,int height)
{
	pD3D8 = Direct3DCreate8(D3D_SDK_VERSION);
	if(!pD3D8)
		return false;

	const int size_mul = 2;
	const int kick_mul = 2;
	pD3D8->SetPushBufferSize(size_mul * 512 * 1024, kick_mul * 32 * 1024);


	ZeroMemory( &d3dPresentParams, sizeof(d3dPresentParams) );
    d3dPresentParams.BackBufferWidth        = width;
    d3dPresentParams.BackBufferHeight       = height;
    d3dPresentParams.BackBufferFormat       = D3DFMT_A8R8G8B8;
    d3dPresentParams.BackBufferCount        = 1;
    d3dPresentParams.EnableAutoDepthStencil = TRUE;
    d3dPresentParams.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dPresentParams.SwapEffect             = D3DSWAPEFFECT_DISCARD;
	d3dPresentParams.MultiSampleType        = D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR; 
//	d3dPresentParams.MultiSampleType        = D3DMULTISAMPLE_NONE; 

	// No VSync.
//	d3dPresentParams.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_IMMEDIATE;

    if (gApp.bWideScreen)
    {
        d3dPresentParams.Flags |= D3DPRESENTFLAG_WIDESCREEN;
    }

#ifdef STARTUPANIMATION
    // Always do interlaced output on an HDTV.
    ULONG AvInfo;
    AvSendTVEncoderOption(NULL, AV_QUERY_AV_CAPABILITIES, 0, &AvInfo);

    if ((AvInfo & AV_PACK_MASK) == AV_PACK_HDTV)
    {
        d3dPresentParams.Flags |= D3DPRESENTFLAG_INTERLACED;
    }
#endif 
    
	if( pD3D8->CreateDevice(D3DADAPTER_DEFAULT,
		                    D3DDEVTYPE_HAL,
						    NULL,
						    D3DCREATE_HARDWARE_VERTEXPROCESSING,
						    &d3dPresentParams,
						    &pD3DDev8 ) != D3D_OK )
	{
#ifndef STARTUPANIMATION
		OutputDebugString("Could not initalize Xbox Video!\n");
#endif // STARTUPANIMATION
		return false;
	}

	for( int i=0; i<4; i++ )
	{
		pD3DDev8->SetTextureStageState( i, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
		pD3DDev8->SetTextureStageState( i, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
		pD3DDev8->SetTextureStageState( i, D3DTSS_MIPFILTER, D3DTEXF_NONE );

		pD3DDev8->SetTextureStageState( i, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
		pD3DDev8->SetTextureStageState( i, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
		pD3DDev8->SetTextureStageState( i, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP );

		pD3DDev8->SetTextureStageState( i, D3DTSS_MAXANISOTROPY,4);
	}

	gpd3dDev = pD3DDev8;

#ifdef STARTUPANIMATION

    gpd3dDev->Clear(0,NULL,
                    D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET,
                    0x00000000,
                    1.f,
                    0 );

    gpd3dDev->Present(NULL,NULL,NULL,NULL);

    // This delay should allow the TV enough time to lock and ensure
    // that the picture doesn't roll on the first few frames of the
    // animation.

    for (i = 0; i < 4; i++)
    {
        gpd3dDev->BlockUntilVerticalBlank();
    }

#endif // STARTUPANIMATION

	return true;
}
///////////////////////////////////////////////////////////////////////////////
void Renderer::shutdown()
{
	if( pD3DDev8 )
	{
		pD3DDev8->Release();
		gpd3dDev = NULL;
	}

	if( pD3D8 )
	{
		pD3D8->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\scene_renderer.h ===
//
//	scene_renderer.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved

#ifndef __SCENE_RENDERER_H__
#define __SCENE_RENDERER_H__

#include "xbs_math.h"
#include "prim_types.h"

///////////////////////////////////////////////////////////////////////////////
enum ShaderTypes
{
	st_Phong		= 0,
	st_Bump			= 1,
	st_Depth		= 2,
	st_ShadowMap	= 3,
	st_NoTypes		= 4,
};
///////////////////////////////////////////////////////////////////////////////
struct BaseStream
{
	D3DVECTOR p;
};
///////////////////////////////////////////////////////////////////////////////
struct BumpStream
{
	FLOAT	  u,v;
	D3DVECTOR s;
	D3DVECTOR t;
	D3DVECTOR n;
};
///////////////////////////////////////////////////////////////////////////////
struct PhongStream
{
	D3DVECTOR s;
	D3DVECTOR t;
	D3DVECTOR n;
};
///////////////////////////////////////////////////////////////////////////////
struct PrimitiveVersionRecord
{
	DWORD		dwVertexStart;
	DWORD		dwVertexCount;
	DWORD		dwIndexStart;
	DWORD		dwPrimCount;
	DWORD		dwIndexCount;
	DWORD		dwParameter;
};
///////////////////////////////////////////////////////////////////////////////
struct PrimitiveInstanceRecord
{
	unsigned short		idxVersion;

	short				idxPosAnim;
	short				idxRotAnim;
	
	D3DMATRIX			matOffset;		
	D3DMATRIX           matInvOffset;
	
	D3DMATRIX			matScale;
	D3DVECTOR4          vObjScale;
	
	D3DMATRIX			matScaleOffset; 

	bool				bHiZ;
};
///////////////////////////////////////////////////////////////////////////////
class PrimitiveSet
{
private:
	
	LPDIRECT3DVERTEXBUFFER8    pBaseStream;
	LPDIRECT3DVERTEXBUFFER8    pExtraStream;

	LPDIRECT3DINDEXBUFFER8     pIB;

	PrimitiveVersionRecord	 * aVersRecs;
	int						   nVersions;

	PrimitiveInstanceRecord  * aInstRecs;
	int						   nInstances;

	D3DPRIMITIVETYPE           d3dType;
	

	LPDIRECT3DTEXTURE8         pNormalMap;
	LPDIRECT3DCUBETEXTURE8	   pCubeMap;

	D3DVECTOR4				   vAmbient;
	D3DVECTOR4                 vDiffuse;
	D3DVECTOR4                 vSpecular;

	DWORD					   dwPShader;
	DWORD					   dwVShader;

	ShaderTypes				   shaderType;
	PrimitiveTypes             primitiveType;
	bool					   bHiZ;


	void createSphereVersion(const SphereVers *psphere,
							 BYTE *pbase,BYTE *pextra,
							 unsigned short *pi,
							 int idx,int ndet_bias );

	void createCylinderVersion(const CylinderVers *pcyl,
							   BYTE *pbase,BYTE *pextra,
							   unsigned short *pi,
							   int idx,int ndet_bias );

	void createConeVersion(const ConeVers  * pcone,
		                   BYTE *pbase,BYTE *pextra,
						   unsigned short *pi,
						   int idx, int ndet_bias );

	void createBoxVersion(BYTE *pbase,BYTE *pextra,
		                  unsigned short *pi,
						  int idx );

	void createTorusVersion(const TorusVers  * ptorus,
		                    BYTE *pbase,BYTE *pextra,
							unsigned short *pi, 
							int idx,int ndet_bias );

	void createSurfOfRevVersion(const SurfOfRevVers *psurf,
		                        BYTE *pbase,BYTE *pextra,
								unsigned short *pi,
								int idx,int ndet_bias);
	
	void initSphereInstance( const SphereInst *psphere, int idx);
	void initCylinderInstance( const CylinderInst *pcyl, int idx);
	void initConeInstance(const ConeInst *pcone,int idx);
	void initBoxInstance(const BoxInst *pbox,int idx);
	void initTorusInstance(const TorusInst *ptorus,int idx);
	void initSurfOfRevInstance(const SurfOfRevInst *psurf,int idx);

	void initSphereVersion(const SphereVers *psphere,int idx,int ndet_bias);
	void initCylinderVersion(const CylinderVers *pcyl,int idx,int ndet_bias);
	void initConeVersion(const ConeVers *pcone,int idx,int ndet_bias);
	void initBoxVersion(int idx);
	void initTorusVersion(const TorusVers *ptorus,int idx,int ndet_bias);
	void initSurfOfRevVersion(const SurfOfRevVers *psurf,int idx,int ndet_bias);
	
public:

	void Init();
	void UnInit();

	void render(const D3DLIGHT8 &light,bool b_query_blob);
	void renderZ();
	void renderShadowMap(bool b_hi_z);

	void create( const void      *		version_data, 
				 int					num_versions, 
		         const void      *		instance_data,
				 int					num_insts,
				 int					ndet_bias,
				 ShaderTypes			shader,
				 PrimitiveTypes			primitive,
				 LPDIRECT3DTEXTURE8		pnormal_map,
				 LPDIRECT3DCUBETEXTURE8 pcubemap );
};
///////////////////////////////////////////////////////////////////////////////
class SceneRenderer 
{
protected:

	PrimitiveSet	  * pSetHiDet[pt_NoTypes];
	PrimitiveSet	  * pSetLoDet[pt_NoTypes];

	IDirect3DSurface8 * pSBufTarget;			


    IDirect3DSurface8 * pRenderTarget;
    IDirect3DSurface8 * pZBuffer;				  			

    D3DSurface			fakeTarget;

    float				fZOffset;				  
    float				fZSlopeScale;
	
	bool				bUseLoDetail;

	D3DVECTOR4 * decompressQuats(short *p_quat_data, DWORD *p_sign_data,int nquats);
	D3DVECTOR  * decompressVecs(short *p_vec_data, int nvecs);
	short      * decompressIndices(char *p_index_data,int nindices);
	void		 updateSBuffer(bool b_hi_z);

	void createSceneGeometry(PrimitiveSet **pp_sets,int ndet_bias);

public:

	D3DVECTOR4			*pQuats;
	short				*pQuatIdSeq[NUM_ROT_SEQ];

	D3DVECTOR			*pPos;
	short				*pPosIdSeq[NUM_POS_SEQ];

	IDirect3DTexture8	*pSBufDepthHi;           
	IDirect3DTexture8   *pSBufDepthLo;

	D3DMATRIX			matWTSHi;
	D3DMATRIX			matWTSLo;

	D3DMATRIX			*pRotAnims;
	int					nRotAnims;

	D3DVECTOR           *pPosAnims;
	int					nPosAnims;

	void create();
	void destroy();

	void render(bool b_with_shadows,bool b_use_blob_intensity);
	void renderZ();

	void advanceTime(float fElapsedTime, float fDt);
	void updateShadows();
};

#endif // __SCENE_RENDERER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\scene_renderer.cpp ===
//
//	scene_renderer.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "xbs_app.h"
#include "scene_renderer.h"
#include "scene_geometry.h"
#include "renderer.h"
#include "tex_gen.h"
	
const float LO_Z_VAL =   (00.f);
const float CEIL_Z =	   (40.f);
const float FLOOR_Z =    (-30.f);
#define SB_WIDTH   (512)
#define SB_HEIGHT  (512)


DWORD FtoDW(float f)
{
	return *((DWORD *)(&f));
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::Init()
{
	nInstances = 0;
	nVersions  = 0;

	aInstRecs = NULL;
	aVersRecs = NULL;
	
	pIB = NULL;
	pBaseStream = NULL;
	pExtraStream = NULL;
}

///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::UnInit()
{
	if( pBaseStream )
	{
		pBaseStream->Release();
		pBaseStream = NULL;
	}

	if( pExtraStream )
	{
		pExtraStream->Release();
		pExtraStream = NULL;
	}

	if( pIB )
	{
		pIB->Release();
		pIB = NULL;
	}

	if( aInstRecs )
	{
		MemFree(aInstRecs);
		aInstRecs = NULL;
	}

	if( aVersRecs )
	{
		MemFree(aVersRecs);
		aVersRecs = NULL;
	}

	nInstances = 0;
	nVersions  = 0;
}

///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createSphereVersion( const SphereVers  *psphere, 
									    BYTE *pbase, BYTE *pextra,
										unsigned short *pi,
										int idx,int ndet_bias )
{
	int nSegs   = (int) psphere->nSegs>>ndet_bias;
	int nSlices = (int) nSegs/2;

	float fDeltaTheta = (2.f*Pi)/((float)nSegs);
	float fDeltaPhi   = Pi/((float)nSlices-1);

	int i;

	BaseStream *pbase_stream = (BaseStream *)pbase;

	for(i = 0; i < nSlices; i++)
	{
		float fPhi = fDeltaPhi * ((float)i);

		float fSinPhi,fCosPhi;
		SinCos(fPhi,&fSinPhi,&fCosPhi);
		
		float fV = fPhi/Pi;

		for(int j = 0; j < nSegs; j++)
		{	
			float fTheta = fDeltaTheta * ((float)j);

			float fSinTheta,fCosTheta;
			SinCos(fTheta,&fSinTheta,&fCosTheta);

			Set(&pbase_stream->p,fCosPhi,fCosTheta * fSinPhi,fSinTheta * fSinPhi);
			
			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					Set( &pps->s, 0.f, -fSinTheta, fCosTheta );
					pps->n = pbase_stream->p;
					Cross( pps->s, pps->n, &pps->t );

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;
					
					Set( &pbs->s, 0.f, -fSinTheta, fCosTheta );
					pbs->n = pbase_stream->p;
					Cross( pbs->s, pbs->n, &pbs->t );
					
					pbs->u = fTheta / (2.f*Pi); 
					pbs->v = fV;

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream; 
		}
	}

	WORD wCurVert = (WORD)aVersRecs[idx].dwVertexStart;

	for(i = 0; i < nSlices - 1; i++)
	{
		WORD wStartVert = wCurVert;

		for(int j = 0; j < nSegs + 1; j++)
		{
			*pi++ = wCurVert + nSegs;
			*pi++ = wCurVert;

			if(j < nSegs - 1)
				++wCurVert;
			else
				wCurVert = wStartVert;
		}

		wCurVert += (WORD)nSegs;
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createCylinderVersion( const CylinderVers  * pcyl,
										  BYTE *pbase, BYTE *pextra,
										  unsigned short *pi, 
										  int idx,int ndet_bias)
{
	int nsides = pcyl->nSides>>ndet_bias;

	float fDeltaZ = 1.f/((float)pcyl->nHeightSeg);
	float fDeltaTheta = (2.f * Pi)/((float)nsides);

	D3DVECTOR *ppts = (D3DVECTOR*)MemAlloc(sizeof(D3DVECTOR)*(nsides+1));

	BaseStream *pbase_stream = (BaseStream *)pbase;
	
	int i;
	for(i = 0; i < nsides+1; i++)
	{
		float fTheta = fDeltaTheta * ((float)i);
		float fSinTheta,fCosTheta;

		SinCos(fTheta,&fSinTheta,&fCosTheta);
		
		Set( &ppts[i],fCosTheta,fSinTheta,fTheta/(2.f*Pi));
	}

	for(i = nsides-1; i >= 0; i--)
	{
		Set(&pbase_stream->p,ppts[i].x,ppts[i].y,1.f);
		
		switch(shaderType)
		{
		case st_Phong:
			{
				PhongStream *pps = (PhongStream *)pextra;
				
				Set(&pps->s,1.f,0.f,0.f);
				Set(&pps->t,0.f,1.f,0.f);
				Set(&pps->n,0.f,0.f,1.f);

				pextra += sizeof(PhongStream);
			}
			break;

		case st_Bump:
			{
				BumpStream *pbs = (BumpStream *)pextra;
				pbs->u = ppts[i].x + 0.5f;
				pbs->v = ppts[i].y + 0.5f;

				Set(&pbs->s,1.f,0.f,0.f);
				Set(&pbs->t,0.f,1.f,0.f);
				Set(&pbs->n,0.f,0.f,1.f);

				pextra += sizeof(BumpStream);
			}
			break;
		}

		++pbase_stream;
	}

	for(i = 0; i < nsides; i++)
	{
		Set(&pbase_stream->p,ppts[i].x,ppts[i].y,0.f);
		
		switch(shaderType)
		{
		case st_Phong:
			{
				PhongStream *pps = (PhongStream *)pextra;
				
				Set(&pps->s,1.f,0.f,0.f);
				Set(&pps->t,0.f,-1.f,0.f);
				Set(&pps->n,0.f,0.f,-1.f);

				pextra += sizeof(PhongStream);
			}
			break;

		case st_Bump:
			{
				BumpStream *pbs = (BumpStream *)pextra;
				pbs->u = ppts[i].x + 0.5f;
				pbs->v = ppts[i].y + 0.5f;

				Set(&pbs->s,1.f,0.f,0.f);
				Set(&pbs->t,0.f,-1.f,0.f);
				Set(&pbs->n,0.f,0.f,-1.f);

				pextra += sizeof(BumpStream);
			}
			break;
		}

		++pbase_stream;
	}

	for(i = 0; i < pcyl->nHeightSeg+1; i++)
	{
		float fZ = fDeltaZ * ((float)i);

		for(unsigned short j = 0; j < nsides+1; j++)
		{
			Set(&pbase_stream->p,ppts[j].x,ppts[j].y,fZ);
			
			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					Set(&pps->s,-ppts[j].y,ppts[j].x,0.f);
					Set(&pps->t,0.f,0.f,1.f);
					Set(&pps->n,ppts[j].x,ppts[j].y,0.f);

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					pbs->u = 4.0f * ppts[j].z;
					pbs->v = fZ * 32.0f;
		
					Set(&pbs->s,-ppts[j].y,ppts[j].x,0.f);
					Set(&pbs->t,0.f,0.f,1.f);
					Set(&pbs->n,ppts[j].x,ppts[j].y,0.f);

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream;
		}
	}

	MemFree(ppts);

	
	WORD wStartCap = (WORD)aVersRecs[idx].dwVertexStart;
	for(i = 0; i < nsides; i++)
	{
		*pi++ = wStartCap++;
	}

	for(i = 0; i < nsides; i++)
	{
		*pi++ = wStartCap++;
	}

	CreateTristripForMesh(pi, nsides, pcyl->nHeightSeg, false, false, wStartCap);
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createConeVersion( const ConeVers * pcone,
									  BYTE *pbase,BYTE *pextra,
									  unsigned short *pi, 
									  int idx,int ndet_bias )
{
	int nsides = pcone->nSides>>ndet_bias;

	float fDeltaTheta = (2.f * Pi)/((float)nsides);

	D3DVECTOR *ppts_bot = (D3DVECTOR*)MemAlloc(sizeof(D3DVECTOR)*(nsides+1));
	D3DVECTOR *ppts_top = (D3DVECTOR*)MemAlloc(sizeof(D3DVECTOR)*(nsides+1));

	BaseStream *pbase_stream = (BaseStream *)pbase;

	int i;
	for(i = 0; i < nsides+1; i++)
	{
		float fTheta = fDeltaTheta * ((float)i);
		float fSinTheta,fCosTheta;

		SinCos(fTheta,&fSinTheta,&fCosTheta);
		
		Set(&ppts_bot[i],fCosTheta * pcone->fRad1,fSinTheta * pcone->fRad1,fTheta/(2.f*Pi));
		Set(&ppts_top[i],fCosTheta * pcone->fRad2,fSinTheta * pcone->fRad2,fTheta/(2.f*Pi));
	}

	float fDeltaZ = 1.f/((float)(pcone->nHeightSeg));

	for(i = nsides-1; i >= 0; i--)
	{
		Set(&pbase_stream->p,ppts_top[i].x,ppts_top[i].y,pcone->fHeight);
		
		switch(shaderType)
		{
		case st_Phong:
			{
				PhongStream *pps = (PhongStream *)pextra;
				
				Set(&pps->s,1.f,0.f,0.f);
				Set(&pps->t,0.f,1.f,0.f);
				Set(&pps->n,0.f,0.f,1.f);

				pextra += sizeof(PhongStream);
			}
			break;

		case st_Bump:
			{
				BumpStream *pbs = (BumpStream *)pextra;
				pbs->u = ppts_top[i].x + 0.5f;
				pbs->v = ppts_top[i].y + 0.5f;

				Set(&pbs->s,1.f,0.f,0.f);
				Set(&pbs->t,0.f,1.f,0.f);
				Set(&pbs->n,0.f,0.f,1.f);

				pextra += sizeof(BumpStream);
			}
			break;
		}

		++pbase_stream;
	}

	for(i = 0; i < nsides; i++)
	{
		Set(&pbase_stream->p,ppts_bot[i].x,ppts_bot[i].y,0.f);
		
		switch(shaderType)
		{
		case st_Phong:
			{
				PhongStream *pps = (PhongStream *)pextra;
				
				Set(&pps->s,1.f,0.f,0.f);
				Set(&pps->t,0.f,-1.f,0.f);
				Set(&pps->n,0.f,0.f,-1.f);

				pextra += sizeof(PhongStream);
			}
			break;

		case st_Bump:
			{
				BumpStream *pbs = (BumpStream *)pextra;
				pbs->u = ppts_bot[i].x + 0.5f;
				pbs->v = ppts_bot[i].y + 0.5f;

				Set(&pbs->s,1.f,0.f,0.f);
				Set(&pbs->t,0.f,-1.f,0.f);
				Set(&pbs->n,0.f,0.f,-1.f);

				pextra += sizeof(BumpStream);
			}
			break;
		}

		++pbase_stream;
	}

	for(i = 0; i < pcone->nHeightSeg + 1; i++)
	{
		float fZ = fDeltaZ * ((float)i);

		for(unsigned short j = 0; j < nsides+1; j++)
		{	
			Set( &pbase_stream->p,
				 ppts_bot[j].x + fZ * ( ppts_top[j].x - ppts_bot[j].x ),
				 ppts_bot[j].y + fZ * ( ppts_top[j].y - ppts_bot[j].y ),
				 fZ * pcone->fHeight );


			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					Set(&pps->s, -ppts_top[j].y, ppts_top[j].x, 0.f );
					Normalize(&pps->s);
					Set(&pps->t,ppts_top[j].x - ppts_bot[j].x,ppts_top[j].y - ppts_bot[j].y,pcone->fHeight);
					Normalize(&pps->t);
					Cross(pps->s,pps->t,&pps->n);

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					Set(&pbs->s, -ppts_top[j].y, ppts_top[j].x, 0.f );
					Normalize(&pbs->s);
					Set(&pbs->t,ppts_top[j].x - ppts_bot[j].x,ppts_top[j].y - ppts_bot[j].y,pcone->fHeight);
					Normalize(&pbs->t);
					Cross(pbs->s,pbs->t,&pbs->n);

					pbs->u = ppts_top[j].z;
					pbs->v = fZ;

					pextra += sizeof(BumpStream);
				}
				break;
			}
			
			++pbase_stream;
		}
	}

	MemFree(ppts_bot);
	MemFree(ppts_top);
	

	WORD wStartCap = (WORD)aVersRecs[idx].dwVertexStart;
	for(i = 0; i < nsides; i++)
	{
		*pi++ = wStartCap++;
	}

	for(i = 0; i < nsides; i++)
	{
		*pi++ = wStartCap++;
	}	

	CreateTristripForMesh(pi, nsides, pcone->nHeightSeg, false, false, wStartCap);
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createBoxVersion( BYTE *pbase, BYTE *pextra,
									 unsigned short *pi,int idx)
{
	float fUV[4][2] = 
	{ 
		{ 0.f,1.f }, 
		{ 1.f,1.f }, 
		{ 1.f,0.f },
		{ 0.f,0.f } 
	};

	BaseStream *pbase_stream = (BaseStream *)pbase;

	for(int i = 0; i < 6; i++)
	{
		D3DVECTOR vS,vT,vN;
		D3DVECTOR vPos[4];

		switch(i)
		{
			case 0: 
			{
				Set(&vS,0.f,1.f,0.f);
				Set(&vT,0.f,0.f,1.f);
				Set(&vN,1.f,0.f,0.f);
				
				Set(&vPos[0],0.5f,-0.5f, 0.5f);
				Set(&vPos[1],0.5f, 0.5f, 0.5f);
				Set(&vPos[2],0.5f, 0.5f,-0.5f);
				Set(&vPos[3],0.5f,-0.5f,-0.5f);
				break;
			}
			case 1: 
			{
				Set(&vS,-1.f,0.f,0.f);
				Set(&vT, 0.f,0.f,1.f);
				Set(&vN, 0.f,1.f,0.f);
			
				Set(&vPos[0], 0.5f,0.5f, 0.5f);
				Set(&vPos[1],-0.5f,0.5f, 0.5f);
				Set(&vPos[2],-0.5f,0.5f,-0.5f);
				Set(&vPos[3], 0.5f,0.5f,-0.5f);
				break;
			}

			case 2: 
			{
				Set(&vS,0.f,-1.f,0.f);
				Set(&vT,0.f, 0.f,1.f);
				Set(&vN,0.f,-1.f,0.f);

				Set(&vPos[0],-0.5f, 0.5f, 0.5f);
				Set(&vPos[1],-0.5f,-0.5f, 0.5f);
				Set(&vPos[2],-0.5f,-0.5f,-0.5f);
				Set(&vPos[3],-0.5f, 0.5f,-0.5f);
				break;
			}

			case 3: 
			{
				Set(&vS,1.f, 0.f,0.f);
				Set(&vT,0.f, 0.f,1.f);
				Set(&vN,0.f,-1.f,0.f);

				Set(&vPos[0],-0.5f,-0.5f, 0.5f);
				Set(&vPos[1], 0.5f,-0.5f, 0.5f);
				Set(&vPos[2], 0.5f,-0.5f,-0.5f);
				Set(&vPos[3],-0.5f,-0.5f,-0.5f);
				break;
			}

			case 4: 
			{
				Set(&vS,1.f,0.f,0.f);
				Set(&vT,0.f,1.f,0.f);
				Set(&vN,0.f,0.f,1.f);

				Set(&vPos[0],-0.5f, 0.5f,0.5f);
				Set(&vPos[1], 0.5f, 0.5f,0.5f);
				Set(&vPos[2], 0.5f,-0.5f,0.5f);
				Set(&vPos[3],-0.5f,-0.5f,0.5f);
				break;
			}

			case 5: 
			{
				Set(&vS,1.f, 0.f, 0.f);
				Set(&vT,0.f,-1.f, 0.f);
				Set(&vN,0.f, 0.f,-1.f);

				Set(&vPos[0],-0.5f,-0.5f,-0.5f);
				Set(&vPos[1], 0.5f,-0.5f,-0.5f);
				Set(&vPos[2], 0.5f, 0.5f,-0.5f);
				Set(&vPos[3],-0.5f, 0.5f,-0.5f);
				break;
			}
		}

		for(int j = 0; j < 4; j++)
		{
			pbase_stream->p = vPos[j];
			
			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					pps->s = vS;
					pps->t = vT;
					pps->n = vN;

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					pbs->u = fUV[j][0];
					pbs->v = fUV[j][1];
					pbs->s = vS;
					pbs->t = vT;
					pbs->n = vN;

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream;
		}

		WORD wVertStart = i * 4;

		*pi++ = wVertStart;
		*pi++ = wVertStart+1;
		*pi++ = wVertStart+2;
		*pi++ = wVertStart;
		*pi++ = wVertStart+2;
		*pi++ = wVertStart+3;
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createTorusVersion( const TorusVers  * ptorus,
									   BYTE *pbase, BYTE *pextra,
									   unsigned short *pi, 
									   int idx,int ndet_bias)
{
	int nsegs = ptorus->nSegs>>ndet_bias;
	int nsides = ptorus->nSides>>ndet_bias;

	float fDeltaTheta = (2.f*Pi)/((float)nsegs);
	float fDeltaPhi   = (2.f*Pi)/((float)nsides);

	BaseStream *pbase_stream = (BaseStream *)pbase;

	int i;
	for(i = 0; i < nsides; i++)
	{
		float fPhi = fDeltaPhi * ((float)i);
		float fSinPhi,fCosPhi;

		SinCos(fPhi,&fSinPhi,&fCosPhi);

		float fRad = 1.f + (fCosPhi * ptorus->fRatio);
		float fV   = fPhi/(2.f * Pi);
		float fZ   = fSinPhi * ptorus->fRatio; 
		
		for(unsigned short j = 0; j < nsegs; j++)
		{
			float fTheta = fDeltaTheta * ((float)j);
			float fSinTheta,fCosTheta;

			SinCos(fTheta,&fSinTheta,&fCosTheta);

			Set(&pbase_stream->p,fCosTheta * fRad,fSinTheta * fRad,fZ);

			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					Set(&pps->s,-fSinTheta,fCosTheta,0.f);
					Set(&pps->t, fCosTheta * -fSinPhi,fSinTheta * -fSinPhi,fCosPhi);

					Cross(pps->s,pps->t,&pps->n);

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					pbs->u = fTheta/(2.f*Pi);
					pbs->v = fV;

					Set(&pbs->s,-fSinTheta,fCosTheta,0.f);
					Set(&pbs->t, fCosTheta * -fSinPhi,fSinTheta * -fSinPhi,fCosPhi);

					Cross(pbs->s,pbs->t,&pbs->n);

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream;
		}
	}

	WORD wVersionStart = (WORD)aVersRecs[idx].dwVertexStart;
	WORD wLoVert = wVersionStart;
	WORD wHiVert = wVersionStart + nsegs;

	for(i = 0; i < nsides; i++)
	{
		WORD wStripStartLo = wLoVert;
		WORD wStripStartHi = wHiVert;
		
		for(unsigned short j = 0; j < nsegs + 1; j++)
		{
			*pi++ = wLoVert;
			*pi++ = wHiVert;
			
			if(j < nsegs - 1)
			{
				++wLoVert;
				++wHiVert;
			}
			else
			{
				wLoVert = wStripStartLo;
				wHiVert = wStripStartHi;
			}
		}

		wLoVert += (WORD)nsegs;

		if ( (i+1) < (nsides - 1) )
		{
			wHiVert += (WORD)nsegs;
		}
		else
		{
			wHiVert = wVersionStart;	
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::createSurfOfRevVersion( const SurfOfRevVers  * psurf,
										   BYTE *pbase, BYTE *pextra, 
										   unsigned short *pi, 
										   int idx,int ndet_bias )
{		
	DWORD dwPolyPts = psurf->nPts;
	for (int i = 0; i < psurf->nPts; i++)
	{
		if (!(psurf->pts[i].flags & sr_Smooth))
			++dwPolyPts;
	}

	D3DVECTOR *pSegNorms = (D3DVECTOR *) _alloca(dwPolyPts * sizeof(D3DVECTOR));
	D3DVECTOR *pVerts    = (D3DVECTOR *) _alloca(dwPolyPts * sizeof(D3DVECTOR));

	enum NormalCalcFlags
	{
		nf_PrevSeg,	
		nf_NextSeg, 
		nf_BothSeg  
	};

	DWORD * dwVertFlags = (DWORD *)_alloca(dwPolyPts * sizeof(DWORD));

	D3DVECTOR vAxis;
	D3DVECTOR ptOnAxis;

	Set(&vAxis,psurf->ax,psurf->ay,psurf->az);
	Set(&ptOnAxis,psurf->px,psurf->py,psurf->pz);

	int ntot = 0;
	for (i = 0; i < psurf->nPts; i++)
	{
		Set(&pVerts[ntot],psurf->pts[i].x,psurf->pts[i].y,psurf->pts[i].z); 

		if (!(psurf->pts[i].flags & sr_Smooth))
		{
			dwVertFlags[ntot] = nf_PrevSeg;
			Set(&pSegNorms[ntot],0.f,0.f,0.f);
			ntot++;
			
			Set(&pVerts[ntot],psurf->pts[i].x,psurf->pts[i].y,psurf->pts[i].z); 
			dwVertFlags[ntot] = nf_NextSeg;
		}
		else 
		{
			dwVertFlags[ntot] = nf_BothSeg;
		}

		DWORD dwNextVert = i + 1;
		if(dwNextVert == psurf->nPts)
			dwNextVert = 0;

		D3DVECTOR seg;
		Set(&seg, psurf->pts[dwNextVert].x - psurf->pts[i].x,
			      psurf->pts[dwNextVert].y - psurf->pts[i].y,
				  psurf->pts[dwNextVert].z - psurf->pts[i].z );

		D3DVECTOR axisToPt;
		Set(&axisToPt,psurf->pts[dwNextVert].x - ptOnAxis.x,
					  psurf->pts[dwNextVert].y - ptOnAxis.y,
					  psurf->pts[dwNextVert].z - ptOnAxis.z );

		D3DVECTOR tang;
		Cross( vAxis,axisToPt,&tang );
		Cross( tang, seg, &pSegNorms[ntot] );
		Normalize(&pSegNorms[ntot]);

		ntot++;
	}

	D3DVECTOR *pVertNorms = (D3DVECTOR *) _alloca(dwPolyPts * sizeof(D3DVECTOR));
	for (i = 0; i < (int)dwPolyPts; i++)
	{
		switch(dwVertFlags[i])
		{
			case nf_PrevSeg:
				pVertNorms[i] = pSegNorms[(i + dwPolyPts - 1) % dwPolyPts];
				break;

			case nf_NextSeg:
				pVertNorms[i] = pSegNorms[i];
				break;

			case nf_BothSeg:
				Add( pSegNorms[(i + dwPolyPts - 1) % dwPolyPts], pSegNorms[i], &pVertNorms[i] );
				Normalize(&pVertNorms[i]);
				break;
		}
	}

	int nsegs = psurf->nSegs>>ndet_bias;

	float fDeltaTheta = (2.f * Pi)/((float)nsegs);
	float fDeltaV     = 1.f/((float)psurf->nPts-1);

	BaseStream *pbase_stream = (BaseStream *)pbase;

	for (i = 0; i < (nsegs+1); i++)
	{
		float fTheta = fDeltaTheta * ((float)i);
		
		D3DVECTOR4 quat;
		SetQuatFromAxis(vAxis,fTheta,&quat);

		D3DMATRIX rotMat;
		SetRotationFromRHQuat(quat,&rotMat);

		float fU = fTheta/(2.f * Pi);

		unsigned unique_vert_count = 0;
		for (unsigned int j = 0; j < dwPolyPts; j++)
		{
			float fV = fDeltaV * ((float)unique_vert_count);

			if(dwVertFlags[j] != nf_PrevSeg)
				++unique_vert_count;

			D3DVECTOR pt;
			Sub(pVerts[j],ptOnAxis,&pt);
			TransformVector(pt,rotMat,&pbase_stream->p);
			
			pbase_stream->p.x += ptOnAxis.x;
			pbase_stream->p.y += ptOnAxis.y;
			pbase_stream->p.z += ptOnAxis.z;

			switch(shaderType)
			{
			case st_Phong:
				{
					PhongStream *pps = (PhongStream *)pextra;
					
					D3DVECTOR tang;
					Cross(vAxis,pt,&tang);
					TransformVector(tang,rotMat,&pps->s);
					Normalize(&pps->s);

					TransformVector(pVertNorms[j],rotMat,&pps->n);
					Cross(pps->n,pps->s,&pps->t);

					pextra += sizeof(PhongStream);
				}
				break;

			case st_Bump:
				{
					BumpStream *pbs = (BumpStream *)pextra;

					D3DVECTOR tang;
					Cross(vAxis,pt,&tang);
					TransformVector(tang,rotMat,&pbs->s);
					Normalize(&pbs->s);

					TransformVector(pVertNorms[j],rotMat,&pbs->n);
					Cross(pbs->n,pbs->s,&pbs->t);

					pbs->u = fU * 10.f;
					pbs->v = fV * 10.f;

					pextra += sizeof(BumpStream);
				}
				break;
			}

			++pbase_stream;
		}
	}

	WORD wLeftVert  = (WORD)aVersRecs[idx].dwVertexStart;
	WORD wRightVert = (WORD)(wLeftVert + dwPolyPts);

	for (i = 0; i < nsegs; i++)
	{
		WORD wStartStripRight = wRightVert;
		WORD wStartStripLeft  = wLeftVert;

		for (unsigned int j = 0; j < dwPolyPts + 1; j++)
		{
			*pi++ = wRightVert;
			*pi++ = wLeftVert;

			if( j < dwPolyPts - 1 )
			{
				++wRightVert;
				++wLeftVert;
			}
			else
			{
				wRightVert = wStartStripRight;
				wLeftVert  = wStartStripLeft;
			}
		}

		wLeftVert = wRightVert;
		wRightVert += (WORD)dwPolyPts;
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initSphereInstance(const SphereInst *psphere, int idx)
{
	SetScale( psphere->fRad, psphere->fRad, psphere->fRad, &aInstRecs[idx].matScale );
	Set( &aInstRecs[idx].vObjScale,psphere->fRad,psphere->fRad,psphere->fRad,1.f );
	
	SetIdentity( &aInstRecs[idx].matOffset );
	aInstRecs[idx].matOffset._41 = ((float)psphere->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)psphere->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)psphere->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;

	SetIdentity(&aInstRecs[idx].matInvOffset);
	aInstRecs[idx].matInvOffset._41 = -(((float)psphere->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X);
	aInstRecs[idx].matInvOffset._42 = -(((float)psphere->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y);
	aInstRecs[idx].matInvOffset._43 = -(((float)psphere->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z);

	MulMats(aInstRecs[idx].matScale,aInstRecs[idx].matOffset,&aInstRecs[idx].matScaleOffset);

	aInstRecs[idx].idxVersion = psphere->idVersion;

	aInstRecs[idx].idxPosAnim = psphere->idPosAnim;
	aInstRecs[idx].idxRotAnim = psphere->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initCylinderInstance( const CylinderInst *pcyl, int idx )
{
	SetScale(pcyl->fRad,pcyl->fRad,pcyl->fHalfHeight*2.f,&aInstRecs[idx].matScale);
	Set(&aInstRecs[idx].vObjScale,pcyl->fRad,pcyl->fRad,pcyl->fHalfHeight*2.f,1.f);


	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[pcyl->idQuat],&aInstRecs[idx].matOffset);
	aInstRecs[idx].matOffset._41 = ((float)pcyl->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)pcyl->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)pcyl->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);

	MulMats(aInstRecs[idx].matScale,aInstRecs[idx].matOffset,&aInstRecs[idx].matScaleOffset);

	aInstRecs[idx].idxVersion = pcyl->idVersion;

	aInstRecs[idx].idxPosAnim = pcyl->idPosAnim;
	aInstRecs[idx].idxRotAnim = pcyl->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initConeInstance( const ConeInst *pcone, int idx )
{
	SetScale(1.f,1.f,1.f,&aInstRecs[idx].matScale);
	Set(&aInstRecs[idx].vObjScale,1.f,1.f,1.f,1.f);

	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[pcone->idQuat],&aInstRecs[idx].matOffset);
	aInstRecs[idx].matOffset._41 = ((float)pcone->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)pcone->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)pcone->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);
	
	aInstRecs[idx].matScaleOffset = aInstRecs[idx].matOffset;

	aInstRecs[idx].idxVersion = pcone->idVersion;

	aInstRecs[idx].idxPosAnim = pcone->idPosAnim;
	aInstRecs[idx].idxRotAnim = pcone->idRotAnim;


	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initBoxInstance( const BoxInst *pbox, int idx )
{
	SetScale(pbox->fWidth,pbox->fLen,pbox->fHeight,&aInstRecs[idx].matScale);
	Set(&aInstRecs[idx].vObjScale,pbox->fWidth,pbox->fLen,pbox->fHeight,1.f);	

	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[pbox->idQuat],&aInstRecs[idx].matOffset);
	aInstRecs[idx].matOffset._41 = ((float)pbox->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)pbox->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)pbox->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;	
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);
	
	MulMats(aInstRecs[idx].matScale,aInstRecs[idx].matOffset,&aInstRecs[idx].matScaleOffset);

	aInstRecs[idx].idxVersion = 0;

	aInstRecs[idx].idxPosAnim = pbox->idPosAnim;
	aInstRecs[idx].idxRotAnim = pbox->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initTorusInstance( const TorusInst *ptorus, int idx )
{	
	SetScale( ptorus->fRad1, ptorus->fRad1, ptorus->fRad1, &aInstRecs[idx].matScale );
	Set(&aInstRecs[idx].vObjScale,ptorus->fRad1,ptorus->fRad1,ptorus->fRad1,1.f);

	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[ptorus->idQuat],&aInstRecs[idx].matOffset);		
	aInstRecs[idx].matOffset._41 = ((float)ptorus->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)ptorus->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)ptorus->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);

	MulMats(aInstRecs[idx].matScale,aInstRecs[idx].matOffset,&aInstRecs[idx].matScaleOffset);

	aInstRecs[idx].idxVersion = ptorus->idVersion;

	aInstRecs[idx].idxPosAnim = ptorus->idPosAnim;
	aInstRecs[idx].idxRotAnim = ptorus->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initSurfOfRevInstance( const SurfOfRevInst *psurf, int idx )
{
	SetScale(1.f,1.f,1.f,&aInstRecs[idx].matScale);
	Set( &aInstRecs[idx].vObjScale, 1.f,1.f,1.f,1.f );

	SetRotationFromLHQuat(gApp.sceneGeom.pQuats[psurf->idQuat],&aInstRecs[idx].matOffset);
	aInstRecs[idx].matOffset._41 = ((float)psurf->tx) * OO_PRIM_TRANS_SCALE_X + PRIM_TRANS_DELTA_X;
	aInstRecs[idx].matOffset._42 = ((float)psurf->ty) * OO_PRIM_TRANS_SCALE_Y + PRIM_TRANS_DELTA_Y;
	aInstRecs[idx].matOffset._43 = ((float)psurf->tz) * OO_PRIM_TRANS_SCALE_Z + PRIM_TRANS_DELTA_Z;
	SetInverse(aInstRecs[idx].matOffset,&aInstRecs[idx].matInvOffset);
	
	aInstRecs[idx].matScaleOffset = aInstRecs[idx].matOffset;

	aInstRecs[idx].idxVersion = psurf->idVersion;

	aInstRecs[idx].idxPosAnim = psurf->idPosAnim;
	aInstRecs[idx].idxRotAnim = psurf->idRotAnim;

	SceneRenderer &scene = gApp.sceneGeom;

	D3DVECTOR v;
	Set(&v,aInstRecs[idx].matOffset._41,aInstRecs[idx].matOffset._42,aInstRecs[idx].matOffset._43);

	if(aInstRecs[idx].idxRotAnim >= 0)
	{
		D3DVECTOR tmp = v;
		D3DVECTOR4 &q = scene.pQuats[scene.pQuatIdSeq[aInstRecs[idx].idxRotAnim][0]];
		
		D3DMATRIX mat;
		SetRotationFromLHQuat(q,&mat);

		TransformVector(tmp,mat,&v);
	}
	if(aInstRecs[idx].idxPosAnim >= 0)
	{
		v.x += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].x;
		v.y += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].y;
		v.z += scene.pPos[scene.pPosIdSeq[aInstRecs[idx].idxPosAnim][0]].z;
	}

	aInstRecs[idx].bHiZ = v.z > LO_Z_VAL;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initSphereVersion(const SphereVers *psphere, int idx,int ndet_bias)
{
	DWORD dwSegs   = psphere->nSegs>>ndet_bias;
	DWORD dwSlices = dwSegs/2;

	aVersRecs[idx].dwVertexCount = dwSegs * dwSlices; 
	aVersRecs[idx].dwPrimCount   = (dwSlices-1) * (dwSegs+1) * 2 - 2;
	aVersRecs[idx].dwIndexCount  = aVersRecs[idx].dwPrimCount + 2;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initCylinderVersion(const CylinderVers *pcyl, int idx,int ndet_bias)
{
	int nsides = pcyl->nSides>>ndet_bias;

	aVersRecs[idx].dwVertexCount = (nsides+1) * (pcyl->nHeightSeg+1) + (nsides+1) * 2;
	aVersRecs[idx].dwPrimCount   = 0;
	aVersRecs[idx].dwIndexCount  = 2*nsides + GetNumberOfIndicesForTristripMesh(nsides, pcyl->nHeightSeg);
	aVersRecs[idx].dwParameter   = nsides;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initConeVersion(const ConeVers *pcone,int idx,int ndet_bias)
{
	int nsides = pcone->nSides>>ndet_bias;

	aVersRecs[idx].dwVertexCount = (nsides+1) * (pcone->nHeightSeg+1) + (nsides+1) * 2;
	aVersRecs[idx].dwPrimCount   = 0;
	aVersRecs[idx].dwIndexCount  = 2*nsides + GetNumberOfIndicesForTristripMesh(nsides, pcone->nHeightSeg);
	aVersRecs[idx].dwParameter   = nsides;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initBoxVersion( int idx )
{
	aVersRecs[idx].dwVertexCount = 24;
	aVersRecs[idx].dwPrimCount   = 12;
	aVersRecs[idx].dwIndexCount  = 36;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initTorusVersion(const TorusVers *ptorus,int idx,int ndet_bias)
{
	int nsides = ptorus->nSides>>ndet_bias;
	int nsegs = ptorus->nSegs>>ndet_bias;

	aVersRecs[idx].dwVertexCount = nsegs * nsides; 
	aVersRecs[idx].dwPrimCount   = (nsegs + 1) * nsides * 2 - 2;
	aVersRecs[idx].dwIndexCount  = aVersRecs[idx].dwPrimCount + 2;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::initSurfOfRevVersion(const SurfOfRevVers *psurf,int idx,int ndet_bias)
{
	DWORD dwDupVerts = 0;

	for (unsigned short i = 0; i < psurf->nPts; i++)
	{
		if (!(psurf->pts[i].flags & sr_Smooth))
			++dwDupVerts;
	}

	int nsegs = psurf->nSegs>>ndet_bias;

	aVersRecs[idx].dwVertexCount = (dwDupVerts + psurf->nPts) * (nsegs+1);
	aVersRecs[idx].dwPrimCount   = (psurf->nPts + dwDupVerts +1) * 2 * nsegs - 2;
	aVersRecs[idx].dwIndexCount  = aVersRecs[idx].dwPrimCount + 2;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::renderZ()
{
	ShaderTypes shader = shaderType;
	shaderType = st_Depth;
	
	render(gApp.blobLight,false);
	
	shaderType = shader;
}

///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::renderShadowMap(bool b_hi_z)
{
	ShaderTypes shader = shaderType;
	shaderType = st_ShadowMap;
	
	bHiZ = b_hi_z;
	
	render(gApp.blobLight,false);
	
	shaderType = shader;
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::render( const D3DLIGHT8 &light,bool b_query_blob )
{
	gpd3dDev->SetStreamSource( 0, pBaseStream, sizeof(BaseStream) );
	gpd3dDev->SetIndices( pIB, 0 );

	bool b_no_lighting = false;

	switch( shaderType )
	{
	case st_Bump:
		{
			gpd3dDev->SetTexture(0,pNormalMap);
			gpd3dDev->SetTexture(1,pCubeMap);
			gpd3dDev->SetTexture(2,pCubeMap);
			
			gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC);
			gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC);
			gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
			gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
			gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
			gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSW,  D3DTADDRESS_WRAP );

			gpd3dDev->SetStreamSource( 1, pExtraStream, sizeof(BumpStream) );
			gpd3dDev->SetVertexShader(gApp.dwVShader[st_Bump]);
			gpd3dDev->SetPixelShader (gApp.dwPShader[st_Bump]);
		}
		break;

	case st_Phong:
		{
			gpd3dDev->SetTexture(1,pCubeMap);
			gpd3dDev->SetTexture(2,pCubeMap);
			gpd3dDev->SetStreamSource( 1, pExtraStream, sizeof(PhongStream) );
			gpd3dDev->SetVertexShader( gApp.dwVShader[st_Phong] );
			gpd3dDev->SetPixelShader ( gApp.dwPShader[st_Phong] );
		}
		break;

	case st_Depth:
		{
			b_no_lighting = true;
		}
		break;

	case st_ShadowMap:
		{
			b_no_lighting = true;
			gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
			gpd3dDev->SetRenderState( D3DRS_ZENABLE,			TRUE );
		}
		break;
	}

	D3DVECTOR4 light_val[3];

	if( !b_query_blob  && !b_no_lighting)
	{
		Set(&light_val[0],vAmbient.x * light.Ambient.r,
						  vAmbient.y * light.Ambient.g,
						  vAmbient.z * light.Ambient.b, 1.f );

		Set(&light_val[1],vDiffuse.x * light.Diffuse.r,
						  vDiffuse.y * light.Diffuse.g,
						  vDiffuse.z * light.Diffuse.b, 1.f );

		Set(&light_val[2],vSpecular.x * light.Specular.r,
						  vSpecular.y * light.Specular.g,
						  vSpecular.z * light.Specular.b, 1.f );

		gpd3dDev->SetPixelShaderConstant ( 0,(CONST void *)&light_val, 3 );

		D3DVECTOR4 vAtten;
		Set(&vAtten,light.Attenuation0,light.Attenuation1,light.Attenuation2, 1.f );
		gpd3dDev->SetVertexShaderConstant( 7, (CONST void *)&vAtten,1 );	
	}

	const D3DMATRIX  &matWTP = gApp.theCamera.getWTP();

	SceneRenderer & scene = gApp.sceneGeom;

	for(int i = 0; i < nInstances; i++)
	{
		const PrimitiveInstanceRecord &inst = aInstRecs[i];

		D3DMATRIX world_mat;
		D3DMATRIX inv_world_mat;
		
		if (inst.idxPosAnim >= 0 || inst.idxRotAnim >= 0)
		{
			D3DMATRIX tmp;
			if(inst.idxRotAnim >= 0)
			{
			
				MulMats( inst.matOffset,scene.pRotAnims[inst.idxRotAnim], &tmp );
			}
			else
			{
				tmp = inst.matOffset;
			}

			if(inst.idxPosAnim >= 0)
			{
				tmp._41 += scene.pPosAnims[inst.idxPosAnim].x;
				tmp._42 += scene.pPosAnims[inst.idxPosAnim].y;
				tmp._43 += scene.pPosAnims[inst.idxPosAnim].z;
			}
			

			SetInverse(tmp,&inv_world_mat);
			MulMats(inst.matScale,tmp,&world_mat);
		}
		else
		{
			world_mat = inst.matScaleOffset;
			inv_world_mat = inst.matInvOffset;
		}

		if(shaderType == st_ShadowMap)
		{
			if(inst.bHiZ != bHiZ)
				continue;

			gpd3dDev->SetTransform(D3DTS_WORLD,&world_mat);
		}
		else
		{
			D3DMATRIX matTmp,matFinal;

			MulMats(world_mat,matWTP,&matTmp);
			SetTranspose(matTmp,&matFinal);

			gpd3dDev->SetVertexShaderConstant(0,&matFinal,4);
		}

		D3DVECTOR4 vObjEyePos;
		D3DVECTOR4 vObjLightPos;

		if( b_query_blob && !b_no_lighting )
		{
			D3DVECTOR4 tmp;

			float fIntensity;

			tmp.w = 1.0f;
			gApp.vblob.getLightForPosition(&tmp,&fIntensity,*((D3DVECTOR *) &world_mat._41));
			
			fIntensity = gApp.getBlobIntensity() * 2.f ;

			Set(&light_val[0],vAmbient.x * light.Ambient.r * fIntensity,
							  vAmbient.y * light.Ambient.g * fIntensity,
							  vAmbient.z * light.Ambient.b * fIntensity, 1.f );
		
			Set(&light_val[1],vDiffuse.x * light.Diffuse.r * fIntensity,
							  vDiffuse.y * light.Diffuse.g * fIntensity,
							  vDiffuse.z * light.Diffuse.b * fIntensity, 1.f );

  			Set(&light_val[2],vSpecular.x * light.Specular.r * fIntensity,
							  vSpecular.y * light.Specular.g * fIntensity,
							  vSpecular.z * light.Specular.b * fIntensity, 1.f );


			gpd3dDev->SetPixelShaderConstant ( 0,(CONST void *)&light_val, 3 );

			TransformPoint( tmp, inv_world_mat, &vObjLightPos);

			D3DVECTOR4 vAtten;

			float f_oo_intensity = 1.f/fIntensity;
			Set(&vAtten,light.Attenuation0,light.Attenuation1 * f_oo_intensity, 
										   light.Attenuation2 * f_oo_intensity, 1.f );
			gpd3dDev->SetVertexShaderConstant( 7, (CONST void *)&vAtten,1 );
		}
		else if(shaderType != st_ShadowMap && shaderType != st_Depth)
		{
			TransformPoint( light.Position, inv_world_mat, &vObjLightPos);	
		}
		
		if( shaderType != st_ShadowMap && shaderType != st_Depth )
		{
			vObjLightPos.w = 1.f;
			gpd3dDev->SetVertexShaderConstant(4,&vObjLightPos,1);

			TransformPoint(*((D3DVECTOR *)&gApp.theCamera.matCTW._41),inv_world_mat,&vObjEyePos);
			vObjEyePos.w = 1.f;
		
			gpd3dDev->SetVertexShaderConstant(5,&vObjEyePos,1);
			gpd3dDev->SetVertexShaderConstant(6,&inst.vObjScale,1);

			D3DMATRIX matOTS,finalSMat;
			MulMats(world_mat, (inst.bHiZ) ? scene.matWTSHi : scene.matWTSLo , &matOTS );
			SetTranspose(matOTS,&finalSMat);
			gpd3dDev->SetVertexShaderConstant(8,&finalSMat,4);

			gpd3dDev->SetTexture(3,(inst.bHiZ) ? scene.pSBufDepthHi: scene.pSBufDepthLo );
		}
		
		const PrimitiveVersionRecord &vs = aVersRecs[aInstRecs[i].idxVersion];

		if ((primitiveType==pt_Cylinder) || (primitiveType==pt_Cone))
		{
			int num_indices_in_cap = vs.dwParameter;
			if (num_indices_in_cap)
			{
				gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLEFAN,vs.dwVertexStart,vs.dwVertexCount,
												vs.dwIndexStart + 0, num_indices_in_cap-2 );
				gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLEFAN,vs.dwVertexStart,vs.dwVertexCount,
												vs.dwIndexStart + num_indices_in_cap, num_indices_in_cap-2 );
			}

			gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP,vs.dwVertexStart,vs.dwVertexCount,
											vs.dwIndexStart + 2*num_indices_in_cap,vs.dwIndexCount - 2*num_indices_in_cap - 2 );
		}
		else
		{
			gpd3dDev->DrawIndexedPrimitive( d3dType,vs.dwVertexStart,vs.dwVertexCount,
											vs.dwIndexStart,vs.dwPrimCount );
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
void PrimitiveSet::create( const void *				version_data, 
						   int						num_versions, 
						   const void *				instance_data,
						   int						num_insts,
						   int						ndet_bias,
						   ShaderTypes				shader,
						   PrimitiveTypes			primitive,
						   LPDIRECT3DTEXTURE8		pnormal_map,
						   LPDIRECT3DCUBETEXTURE8	pcube_map)
{
	nVersions  = num_versions;
	nInstances = num_insts;

	shaderType = shader;
	primitiveType = primitive;
	pNormalMap = pnormal_map;
	pCubeMap   = pcube_map;

	aVersRecs = (PrimitiveVersionRecord*)MemAlloc(sizeof(PrimitiveVersionRecord)*nVersions);
	ZeroMemory(aVersRecs,sizeof(PrimitiveVersionRecord)*nVersions);

	DWORD dwVertCount  = 0;
	DWORD dwIndexCount = 0;

	unsigned short i;
	for(i = 0; i < nVersions; i++)
	{
		aVersRecs[i].dwVertexStart = dwVertCount;
		aVersRecs[i].dwIndexStart  = dwIndexCount;
		
		switch(primitiveType)
		{
		case pt_Sphere:		
			initSphereVersion( ((const SphereVers *)version_data)+i,i,ndet_bias);
			break;
		case pt_Cone:		
			initConeVersion( ((const ConeVers *)version_data)+i,i,ndet_bias);				
			break;
		case pt_Cylinder:	
			initCylinderVersion( ((const CylinderVers *)version_data)+i,i,ndet_bias);
			break;
		case pt_Box:		
			initBoxVersion(i);													
			break;
		case pt_Torus:		
			initTorusVersion( ((const TorusVers *)version_data)+i,i,ndet_bias);			
			break;
		case pt_SurfOfRev:	
			initSurfOfRevVersion( ((const SurfOfRevVers *)version_data)+i,i,ndet_bias);	
			break;
		}

		dwVertCount  += aVersRecs[i].dwVertexCount;
		dwIndexCount += aVersRecs[i].dwIndexCount;
	}

	DWORD dwExtraStride = 0;

	switch(shaderType)
	{
	case st_Bump:  dwExtraStride = sizeof(BumpStream);  break;
	case st_Phong: dwExtraStride = sizeof(PhongStream); break;
	}

	gpd3dDev->CreateVertexBuffer( sizeof(BaseStream) * dwVertCount, NULL, NULL, NULL, &pBaseStream );
	gpd3dDev->CreateVertexBuffer( dwExtraStride * dwVertCount, NULL, NULL, NULL, &pExtraStream );

	gpd3dDev->CreateIndexBuffer ( sizeof(unsigned short) * dwIndexCount,NULL,D3DFMT_INDEX16,NULL,&pIB);

	BYTE *pbase,*pextra;

	pBaseStream->Lock(0,sizeof(BaseStream) * dwVertCount,&pbase,NULL);
	pExtraStream->Lock(0,dwExtraStride * dwVertCount,&pextra,NULL);

	unsigned short *pi;
	pIB->Lock(0,sizeof(unsigned short) * dwIndexCount,(BYTE **)&pi,NULL);

	for(i = 0; i < nVersions; i++)
	{
		switch(primitiveType)
		{
		case pt_Sphere:		
			createSphereVersion( ((const SphereVers *)version_data)+i,pbase, pextra, pi, i,ndet_bias ); 
			break;		  
		case pt_Cone:		
			createConeVersion( ((const ConeVers *)version_data)+i,pbase,pextra,pi,i,ndet_bias );	
			break;
		case pt_Cylinder:	
			createCylinderVersion( ((const CylinderVers *)version_data)+i,pbase,pextra,pi,i,ndet_bias);  
			break;
		case pt_Box:		
			createBoxVersion(pbase,pextra,pi,i);
			break;
		case pt_Torus:		
			createTorusVersion( ((const TorusVers *)version_data)+i,pbase,pextra,pi,i,ndet_bias);
			break;
		case pt_SurfOfRev:	
			createSurfOfRevVersion( ((const SurfOfRevVers *)version_data)+i,pbase,pextra,pi,i,ndet_bias );
			break;
		}
		
		pbase  += (aVersRecs[i].dwVertexCount * sizeof(BaseStream));
		pextra += (aVersRecs[i].dwVertexCount * dwExtraStride );
		pi     += aVersRecs[i].dwIndexCount;
	}

	pBaseStream->Unlock();
	pExtraStream->Unlock();

	pIB->Unlock();

	aInstRecs  = (PrimitiveInstanceRecord*)MemAlloc(sizeof(PrimitiveInstanceRecord)*nInstances);
	ZeroMemory(aInstRecs,sizeof(PrimitiveInstanceRecord)*nInstances);

	for(i = 0; i < nInstances; i++)
	{
		switch(primitiveType)
		{
		case pt_Sphere:		
			initSphereInstance(((const SphereInst *)instance_data)+i,i);		
			break;
		case pt_Cone:		
			initConeInstance( ((const ConeInst *)instance_data)+i,i);			
			break;
		case pt_Cylinder:	
			initCylinderInstance( ((const CylinderInst *)instance_data)+i,i);   
			break;
		case pt_Box:		
			initBoxInstance( ((const BoxInst *)instance_data)+i,i);			    
			break;											  
		case pt_Torus:		
			initTorusInstance( ((const TorusInst *)instance_data)+i,i);         
			break;
		case pt_SurfOfRev:	
			initSurfOfRevInstance( ((const SurfOfRevInst *)instance_data)+i,i); 
			break;
		}	
	}

	switch(primitiveType)
	{	
	case pt_Box:
		d3dType = D3DPT_TRIANGLELIST;
		break;

	case pt_Cone:	
	case pt_Cylinder:	
	case pt_Sphere:	
	case pt_Torus:		
	case pt_SurfOfRev:
		d3dType = D3DPT_TRIANGLESTRIP;
		break;
	}	

	Set(&vAmbient, 0.2079f,1.f,0.100f,1.f );
	Set(&vDiffuse, 0.2079f,1.f,0.100f,1.f );
	Set(&vSpecular,0.2079f,1.f,0.100f,1.f );
}
///////////////////////////////////////////////////////////////////////////////
D3DVECTOR4 * SceneRenderer::decompressQuats(short *p_quat_data,DWORD *p_sign_data,int nquats)
{
	D3DVECTOR4 *pquats = (D3DVECTOR4 *)MemAlloc(sizeof(D3DVECTOR4)*nquats);
	float f_oo_scale = 1.f/32750.f;
	for(int i = 0; i < nquats; i++,p_quat_data+=3)
	{
		pquats[i].x = ((float)p_quat_data[0]) * f_oo_scale;
		pquats[i].y = ((float)p_quat_data[1]) * f_oo_scale;
		pquats[i].z = ((float)p_quat_data[2]) * f_oo_scale;

		pquats[i].w = fast_sqrt(1.f - pquats[i].x*pquats[i].x - 
						          pquats[i].y*pquats[i].y - 
								  pquats[i].z*pquats[i].z );
		
		int idw  = i >> 5;
		int bpos = i & 31;
		bool b_pos_w = ((p_sign_data[idw] & (1<<bpos))) != 0;
		if(!b_pos_w) 
			pquats[i].w *= -1.f;
	}

	return pquats;
}
///////////////////////////////////////////////////////////////////////////////
D3DVECTOR * SceneRenderer::decompressVecs(short *p_vec_data,int nvecs)
{
	D3DVECTOR * pvecs = (D3DVECTOR *)MemAlloc(sizeof(D3DVECTOR)*nvecs);
	for(int i = 0; i < nvecs; i++,p_vec_data+=3)
	{
		pvecs[i].x = ((float)p_vec_data[0]) * OO_POS_ANIM_SCALE_X + POS_ANIM_DELTA_X;
		pvecs[i].y = ((float)p_vec_data[1]) * OO_POS_ANIM_SCALE_Y + POS_ANIM_DELTA_Y;
		pvecs[i].z = ((float)p_vec_data[2]) * OO_POS_ANIM_SCALE_Z + POS_ANIM_DELTA_Z;
	}
	return pvecs;
}
///////////////////////////////////////////////////////////////////////////////
short * SceneRenderer::decompressIndices(char * p_indices,int nindices)
{
	short * pindices = (short *)MemAlloc(sizeof(short)*nindices);

	if(p_indices[0] == 127)
	{
		char hi = p_indices[1];
		char lo = p_indices[2];

		pindices[0] = ((((short)hi)&0xff)<<8) | (((short)lo)&0xff);
		p_indices += 2;
	}
	else
	{
		pindices[0] = p_indices[0];
	}

	for(int i = 1; i < nindices; i++)
	{
		if(p_indices[i] == 127)
		{
			char hi = p_indices[i+1];
			char lo = p_indices[i+2];

			pindices[i] = ((((short)hi)&0xff)<<8) | (((short)lo)&0xff);
			pindices[i] += pindices[i-1];
			
			p_indices   += 2;
		}
		else
		{
			pindices[i] = pindices[i-1] + p_indices[i];
		}
	}

	return pindices;
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::create()
{
	for(int i = 0; i < pt_NoTypes; i++)
	{
		pSetHiDet[i] = (PrimitiveSet *)MemAlloc(sizeof(PrimitiveSet));
        pSetHiDet[i]->Init();

		pSetLoDet[i] = (PrimitiveSet *)MemAlloc(sizeof(PrimitiveSet));
        pSetLoDet[i]->Init();
	}

	pQuats = decompressQuats(theQuats,theQuatSigns,numQuats);
	for(i = 0; i < NUM_ROT_SEQ; i++)
	{
		pQuatIdSeq[i] = decompressIndices(theRotAnimSeq[i].quatIds,MAX_ROT_SAMPLES);	
	}

	pPos = decompressVecs(thePos,numPos);
	for(i = 0; i < NUM_POS_SEQ; i++)
	{
		pPosIdSeq[i] = decompressIndices(thePosAnimSeq[i].posIds,MAX_POS_SAMPLES);
	}

	createSceneGeometry(pSetHiDet,0);
	createSceneGeometry(pSetLoDet,1);
	bUseLoDetail = false;

    gpd3dDev->CreateTexture(SB_WIDTH,SB_HEIGHT,1,0,D3DFMT_LIN_D16,0,&pSBufDepthLo);
	gpd3dDev->CreateTexture(SB_WIDTH,SB_HEIGHT,1,0,D3DFMT_LIN_D16,0,&pSBufDepthHi);

    memset(&fakeTarget, 0, sizeof(fakeTarget));

    XGSetSurfaceHeader(SB_WIDTH,
                       SB_HEIGHT,
                       D3DFMT_LIN_R5G6B5,
                       &fakeTarget,
                       0,
                       0);

    pSBufTarget = &fakeTarget;

    gpd3dDev->GetDepthStencilSurface(&pZBuffer);
    gpd3dDev->GetRenderTarget(&pRenderTarget);

	fZOffset = 10.f;
    fZSlopeScale = 4.0f;

	nRotAnims = sizeof(theRotAnimSeq)/sizeof(RotAnimSeq);
	nPosAnims = sizeof(thePosAnimSeq)/sizeof(PosAnimSeq);

	pRotAnims = (D3DMATRIX *)MemAlloc(sizeof(D3DMATRIX)*nRotAnims);
	pPosAnims = (D3DVECTOR *)MemAlloc(sizeof(D3DVECTOR)*nPosAnims);
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::createSceneGeometry(PrimitiveSet **pp_sets,int ndet_bias)
{
	pp_sets[pt_Sphere]->create(
		(const void *)theSphereVers, 
		sizeof(theSphereVers)/sizeof(SphereVers),
		(const void *)theSphereInsts, 
		sizeof(theSphereInsts)/sizeof(SphereInst),
		ndet_bias,
		st_Bump,
		pt_Sphere,
		gApp.pRoughBumpMap,
		gApp.pNormalCubeMapLoRes ); 

	pp_sets[pt_SurfOfRev]->create(
		(const void *)theSurfOfRevVers, 
		sizeof(theSurfOfRevVers)/sizeof(SurfOfRevVers),
		(const void *)theSurfOfRevInsts, 
		sizeof(theSurfOfRevInsts)/sizeof(SurfOfRevInst),
		ndet_bias,
		st_Bump, 
		pt_SurfOfRev,
		gApp.pRoughBumpMap,
		gApp.pNormalCubeMapHiRes );

	pp_sets[pt_Cone]->create(
		(const void *)theConeVers, 
		sizeof(theConeVers)/sizeof(ConeVers),
		(const void *)theConeInsts, 
		sizeof(theConeInsts)/sizeof(ConeInst),
		ndet_bias,
		st_Phong,
		pt_Cone,
		NULL, 
		gApp.pNormalCubeMapLoRes );

	pp_sets[pt_Box]->create( 
		NULL,1,
		(const void *)theBoxInsts, 
		sizeof(theBoxInsts)/sizeof(BoxInst),
		ndet_bias,
		st_Phong,
		pt_Box,
		NULL,
		gApp.pNormalCubeMapLoRes );

	pp_sets[pt_Cylinder]->create(
		(const void *)theCylinderVers, 
		sizeof(theCylinderVers)/sizeof(CylinderVers),
		(const void *)theCylinderInsts, 
		sizeof(theCylinderInsts)/sizeof(CylinderInst),
		ndet_bias,
		st_Phong,
		pt_Cylinder,
		NULL,gApp.pNormalCubeMapHiRes );

	pp_sets[pt_Torus]->create(
		(const void *)theTorusVers, 
		sizeof(theTorusVers)/sizeof(TorusVers),
		(const void *)theTorusInsts, 
		sizeof(theTorusInsts)/sizeof(TorusInst),
		ndet_bias,
		st_Phong,
		pt_Torus,
		NULL,
		gApp.pNormalCubeMapLoRes );	
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::destroy()
{
	for(int i = 0; i < pt_NoTypes; i++)
	{
        pSetHiDet[i]->UnInit();
        MemFree(pSetHiDet[i]);
        pSetHiDet[i] = NULL;

		pSetLoDet[i]->UnInit();
        MemFree(pSetLoDet[i]);
        pSetLoDet[i] = NULL;
	}

	MemFree(pRotAnims);
	MemFree(pPosAnims);

	MemFree(pQuats);
	for(i = 0; i < NUM_ROT_SEQ; i++)
	{
		MemFree(pQuatIdSeq[i]);
	}

	MemFree(pPos);
	for(i = 0; i < NUM_POS_SEQ; i++)
	{
		MemFree(pPosIdSeq[i]);
	}

#define XBS_RESOURCE_RELEASE(a) if (a) a->Release(); a = NULL;
    XBS_RESOURCE_RELEASE(pSBufDepthLo);
    XBS_RESOURCE_RELEASE(pSBufDepthHi);
#undef XBS_RESOURCE_RELEASE
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::render(bool b_with_shadows,bool b_use_blob_intensity)
{
	gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
	gpd3dDev->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);

	gpd3dDev->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSW,  D3DTADDRESS_CLAMP );

	gpd3dDev->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    gpd3dDev->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
	gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSW,  D3DTADDRESS_CLAMP );
	
	gpd3dDev->SetTextureStageState(3,D3DTSS_ADDRESSU,    D3DTADDRESS_BORDER );
	gpd3dDev->SetTextureStageState(3,D3DTSS_ADDRESSV,    D3DTADDRESS_BORDER );
	gpd3dDev->SetTextureStageState(3,D3DTSS_BORDERCOLOR, 0xffffffff );
	gpd3dDev->SetTextureStageState(3,D3DTSS_MINFILTER,   D3DTEXF_LINEAR );
	gpd3dDev->SetTextureStageState(3,D3DTSS_MAGFILTER,   D3DTEXF_LINEAR );
	gpd3dDev->SetTextureStageState(3,D3DTSS_MIPFILTER,   D3DTEXF_NONE );

	if(b_with_shadows)
	{
		gpd3dDev->SetRenderState(D3DRS_SHADOWFUNC,D3DCMP_GREATER);
	}

	for(int i = 0; i < pt_NoTypes; i++)
	{
		if(bUseLoDetail)
			pSetLoDet[i]->render(gApp.blobLight,b_use_blob_intensity);
		else
			pSetHiDet[i]->render(gApp.blobLight,b_use_blob_intensity);
	}
	if(b_with_shadows)
	{
		gpd3dDev->SetRenderState(D3DRS_SHADOWFUNC,D3DCMP_ALWAYS);
	}

	gpd3dDev->SetTexture(3,NULL);
	gpd3dDev->SetPixelShader(NULL);
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::renderZ()
{
	for(int i = 0; i < pt_NoTypes; i++)
	{
		if(bUseLoDetail)
			pSetLoDet[i]->renderZ();
		else
			pSetHiDet[i]->renderZ();
	}
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::advanceTime(float fElapsedTime, float fDt)
{
	float fpos = ((fElapsedTime-SCENE_ANIM_START_TIME) / SCENE_ANIM_LEN);
	float ffrac_pos =  fpos * ((float)MAX_POS_SAMPLES-2);
	int   pos_id;

    __asm
    {
        cvttss2si eax, ffrac_pos
        mov pos_id, eax
    }

	float ffrac = ffrac_pos - (float)pos_id;
    
	for(int i = 0; i < nPosAnims; i++)
	{
		if(fpos <= 0.f)
		{
			pPosAnims[i] = pPos[pPosIdSeq[i][0]];
		}
		else if(fpos >= 1.f)
		{
			pPosAnims[i] = pPos[pPosIdSeq[i][MAX_POS_SAMPLES-1]];
		}
		else
		{
			D3DVECTOR &a = pPos[pPosIdSeq[i][pos_id]];
			D3DVECTOR &b = pPos[pPosIdSeq[i][pos_id+1]];

			pPosAnims[i].x = a.x * (1.f-ffrac) + b.x * ffrac; 
			pPosAnims[i].y = a.y * (1.f-ffrac) + b.y * ffrac; 
			pPosAnims[i].z = a.z * (1.f-ffrac) + b.z * ffrac; 
		}
	}

	ffrac_pos =  fpos * ((float)MAX_ROT_SAMPLES-2);

    __asm
    {
        cvttss2si eax, ffrac_pos
        mov pos_id, eax
    }

	ffrac = ffrac_pos - (float)pos_id;

	for(i = 0; i < nRotAnims; i++)
	{
		if(fpos <= 0.f)
		{
			D3DVECTOR4 &q = pQuats[pQuatIdSeq[i][0]];
			SetRotationFromLHQuat(q,&pRotAnims[i]);
		}
		else if(fpos >= 1.f)
		{
			D3DVECTOR4 &q = pQuats[pQuatIdSeq[i][MAX_ROT_SAMPLES-1]];
			SetRotationFromLHQuat(q,&pRotAnims[i]);
		}
		else
		{
			D3DVECTOR4 &a = pQuats[pQuatIdSeq[i][pos_id]];
			D3DVECTOR4 &b = pQuats[pQuatIdSeq[i][pos_id+1]];

			D3DVECTOR4 res;
			SlerpQuats(a,b,ffrac,&res);
			SetRotationFromLHQuat(res,&pRotAnims[i]);
		}	
	}

	bUseLoDetail = fElapsedTime >= SCENE_LO_DETAIL_START;
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::updateShadows()
{
	Camera cam = gApp.theCamera;
	updateSBuffer( false);
	updateSBuffer( true );
	gApp.theCamera = cam;
}
///////////////////////////////////////////////////////////////////////////////
void SceneRenderer::updateSBuffer(bool b_hi_z)
{
	Camera &cam = gApp.theCamera;

	D3DVECTOR eye_pos,look_pt,up;

	D3DVECTOR pos;
	pos.x = 0.0f;
	pos.y = 0.0f;
	pos.z = b_hi_z ? CEIL_Z : FLOOR_Z;

	float fi;
	gApp.vblob.getLightForPosition(&eye_pos,&fi,pos);

	D3DVECTOR dir ;
	Set(&dir,0.f,0.f,(b_hi_z) ? 1.f : -1.f);
	Add(eye_pos,dir,&look_pt);
	Set(&up,0.f,(b_hi_z) ? -1.f : 1.f,0.f);
	
	cam.lookAt(eye_pos,look_pt,up);
	cam.setProjection(Pi/1.5f,1.f,1.f,500.f);

	D3DMATRIX shadow_proj_mat = cam.matProj;
	D3DMATRIX shadow_vp_mat;
    SetIdentity(&shadow_vp_mat);

    shadow_vp_mat._11 = SB_WIDTH   * 0.5f;
    shadow_vp_mat._22 = -SB_HEIGHT * 0.5f;
    shadow_vp_mat._33 = D3DZ_MAX_D16;

    shadow_vp_mat._41 = SB_WIDTH  * 0.5f + 0.5f;
    shadow_vp_mat._42 = SB_HEIGHT * 0.5f + 0.5f;

	D3DMATRIX mat;
	MulMats( cam.matWTC,shadow_proj_mat,&mat );
    MulMats( mat, shadow_vp_mat, (b_hi_z) ? &matWTSHi : &matWTSLo );
	
	if( gpd3dDev->BeginScene() == D3D_OK )
	{
		IDirect3DSurface8 *psurf;

		gpd3dDev->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
		gpd3dDev->SetRenderState(D3DRS_ALPHATESTENABLE,FALSE);
		gpd3dDev->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
		
		if(b_hi_z) 
			pSBufDepthHi->GetSurfaceLevel(0,&psurf);
		else	   
			pSBufDepthLo->GetSurfaceLevel(0,&psurf);

		gpd3dDev->SetRenderTarget(pSBufTarget,psurf);

		D3DVIEWPORT8 viewport = { 0, 0, SB_WIDTH, SB_HEIGHT, 0.0f, 1.0f };
		gpd3dDev->SetViewport(&viewport);

		gpd3dDev->Clear(0,NULL,D3DCLEAR_ZBUFFER,0,1.0f,0);
		gpd3dDev->SetRenderState(D3DRS_COLORWRITEENABLE,0);

		gpd3dDev->SetRenderState(D3DRS_SOLIDOFFSETENABLE, TRUE);
		gpd3dDev->SetRenderState(D3DRS_POLYGONOFFSETZOFFSET, FtoDW(fZOffset));
		gpd3dDev->SetRenderState(D3DRS_POLYGONOFFSETZSLOPESCALE, FtoDW(fZSlopeScale));

		gpd3dDev->SetVertexShader(D3DFVF_XYZ);
		gpd3dDev->SetPixelShader (NULL);

		gpd3dDev->SetTransform(D3DTS_VIEW,&cam.matWTC);
		gpd3dDev->SetTransform(D3DTS_PROJECTION,&shadow_proj_mat);

		gpd3dDev->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
		gpd3dDev->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TFACTOR);
		gpd3dDev->SetTextureStageState(1,D3DTSS_COLOROP,D3DTOP_DISABLE);

		for(int i = 0; i < 4; i++)
			gpd3dDev->SetTexture(i,NULL);

		const PrimitiveTypes sb_types[] = { pt_Torus, pt_Cone, pt_Box, pt_Cylinder };
		const int num_sb_types = sizeof(sb_types)/sizeof(PrimitiveTypes); 

		for(i = 0; i < num_sb_types; i++)
		{
			if(bUseLoDetail)
				pSetLoDet[sb_types[i]]->renderShadowMap(b_hi_z);
			else
				pSetHiDet[sb_types[i]]->renderShadowMap(b_hi_z);
		}

		gpd3dDev->SetRenderTarget(pRenderTarget, pZBuffer);
		gpd3dDev->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALL);
		gpd3dDev->SetRenderState(D3DRS_SOLIDOFFSETENABLE, FALSE);
		
		psurf->Release();

		gpd3dDev->EndScene();
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\scene_geometry.h ===
#ifndef __DEFAULT_NAME_H__
#define __DEFAULT_NAME_H__

#include "prim_types.h"

RotAnimSeq theRotAnimSeq[] = 
{
{2,0,48,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{60,0,0,0,0,0,0,0,-1,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{64,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0}
,{86,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0}
,{108,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0}
,{127,0,-126,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0}
,{64,0,0,88,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-86,0,0,0,0,0,0}
,{108,0,0,64,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-62,0,0,0,0,0,0}
,{127,0,-126,0,0,62,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-60,0,0,0,0,0,0}
,{86,0,0,126,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-124,0,0,0,0,0,0}
,{2,0,0,0,0,127,0,-26,1,1,1,1,1,127,-1,78,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-18,0,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{2,127,0,-10,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{64,127,0,-62,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{6,127,1,6,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{108,127,0,-86,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-18,50,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-126,127,0,-88,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{23,127,1,29,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,62,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{2,127,1,71,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{64,127,1,19,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{6,127,1,87,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{108,127,0,-5,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-18,127,0,-125,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-126,127,0,-7,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{23,127,1,110,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,62,81,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{64,127,1,89,1,1,1,127,-2,-48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

PosAnimSeq thePosAnimSeq[] = 
{
{0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{13,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{26,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{33,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{49,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{65,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{81,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{97,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
,{113,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-127,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-111,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-95,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-89,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-76,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-63,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-56,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-49,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-42,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-35,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-28,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-21,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-14,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,0,-7,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,7,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,14,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,21,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,28,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,35,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,42,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,49,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
,{127,1,57,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

short numPos = 320;
short thePos[]=
{
	46,374,9290,
	46,374,9282,
	46,374,9029,
	46,374,8776,
	46,374,8679,
	46,374,8562,
	46,374,7863,
	46,374,7163,
	46,374,6916,
	46,374,6821,
	46,374,6725,
	46,374,7078,
	46,374,7129,
	57,268,-10221,
	57,268,-10201,
	57,268,-9624,
	57,268,-9047,
	57,268,-8825,
	57,268,-8751,
	57,268,-8308,
	57,268,-7865,
	57,268,-7572,
	57,268,-7695,
	57,268,-7819,
	57,268,-7942,
	57,268,-7957,
	57,269,-16816,
	57,269,-16555,
	57,269,-16294,
	57,269,-16033,
	57,269,-15772,
	57,269,-15511,
	57,269,-15428,
	-16187,16454,-11876,
	-15779,16045,-11876,
	-15370,15637,-11876,
	-14962,15229,-11876,
	-14554,14820,-11876,
	-14145,14412,-11876,
	-13737,14004,-11876,
	-13329,13595,-11876,
	-12920,13187,-11876,
	-12512,12779,-11876,
	-12104,12370,-11876,
	-11695,11962,-11876,
	-11287,11554,-11876,
	-10879,11145,-11876,
	-10470,10737,-11876,
	-10463,10730,-11876,
	16402,16509,-11876,
	15978,16085,-11876,
	15554,15661,-11876,
	15130,15237,-11876,
	14706,14813,-11876,
	14282,14390,-11876,
	13858,13966,-11876,
	13434,13542,-11876,
	13010,13118,-11876,
	12586,12694,-11876,
	12163,12270,-11876,
	11739,11846,-11876,
	11315,11422,-11876,
	10891,10998,-11876,
	10467,10574,-11876,
	10459,10567,-11876,
	-16346,-16240,-11876,
	-15907,-15802,-11876,
	-15469,-15363,-11876,
	-15031,-14925,-11876,
	-14592,-14487,-11876,
	-14154,-14048,-11876,
	-13715,-13610,-11876,
	-13277,-13171,-11876,
	-12839,-12733,-11876,
	-12400,-12295,-11876,
	-11962,-11856,-11876,
	-11524,-11418,-11876,
	-11085,-10980,-11876,
	-10647,-10541,-11876,
	-10208,-10103,-11876,
	-10200,-10095,-11876,
	16402,-16134,-11876,
	15971,-15702,-11876,
	15539,-15271,-11876,
	15108,-14840,-11876,
	14676,-14408,-11876,
	14245,-13977,-11876,
	13814,-13546,-11876,
	13382,-13114,-11876,
	12951,-12683,-11876,
	12519,-12251,-11876,
	12088,-11820,-11876,
	11657,-11389,-11876,
	11225,-10957,-11876,
	10794,-10526,-11876,
	10362,-10094,-11876,
	10355,-10087,-11876,
	-16187,16454,10668,
	-15949,16216,10668,
	-15541,15807,10668,
	-15132,15399,10668,
	-14724,14991,10668,
	-14316,14582,10668,
	-13907,14174,10668,
	-13499,13766,10668,
	-13091,13357,10668,
	-12682,12949,10668,
	-12274,12541,10668,
	-11866,12132,10668,
	-11457,11724,10668,
	-11049,11316,10668,
	-10640,10907,10668,
	-10463,10730,10668,
	-16346,-16240,10668,
	-16090,-15984,10668,
	-15652,-15546,10668,
	-15213,-15108,10668,
	-14775,-14669,10668,
	-14337,-14231,10668,
	-13898,-13793,10668,
	-13460,-13354,10668,
	-13021,-12916,10668,
	-12583,-12478,10668,
	-12145,-12039,10668,
	-11706,-11601,10668,
	-11268,-11162,10668,
	-10830,-10724,10668,
	-10391,-10286,10668,
	-10200,-10095,10668,
	16402,-16134,10668,
	16162,-15893,10668,
	15749,-15481,10668,
	15337,-15069,10668,
	14924,-14656,10668,
	14512,-14244,10668,
	14100,-13831,10668,
	13687,-13419,10668,
	13275,-13007,10668,
	12862,-12594,10668,
	12450,-12182,10668,
	12037,-11769,10668,
	11625,-11357,10668,
	11213,-10945,10668,
	10800,-10532,10668,
	10621,-10353,10668,
	16403,16508,10668,
	16156,16260,10668,
	15732,15836,10668,
	15308,15413,10668,
	14884,14989,10668,
	14460,14565,10668,
	14037,14141,10668,
	13613,13717,10668,
	13189,13293,10668,
	12765,12869,10668,
	12341,12445,10668,
	11917,12021,10668,
	11493,11597,10668,
	11069,11173,10668,
	10645,10750,10668,
	10461,10565,10668,
	57,269,15933,
	57,269,15644,
	57,269,15354,
	57,269,15065,
	57,269,14776,
	57,269,14535,
	51,269,-11962,
	51,269,-11943,
	51,269,-11366,
	51,269,-10788,
	51,269,-10567,
	51,269,-10493,
	51,269,-10050,
	51,269,-9606,
	51,269,-9314,
	51,269,-9437,
	51,269,-9560,
	51,269,-9684,
	51,269,-9698,
	51,269,11058,
	51,269,11050,
	51,269,10797,
	51,269,10544,
	51,269,10446,
	51,269,10330,
	51,269,9631,
	51,269,8931,
	51,269,8684,
	51,269,8588,
	51,269,8493,
	51,269,8846,
	51,269,8897,
	-3760,264,-8917,
	-3760,264,-8657,
	-3760,264,-8398,
	-3760,264,-8138,
	-3760,264,-7879,
	-3760,264,-7619,
	-3760,264,-7537,
	-2638,-2434,-8917,
	-2638,-2434,-8657,
	-2638,-2434,-8398,
	-2638,-2434,-8138,
	-2638,-2434,-7879,
	-2638,-2434,-7619,
	-2638,-2434,-7537,
	62,-3548,-8917,
	62,-3548,-8657,
	62,-3548,-8398,
	62,-3548,-8138,
	62,-3548,-7879,
	62,-3548,-7619,
	62,-3548,-7537,
	2761,-2427,-8917,
	2761,-2427,-8657,
	2761,-2427,-8398,
	2761,-2427,-8138,
	2761,-2427,-7879,
	2761,-2427,-7619,
	2761,-2427,-7537,
	3875,274,-8917,
	3875,274,-8657,
	3875,274,-8398,
	3875,274,-8138,
	3875,274,-7879,
	3875,274,-7619,
	3875,274,-7537,
	2754,2972,-8917,
	2754,2972,-8657,
	2754,2972,-8398,
	2754,2972,-8138,
	2754,2972,-7879,
	2754,2972,-7619,
	2754,2972,-7537,
	52,4087,-8917,
	52,4087,-8657,
	52,4087,-8398,
	52,4087,-8138,
	52,4087,-7879,
	52,4087,-7619,
	52,4087,-7537,
	-2645,2965,-8917,
	-2645,2965,-8657,
	-2645,2965,-8398,
	-2645,2965,-8138,
	-2645,2965,-7879,
	-2645,2965,-7619,
	-2645,2965,-7537,
	-3760,264,7941,
	-3760,264,7682,
	-3760,264,7423,
	-3760,264,7165,
	-3760,264,6906,
	-3760,264,6647,
	-3760,264,6565,
	-2638,-2434,7941,
	-2638,-2434,7682,
	-2638,-2434,7423,
	-2638,-2434,7165,
	-2638,-2434,6906,
	-2638,-2434,6647,
	-2638,-2434,6565,
	62,-3548,7941,
	62,-3548,7682,
	62,-3548,7423,
	62,-3548,7165,
	62,-3548,6906,
	62,-3548,6647,
	62,-3548,6565,
	2761,-2427,7941,
	2761,-2427,7682,
	2761,-2427,7423,
	2761,-2427,7165,
	2761,-2427,6906,
	2761,-2427,6647,
	2761,-2427,6565,
	3875,274,7941,
	3875,274,7682,
	3875,274,7423,
	3875,274,7165,
	3875,274,6906,
	3875,274,6647,
	3875,274,6565,
	2754,2972,7941,
	2754,2972,7682,
	2754,2972,7423,
	2754,2972,7165,
	2754,2972,6906,
	2754,2972,6647,
	2754,2972,6565,
	52,4087,7941,
	52,4087,7682,
	52,4087,7423,
	52,4087,7165,
	52,4087,6906,
	52,4087,6647,
	52,4087,6565,
	-2645,2965,7941,
	-2645,2965,7682,
	-2645,2965,7423,
	-2645,2965,7165,
	-2645,2965,6906,
	-2645,2965,6647,
	-2645,2965,6565,
	57,269,-13617,
	57,269,-13397,
	57,269,-13178,
	57,269,-12958,
	57,269,-12739,
	57,269,-12663,
	57,269,-13307,
	57,269,-13801,
	57,269,12556,
	57,269,12339,
	57,269,12121,
	57,269,11903,
	57,269,11772,
	57,269,12202,
	57,269,12546,
};

short numQuats = 413;
short theQuats[]=
{
	0,32750,0,
	8862,-21394,-8862,
	0,0,0,
	-16375,-16375,16375,
	-8862,-21394,8862,
	16375,-16375,-16375,
	0,0,-23157,
	-23157,-23157,0,
	-23030,23030,2420,
	-12464,30091,3162,
	0,32570,3423,
	-30091,12464,1310,
	-32570,0,0,
	-12464,-30091,-3162,
	-23030,-23030,-2420,
	-30091,-12464,-1310,
	-16374,-16375,16374,
	2721,2721,-22997,
	2721,-2721,22997,
	0,3849,-32522,
	3849,0,0,
	-16374,16374,16375,
	16375,-16375,16374,
	0,0,23157,
	-23157,23157,0,
	-16375,16374,16375,
	23005,22728,-3751,
	23157,-23157,0,
	0,0,-23157,
	23157,23157,0,
	-16374,16375,-16374,
	-16375,-16375,16374,
	16375,-16374,-16375,
	15645,17073,17073,
	-18783,-18723,-13418,
	3793,22963,22770,
	0,-23157,-23157,
	0,-23157,23157,
	9048,-21316,21316,
	8675,21471,-21471,
	21471,-8675,8675,
	21316,9048,-9048,
	21316,-9048,-9048,
	-21471,-8675,-8675,
	8675,-21471,-21471,
	-9048,-21316,-21316,
	13751,13418,-18723,
	23157,0,0,
	21394,-8862,8862,
	16374,16375,-16375,
	0,0,-314,
	0,0,-788,
	0,0,-798,
	0,0,270,
	0,0,2327,
	0,0,4941,
	0,0,7845,
	0,0,10771,
	0,0,13467,
	0,0,13840,
	0,0,12400,
	0,0,18945,
	0,0,23433,
	0,0,24049,
	0,0,-12532,
	32,-77,-12532,
	118,-286,-12532,
	244,-590,-12530,
	395,-954,-12526,
	556,-1342,-12520,
	711,-1718,-12512,
	847,-2046,-12504,
	949,-2292,-12496,
	1001,-2418,-12492,
	990,-2390,-12493,
	900,-2173,-12500,
	716,-1730,-12512,
	424,-1024,-12525,
	8,-21,-12532,
	-781,1886,-12508,
	-2089,5045,-12357,
	-3723,8988,-11967,
	-5468,13203,-11276,
	-7119,17189,-10314,
	-8510,20545,-9200,
	-8862,21394,-8862,
	-12532,-30257,0,
	-12532,-30256,32,
	-12532,-30255,118,
	-12530,-30251,244,
	-12526,-30241,395,
	-12520,-30227,556,
	-12512,-30208,711,
	-12504,-30187,847,
	-12496,-30170,949,
	-12492,-30160,1001,
	-12493,-30162,990,
	-12500,-30178,900,
	-12512,-30207,716,
	-12525,-30239,424,
	-12532,-30257,8,
	-12508,-30198,-781,
	-12357,-29833,-2089,
	-11967,-28891,-3723,
	-11276,-27224,-5468,
	-10314,-24900,-7119,
	-9200,-22211,-8510,
	-8862,-21394,-8862,
	0,0,-30257,
	-77,32,-30256,
	-286,118,-30255,
	-590,244,-30251,
	-954,395,-30241,
	-1342,556,-30227,
	-1718,711,-30208,
	-2046,847,-30187,
	-2292,949,-30170,
	-2418,1001,-30160,
	-2390,990,-30162,
	-2173,900,-30178,
	-1730,716,-30207,
	-1024,424,-30239,
	-21,8,-30257,
	1886,-781,-30198,
	5045,-2089,-29833,
	8988,-3723,-28891,
	13203,-5468,-27224,
	17189,-7119,-24900,
	20545,-8510,-22211,
	21394,-8862,-21394,
	0,0,30257,
	-77,-32,30256,
	-286,-118,30255,
	-590,-244,30251,
	-954,-395,30241,
	-1342,-556,30227,
	-1718,-711,30208,
	-2046,-847,30187,
	-2292,-949,30170,
	-2418,-1001,30160,
	-2390,-990,30162,
	-2173,-900,30178,
	-1730,-716,30207,
	-1024,-424,30239,
	-21,-8,30257,
	1886,781,30198,
	5045,2089,29833,
	8988,3723,28891,
	13203,5468,27224,
	17189,7119,24900,
	20545,8510,22211,
	21394,8862,21394,
	11,-27,-12532,
	78,-190,-12532,
	192,-465,-12531,
	338,-817,-12528,
	500,-1208,-12522,
	664,-1603,-12515,
	813,-1964,-12506,
	934,-2255,-12498,
	1010,-2440,-12492,
	1028,-2482,-12490,
	971,-2345,-12495,
	825,-1992,-12505,
	574,-1385,-12519,
	202,-489,-12531,
	-406,980,-12526,
	-1649,3981,-12423,
	-3353,8095,-12075,
	-5247,12667,-11381,
	-7058,17040,-10356,
	-8566,20682,-9147,
	-27,11,-30257,
	-190,78,-30256,
	-465,192,-30253,
	-817,338,-30246,
	-1208,500,-30232,
	-1603,664,-30214,
	-1964,813,-30193,
	-2255,934,-30172,
	-2440,1010,-30158,
	-2482,1028,-30155,
	-2345,971,-30166,
	-1992,825,-30191,
	-1385,574,-30225,
	-489,202,-30253,
	980,-406,-30241,
	3981,-1649,-29993,
	8095,-3353,-29153,
	12667,-5247,-27477,
	17040,-7058,-25002,
	20682,-8566,-22084,
	-27,-11,30257,
	-190,-78,30256,
	-465,-192,30253,
	-817,-338,30246,
	-1208,-500,30232,
	-1603,-664,30214,
	-1964,-813,30193,
	-2255,-934,30172,
	-2440,-1010,30158,
	-2482,-1028,30155,
	-2345,-971,30166,
	-1992,-825,30191,
	-1385,-574,30225,
	-489,-202,30253,
	980,406,30241,
	3981,1649,29993,
	8095,3353,29153,
	12667,5247,27477,
	17040,7058,25002,
	20682,8566,22084,
	-12532,-30257,11,
	-12532,-30256,78,
	-12531,-30253,192,
	-12528,-30246,338,
	-12522,-30232,500,
	-12515,-30214,664,
	-12506,-30193,813,
	-12498,-30172,934,
	-12492,-30158,1010,
	-12490,-30155,1028,
	-12495,-30166,971,
	-12505,-30191,825,
	-12519,-30225,574,
	-12531,-30253,202,
	-12526,-30241,-406,
	-12423,-29993,-1649,
	-12075,-29153,-3353,
	-11381,-27477,-5247,
	-10356,-25002,-7058,
	-9147,-22084,-8566,
	0,0,-24,
	0,0,-753,
	0,0,-1100,
	0,0,892,
	0,0,6514,
	0,0,13000,
	0,0,32750,
	0,0,32748,
	0,0,32740,
	0,0,32748,
	0,0,32667,
	0,0,32375,
	0,0,31796,
	0,0,30928,
	0,0,29852,
	0,0,29681,
	0,586,0,
	0,1802,0,
	0,2831,0,
	0,2861,0,
	0,1077,0,
	0,-3544,0,
	0,-11170,0,
	0,-19638,0,
	0,-26599,0,
	0,-29681,0,
	-224,542,-12530,
	-689,1665,-12513,
	-1083,2615,-12485,
	-1094,2643,-12484,
	-412,995,-12526,
	1356,-3274,-12459,
	4274,-10320,-11781,
	7515,-18143,-10029,
	10179,-24574,-7311,
	11358,-27422,-5296,
	-414,414,-23154,
	-1274,1274,-23122,
	-2001,2001,-23071,
	-2023,2023,-23069,
	-762,762,-23145,
	2506,-2506,-23021,
	7898,-7898,-21769,
	13886,-13886,-18532,
	18808,-18808,-13509,
	20988,-20988,-9786,
	-542,224,-30252,
	-1665,689,-30211,
	-2615,1083,-30143,
	-2643,1094,-30141,
	-995,412,-30240,
	3274,-1356,-30079,
	10320,-4274,-28442,
	18143,-7515,-24213,
	24574,-10179,-17651,
	27422,-11358,-12787,
	586,0,32744,
	1802,0,32700,
	2831,0,32627,
	2861,0,32624,
	1077,0,32732,
	-3544,0,32557,
	-11170,0,30786,
	-19638,0,26208,
	-26599,0,19105,
	-29681,0,13840,
	542,224,30252,
	1665,689,30211,
	2615,1083,30143,
	2643,1094,30141,
	995,412,30240,
	-3274,-1356,30079,
	-10320,-4274,28442,
	-18143,-7515,24213,
	-24574,-10179,17651,
	-27422,-11358,12787,
	414,414,23154,
	1274,1274,23122,
	2001,2001,23071,
	2023,2023,23069,
	762,762,23145,
	-2506,-2506,23021,
	-7898,-7898,21769,
	-13886,-13886,18532,
	-18808,-18808,13509,
	-20988,-20988,9786,
	0,0,12532,
	224,542,12530,
	689,1665,12513,
	1083,2615,12485,
	1094,2643,12484,
	412,995,12526,
	-1356,-3274,12459,
	-4274,-10320,11781,
	-7515,-18143,10029,
	-10179,-24574,7311,
	-11358,-27422,5296,
	0,-756,0,
	0,-2324,0,
	0,-3649,0,
	0,-3687,0,
	0,-1390,0,
	0,4566,0,
	0,14215,0,
	0,24156,0,
	0,30786,0,
	0,32561,0,
	293,-708,-12529,
	901,-2177,-12500,
	1415,-3417,-12452,
	1430,-3453,-12450,
	539,-1301,-12521,
	-1771,4276,-12407,
	-5509,13301,-11256,
	-9340,22548,-8356,
	-11851,28612,-4075,
	-12485,30141,-1092,
	542,-542,-23151,
	1666,-1666,-23097,
	2615,-2615,-23009,
	2643,-2643,-23006,
	996,-996,-23136,
	-3273,3273,-22925,
	-10180,10180,-20800,
	-17258,17258,-15441,
	-21899,21899,-7530,
	-23069,23069,-2018,
	708,-293,-30248,
	2177,-901,-30178,
	3417,-1415,-30063,
	3453,-1430,-30059,
	1301,-539,-30229,
	-4276,1771,-29953,
	-13301,5509,-27176,
	-22549,9340,-20175,
	-28612,11851,-9839,
	-30141,12485,-2637,
	-767,0,32741,
	-2356,0,32665,
	-3699,0,32540,
	-3738,0,32535,
	-1409,0,32719,
	4628,0,32421,
	14397,0,29415,
	24406,0,21837,
	30969,0,10650,
	32625,0,2854,
	-708,-293,30248,
	-2177,-901,30178,
	-3417,-1415,30063,
	-3453,-1430,30059,
	-1301,-539,30229,
	4276,1771,29953,
	13301,5509,27176,
	22548,9340,20175,
	28612,11851,9839,
	30141,12485,2637,
	-542,-542,23151,
	-1666,-1666,23097,
	-2615,-2615,23009,
	-2643,-2643,23006,
	-996,-996,23136,
	3273,3273,22925,
	10180,10180,20800,
	17258,17258,15441,
	21899,21899,7530,
	23069,23069,2018,
	-293,-708,12529,
	-901,-2177,12500,
	-1415,-3417,12452,
	-1430,-3453,12450,
	-539,-1301,12521,
	1771,4276,12407,
	5509,13301,11256,
	9340,22549,8356,
	11851,28612,4075,
	12485,30141,1092,
	0,0,-17262,
	0,0,-21537,
	0,0,-25244,
	0,0,-28287,
};


DWORD theQuatSigns[]=
{
	0XEFFFFFFF,
	0XFFFFEBFF,
	0XFFFFFFFF,
	0XFFFFF01F,
	0XFFFFFFFF,
	0XFFFFFFFF,
	0XFFFFFFFF,
	0XFF01FF03,
	0XFFFFFFFF,
	0XFFFFFCFF,
	0XFFFFFFFF,
	0XFFFFFFFF,
	0X1FFFFFFF,
};

SphereInst theSphereInsts[]=
{
{5704,27,-230,0,0,0,1.522714f},
{7776,27,-230,0,0,0,1.522714f},
{6027,403,-230,0,0,0,1.522714f},
{7486,387,-230,0,0,0,1.522714f},
{7454,-348,-230,0,0,0,1.522714f},
{6795,545,-230,0,0,0,1.522714f},
{5995,-332,-230,0,0,0,1.522714f},
{6750,27,-112,0,0,0,2.671428f},
{6686,-490,-230,0,0,0,1.522714f},
{6733,27,-112,0,1,1,2.283272f},
{5855,27,-11,0,1,1,1.301465f},
{6103,-280,-11,0,1,1,1.301465f},
{7350,-293,-11,0,1,1,1.301465f},
{6694,-414,-11,0,1,1,1.301465f},
{6787,470,-11,0,1,1,1.301465f},
{7377,335,-11,0,1,1,1.301465f},
{7626,27,-11,0,1,1,1.301465f},
{6131,349,-11,0,1,1,1.301465f},
{-2847,4790,6279,1,-1,-1,7.010400f},
{6737,8161,-6189,1,-1,-1,7.010400f},
{6737,8161,6279,1,-1,-1,7.010400f},
{16375,4798,6279,1,-1,-1,7.010400f},
{16375,-4805,6279,1,-1,-1,7.010400f},
{16375,4798,-6189,1,-1,-1,7.010400f},
{16375,-4805,-6189,1,-1,-1,7.010400f},
{-2840,-4805,-6189,1,-1,-1,7.010400f},
{-2847,4790,-6189,1,-1,-1,7.010400f},
{-2840,-4805,6279,1,-1,-1,7.010400f}
};

SphereVers theSphereVers[]=
{
{16},
{24}
};

CylinderInst theCylinderInsts[]=
{
{0,16367,-4804,-250,0,-1,-1,3.567284f,1.981200f},
{0,-2836,4798,-250,0,-1,-1,3.567284f,1.981200f},
{1,-16374,-11578,6302,1,-1,-1,3.353000f,135.129410f},
{2,-2836,4798,18,0,-1,-1,3.567284f,1.981200f},
{3,6756,16375,6302,1,-1,-1,3.353000f,135.129501f},
{4,-16375,11578,-6180,1,-1,-1,3.353000f,135.129410f},
{2,-2836,-4804,18,0,-1,-1,3.567284f,1.981200f},
{0,-2836,-4804,-250,0,-1,-1,3.567284f,1.981200f},
{2,-2846,-4799,-16142,2,-1,-1,2.104218f,79.909309f},
{2,-2846,4804,-16142,2,-1,-1,2.104218f,79.909309f},
{5,6756,-16375,-6180,1,-1,-1,3.353000f,135.129410f},
{2,6738,8174,-16142,2,-1,-1,2.104218f,79.909309f},
{2,16356,-4799,-16142,2,-1,-1,2.104218f,79.909309f},
{2,16356,4804,-16142,2,-1,-1,2.104218f,79.909309f},
{2,16367,-4804,18,0,-1,-1,3.567284f,1.981200f},
{4,-16375,11578,6302,1,-1,-1,3.353000f,135.129410f},
{1,-16374,-11578,-6180,1,-1,-1,3.353000f,135.129410f},
{2,16367,4798,18,0,-1,-1,3.567284f,1.981200f},
{0,16367,4798,-250,0,-1,-1,3.567284f,1.981200f},
{2,6748,8169,18,0,-1,-1,3.567284f,1.981200f},
{0,6748,8169,-250,0,-1,-1,3.567284f,1.981200f},
{6,6726,41,-16374,3,-1,-1,7.174442f,15.087600f},
{7,6729,31,16374,3,-1,-1,7.174442f,15.087600f},
{8,4182,30,4210,4,2,-1,0.324547f,19.536489f},
{9,4936,935,4210,4,2,-1,0.324547f,19.536489f},
{10,6747,1308,4210,4,2,-1,0.324547f,19.536491f},
{11,4927,-875,4210,4,2,-1,0.324547f,19.536491f},
{12,6734,-1252,4210,4,2,-1,0.324547f,19.536489f},
{13,8553,930,4210,4,2,-1,0.324547f,19.536489f},
{14,9298,24,4210,4,2,-1,0.324547f,19.536489f},
{15,8545,-879,4210,4,2,-1,0.324547f,19.536486f},
{16,6740,2700,-112,5,3,2,5.387035f,20.375206f},
{16,6740,2700,-112,5,4,3,5.387035f,20.375206f},
{16,6740,2700,-112,5,5,4,5.387035f,20.375206f},
{16,6740,2700,-112,5,6,5,5.387035f,20.375206f},
{16,6740,2700,-112,5,7,6,5.387035f,20.375206f},
{16,6740,2700,-112,5,8,7,5.387035f,20.375206f},
{16,6740,2700,-112,5,9,8,5.387035f,20.375206f},
{16,6740,2700,-112,5,10,9,5.387035f,20.375206f},
{8,11265,24,4210,4,11,-1,0.324547f,19.536488f},
{9,9935,-1575,4210,4,11,-1,0.324547f,19.536488f},
{10,6734,-2237,4210,4,11,-1,0.324547f,19.536489f},
{11,9944,1627,4210,4,11,-1,0.324547f,19.536489f},
{12,6747,2292,4210,4,11,-1,0.324547f,19.536489f},
{13,3537,-1571,4210,4,11,-1,0.324547f,19.536489f},
{14,2216,30,4210,4,11,-1,0.324547f,19.536489f},
{15,3545,1631,4210,4,11,-1,0.324547f,19.536488f}
};

CylinderVers theCylinderVers[]=
{
{1,16},
{5,16},
{5,10},
{1,12},
{1,6},
{1,20}
};

BoxInst theBoxInsts[]=
{
{17,8856,27,-929,0,12,10,2.103120f,1.219200f,6.102096f},
{18,4634,27,-929,0,12,10,2.103120f,1.219200f,6.102096f},
{19,6745,1084,-929,0,12,10,2.103120f,1.219200f,6.102096f},
{20,6745,-1028,-929,0,12,10,2.103120f,1.219200f,6.102096f},
{17,4970,27,-638,0,13,11,2.103120f,1.219200f,6.102096f},
{18,8502,27,-638,0,13,11,2.103120f,1.219200f,6.102096f},
{19,6736,-856,-638,0,13,11,2.103120f,1.219200f,6.102096f},
{20,6736,911,-638,0,13,11,2.103120f,1.219200f,6.102096f},
{21,5519,-1916,-166,0,3,2,1.271931f,6.522720f,1.891589f},
{22,7957,-1916,-157,0,3,2,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,3,2,1.271931f,6.522721f,1.891589f},
{24,6745,-1916,-1214,0,3,2,1.271931f,6.522720f,1.891589f},
{21,5519,-1916,-166,0,4,3,1.271930f,6.522719f,1.891589f},
{22,7957,-1916,-157,0,4,3,1.271930f,6.522719f,1.891589f},
{23,6736,-1916,1021,0,4,3,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,4,3,1.271931f,6.522719f,1.891589f},
{21,5519,-1916,-166,0,5,4,1.271931f,6.522719f,1.891588f},
{22,7957,-1916,-157,0,5,4,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,5,4,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,5,4,1.271930f,6.522719f,1.891589f},
{25,5519,-1916,-166,0,6,5,1.271931f,6.522719f,1.891589f},
{22,7957,-1916,-157,0,6,5,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,6,5,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,6,5,1.271930f,6.522719f,1.891589f},
{21,5519,-1916,-166,0,7,6,1.271931f,6.522720f,1.891589f},
{22,7957,-1916,-157,0,7,6,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,7,6,1.271931f,6.522721f,1.891589f},
{24,6745,-1916,-1214,0,7,6,1.271931f,6.522720f,1.891589f},
{21,5519,-1916,-166,0,8,7,1.271931f,6.522719f,1.891588f},
{22,7957,-1916,-157,0,8,7,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,8,7,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,8,7,1.271930f,6.522719f,1.891589f},
{25,5519,-1916,-166,0,9,8,1.271931f,6.522719f,1.891589f},
{22,7957,-1916,-157,0,9,8,1.271931f,6.522720f,1.891589f},
{23,6736,-1916,1021,0,9,8,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,9,8,1.271930f,6.522719f,1.891589f},
{21,5519,-1916,-166,0,10,9,1.271930f,6.522719f,1.891589f},
{22,7957,-1916,-157,0,10,9,1.271930f,6.522719f,1.891589f},
{23,6736,-1916,1021,0,10,9,1.271931f,6.522720f,1.891589f},
{24,6745,-1916,-1214,0,10,9,1.271931f,6.522719f,1.891589f},
{26,6703,-28,-2,0,14,12,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,14,12,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,15,13,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,15,13,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,16,14,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,16,14,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,17,15,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,17,15,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,18,16,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,18,16,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,19,17,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,19,17,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,20,18,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,20,18,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,21,19,2.053633f,0.328581f,0.821453f},
{26,6705,84,-4,0,21,19,2.053633f,0.328581f,0.821453f},
{26,6703,-28,-2,0,22,20,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,22,20,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,23,21,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,23,21,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,24,22,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,24,22,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,25,23,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,25,23,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,26,24,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,26,24,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,27,25,2.053631f,0.328581f,0.821453f},
{26,6705,84,-4,0,27,25,2.053631f,0.328581f,0.821453f},
{26,6703,-28,-2,0,28,26,2.053632f,0.328581f,0.821453f},
{26,6705,84,-4,0,28,26,2.053632f,0.328581f,0.821453f},
{26,6703,-28,-2,0,29,27,2.053632f,0.328582f,0.821453f},
{26,6705,84,-4,0,29,27,2.053632f,0.328582f,0.821453f}
};

TorusInst theTorusInsts[]=
{
{27,6740,52,-4956,0,-1,-1,13.368955f},
{28,6715,42,4956,0,-1,-1,13.368955f},
{29,6745,27,416,1,12,10,7.843735f},
{29,6745,27,973,2,12,10,6.464866f},
{29,6736,27,-1198,2,13,11,6.464863f},
{29,6736,27,-641,1,13,11,7.843732f},
{29,6740,27,2241,3,30,28,9.715066f},
{29,6740,27,-2465,3,31,-1,9.715062f},
{16,6740,-1539,-112,4,3,2,7.760977f},
{16,6740,-2180,-112,4,3,2,7.760977f},
{30,6758,-2149,-112,4,4,3,7.760977f},
{30,6758,-1508,-112,4,4,3,7.760977f},
{31,6740,-2166,-112,4,5,4,7.760977f},
{31,6740,-1534,-112,4,5,4,7.760977f},
{32,6740,-1501,-112,4,6,5,7.760977f},
{32,6740,-2142,-112,4,6,5,7.760977f},
{16,6740,-1550,-142,4,7,6,7.760977f},
{16,6740,-2191,-142,4,7,6,7.760977f},
{31,6723,-2239,-142,4,8,7,7.760977f},
{31,6723,-1598,-142,4,8,7,7.760977f},
{32,6740,-1574,-142,4,9,8,7.760977f},
{32,6740,-2214,-142,4,9,8,7.760977f},
{33,6814,-1496,-76,4,10,9,7.760977f},
{33,6814,-2137,-76,4,10,9,7.760977f},
{34,6682,28,-94,5,14,12,0.980577f},
{34,6740,28,-112,5,14,12,0.980577f},
{35,6726,28,-108,5,14,12,0.980578f},
{35,6726,28,-108,5,15,13,0.980578f},
{34,6682,28,-94,5,15,13,0.980577f},
{34,6740,28,-112,5,15,13,0.980577f},
{34,6740,28,-112,5,16,14,0.980577f},
{34,6682,28,-94,5,16,14,0.980577f},
{35,6726,28,-108,5,16,14,0.980578f},
{35,6726,28,-108,5,17,15,0.980578f},
{34,6682,28,-94,5,17,15,0.980577f},
{34,6740,28,-112,5,17,15,0.980577f},
{35,6726,28,-108,5,18,16,0.980578f},
{34,6682,28,-94,5,18,16,0.980577f},
{34,6740,28,-112,5,18,16,0.980577f},
{35,6726,28,-108,5,19,17,0.980578f},
{34,6682,28,-94,5,19,17,0.980578f},
{34,6740,28,-112,5,19,17,0.980578f},
{35,6726,28,-108,5,20,18,0.980578f},
{34,6682,28,-94,5,20,18,0.980577f},
{34,6740,28,-112,5,20,18,0.980577f},
{35,6726,28,-108,5,21,19,0.980578f},
{34,6682,28,-94,5,21,19,0.980577f},
{34,6740,28,-112,5,21,19,0.980577f},
{35,6726,28,-108,5,22,20,0.980578f},
{34,6682,28,-94,5,22,20,0.980577f},
{34,6740,28,-112,5,22,20,0.980577f},
{34,6740,28,-112,5,23,21,0.980578f},
{35,6726,28,-108,5,23,21,0.980578f},
{34,6682,28,-94,5,23,21,0.980578f},
{34,6740,28,-112,5,24,22,0.980577f},
{35,6726,28,-108,5,24,22,0.980577f},
{34,6682,28,-94,5,24,22,0.980577f},
{34,6682,28,-94,5,25,23,0.980577f},
{35,6726,28,-108,5,25,23,0.980578f},
{34,6740,28,-112,5,25,23,0.980577f},
{34,6740,28,-112,5,26,24,0.980577f},
{35,6726,28,-108,5,26,24,0.980578f},
{34,6682,28,-94,5,26,24,0.980577f},
{34,6740,28,-112,5,27,25,0.980577f},
{35,6726,28,-108,5,27,25,0.980577f},
{34,6682,28,-94,5,27,25,0.980577f},
{34,6740,28,-112,5,28,26,0.980577f},
{35,6726,28,-108,5,28,26,0.980577f},
{34,6682,28,-94,5,28,26,0.980577f},
{34,6740,28,-112,5,29,27,0.980578f},
{35,6726,28,-108,5,29,27,0.980577f},
{34,6682,28,-94,5,29,27,0.980578f},
{36,6764,2981,-6140,6,-1,-1,5.359474f},
{37,6744,2295,6305,6,-1,-1,5.359473f},
{37,6744,3669,6305,6,-1,-1,5.359473f},
{37,6744,2982,6305,6,-1,-1,5.359473f},
{36,6764,2295,-6140,6,-1,-1,5.359474f},
{36,6764,3669,-6140,6,-1,-1,5.359474f},
{36,6764,-3081,-6140,6,-1,-1,5.359474f},
{37,6744,-3080,6305,6,-1,-1,5.359473f},
{37,6744,-2393,6305,6,-1,-1,5.359473f},
{36,6764,-2393,-6140,6,-1,-1,5.359474f},
{36,6764,-3767,-6140,6,-1,-1,5.359474f},
{37,6744,-3767,6305,6,-1,-1,5.359473f}
};

TorusVers theTorusVers[]=
{
{0.076322f,32,12},
{0.079062f,32,10},
{0.057254f,32,10},
{0.082361f,24,10},
{0.166786f,32,8},
{0.078551f,12,6},
{0.165014f,32,10}
};

ConeInst theConeInsts[]=
{
{2,-2836,4798,1044,0,-1,-1},
{0,-2836,4798,-1276,0,-1,-1},
{2,-2836,-4804,1044,0,-1,-1},
{0,-2836,-4804,-1276,0,-1,-1},
{2,16367,-4804,1044,0,-1,-1},
{0,16367,-4804,-1276,0,-1,-1},
{2,16367,4798,1044,0,-1,-1},
{0,16367,4798,-1276,0,-1,-1},
{2,6748,8169,1044,0,-1,-1},
{0,6748,8169,-1276,0,-1,-1},
{38,3029,1849,-6322,1,-1,-1},
{39,10379,1885,-6322,1,-1,-1},
{40,3101,-1830,-6322,1,-1,-1},
{41,10452,-1793,-6322,1,-1,-1},
{42,10426,1839,6322,1,-1,-1},
{43,3076,1875,6322,1,-1,-1},
{44,10354,-1840,6322,1,-1,-1},
{45,3003,-1803,6322,1,-1,-1},
{46,6980,26,-185,2,14,12},
{46,6980,26,-185,2,15,13},
{46,6980,26,-185,2,16,14},
{46,6980,26,-185,2,17,15},
{46,6980,26,-185,2,18,16},
{46,6980,26,-185,2,19,17},
{46,6980,26,-185,2,20,18},
{46,6980,26,-185,2,21,19},
{46,6980,26,-185,2,22,20},
{46,6980,26,-185,2,23,21},
{46,6980,26,-185,2,24,22},
{46,6980,26,-185,2,25,23},
{46,6980,26,-185,2,26,24},
{46,6980,26,-185,2,27,25},
{46,6980,26,-185,2,28,26},
{46,6980,26,-185,2,29,27}
};

ConeVers theConeVers[]=
{
{3.594747f,2.523780f,6.400800f,2,10},
{5.576570f,5.387035f,7.578804f,1,16},
{0.268712f,0.138889f,3.377083f,1,8}
};

SurfOfRevInst theSurfOfRevInsts[]=
{
{47,9275,94,-5620,0,-1,-1},
{36,4180,84,5620,0,-1,-1},
{37,4182,27,-1372,1,12,10},
{37,9299,27,1147,2,13,11},
{48,8556,-881,1620,3,30,28},
{49,6740,-1258,-1836,4,31,-1}
};

SurfOfRevVers theSurfOfRevVers[]=
{
{{-4.359139f,-2.958513f,-0.000000f,4,1.970802f,-2.925227f,-0.000000f,4,1.970802f,-3.197081f,0.000000f,4,1.988851f,-3.298593f,-0.000000f,3,2.027048f,-3.375998f,-0.000000f,3,2.084253f,-3.432359f,-0.000000f,3,2.159328f,-3.470741f,-0.000000f,3,2.251134f,-3.494205f,-0.000000f,3,2.358533f,-3.505817f,-0.000000f,3,2.480385f,-3.508639f,-0.000000f,4,2.566736f,-3.500061f,-0.000000f,3,2.641094f,-3.472886f,-0.000000f,3,2.704348f,-3.431704f,-0.000000f,3,2.757388f,-3.381108f,-0.000000f,3,2.801100f,-3.325687f,-0.000000f,3,2.836375f,-3.270034f,-0.000000f,3,2.864100f,-3.218738f,0.000000f,4,11.824816f,17.751820f,0.000000f,4,-4.380587f,17.751820f,0.000000f,4},0.000000f,1.000000f,0.000000f,-10.616185f,0.000000f,0.000000f,24,19},
{{-5.504433f,-10.641512f,0.000000f,4,-4.774506f,-10.642336f,0.000000f,4,-3.894176f,-10.139321f,0.000000f,4,-3.686893f,-9.865250f,0.000000f,4,-1.490274f,-0.327833f,0.000001f,4,-5.505459f,-0.327833f,-0.000000f,4},0.000000f,1.000000f,0.000000f,-10.586493f,-0.000000f,-0.000000f,24,6},
{{5.504433f,10.569339f,-0.000002f,4,5.464631f,10.713093f,-0.000002f,3,5.382375f,10.793278f,-0.000002f,3,5.247026f,10.808883f,-0.000002f,3,5.047949f,10.758904f,-0.000002f,3,4.774506f,10.642333f,-0.000002f,4,3.894175f,10.139318f,-0.000002f,4,3.839351f,10.110714f,-0.000002f,3,3.792788f,10.076303f,-0.000001f,3,3.752907f,10.028785f,-0.000001f,3,3.718134f,9.960867f,-0.000001f,3,3.686892f,9.865248f,-0.000001f,4,1.490273f,0.327833f,-0.000001f,4,5.505459f,0.327833f,0.000000f,4},0.000000f,-1.000000f,0.000000f,10.586493f,-0.000000f,0.000000f,24,14},
{{-8.638294f,3.612662f,0.000001f,4,-2.510784f,3.622479f,0.000001f,4,-2.510784f,-2.186819f,0.000001f,4,-0.669379f,-2.186883f,0.000000f,4,4.378792f,17.751820f,0.000001f,4,-8.659742f,17.751820f,0.000000f,4},0.000000f,1.000000f,0.000000f,-10.616185f,0.000000f,0.000000f,24,6},
{{8.638292f,-3.612659f,-0.000001f,4,2.510784f,-3.622476f,-0.000001f,4,2.510783f,2.186817f,-0.000000f,4,0.669379f,2.186882f,-0.000000f,4,-4.378790f,-17.751804f,-0.000001f,4,8.659740f,-17.751804f,-0.000000f,4},0.000000f,-1.000000f,-0.000000f,10.616182f,-0.000000f,0.000000f,24,6}
};

#endif //__DEFAULT_NAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\SOS.C ===
/*
 *	Sound Operating System
 */



#include "sos.h"
#include "protos.h"
#include "ftables.h"			/* event/call function tables */

#include "externs.h"
#include <xtl.h>

#include <stdio.h>


unsigned char	sound_call;

//WCHAR	StringBuffer[256];

//extern	uchar	max_tracks;
extern	uchar	max_sound_call;
extern	ushort	default_clock_value;
extern	const ushort	max_processes;
extern	_base_	uchar	gtifbtmp;

#define	c_p	current_process

/* 
 * boolean T if a sound call is in buffer 
 */
#define	CALL_WAITING  (fifo.fifo_read != fifo.fifo_write)
/*
 * return the sound call in the buffer 
 */


/*************************************************************************
*                                                                        *
* 	Call main if we are going to do sos only						  *
* 	call do_sos_init_return followed by repeated calls to			  *
* 	sos_main if we are just part of another program					  *
*                                                                        *
*************************************************************************/

void	sos_main(void)
{
	struct	process	*tpp;
	do {
	    if (CALL_WAITING) {
			sound_call = get_fifo();
#if DBG
//			swprintf( StringBuffer, L"Current Sound: %d", sound_call);
#endif
			if (sound_call > max_sound_call)
		   	 	continue;
			current_call = &sound_calls[sound_call];
			call_fcns[current_call->type]();
	    }

		current_process = process_queue->next;
		while (current_process != (struct process *)NULL) {
		    tpp = current_process->next;
//			DINT;

				c_p->timer = c_p->timer +c_p->prev_timer - system_clock_music;
				current_process->prev_timer = system_clock_music;


//			EINT;
		    if (current_process->timer < 0) {
				current_channel = current_process->hard_channel;
				current_level = current_process->level;
/*				gtifbtmp = current_channel + current_level*max_tracks;*/
				if (current_level == 0)
					gtifbtmp = current_channel;
				else
					gtifbtmp = current_channel + max_tracks;
				ti = &(track_status[gtifbtmp]);
				if (event_fcns[current_process->function]() == 0) {
					current_process = process_queue->next;
					break;
				}
		    }
		    current_process = tpp;
		}
	} while (sos_only);
}



void	do_sos_init_return()
{

	sos_only = 0;
	fifo.fifo_read = 0;	
	fifo.fifo_write = 0;	
	dev_init();
	init_queuelist();
//	clock_cntr_value[0] = default_clock_value;
	system_clock_music = 1;
	sound_call_table = 0;
}

/*************************************************************************
*                                                                        *
* 	Put the value, value in the receive fifo			  *
*                                                                        *
*************************************************************************/

void put_fifo(uchar value)
{
	fifo.data[fifo.fifo_write++] = value;
	if (fifo.fifo_write >= FIFO_SIZE)
	    fifo.fifo_write = 0;
}

/*************************************************************************
*                                                                        *
* 	Get the next byte in the receive fifo				  *
*                                                                        *
*************************************************************************/
uchar	get_fifo(void)
{
	uchar	retval;

	retval = fifo.data[fifo.fifo_read++];
	if (fifo.fifo_read >= FIFO_SIZE)
	    fifo.fifo_read = 0;
	return(retval);
}
init_queuelist()
{
	uchar	i;
	queue_list[0].prev = (struct process *)NULL;
	queue_list[0].next = &(queue_list[1]);
	for (i = 1; i < max_processes - 1; i++) {
	    queue_list[i].next = &(queue_list[i+1]);	
	    queue_list[i].prev = &(queue_list[i-1]);
	}
	queue_list[max_processes-1].next = (struct process *)NULL;
	queue_list[max_processes-1].prev = &(queue_list[max_processes-2]);

	if ((process_queue = get_process_packet()) == NULL) {
//	    sos_error(SOS_NO_MEM);
	    return(0);
	}
	(*process_queue).next = (struct process *)NULL;
	process_queue->prev = (struct process *)NULL;
	for (i = 0; i < max_tracks; i++)
	    channel_level[i] = 0;
	return(0);
}


void	sos_error(int n)
{

}


/*************************************************************************
*                                                                        *
* 	Utilities for SOS						  *
*                                                                        *
*************************************************************************/



struct track_info *get_track_info_block()
{
	gtifbtmp = (current_level)*max_tracks + current_channel;	
	return(&(track_status[gtifbtmp]));
}
struct track_info *get_track_info_block2(uchar level, uchar chan)
{
	gtifbtmp = (level)*max_tracks + chan;	
	return(&(track_status[gtifbtmp]));
}

struct track_info *get_music_info_block()
{
#if LEVEL_MUSIC==0
	return(&(track_status[current_channel]));
#else
	gtifbtmp = (LEVEL_MUSIC)*max_tracks + current_channel;	
	return(&(track_status[gtifbtmp]));
#endif
}

	
struct track_info *get_music_info_block_i(uchar i)
{
#if LEVEL_MUSIC==0
	return(&(track_status[i]));
#else
	gtifbtmp = (LEVEL_MUSIC)*max_tracks + i;
	return(&(track_status[gtifbtmp]));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\Shield.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: Shield.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "xbs_math.h"
#include "xbs_app.h"
#include "qrand.h"
#include "Shield.h"
#include "tex_gen.h"

///////////////////////////////////////////////////////////////////////////////
D3DVECTOR Shield::ms_Pos;
const float SHIELD_ROTATION_RATE = (2.0f);
///////////////////////////////////////////////////////////////////////////////
void Shield::Init()
{
	m_RadiusScale = 1.0f;
	m_Speed = 1.0f;
}
///////////////////////////////////////////////////////////////////////////////
void Shield::create()
{
}
///////////////////////////////////////////////////////////////////////////////
void Shield::destroy()
{
	// Nothing to do.
}
///////////////////////////////////////////////////////////////////////////////
void Shield::render(const D3DMATRIX& mat_wtp)
{
	D3DMATRIX transp;
	SetTranspose(m_CurMatrix, &transp);
	gpd3dDev->SetVertexShaderConstant(0,(CONST void *)&transp,4);
	// The ShieldMgr will do the rest of the rendering.
}
///////////////////////////////////////////////////////////////////////////////
void Shield::advanceTime(float fElapsedTime, float fDt)
{
	D3DVECTOR4 quat;

	float pushout_radius = max(0.0f, (PUSHOUT_START_TIME + PUSHOUT_DELTA - fElapsedTime) * OO_PUSHOUT_DELTA);
	pushout_radius = START_PUSHOUT_RADIUS * pushout_radius*pushout_radius;

//MTS	if (gApp.getPulseIntensity() > 0.0f) m_Speed += fDt * 1.65f;
	m_Speed += fDt * 0.8f;

	float theta = fDt * SHIELD_ROTATION_RATE * m_Speed + m_ThetaZero;
	m_ThetaZero = theta;

	SetQuatFromAxis(m_RotationDir, theta, &quat);
	D3DMATRIX mat;
	SetRotationFromRHQuat(quat, &mat);
	MulMats(m_StartRotation, mat, &m_CurMatrix);

	m_CurMatrix._11 *= m_RadiusScale;
	m_CurMatrix._12 *= m_RadiusScale;
	m_CurMatrix._13 *= m_RadiusScale;
	m_CurMatrix._21 *= m_RadiusScale;
	m_CurMatrix._22 *= m_RadiusScale;
	m_CurMatrix._23 *= m_RadiusScale;
	m_CurMatrix._31 *= m_RadiusScale;
	m_CurMatrix._32 *= m_RadiusScale;
	m_CurMatrix._33 *= m_RadiusScale;
//MTS	m_CurMatrix._41 = ms_Pos.x;
//MTS	m_CurMatrix._42 = ms_Pos.y;
//MTS	m_CurMatrix._43 = ms_Pos.z;
	// Adjusted so that the reflection is now stationary as the shield moves around.
	m_CurMatrix._41 = ms_Pos.x + m_CurMatrix._11 * (2.0f + pushout_radius);
	m_CurMatrix._42 = ms_Pos.y + m_CurMatrix._12 * (2.0f + pushout_radius);
	m_CurMatrix._43 = ms_Pos.z + m_CurMatrix._13 * (2.0f);

//MTS	bool b_far_side = m_CurCenter.y > ms_Pos.y;
	TransformPoint(m_ObjectCenter, m_CurMatrix, &m_CurCenter);
}
///////////////////////////////////////////////////////////////////////////////
void Shield::restart(float radian_extent)
{
	float crossing_radian = gApp.fRand01() * 2.09f * Pi;

	// Find the constants to make this happen.
	// First pick a "peak" orientation.
	const float f_RY_ARC = Pi * 1.2f;
	bool b_flipped = false;

	float rz = gApp.fRand01() * 2.0f * Pi;
	float ry = gApp.fRand01() * f_RY_ARC * 2.0f - f_RY_ARC*0.5f;

	if (ry > f_RY_ARC * 0.5f)
	{
		ry += Pi - f_RY_ARC;
		b_flipped = true;
	}

	if (b_flipped)
	{
		m_ThetaZero = rz + Pi - crossing_radian;
	}
	else
	{
		m_ThetaZero = - rz - crossing_radian;
	}

//MTS	char buf[512];
//MTS	sprintf(buf, "Ry=%f, Rz=%f, theta_zero=%f, crossing_radian=%f\n",
//MTS		ry, rz, m_ThetaZero, crossing_radian);
//MTS	OutputDebugString(buf);

	// Rotate around ry
	// Rotate around rz
	D3DMATRIX mat1, mat2;
	SetYRotation(ry, &mat1);
	SetZRotation(rz, &mat2);
	MulMats(mat1, mat2, &m_StartRotation);
	m_RotationDir.x = m_StartRotation._31;
	m_RotationDir.y = m_StartRotation._32;
	m_RotationDir.z = m_StartRotation._33;
//MTS	sprintf(buf, "    RotationDir=%+f,%+f,%+f\n",
//MTS		m_RotationDir.x, m_RotationDir.y, m_RotationDir.z);
//MTS	OutputDebugString(buf);

	m_Speed = 0.0f;
	
	advanceTime(0.0f, 0.0f);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void ZShield::Init()
{
	m_pShieldVB = NULL;
	m_pShieldIB = NULL;
	m_dwNumVertices = m_dwNumIndices = 0;
	m_Speed = 0.0f;
	m_Theta = 0.0f;
}
///////////////////////////////////////////////////////////////////////////////
void ZShield::create()
{
}
///////////////////////////////////////////////////////////////////////////////
void ZShield::destroy()
{
#define XBS_RELEASE(a) if (a) a->Release(); a = NULL;
	XBS_RELEASE(m_pShieldVB);
	XBS_RELEASE(m_pShieldIB);
#undef XBS_RELEASE
	m_dwNumVertices = 0;
	m_dwNumIndices = 0;
}
///////////////////////////////////////////////////////////////////////////////
void ZShield::render(const D3DMATRIX& mat_wtp)
{
	D3DMATRIX transp;
	SetTranspose(m_CurMatrix, &transp);
	gpd3dDev->SetVertexShaderConstant(0,(CONST void *)&transp,4);

	gpd3dDev->SetStreamSource(0, m_pShieldVB, sizeof(ShieldVertex));
	gpd3dDev->SetIndices(m_pShieldIB, 0);
	gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP, 0, m_dwNumVertices,  0, m_dwNumIndices-2 );
}
///////////////////////////////////////////////////////////////////////////////
void ZShield::advanceTime(float fElapsedTime, float fDt)
{
//MTS	if (gApp.getPulseIntensity() > 0.0f) m_Speed += fDt * 1.0f;
	m_Speed += fDt * 0.8f;
	m_Theta += m_Speed * fDt;


	float pushout_radius = max(0.0f, (PUSHOUT_START_TIME + PUSHOUT_DELTA - fElapsedTime) * OO_PUSHOUT_DELTA);
	pushout_radius = START_PUSHOUT_RADIUS * pushout_radius*pushout_radius;

	SetZRotation(m_Theta, &m_CurMatrix);
	m_CurMatrix._41 += m_CurMatrix._11 * (2.0f + pushout_radius);
	m_CurMatrix._42 += m_CurMatrix._12 * (2.0f + pushout_radius);
	m_CurMatrix._43 += m_CurMatrix._13 * (2.0f);
}
///////////////////////////////////////////////////////////////////////////////
// returns the new start_radian, from bottom (-Pi/2) up.
void ZShield::restart(float start_radian, float end_radian, float outside_radius)
{
	destroy();

	m_Theta = gApp.fRand01() * 2.0f * Pi;
	m_Speed = 0.0f;


	// Create the index and vertex buffers.
	const int width = 8;		// number of panels, one less than the number of vertices
	const int height = 6;
	const float inside_radius = outside_radius - 0.5f;
	const float f_vert_radians = end_radian - start_radian;
	const float f_horiz_radians = 1.2f;

	int num_verts_per_face = (height+1) * (width+1);
	int num_side_verts = 2*2*(height+1) + 2*2*(width+1);
	m_dwNumVertices = 
				2*num_verts_per_face +			// top and bottom
				num_side_verts;					// edges

	m_dwNumIndices =
				GetNumberOfIndicesForTristripMesh(width, height, false, true) +
				GetNumberOfIndicesForTristripMesh(width, height, true, true) +
				(height+1)*2 + 2 +
				(width+1)*2 + 2 +
				(height+1)*2 + 2 +
				(width+1)*2 + 1;

	gpd3dDev->CreateVertexBuffer( m_dwNumVertices * sizeof(ShieldVertex), 0, 0, 0, &m_pShieldVB);
	gpd3dDev->CreateIndexBuffer(  m_dwNumIndices  * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pShieldIB);




	// Vertex index is (y*(width+1) + x) + ((inside_face) ? num_verts_per_face+num_side_verts : 0)
	// or for the sides num_verts_per_face + 2*(clockwise position from ll) + ((inside_face) ? 1 : 0


	ShieldVertex* p_verts;
	m_pShieldVB->Lock(0, 0, (BYTE**)&p_verts, 0);
	ShieldVertex* pverto = &p_verts[0];
	ShieldVertex* pverti = &p_verts[num_verts_per_face+num_side_verts];

	float f_left_rad   = -0.5f * f_horiz_radians;
	float f_right_rad  = +0.5f * f_horiz_radians;
	float f_top_rad    = end_radian;
	float f_bottom_rad = start_radian;
	float f_horiz_step = (f_right_rad-f_left_rad) / ((float)width);
	float f_vert_step  = (f_top_rad-f_bottom_rad) / ((float)height);

	int i,j;
	float f_i, f_j;

	for (j=0, f_j=f_bottom_rad; j<=height; j++, f_j+=f_vert_step)
	{
		float vs,vc;
		SinCos(f_j, &vs, &vc);
		for (i=0, f_i=f_left_rad; i<=width; i++, f_i+=f_horiz_step)
		{
			float hs,hc;
			SinCos(f_i, &hs, &hc);

			D3DVECTOR norm;
			Set(&norm, vc*hc, vc*hs, vs);

			Set(&pverto->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
			pverto->normal = norm;
			pverto++;
			Set(&pverti->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
			pverti->normal = norm;
			Scale(&pverti->normal, -1.0f);
			pverti++;

			if ((!j) && (i==width)) f_right_rad = f_i;		// set it exactly to what we iterate to
		}
		if (j==height) f_top_rad = f_j;						// set it exactly to what we iterate to
	}

	ShieldVertex* pvert = pverto;


	// Fill in the vertices around the edges.
	f_i = f_left_rad;
	float vs,vc,hs,hc;

	// Start at left, move up.
	SinCos(f_i, &hs, &hc);
	for (j=0, f_j=f_bottom_rad; j<=height; j++, f_j+=f_vert_step)
	{
		SinCos(f_j, &vs, &vc);

		D3DVECTOR norm, side;
		Set(&norm, vc*hc, vc*hs, vs);
		Set(&side, hs, -hc, 0.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}
	j = height;
	f_j = f_top_rad;

	// At UL, move right
	for (i=0, f_i=f_left_rad; i<=width; i++, f_i+=f_horiz_step)
	{
		SinCos(f_i, &hs, &hc);

		D3DVECTOR norm, side;
		Set(&norm, vc*hc, vc*hs, vs);
		Set(&side, -vs*hc, -vs*hs, vc);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// At UR, move down
	for (j=height, f_j=f_top_rad; j>=0; j--, f_j-=f_vert_step)
	{
		if (!j) f_j=f_bottom_rad;
		SinCos(f_j, &vs, &vc);

		D3DVECTOR norm, side;
		Set(&norm, vc*hc, vc*hs, vs);
		Set(&side, -hs, hc, 0.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// At LR, move left
	for (i=width, f_i=f_right_rad; i>=0; i--, f_i-=f_horiz_step)
	{
		if (!i) f_i=f_left_rad;
		SinCos(f_i, &hs, &hc);

		D3DVECTOR norm, side;
		Set(&norm, vc*hc, vc*hs, vs);
		Set(&side, vs*hc, vs*hs, -vc);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// Done with the vertices!
	m_pShieldVB->Unlock();






	WORD* p_indices;
	m_pShieldIB->Lock(0, 0, (BYTE**)&p_indices, 0);

	// Vertex index is (y*(width+1) + x) + ((inside_face) ? num_verts_per_face : 0)
	// or for the sides 2*num_verts_per_face + 2*(clockwise position from ll) + ((inside_face) ? 1 : 0

	// Outside surface.
	int index_num = 0;
	index_num += CreateTristripForMesh(&p_indices[index_num], width, height, false, true, 0);
	index_num += CreateTristripForMesh(&p_indices[index_num], width, height,  true, true, num_verts_per_face+num_side_verts+width, 0, -1);

	int vertex_index = num_verts_per_face;

	// Sides
	for (i=0; i<4; i++)
	{
		p_indices[index_num++] = (WORD)vertex_index;	// first tap of a double-tap

		int length = (i&1) ? width : height;
		for (j=0; j<=length; j++)
		{
			p_indices[index_num++] = vertex_index + 0;
			p_indices[index_num++] = vertex_index + 1;
			vertex_index += 2;
		}
		if (i<3) p_indices[index_num++] = vertex_index - 1;	// double-tap
	}

	m_pShieldIB->Unlock();

}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::Init()
{
    int i;

    for (i = 0; i < MAX_SHIELDS; i++)
    {
        m_Shields[i].Init();
    }

    for (int i = 0; i < MAX_ZSHIELDS; i++)
    {
        m_ZShields[i].Init();
    }

	m_NumShields = 0;
	m_pShieldVB = NULL;
	m_pShieldIB = NULL;
	m_dwNumVertices = 0;
	m_dwNumIndices = 0;
	m_dwPShader = 0;
	m_dwVShader = 0;

	Set(&m_Pos, 0.0f, 0.0f, 0.0f);
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::create()
{
	// Make the meshes and stuff.
	const int width = 8;		// number of panels, one less than the number of vertices
	const int height = 6;
	const float inside_radius = 13.1f;
	const float outside_radius = 14.0f;
	const float f_vert_dim = 0.9f;
	const float f_horiz_dim = 1.2f;
	// Partial sphere surface is made by generating a mesh at x=1.0f, and normalizing the vertices.

	m_RadiusScale = 1.0f - 1.2f * (outside_radius-inside_radius) / outside_radius;
	m_MidRadius = (inside_radius + outside_radius) * 0.5f;

	int num_verts_per_face = (height+1) * (width+1);
	int num_side_verts = 2*2*(height+1) + 2*2*(width+1);
	m_dwNumVertices = 
				2*num_verts_per_face +			// top and bottom
				num_side_verts;					// edges

	m_dwNumIndices =
				GetNumberOfIndicesForTristripMesh(width, height, false, true) +
				GetNumberOfIndicesForTristripMesh(width, height, true, true) +
				(height+1)*2 + 2 +
				(width+1)*2 + 2 +
				(height+1)*2 + 2 +
				(width+1)*2 + 1;

	gpd3dDev->CreateVertexBuffer( m_dwNumVertices * sizeof(ShieldVertex), 0, 0, 0, &m_pShieldVB);
	gpd3dDev->CreateIndexBuffer(  m_dwNumIndices  * sizeof(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pShieldIB);




	// Vertex index is (y*(width+1) + x) + ((inside_face) ? num_verts_per_face+num_side_verts : 0)
	// or for the sides num_verts_per_face + 2*(clockwise position from ll) + ((inside_face) ? 1 : 0


	ShieldVertex* p_verts;
	m_pShieldVB->Lock(0, 0, (BYTE**)&p_verts, 0);
	ShieldVertex* pverto = &p_verts[0];
	ShieldVertex* pverti = &p_verts[num_verts_per_face+num_side_verts];

	float f_left_c		= -0.5f * f_horiz_dim;
	float f_right_c		= +0.5f * f_horiz_dim;
	float f_top_c		= +0.5f * f_vert_dim;
	float f_bottom_c	= -0.5f * f_vert_dim;
	float f_horiz_step	= (f_right_c-f_left_c) / ((float)width);
	float f_vert_step	= (f_top_c-f_bottom_c) / ((float)height);

	int i,j;
	float f_i, f_j;

	for (j=0, f_j=f_bottom_c; j<=height; j++, f_j+=f_vert_step)
	{
		for (i=0, f_i=f_left_c; i<=width; i++, f_i+=f_horiz_step)
		{
			D3DVECTOR norm;
			Set(&norm, 1.0f, f_i, f_j);
			Normalize(&norm);

			Set(&pverto->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
			pverto->normal = norm;
			pverto++;
			Set(&pverti->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
			pverti->normal = norm;
			Scale(&pverti->normal, -1.0f);
			pverti++;

			if ((!j) && (i==width)) f_right_c = f_i;		// set it exactly to what we iterate to
		}
		if (j==height) f_top_c = f_j;						// set it exactly to what we iterate to
	}

	ShieldVertex* pvert = pverto;


	// Fill in the vertices around the edges.
	f_i = f_left_c;

	// Start at left, move up.
	for (j=0, f_j=f_bottom_c; j<=height; j++, f_j+=f_vert_step)
	{
		D3DVECTOR norm, side;
		Set(&norm, 1.0f, f_i, f_j);
		Normalize(&norm);

		Set(&side, 0.0f, -1.0f, 0.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}
	j = height;
	f_j = f_top_c;

	// At UL, move right
	for (i=0, f_i=f_left_c; i<=width; i++, f_i+=f_horiz_step)
	{
		D3DVECTOR norm, side;
		Set(&norm, 1.0f, f_i, f_j);
		Normalize(&norm);

		Set(&side, 0.0f, 0.0f, +1.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// At UR, move down
	f_i = f_right_c;
	for (j=height, f_j=f_top_c; j>=0; j--, f_j-=f_vert_step)
	{
		if (!j) f_j=f_bottom_c;

		D3DVECTOR norm, side;
		Set(&norm, 1.0f, f_i, f_j);
		Normalize(&norm);

		Set(&side, 0.0f, +1.0f, 0.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// At LR, move left
	f_j = f_bottom_c;
	for (i=width, f_i=f_right_c; i>=0; i--, f_i-=f_horiz_step)
	{
		if (!i) f_i=f_left_c;

		D3DVECTOR norm, side;
		Set(&norm, 1.0f, f_i, f_j);
		Normalize(&norm);

		Set(&side, 0.0f, 0.0f, -1.0f);

		Set(&pvert->position, outside_radius*norm.x, outside_radius*norm.y, outside_radius*norm.z);
		pvert->normal = side;
		pvert++;
		Set(&pvert->position,  inside_radius*norm.x,  inside_radius*norm.y,  inside_radius*norm.z);
		pvert->normal = side;
		pvert++;
	}

	// Done with the vertices!
	m_pShieldVB->Unlock();






	WORD* p_indices;
	m_pShieldIB->Lock(0, 0, (BYTE**)&p_indices, 0);

	// Vertex index is (y*(width+1) + x) + ((inside_face) ? num_verts_per_face : 0)
	// or for the sides 2*num_verts_per_face + 2*(clockwise position from ll) + ((inside_face) ? 1 : 0

	// Outside surface.
	int index_num = 0;
	index_num += CreateTristripForMesh(&p_indices[index_num], width, height, false, true, 0);
	index_num += CreateTristripForMesh(&p_indices[index_num], width, height,  true, true, num_verts_per_face+num_side_verts+width, 0, -1);

	int vertex_index = num_verts_per_face;

	// Sides
	for (i=0; i<4; i++)
	{
		p_indices[index_num++] = (WORD)vertex_index;	// first tap of a double-tap

		int length = (i&1) ? width : height;
		for (j=0; j<=length; j++)
		{
			p_indices[index_num++] = vertex_index + 0;
			p_indices[index_num++] = vertex_index + 1;
			vertex_index += 2;
		}
		if (i<3) p_indices[index_num++] = vertex_index - 1;	// double-tap
	}

	m_pShieldIB->Unlock();



	// Create the shaders.

	
	// Initialize the pixel shaders.
    if( m_dwPShader )
    {
        gpd3dDev->DeletePixelShader( m_dwPShader );
        m_dwPShader = 0;
    }
#ifndef BINARY_RESOURCE
	m_dwPShader = gApp.loadPixelShader("D:\\Shaders\\shield.xpu");
#else // BINARY_RESOURCE
	m_dwPShader = gApp.loadPixelShader(g_shield_xpu);
#endif // BINARY_RESOURCE

	

	// Initialize the vertex shaders.
    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),	// position
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),	// normal
        D3DVSD_END()
    };
	if (m_dwVShader)
	{
		gpd3dDev->DeleteVertexShader( m_dwVShader );
		m_dwVShader = 0;
	}
#ifndef BINARY_RESOURCE
	m_dwVShader = gApp.loadVertexShader("D:\\Shaders\\shield.xvu", dwShaderVertexDecl);
#else // BINARY_RESOURCE
	m_dwVShader = gApp.loadVertexShader(g_shield_xvu, dwShaderVertexDecl);
#endif // BINARY_RESOURCE



	for (i=0; i<MAX_SHIELDS; i++) m_Shields[i].create();
	for (i=0; i<MAX_ZSHIELDS; i++) m_ZShields[i].create();


	restart();
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::destroy()
{
	for (int i=0; i<m_NumShields; i++) m_Shields[i].destroy();
	m_NumShields = 0;

    if (m_dwPShader) gpd3dDev->DeletePixelShader(  m_dwPShader );
	if (m_dwVShader) gpd3dDev->DeleteVertexShader( m_dwVShader );
    m_dwPShader = 0;
	m_dwVShader = 0;

#define XBS_RELEASE(a) if (a) a->Release(); a = NULL;
	XBS_RELEASE(m_pShieldVB);
	XBS_RELEASE(m_pShieldIB);
#undef XBS_RELEASE
	m_dwNumVertices = 0;
	m_dwNumIndices  = 0;
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::render(bool b_far_side)
{
	// Set default states
    gpd3dDev->SetRenderState( D3DRS_LIGHTING, FALSE );
    gpd3dDev->SetRenderState( D3DRS_ZENABLE,  TRUE );
    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,  FALSE );

    gpd3dDev->SetTexture( 0, gApp.pStaticReflectionCubeMap );
	gpd3dDev->SetTexture( 1, gApp.pNormalCubeMapHiRes );
	gpd3dDev->SetTexture( 2, gApp.pNormalCubeMapHiRes );
	gpd3dDev->SetTexture( 3, gApp.pNormalCubeMapHiRes );


    gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

	gpd3dDev->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 1, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

	gpd3dDev->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 2, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

	
	gpd3dDev->SetTextureStageState( 3, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 3, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 3, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 3, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 3, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);


    gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    gpd3dDev->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    gpd3dDev->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );

    gpd3dDev->SetTexture( 0, gApp.pStaticReflectionCubeMap );
	gpd3dDev->SetTexture( 1, gApp.pNormalCubeMapHiRes );
	gpd3dDev->SetTexture( 2, gApp.pNormalCubeMapHiRes );
	gpd3dDev->SetTexture( 3, gApp.pNormalCubeMapHiRes );



    gpd3dDev->SetVertexShader( m_dwVShader );
    gpd3dDev->SetPixelShader(  m_dwPShader );




	D3DVECTOR cam_pos, look_dir, look_at;
	gApp.theCamera.getCameraPos (&cam_pos);
	gApp.theCamera.getCameraLook(&look_at);
	Sub(look_at, cam_pos, &look_dir);


	//; Expected vertex shaders constants
	//;    c0-c3    = Transpose of object to world matrix
	//;    c4-c7    = Transpose of view*projection matrix
	//;    c8       = some constants, x=0, y=1, z=2, w=0.5
	//;    c9       = eye location in world space
	//;    c10      = light pos in world space

    // Note: when passing matrices to a vertex shader, we transpose them, since
    // matrix multiplies are done with dot product operations on the matrix rows.
	D3DMATRIX matFinal,matWTP;
	MulMats(gApp.theCamera.matWTC,gApp.theCamera.matProj,&matWTP);
	SetTranspose(matWTP,&matFinal);
	gpd3dDev->SetVertexShaderConstant(4,(CONST void *)&matFinal,4);

	// Constants
	D3DVECTOR4 val[4];
	Set(&val[0], 0.0f, 1.0f, 2.0f, 0.5f);

	// Eye position
	Set(&val[1], cam_pos.x, cam_pos.y, cam_pos.z, 0.0f);

	// Blob Light position
	Set(&val[2],0.f,0.f,0.f,1.f);

	// Mood Light position
	const D3DVECTOR &mlp = gApp.moodLight.Position;
	Set(&val[3],mlp.x,mlp.y,mlp.z,1.f);

	gpd3dDev->SetVertexShaderConstant( 8, &val[0], 4 );

	// alpha
	float f_shading = 0.75f;	// 1 = black, 0 = no shading
	if (gApp.getElapsedTime() < SHIELD_FADE_IN_START_TIME + SHIELD_FADE_IN_DELTA)
	{
		f_shading *= (gApp.getElapsedTime() - SHIELD_FADE_IN_START_TIME) * OO_SHIELD_FADE_IN_DELTA;
	}
	else if (gApp.getElapsedTime() > SHIELD_FADE_OUT_START_TIME)
	{
		f_shading *= (SHIELD_FADE_OUT_START_TIME + SHIELD_FADE_OUT_DELTA - gApp.getElapsedTime()) * OO_SHIELD_FADE_OUT_DELTA;
	}
	f_shading = min(1.0f, max(0.0f, f_shading));
	Set(&val[0], 0.0f, 0.0f, 0.0f, f_shading);	// final alpha is 1.0f - f_shading

	// blob light
	float f_intensity = gApp.getBlobIntensity() * 2.f;
	float fscale = max(0.0f, min(1.0f, (gApp.getElapsedTime()-PUSHOUT_START_TIME) * OO_PUSHOUT_DELTA));
	f_intensity *= fscale*fscale;
	
	Set(&val[1], f_intensity, f_intensity, f_intensity, f_intensity);

	// Specular coefficient
	Set(&val[2], 0.4f,1.f,0.3f,1.f);
	gpd3dDev->SetPixelShaderConstant( 0, &val[0], 3 );


	gpd3dDev->SetIndices( m_pShieldIB, 0 );
    gpd3dDev->SetStreamSource( 0, m_pShieldVB, sizeof(ShieldVertex) );


	float shield_dot[MAX_SHIELDS];
	int shield_order[MAX_SHIELDS];
	int i;
	for (i=0; i<m_NumShields; i++)
	{
		shield_dot[i] = Dot(m_Shields[i].getCenter(), look_dir);
		shield_order[i] = i;
	}


	float f_blob_dot = Dot(m_Pos, look_dir);
	for (int j=m_NumShields-1; j>=0; j--)
	{
		int i = (b_far_side) ? m_NumShields-1-j : j;
		if (  (( b_far_side) && (shield_dot[i]>=f_blob_dot)) ||
			  ((!b_far_side) && (shield_dot[i]< f_blob_dot)) )
		{
			m_Shields[shield_order[i]].render(matWTP);
			gpd3dDev->DrawIndexedPrimitive( D3DPT_TRIANGLESTRIP, 0, m_dwNumVertices,  0, m_dwNumIndices-2 );

		}
	}

	for (int j=m_NumZShields-1; j>=0; j--)
	{
		if (b_far_side) break;
		// Oh, don't bother sorting, see how it looks.
		m_ZShields[j].render(matWTP);	// sets the object to world transpose transform
	}


    // Restore the state
    gpd3dDev->SetPixelShader(  NULL );
    gpd3dDev->SetVertexShader( NULL );

	gpd3dDev->SetTexture(0, NULL);
	gpd3dDev->SetTexture(1, NULL);

    gpd3dDev->SetRenderState( D3DRS_ZWRITEENABLE,     TRUE );
	 gpd3dDev->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::advanceTime(float fElapsedTime, float fDt)
{
	int i;
	for (i=0; i<m_NumShields; i++) m_Shields[i].advanceTime(fElapsedTime, fDt);
	for (i=0; i<m_NumZShields; i++) m_ZShields[i].advanceTime(fElapsedTime, fDt);
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::restart()
{
	Set(&m_Pos, 0.0f, 0.0f, 1.0f);
	Shield::sSetCenter(m_Pos);

	restartShields();
}
///////////////////////////////////////////////////////////////////////////////
void ShieldMgr::restartShields()
{
	float radian_extent = Pi / 6.0f;
	float scale = 1.0f;

	for (m_NumShields=0; m_NumShields<MAX_SHIELDS; m_NumShields++)
	{
		m_Shields[m_NumShields].restart(radian_extent);
		m_Shields[m_NumShields].setRadiusScale(scale, m_MidRadius);
		scale *= m_RadiusScale;
	}

	float min_rad = -0.45f * Pi;
	float max_rad = +0.45f * Pi;
	float rad_step = (max_rad-min_rad) / MAX_ZSHIELDS;
	for (m_NumZShields=0; m_NumZShields<MAX_ZSHIELDS; m_NumZShields++)
	{
		float mid_rad = min_rad + rad_step;
		m_ZShields[m_NumZShields].restart(min_rad, mid_rad, scale * m_MidRadius);
		min_rad = mid_rad;
	}
}
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\SOS.H ===
/*
 	structures and equates for sound operation system
 */

typedef unsigned char	uchar;
typedef unsigned short	ushort;
typedef unsigned long	ulong;


#ifndef NULL
#define	NULL			0
#endif

#define	LEVEL_SILENCE		0
#define	LEVEL_MUSIC		0
#define	LEVEL_EFFECT	1

#define	MUSIC_VOLUME		0
#define	EFFECT_VOLUME		1
#define	MUSIC_FADE			2
#define	RESTORE_MUSIC_VOLUME	3
#define	SET_RESTORE_VOLUME	4
#define	MUSIC_ATTEN		5

#define	MAX_DURATION		(0xffff-12)		/* max duration */

/* 
 * process (event) structure 
 */

struct	process {
	struct process *next;		/* pointer to next process in queue */
	struct process *prev;		/* pointer to previous process in queue*/
	union  {
			uchar	*c;
			ushort	*i;
			} mem_ptr;
	short	timer;			/* timer value for this process */
	short	prev_timer;		/* last value of timer for delta */
	ushort	function;		/* event type (function) */
	uchar	level;			/* sound level (type) NOT volume */
	uchar	hard_channel;		/* synthesis device channel */
	uchar	type;			/* for later use...*/
	ushort	data1;
	ushort	data2;
};


/*
 *	sound (call) structure
 */

struct	sound {
	const uchar	type;		/* sound type (backg, forg, vox, etc) */
	const uchar	priority;	/* priority of this sound */
	const ushort	track_map;	/* bit map for tracks this sound uses */
	const ushort	**tbl_ptr;	/* pointer to this sounds event pointers */
};	

/*
 * sound call receive fifo structure
 */
  
#define	FIFO_SIZE	16

struct	fifo {
	uchar	fifo_read;
	uchar	fifo_write;
	uchar	data[FIFO_SIZE];
};



/*************************************************************************
*                                                                        *
* 	Track information						  *
*      NOTE:								  *
*	Tracks are soft                                                   *
*************************************************************************/
#define	MAX_LOOP	4	/* # of nested loops allowed 	*/
#define	MAX_MUX		3   	/* # of nested mux's allowed 	*/

struct	track_info {
	ushort 	patch;			/* pointer to this tracks voice */
	signed char	pan;			/* left/right/center pan	*/
	uchar	volume;			/* patch's attenuation value	*/
	uchar	lfo_sens;		/* patch's lfo sensitivity value*/
	ushort	pitch;			/* current pitch 		*/
	ushort	loop_counter[MAX_LOOP];	/* # of times to loop		*/
	ushort	*loop_addr[MAX_LOOP];	/* address of loop back points  */
	uchar	loop_level;		/* deepness of loop		*/
	ushort	*mux_addr[MAX_MUX];	/* address of mux back points   */
	uchar	mux_level;		/* deepness of mux		*/
	short	transpose;		/* transposition of track	*/
	ushort	filtercutoff;	/* filter cutoff */
	ushort	filterres;		/* filter resonance */
};

/*************************************************************************
*                                                                        *
* 	Timer music structurs											  *
*                                                                        *
*************************************************************************/
#define	MUSIC_TIMER_PENDING	2		/* silent but "playing" */
#define	MUSIC_TIMER_ON		1		/* playing				*/
#define	MUSIC_TIMER_OFF		0		/* not playing			*/
#define	MAX_TIMERS			17

struct	timer_music {
	uchar	priority;		/* priority of timer					*/
	uchar	sound_call;		/* sound call to make for this timer	*/
	uchar	off_fx;			/* sound fx call to make for end of timr*/
};

/*************************************************************************
*                                                                        *
* 	Channel information						  *
* 	NOTE:								  *
* 	Channels are hard						  *
*                                                                        *
*************************************************************************/


struct	channel_info {
	uchar	type;		/* type of channel 			 */
	uchar	level;		/* current highest level playing on chan */
};



/*************************************************************************
*                                                                        *
* 	Add a watchdog check to code					  *
*                                                                        *
*************************************************************************/


#define	DOGIT	do_watchdog()







=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\Shield.h ===
///////////////////////////////////////////////////////////////////////////////
// File: Shield.h
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#ifndef SHIELD_H
#define SHIELD_H


#include "qrand.h"



// The vertex list holding the unit sphere coordinates remain on the card.
// Each frame another list is streamed.

struct ShieldVertex
{
	D3DVECTOR position;
	D3DVECTOR normal;
};




// The shields actually look like they are the surface of a sphere that has been cut
// off by cuts perpendicular/parallel to each other and in the direction from
// the center of the shield to the center of the sphere. IOW, a piece bounded by
// lat and long lines where the center is on the equator.
   

class Shield
{
protected:
	D3DMATRIX				m_CurOTPMatrix;
	D3DMATRIX				m_CurMatrix;
	D3DVECTOR				m_CurCenter;	// world coordinates
	D3DVECTOR				m_ObjectCenter;	// object coordinates

	D3DMATRIX				m_StartRotation;
	D3DVECTOR				m_RotationDir;
	FLOAT					m_ThetaZero;	// start angle offset
	FLOAT					m_Speed;


	float					m_RadiusScale;

	static D3DVECTOR		ms_Pos;		// position of center


public:
	void Init();
	void UnInit()	{ destroy(); }

	void create();
	void destroy();

	void render(const D3DMATRIX& mat_wtp);	// sets object to world matrix constants
	void advanceTime(float fElapsedTime, float fDt);

	void restart(float radian_extent);	// pairs of floats


	const D3DVECTOR& getCenter() const { return m_CurCenter; }

	void		setRadiusScale(float rs, float dist)
	{
		m_RadiusScale = rs;
		Set(&m_ObjectCenter, dist*rs, 0.0f, 0.0f);
	}

	float	getRadiusScale()	const	{ return m_RadiusScale; }
	float	getSpeed()			const	{ return m_Speed; }

	const D3DMATRIX&	getObjectToWorldMatrix()	const	{ return m_CurMatrix; }

	static void sSetCenter(const D3DVECTOR& pos) { ms_Pos = pos; }
};



class ZShield
{
protected:
    LPDIRECT3DVERTEXBUFFER8 m_pShieldVB;
    LPDIRECT3DINDEXBUFFER8  m_pShieldIB;
    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;

	D3DMATRIX				m_CurMatrix;
	float					m_Speed;
	float					m_Theta;

public:
	void Init();
	void UnInit()	{ destroy(); }

	void create();
	void destroy();

	void render(const D3DMATRIX& mat_wtp);
	void advanceTime(float fElapsedTime, float fDt);

	void restart(float start_radian, float end_radian, float outside_radius);
};





class ShieldMgr
{
protected:
	enum { MAX_SHIELDS = 3 };
	enum { MAX_ZSHIELDS = 5 };
	Shield					m_Shields[MAX_SHIELDS];
	ZShield					m_ZShields[MAX_ZSHIELDS];
	int						m_NumShields;
	int						m_NumZShields;

	void					restartShields();


    LPDIRECT3DVERTEXBUFFER8 m_pShieldVB;
    LPDIRECT3DINDEXBUFFER8  m_pShieldIB;
    DWORD					m_dwNumVertices;
    DWORD					m_dwNumIndices;

    DWORD                   m_dwVShader;
    DWORD					m_dwPShader;



	D3DVECTOR				m_Pos;		// position of center
	float					m_RadiusScale;
	float					m_MidRadius;	// assumes full scale


public:
	void Init();
	void UnInit()
    {
        int i;

        for (i = 0; i < MAX_SHIELDS; i++)
        {
            m_Shields[i].UnInit();
        }

        for (int i = 0; i < MAX_ZSHIELDS; i++)
        {
            m_ZShields[i].UnInit();
        }

        destroy();
    }


	void create();
	void destroy();

	void advanceTime(float fElapsedTime, float fDt);	// resets if fElapsedTime is zero

	void render(bool b_far_side);

	void restart();
};



#endif // SHIELD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\shaders.h ===
const BYTE g_greenfog_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x30, 0xDA, 0x30, 0xD9, 0x30, 0xDB,
0x30, 0xDD, 0x10, 0x10, 0xD1, 0xDD, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x30, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D,
0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x20, 0xDA, 0x20, 0xD9, 0x20, 0xDB, 0x20, 0xCD, 0x00, 0x00,
0xC1, 0xCD, 0x00, 0x00, 0xCD, 0xC8, 0x20, 0xC1, 0x20, 0xCC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x11, 0x01, 0x00,
0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xF0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};

const BYTE g_scene_bump_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x5A, 0x58, 0x59, 0x58, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0B, 0x0C,
0x80, 0x11, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x4A, 0x48, 0x49, 0x48, 0x00, 0x00, 0x0D, 0x0D, 0x00, 0x00,
0xCD, 0xCD, 0x00, 0x00, 0xCD, 0xCD, 0x00, 0x00, 0xCD, 0xCD,
0x0D, 0xC2, 0x0C, 0xC1, 0xC1, 0x20, 0x05, 0xC4, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0xFF,
0x00, 0x00, 0x00, 0x00, 0xCD, 0x30, 0x0C, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00,
0xD0, 0x00, 0x00, 0x00, 0xCD, 0x05, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x11, 0x01, 0x00,
0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0x1F, 0xF0, 0xFF, 0xFF, 0x2F, 0xFF,
0xF4, 0x01, 0x00, 0x00,

};


const BYTE g_scene_phong_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x5A, 0xD1, 0x59, 0xD1, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x0B, 0x0C,
0x80, 0x11, 0x01, 0x0C, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x4A, 0xC1, 0x49, 0xC1, 0x00, 0x00, 0x0D, 0x0D, 0x00, 0x00,
0xCD, 0xCD, 0x00, 0x00, 0xCD, 0xCD, 0x00, 0x00, 0xCD, 0xCD,
0x00, 0x00, 0xCD, 0xCD, 0x0D, 0xC2, 0x0C, 0xC1, 0xC1, 0x20,
0x05, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0xFF,
0x00, 0x00, 0x00, 0x00, 0xCD, 0x30, 0x0C, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00,
0xD0, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xCD, 0x05,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x08, 0x11, 0x01, 0x00,
0x20, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xF3, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xF2,
0xF4, 0x01, 0x00, 0x00,

};


const BYTE g_scene_zr_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,
0x3D, 0x3D, 0x10, 0x10, 0xDD, 0xD4, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x48, 0x48, 0x00, 0x00, 0x2D, 0x2D, 0x00, 0x00,
0xCD, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xD0, 0x20, 0x08, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x11, 0x01, 0x00,
0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_shield_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x5B, 0x5A, 0x5B, 0x59, 0x1D, 0x1D,
0x1C, 0x1C, 0xDD, 0xDD, 0xDC, 0xDC, 0xDD, 0xDD, 0xDC, 0xDC,
0xDD, 0xDD, 0xDC, 0xDC, 0xDC, 0x30, 0xD1, 0xDC, 0x30, 0x1D,
0x30, 0x1C, 0x10, 0x10, 0x30, 0xD2, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x33, 0xFF, 0x66, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xCD, 0x04, 0x00, 0x00, 0xCD, 0x04, 0x00, 0x00,
0xCD, 0x04, 0x00, 0x00, 0xCD, 0x04, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x4B, 0x4A, 0x4B, 0x49, 0x0D, 0x0D, 0x0C, 0x0C, 0xCD, 0xCD,
0xCC, 0xCC, 0xCD, 0xCD, 0xCC, 0xCC, 0xCD, 0xCD, 0xCC, 0xCC,
0xCC, 0x20, 0xC1, 0xCC, 0x20, 0x0D, 0x20, 0x0C, 0xC8, 0x20,
0xC1, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xCD, 0x30, 0x0C, 0x00, 0xCD, 0x04,
0x00, 0x00, 0xCD, 0x04, 0x00, 0x00, 0xCD, 0x04, 0x00, 0x00,
0xCD, 0x04, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x0C,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x08, 0x11, 0x01, 0x00,
0x21, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0x3F, 0x2F, 0xFF, 0xFF, 0xFF, 0x0F,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_shield_sh_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x10, 0x10, 0x30, 0xD4, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
0x80, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x20, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_vblob_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,
0x30, 0x1C, 0x10, 0x10, 0x3D, 0x3D, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x30, 0xD1, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x49, 0x48, 0x00, 0x00, 0x20, 0x0C, 0x00, 0x00,
0x2D, 0x2D, 0x00, 0x00, 0xC1, 0x2C, 0x20, 0xC1, 0x20, 0xCC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xC0, 0x20, 0x08, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x11, 0x01, 0x00,
0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x0F, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_vbloblet_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,
0x30, 0x1C, 0x10, 0x10, 0x3D, 0x3D, 0x10, 0x10, 0xD1, 0x3C,
0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0xD1, 0xDC, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x49, 0x48, 0x00, 0x00, 0x20, 0x0C, 0x00, 0x00,
0x2D, 0x2D, 0x00, 0x00, 0xC1, 0x2C, 0x20, 0xC1, 0x20, 0xCC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xC0, 0x20, 0x08, 0x00, 0xD0, 0x00,
0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x11, 0x01, 0x00,
0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x0F, 0x21, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};


const BYTE g_greenfog_xvu[] =
{

0x78, 0x20, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x20, 0x00, 0x6C, 0x10, 0x36, 0x08, 0x00, 0xF8, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x02, 0x20, 0x00, 0x6C, 0x10,
0x36, 0x08, 0x48, 0xF8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x24, 0x4C, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x64, 0x4C, 0x00,
0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x30, 0x2F, 0x00, 0x00,
0x00, 0x00, 0x1B, 0xA4, 0x4C, 0x00, 0x6C, 0x18, 0x36, 0x08,
0xF8, 0x0F, 0x40, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x6C, 0x00, 0x6C, 0x10, 0x36, 0x24, 0x50, 0xF8, 0x70, 0x30,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x6C, 0x00, 0x6C, 0x10,
0x36, 0x34, 0x58, 0xF8, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x80, 0x6C, 0x00, 0x6C, 0x10, 0x36, 0x44, 0x60, 0xF8,
0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06,
0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4,
0x01, 0xE8, 0x70, 0x30,

};


const BYTE g_scene_bump_xvu[] =
{

0x78, 0x20, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x88, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x00, 0x48, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x28,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x08,
0x60, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x20,
0xED, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x60, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0xED, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x60, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x02, 0x6C, 0x03,
0x6C, 0x18, 0x36, 0x0C, 0x4C, 0xF8, 0x30, 0x21, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x00, 0x40, 0x01, 0x6C, 0x68, 0xFE, 0x25,
0x60, 0x18, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xC0,
0x4C, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x40, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x80, 0x6C, 0x00, 0x69, 0x14,
0x36, 0x0C, 0xF8, 0x0F, 0x50, 0x1E, 0x00, 0x00, 0x00, 0x00,
0x1A, 0xA0, 0x6C, 0x00, 0x69, 0x14, 0x36, 0x0C, 0xF8, 0x0F,
0xA0, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0xA0, 0x00,
0x6C, 0xA8, 0x34, 0x54, 0xF8, 0x0F, 0x60, 0x28, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xA0, 0x08, 0x6D, 0x48, 0x37, 0xA4,
0xF8, 0x0F, 0xB1, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x09, 0x6E, 0x28, 0xFE, 0x65, 0xF8, 0x0F, 0x78, 0xDE,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xAC, 0x00, 0x6C, 0x18,
0x36, 0x74, 0xF8, 0x0F, 0x80, 0x28, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x40, 0x00, 0x6C, 0x48, 0x35, 0x14, 0xF8, 0x0F,
0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x40, 0x06,
0x6E, 0xA8, 0x36, 0x14, 0x1C, 0xE8, 0x90, 0x1E, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x04, 0xA0, 0x00, 0x6C, 0x10, 0x36, 0x94,
0x50, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x06,
0xA0, 0x00, 0x6C, 0x10, 0x36, 0x94, 0x50, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x08, 0xA0, 0x00, 0x6C, 0x10,
0x36, 0x94, 0x50, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1A, 0x00, 0x60, 0x00, 0x6A, 0x10, 0x36, 0x04, 0xF8, 0x0F,
0x20, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06,
0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x04, 0xA0, 0x00, 0x6C, 0x10, 0x36, 0x24,
0x58, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x06,
0xA0, 0x00, 0x6C, 0x10, 0x36, 0x24, 0x58, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x08, 0xA0, 0x00, 0x6C, 0x10,
0x36, 0x24, 0x58, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8,
0x70, 0x30,

};


const BYTE g_scene_phong_xvu[] =
{

0x78, 0x20, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x88, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x00, 0x48, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x28,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x08,
0x60, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x20,
0xED, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x60, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0xED, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x60, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x6C, 0x01,
0x6C, 0x18, 0x36, 0x0C, 0xF8, 0x0F, 0x30, 0x21, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x00, 0x40, 0x01, 0x6C, 0x68, 0xFE, 0x25,
0x60, 0x18, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xC0,
0x4C, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x40, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x80, 0x6C, 0x00, 0x69, 0x14,
0x36, 0x0C, 0xF8, 0x0F, 0x50, 0x1E, 0x00, 0x00, 0x00, 0x00,
0x1A, 0xA0, 0x6C, 0x00, 0x69, 0x14, 0x36, 0x0C, 0xF8, 0x0F,
0xA0, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0xA0, 0x00,
0x6C, 0xA8, 0x34, 0x54, 0xF8, 0x0F, 0x60, 0x28, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xA0, 0x08, 0x6D, 0x48, 0x37, 0xA4,
0xF8, 0x0F, 0xB1, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x09, 0x6E, 0x28, 0xFE, 0x65, 0xF8, 0x0F, 0x78, 0xDE,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xAC, 0x00, 0x6C, 0x18,
0x36, 0x74, 0xF8, 0x0F, 0x80, 0x28, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x40, 0x00, 0x6C, 0x48, 0x35, 0x14, 0xF8, 0x0F,
0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x40, 0x06,
0x6E, 0xA8, 0x36, 0x14, 0x1C, 0xE8, 0x90, 0x1E, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x02, 0xA0, 0x00, 0x6C, 0x10, 0x36, 0x94,
0x50, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x04,
0xA0, 0x00, 0x6C, 0x10, 0x36, 0x94, 0x50, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x06, 0xA0, 0x00, 0x6C, 0x10,
0x36, 0x94, 0x50, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1A, 0x00, 0x60, 0x00, 0x6A, 0x10, 0x36, 0x04, 0xF8, 0x0F,
0x20, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06,
0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x02, 0xA0, 0x00, 0x6C, 0x10, 0x36, 0x24,
0x58, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x04,
0xA0, 0x00, 0x6C, 0x10, 0x36, 0x24, 0x58, 0x48, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x06, 0xA0, 0x00, 0x6C, 0x10,
0x36, 0x24, 0x58, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8,
0x70, 0x30,

};


const BYTE g_scene_zr_xvu[] =
{

0x78, 0x20, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x28,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0xF8, 0x0F, 0x20, 0x24, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x22, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x21, 0x00, 0x00,
0x00, 0x00, 0xAA, 0x00, 0x20, 0x02, 0x6C, 0x10, 0x36, 0x24,
0x04, 0xF8, 0x30, 0x9F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
0x20, 0x00, 0x6C, 0x10, 0x36, 0x24, 0xF8, 0x0F, 0x40, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0x6E, 0x00, 0x6C, 0x10,
0x36, 0x34, 0xF8, 0x0F, 0x50, 0x3E, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0x80, 0x05, 0xFD, 0x6B, 0x36, 0x34, 0xF8, 0x0F,
0x6F, 0x11, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x4E, 0x00,
0x6C, 0xA8, 0x36, 0x0C, 0xF8, 0x0F, 0x60, 0x2E, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x60, 0x01, 0x6C, 0x68, 0x36, 0x34,
0xF8, 0x0F, 0x70, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x80, 0x01, 0x6C, 0x68, 0x36, 0x34, 0xF8, 0x0F, 0x70, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x40, 0x01, 0x6C, 0xE8,
0x36, 0x64, 0x18, 0xF8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0x40, 0x00, 0x6C, 0x28, 0x36, 0x24, 0xF8, 0x0F,
0x80, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x4E, 0x00,
0x6C, 0x18, 0x36, 0x84, 0xF8, 0x0F, 0x90, 0x2E, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x60, 0x6E, 0x00, 0x6C, 0x10, 0x36, 0x94,
0x48, 0xE8, 0x70, 0x30, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x80, 0x01, 0x6C, 0x28, 0x36, 0x14, 0x48, 0x18, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06, 0xFF, 0x1B,
0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8,
0x70, 0x30,

};


const BYTE g_shield_xvu[] =
{

0x78, 0x20, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x28,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0xF8, 0x0F, 0x20, 0x24, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0x20, 0x22, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x21, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x02, 0xAC, 0x00, 0x6C, 0x18, 0x34, 0x08,
0xF8, 0x0F, 0x30, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22,
0xAC, 0x00, 0x6C, 0x18, 0x34, 0x08, 0xF8, 0x0F, 0x30, 0x24,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x42, 0xAC, 0x00, 0x6C, 0x18,
0x34, 0x08, 0xF8, 0x0F, 0x30, 0x22, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x20, 0x6D, 0x00, 0x6C, 0x14, 0x36, 0x24, 0xF8, 0x0F,
0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x6D, 0x00,
0x6C, 0x14, 0x36, 0x24, 0xF8, 0x0F, 0x70, 0x3E, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0xA0, 0x02, 0x6D, 0x6C, 0x36, 0x44,
0x64, 0xE8, 0x50, 0x18, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00,
0xA0, 0x00, 0x6C, 0x68, 0x34, 0x74, 0xF8, 0x0F, 0x80, 0x28,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x6C, 0x18,
0x54, 0x57, 0xF8, 0x0F, 0x60, 0x24, 0x00, 0x00, 0x00, 0x00,
0x55, 0x00, 0x80, 0x00, 0x69, 0x68, 0x34, 0x64, 0x48, 0xE8,
0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x00,
0x6C, 0x18, 0x54, 0x87, 0xF8, 0x0F, 0x90, 0x24, 0x00, 0x00,
0x00, 0x00, 0x55, 0x00, 0x80, 0x00, 0x69, 0x68, 0x34, 0x94,
0x50, 0xE8, 0x30, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x60,
0x6D, 0x00, 0x68, 0x14, 0x36, 0x24, 0xF8, 0x0F, 0xA0, 0x3E,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x80, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x24, 0x00, 0x88, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1A, 0x00, 0xA0, 0x00, 0x6C, 0x68, 0x34, 0xA4, 0xF8, 0x0F,
0xB0, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xA0, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x24, 0x00, 0x48, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x6C, 0x18, 0x54, 0xB7,
0xF8, 0x0F, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00,
0x80, 0x00, 0x6A, 0x68, 0x34, 0x04, 0x58, 0xE8, 0x30, 0x90,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xC0, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x24, 0x00, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0xE0, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x24, 0x00, 0x18,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40, 0x47, 0x06,
0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4,
0x01, 0xE8, 0x70, 0x30,

};


const BYTE g_shield_sh_xvu[] =
{

0x78, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x20, 0x00, 0x6C, 0x10, 0x36, 0x08, 0xF8, 0x0F, 0x20, 0x2F,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x80, 0x01, 0x6C, 0x48,
0x36, 0x24, 0xF8, 0x0F, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x24, 0xF8, 0x0F,
0x30, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xED, 0x00,
0x6C, 0x18, 0x36, 0x24, 0xF8, 0x0F, 0x30, 0x24, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x40, 0xED, 0x00, 0x6C, 0x18, 0x36, 0x24,
0xF8, 0x0F, 0x30, 0x22, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60,
0xED, 0x00, 0x6C, 0x18, 0x36, 0x24, 0xF8, 0x0F, 0x30, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x80, 0x2D, 0x00, 0x6C, 0x10,
0x36, 0x0C, 0xF8, 0x0F, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0x6E, 0x00, 0x6C, 0x14, 0x36, 0x34, 0xF8, 0x0F,
0x40, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0xA0, 0x00,
0x6C, 0x88, 0x36, 0x44, 0xF8, 0x0F, 0x50, 0x21, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x00, 0x08, 0xFD, 0x13, 0x36, 0x08,
0xF8, 0x0F, 0x1F, 0x50, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x40, 0x00, 0x6C, 0x88, 0x36, 0x14, 0xF8, 0x0F, 0x60, 0x2F,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x80, 0x01, 0x6C, 0x28,
0x36, 0x14, 0xF8, 0x0F, 0x70, 0x2F, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0x60, 0x00, 0xFC, 0x17, 0x36, 0x74, 0xF8, 0x0F,
0x80, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xC0, 0x4C, 0x00,
0x6C, 0x18, 0x36, 0x84, 0xF8, 0x0F, 0x90, 0x2F, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x80, 0x00, 0x6C, 0xC8, 0x36, 0x94,
0xF8, 0x0F, 0xA0, 0xDF, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xA0, 0x00, 0x6C, 0x48, 0x37, 0xA4, 0xF8, 0x0F, 0xB0, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0xA4, 0xF8, 0x0F, 0x70, 0x24, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0xEC, 0x08, 0xFE, 0x1B, 0x36, 0xA4, 0xF8, 0x0F,
0x7E, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0xA4, 0xF8, 0x0F, 0x70, 0x21, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x60, 0x01, 0x6C, 0x48, 0x37, 0xA4,
0x18, 0xE8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0x40, 0x02, 0x6D, 0x48, 0x37, 0x14, 0x04, 0xD8, 0x00, 0xDE,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xAC, 0x00, 0x6C, 0x18,
0x36, 0x04, 0xF8, 0x0F, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00,
0xFF, 0x00, 0x20, 0x00, 0x6C, 0x10, 0x36, 0x74, 0xF8, 0x0F,
0x80, 0x22, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xA0, 0x8D, 0x00,
0x6C, 0x48, 0x36, 0x04, 0xF8, 0x0F, 0x30, 0x31, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x40, 0x00, 0x6C, 0x08, 0x36, 0x04,
0xF8, 0x0F, 0x40, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xC0,
0x8D, 0x00, 0x6C, 0x18, 0x36, 0x44, 0xF8, 0x0F, 0x50, 0xD1,
0x00, 0x00, 0x00, 0x00, 0xAA, 0x80, 0x4C, 0x00, 0x6C, 0x08,
0x55, 0x0D, 0x00, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0xE0, 0x4D, 0x01, 0x6C, 0x18, 0x36, 0x54, 0xF8, 0x0F,
0x60, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xA0, 0x4C, 0x00,
0x6C, 0x18, 0x36, 0x64, 0xF8, 0x0F, 0x90, 0x21, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x00, 0x40, 0x00, 0x6C, 0x10, 0xFE, 0x95,
0x18, 0x18, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40,
0x47, 0x06, 0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8, 0x78, 0x10,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28,
0x00, 0xC4, 0x01, 0xE8, 0x70, 0x30,

};


const BYTE g_vblob_xvu[] =
{

0x78, 0x20, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60,
0x4D, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F, 0xA0, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0xA0, 0x00, 0x6C, 0x48,
0x37, 0xA4, 0xF8, 0x0F, 0x20, 0x28, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0x4D, 0x00, 0x6C, 0x18, 0x36, 0x08, 0xF8, 0x0F,
0xB0, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x2D, 0x08,
0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F, 0xA8, 0x91, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x80, 0x6D, 0x00, 0x6C, 0x10, 0x36, 0xB4,
0xF8, 0x0F, 0xB0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x40, 0x00, 0x6C, 0x48, 0x35, 0x14, 0xF8, 0x0F, 0xA0, 0x2E,
0x00, 0x00, 0x00, 0x00, 0xFF, 0x02, 0x20, 0x00, 0x6C, 0x10,
0x36, 0x08, 0xF8, 0x0F, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x2D, 0x00, 0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F,
0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x80, 0x00,
0x6E, 0x08, 0x36, 0xA4, 0xF8, 0x0F, 0xB0, 0xDF, 0x00, 0x00,
0x00, 0x00, 0x1A, 0x20, 0x6D, 0x00, 0x6A, 0x14, 0x36, 0x0C,
0xF8, 0x0F, 0x00, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00,
0x2D, 0x00, 0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F, 0x20, 0x21,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0xA0, 0x00, 0x6C, 0x08,
0x34, 0x04, 0xF8, 0x0F, 0x20, 0x28, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x80, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0xB4, 0x00, 0x88,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x2D, 0x08,
0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F, 0x98, 0x91, 0x00, 0x00,
0x00, 0x00, 0x1B, 0xA0, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0xB4,
0x00, 0x48, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x40, 0x00, 0x6C, 0x08, 0x34, 0x14, 0xF8, 0x0F, 0x20, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x62, 0x4D, 0x02, 0x6C, 0x18,
0x36, 0x08, 0x54, 0xF8, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x00, 0xA0, 0x00, 0x6C, 0x08, 0x36, 0x04, 0xF8, 0x0F,
0x20, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0xB4, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1B, 0xC0, 0xEC, 0x08, 0x6C, 0x18, 0x36, 0xB4,
0x00, 0x28, 0x18, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x40, 0x00, 0x6C, 0x08, 0x36, 0x14, 0xF8, 0x0F, 0x90, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x20, 0x00, 0x6C, 0x10,
0x36, 0x94, 0x48, 0xF8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0x47, 0x06, 0xFF, 0x1B, 0x36, 0xC4, 0x00, 0xE8,
0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0x87, 0x00,
0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8, 0x70, 0x30,

};


const BYTE g_vbloblet_xvu[] =
{

0x78, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60,
0xAD, 0x02, 0x6C, 0x18, 0x36, 0x08, 0x4C, 0xF8, 0x20, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x2D, 0x00, 0x6C, 0x10,
0x36, 0x0C, 0xF8, 0x0F, 0x50, 0x21, 0x00, 0x00, 0x00, 0x00,
0x1B, 0xA0, 0x4D, 0x00, 0x6C, 0x18, 0x36, 0x24, 0xF8, 0x0F,
0x30, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x80, 0x8D, 0x00,
0x6C, 0x10, 0x36, 0x0C, 0xF8, 0x0F, 0x40, 0xDE, 0x00, 0x00,
0x00, 0x00, 0x55, 0x00, 0x2D, 0x00, 0x6C, 0x10, 0x36, 0x0C,
0xF8, 0x0F, 0x80, 0x21, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x40,
0x6D, 0x00, 0x6C, 0x10, 0x36, 0x44, 0xF8, 0x0F, 0x50, 0x3E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x20, 0x6D, 0x00, 0x69, 0x14,
0x36, 0x0C, 0xF8, 0x0F, 0x60, 0x5E, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x80, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x54, 0x00, 0x88,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0xA0, 0x00,
0x6C, 0xC8, 0x34, 0x64, 0xF8, 0x0F, 0x70, 0x28, 0x00, 0x00,
0x00, 0x00, 0x1B, 0xC0, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x54,
0x00, 0x28, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xA0,
0xEC, 0x08, 0x6D, 0x18, 0x36, 0x54, 0x00, 0x48, 0x18, 0xD0,
0x00, 0x00, 0x00, 0x00, 0x1B, 0xE0, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x54, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x40, 0x00, 0x6C, 0xC8, 0x34, 0x14, 0xF8, 0x0F,
0x80, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x20, 0x00,
0x6C, 0x10, 0x36, 0x84, 0x50, 0xF8, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x40, 0x47, 0x06, 0xFF, 0x1B, 0x36, 0xC4,
0x00, 0xE8, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60,
0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4, 0x01, 0xE8, 0x70, 0x30,

};

const BYTE g_slash_interior_xpu[] =
{

0x50, 0x53, 0x42, 0x30, 0x10, 0x10, 0x30, 0xD4, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x20, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x11, 0x01, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x01, 0x00, 0x00,

};

const BYTE g_slash_interior_xvu[] =
{

0x78, 0x20, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00,
0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x88, 0x70, 0x20,
0x00, 0x00, 0x00, 0x00, 0x1B, 0x20, 0xEC, 0x00, 0x6C, 0x18,
0x36, 0x08, 0x00, 0x48, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
0x1B, 0x40, 0xEC, 0x00, 0x6C, 0x18, 0x36, 0x08, 0x00, 0x28,
0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x60, 0xEC, 0x00,
0x6C, 0x18, 0x36, 0x08, 0x00, 0x18, 0x70, 0x20, 0x00, 0x00,
0x00, 0x00, 0x1A, 0xA0, 0x2C, 0x00, 0x6C, 0x10, 0x36, 0x0C,
0xF8, 0x0F, 0x20, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x80,
0x6C, 0x00, 0x68, 0x14, 0x36, 0x0C, 0xF8, 0x0F, 0x30, 0x9E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0xE0, 0x2C, 0x00, 0x6C, 0x10,
0x36, 0x0C, 0xF8, 0x0F, 0x50, 0x2E, 0x00, 0x00, 0x00, 0x00,
0x1A, 0xA2, 0x8C, 0x00, 0x68, 0x10, 0xAA, 0x34, 0xF8, 0x0F,
0x40, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xC0, 0x6C, 0x00,
0x69, 0x14, 0x36, 0x0C, 0xF8, 0x0F, 0x60, 0x5E, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x40, 0x47, 0x06, 0xFF, 0x1B, 0x36, 0xC4,
0x00, 0xE8, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1A, 0xE2,
0x8C, 0x00, 0x68, 0x10, 0xAA, 0x64, 0xF8, 0x0F, 0x70, 0x3E,
0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x8D, 0x00, 0x69, 0x18,
0x34, 0x44, 0xF8, 0x0F, 0x80, 0xDE, 0x00, 0x00, 0x00, 0x00,
0x1A, 0x00, 0x4D, 0x00, 0x6C, 0x18, 0x34, 0x74, 0xF8, 0x0F,
0x90, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x60, 0x00,
0x6A, 0x14, 0x36, 0x84, 0x18, 0xE8, 0x70, 0x50, 0x00, 0x00,
0x00, 0x00, 0x1B, 0x60, 0x87, 0x00, 0x6C, 0x28, 0x00, 0xC4,
0x01, 0xE8, 0x70, 0x30,

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\sosdsp.h ===
#define	GPXMEM	0xfe830000
#define	GPYMEM	0xfe836000
#define	GPPMEM	0xfe83a000



struct	patch {
	unsigned int	start;
	unsigned int	end;
	unsigned int	loop;
	unsigned char	pitch;
	unsigned char	bank;
};
struct	word {
	unsigned int	start;
	unsigned int	end;
	unsigned char	bank;
	unsigned int	volume;
};


struct	two_pole_lpf {
	unsigned short	c0;
	unsigned short	c1;
	unsigned short	c2;
};
#define	N_OSCS		11
#define	OSC_SIZE	6

#define	ST_VOLUME_R			66
#define	ST_VOLUME_L			77


/*
 *	adpcm equates
 */

#define		ADP_END			109
#define		ADP_BANK		111
#define		ADP_PRE_VOLUME_R 116
#define		ADP_PRE_VOLUME_L 120
#define		ADP_PRE_START	117
#define		ADP_STATUS		115
#define		ADP_VOLUME_R 110
#define		ADP_VOLUME_L 112


#define	OSC_0_MOD_INDEX	119
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\sources.inc ===
# C_DEFINES=$(C_DEFINES) -DPROFILE
# C_DEFINES=$(C_DEFINES) -DDETERMINISTIC

LINKER_FLAGS=$(LINKER_FLAGS) /MAP

SOURCES=\
CamControl.cpp \
camera.cpp \
GreenFog.cpp \
logo_renderer.cpp \
qrand.cpp \
renderer.cpp \
scene_renderer.cpp \
Shield.cpp \
tex_gen.cpp \
VBlob.cpp \
xbs_app.cpp \
fastmath.cpp \
placementdoodad.cpp \
bootsound.cpp \
mslogo.cpp \
dev.c \
cf.c \
evf.c \
globals.c \
sos.c \
proc.c \
stboot.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\tm_pixels.h ===
///////////////////////////////////////////////////////////////////////////////
//
// tm.h
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __tm_h__
#define __tm_h__

DWORD tm_pixels[256] =
{
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0xff152305,0xff1e3207,0xff1e3207,0xff1e3207,0xff1e3207,0xff1e3207,0x0,0xff152305,0xff1e3207,0x0,0x0,0x0,0xff0e1703,0xff1e3207,0xff070c02,0x0,
	0xff518814,0xff6fbb1b,0xff6fbb1b,0xff6fbb1b,0xff6fbb1b,0xff6fbb1b,0x0,0xff6fbb1b,0xff6fbb1b,0xff152305,0x0,0x0,0xff4a7d12,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff6fbb1b,0xff3c640f,0x0,0xff070c02,0xff6fbb1b,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff5a9716,0xff61a318,0x0,0xff2c4a0b,0xff5a9716,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff33560c,0xff68af19,0xff0e1703,0xff437010,0xff33560c,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff33560c,0xff437010,0xff33560c,0xff68af19,0xff152305,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff33560c,0xff2c4a0b,0xff6fbb1b,0xff61a318,0x0,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff33560c,0xff6fbb1b,0x0,0x0,0x0,0xff6fbb1b,0xff33560c,0xff070c02,0xff6fbb1b,0xff3c640f,0x0,0xff6fbb1b,0xff1e3207,0x0,
	0x0,0x0,0xff0e1703,0xff152305,0x0,0x0,0x0,0xff152305,0xff0e1703,0x0,0xff152305,0xff070c02,0x0,0xff1e3207,0xff070c02,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
};

#endif // ___h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\st.c ===
#include <dsound.h>
#include "sos.h"
#include "macros.h"
#include "bootsnd.h"
#include "pitches.h"

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

DSENVELOPEDESC	Env1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x5,						// hold
	0x20,						// decay
	0x0,						// release
	0x7f,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x10,						// pitch scale
	0x7f,						// filter scale
};




DSENVELOPEDESC	Env2a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x40,						// decay
	0x0,						// release
	0x3f,						// sustain
	0x7f,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env2m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x40,						// pitch scale
	0x4f,						// filter scale
};
	

DSENVELOPEDESC	Env3a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x3,						// hold
	0x10,						// decay
	0x20,						// release
	0x10,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env3m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x10,						// pitch scale
	0x1f,						// filter scale
};



DSENVELOPEDESC	OpenEnva = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x0,						// attack
	0x0,						// hold
	0x0,						// decay
	0x0,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	OpenEnvm = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0,						// attack
	0x0,						// hold
	0x00,						// decay
	0x00,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

extern	unsigned short  Sin128[];
extern	unsigned short	Saw128[];
extern	unsigned short	Noise8192[];
extern	unsigned short	FM32768[];
extern	unsigned short	Glock[];
extern	unsigned short	Thun8k[];
extern	unsigned short	Cannon[];
extern	unsigned short	Bubble[];
extern	unsigned short	ThunEl16[];
extern	unsigned short	ReverseThunEl16[];


//
// patch is table, loop, env1, env2
// so, patches are defined by a waveform, a length, a loop address
// and the pair of envelopes.
//


const struct DSPpatch PatchSin = {
	Sin128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env1a,			// ampitude envelope
	&Env1m			// multi purpose envelope
};

///////////////////////////////////////////////////////////////////////
DSENVELOPEDESC	SawEnv1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x2,						// hold
	0x10,						// decay
	0x0,						// release
	0x9f,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	SawEnv1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x10,						// attack
	0x100,						// hold
	0x100,						// decay
	0x80,						// release
	0xff,						// sustain
	0x00,						// pitch scale
	-80,						// filter scale
};


const struct DSPpatch PatchSaw1 = {
	Saw128,			// start addr
	256,				// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&SawEnv1a,			// ampitude envelope
	&SawEnv1m			// multi purpose envelope
};




///////////////////////////////////////////////////////////////////////

DSENVELOPEDESC	SawEnv2a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x40,						// decay
	0x0,						// release
	0x3f,						// sustain
	0x7f,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	SawEnv2m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x00,						// pitch scale
	0x0,						// filter scale
};

const struct DSPpatch PatchSaw2 = {
	Saw128,			// start addr
	256,				// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&SawEnv2a,			// ampitude envelope
	&SawEnv2m			// multi purpose envelope
};



	

///////////////////////////////////////////////////////////////////////
const struct DSPpatch PatchSaw3 = {
	Saw128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env3a,			// ampitude envelope
	&Env3m			// multi purpose envelope
};



const struct DSPpatch PatchSquare = {
	Saw128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env3a,			// ampitude envelope
	&Env3m			// multi purpose envelope
};


/////////////////////////////////////////////////////////////////////
DSENVELOPEDESC	NoiseEnv1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x3,						// hold
	0x10,						// decay
	0x20,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	NoiseEnv1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x30,						// decay
	0xc0,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

/////////////////////////////////////////////////////////////////////
const struct DSPpatch PatchEnvNoise1 = {
	Noise8192,			// start addr
	8192*2,			// length
	0,				// loop start
	8192*2,			// loop end
	1,				// loop sound
	&NoiseEnv1a,			// ampitude envelope
	&NoiseEnv1m			// multi purpose envelope
};


//////////////////////////////
const struct DSPpatch PatchFM = {
	FM32768,			// start addr
	32768,			// length
	0,				// loop start
	32768,			// loop end
	0,				// loop sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchGlock = {
	Glock,			// start addr
	3768*2,			// length...from glock.equ
	0,				// loop start
	3768*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};

///////////////////////////////////////////////////////////////
const struct DSPpatch PatchThun8k = {
	Thun8k,			// start addr
	10922*2,			// length...from glock.equ
	0,				// loop start
	10922*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchThunEl16 = {
	ThunEl16,			// start addr
	0x5540*2,			// length...from glock.equ
	0,				// loop start
	0x5540*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchRevThun = {
	ReverseThunEl16,			// start addr
	0x5540*2,			// length...from glock.equ
	0,				// loop start
	0x5540*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////

const struct DSPpatch PatchCannon = {
	Cannon,			// start addr
	3086*2,			// length...from glock.equ
	0,				// loop start
	3086*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
const struct DSPpatch PatchBubble = {
	Bubble,			// start addr
	6719*2,			// length...from glock.equ
	0,				// loop start
	6719*2,			// loop end
	1,				//  loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};


#define	PSIN1	0
#define	PSAW1	1
#define	PSQUARE	2
#define	PSAW2	3
#define	PSAW3	4
#define	PNOISE1	5
#define	PGLOCK	6
#define	PTHUN	7
#define	PCANNON	8
#define	PBUBBLE	9
#define	PFM		10
#define	PTHUNEL16 11
#define	PREVTHUN	12
struct DSPpatch	const *Patches[] = {
	&PatchSin,			// patch 0
	&PatchSaw1,			// patch 1
	&PatchSquare,		// patch 2
	&PatchSaw2,			// patch 3
	&PatchSaw3,			// patch 4
	&PatchEnvNoise1,	// patch 5
	&PatchGlock,		// patch 6
	&PatchThun8k,		// patch 7
	&PatchCannon,		// 8
	&PatchBubble,		// 9
	&PatchFM,			// 10
	&PatchThunEl16,		//11
	&PatchRevThun		// 12
};



// throbbing bass
//
const unsigned short Boot0[] = {
	rest(194),
	fset(25000,26000),
	patch(PSAW1),
	volume(40),
	loop(13),

		note(dd1,57),
		rest(3),
	endloop,
	note(dd1,28),
	rest(2),
	loop(6),
		volume(15),
		note(dd1,27),
		rest(3),
	endloop,

	loop(255),
	rest(2000),
	endloop
};





//noise whoosh for opening
const unsigned short Boot1[] = {
	fset(1000,26000),
	patch(5),
	volume(43),
	note(cc2,1),
	loop(10),
		finc(3000,26000),
		slur(cc2,13),
	endloop,
	ring(4),
	volume(20),
	loop(60),
		volume(1),
		finc(-1000,26000),
		slur(cc2,15),
	endloop,

	loop(255),
	rest(2000),
	endloop
};

// bubbling sound
const unsigned short Boot2[] = {
	patch(PBUBBLE),
	volume(0),
	fset(5000,26000),
	rest(194),
	note(dd2,412),
	loop(20),
		ring(20),
		finc(1000,26000),
	endloop,
	loop(30),
		ring(10),
		volume(4),
	endloop,
	loop(255),
		rest(2000),
	endloop
};


// first and last flashes
const unsigned short Boot3[] = {
	patch(PTHUN),
	volume(20),
	fset(32767,26000),
	rest(134),
	note(dd2,820),
	note(dd2,200),
	loop(20),
		ring(20),
		volume(2),
		finc(-1000,26000),
	endloop,
	ring(10000),
	loop(255),
		rest(2000),
	endloop
};

// fast noisy stuff...
//
const unsigned short Boot4[] = {
	rest(194),
	fset(32000,26000),
	patch(PNOISE1),
	volume(160),
	loop(10),
		volume(-3),
		note(cc4,15),
		rest(5),
		note(ff4,15),
		volume(-3),
		rest(5),
		note(gg5,15),
		rest(5),
		volume(-3),
		note(ff4,15),
		rest(5),
	endloop,
	note(ff4,18),

	loop(255),
	rest(2000),
	endloop
};

// glocks....
const unsigned short Boot5[] = {
	patch(PGLOCK),
	volume(70),
	rest(1194),
	fset(32000,26000),
	loop(40),
		note(cc4,18),
		rest(2),

		volume(15),
	endloop,
	note(cc4,500),
	loop(255),
	rest(2000),
	endloop
};

// glocks....
const unsigned short Boot6[] = {
	patch(PGLOCK),
	volume(70),
	rest(1194),
	fset(32000,26000),
	loop(40),
		note(cc3,18),
		rest(2),
		volume(15),
	endloop,
	note(cc3,500),
	loop(255),
	rest(2000),
	endloop
};

/////
// glocks....
const unsigned short Boot8[] = {
	patch(PGLOCK),
	volume(70),
	rest(1194),
	fset(32000,26000),
	loop(40),
		note(gg3,18),
		rest(2),
		volume(15),
	endloop,
	note(cc3,500),
	loop(255),
	rest(2000),
	endloop
};


// bass beg....
const unsigned short Boot7[] = {
	patch(PSAW2),
	volume(3),
	fset(1000,26000),
	note(dd2,1),
	loop(19),
		slur(dd2,10),
		finc(1500,2600),
	endloop,

	loop(255),
	rest(2000),
	endloop
};


const unsigned short *Boot[] = {
	Boot0,Boot1,Boot2,Boot3,Boot4,Boot5,Boot6,Boot7,Boot8
};
/////////////////////////////////////////////////////////////////////////

const unsigned short Tune0[] = {

	patch(PREVTHUN),
	note(cc3,800),
	patch(PTHUNEL16),
	note(cc3,800),

	rest(200),
	patch(PSIN1),

	loop(5),
	loop(120),
		note(cc2,50),
		xpose(200),
		rest(0),
	endloop,
	loop(120),
		note(cc0,50),
		xpose(-200),
		rest(0),
	endloop,
	endloop,
	note(5,6),
	rest(0x10),
	
//	0,1,2,3,4
};

const unsigned short Tune1[] = {

//	fset(6000,26000),
	patch(PSIN1),

	note(cc3,200),

};

const unsigned short *Tune[] = {
	Tune0
};

const struct sound sound_calls[] = {
	0,0,0,NULL,				//0 
	1,0,0x1ff,Boot,			//1
	1,0,0x001,Tune,			//2
	1,0,0x001,Tune,			//2
};


struct sound sound_calls2[2];

int	max_sound_call = 0x2;
int	default_clock_value = 80;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\tex_gen.h ===
//
//	bs_texgen.h
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#ifndef __TEX_GEN_H__
#define __TEX_GEN_H__


LPDIRECT3DTEXTURE8 CreateIntensityTexture(
							int   size,
							bool  b_convert_to_normal_map = false,
							float f_height_scale		  = 1.f/512.f,
							int   noise					  = 1024,
							int   seed				      = 0,
							int   clr_mask				  = 0x00ffffff,
							int   intensity_seed          = 255,
							bool  b_use_intensity_seed    = false,
							DWORD intensity_max           = 255,
							int   negative_prob           = 50
							);

void CreateIntensityTexture_8Bit(
							LPDIRECT3DTEXTURE8 ppTextures[],
							int   num,
							int   size,
							int   noise,
							int   seed,
							int   intensity_seed,
							int   intensity_max
							);



LPDIRECT3DTEXTURE8 CreateGlowTexture(int width,int height,int colorScale,int noise,int seed);
LPDIRECT3DTEXTURE8 CreateGradientTexture(DWORD dwWidth,DWORD dwHeight,DWORD dwClrStart,DWORD dwClrEnd);
LPDIRECT3DCUBETEXTURE8 CreateNormalizationCubeMap(DWORD dwSize);
LPDIRECT3DCUBETEXTURE8 CreateStaticReflectionCubeMap(DWORD dwSize);
LPDIRECT3DTEXTURE8 CreateHighlightTexture(int size,int power,
										  bool b_falloff_alpha, 
										  float f_linear_w, float f_cos_w);

int						GetNumberOfIndicesForTristripMesh(
												int x_quads,
												int y_quads,
												bool b_d_tap_1=false,
												bool b_d_tap_2=false
											);
int						CreateTristripForMesh(	WORD* p_index_buffer,
												int x_quads,			// number of quad columns
												int y_quads,			// number of quad rows
												bool b_double_tap_first=false,
												bool b_double_tap_last=false,
												int start_index = 0,	// starting index of lower-left corner
												int vstride = 0,		// vertex difference between rows
												int hstride = 0			// vertex difference between columns
											);	// returns number of indices added
LPDIRECT3DINDEXBUFFER8	CreateTristripForMesh(int x_quads, int y_quads, int* p_num_indices);



#endif	//__TEX_GEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\text_geometry.h ===
/*

xbt.h

*/
#ifndef __xbt_h__
#define __xbt_h__

#include "d3d8types.h"

#define FVF_xbt D3DFVF_XYZ

struct xbt_vertex
{
	float x,y,z;
};

const float xbt_OO_POS_SCALE = 0.002508f;
const float xbt_POS_DELTA = 41.065369f;
const float xbt_OO_TEX_SCALE = -61.068704f;
const float xbt_TEX_DELTA = -1000000.000000f;


///////////////////////////////////////////////////////////////////////////////
const int vertex_count_text_0 = 156;
short verts_text_0C[] = 
{
		-29368,-16381,-16375, //	x,y,z
		-32752,-19098,-16375, //	x,y,z
		-31303,-19096,-16375, //	x,y,z
		-28656,-16952,-16375, //	x,y,z
		-27947,-16381,-16375, //	x,y,z
		-24567,-13668,-16375, //	x,y,z
		-26012,-13668,-16375, //	x,y,z
		-28656,-15814,-16375, //	x,y,z
		-31323,-13667,-16375, //	x,y,z
		-32748,-13668,-16375, //	x,y,z
		-26011,-19099,-16375, //	x,y,z
		-24563,-19098,-16375, //	x,y,z
		-17241,-16195,-16375, //	x,y,z
		-16875,-15892,-16375, //	x,y,z
		-23197,-16837,-16375, //	x,y,z
		-17767,-16837,-16375, //	x,y,z
		-17241,-16592,-16375, //	x,y,z
		-17482,-13978,-16375, //	x,y,z
		-17631,-13777,-16375, //	x,y,z
		-18229,-14512,-16375, //	x,y,z
		-17341,-14216,-16375, //	x,y,z
		-18180,-14621,-16375, //	x,y,z
		-18115,-14760,-16375, //	x,y,z
		-17211,-14489,-16375, //	x,y,z
		-18042,-14928,-16375, //	x,y,z
		-17096,-14794,-16375, //	x,y,z
		-17965,-15125,-16375, //	x,y,z
		-16999,-15131,-16375, //	x,y,z
		-17890,-15350,-16375, //	x,y,z
		-17825,-15603,-16375, //	x,y,z
		-16925,-15498,-16375, //	x,y,z
		-17775,-15884,-16375, //	x,y,z
		-23189,-15884,-16375, //	x,y,z
		-24897,-15884,-16375, //	x,y,z
		-24897,-16837,-16375, //	x,y,z
		-24093,-16837,-16375, //	x,y,z
		-24089,-15884,-16375, //	x,y,z
		-17771,-13594,-16375, //	x,y,z
		-23188,-13593,-16375, //	x,y,z
		-22735,-14514,-16375, //	x,y,z
		-23341,-13768,-16375, //	x,y,z
		-23488,-13970,-16375, //	x,y,z
		-23627,-14208,-16375, //	x,y,z
		-22784,-14624,-16375, //	x,y,z
		-22849,-14762,-16375, //	x,y,z
		-23755,-14481,-16375, //	x,y,z
		-22922,-14930,-16375, //	x,y,z
		-23868,-14787,-16375, //	x,y,z
		-22999,-15127,-16375, //	x,y,z
		-23964,-15124,-16375, //	x,y,z
		-23073,-15352,-16375, //	x,y,z
		-24038,-15491,-16375, //	x,y,z
		-23139,-15605,-16375, //	x,y,z
		-24046,-17245,-16375, //	x,y,z
		-23154,-17120,-16375, //	x,y,z
		-23971,-17623,-16375, //	x,y,z
		-23099,-17366,-16375, //	x,y,z
		-23873,-17969,-16375, //	x,y,z
		-23035,-17579,-16375, //	x,y,z
		-22964,-17766,-16375, //	x,y,z
		-23755,-18281,-16375, //	x,y,z
		-22887,-17934,-16375, //	x,y,z
		-23622,-18558,-16375, //	x,y,z
		-22807,-18089,-16375, //	x,y,z
		-23477,-18796,-16375, //	x,y,z
		-22725,-18238,-16375, //	x,y,z
		-23325,-18994,-16375, //	x,y,z
		-23181,-19156,-16375, //	x,y,z
		-17783,-19156,-16375, //	x,y,z
		-18244,-18241,-16375, //	x,y,z
		-17607,-18874,-16375, //	x,y,z
		-17437,-18588,-16375, //	x,y,z
		-18221,-18195,-16375, //	x,y,z
		-18163,-18080,-16375, //	x,y,z
		-17279,-18291,-16375, //	x,y,z
		-18082,-17905,-16375, //	x,y,z
		-17138,-17978,-16375, //	x,y,z
		-17990,-17683,-16375, //	x,y,z
		-17899,-17424,-16375, //	x,y,z
		-17019,-17643,-16375, //	x,y,z
		-17821,-17138,-16375, //	x,y,z
		-16930,-17283,-16375, //	x,y,z
		-16875,-16890,-16375, //	x,y,z
		-14534,-14523,-16375, //	x,y,z
		-9555,-13605,-16375, //	x,y,z
		-15016,-13619,-16375, //	x,y,z
		-10027,-14518,-16375, //	x,y,z
		-9376,-13854,-16375, //	x,y,z
		-15135,-13768,-16375, //	x,y,z
		-9197,-14166,-16375, //	x,y,z
		-15307,-14007,-16375, //	x,y,z
		-9965,-14655,-16375, //	x,y,z
		-9028,-14534,-16375, //	x,y,z
		-9882,-14833,-16375, //	x,y,z
		-9789,-15055,-16375, //	x,y,z
		-8879,-14949,-16375, //	x,y,z
		-9697,-15320,-16375, //	x,y,z
		-8761,-15403,-16375, //	x,y,z
		-9618,-15631,-16375, //	x,y,z
		-8682,-15885,-16375, //	x,y,z
		-9562,-15987,-16375, //	x,y,z
		-8654,-16389,-16375, //	x,y,z
		-9541,-16389,-16375, //	x,y,z
		-8681,-16881,-16375, //	x,y,z
		-9563,-16789,-16375, //	x,y,z
		-8757,-17327,-16375, //	x,y,z
		-9620,-17140,-16375, //	x,y,z
		-8874,-17736,-16375, //	x,y,z
		-9701,-17445,-16375, //	x,y,z
		-9023,-18116,-16375, //	x,y,z
		-9794,-17704,-16375, //	x,y,z
		-15468,-14296,-16375, //	x,y,z
		-14598,-14659,-16375, //	x,y,z
		-14682,-14838,-16375, //	x,y,z
		-15611,-14633,-16375, //	x,y,z
		-14777,-15059,-16375, //	x,y,z
		-15733,-15013,-16375, //	x,y,z
		-14870,-15324,-16375, //	x,y,z
		-15826,-15435,-16375, //	x,y,z
		-14950,-15633,-16375, //	x,y,z
		-15886,-15894,-16375, //	x,y,z
		-15006,-15988,-16375, //	x,y,z
		-15907,-16389,-16375, //	x,y,z
		-15028,-16389,-16375, //	x,y,z
		-15880,-16881,-16375, //	x,y,z
		-15006,-16788,-16375, //	x,y,z
		-15805,-17327,-16375, //	x,y,z
		-14947,-17139,-16375, //	x,y,z
		-15688,-17736,-16375, //	x,y,z
		-14865,-17442,-16375, //	x,y,z
		-15540,-18116,-16375, //	x,y,z
		-14769,-17700,-16375, //	x,y,z
		-9888,-17920,-16375, //	x,y,z
		-9197,-18473,-16375, //	x,y,z
		-9973,-18094,-16375, //	x,y,z
		-9387,-18814,-16375, //	x,y,z
		-10035,-18227,-16375, //	x,y,z
		-14673,-17915,-16375, //	x,y,z
		-15367,-18473,-16375, //	x,y,z
		-14588,-18088,-16375, //	x,y,z
		-15177,-18814,-16375, //	x,y,z
		-14525,-18221,-16375, //	x,y,z
		-9585,-19149,-16375, //	x,y,z
		-14980,-19149,-16375, //	x,y,z
		-4808,-16381,-16375, //	x,y,z
		-8192,-19098,-16375, //	x,y,z
		-6744,-19098,-16375, //	x,y,z
		-4099,-16952,-16375, //	x,y,z
		-1453,-19099,-16375, //	x,y,z
		-2,-19098,-16375, //	x,y,z
		-3386,-16381,-16375, //	x,y,z
		-6764,-13662,-16375, //	x,y,z
		-8188,-13668,-16375, //	x,y,z
		-4099,-15814,-16375, //	x,y,z
		-6,-13714,-16375, //	x,y,z
		-1430,-13678,-16375, //	x,y,z
};
const int index_count_text_0 = 462;
char indices_text_0C[] = 
{
	0,1,1,
	-2,2,1,
	1,1,1,
	-2,2,1,
	1,1,-9,
	7,1,-8,
	10,1,-7,
	-1,7,-6,
	3,-7,3,
	4,-4,1,
	8,1,1,
	-2,2,1,
	1,-4,3,
	2,1,1,
	1,-3,2,
	1,-1,2,
	-1,1,1,
	1,-3,2,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	-1,1,1,
	1,-3,2,
	1,-1,2,
	-18,17,1,
	-17,-1,18,
	-17,17,1,
	1,1,1,
	1,-3,2,
	-16,-1,19,
	-18,18,1,
	1,-20,19,
	1,-1,2,
	-1,1,1,
	-2,2,1,
	1,-4,3,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	-19,20,-1,
	-19,19,-15,
	-22,18,4,
	-22,22,-1,
	-21,21,18,
	1,-40,39,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	-1,1,1,
	-2,2,1,
	1,-4,3,
	1,-1,2,
	-1,1,1,
	1,-3,2,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	-66,65,1,
	-65,-1,66,
	1,-66,65,
	2,1,1,
	-1,-1,3,
	1,-3,2,
	-3,2,3,
	1,-2,-1,
	-3,5,2,
	-1,-3,5,
	1,-3,2,
	1,-1,2,
	-1,1,1,
	1,-3,2,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	-27,7,21,
	1,-29,28,
	2,-1,-1,
	2,-2,3,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	-21,1,22,
	1,-24,23,
	1,-1,2,
	1,-2,1,
	1,-1,2,
	1,-6,-1,
	7,-7,8,
	1,-2,1,
	1,-1,2,
	1,-2,1,
	2,-7,1,
	7,-1,-6,
	7,-7,5,
	2,-2,-1,
	4,1,1,
	-2,2,1,
	1,1,1,
	-3,1,2,
	1,1,-8,
	9,-2,-7,
	6,4,1,
	-5,5,-2,
	-6,3,3,
	-9,3,6,
};

D3DVECTOR pos_anim_text[2] = 
{
	{-0.229403f,-267.650421f,-103.040421f},	
	{-0.229403f,-141.053757f,-54.439625f} 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\tex_gen.cpp ===
//
//	tex_gen.cpp
//
///////////////////////////////////////////////////////////////////////////////
//  Copyright (C) 2001, Pipeworks Software Inc.
//				All rights reserved
#include "precomp.h"
#include "tex_gen.h"
#include "xbs_app.h"
#include "qrand.h"


#ifndef STARTUPANIMATION
#define ALLOC_TEX_MEM(nb) MemAlloc(nb)
#define FREE_TEX_MEM(pb)  MemFree(pb) 
#else
#define ALLOC_TEX_MEM(nb) MemAllocContiguous(nb,D3DTEXTURE_ALIGNMENT)
#define FREE_TEX_MEM(pb)  MemFreeContiguous(pb)
#endif


inline DWORD GetMaxMipCountFromSize(DWORD size )
{
	DWORD c = 0;
	
	while(size >>= 1) 
		++c;
	
	return c;
}

inline D3DCOLOR VectorToRGBA( const D3DVECTOR* v)
{
    D3DCOLOR color;

    FLOAT r = ( ( v->x + 1.0f ) * 127.5f );
    FLOAT g = ( ( v->y + 1.0f ) * 127.5f );
    FLOAT b = ( ( v->z + 1.0f ) * 127.5f );
    FLOAT a = ( 255.0f);

    __asm
    {
        cvttss2si edx, a       
        cvttss2si ecx, r       
        cvttss2si ebx, g       
        cvttss2si eax, b       
        shl ebx, 8             
        or  eax, ebx           
        shl ecx, 16            
        or  eax, ecx           
        shl edx, 24            
        or  eax, edx           
        mov color, eax       
    }

    return color;
}

LPDIRECT3DTEXTURE8 CreateHighlightTexture(int size,int power,bool b_falloff_alpha, float f_linear_w, float f_cos_w)
{
	IDirect3DTexture8 *pTexture;
	gpd3dDev->CreateTexture( size,size,1,0,D3DFMT_A8R8G8B8,NULL,&pTexture );

	D3DSURFACE_DESC desc;
	pTexture->GetLevelDesc(0,&desc);

	D3DLOCKED_RECT rc;
	pTexture->LockRect(0,&rc,NULL,0);
	int tmp = 4096/size;
	float	ooRadius = 1.0f/(float)(size/2);
	int cntrx = (size-1) / 2;
	int cntry = (size-1) / 2;

	unsigned int *pData;
	pData = (unsigned int *)rc.pBits;

	DWORD *pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*size*size);

	unsigned char cosTable[257];
	for (int i=0; i < 256; i++)
	{
		float Cos,Sin;
		SinCos((float)i/256.f,&Sin,&Cos);
		for (int k = power; k; --k)
			Cos *=Cos;
		float f_sum = 255.f * (Cos * f_cos_w + (float(256-i) / 256.f) * f_linear_w);

		__asm 
		{
			cvttss2si eax, f_sum
			mov		ebx,i
			mov	cosTable[ebx],al
		}
	}

	for (int y=0; y < size; y++)
	{
		unsigned int *pPixel = (unsigned int *)pSourceBits + y*size;
		for (int x=0; x < y; x++)
		{
			float f_dist = fast_sqrt((float)((x-cntrx)*(x-cntrx) + (y-cntry)*(y-cntry))) * ooRadius;
			if (f_dist < 1.f)
			{
				unsigned int c;
				float indexShift = f_dist * 256.f;
				__asm 
				{
					cvttss2si ebx, indexShift;
					movzx	  eax, byte ptr cosTable[ebx]
					mov		  c,eax
				}

				unsigned char a = b_falloff_alpha ? c : 255;

				DWORD P = c | c<<8 | c<<16 | a<<24;
				*pPixel++ = P;
			} 
			else 
			{
				unsigned char a = b_falloff_alpha ? 0 : 0xff000000;
				*pPixel++ = a;
			}
		}
	}
		
	XGSwizzleRect(pSourceBits,
				  0,
				  NULL,
				  rc.pBits,
				  size,
				  size,
				  NULL,
				 sizeof(DWORD));
	pTexture->UnlockRect(0);

	FREE_TEX_MEM(pSourceBits);

	return pTexture;	
}


LPDIRECT3DTEXTURE8 CreateGlowTexture(int width,int height,int colorScale,int noise,int seed)
{
	IDirect3DTexture8 *pTexture;
	int mipLevels = max(GetMaxMipCountFromSize(width),GetMaxMipCountFromSize(height));
	gpd3dDev->CreateTexture(
		width,
		height,
		mipLevels,			
		0,					
		D3DFMT_A8R8G8B8,	
		D3DPOOL_MANAGED,	
		&pTexture);

	for (int i=0; i < mipLevels; i++)
	{
		D3DSURFACE_DESC desc;
		pTexture->GetLevelDesc(i,&desc);

		D3DLOCKED_RECT rc;
		pTexture->LockRect(i,&rc,NULL,0);
		int sWidth = width >> i;
		int tmp = 4096/sWidth;
		int sHeight = height >> i;
		int scale=1;	
		while (tmp!=1) {
			scale++;
			tmp=tmp>>1;
		}
		int cntrx = (sWidth-1) / 2;
		int cntry = (sHeight-1) / 2;

		unsigned int *pData;
		pData = (unsigned int *)rc.pBits;

		DWORD *pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*sWidth*sHeight);

		unsigned int *pPixel = (unsigned int *)pSourceBits;

		for (int y=0; y < sHeight; y++)
		{
			for (int x=0; x < sWidth; x++)
			{
				_asm
				{
					mov		ecx,scale
					mov		eax,x
					mov		ebx,y
					sub		eax,cntrx
					sub		ebx,cntry
					sal		eax,cl
					imul	eax
					sal		ebx,cl
					xchg	eax,ebx
					mov		edi,pPixel
					imul	eax
					mov		edx,4096*4096
					add		ebx,eax
					sub		edx,ebx
					jnc		noOverflow1
					xor		edx,edx
noOverflow1:		mov		ebx,edx
					mov		eax,ebx
					mul		noise
					mov		ecx,seed
					mov		eax,edx
					mov		edx,ecx
					rcl		ecx,13
					sub		edx,11
					sub		ecx,edx
					mov		seed,ecx
					mul		ecx
					shl		edx,15
					sub		ebx,edx	
					jge		bxOk1
					xor		ebx,ebx
					
bxOk1:				and		ebx,0x1ff0000
					rcl		ebx,8
					sbb		ebx,0
					mov		eax,ebx
					shr		eax,24
					mul		al
					mul		eax
					shr		eax,16
					mul		eax
					shr		eax,16

					and		eax,0xff00
					mov		ecx,eax
					shr		ecx,8
					or		ecx,eax
					mov		eax,ecx
					shl		ecx,16
					or		ecx,eax

					mov		[edi],ecx
					add		edi,4
					mov		pPixel,edi
				}
			}
		}		

		XGSwizzleRect(pSourceBits,
					  0,
					  NULL,
					  rc.pBits,
					  sWidth,
					  sHeight,
					  NULL,
					  sizeof(DWORD));
		pTexture->UnlockRect(i);
	
		FREE_TEX_MEM(pSourceBits);
	}
	return pTexture;
}

LPDIRECT3DTEXTURE8 CreateGradientTexture( DWORD dwWidth,    DWORD dwHeight,
										  DWORD dwClrStart, DWORD dwClrEnd)
{
	LPDIRECT3DTEXTURE8 pTex = NULL;
	gpd3dDev->CreateTexture( dwWidth, dwHeight, 1, 0, D3DFMT_A8R8G8B8, NULL, &pTex );

	DWORD *pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*dwWidth*dwHeight);

	D3DCOLORVALUE cv_start,cv_end;

	cv_start.a = ((float)(dwClrStart>>24))/255.f;
	cv_start.r = ((float)((dwClrStart>>16)&0xff))/255.f;
	cv_start.g = ((float)((dwClrStart>>8)&0xff))/255.f;
	cv_start.b = ((float)(dwClrStart&0xff))/255.f;

	cv_end.a = ((float)(dwClrEnd>>24))/255.f;
	cv_end.r = ((float)((dwClrEnd>>16)&0xff))/255.f;
	cv_end.g = ((float)((dwClrEnd>>8)&0xff))/255.f;
	cv_end.b = ((float)(dwClrEnd&0xff))/255.f;

	float del = 1.f/((float)(dwHeight-1));

	for(DWORD r = 0; r < dwHeight; r++)
	{
		float t = del * ((float)r);

		D3DCOLOR color;

		FLOAT _r = (cv_start.r * (1.f-t) + cv_end.r * t) * 255.f;
		FLOAT _g = (cv_start.g * (1.f-t) + cv_end.g * t) * 255.f;
		FLOAT _b = (cv_start.b * (1.f-t) + cv_end.b * t) * 255.f;
		FLOAT _a = (cv_start.a * (1.f-t) + cv_end.a * t) * 255.f;

		__asm
		{
			cvttss2si edx, _a       
			cvttss2si ecx, _r       
			cvttss2si ebx, _g       
			cvttss2si eax, _b       
			shl ebx, 8             
			or  eax, ebx           
			shl ecx, 16            
			or  eax, ecx           
			shl edx, 24            
			or  eax, edx           
			mov color, eax       
		}

		DWORD *ppix = pSourceBits + r * dwWidth;
		for(DWORD x = 0; x < dwWidth; x++)
		{
			*ppix++ = color;
		}
	};

	D3DLOCKED_RECT rc;
	pTex->LockRect(0,&rc,NULL,0);

	XGSwizzleRect(pSourceBits,
				  0,
				  NULL,
				  rc.pBits,
				  dwWidth,
				  dwHeight,
				  NULL,
				  sizeof(DWORD));

	FREE_TEX_MEM(pSourceBits);

	pTex->UnlockRect(0);
	return pTex;
}

LPDIRECT3DTEXTURE8 CreateIntensityTexture(
							int           size,
							bool          b_convert_to_normal_map,
							float         f_height_scale,
							int           noise,
							int           seed,
							int           clr_mask,
							int           intensity_seed,
							bool          b_use_intensity_seed,
							DWORD         intensity_max,
							int			  negative_prob
							)
{
	LPDIRECT3DTEXTURE8 pTex;
	gpd3dDev->CreateTexture(size,size,1,0,D3DFMT_A8R8G8B8,D3DPOOL_MANAGED,&pTex);
	
	D3DLOCKED_RECT rc;
	pTex->LockRect(0,&rc,NULL,0);

	DWORD *pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*size*size);

	DWORD *pPixel = pSourceBits;
	memset(pPixel,0,sizeof(DWORD)*size*size);
	
	QRand rng;
    rng.Init(seed);

	DWORD i = (b_use_intensity_seed) ? intensity_seed : rng.Rand(intensity_max);
	*pPixel = (i<<16)|(i<<8)|(i);

	int curSize    = size>>1;
	int curX       = curSize;
	int curY       = curSize;
	int curNoise   = noise>>1;
	int curStep    = size;

	bool bSquare      = true;
	bool bSecondPass  = false;
	
	while(curSize > 0)
	{
		int lx = curX - curSize;
		int rx = curX + curSize;
		int ly = curY - curSize;
		int uy = curY + curSize;

		if(lx < 0)      lx += size;
		if(rx >= size) rx -= size;
		if(ly < 0)      ly += size;
		if(uy >= size) uy -= size;

		if(bSquare)
		{
			DWORD crnSW = *(pPixel + size*ly + lx);
			DWORD crnSE = *(pPixel + size*ly + rx);
			DWORD crnNW = *(pPixel + size*uy + lx);
			DWORD crnNE = *(pPixel + size*uy + rx);

			DWORD dwI = ((crnSW&0xff) + (crnSE&0xff) + (crnNW&0xff) + (crnNE&0xff) ) >> 2;
			
			if(rng.Rand(100) > negative_prob)
			{
				dwI += rng.Rand(curNoise);
				if(dwI > intensity_max) 
					dwI = intensity_max;
			}
			else
			{
				dwI -= rng.Rand(curNoise);
				if(dwI > 255) 
					dwI = 0;
			}
			

			*(pPixel + size*curY + curX) = (dwI<<16)|(dwI<<8)|(dwI);

			curX += curStep;
			if(curX >= size)
			{
				curY += curStep;
				if(curY >= size)
				{
					curX = curSize;
					curY = 0;
					bSquare = false;
					continue;	
				}
				curX = curSize;
			}
		}
		else
		{
			DWORD crnN = *(pPixel + size*uy   + curX);
			DWORD crnS = *(pPixel + size*ly   + curX);
			DWORD crnW = *(pPixel + size*curY + lx);
			DWORD crnE = *(pPixel + size*curY + rx);

			DWORD dwI = ((crnN&0xff) + (crnS&0xff) + (crnE&0xff) + (crnW&0xff)) >> 2;
			
			if(rng.Rand(100) > negative_prob)
			{
				dwI += rng.Rand(curNoise);
				if(dwI > intensity_max) 
					dwI = intensity_max;
			}
			else
			{
				dwI -= rng.Rand(curNoise);
				if(dwI > 255) 
					dwI = 0;
			}


			*(pPixel + size*curY + curX) = (dwI<<16)|(dwI<<8)|(dwI);

			curX += curStep;
			if(curX >= size)
			{
				curY += curStep;
				if(curY >= size)
				{
					if(bSecondPass)
					{
						curStep = curSize;
						curSize  >>= 1;
						curNoise >>= 1;
						curX = curSize;
						curY = curSize;
						bSquare = true;	
					}
					else
					{
						curX = 0;
						curY = curSize;
					}
					bSecondPass = !bSecondPass;
					continue;
				}

				curX = bSecondPass ? 0 : curSize;
			}	
		}
	}

	DWORD *pTooFar = pPixel + size*size;
	while(pPixel != pTooFar)
	{
		*pPixel = (((*pPixel)&0xff)<<24) | ((*pPixel)&clr_mask);
        pPixel++;
	}
	if(b_convert_to_normal_map)
	{
		for( int y=0; y<size; y++ )
		{
			DWORD *prow0 = pSourceBits + size*y;
			DWORD *prow1 = pSourceBits + size*(y+1);

			if(prow1 >= pTooFar)
				prow1 = pTooFar;

			for( int x = 0; x < size; x++ )
			{
				DWORD* p00 = prow0 + x;
				DWORD* p10 = prow0 + x + 1;
				if(p10 >= pTooFar)
					p10 = pTooFar;

				DWORD* p01 = prow1 + x;

				FLOAT fHeight00 = (FLOAT)(((*p00)&0x00ff0000)>>16) * f_height_scale;
				FLOAT fHeight10 = (FLOAT)(((*p10)&0x00ff0000)>>16) * f_height_scale;
				FLOAT fHeight01 = (FLOAT)(((*p01)&0x00ff0000)>>16) * f_height_scale;

				D3DVECTOR vPoint00;
				Set(&vPoint00, x+0.0f, y+0.0f, fHeight00 );

				D3DVECTOR vPoint10;
				Set(&vPoint10,x+0.1f, y+0.0f, fHeight10 );

				D3DVECTOR vPoint01;
				Set(&vPoint01, x+0.0f, y+0.1f, fHeight01 );
				
				D3DVECTOR v10;
				Sub(vPoint10,vPoint00,&v10);
				
				D3DVECTOR v01;
				Sub(vPoint01,vPoint00,&v01);

				D3DVECTOR v;
				Cross(v10, v01, &v);
				Normalize(&v);

				*p00 = VectorToRGBA( &v );
			}
		}
	}

	XGSwizzleRect(pSourceBits,
				  0,
				  NULL,
				  rc.pBits,
				  size,
				  size,
				  NULL,
				  sizeof(DWORD));

	FREE_TEX_MEM(pSourceBits);

	pTex->UnlockRect(0);

	return pTex;
}

void CreateIntensityTexture_8Bit(
							LPDIRECT3DTEXTURE8 ppTextures[],
							int   num,
							int   size,
							int   noise,
							int   seed,
							int   intensity_seed,
							int   intensity_max
							)
{
#define MAX_TEXTURES (3)
	if (num > MAX_TEXTURES) return;
	D3DLOCKED_RECT rcs[MAX_TEXTURES];

	int tex_size = size*size;

	int i;
	for (i=0; i<num; i++)
	{
		gpd3dDev->CreateTexture(size,size,1,0,D3DFMT_A8,D3DPOOL_MANAGED,&ppTextures[i]);
		ppTextures[i]->LockRect(0,&rcs[i],NULL,0);
	}
	
	BYTE *pSourceBits = (BYTE *)ALLOC_TEX_MEM(sizeof(BYTE)*size*size * num);
	// byte = pSourceBits[tex_num*tex_size + y*size + x];


	BYTE *pPixel = pSourceBits;
	memset(pPixel,0,sizeof(BYTE)*tex_size*num);
	
	QRand rng;
    rng.Init(seed);

	*pPixel = (BYTE)intensity_seed;

	int curSize    = size>>1;
	int curX       = curSize;
	int curY       = curSize;
	int curNoise   = noise>>1;
	int curStep    = size;

	bool bSquare      = true;
	bool bSecondPass  = false;
	
	while(curSize > 0)
	{
		int lx = curX - curSize;
		int rx = curX + curSize;
		int ly = curY - curSize;
		int uy = curY + curSize;

		if(lx < 0)      lx += size;
		if(rx >= size) rx -= size;
		if(ly < 0)      ly += size;
		if(uy >= size) uy -= size;

		if(bSquare)
		{
			for (i=0; i<num; i++)
			{
				int crnSW = *(pPixel + tex_size * i + size*ly + lx);
				int crnSE = *(pPixel + tex_size * i + size*ly + rx);
				int crnNW = *(pPixel + tex_size * i + size*uy + lx);
				int crnNE = *(pPixel + tex_size * i + size*uy + rx);

				int dwI = (crnSW + crnSE + crnNW + crnNE) >> 2;
				
				dwI += rng.Rand(curNoise*2) - curNoise;

				*(pPixel + tex_size * i + size*curY + curX) = (BYTE) (max(0, min(intensity_max, dwI)));
			}

			curX += curStep;
			if(curX >= size)
			{
				curY += curStep;
				if(curY >= size)
				{
					curX = curSize;
					curY = 0;
					bSquare = false;
					continue;	
				}
				curX = curSize;
			}
		}
		else
		{
			for (i=0; i<num; i++)
			{
				int crnN = *(pPixel + tex_size * i + size*uy   + curX);
				int crnS = *(pPixel + tex_size * i + size*ly   + curX);
				int crnW = *(pPixel + tex_size * i + size*curY + lx);
				int crnE = *(pPixel + tex_size * i + size*curY + rx);

				int dwI = ((crnN&0xff) + (crnS&0xff) + (crnE&0xff) + (crnW&0xff)) >> 2;

				dwI += rng.Rand(curNoise*2) - curNoise;

				*(pPixel + tex_size * i + size*curY + curX) = (BYTE) (max(0, min(intensity_max, dwI)));
			}

			curX += curStep;
			if(curX >= size)
			{
				curY += curStep;
				if(curY >= size)
				{
					if(bSecondPass)
					{
						curStep = curSize;
						curSize  >>= 1;
						curNoise >>= 1;
						curX = curSize;
						curY = curSize;
						bSquare = true;	
					}
					else
					{
						curX = 0;
						curY = curSize;
					}
					bSecondPass = !bSecondPass;
					continue;
				}

				curX = bSecondPass ? 0 : curSize;
			}	
		}
	}

	for (i=0; i<num; i++)
	{
		XGSwizzleRect(pSourceBits,
					  0,
					  NULL,
					  rcs[i].pBits,
					  size,
					  size,
					  NULL,
					  sizeof(BYTE));
		ppTextures[i]->UnlockRect(0);
	}

	FREE_TEX_MEM(pSourceBits);
}





LPDIRECT3DCUBETEXTURE8 CreateNormalizationCubeMap(DWORD dwSize)
{
	LPDIRECT3DCUBETEXTURE8 pCubeMap;     
    gpd3dDev->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, &pCubeMap );

	DWORD * pSourceBits = (DWORD *)ALLOC_TEX_MEM(sizeof(DWORD)*dwSize*dwSize);

    for( DWORD i=0; i<6; i++ )
    {
        LPDIRECT3DSURFACE8 pCubeMapFace;
        pCubeMap->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );
        DWORD*      pPixel = pSourceBits;
        D3DVECTOR   n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

				Normalize(&n);
                *pPixel++ = VectorToRGBA( &n );
            }
        }
        
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();
        pCubeMapFace->Release();
    }
    
	FREE_TEX_MEM(pSourceBits);

    return pCubeMap;
}


LPDIRECT3DCUBETEXTURE8 CreateStaticReflectionCubeMap( DWORD dwSize )
{
	Camera old_camera = gApp.theCamera;

	LPDIRECT3DCUBETEXTURE8 pCubeMap;

	gpd3dDev->CreateCubeTexture(dwSize,1,D3DUSAGE_RENDERTARGET,D3DFMT_A8R8G8B8,NULL,&pCubeMap);
	
	LPDIRECT3DSURFACE8 pOldRT,pOldZ;
	gpd3dDev->GetRenderTarget(&pOldRT);
	gpd3dDev->GetDepthStencilSurface(&pOldZ);

	LPDIRECT3DSURFACE8 pNewZ;
	gpd3dDev->CreateDepthStencilSurface(dwSize,dwSize,D3DFMT_LIN_D24S8,
										D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR,
										&pNewZ);

	D3DMATRIX oldProjMat = gApp.theCamera.matProj;
	D3DMATRIX oldViewMat = gApp.theCamera.matWTC;

	gApp.theCamera.setProjection(Pi/2.f,1.f,0.1f,400.f);
	
	D3DVECTOR pos;
	Set(&pos,0.f,0.f,0.f);

	for(DWORD dwFace = 0; dwFace < 6; dwFace++)
	{
		LPDIRECT3DSURFACE8 pNewRT;
		pCubeMap->GetCubeMapSurface( (D3DCUBEMAP_FACES)dwFace, 0, &pNewRT );
		
		gpd3dDev->SetRenderTarget(pNewRT,pNewZ);
		
		if( gpd3dDev->BeginScene() == D3D_OK )
		{
			gpd3dDev->Clear(0,NULL,
							D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET,
							0xff000000,
							1.f,
							0 );

			D3DMATRIX viewMat;
			SetCubeMapView( dwFace, pos, &viewMat );

			gApp.theCamera.setWTC(viewMat);
			gApp.sceneGeom.advanceTime(SCENE_ANIM_START_TIME + SCENE_ANIM_LEN,0.f);
			gApp.sceneGeom.render(false,false);

			pNewRT->Release();

			gpd3dDev->EndScene();
		}
	}

	gpd3dDev->SetRenderTarget(pOldRT,pOldZ);
	
	pOldRT->Release();
	pOldZ->Release();
	pNewZ->Release();

	gApp.theCamera = old_camera;

	return pCubeMap;
}

int GetNumberOfIndicesForTristripMesh(int x_quads, int y_quads, bool b_d_tap_1, bool b_d_tap_2)
{
	if (x_quads <= 14)
	{
		// Single stack is sufficient.
		// Each mesh is composed of x_quads*2 + 1 priming vertices,
		// and for each row there are (x_quads+1)*2 + 2 CR vertices, minus one on the last row.
		return	((b_d_tap_1) ? 1 : 0) +
				x_quads*2 + 1 +
				y_quads*( 2*(x_quads+1) + 2) - 1 +
				((b_d_tap_2) ? 1 : 0);
	}

	return
		GetNumberOfIndicesForTristripMesh(        14, y_quads, b_d_tap_1, true) +
		GetNumberOfIndicesForTristripMesh(x_quads-14, y_quads, true, b_d_tap_2);
}


// returns number of indices added
int CreateTristripForMesh(	WORD* p_index_buffer,
							int x_quads,			// number of quad columns
							int y_quads,			// number of quad rows
							bool b_double_tap_first,
							bool b_double_tap_last,
							int start_index,		// starting index of lower-left corner
							int vstride,			// vertex difference between rows
							int hstride				// vertex difference between columns
							)
{
	if (!vstride) vstride = x_quads+1;
	if (!hstride) hstride = 1;

	if (x_quads > 14)
	{
		int num = 0;
		num += CreateTristripForMesh(&p_index_buffer[num],         14, y_quads, b_double_tap_first, true, start_index           , vstride, hstride);
		num += CreateTristripForMesh(&p_index_buffer[num], x_quads-14, y_quads, true,  b_double_tap_last, start_index+14*hstride, vstride, hstride);
		return num;
	}

	int num = 0;

	if (b_double_tap_first) p_index_buffer[num++] = (WORD) (start_index);
	p_index_buffer[num++] = (WORD) (start_index);

	int i;
	for (i=1; i<=x_quads; i++)
	{
		p_index_buffer[num++] = (WORD) (start_index + i*hstride);
		p_index_buffer[num++] = (WORD) (start_index + i*hstride);
	}

	for (int j=0; j<y_quads; j++)
	{
		p_index_buffer[num++] = (WORD) (start_index + j*vstride);				// double tap beginning of line
		for (int i=0; i<=x_quads; i++)
		{
			p_index_buffer[num++] = (WORD) (start_index + j*vstride + i*hstride);
			p_index_buffer[num++] = (WORD) (start_index + (j+1)*vstride + i*hstride);
		}
		if (j<y_quads-1) p_index_buffer[num++] = (WORD) (start_index + (j+1)*vstride + x_quads*hstride);	// double tap end of line
	}

	if (b_double_tap_last) p_index_buffer[num++] = (WORD) (start_index + y_quads*vstride + x_quads*hstride);

	return num;
}


LPDIRECT3DINDEXBUFFER8 CreateTristripForMesh(int x_quads, int y_quads, int* p_num_indices)
{
	LPDIRECT3DINDEXBUFFER8 p_ib;
	int dummy;
	if (!p_num_indices) p_num_indices = &dummy;
	*p_num_indices = GetNumberOfIndicesForTristripMesh(x_quads, y_quads);
	gpd3dDev->CreateIndexBuffer(
		*p_num_indices * sizeof(WORD),
		D3DUSAGE_WRITEONLY,
		D3DFMT_INDEX16,
		D3DPOOL_DEFAULT,
		&p_ib
		);

	WORD* p_indices;
	p_ib->Lock(0, 0, (BYTE**)&p_indices, 0);
	CreateTristripForMesh(p_indices, x_quads, y_quads);
	p_ib->Unlock();	
	return p_ib;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\stboot.c ===
#include <dsound.h>
#include "sos.h"
#include "macros.h"
#include "bootsnd.h"
#include "pitches.h"

#ifdef STARTUPANIMATION

#pragma data_seg("INIT_RW")
#pragma code_seg("INIT")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

// Tell linker to put bootsound code and data into INIT section
#pragma comment(linker, "/merge:DSOUND=INIT")

#pragma comment(linker, "/merge:INIT_RD=INIT")
#pragma comment(linker, "/merge:INIT_RW=INIT")

#endif //STARTUPANIMATION

DSENVELOPEDESC	Env1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x5,						// hold
	0x20,						// decay
	0x0,						// release
	0x7f,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x10,						// pitch scale
	0x7f,						// filter scale
};




DSENVELOPEDESC	Env2a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x40,						// decay
	0x0,						// release
	0x3f,						// sustain
	0x7f,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env2m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x40,						// pitch scale
	0x4f,						// filter scale
};
	

DSENVELOPEDESC	Env3a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x3,						// hold
	0x10,						// decay
	0x20,						// release
	0x10,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	Env3m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x10,						// pitch scale
	0x1f,						// filter scale
};



DSENVELOPEDESC	OpenEnva = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x0,						// attack
	0x0,						// hold
	0x0,						// decay
	0x0,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	OpenEnvm = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0,						// attack
	0x0,						// hold
	0x00,						// decay
	0x00,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

extern	unsigned short  Sin128[];
extern	unsigned short	Saw128[];
extern	unsigned short	Noise8192[];
extern	unsigned short	FM32768[];
extern	unsigned short	Glock[];

extern	unsigned short	Bubble[];
extern	unsigned short	ThunEl16[];
extern	unsigned short	ReverseThunEl16[];


//
// patch is table, loop, env1, env2
// so, patches are defined by a waveform, a length, a loop address
// and the pair of envelopes.
//


const struct DSPpatch PatchSin = {
	Sin128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env1a,			// ampitude envelope
	&Env1m			// multi purpose envelope
};

///////////////////////////////////////////////////////////////////////
DSENVELOPEDESC	SawEnv1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x2,						// hold
	0x10,						// decay
	0x0,						// release
	0x9f,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	SawEnv1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x10,						// attack
	0x100,						// hold
	0x100,						// decay
	0x80,						// release
	0xff,						// sustain
	0x00,						// pitch scale
	-80,						// filter scale
};


const struct DSPpatch PatchSaw1 = {
	Saw128,			// start addr
	256,				// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&SawEnv1a,			// ampitude envelope
	&SawEnv1m			// multi purpose envelope
};




///////////////////////////////////////////////////////////////////////

DSENVELOPEDESC	SawEnv2a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x0,						// hold
	0x40,						// decay
	0x0,						// release
	0x3f,						// sustain
	0x7f,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	SawEnv2m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x10,						// decay
	0x0,						// release
	0x1f,						// sustain
	0x00,						// pitch scale
	0x0,						// filter scale
};

const struct DSPpatch PatchSaw2 = {
	Saw128,			// start addr
	256,				// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&SawEnv2a,			// ampitude envelope
	&SawEnv2m			// multi purpose envelope
};



	

///////////////////////////////////////////////////////////////////////
const struct DSPpatch PatchSaw3 = {
	Saw128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env3a,			// ampitude envelope
	&Env3m			// multi purpose envelope
};



const struct DSPpatch PatchSquare = {
	Saw128,			// start addr
	256,			// length
	0,				// loop start
	256,			// loop end
	1,				// loop sound
	&Env3a,			// ampitude envelope
	&Env3m			// multi purpose envelope
};


/////////////////////////////////////////////////////////////////////
DSENVELOPEDESC	NoiseEnv1a = {
	DSEG_AMPLITUDE,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x1,						// attack
	0x3,						// hold
	0x10,						// decay
	0x20,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

DSENVELOPEDESC	NoiseEnv1m = {
	DSEG_MULTI,				// EG
	DSEG_MODE_DELAY,			// mode
	0,							// delay
	0x100,						// attack
	0x0,						// hold
	0x30,						// decay
	0xc0,						// release
	0xff,						// sustain
	0x0,						// pitch scale
	0x0,						// filter scale
};

/////////////////////////////////////////////////////////////////////
const struct DSPpatch PatchEnvNoise1 = {
	Noise8192,			// start addr
	8192*2,			// length
	0,				// loop start
	8192*2,			// loop end
	1,				// loop sound
	&NoiseEnv1a,			// ampitude envelope
	&NoiseEnv1m			// multi purpose envelope
};


//////////////////////////////
const struct DSPpatch PatchFM = {
	FM32768,			// start addr
	32768,			// length
	0,				// loop start
	32768,			// loop end
	0,				// loop sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchGlock = {
	Glock,			// start addr
	3768*2,			// length...from glock.equ
	0,				// loop start
	3768*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};

///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
const struct DSPpatch PatchThunEl16 = {
	ThunEl16,			// start addr
	0x5540*2,			// length...from glock.equ
	0,				// loop start
	0x5540*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////
const struct DSPpatch PatchRevThun = {
	ReverseThunEl16,			// start addr
	0x5540*2,			// length...from glock.equ
	0,				// loop start
	0x5540*2,			// loop end
	0,				// Don't loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};
///////////////////////////////////////////////////////////////

const struct DSPpatch PatchBubble = {
	Bubble,			// start addr
	6719*2,			// length...from glock.equ
	0,				// loop start
	6719*2,			// loop end
	1,				//  loop this sound
	&OpenEnva,			// ampitude envelope
	&OpenEnvm			// multi purpose envelope
};


#define	PSIN1		0
#define	PSAW1		1
#define	PSQUARE		2
#define	PSAW2		3
#define	PSAW3		4
#define	PNOISE1		5
#define	PGLOCK		6
#define	PBUBBLE		7
#define	PFM		8
#define	PTHUNEL16 	9
#define	PREVTHUN	10

struct DSPpatch	const *Patches[] = {
	&PatchSin,			// patch 0
	&PatchSaw1,			// patch 1
	&PatchSquare,		// patch 2
	&PatchSaw2,			// patch 3
	&PatchSaw3,			// patch 4
	&PatchEnvNoise1,	// patch 5
	&PatchGlock,		// patch 6
	&PatchBubble,		// 7
	&PatchFM,		// 8
	&PatchThunEl16,		//9
	&PatchRevThun		// 10
};



// throbbing bass
//
const unsigned short Boot0[] = {
	fset(29000,26000),
	patch(PSAW1),
	volume(10),
	rest(194-50),
	note(dd1,130),
	rest(2),
	note(dd1,125),
	rest(3),
	note(dd1,70),
	rest(2),
	note(dd1,77),
	rest(3),
	note(dd1,97),
	rest(3),
	note(dd1,91),
	rest(3),
	note(dd1,47),
	rest(3),
	note(dd1,51),
	rest(3),
	note(dd1,57),
	rest(3),
	note(dd1,132),
	rest(0),





//	rest(194),
//	fset(29000,26000),
//	patch(PSAW1),
//	volume(10),
//	loop(13),
//
//		note(dd1,57),
//		rest(3),
//	endloop,
//	note(dd1,28),
//	rest(2),
//	loop(6),
//		volume(15),
//		note(dd1,27),
//		rest(3),
//	endloop,
//
	loop(255),
	rest(20000),
	endloop
};






//noise whoosh for opening
const unsigned short Boot1[] = {
	fset(1000,26000),
	patch(5),
	volume(43),
	note(cc2,1),
	loop(10),
		finc(3000,26000),
		slur(cc2,13),
	endloop,
	ring(4),
	volume(20),
	loop(60),
		volume(1),
		finc(-1000,26000),
		slur(cc2,15),
	endloop,

	loop(255),
	rest(2000),
	endloop
};

// bubbling sound
const unsigned short Boot2[] = {
	patch(PBUBBLE),
	volume(12),
	fset(6000,26000),
	rest(134),
	note(dd2,412+60),
	loop(20),
		ring(20),
		finc(1000,26000),
	endloop,
	loop(30),
		ring(10),
		volume(4),
	endloop,
	loop(255),
		rest(20000),
	endloop
};


// first and last flashes
const unsigned short Boot3[] = {
	patch(PTHUNEL16),
	volume(40),
	fset(32767,26000),
	rest(134),
	note(dd3,820),
	volume(-25),
	note(dd3,200),
	loop(20),
		ring(20),
		volume(2),
		finc(-1000,26000),
	endloop,
	ring(10000),
	loop(255),
		rest(2000),
	endloop
};

// fast noisy stuff...
//
const unsigned short Boot4[] = {
	rest(194),
	fset(32000,26000),
	patch(PNOISE1),
	volume(160),
	loop(8),
		volume(-3),
		note(cc4,15),
		rest(5),
		note(ff4,15),
		volume(-3),
		rest(5),
		note(gg5,15),
		rest(5),
		volume(-3),
		note(ff4,15),
		rest(5),
	endloop,
	loop(3),
		xpose(0x100),
		volume(-3),
		note(cc4,10),
		rest(5),
		note(ff4,10),
		volume(-3),
		rest(5),
		note(gg5,10),
		rest(5),
		volume(-3),
		note(ff4,10),
		rest(5),
	endloop,


	note(ff4,10),

	loop(255),
	rest(20000),
	endloop
};

// glocks....
const unsigned short Boot5[] = {
	patch(PGLOCK),
	volume(55),
	rest(1114),
	fset(32000,26000),
	
	note(as2,20),
	note(ff2,20),
	note(as1,20),

	volume(10),	
	loop(6),

		note(as2,18),
		rest(2),

		volume(30),
		note(as2,18),
		rest(2),

		volume(20),

		note(as2,18),
		rest(2),
		
		volume(-35),

		finc(-2500,26000),
	endloop,

	loop(255),
	rest(20000),
	endloop
};

// glocks....
const unsigned short Boot6[] = {




//	patch(PGLOCK),
//	volume(10),
//	loop(100),
//		note(cc3,55),
//		rest(5),
//	endloop,
//	rest(1194),
//	fset(32000,26000),

//	note(cc3,40),
//	rest(1),
//	note(ff3,40),
//	rest(1),
//	note(cc3,40),
//	rest(1),
//	note(gg3,400),
//	rest(1),

//	loop(40),
//		note(cc3,18),
//		rest(2),
//		volume(2),
//	endloop,
//	note(cc3,500),
	loop(255),
	rest(20000),
	endloop
};

/////
// glocks....
const unsigned short Boot8[] = {
	patch(PGLOCK),
	volume(100),
	rest(1194),
	fset(32000,26000),
//	note(cc2,40),
//	rest(1),
//	note(ff2,40),
//	rest(1),
//	note(cc2,40),
//	rest(1),
//	note(gg2,400),
//	rest(1),



//	loop(40),
//		note(gg2,18),
//		rest(2),
//		volume(2),
//	endloop,
//	note(cc3,500),

	loop(255),
	rest(20000),
	endloop
};


// bass beg....
const unsigned short Boot7[] = {
	patch(PSAW2),
	xpose(0x60),
	volume(18),
	fset(1000,26000),
	note(dd2,1),
	loop(19),
		slur(dd2,10),
		finc(1500,2600),
	endloop,
	rest(800),
	note(dd2,1),
	loop(30),
		slur(dd2,10),
		finc(-750,2600),
	endloop,
	loop(30),
		slur(dd2,5),
		volume(3),
	endloop,


	loop(255),
	rest(2000),
	endloop
};

////////////////////////////////////////////////////////
// Boot track 9:  Pulses in sync with blob

const unsigned short Boot9[] = {
	patch(PTHUNEL16),
	volume(50),
	rest(326-50),
	note(aa2,280),
	rest(0),
	volume(-15),
	note(aa2,244),
	rest(0),
	volume(-15),
	note(aa2,500),

	loop(255),
	rest(2000),
	endloop
};

////////////////////////////////////////////////////////
// Boot track A:  Pulses in sync with blob

const unsigned short BootA[] = {
	patch(PTHUNEL16),
	volume(50),
	rest(454-50),
	note(aa2,252),
	rest(0),
	note(aa2,194),
	rest(0),
	volume(-20),
	note(aa2,200),


	loop(255),
	rest(2000),
	endloop
};

////////////////////////////////////////////////////////
// Boot track B:  Pulses in sync with blob

const unsigned short BootB[] = {
	patch(PTHUNEL16),
	volume(50),
	rest(526-50),
	note(aa2,274),
	rest(0),
	note(aa2,154),
	rest(0),
	volume(-20),
	note(aa2,200),

	loop(255),
	rest(2000),
	endloop
};



const unsigned short *Boot[] = {
	Boot0,Boot1,Boot2,Boot3,Boot4,Boot5,Boot6,Boot7,Boot8,Boot9,BootA,BootB
};
/////////////////////////////////////////////////////////////////////////

const unsigned short Tune0[] = {

	patch(PREVTHUN),
	note(cc3,800),
	patch(PTHUNEL16),
	note(cc3,800),

	rest(200),
	patch(PSIN1),

	loop(5),
	loop(120),
		note(cc2,50),
		xpose(200),
		rest(0),
	endloop,
	loop(120),
		note(cc0,50),
		xpose(-200),
		rest(0),
	endloop,
	endloop,
	note(5,6),
	rest(0x10),
	
//	0,1,2,3,4
};

const unsigned short Tune1[] = {

//	fset(6000,26000),
	patch(PSIN1),

	note(cc3,200),

};

const unsigned short *Tune[] = {
	Tune0
};

const struct sound sound_calls[] = {
	0,0,0,NULL,				//0 
	1,0,0xfff,Boot,			//1
	1,0,0x001,Tune,			//2
	1,0,0x001,Tune,			//2
};


struct sound sound_calls2[2];

int	max_sound_call = 0x2;
int	default_clock_value = 80;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ani2\VBlob.cpp ===
///////////////////////////////////////////////////////////////////////////////
// File: VBlob.cpp
//
// Copyright 2001 Pipeworks Software
///////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "xbs_math.h"
#include "xbs_app.h"
#include "qrand.h"
#include "VBlob.h"
#include "tex_gen.h"
///////////////////////////////////////////////////////////////////////////////
const float MIN_SPAWN_MAGN =		(0.5f);
#define BLOBLET_DIM			(8)
#define BLOB_DIM			(32)
///////////////////////////////////////////////////////////////////////////////
QRand VBlob::m_QRand;
VBlob* gpVBlob;
///////////////////////////////////////////////////////////////////////////////
void VBlob::Init()
{
    int i;

    for (i = 0; i < MAX_BLOBBUMPS; i++)
    {
        m_BlobBumps[i].Init();
    }

    for (i = 0; i < MAX_BLOBLETS; i++)
    {
        m_Bloblets[i].Init();
    }

    m_QRand.Init();

	m_pBlobletVB = m_pBlobVBConst = m_pBlobVBChangingR = m_pBlobVBChangingU = NULL;
	m_pBlobletIB = m_pBlobIB = NULL;
	m_pUnitSphereNormals = NULL;
    m_dwNumBlobletVertices = m_dwNumBlobletIndices = m_NumVertsPerFace = m_dwNumVertices = m_dwNumIndices = 0;
    m_dwVShaderBlob = m_dwVShaderBloblet = 0;
    m_dwPShaderBlob = m_dwPShaderBloblet = 0;
	m_NumBlobBumps = m_NumBloblets = 0;
	Set(&m_BlobColor, 0.25f, 1.0f, 0.15f, 1.0f);
	Set(&m_Pos, 0.0f, 0.0f, 0.0f);
	Set(&m_Scale, 1.0f, 1.0f, 1.0f);
	m_fRadius = 2.3f;
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::create()
{
	gpVBlob = this;

	gpd3dDev->CreateVertexBuffer(4 * sizeof(float)*5, 0, 0, 0, &pHaloQuadVB);


//MTS	generateUnitSphere(2, &m_pBlobletVB, &m_pBlobletIB, NULL, &m_dwNumBlobletVertices, &m_dwNumBlobletIndices);
	generateUnitSphere(BLOBLET_DIM, &m_pBlobletVB, &m_pBlobletIB, NULL, &m_dwNumBlobletVertices, &m_dwNumBlobletIndices);

	generateUnitSphere(BLOB_DIM, &m_pBlobVBConst, &m_pBlobIB, &m_pUnitSphereNormals, &m_dwNumVertices, &m_dwNumIndices);
	gpd3dDev->CreateVertexBuffer(m_dwNumVertices * sizeof(VBlobChangingVertex), 0, 0, 0, &m_pBlobVBChangingR);
	gpd3dDev->CreateVertexBuffer(m_dwNumVertices * sizeof(VBlobChangingVertex), 0, 0, 0, &m_pBlobVBChangingU);
	m_NumVertsPerFace = m_dwNumVertices / 6;

	restart();

	// Initialize the pixel shaders.
    if( m_dwPShaderBlob )
    {
        gpd3dDev->DeletePixelShader( m_dwPShaderBlob );
        m_dwPShaderBlob = 0;
    }
#ifndef BINARY_RESOURCE
	m_dwPShaderBlob = gApp.loadPixelShader("D:\\Shaders\\VBlob.xpu");
#else // BINARY_RESOURCE
	m_dwPShaderBlob = gApp.loadPixelShader(g_vblob_xpu);
#endif // BINARY_RESOURCE

    if( m_dwPShaderBloblet )
    {
        gpd3dDev->DeletePixelShader( m_dwPShaderBloblet );
        m_dwPShaderBloblet = 0;
    }
#ifndef BINARY_RESOURCE
	m_dwPShaderBloblet = gApp.loadPixelShader("D:\\Shaders\\VBloblet.xpu");
#else // BINARY_RESOURCE
	m_dwPShaderBloblet = gApp.loadPixelShader(g_vbloblet_xpu);
#endif // BINARY_RESOURCE

	// Initialize the vertex shaders.
    DWORD dwBlobShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),    // unit sphere normal
        D3DVSD_STREAM( 1 ),
        D3DVSD_REG( 1, D3DVSDT_FLOAT4 ),    // vertex normal, w is displacement
        D3DVSD_END()
    };
	if (m_dwVShaderBlob)
	{
		gpd3dDev->DeleteVertexShader( m_dwVShaderBlob );
		m_dwVShaderBlob = 0;
	}
#ifndef BINARY_RESOURCE
	m_dwVShaderBlob    = gApp.loadVertexShader("D:\\Shaders\\VBlob.xvu",    dwBlobShaderVertexDecl);
#else // BINARY_RESOURCE
	m_dwVShaderBlob    = gApp.loadVertexShader(g_vblob_xvu,    dwBlobShaderVertexDecl);
#endif // BINARY_RESOURCE

    DWORD dwBlobletShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),    // unit sphere normal
        D3DVSD_END()
    };
	if (m_dwVShaderBloblet)
	{
		gpd3dDev->DeleteVertexShader( m_dwVShaderBloblet );
		m_dwVShaderBloblet = 0;
	}
#ifndef BINARY_RESOURCE
	m_dwVShaderBloblet = gApp.loadVertexShader("D:\\Shaders\\VBloblet.xvu", dwBlobletShaderVertexDecl);
#else // BINARY_RESOURCE
	m_dwVShaderBloblet = gApp.loadVertexShader(g_vbloblet_xvu, dwBlobletShaderVertexDecl);
#endif // BINARY_RESOURCE
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::destroy()
{
	m_pBlobletVB->Release();
	m_pBlobletIB->Release();
	m_pBlobVBConst->Release();
	m_pBlobVBChangingR->Release();
	m_pBlobVBChangingU->Release();
	m_pBlobIB->Release();
	MemFree(m_pUnitSphereNormals);

	pHaloQuadVB->Release();

    if (m_dwPShaderBlob) gpd3dDev->DeletePixelShader(m_dwPShaderBlob);
    if (m_dwPShaderBloblet) gpd3dDev->DeletePixelShader(m_dwPShaderBloblet);
	if (m_dwVShaderBlob) gpd3dDev->DeleteVertexShader(m_dwVShaderBlob);
	if (m_dwVShaderBloblet)	gpd3dDev->DeleteVertexShader(m_dwVShaderBloblet);

	m_pBlobletVB = NULL;
	m_pBlobletIB = NULL;
	m_pBlobVBConst = NULL;
	m_pBlobVBChangingU = m_pBlobVBChangingR = NULL;
	m_pBlobIB = NULL;
	m_pUnitSphereNormals = NULL;
}
///////////////////////////////////////////////////////////////////////////////
void VBlob::render()
{
    // Set default states
    gpd3dDev->SetRenderState( D3DRS_LIGHTING, FALSE );
    gpd3dDev->SetRenderState( D3DRS_ZENABLE,  TRUE );

    gpd3dDev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    gpd3dDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	gpd3dDev->SetTextureStageState( 0, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP);

    gpd3dDev->Se