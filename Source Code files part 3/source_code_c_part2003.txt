return that prefix, otherwise: repeat up to five times
          public void GetPrefixKey(out byte[] key)
          {
               key = null; 
               if (_KeyValueMappings.Keys.Count <= 2) 
                    return;
               bool bFound = false;
               int iTryCount = 0;
               byte[] firstPicked = null;
               byte[] secondPicked = null;
               int iRandIndex = 0;
               int iDifferingIndex = 0;

               //find a prefix to use
               //lock(_KeyValueMappings) //need a lock so no new keys will be added while we're looking for keys
               //{
                    while (bFound == false)
                    {
                         //only try this 5 times, it is a lengthy process
                         if (iTryCount == 5) return;
                         iTryCount++;
                         //pick a random index from all keys
                         iRandIndex = _random.Next(0, _KeyValueMappings.Keys.Count - 1);
                         //pull out the key and the next key
                         firstPicked = _KeyValueMappings.Keys[iRandIndex];
                         secondPicked = _KeyValueMappings.Keys[iRandIndex+1]; 
                         iDifferingIndex = GetFirstDifferingIndex(firstPicked, secondPicked);
                         if (iDifferingIndex >= _MinPrefixLength) break; //we've found our prefix!
                    }

                    //we've found our prefixed key. pull out the prefix
                    key = new byte[iDifferingIndex];
                    Array.Copy(firstPicked, 0, key, 0, iDifferingIndex);
               //}
          }

           public byte[] GetPrefixKeyLITE()
          {
                //generate a prefix key with the LITEPrefix concatenated with one random byte
               ASCIIEncoding enc = new ASCIIEncoding();
               int iLength = _LITEPrefix.Length+1;
               byte[] rgbPrefix = enc.GetBytes(_LITEPrefix);
               byte[] rgbRetVal = new byte[iLength];
               byte[] rand = new byte[1];
               _random.NextBytes(rand);
               //combine cosmic powers!(prefix & postfix)
               Array.Copy(rgbPrefix, 0, rgbRetVal, 0, iLength - 1);
               Array.Copy(rand,0, rgbRetVal , iLength - 1, 1);
               
               return rgbRetVal;
          }

          //called when expiredkeylist.count >=1000; it randomly chooses keys to remove until the count <= 500
          //tries to avoid using too much memory
           private void DoExpiredKeyListMaintenace()
          {
               //cut the key list in half
               while(_ExpiredKeyList.Count > 500)
               {
                    //pick a random key to delete
                    int randIndex = _random.Next(0, _ExpiredKeyList.Count - 1);
                    _ExpiredKeyList.Remove(_ExpiredKeyList.Keys[randIndex]);
               }
          }

          //*** Yanked from XBancProxy.cs ****//
          //Hashes a key to a bucket number according to the hash function found in xbancproxy
          private static uint HashKeyToBucket(byte[] key)
          {
               
               uint sum = 0;
               for (int i = 0; i < key.Length; i++)
               {
                     sum += (uint)key[i];
               }

               return sum % Config.GetBucketCount(Interface.xbanc);
          }
          private static bool IsServerIndexInBucketMap(int index, int[] bucketMap)
          {
                for(int i=0; i<bucketMap.Length; i++)
                {
                    if (bucketMap[i] == index) return true;
                }
                return false;
          }

          //determines if the node passed in is expired, if so, returns true otherwise false
          private bool IsExpired(XBancValueNode node)
          {
               DateTime now = DateTime.Now;

               if (node._isAbsExpiry && now > node._absExpiry)
               {
                    return true;
               }
               if (node._isSlidExpiry && now > node._slidExpiry)
               {
                    return true;
               }
               
               return false;
          }
          
          //compares two byte[]s and returns the index of the first differing byte
          private int GetFirstDifferingIndex(byte[] a, byte[] b)
          {
               int minlength = a.Length;
               if (b.Length < a.Length) minlength = b.Length;
               int index = 0;
               for (index=0; index<minlength; index++)
               {
                    if (b[index] != a[index]) return index;
               }
               return index;
          }
          //updates the MRU list by removing the key and adding it to the front of the linked list
          private void UpdateMRUList(byte[] key)
          {
               //change the linked list, need a ////lock
               //lock(_KeyMRUList)
               //{
                    _KeyMRUList.Remove(key);
                    _KeyMRUList.AddFirst(key);
               //}
          }
          //updates the sliding expiry times for a key, if any
          private void UpdateNodeExpiry(byte[] key)
          {
               XBancValueNode node = null;
               bool notfound = false;
               try
               {
                    node = _KeyValueMappings[key];
               }
               catch(KeyNotFoundException)
               {
                    //key not found in dictionary, do nothing
                    notfound = true;
               }
               if (notfound) return;
               
               if (node._isSlidExpiry)
               {
                    DateTime dt = DateTime.Now;
                    node._slidExpiry = dt.AddSeconds(node._slidExpiryTime);

                    //change the dictionary, need a lock
                    //lock(_KeyValueMappings)
                    //{
                         _KeyValueMappings.Remove(key);
                         _KeyValueMappings.Add(key, node);
                    //}
               }
          }

          /* NO LONGER IN USE
          //generates a small key for the caller to insert into XBanc, caller should also call stressmanagerobject.insert with key after inserting it into Xbanc
          public byte[] GetNewSmallKey()
          {    
               //generate from list of prefixs with the length between the lowestkeysize and smallkeysize settings
               ASCIIEncoding enc = new ASCIIEncoding();
               int iLastIndex = _ListOfPrefixs.Length;
               int iPrefixLength = 0;
               int iPostfixLength = 0; 
               byte[] rgbRetVal = null;
               bool bInList = true;
               // generate the prefix!
               //randomly pick a prefix from the list of prefixs
               string sPrefix = _ListOfPrefixs[_random.Next(0, iLastIndex)];
               //add a few more not terribly random characters to make prefix finding easier
               for(int i=sPrefix.Length; i<=_MinPrefixLength;i++) //to min prefix length
               {
                    switch(_random.Next(1, 3)) //50% chance for an a or b
                    {
                         case 1:
                              sPrefix+="a";
                              break;
                         case 2:
                              sPrefix += "b";
                              break;
                    }
               }
               iPrefixLength =sPrefix.Length ;
                //turn string prefix into byte[]
               byte[] rgbPrefix = enc.GetBytes(sPrefix);
               // generate postfix 
               //do this until we find a key that is not in KeyValueMAppings
               while(bInList)
               {
                    //pick postfix size
                    iPostfixLength = _random.Next(_LowestKeySize-iPrefixLength, _SmallKeySize-iPrefixLength+1);
                    byte[] rgbPostfix = new byte[iPostfixLength];
                    //fill postfix with random bytes
                    _random.NextBytes(rgbPostfix);
                    //combine cosmic powers!(prefix & postfix)
                    rgbRetVal = new byte[iPrefixLength + iPostfixLength];
                    Array.Copy(rgbPrefix, 0, rgbRetVal, 0, iPrefixLength);
                    Array.Copy(rgbPostfix,0, rgbRetVal , iPrefixLength, iPostfixLength);

                    //check to see if the created key is already in the list
                    //lock(_KeyValueMappings)
                    //{
                         if (_KeyValueMappings.ContainsKey(rgbRetVal))
                              bInList = true;
                         else
                         {
                              bInList = false;
                              //insert a reservation
                              _KeyValueMappings.Add(rgbRetVal, null);
                         }

                   // }
               } 
               
               return rgbRetVal;
          }
          
           //generates a LARGE key for the caller to insert into XBanc, caller should also call stressmanagerobject.insert with key after inserting it into Xbanc
          public byte[] GetNewLargeKey()
          {    
               //generate from list of prefixs with the length between the smallkeysize and largekeysize settings
               ASCIIEncoding enc = new ASCIIEncoding();
               int iLastIndex = _ListOfPrefixs.Length;
               int iPrefixLength = 0;
               int iPostfixLength = 0; 
               byte[] rgbRetVal = null;
               bool bInList = true;
                // generate the prefix  
               //randomly pick a prefix from the list of prefixs
               string sPrefix = _ListOfPrefixs[_random.Next(0, iLastIndex)];
                //add a few more not terribly random characters to make prefix finding easier
               for(int i=sPrefix.Length; i<=10;i++)
               {
                    switch(_random.Next(1, 3))
                    {
                         case 1:
                              sPrefix+="a";
                              break;
                         case 2:
                              sPrefix += "b";
                              break;
                    }
               }
               iPrefixLength =sPrefix.Length ;
                //turn string prefix into byte[]
               byte[] rgbPrefix = enc.GetBytes(sPrefix);
               // generate postfix 
               //do this until we find a key that is not in keyvaluemappings
               while(bInList)
               {
                    //pick postfix size
                    iPostfixLength = _random.Next(_SmallKeySize-iPrefixLength, _LargeKeySize-iPrefixLength+1);
                    byte[] rgbPostfix = new byte[iPostfixLength];
                    //fill postfix with random bytes
                    _random.NextBytes(rgbPostfix);
                    //combine cosmic powers!(prefix & postfix)
                    rgbRetVal = new byte[iPrefixLength + iPostfixLength];
                    Array.Copy(rgbPrefix, 0, rgbRetVal, 0, iPrefixLength);
                    Array.Copy(rgbPostfix,0, rgbRetVal , iPrefixLength, iPostfixLength);


                    //check to see if the created key is already in the list
                    //lock(_KeyValueMappings)
                    //{
                         if (_KeyValueMappings.ContainsKey(rgbRetVal))
                              bInList = true;
                         else
                              bInList = false;
                   // }
               } 
               
               return rgbRetVal;
          }
          */

     }

      /** NOTE: this function is mostly unneccesary as it takes too much time and isn't accurate enough in draining. Instead, I just have the stress function call xbsm.RemoveKey() when it errors when querying, etc, due to drainage **/
          //this function will check the memory on the xbanc server to see if it is near the low water mark setting. if the memory + the just "added" value size is greater, it will drain as appropriate.
          //this may lead to some values that are in XBanc but NOT in XbancStressManager. That is OK. We can tolerate SOME inconsistency.
          /*private void CheckMemoryPressure(uint bucketNum, uint dataSize)
          {
               //check the performance counter total bytes size, compare it to the config setting, drain if neccessary
               int retval = 0;
               //determine the server 
               string serverName = _serverList[_bucketMap[(int) bucketNum]];
               //get the total bytes perf counter from XBanc server
               PerformanceCounter XBancTotalBytes = new PerformanceCounter("Xbox Live XBanc Data", "Total bytes", "Total", serverName);
               uint PCData = (uint) XBancTotalBytes.NextValue();
               //get the size limit setting from config
              // uint TotalDataBytes = Config.GetUIntSetting(Setting.xbanc_total_data_storage_bytes);
               uint LowWaterBytes = Config.GetUIntSetting(Setting.xbanc_low_water_data_storage_bytes); 
               //we only care about the lowwaterbytes value because the heartbeat thread on xbanc is so fast that it will remove everything > lowwater pretty much before we get the performance counter reading
               //uint MemoryPressure = LowWaterBytes - PCData; //we're going to assume that the PCreading will never be > LowWaterBytes
               uint MemoryPressure = PCData;
               //if (MemoryPressure > _previousMemoryPressure) 
               if (MemoryPressure < LowWaterBytes && _previousMemoryPressure + dataSize > LowWaterBytes)
               {
                    //time to drain! 
                    uint drainage = dataSize;
                    if (_previousMemoryPressure + dataSize - MemoryPressure < dataSize) drainage = _previousMemoryPressure + dataSize - MemoryPressure;
                    
                    retval = DrainToLowWater((uint) (drainage ), serverName);
               }
               
               //if (PCData + dataSize > LowWaterBytes)                            
                //    retval = DrainToLowWater((uint) (PCData + dataSize - LowWaterBytes), serverName);
               if (retval == -1)
               {
                    //the draintolowwater function did not find enough keys in the MRU list to delete. this is bad. let the user know.
                    XBancStressHelper.Report("DrainToLowWater function did not find enough keys in MRU list to remove. INCONSISTENCY in the XBancStressManager class!!");
               }
               _previousMemoryPressure = MemoryPressure;
          }

          private int DrainToLowWater(uint SizeToDrain, string ServerName)
          {
               uint sizeRemoved = 0;
               LinkedListNode<byte[]> lastNode = _KeyMRUList.Last;
               while(sizeRemoved < SizeToDrain)
               {
                    if (lastNode == null)
                    {
                         //we've got some seriously bad issues here!
                         return -1;
                    }
                    byte[] lastKey = lastNode.Value;
                    //if this key hashes to the correct server, see if we can remove it!
                    uint bucketNum = HashKeyToBucket(lastKey);
                    if (! ServerName.Equals( _serverList[_bucketMap[(int) bucketNum]]))
                    {
                         //skip to next node
                         if (lastNode.Previous == null)
                         {
                              //we've got some seriously bad issues here!
                              return -1;
                         }
                         lastNode = lastNode.Previous;
                         continue;
                    }
                    //it does map, so lets see if it's valid
                    if (_KeyValueMappings.ContainsKey(lastKey))
                    {
                         XBancValueNode temp = _KeyValueMappings[lastKey];
                         //make sure it's not expired!
                         if (! IsExpired(temp))
                         {
                              sizeRemoved += (uint) _valueList[temp._valueIndex].Length;
                         }
                    }
                    //remove the key, valid or not
                    RemoveKey(lastKey);
                    //find next node to remove
                    //RemoveKey modified KeyMRUList, so C# reassigns a new last. lovely.
                    lastNode = _KeyMRUList.Last;
                  
               }

               return 0;
               
          }*/



     //This class houses the tedious functions, used by SM and core stress functions in XBANCStress.cs
     public abstract class XBancStressHelper
     {
          public static XBanc _xb = new XBanc();
          private static Report _report = new Report("Log");
          //inserts rgbKey and rgbValue into XBanc. Wrapper function for the core stress functions.
          public static TEST_RESULTS Insert(byte[] rgbKey, int iValueIndex)
          {
               TEST_RESULTS ResultCode = TEST_RESULTS.PASSED;
               uint hr;
               byte[] rgbOutValue=null;

                //call query to make a reservation
                hr = _xb.Query(rgbKey, out rgbOutValue);
                if ( hr != HResult.S_FALSE )
                {
                    _report.Fatal("XBancStressHelper.Insert: Query failed on key "+PrintByteArray(rgbKey)+" with hr = "+hr);
                     ResultCode = TEST_RESULTS.FAILED;
                }
                //call insert to put the value in the cache
                hr = _xb.Insert(rgbKey, XBancStressManager._valueList[iValueIndex]);
                if ( hr != HResult.S_OK )
                {
                    _report.Fatal("XBancStressHelper.Insert: Insert failed on key "+PrintByteArray(rgbKey)+" with hr = "+hr);
                    ResultCode = TEST_RESULTS.FAILED;
                } 
               return ResultCode;
          }

           //compares two byte arrays, returns true if they are equal, otherwise false
          public static bool CompareByteArrays(byte[] value, byte[] outvalue)
          {
               if (value.Length == outvalue.Length)
               {
                    for(int i=0; i< value.Length; i++)
                    {
                         if (value[i] != outvalue[i])
                         {
                              _report.Fatal("Returned value byte was not expected. Expected: "+value[i]+" Received:  "+outvalue[i]);
                              return false;
                         }
                    }
               }
               else
               {
                    _report.Fatal("value array and returned value array were not the same length. Expected: "+value.Length+" Received:  "+outvalue.Length);
                    return false;
               }
               
               return true;
                              
          }

          //returns the string representation of a byte[]
          public static string PrintByteArray(byte[] b)
          {
               if (b.Length == 0) return "";

               string sRet = "";
               for (int i = 0; i < b.Length - 1; i++)
               {
                    sRet += b[i].ToString() + ",";
               }
               sRet += b[b.Length - 1].ToString();
               return sRet;
          }
          public static void Report(string report)
          {
               _report.Error(report);
          }
     }
      //this class's sole purpose is to act as a mutex for the core stress functions. it otherwise doesn't do anything at all.
      public  static class XBancMutex
      {
          public static void DoNothing()
          {
               //do nothing! haha!
          }
      }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\XBANCStress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.protocol;
using xonline.common.service;

//This file contains all the functions for stress cases. It utilizes XBancStressManager.cs to keep track of all keys and values that are in XBanc to
// attempt to perform meaningful testing, ie, querying for exisiting values of knows sizes, removing actual prefixs, etc. Most functions also attempt
// to verify their cases, ie, compare the returned value from a query with the expected value, check return codes, etc. Each key is prefixed using
// prefixs from XBancTest.xml, so multiple instances of this code can run together if the prefixs are changed for each instance. These cases are
// NOT MULTITHREADABLE, as each function locks on a mutex. This is so the XBanc emulation done by XBancStressManager stays consistent,
// and XBancProxy serializes all requests to XBanc anyway, so very little TPS is lost through this design.

//This file also contains the LITE version of the stress cases. The LITE version does no verification of cases, nor does it attempt to keep track of all keys
// and values stored in XBanc. It picks random keys to insert, queries for a small set of known keys, and picks random keys to remove by prefix.
// HOWEVER each key is prefixed by a string from XBancTest.xml. LITE functions do not lock, so they can be multithreaded, but that won't give you
// much performance increase due to XBancProxy serializing all requests to XBanc.

//THE REGULAR AND LITE FUNCTIONS ARE NOT MEANT TO RUN SIMULTANEOUSLY. CHOOSE ONE TYPE TO RUN AND CHANGE ALL OF THE OTHER FUNCTIONS' PRIORITIES TO ZERO

//NOTE: Running regular (non-LITE) stress in STF will take up a lot of memory: ~500 MB.


namespace XBANCTest
{
   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressInsertSmallValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._LowestValueSize,XBancStressManager._SmallValueSize+1)];
            //_random.NextBytes(rgbValue);
            int valueIndex = _xbsm.GetValueIndex(1);
            ResultCode = XBancStressHelper.Insert(rgbKey, valueIndex);
            if (ResultCode == TEST_RESULTS.PASSED)
            {
               _xbsm.Insert(rgbKey, valueIndex, 0,0);
            }
         }

      }
   }



   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressInsertMediumValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._SmallValueSize+1,XBancStressManager._MediumValueSize+1)];
            //_random.NextBytes(rgbValue);
            int valueIndex = _xbsm.GetValueIndex(2);
            ResultCode = XBancStressHelper.Insert(rgbKey, valueIndex);
            if (ResultCode == TEST_RESULTS.PASSED)
            {
               _xbsm.Insert(rgbKey, valueIndex, 0,0);
            }
         }
      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressInsertLargeValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._MediumValueSize+1, XBancStressManager._LargeValueSize+1)];
            //_random.NextBytes(rgbValue);
            int valueIndex = _xbsm.GetValueIndex(3);
            ResultCode = XBancStressHelper.Insert(rgbKey, valueIndex);
            if (ResultCode == TEST_RESULTS.PASSED)
            {
               _xbsm.Insert(rgbKey, valueIndex, 0,0);
            }
         }

      }
   }


   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressSetDataSmallValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         uint hr, abs, slid;
         XBanc xb = new XBanc();
         //pick random values
         int valueIndex = _xbsm.GetValueIndex(1);
         abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
         if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
         slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
         if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._LowestValueSize,XBancStressManager._SmallValueSize+1)];
            //_random.NextBytes(rgbValue);

            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex], abs, slid);
            if (hr == HResult.S_OK)
            {
               _xbsm.Insert(rgbKey, valueIndex, abs, slid);
            }
            else
            {
               _report.Fatal("SetData failed on small key "+XBancStressHelper.PrintByteArray(rgbKey)+" with hr = "+hr);
               ResultCode = TEST_RESULTS.FAILED;
            }
         }
      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressSetDataMediumValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         uint hr, abs, slid;
         XBanc xb = new XBanc();
         //pick random values
         int valueIndex = _xbsm.GetValueIndex(2);
         abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
         if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
         slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
         if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;

         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._SmallValueSize+1,XBancStressManager._MediumValueSize+1)];
            //_random.NextBytes(rgbValue);

            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex], abs, slid);
            if (hr == HResult.S_OK)
            {
               _xbsm.Insert(rgbKey, valueIndex, abs, slid);
            }
            else
            {
               _report.Fatal("SetData failed on small key "+XBancStressHelper.PrintByteArray(rgbKey)+" with hr = "+hr);
               ResultCode = TEST_RESULTS.FAILED;
            }
         }
      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressSetDataLargeValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;//rgbValue = null;
         uint hr, abs, slid;
         XBanc xb = new XBanc();
         //pick random values
         int valueIndex = _xbsm.GetValueIndex(3);
         abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
         if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
         slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
         if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;

         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewKey();
            // rgbValue = new byte[_random.Next(XBancStressManager._MediumValueSize+1, XBancStressManager._LargeValueSize+1)];
            //_random.NextBytes(rgbValue);

            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex], abs, slid);
            if (hr == HResult.S_OK)
            {
               _xbsm.Insert(rgbKey, valueIndex, abs, slid);
            }
            else
            {
               _report.Fatal("SetData failed on small key "+XBancStressHelper.PrintByteArray(rgbKey)+" with hr = "+hr);
               ResultCode = TEST_RESULTS.FAILED;
            }
         }
      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressQueryForLargeValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         byte[] rgbOutValue = null;
         int valueIndex = -1;
         lock(typeof (XBancMutex))
         {
            _xbsm.GetKeyThatMapsToLargeValue(out rgbKey, out valueIndex);
            if (rgbKey == null)
            {
               _report.Warn("No Keys that map to Large value found");
               return;
            }
            hr = _xb.Query(rgbKey, out rgbOutValue);
            if (hr != HResult.S_OK)
            {
               if (hr!=HResult.S_FALSE)_report.Fatal("Querying for expected existing key  "+XBancStressHelper.PrintByteArray(rgbKey)+", value returned "+hr);
               ResultCode = TEST_RESULTS.FAILED;
               _xbsm.RemoveKey(rgbKey);
               return;
            }
            _xbsm.Query(rgbKey);
         }

         if (! XBancStressHelper.CompareByteArrays(XBancStressManager._valueList[valueIndex], rgbOutValue))
         {
            _report.Fatal("Querying for expected existing key "+XBancStressHelper.PrintByteArray(rgbKey)+" did not return expected value");
            ResultCode = TEST_RESULTS.FAILED;
         }

      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressQueryForMediumValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;//rgbValue = null;
         byte[] rgbOutValue = null;
         int valueIndex = -1;
         lock(typeof (XBancMutex))
         {
            _xbsm.GetKeyThatMapsToMediumValue(out rgbKey, out valueIndex);
            if (rgbKey == null)
            {
               _report.Warn("No Keys that map to medium value found");
               return;
            }
            hr = _xb.Query(rgbKey, out rgbOutValue);
            if (hr != HResult.S_OK)
            {
               if (hr!=HResult.S_FALSE)_report.Fatal("Querying for expected existing key  "+XBancStressHelper.PrintByteArray(rgbKey)+", value returned "+hr);
               ResultCode = TEST_RESULTS.FAILED;
               _xbsm.RemoveKey(rgbKey);
               return;
            }
            _xbsm.Query(rgbKey);
         }
         if (! XBancStressHelper.CompareByteArrays(XBancStressManager._valueList[valueIndex], rgbOutValue))
         {
            _report.Fatal("Querying for expected existing key "+XBancStressHelper.PrintByteArray(rgbKey)+" did not return expected value");
            ResultCode = TEST_RESULTS.FAILED;
         }

      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressQueryForSmallValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         byte[] rgbOutValue = null;
         int valueIndex = -1;
         lock(typeof (XBancMutex))
         {
            _xbsm.GetKeyThatMapsToSmallValue(out rgbKey, out valueIndex);
            if (rgbKey == null)
            {
               _report.Warn("No Keys that map to small value found");
               return;
            }
            hr = _xb.Query(rgbKey, out rgbOutValue);
            if (hr != HResult.S_OK)
            {
               if (hr!=HResult.S_FALSE)_report.Fatal("Querying for expected existing key  "+XBancStressHelper.PrintByteArray(rgbKey)+", value returned "+hr);
               ResultCode = TEST_RESULTS.FAILED;
               _xbsm.RemoveKey(rgbKey);
               return;
            }
            //update expiry if needed
            _xbsm.Query(rgbKey);
         }
         if (! XBancStressHelper.CompareByteArrays(XBancStressManager._valueList[valueIndex], rgbOutValue))
         {
            _report.Fatal("Querying for expected existing key "+XBancStressHelper.PrintByteArray(rgbKey)+" did not return expected value");
            ResultCode = TEST_RESULTS.FAILED;
         }

      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressQueryForNonExpiredValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null, rgbValue = null;
         byte[] rgbOutValue = null;
         lock(typeof (XBancMutex))
         {
            _xbsm.GetNonExpiredKey(out rgbKey, out rgbValue);
            if (rgbKey == null)
            {
               _report.Warn("No non expired keys found");
               return;
            }
            hr = _xb.Query(rgbKey, out rgbOutValue);
            if (hr != HResult.S_OK)
            {
               _report.Fatal("Querying for expected existing key  "+XBancStressHelper.PrintByteArray(rgbKey)+", value returned "+hr);
               ResultCode = TEST_RESULTS.FAILED;
               _xbsm.RemoveKey(rgbKey);
               return;
            }
            //update expiry if needed
            _xbsm.Query(rgbKey);
         }
         if (! XBancStressHelper.CompareByteArrays(rgbValue, rgbOutValue))
         {
            _report.Fatal("Querying for expected non expired key "+XBancStressHelper.PrintByteArray(rgbKey)+" did not return expected value");
            ResultCode = TEST_RESULTS.FAILED;
         }

      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressQueryForExpiredKey : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;
         byte[] rgbOutValue = null;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetExpiredKey();
            if (rgbKey == null)
            {
               _report.Warn("No expired keys found for QueryForExpiredKey");
               return;
            }
            hr = _xb.Query(rgbKey, out rgbOutValue);
            if (hr != HResult.S_FALSE)
            {
               _report.Fatal("Querying for expired key  "+XBancStressHelper.PrintByteArray(rgbKey)+" returned "+hr);
               ResultCode = TEST_RESULTS.FAILED;
               return;
            }
         }
      }
   }


   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressIncrementCreateNew : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         XBanc xb = new XBanc();
         byte[] rgbKey = null;
         uint hr = 0;
         uint randHalfLife = (uint)_random.Next(1,2147483647); 
         ulong randAmount = (ulong)_random.Next(0,2147483647);
         ulong results = 0;
         uint abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
         if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
         uint slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
         if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
         long ticks = 0;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewKey();

            hr = xb.Increment(rgbKey, randAmount, 1, abs, slid, out results);
            ticks = DateTime.Now.Ticks;
            if (hr == HResult.S_FALSE)
            {
               _xbsm.Increment(rgbKey, randAmount,1, abs, slid, ticks);
               if (results != randAmount)
               {
                    ResultCode = TEST_RESULTS.FAILED;
                    _report.Fatal("IncrementExisting returned value: "+results+" did not match expected value "+randAmount+".");
               }
            }
            else
            {
                ResultCode = TEST_RESULTS.FAILED;
                _report.Fatal("Incrementing an new value returned "+hr+" instead of S_FALSE.");
            }
         }

      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressIncrementExisting : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         XBanc xb = new XBanc();
         byte[] rgbKey = null;
         uint hr = 0;
         uint randHalfLife = (uint)_random.Next(1,2147483647); 
         ulong randAmount = (ulong)_random.Next(0,2147483647);
         ulong results = 0, newAmount = 0;
         long ticks = 0;

         lock(typeof (XBancMutex))
         {
            _xbsm.GetKeyThatMapsToIncrementValue(out rgbKey);
            if (rgbKey == null)
            {
                _report.Warn("No existing Increment keys found for IncrementExisting");
                return;
            }
            
            hr = xb.Increment(rgbKey, randAmount, randHalfLife, out results);
            ticks = DateTime.Now.Ticks;
            if (hr == HResult.S_OK)
            {
                newAmount = _xbsm.Increment(rgbKey, randAmount, randHalfLife, 0, 0, ticks);
                //the result that xbsm returns back is not incredibly accurate, due to timing issues. checking for a 1% range is fine.
                ulong range = (ulong)(results * .01);
                if (! (results > newAmount - range && results < newAmount + range))
                {
                    ResultCode = TEST_RESULTS.FAILED;
                    _report.Fatal("IncrementExisting returned value: "+results+" did not match expected value "+newAmount+".");
                }
            }
             else
            {
                ResultCode = TEST_RESULTS.FAILED;
                _report.Fatal("Incrementing an existing value returned "+hr+" instead of S_OK.");
            }
         }

      }
   }



   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressRemoveOneValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         Random random = new Random();
         byte[] rgbKey = null;// rgbValue = null;
         int valueIndex = -1;
         lock(typeof (XBancMutex))
         {
            //randomly chose which type of value to remove -- with a lot more weight on small values
            int choose = random.Next(1,51);
            if (choose % 13 == 0) // 3 / 50 chance 6%
            _xbsm.GetKeyThatMapsToLargeValue(out rgbKey, out valueIndex);
            else if (choose % 7 == 0) // 7 / 50 chance 14%
            _xbsm.GetKeyThatMapsToMediumValue(out rgbKey, out valueIndex);
            else // 40/50 chance 80%
            _xbsm.GetKeyThatMapsToSmallValue(out rgbKey, out valueIndex);
            if (rgbKey == null)
            {
               _report.Warn("No Keys that map to value type found");
               return;
            }
            hr = _xb.Remove(rgbKey, true);
            if (hr != HResult.S_OK)
            {
               _report.Fatal("Removing expected existing key returned "+hr);
               ResultCode = TEST_RESULTS.FAILED;
               return;
            }
            //remove the key from the stress manager too
            _xbsm.RemoveKey(rgbKey);
         }


      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressRemovePrefix : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         Random random = new Random();
         byte[] rgbKey = null;
         lock(typeof (XBancMutex))
         {
            //randomly chose which type of value to remove -- with a lot more weight on small values
            _xbsm.GetPrefixKey(out rgbKey);
            if (rgbKey == null)
            {
               _report.Warn("No key found to remove by prefix");
               return;
            }
            hr = _xb.Remove(rgbKey, false);
            if (hr != HResult.S_OK)
            {
               _report.Fatal("Removing expected existing key returned "+hr);
               ResultCode = TEST_RESULTS.FAILED;
               return;
            }
            //remove the key from the stress manager too
            _xbsm.RemovePrefixKey(rgbKey);
         }
      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressInsertExisitingKey : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         Random random = new Random();
         byte[] rgbKey = null;// rgbValue = null;
         int valueIndex = -1;
         //randomly chose which type of value to reinsert
         int choose = random.Next(1,4);
         lock(typeof (XBancMutex))
         {
            if (choose ==  1)
            _xbsm.GetKeyThatMapsToLargeValue(out rgbKey, out valueIndex);
            else if (choose ==  2)
            _xbsm.GetKeyThatMapsToMediumValue(out rgbKey, out valueIndex);
            else
            _xbsm.GetKeyThatMapsToSmallValue(out rgbKey, out valueIndex);
            if (rgbKey == null)
            {
               _report.Warn("No key existing key found for InsertExisitingKey");
               return;
            }
            if (valueIndex == 0) valueIndex = 2;
            hr = _xb.Insert(rgbKey, XBancStressManager._valueList[valueIndex-1]);
         }
         if (hr != HResult.E_ACCESSDENIED)
         {
            _report.Fatal("Inserting Different data on an exisiting key returned"+hr);
            ResultCode = TEST_RESULTS.FAILED;
            return;
         }

      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressSetDataExistingKey : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;//rgbValue = null;
         uint hr, abs, slid;
         XBanc xb = new XBanc();
         //pick random values
         abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
         if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
         slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
         if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;
         int choose = _random.Next(1,4);
         int valueIndex = _xbsm.GetValueIndex(choose); //doesn't matter if the currently mapped index is the same that we choose
         int outValueIndex = -1;
         lock(typeof (XBancMutex))
         {
            //randomly chose which type of value to change
            if (choose ==  1) //large value
            {
               _xbsm.GetKeyThatMapsToLargeValue(out rgbKey, out outValueIndex);
               //rgbValue = new byte[_random.Next(XBancStressManager._MediumValueSize+1, XBancStressManager._LargeValueSize)];

            }
            else if (choose ==  2) //medium value
            {
               _xbsm.GetKeyThatMapsToMediumValue(out rgbKey, out outValueIndex);
               // rgbValue = new byte[_random.Next(XBancStressManager._SmallValueSize+1,XBancStressManager._MediumValueSize)];
               //_random.NextBytes(rgbValue);
            }
            else  //small value
            {
               _xbsm.GetKeyThatMapsToSmallValue(out rgbKey, out outValueIndex);
               //rgbValue = new byte[_random.Next(XBancStressManager._LowestValueSize,XBancStressManager._SmallValueSize)];
               //_random.NextBytes(rgbValue);
            }

            if (rgbKey == null)
            {
               _report.Warn("No key existing key found for SetDataExistingKey");
               return;
            }

            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex], abs, slid);
            if (hr == HResult.S_OK)
            {
               _xbsm.RemoveKey(rgbKey); //remove it first, since it is an existing key
               _xbsm.Insert(rgbKey, valueIndex, abs, slid); //add the new value
            }
            else
            {
               _report.Fatal("SetData failed on existing key "+XBancStressHelper.PrintByteArray(rgbKey)+" with hr = "+hr);
               ResultCode = TEST_RESULTS.FAILED;
            }
         }
      }
   }


   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressQueryNonExisitingKey : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         Random random = new Random();
         byte[] rgbKey = null, rgbValue = null;
         lock(typeof (XBancMutex))
         {
            //randomly chose which type of key to generate
            rgbKey = _xbsm.GetNewKey();
            if (rgbKey == null)
            {
               _report.Warn("Could not get new key");
               return;
            }
            hr = _xb.Query(rgbKey, out rgbValue);
         }
         if (hr != HResult.S_FALSE)
         {
            _report.Fatal("Did not receive S_FALSE when insterting key "+XBancStressHelper.PrintByteArray(rgbKey)+" but received "+hr);
         }
         //remove the reservation that xbsm made for new the key we got
         _xbsm.RemoveKey(rgbKey);
      }
   }

   [StressInstantiate, StressTest(Priority = 10), EnvRequirement("Stress")]
   class XBancStressRemoveNonExisitingKey : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      public static XBanc _xb = new XBanc();
      private static Report _report = new Report("Log");
      override protected void Execute()
      {
         uint hr;
         ResultCode = TEST_RESULTS.PASSED;
         Random random = new Random();
         byte[] rgbKey = null;
         lock(typeof (XBancMutex))
         {
            //randomly chose which type of key to generate
            rgbKey = _xbsm.GetNewKey();
            if (rgbKey == null)
            {
               _report.Warn("Could not get new key");
               return;
            }
            hr = _xb.Remove(rgbKey, true);
         }
         if (hr != HResult.S_FALSE)
         {
            _report.Fatal("Did not receive S_FALSE when removing non-existing key "+XBancStressHelper.PrintByteArray(rgbKey)+" but received "+hr);
         }
         //remove the reservation that xbsm made for new the key we got
         _xbsm.RemoveKey(rgbKey);
      }
   }

//the key distinctions are no longer needed. having too many functions makes stress complicated and may slow down STFRunner. :(
//xbanc performance is not noticably changed by key length
 /*  [StressInstantiate, StressTest(Priority = 10)]
   class XBancStressInsertLargeKeySmallValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewLargeKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._LowestValueSize,XBancStressManager._SmallValueSize+1)];
            //_random.NextBytes(rgbValue);
            int valueIndex = _xbsm.GetValueIndex(1);
            ResultCode = XBancStressHelper.Insert(rgbKey, valueIndex);
            if (ResultCode == TEST_RESULTS.PASSED)
            {
               _xbsm.Insert(rgbKey, valueIndex, 0,0);
            }
         }

      }
   }

   [StressInstantiate, StressTest(Priority = 10)]
   class XBancStressInsertLargeKeyMediumValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewLargeKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._SmallValueSize+1,XBancStressManager._MediumValueSize+1)];
            //_random.NextBytes(rgbValue);
            int valueIndex = _xbsm.GetValueIndex(2);
            ResultCode = XBancStressHelper.Insert(rgbKey, valueIndex);
            if (ResultCode == TEST_RESULTS.PASSED)
            {
               _xbsm.Insert(rgbKey, valueIndex, 0,0);
            }
         }

      }
   }

   [StressInstantiate, StressTest(Priority = 10)]
   class XBancStressInsertLargeKeyLargeValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewLargeKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._MediumValueSize+1, XBancStressManager._LargeValueSize+1)];
            //_random.NextBytes(rgbValue);
            int valueIndex = _xbsm.GetValueIndex(3);
            ResultCode = XBancStressHelper.Insert(rgbKey, valueIndex);
            if (ResultCode == TEST_RESULTS.PASSED)
            {
               _xbsm.Insert(rgbKey, valueIndex, 0,0);
            }
         }

      }
   }

   
   [StressInstantiate, StressTest(Priority = 10)]
   class XBancStressSetDataLargeKeySmallValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Stress","Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;//rgbValue = null;
         uint hr, abs, slid;
         XBanc xb = new XBanc();
         //pick random values
         int valueIndex = _xbsm.GetValueIndex(1);
         abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
         if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
         slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
         if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;

         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewLargeKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._LowestValueSize,XBancStressManager._SmallValueSize+1)];
            //_random.NextBytes(rgbValue);

            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex], abs, slid);
            if (hr == HResult.S_OK)
            {
               _xbsm.Insert(rgbKey, valueIndex, abs, slid);
            }
            else
            {
               _report.Fatal("SetData failed on large key "+XBancStressHelper.PrintByteArray(rgbKey)+" with hr = "+hr);
               ResultCode = TEST_RESULTS.FAILED;
            }
         }
      }
   }

   [StressInstantiate, StressTest(Priority = 10)]
   class XBancStressSetDataLargeKeyMediumValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Stress","Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;// rgbValue = null;
         uint hr, abs, slid;
         XBanc xb = new XBanc();
         //pick random values
         int valueIndex = _xbsm.GetValueIndex(2);
         abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
         if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
         slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
         if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;

         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewLargeKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._SmallValueSize+1,XBancStressManager._MediumValueSize+1)];
            //_random.NextBytes(rgbValue);

            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex], abs, slid);
            if (hr == HResult.S_OK)
            {
               _xbsm.Insert(rgbKey, valueIndex, abs, slid);
            }
            else
            {
               _report.Fatal("SetData failed on large key "+XBancStressHelper.PrintByteArray(rgbKey)+" with hr = "+hr);
               ResultCode = TEST_RESULTS.FAILED;
            }
         }
      }
   }

   [StressInstantiate, StressTest(Priority = 10)]
   class XBancStressSetDataLargeKeyLargeValue : TestBase
   {
      public static XBancStressManager _xbsm = new XBancStressManager();
      private static Random _random = new Random();
      private static Report _report = new Report("Stress","Log");

      override protected void Execute()
      {
         ResultCode = TEST_RESULTS.PASSED;
         byte[] rgbKey = null;//rgbValue = null;
         uint hr, abs, slid;
         XBanc xb = new XBanc();
         //pick random values
         int valueIndex = _xbsm.GetValueIndex(3);
         abs = (uint) _random.Next(XBancStressManager._AbsoluteExpiryLow,XBancStressManager._AbsoluteExpiryHigh+1);
         if (abs > XBancStressManager._AbsoluteExpiryCutoff) abs = 0;
         slid = (uint) _random.Next(XBancStressManager._SlidingExpiryLow,XBancStressManager._SlidingExpiryHigh+1);
         if (slid > XBancStressManager._SlidingExpiryCutoff) slid = 0;

         lock(typeof (XBancMutex))
         {
            rgbKey = _xbsm.GetNewLargeKey();
            //rgbValue = new byte[_random.Next(XBancStressManager._MediumValueSize+1, XBancStressManager._LargeValueSize+1)];
            //_random.NextBytes(rgbValue);

            hr = xb.SetData(rgbKey, XBancStressManager._valueList[valueIndex], abs, slid);
            if (hr == HResult.S_OK)
            {
               _xbsm.Insert(rgbKey, valueIndex, abs, slid);
            }
            else
            {
               _report.Fatal("SetData failed on large key "+XBancStressHelper.PrintByteArray(rgbKey)+" with hr = "+hr);
               ResultCode = TEST_RESULTS.FAILED;
            }
         }
      }
   }
   */

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncInsert.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace XBANCTest
{
     public class XBancFuncInsert : TestNode
     {

          [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Mainline : XBancFuncTestBase
          {
                 /***** valid key, valid value *****/
               override protected void Execute()
               {
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);

                    InsertSingleItem(key, value);
                     //cleanup
                    Remove(key);

                    //Insert [][] overload
                    byte[][] key2 = null;
                    byte[][] value2 = null;
                    
                    CreateKeyValueArrayPair(out key2, out value2);

                    InsertMultipleItems(key2, value2);
                     //cleanup
                    Remove(key2);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
                    
                    

          [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Keys_EdgeCases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] tempkey = null;
                    byte[] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    
                    CreateKeyValuePair(out tempkey, out value);
                    /***** rest of valid key, valid value test cases *****/
                    //according to MSDN there is an implicit cast from integer literal to byte as long as the literal is < 256
                    byte[][] keyTable = { 
                                                            new byte[] {0,0,0,0},    //nonzero length key with no bits set
                                                            new byte[] {5},          // 1 byte length key
                                                            new byte[] {1,2,3,4,5,6,7,8}, //byte aligned key
                                                            new byte[] {1,2,3,4,5,6},     //non-byte aligned key
                                                            CreateKey( _maxKeyLength) // equal to max size key length
                                                       };
                                                       
                    foreach (byte[] key in keyTable)
                    {
                         InsertSingleItem(key, value);
                          //cleanup
                         Remove(key);
                    }

                     ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

            [TestCase]
           class P_KeyArray_EdgeCases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hr;
                    byte[][] key = new byte[2][];
                    key[0] = new byte[] {34};
                    key[1] = null;
                    byte[][] value = new byte[2][]; //just some random data
                    value[0] = new byte[] {25};
                    value[1] = new byte[] {45};
                    hr = _xb.Insert(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hr == null || hr.Length != 2)
                    {
                        throw new Exception("Insert did not return expected HR results");
                    }
                    if (hr[0] != HResult.S_FALSE)
                    {
                        throw new HResultException(hr[0], "Insert returned "+hr[0]+" instead of S_FALSE");
                    }
                    if (hr[1] != HResult.E_INVALIDARG)
                    {
                        throw new HResultException(hr[1], "Insert returned "+hr[1]+" instead of E_INVALIDARG");
                    }

                    key = new byte[100][];
                    value = new byte[100][];
                    for(int i=0; i<key.Length; i++)
                    {
                        key[i] = CreateKey();
                        value[i] = CreateValue();
                    }

                    InsertMultipleItems(key, value, new uint [key.Length], new uint [key.Length]);

                    //remove for cleanup
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

           [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Values_EdgeCases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    byte[] tempvalue = null;
                    CreateKeyValuePair(out key, out tempvalue);
                    /***** rest of valid key, valid value test cases *****/
                    //according to MSDN there is an implicit cast from integer literal to byte as long as the literal is < 256
                    byte[][] valueTable = { 
                                                            new byte[] {0,0,0,0},    //nonzero length value with no bits set
                                                            new byte[] {5},          // 1 byte length value
                                                            new byte[256000],   //large value size
                                                            new byte[1048576 ] //value sized =  1 mb
                                                       };
                                                       
                    foreach (byte[] value in valueTable)
                    {
                        if (value.Length > 4)
                        {
                            //fill key with some random values.
                            _random.NextBytes(value);
                        }
                         
                        InsertSingleItem(key, value);
                         //cleanup
                        Remove(key);
                    }
                    
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Insert_Same_Value : XBancFuncTestBase
          {
               /***** existing key, same value *****/
               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);
                    //put value at key with SetData
                    SetData(key,value,0,0);

                    hr = _xb.Insert(key, value);
                    if (hr != HResult.S_FALSE )
                    {
                        throw new HResultException(hr, "Insert over existing item with same value returned "+hr+" instead of S_FALSE");
                    }
                    //call remove to clean up
                    Remove(key);

                    //try to do it in the same call
                    byte[][] dupKeys = new byte[][] {key, key};
                    byte[][] dupValues = new byte[][] {value, value};
                    byte[][] outvalues = null;
                    uint[] dupHr;

                    //make a reservation
                    Query(dupKeys, outvalues, new uint[] {HResult.S_FALSE, HResult.S_FALSE});

                    //call insert
                    dupHr = _xb.Insert(dupKeys, dupValues, new uint[dupKeys.Length], new uint[dupKeys.Length]);
                    if (dupHr == null || dupHr.Length != 2)
                    {
                        throw new Exception("Insert did not return expected HR results");
                    }
                    if (dupHr[0] != HResult.S_OK)
                    {
                        throw new HResultException(dupHr[0], "Insert returned "+dupHr[0]+" instead of S_OK");
                    }
                    if (dupHr[1] != HResult.S_FALSE)
                    {
                        throw new HResultException(dupHr[1], "Insert returned "+dupHr[1]+" instead of S_FALSE");
                    }
                     //cleanup                    
                    Remove(dupKeys);
                    

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Insert_Without_Reservation: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);
                    hr = _xb.Insert(key, value);
                    if (hr != HResult.S_FALSE )
                    {
                          throw new HResultException(hr, "Calling Insert without a reservation returned "+hr+" instead of S_FALSE");
                    }    
                    //should fail, so nothing to remove
                    ResultCode = TEST_RESULTS.PASSED;
                    
                    //done with FuncInsertPositive_Simple
               }
          }

          [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_None : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] noExpirationKey = null;
                    byte[] key = null;

                    //valid key, valid value, no expiration          
                    CreateKeyValuePair(out noExpirationKey, out value);
                    CreateKeyValuePair(out key, out value);
                    QueryCheckTime(noExpirationKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                    InsertSingleItem(noExpirationKey, value, 0, 0);
                    QueryCheckTime(noExpirationKey, value, 0xFFFFFFFF, HResult.S_OK);
                    
                    Remove(noExpirationKey);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_MaxAbsolute : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] expiry = null;
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);

                    expiry = new uint[keyArray.Length];
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<expiry.Length; i++)
                    {
                        expiry[i] = _maxUInt;
                        expectedHR[i] = HResult.S_OK;
                        expectedExpiry[i] = _maxUInt - 5;
                    }
                    
                    InsertSingleItem(key, value, _maxUInt, 0);
                    InsertMultipleItems(keyArray, valueArray, expiry, new uint[keyArray.Length]);
                    
                    //wait to see if the value will expire, it should not.
                    new SleepInfo("Wait for 5 seconds for value to NOT expire",5*1000);
                    //Query to see if value did not expire
                    QueryCheckTime(key, value, _maxUInt - 5, HResult.S_OK);
                    QueryCheckTime(keyArray, valueArray, expectedExpiry, expectedHR);
                  
                    //remove for cleanup
                    Remove(key);
                    Remove(keyArray);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_MaxSliding : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] expiry = null;
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);

                    expiry = new uint[keyArray.Length];
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<expiry.Length; i++)
                    {
                        expiry[i] = _maxUInt;
                        expectedHR[i] = HResult.S_OK;
                        expectedExpiry[i] = _maxUInt;
                    }
                    
                    InsertSingleItem(key, value, 0,  _maxUInt);
                    InsertMultipleItems(keyArray, valueArray, new uint[keyArray.Length], expiry);
                    
                    //wait to see if the value will expire, it should not.
                    new SleepInfo("Wait for 5 seconds for value to NOT expire",5*1000);
                    
                    //Query to see if value did not expire
                    QueryCheckTime(key, value, _maxUInt, HResult.S_OK); //sliding time updated because we just queried for it
                    QueryCheckTime(keyArray, valueArray, expectedExpiry, expectedHR);
                    //remove for cleanup
                    Remove(key);
                    Remove(keyArray);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

             [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_Both60seconds : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] absoluteExpiry = null;
                    uint[] slidingExpiry = null;                    
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    //create sliding and absolute keys, one value
                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);

                    keyArray = new byte[3][];
                    valueArray = new byte[3][];

                    absoluteExpiry = new uint[keyArray.Length];
                    slidingExpiry = new uint[keyArray.Length];                    
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<keyArray.Length; i++)
                    {
                        keyArray[i] = CreateKey();
                        valueArray[i] = CreateValue();
                        expectedHR[i] = HResult.S_FALSE;
                        expectedExpiry[i] = _reservationExpirySeconds;
                    }
                    absoluteExpiry[0] = 0;
                    absoluteExpiry[1] = 60;
                    absoluteExpiry[2] = 60;
                    slidingExpiry[0] = 60;
                    slidingExpiry[1] = 0;
                    slidingExpiry[2] = 60;

                    //valid key, valid value, 60 seconds sliding expiration          

                    // *******  verify value expires 60 seconds after insertion **********
                    InsertSingleItem(slidingKey, value, 0, 60);
                    InsertSingleItem(absoluteKey, value, 60, 0);
                    InsertMultipleItems(keyArray, valueArray, absoluteExpiry, slidingExpiry);

                     //sleep for 60 seocnds, value should expire
                     new SleepInfo("Wait 60 seconds for both values to expire", 60 * 1000);
                     //both values should be expired
                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                     QueryCheckTime(keyArray, null, expectedExpiry, expectedHR);

                     Remove(keyArray);

                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class P_Expiry_MultipleInsert : XBancFuncTestBase
          {
                
               override protected void Execute()
               {
                    byte[][] keyArrayInsert = null;
                    byte[][] keyArrayQuery = null;
                    byte[][] valueArray = null;
                    byte[][] expectedQueryValues = null;
                    uint[] absoluteExpiry = null;
                    uint[] slidingExpiry = null;                    
                    uint[] expectedExpiry = null;
                    uint[] expectedHR= null;
                    
                   //65                                  75                          30                      45                  60                  
                    //not sliding expired, not absolute expired, sliding expired, absolute expired, reservation expired, 
                    keyArrayInsert = new byte[4][];
                    valueArray = new byte[4][];
                    absoluteExpiry = new uint[keyArrayInsert.Length];
                    slidingExpiry = new uint[keyArrayInsert.Length];   
                    //for the query checktime call
                    expectedQueryValues = new byte[5][];
                    keyArrayQuery = new byte[5][];
                    expectedHR = new uint[keyArrayQuery.Length];
                    expectedExpiry = new uint[keyArrayQuery.Length];
                    
                    for(int i=0; i<keyArrayInsert.Length; i++)
                    {
                        keyArrayInsert[i] = CreateKey();
                        valueArray[i] = CreateValue();
                        keyArrayQuery[i] = keyArrayInsert[i];
                    }
                    
                    absoluteExpiry[0] = 0;
                    absoluteExpiry[1] = 75;
                    absoluteExpiry[2] = 0;
                    absoluteExpiry[3] = 45;
                    slidingExpiry[0] = 70;
                    slidingExpiry[1] = 0;
                    slidingExpiry[2] = 30;
                    slidingExpiry[3] = 0;

                    //results for the QueryCheckTime
                    keyArrayQuery[4] = CreateKey();
                    
                    expectedHR[0] = HResult.S_OK;
                    expectedHR[1] = HResult.S_OK;
                    expectedHR[2] = HResult.S_FALSE;
                    expectedHR[3] = HResult.S_FALSE;
                    expectedHR[4] = HResult.S_FALSE;
                    expectedExpiry[0] = 70;
                    expectedExpiry[1] = 15;
                    expectedExpiry[2] = _reservationExpirySeconds;
                    expectedExpiry[3] = _reservationExpirySeconds;
                    expectedExpiry[4] = _reservationExpirySeconds;
                    expectedQueryValues[0] = valueArray[0];
                    expectedQueryValues[1] = valueArray[1];
                    expectedQueryValues[2] = null;
                    expectedQueryValues[3] = null;
                    expectedQueryValues[4] = null;
                    //make the reservation for the last case
                    Query(keyArrayQuery[4], null, HResult.S_FALSE);
                    
                    InsertMultipleItems(keyArrayInsert, valueArray, absoluteExpiry, slidingExpiry);

                     //sleep for 60 seocnds, value should expire
                    new SleepInfo("Wait 60 seconds for both values to expire", 60 * 1000);

                    QueryCheckTime(keyArrayQuery, expectedQueryValues, expectedExpiry, expectedHR);

                    //remove everything for cleanup
                    Remove(keyArrayQuery);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
           class P_Expiry_RandomlyQuerySlidingExpiration : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint slidingExpiryTime = 100;
                    byte[] key = null, value = null;
                    long ticksPerSecond = 10000000;
                    CreateKeyValuePair(out key, out value);

                    DateTime timeNanny = DateTime.Now;
                    SetData(key, value, 0, slidingExpiryTime);
                    long secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                    for (int i=0; i<10; i++)
                    {
                        _report.Debug(i+"/10 query test begins.");
                        //randomly pick a time to sleep
                        int sleepSeconds = _random.Next(1,(int)(slidingExpiryTime+1));
                        Thread.Sleep(sleepSeconds * 1000);

                        QueryCheckTime(key, value, slidingExpiryTime, HResult.S_OK);
                        secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;                        
                        _report.Debug(secondsPassed + " total seconds have passed");
                    }
                   //remove for cleanup
                   Remove(key);
                   ResultCode = TEST_RESULTS.PASSED;
               }
          }


           [TestCase]
           class P_Expiry_220secondsAbsolute_Bug107728 : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    long secondsPassed = 0;
                    uint absoluteExpirySeconds = 220;
                    long ticksPerSecond =10000000;

                    //valid key, valid value       
                    CreateKeyValuePair(out key, out value);
                    DateTime timeNanny = DateTime.Now;
                    DateTime now = DateTime.Now;

                    SetData(key, value, absoluteExpirySeconds, 0);
                    secondsPassed = (DateTime.Now.Ticks - now.Ticks)/ticksPerSecond; 
                  
                    //query for it every 10 seconds to make sure it is still there
                    while (secondsPassed < absoluteExpirySeconds)
                    {
                        secondsPassed = ( DateTime.Now.Ticks - now.Ticks)/ticksPerSecond; 
                        QueryCheckTime(key, value, absoluteExpirySeconds - (uint)secondsPassed, HResult.S_OK);

                        new SleepInfo("Waiting 10 seconds to query", 10*1000);
                
                        //do time keeping because i do not trust the sleepinfo to be accurate
                        secondsPassed = ( DateTime.Now.Ticks - now.Ticks)/ticksPerSecond; 

                    }
                     long newSecondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                     _report.Debug("total time passed: "+newSecondsPassed);
                    // Query to see if value expired
                    QueryCheckTime(key, null, _reservationExpirySeconds, HResult.S_FALSE);

                    //remove to clean it up, just incase.
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }

               [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_MultipleInserts: XBancFuncTestBase
          {
            // *******  verify value expires 30 seconds after insertion despite multiple inserts **********
               override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    byte[] anotherSlidingKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out anotherSlidingKey, out value);
                    CreateKeyValuePair(out slidingKey, out value);

                    InsertSingleItem(slidingKey, value, 0, 30);
                    InsertSingleItem(anotherSlidingKey, value, 0, 30);
                    //sleep for 15 seocnds
                    new SleepInfo("Wait 15 seconds.", 15 * 1000);

                    //try to insert same value again
                    hr = _xb.Insert(slidingKey, value);
                    if (hr != HResult.S_FALSE)
                    {
                        throw new HResultException(hr, "Calling Insert with existing key and same value "+hr+" instead of S_FALSE");  
                    }

                     //try to insert different value 
                     byte[] differentValue = _enc.GetBytes("sliiiiding different value!");
                     hr = _xb.Insert(anotherSlidingKey, differentValue);
                     if (hr != HResult.E_ACCESSDENIED)
                     {
                         throw new HResultException(hr, "Calling Insert with existing key and different value "+hr+" instead of E_ACCESSDENIED"); 
                     }

                     //sleep for 20 seocnds, "insert different value" case should should expire, "insert same value" should not
                     new SleepInfo("Wait 20 seconds.", 20 * 1000); //now 35 seconds after initial insertion, 20 seconds after re-insertion
                     
                    QueryCheckTime(slidingKey, value, 30, HResult.S_OK);                      
                    QueryCheckTime(anotherSlidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);

                    //sleep for 31 seocnds, both values should be expired
                    new SleepInfo("Wait 31 seconds.", 31 * 1000); //now 66 seconds after initial insertion, 51 seconds after re-insertion, 31 seconds after last query

                    QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);                

                    Remove(slidingKey);
                    Remove(anotherSlidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

                    [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_MultipleQueries60Sec: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;
                    long ticksPerSecond = 10000000;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);

                     // ****** verify value expires 60 seconds after last query ********
                    InsertSingleItem(slidingKey, value, 0, 60);
                    InsertSingleItem(absoluteKey, value, 60, 0);
                    DateTime now = DateTime.Now;
                    //sleep for 25 seocnds
                    new SleepInfo("Wait 25 seconds then query for sliding key", 25 * 1000);
                    uint secPassed = (uint)((DateTime.Now.Ticks - now.Ticks)/ticksPerSecond);
                    //now 25 seconds after insertion
                    QueryCheckTime(slidingKey, value, 60, HResult.S_OK);
                    QueryCheckTime(absoluteKey, value, 60-secPassed, HResult.S_OK);

                      //sleep for 40 seconds
                      _report.Debug("Sleeping for 40 seconds, will be 65 seconds after insertion, 40 seconds after last query.");
                      new SleepInfo("Wait 40 seconds.", 40 * 1000);  //now 65 seconds after insertion, 40 seconds after last query

                     //do not test query for sliding expiry key, it will push its expiration longer
                     //test absolute expiry, should be expired
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds, HResult.S_FALSE);    

                    //sleep for 25 seocnds
                    _report.Debug("Sleeping for 25 seconds, will be 80 seconds after insertion, 65 seconds after last query.");
                    new SleepInfo("Wait 25 seconds", 25 * 1000);

                     //now 80 seconds after insertion, 65 seconds after last query, all should be expired
                    QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);  

                    Remove(slidingKey);
                    Remove(absoluteKey);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_Remove: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    // ****** verify remove called before 60 seconds removes the value ********
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);
                    InsertSingleItem(slidingKey, value, 0, 60);
                    InsertSingleItem(absoluteKey, value, 60, 0);
                   
                     //sleep for 25 seconds
                     new SleepInfo("Wait 25 seconds", 25 * 1000);
                     //now 25 seconds after insertion

                     Remove(slidingKey);
                     //value should be removed
                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);  
                     //remove and check absolute
                     Remove(absoluteKey);
                     //value should be removed
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds, HResult.S_FALSE);  
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_OverwriteWithSetData: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);
                    InsertSingleItem(slidingKey, value, 0, 60);
                    InsertSingleItem(absoluteKey, value, 60, 0);
                    
                    //sleep for 25 seocnds
                    _report.Debug("Sleeping for 25 seconds.");
                    new SleepInfo("Wait 25 seconds",25 * 1000);

                     SetData(slidingKey, value,0,0);
                     SetData(absoluteKey, value,0,0);
                      
                      //check to see if the setdata worked
                      QueryCheckTime(slidingKey, value, 0xFFFFFFFF, HResult.S_OK);
                      QueryCheckTime(absoluteKey, value, 0xFFFFFFFF,  HResult.S_OK);     
                      
                      //sleep for 65 seocnds, value should NOT expire
                      _report.Debug("Sleeping for 65 seconds, will be 90 seconds after insertion, 65 seconds after last query.");
                      new SleepInfo("Wait 65 seconds", 65 * 1000);

                     QueryCheckTime(slidingKey, value, 0xFFFFFFFF,  HResult.S_OK);
                     QueryCheckTime(absoluteKey, value, 0xFFFFFFFF,  HResult.S_OK); 
                     Remove(slidingKey);
                     Remove(absoluteKey);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase, Description("Insert version 2 sliding/absolute seconds individual testing")]
          class P_Expiry_InsertOverExpiredData: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);
                    InsertSingleItem(slidingKey, value, 0, 5);
                    InsertSingleItem(absoluteKey, value, 5, 0);
                    
                    //sleep for 5 seocnds
                    _report.Debug("Sleeping for 5 seconds.");
                     new SleepInfo("Wait 5 seconds",5 * 1000);

                     InsertSingleItem(slidingKey, value, 0, 5);
                     InsertSingleItem(absoluteKey, value, 5, 0);
                      
                      //check to see if the setdata worked
                      QueryCheckTime(slidingKey, value, 5, HResult.S_OK);
                      QueryCheckTime(absoluteKey, value, 5,  HResult.S_OK);     
                      
                      new SleepInfo("Wait 10 seconds", 6 * 1000);

                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds,  HResult.S_FALSE);
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds,  HResult.S_FALSE); 
                     Remove(slidingKey);
                     Remove(absoluteKey);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }
    

             [TestCase, Description("Insert version 2 sliding/absolute seconds integrated testing")]
          class P_Expiry_VariedSlidingAndAbsolute_ExpireAfterInsertion : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] absoluteKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);
                    CreateKeyValuePair(out absoluteKey, out value);

                    InsertSingleItem(slidingKey, value, 60, 30);    
                    InsertSingleItem(absoluteKey, value, 30, 60);   
                   
                     //sleep for 35 seocnds, value should expire
                     new SleepInfo("Wait 35 seconds for value to expire", 35 * 1000);

                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                     QueryCheckTime(absoluteKey, null, _reservationExpirySeconds, HResult.S_FALSE);

                    Remove(slidingKey);
                    Remove(absoluteKey);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

                  [TestCase, Description("Insert version 2 sliding/absolute seconds integrated testing")]
          class P_Expiry_VariedSlidingAndAbsolute_ExpireAfterMultipleQueries : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] value = null;
                    long ticksPerSecond = 10000000;

                    CreateKeyValuePair(out slidingKey, out value);

                    DateTime timeNanny = DateTime.Now;
                    InsertSingleItem(slidingKey, value, 40, 30);
                    uint expectedExpiryTime = 30;
                    
                     //sleep for 10 seocnds
                     _report.Debug("Sleeping for 8 seconds.");
                     new SleepInfo("Wait 8 seconds, then query", 8 * 1000);

                     //now 10 seconds after insertion
                     long secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                     if ((int)secondsPassed > 10) expectedExpiryTime = 40- (uint)secondsPassed;

                     QueryCheckTime(slidingKey, value, expectedExpiryTime, HResult.S_OK); //sliding = 40, absolute = 30

                     //sleep for 20 seocnds
                     _report.Debug("Sleeping for 22 seconds, will be 30 seconds after insertion, 20 seconds after last query.");
                     new SleepInfo("Wait 22 seconds", 22 * 1000);

                     //now 30 seconds after insertion, 20 seconds after last query
                     secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                     if ((int)secondsPassed > 10) expectedExpiryTime = 40-(uint)secondsPassed;
                     QueryCheckTime(slidingKey, value, expectedExpiryTime, HResult.S_OK);

                     //sleep for 15 seocnds, value should expire
                     _report.Debug("Sleeping for 15 seconds, will be 45 seconds after insertion, 15 seconds after last query.");
                     new SleepInfo("Wait 15 seconds for value to expire", 15 * 1000);

                     //45 seconds after insertion, 15 seconds after last query
                     QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);
                     Remove(slidingKey);
                    
                         
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase, Description("Insert version 2 sliding/absolute seconds integrated testing")]
          class P_Expiry_VariedSlidingAndAbsolute_Remove : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] value = null;

                    CreateKeyValuePair(out slidingKey, out value);

                    InsertSingleItem(slidingKey, value, 60, 30);
                    
                     //sleep for 15 seocnds
                     _report.Debug("Sleeping for 15 seconds.");
                     new SleepInfo("Wait 15 seconds", 15 * 1000);

                     Remove(slidingKey);
                     //value should be removed
                      QueryCheckTime(slidingKey, null, _reservationExpirySeconds, HResult.S_FALSE);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           
           [TestCase, Description("Insert version 2 sliding/absolute seconds integrated testing")]
          class P_Expiry_VariedSlidingAndAbsolute_OverwriteWithSetData : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] slidingKey = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out slidingKey, out value);

                    InsertSingleItem(slidingKey, value, 60, 30);
                    
                    SetData(slidingKey, value,0,0);
                     //check to see if the setdata worked
                    QueryCheckTime(slidingKey, value, 0xFFFFFFFF, HResult.S_OK);

                      //sleep for 65 seocnds, value should NOT expire
                      _report.Debug("Sleeping for 65 seconds, will be 65 seconds after setdata and query call.");
                      new SleepInfo("Wait 65 seconds", 65 * 1000);

                     //check to see if value has not expired
                     QueryCheckTime(slidingKey, value, 0xFFFFFFFF, HResult.S_OK);

                      //remove the value (cleanup)
                      Remove(slidingKey);
                         
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Parameter_Null_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] keyNull = null;
                    byte[] value = null;
                    byte[][] valueArray = null;
                    byte[][] valueNull = null;
                    
                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);
                    
                    /**** null key, valid value *****/
               
                     hr = _xb.Insert(null,value);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Insert with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                     hr = _xb.Insert(null,value,0,0);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Insert with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                     hrArray = _xb.Insert(keyNull, valueArray, new uint[valueArray.Length],new uint[valueArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with null key array returned unexpected HResult array");
                     }

                    /**** valid key, null value *****/
                     hr = _xb.Insert(key, null);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Insert with null value returned "+hr+" instead of E_INVALIDARG");                           
                     }

                     hr = _xb.Insert(key, null,0,0);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Insert with null value returned "+hr+" instead of E_INVALIDARG");                           
                     }

                     hrArray = _xb.Insert(keyArray, valueNull,new uint[keyArray.Length],new uint[keyArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with null value array returned unexpected HResult array");
                     }
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
          class N_Parameter_Unequal_Length_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint[] hr;
                    
                    hr = _xb.Insert(new byte[][] {new byte[]{1}},new byte[][] {new byte[]{2},new byte[]{3},new byte[]{4},new byte[]{5}}, new uint[1], new uint[1]);
                    if (hr != null)
                    {
                        throw new Exception("Calling insert with key array and value array different lengths returned unexpected HResult array");
                    }
                    
                    byte[][] key = new byte[][] {new byte[]{1},new byte[] {2},new byte[]{3}};
                    byte[][] value = new byte[][] {new byte[]{1,2},new byte[] {2,3},new byte[]{3,4,5,6}};

                    hr = _xb.Insert(key, value, new uint[] {0,0,0,0}, new uint[] {0,0,0,0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling insert with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                    hr = _xb.Insert(key, value, new uint[] {0,0,0,0,0}, new uint[] {0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling insert with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                     hr = _xb.Insert(key, value, new uint[] {0}, new uint[] {0,0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling insert with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_Parameter_Empty_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    uint[] hrArray;
                    byte[][] keyArray = null;
                    byte[][] keyEmpty = new byte[0][];
                    byte[][] valueArray = null;
                    byte[][] valueEmpty = new byte[0][];
                    
                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);
                   
                    /**** empty key, valid value *****/
                     hr = _xb.Insert(new byte[0], value);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Insert with empty key returned "+hr+" instead of E_INVALIDARG");                                      
                    }

                     hr = _xb.Insert(new byte[0], value,0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Insert with empty key returned "+hr+" instead of E_INVALIDARG");                                      
                    }

                     hrArray = _xb.Insert(keyEmpty, valueArray, new uint[keyEmpty.Length], new uint[keyEmpty.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty key array returned unexpected HResult array");
                     }

                     /***** valid key, empty value ******/
                     hr = _xb.Insert(key, new byte[0]);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Insert with empty value returned "+hr+" instead of E_INVALIDARG");                                      
                    }
                    
                     hr = _xb.Insert(key, new byte[0],0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                         throw new HResultException(hr, "Calling Insert with empty value returned "+hr+" instead of E_INVALIDARG");                        
                    }

                     hrArray = _xb.Insert(keyArray, valueEmpty, new uint[keyArray.Length], new uint[keyArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty value array returned unexpected HResult array");
                     }

                     /***** vaild key, valid value, empty expiries ******/
                      hrArray = _xb.Insert(keyArray, valueArray, new uint[0], new uint[0]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty expiry arrays returned unexpected HResult array");
                     }

                     hrArray = _xb.Insert(keyArray, valueArray, new uint[valueArray.Length], new uint[0]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty sliding expiry array returned unexpected HResult array");
                     }

                     hrArray = _xb.Insert(keyArray, valueArray, new uint[0], new uint[valueArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling insert with empty absolute expiry array returned unexpected HResult array");
                     }
                    

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Key_SizeTooLong : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    
                    CreateKeyValuePair(out key, out value);

                    /***** key size too long, valid value *****/
                    byte[] keyTooLong =  new byte[_maxKeyLength + 1];
                    //fill key with some random values.
                    _random.NextBytes(keyTooLong);

                     hr = _xb.Insert(keyTooLong, value);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Insert with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                     hr = _xb.Insert(keyTooLong, value,0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Insert with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_KeyArray_Invalid_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint[] hrArray;
                    byte[][] key = null;
                    byte[][] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);

                    /********* KEY CASES **************/
                    
                    //key[0] = null;
                    key = new byte[1][];
                    key[0] = null;
                    value = new byte[][] {new byte[]{1}};
                    
                    hrArray = _xb.Insert(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling insert with null key first value returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling Insert with null key first value returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    //key[0] = invalid key, key[1] = valid key w/o reservation, key[2] = invalid key
                    key = new byte[3][];
                    key[0] = new byte[_maxKeyLength + 1];   //key size too long
                    key[1] = new byte[]{2,3,4,5,6,7,8};                   //insert without reservation
                    key[2] = null;                                          //null key
                    value = new byte[][] {new byte[]{1}, new byte[]{3}, new byte[]{5}};      //just random data

                    hrArray = _xb.Insert(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling insert with null first key array returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling Insert with key size too long returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    if (hrArray[1] != HResult.S_FALSE) 
                    {
                        throw new HResultException(hrArray[1], "Calling Insert with key without reservation returned "+hrArray[1]+" instead of S_FALSE");                           
                    }
                    if (hrArray[2] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[2], "Calling Insert with null key returned "+hrArray[2]+" instead of E_INVALIDARG");                           
                    }

                    /**** VALUE CASES  *****/
                    key = new byte[][] {new byte[]{1}, new byte[]{2}};
                    value = new byte[2][];
                    value[0] = new byte[] {33};
                    value[1] = null;
                    hrArray = _xb.Insert(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling insert with null second value array returned unexpected HResult array");
                    }
                    if (hrArray[1] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[1], "Calling Insert with null second value array returned "+hrArray[1]+" instead of E_INVALIDARG");                           
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

             [TestCase]
          class N_Insert_Different_Value: XBancFuncTestBase
          {
                    /***** existing key, different value *****/
               override protected void Execute()
               {
                    
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);
                  
                    //put value at key with SetData
                    SetData(key,value,0,0);
                    
                    //change value
                    value = _enc.GetBytes("A different value!");
                    
                    //call insert to try to put the value in the cache
                    hr = _xb.Insert(key, value);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                         throw new HResultException(hr, "Calling Insert with existing key and different value "+hr+" instead of E_ACCESSDENIED");  
                    }    

                    hr = _xb.Insert(key, value, 0, 0);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                         throw new HResultException(hr, "Calling Insert with existing key and different value "+hr+" instead of E_ACCESSDENIED");  
                    }    
                    
                    //cleanup                    
                    Remove(key);


                    //try to do it in the same call
                    byte[][] dupKeys = new byte[][] {key, key};
                    byte[][] diffValues = new byte[][] {value, new byte[]{1,2,3}};
                    byte[][] outvalues = null;
                    uint[] dupHr;

                    //make a reservation
                    Query(dupKeys, outvalues, new uint[] {HResult.S_FALSE, HResult.S_FALSE});

                    //call insert
                    dupHr = _xb.Insert(dupKeys, diffValues, new uint[dupKeys.Length],new uint[dupKeys.Length]);
                    if (dupHr == null || dupHr.Length != 2)
                    {
                        throw new Exception("Insert did not return expected HR results");
                    }
                    if (dupHr[0] != HResult.S_OK)
                    {
                        throw new HResultException(dupHr[0], "Insert returned "+dupHr[0]+" instead of S_OK");
                    }
                    if (dupHr[1] != HResult.E_ACCESSDENIED)
                    {
                        throw new HResultException(dupHr[1], "Insert returned "+dupHr[1]+" instead of E_ACCESSDENIED");
                    }

                     //cleanup                    
                    Remove(dupKeys);
                    
                  
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }
         
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncIncrement.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;
using xonline.common.diagnostics;


namespace XBANCTest
{
     public class XBancFuncIncrement : TestNode
     {

          [TestCase]
          class P_Mainline : XBancFuncTestBase
          {
                 /***** valid key, valid value *****/
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
 
                    CreateKeyAmountPair(out key, out amount);
                    /***** valid non-existent key, valid amount *****/
                    Increment(key, amount);
                   
                     // increment an existing key (relies on the top part running first)
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                    //remove for cleanup
                    Remove(key);

                     //Insert [][] overload
                    byte[][] key2 = null;
                    ulong[] amount2 = null;
                    ulong[] expectedAmount = null;
                    uint[] expectedHR = null;
                    
                    
                    CreateKeyAmountArrayPair(out key2, out amount2);

                    Increment(key2, amount2);
                    
                    expectedAmount = new ulong[key2.Length];
                    expectedHR = new uint[key2.Length];
                    for(int i=0; i<expectedAmount.Length; i++)
                    {
                        expectedAmount[i] = amount2[i] * 2;
                        expectedHR[i] = HResult.S_OK;
                    }
                    Increment(key2, amount2, expectedAmount, expectedHR);
                    
                     //cleanup
                    Remove(key2);
                    
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
           
          [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Keys_EdgeCase : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                     //pass in key size = 128
                     CreateKeyAmountPair(out key, out amount);
                     //create key
                     key = CreateKey(128);
                  
                    Increment(key, amount);

                    Remove(key);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
           class P_KeyArray_EdgeCases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hr;
                    ulong[] results = null;
                    byte[][] key = new byte[2][];
                    key[0] = new byte[] {34};
                    key[1] = null;
                    ulong[] amount = new ulong[2]; //just some random data
                    amount[0] = 25;
                    amount[1] = 45;
                    
                    hr = _xb.Increment(key, amount, out results);
                    if (hr == null || hr.Length != 2)
                    {
                        throw new Exception("Increment did not return expected HR results");
                    }
                    if (hr[0] != HResult.S_FALSE)
                    {
                        throw new HResultException(hr[0], "Increment returned "+hr[0]+" instead of S_FALSE");
                    }
                    if (hr[1] != HResult.E_INVALIDARG)
                    {
                        throw new HResultException(hr[1], "Increment returned "+hr[1]+" instead of E_INVALIDARG");
                    }

                    //remove for cleanup
                    Remove(key[0]);

                    key = new byte[100][];
                    amount = new ulong[100];
                    for(int i=0; i<key.Length; i++)
                    {
                        key[i] = CreateKey();
                        amount[i] = (ulong) _random.Next(1,10000);
                    }

                    Increment(key, amount);

                    //remove for cleanup
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

          [TestCase, Description("Call increment with amount edge cases")]
          
          class P_Amount_EdgeCases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    ResultCode = TEST_RESULTS.PASSED;
                    byte[] key = CreateKey();
                    ulong amount = 0;

                    amount = 0;
                    /**** valid key, ZERO amount *****/
                    Increment(key, amount);
                    Increment(key, amount, amount, HResult.S_OK);
                  
                    //remove for cleanup
                     Remove(key);

                     /**** valid key, MAX_ULONG  amount *****/
                     amount = _maxULong;
                     Increment(key, amount);
                    
                    //increment an amount that is MAX_ULONG. xbanc will cap it at 
                    //MAX_LONG.
                    amount = 100;
                    ulong expected = 0x7FFFFFFFFFFFFFFF;
                    Increment(key, amount, expected, HResult.S_OK);

                    //remove for cleanup
                    Remove(key);

                    //PASS IN amount = 0 of known value to see if we get known value back
                    CreateKeyAmountPair(out key, out amount);
                    Increment(key, amount);
                   
                    Increment(key, 0, amount, HResult.S_OK);

                    Remove(key);

                    //Pass in initial amount of 0 and see if we can decay it
                    CreateKeyAmountPair(out key, out amount);
                    amount = 0;
                    //insert new amount
                     Increment(key, amount);
                    
                      //sleep one second for decay purposes
                    new SleepInfo("Sleep 1 second for decay",1*1000);
                  
                    //try to decay it!should still be zero
                     Increment(key, amount, 1, amount, HResult.S_OK);

                    //remove for cleanup
                     Remove(key);
               }
          }

          [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_Reservation : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    //try to increment a reservation
                    CreateKeyAmountPair(out key,out amount);

                    //make the reservation
                    Query(key, null, HResult.S_FALSE);

                    //try to increment it, it should pass!
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);

                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
                
               }
          }

            [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_ExpiredReservation : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    CreateKeyAmountPair(out key,out amount);
                    //make the reservation

                    Query(key, null, HResult.S_FALSE);
                  
                    //wait 60 seconds for reservation to Expire
                    new SleepInfo("Waiting for reservation to expire",61*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

        

           [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_OverwriteExpiredIncrement : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    CreateKeyAmountPair(out key,out amount);

                     Increment(key, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, 3, 0, amount, HResult.S_FALSE);
                  
                    //wait 3 seconds for increment to Expire
                    new SleepInfo("Waiting for reservation to expire",3*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_OverwriteExpiredValue : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null, value = null;
                    ulong amount = 0;
                    CreateKeyValuePair(out key, out value);
                    CreateKeyAmountPair(out key,out amount);

                     SetData(key, value, 0, 3);
                  
                    //wait 3 seconds for set data to Expire
                    new SleepInfo("Waiting for reservation to expire",3*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Positive basic cases, incrementing a reservation, expired reservation")]
          
          class P_Increment_OverwriteDifferentExpiry : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null, value = null;
                    ulong amount = 0, result =0;
                    CreateKeyValuePair(out key, out value);
                    CreateKeyAmountPair(out key,out amount);

                     
                    // *******  verify increment expires 10 seconds after insertion **********
                    Increment(key, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE,3,0, amount, HResult.S_FALSE);
                    
                      //increment value again, with different expiry.
                     hr = _xb.Increment(key, 5876, 100000, 60, 0, out result); //5876, 100000: just some random stuff.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Incrementing value 5 seconds after initial increment returned "+hr+" instead of S_OK.");
                     } //we won't check the returned results. decay cases verify this.

                     //wait 3 seconds for set data to Expire
                     new SleepInfo("Waiting for reservation to expire",3*1000);
                     
                     Query(key, null, HResult.S_FALSE);
                     Remove(key);

                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

         

       

          [TestCase, Description("Call increment with halflife = t and halflife = 1 with random amounts")]
          
          class P_Decay_RandomAmountHalfLife: XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    long ticksPerSecond = 10000000;
                    
                     //Pass in random amount of decay it
                     byte[] secondKey = null;
                     ulong secondAmount = 0;
                     
                    CreateKeyAmountPair(out key, out amount);
                    CreateKeyAmountPair(out secondKey, out secondAmount);
                    //insert new amount
                     Increment(key, amount);
                    
                    //insert new amount
                     Increment(secondKey, secondAmount);
                     
                    DateTime now = DateTime.Now;
                    //wait 60 seconds for decaying purposes
                    new SleepInfo("Waiting 30 seconds to decay", 30*1000);
                    DateTime then = DateTime.Now;
                    
                    long secondsPassed = (then.Ticks - now.Ticks)/ticksPerSecond;

                    //try to decay these
                    Increment(key, 0, (uint) secondsPassed, (ulong) amount/2,HResult.S_OK);
                     //halflife = 1 second, results should be halved secondsPassed times
                        // n0 * 1/2^60
                    Increment(secondKey,0, 1, (ulong) ((double) secondAmount /Math.Pow(2, (uint)secondsPassed) ), HResult.S_OK);
                     
                    //remove for cleanup
                    Remove(key);
                    Remove(secondKey);

                    ResultCode = TEST_RESULTS.PASSED;

               }
          }

                     [TestCase, Description("Create a new increment value with decay")]
          
          class P_Decay_NewIncrementValueHalfLifeCase : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    
                    //create a new key/random amount pair                    
                    CreateKeyAmountPair(out key, out amount);
                    uint decayAmount = (uint) _random.Next(1, (int)(_maxUInt/2));
                        
                    //increment and decay a new value
                    Increment(key, amount, decayAmount, amount, HResult.S_FALSE);

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }


          [TestCase, Description("Call increment with MAX_UINT, INFINITY, and INFINITY - 1 half life values")]
          
          class P_Decay_MaxUIntandInfinityHalfLifeCase : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null, secondKey = null, thirdKey = null;
                    ulong amount = 0, secondAmount = 0, thirdAmount = 0;
                    long ticksPerSecond = 10000000;
                    
                    CreateKeyAmountPair(out key, out amount);
                    CreateKeyAmountPair(out secondKey, out secondAmount);
                    CreateKeyAmountPair(out thirdKey, out thirdAmount);
                                 
                    /**** valid key, halflife = MAX_UINT*****/

                    //create a new key/random amount pair
                    Increment(key, amount);
                    

                    //create second key/random value pair
                    Increment(secondKey, secondAmount);
                     

                     //create third key/random value pair
                    Increment(thirdKey, thirdAmount);
                     
                    //do my own time keeping, the sleepinfo wait is NOT reliable.
                    DateTime now = DateTime.Now;
                    //wait 30 seconds for decay purposes
                    new SleepInfo("Waiting 30 seconds for decay", 30*1000);
                    
                    //try to decay with halflife = maxuint, there should be no decay (gigantic halflife)
                    Increment(key, 0, _maxUInt, amount, HResult.S_OK);
                     

                     //try to decay with halflife = XBANC_INCREMENT_HALFLIFE_INFINITE
                    Increment(secondKey, 0, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, secondAmount, HResult.S_OK);

                    //try to decay with halflife = XBANC_INCREMENT_HALFLIFE_INFINITE - 1
                    DateTime then = DateTime.Now;
                    long secondsPassed = (then.Ticks - now.Ticks)/ticksPerSecond;

                    //we'll leave some increment in the call
                    
                    //calculate the result: N(t) = N0 * e ^(lamda * t)
                    double lamda = Math.Log(2.0, Math.E) / (double)(XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE - 1);
                    ulong newAmount = (ulong) (thirdAmount * Math.Pow(Math.E, -(lamda*secondsPassed)) + thirdAmount);
                    Increment(thirdKey, thirdAmount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE - 1, newAmount, HResult.S_OK);
                                     
                    //remove for cleanup
                    Remove(key);
                    Remove(secondKey);
                    Remove(thirdKey);    

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Decay one increment value multiple times with the same half life")]
          class P_Decay_MultipleSameHalfLifeCase : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    long ticksPerSecond = 10000000;
                    
                    CreateKeyAmountPair(out key, out amount);
                                 
                    /**** valid key, halflife = 10*****/

                    //create a new key/random amount pair
                    Increment(key, amount);
                    

                    //do my own time estimation!
                    DateTime now = DateTime.Now;

                    //with halflife seconds 10, lamda = ln(2)/10 = 6.9315
                    double lamda = Math.Log(2.0, Math.E) / (double)(10);
                    //N(t) = N0 * e ^ -(lamda * t)
                    double newAmount = amount;
                    for(int i=0; i<5; i++)
                    {
                        now = DateTime.Now;
                        //wait 5 seconds for decay purposes
                        new SleepInfo("Waiting 5 seconds for decay", 5*1000);
                        //do my own time estimation
                        DateTime then = DateTime.Now;
                        double secondsPassed = (then.Ticks - now.Ticks)/ticksPerSecond;
                        //compute new amount, every 5 seconds with halflife 10
                        newAmount = ( newAmount * Math.Pow(Math.E,-(lamda*secondsPassed))) + 15;
                        //try to decay with halflife = 10 
                        Increment(key, 15, 10, (ulong)newAmount, HResult.S_OK); //increment each time by 15 
                    }

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Decay one increment value multiple times with different half lives")]
          class P_Decay_MultipleDifferentHalfLifeCase : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    long ticksPerSecond = 10000000;
                    
                    CreateKeyAmountPair(out key, out amount);
                                 
                    /**** valid key, halflife = different*****/

                    //create a new key/random amount pair
                    Increment(key, amount);
                    
                    //do my own time estimation!
                    DateTime now = DateTime.Now;

                    //with halflife seconds 10, lamda = ln(2)/10 = 6.9315

                    //N(t) = N0 * e ^ -(lamda * t)
                    double newAmount = amount;
                    for(int i=0; i<5; i++)
                    {
                        //this time we'll do random halflifes and increments, yay.
                        uint randHalfLife = (uint)_random.Next(1,2147483647); 
                        ulong randAmount = (ulong)_random.Next(0,2147483647);
                        
                        now = DateTime.Now;
                        //wait 5 seconds for decay purposes
                        new SleepInfo("Waiting 5 seconds for decay", 5*1000);
                        //do my own time estimation
                        DateTime then = DateTime.Now;
                        double secondsPassed = (then.Ticks - now.Ticks)/ticksPerSecond;
                        //compute new amount, every 5 seconds 
                        newAmount = randAmount + newAmount * Math.Pow(2, -secondsPassed / (double)randHalfLife);
                        //try to decay with different halflifes

                        Increment(key, randAmount, randHalfLife, (ulong)newAmount, HResult.S_OK); 
                         
                    }

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Verify decay with constant half life (10) while simulating periodic increments (1 tps)")]
          class P_Decay_ConstantIncrements_LowTps : XBancFuncTestBase
          {
               override protected void Execute()
               {
                   RunIncrementWithDelayTps(10, 1, 10);
               }
          }

          [TestCase, Description("Verify decay with constant half life (10) while simulating periodic increments (10 tps)")]
          class P_Decay_ConstantIncrements_HighTps : XBancFuncTestBase
          {
               override protected void Execute()
               {
                   RunIncrementWithDelayTps(10, 10, 10);
               }
          }

          [TestCase, Description("Verify decay with constant half life (2) while simulating periodic increments (20 tps)")]
          class P_Decay_ConstantIncrements_HigherTps : XBancFuncTestBase
          {
               override protected void Execute()
               {
                   RunIncrementWithDelayTps(2, 20, 10);
               }
          }

          [TestCase, Description("Verify decay with constant half life (60) while simulating periodic increments (20 tps)")]
          class P_Decay_ConstantIncrements_HigherTpsBigHalflife : XBancFuncTestBase
          {
               override protected void Execute()
               {
                   RunIncrementWithDelayTps(60, 20, 10);
               }
          }

           [TestCase]
          
          class P_Expiry_Absolute_Main : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    CreateKeyAmountPair(out key,out amount);

                     Increment(key, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, 3, 0, amount, HResult.S_FALSE);
                  
                    //wait 3 seconds for increment to Expire
                    new SleepInfo("Waiting for reservation to expire",3*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class P_Expiry_Absolute_DespiteInsertIncrementQuery : XBancFuncTestBase
          {

                override protected void Execute()
               {
                    
                    uint hr;
                    byte[] absoluteKey = null;
                    ulong amount = 0, result = 0;                    
                  
                     //create absolute key, one value
                    CreateKeyAmountPair(out absoluteKey, out amount);
          
                    // *******  verify value expires 30 seconds after insertion despite multiple increments, queries, and inserts **********
                    CreateKeyAmountPair(out absoluteKey, out amount);
                    Increment(absoluteKey, amount, 1, 30, 0, amount, HResult.S_FALSE);
                      //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);

                     //try to insert some value again
                     byte[] value = new byte[] {5,10,15,20};
                     hr = _xb.Insert(absoluteKey, value);
                     if (hr != HResult.E_ACCESSDENIED)
                     {
                          throw new HResultException(hr, "Inserting value on top of increment value 5 seconds after increment returned "+hr+" instead of E_ACCESSDENIED.");
                     }

                     //increment value
                     Increment(absoluteKey, 5876, amount + 5876, HResult.S_OK); //5876 is just some random stuff.
                     
                     //query for the key to get S_OK
                     Query(absoluteKey, null, HResult.S_OK);

                     //increment value again, with different expiry.
                     hr = _xb.Increment(absoluteKey, 5876, 100000, 60, 0, out result); //5876, 100000: just some random stuff.
                     if (hr != HResult.S_OK)
                     {
                         throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK");
                     } //we won't check the returned results. decay cases verify this.
                    
                     //sleep for 25 seocnds, incrememnt value should expire.
                     new SleepInfo("Wait 25 seconds.", 25 * 1000);
                   
                     //try to increment the key to also get S_FALSE
                     Increment(absoluteKey, amount);

                    //remove key for cleanup
                    Remove(absoluteKey);

                    ResultCode = TEST_RESULTS.PASSED;

                   }
          }


           [TestCase]
          
          class P_Expiry_Sliding_Main : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;

                    CreateKeyAmountPair(out key,out amount);

                     Increment(key, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, 0, 3, amount, HResult.S_FALSE);
                  
                    //wait 3 seconds for increment to Expire
                    new SleepInfo("Waiting for reservation to expire",3*1000);
                    
                    //create a increment value on it
                    Increment(key, amount);
                    Increment(key, amount, amount * 2, HResult.S_OK);
                    
                     //remove for cleanup
                     Remove(key);
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }


          

             [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_DespiteInsert : XBancFuncTestBase
          {

                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0;                    
                    
                    CreateKeyAmountPair(out slidingKey, out amount);

                    // *******  verify value expires 30 seconds after insertion despite multiple increments, queries, and inserts **********
                    Increment(slidingKey, amount, 1, 0, 10, amount, HResult.S_FALSE);
                   
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     
                     //try to insert some value again
                     byte[] value = new byte[] {5,10,15,20};
                     hr = _xb.Insert(slidingKey, value);
                     if (hr != HResult.E_ACCESSDENIED)
                     {
                          throw new HResultException(hr, "Inserting value on top of increment value 5 seconds after increment returned "+hr+" instead of E_ACCESSDENIED.");
                     }

                     //sleep for 5 more seocnds
                     new SleepInfo("Wait 5 more seconds.", 5 * 1000);

                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);
                                      
                    //remove key for cleanup
                    Remove(slidingKey);

                    ResultCode = TEST_RESULTS.PASSED;
                }
             }

                [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_DespiteMultipleIncrements : XBancFuncTestBase
          {
                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0, result = 0;                    

                    // *******  verify value expires 30 seconds after insertion despite multiple increments, queries, and inserts **********
                    CreateKeyAmountPair(out slidingKey, out amount);
                    Increment(slidingKey, amount, 1, 0, 10, amount, HResult.S_FALSE);
                    
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     
                    //try to increment the key to increase sliding expiration
                      hr = _xb.Increment(slidingKey, amount, 1000, out result); //random decay... not going to check it.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     }
                     
                      //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                      
                    //try to increment the key to increase sliding expiration
                      hr = _xb.Increment(slidingKey, amount, 1000, out result); //random decay... not going to check it.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     }
                     //sleep for 10 seocnds for expiry
                     new SleepInfo("Wait 10 seconds for expiry", 10 * 1000);

                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);

                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                }
           }

                  [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_DespiteMultipleIncrementsDiffExpiry : XBancFuncTestBase
          {

                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0, result = 0;                    
                  

                       _report.Debug("Starting value expires 10 seconds after last Increment with different expiry values.");
                    // *******  verify value expires 30 seconds after insertion despite multiple increments, queries, and inserts **********
                    CreateKeyAmountPair(out slidingKey, out amount);
                    Increment(slidingKey, amount, 1, 0, 10, amount, HResult.S_FALSE);
                   
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     
                    //try to increment the key to increase sliding expiration
                      hr = _xb.Increment(slidingKey, amount, 1000, 100, 0, out result); //random decay... not going to check it.
                     if (hr != HResult.S_OK)
                     {
                         throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     }
                     
                      //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                      
                    //try to increment the key to increase sliding expiration
                      hr = _xb.Increment(slidingKey, amount, 1000, 0, 100, out result); //random decay... not going to check it.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     }
                     //sleep for 10 seocnds for expiry
                     new SleepInfo("Wait 10 seconds for expiry", 10 * 1000);

                     //try to increment the key to also get s_false
                      Increment(slidingKey, amount);
                   
                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }

                    [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_DespiteMultipleQueries : XBancFuncTestBase
          {
                override protected void Execute()
               {
                    byte[] slidingKey = null;
                    ulong amount = 0 ;                    
                  
                    CreateKeyAmountPair(out slidingKey, out amount);
                     Increment(slidingKey, amount, 1, 0, 10, amount, HResult.S_FALSE);
                    
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     //Query for key to increase sliding expiration
                     Query(slidingKey,null, HResult.S_OK);
                     
                      //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     //Query for key to increase sliding expiration
                     Query(slidingKey,null, HResult.S_OK);
                     
                     //sleep for 10 seocnds for expiry
                     new SleepInfo("Wait 10 seconds for expiry", 10 * 1000);

                     //try to increment the key to also get s_false
                      Increment(slidingKey, amount);
                      
                    //remove key for cleanup
                    Remove(slidingKey);
                     ResultCode = TEST_RESULTS.PASSED;
                }
          }

           [TestCase, Description("Test sliding expiration with multiple Query, Insert, and Increment calls")]
          class P_Expiry_Sliding_Remove : XBancFuncTestBase
          {
                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0, result = 0;   
                    
                    CreateKeyAmountPair(out slidingKey, out amount);                    
                  
                    Increment(slidingKey, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE,0,10, amount, HResult.S_FALSE);
                    
                      //increment value again, with different expiry.
                     hr = _xb.Increment(slidingKey, 5876, 100000, 60, 0, out result); //5876, 100000: just some random stuff.
                     if (hr != HResult.S_OK)
                     {
                           throw new HResultException(hr, "Increment returned "+hr+" instead of S_OK.");
                     } //we won't check the returned results. decay cases verify this.

                      Remove(slidingKey);
                    
                     //try to increment the key to also get s_false
                      Increment(slidingKey, amount);
                      
                    //remove key for cleanup
                     Remove(slidingKey);
                     ResultCode = TEST_RESULTS.PASSED;
                }
          }

                [TestCase, Description("AbsoluteSeconds = 15, slidingSeconds = 10")]
          class P_Expiry_Both_Abs5Slid10 : XBancFuncTestBase
          {

                override protected void Execute()
               {
                    byte[] slidingKey = null;
                    ulong amount = 0;                    
                    
                     //create sliding and absolute keys, one value
                    CreateKeyAmountPair(out slidingKey, out amount);
          
                    //valid key, valid value, 10 seconds sliding expiration          

                    _report.Debug("Starting value expires 5 seconds after insertion test with 10 second sliding expiry.");
                    // *******  verify increment expires 10 seconds after insertion **********
                    Increment(slidingKey, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE,5,10, amount, HResult.S_FALSE);
                    
                     //sleep for 5 seocnds, value should expire
                     new SleepInfo("Wait 5 seconds for increment to expire", 5 * 1000);
                    
                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);

                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }

                     [TestCase, Description("AbsoluteSeconds = 15, slidingSeconds = 10")]
          class P_Expiry_Both_Abs10Slid5 : XBancFuncTestBase
          {

                override protected void Execute()
               {
                    byte[] slidingKey = null;
                    ulong amount = 0;                    
                  
                     //create sliding and absolute keys, one value
                    CreateKeyAmountPair(out slidingKey, out amount);
          
                    Increment(slidingKey, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE,10,5, amount, HResult.S_FALSE);
                    
                     //sleep for 5 seocnds, value should expire
                     new SleepInfo("Wait 5 seconds for increment to expire", 5 * 1000);
                    
                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);
                  
                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }
          

             [TestCase, Description("AbsoluteSeconds = 15, slidingSeconds = 10")]
          class P_Expiry_Both_DespiteInsertIncrementQuery : XBancFuncTestBase
          {

                override protected void Execute()
               {
                    uint hr;
                    byte[] slidingKey = null;
                    ulong amount = 0, result = 0;                    
                  
                    CreateKeyAmountPair(out slidingKey, out amount);
                    Increment(slidingKey, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, 15, 10, amount, HResult.S_FALSE);
                     //sleep for 5 seocnds
                     new SleepInfo("Wait 5 seconds.", 5 * 1000);
                     
                     //try to insert some value again
                     byte[] rgbValue = new byte[] {5,10,15,20};
                     
                     //increment value again, with different expiry.
                     hr = _xb.Increment(slidingKey, 5876, 100000, 60, 0, out result); //5876, 100000, 60: just some random stuff.
                     if (hr != HResult.S_OK)
                     {
                          throw new HResultException(hr, "Increment returned "+hr+" instead of E_ACCESSDENIED.");
                     } //we won't check the returned results. decay cases verify this.

                     //sleep for 5 more seocnds
                     new SleepInfo("Wait 5 more seconds.", 5 * 1000);

                     //Query for key to increase sliding expiration
                      Query(slidingKey, null, HResult.S_OK); 

                      //sleep for 5 seocnds, value should expire
                     new SleepInfo("Wait 5 seconds for expiry", 5 * 1000);

                     //try to increment the key to also get s_false
                     Increment(slidingKey, amount);

                    //remove key for cleanup
                    Remove(slidingKey);
                    ResultCode = TEST_RESULTS.PASSED;
                  }
          }

          [TestCase, Description("Create new increment value over a reservation, setData over an increment value")]
          class P_Integration_Query : XBancFuncTestBase
          {

                 override protected void Execute()
               {
                   
                    uint hr;
                    byte[] key = null, outValue = null;
                    ulong amount = 0;
                    
                    //create a new key/random amount pair                    
                    CreateKeyAmountPair(out key, out amount);
                    uint decayAmount = (uint) _random.Next(1, (int)(_maxUInt/2));
                    //place a reservation at the key
                    Query(key, null, HResult.S_FALSE);
                    
                    //increment and decay a new value OVER A RESERVATION
                    Increment(key, amount, decayAmount, amount, HResult.S_FALSE);
                  
                    //query for the increment key, check if we get the value back
                    hr = _xb.Query(key, out outValue);
                    if (hr != HResult.S_OK)
                    {
                        throw new HResultException(hr, "Query returned "+hr+" instead of S_OK");
                    }
                     //the returned value should be the amount.
                    ulong returnedValue = (ulong) BitConverter.ToUInt64(outValue,0);
                    ValidateReturnedData(amount, returnedValue);

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }

               [TestCase, Description("Create new increment value over a reservation, setData over an increment value")]
          class P_Integration_SetData : XBancFuncTestBase
          {

                 override protected void Execute()
               {
                    byte[] key = null;
                    ulong amount = 0;
                    
                    //create a new key/random amount pair                    
                    CreateKeyAmountPair(out key, out amount);
                    uint decayAmount = (uint) _random.Next(1, (int)(_maxUInt/2));
                   
                    //increment and decay a new value 
                    Increment(key, amount, decayAmount, amount, HResult.S_FALSE);
                  
                    //call setdata to overwrite increment value
                    byte[] newValue = new byte[] {1,2,3,4,5,6,7,8}; //just some random value;
                    SetData(key, newValue, 0,0);

                    //remove for cleanup
                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }
                    [TestCase, Description("Create an increment value over removed increment values")]
          class P_Integration_Remove: XBancFuncTestBase
          {

                 override protected void Execute()
               {
                    ResultCode = TEST_RESULTS.PASSED;
                    byte[] key = null;
                    ulong amount = 0;
                    
                    //create a new key/random amount pair                    
                    CreateKeyAmountPair(out key, out amount);
                    uint decayAmount = (uint) _random.Next(1, (int)(_maxUInt/2));
                        
                    //increment and decay a new value
                    Increment(key, amount, decayAmount, amount, HResult.S_FALSE);

                    //remove the key by prefix.
                    byte[] prefix = new byte[key.Length - 1];
                    Array.Copy(key,0,prefix,0,key.Length - 1);

                    Remove(prefix,false);

                    //call increment on this removed value again
                    //increment and decay a new value
                   Increment(key, amount, decayAmount, amount, HResult.S_FALSE);
                    
                    //remove the key exactly
                    Remove(key);

                     //call increment on this removed value again
                    //increment and decay a new value
                     Increment(key, amount, decayAmount, amount, HResult.S_FALSE);

                     //remove key for cleanup
                      Remove(key);
               }
          }
                    
          [TestCase]
          class N_Parameter_Null_Cases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    ulong result;
                    uint[] hrArray;
                    byte[][] keyArray = new byte[1][];
                    byte[][] keyNull = null;
                    ulong[] amountArray = new ulong[] {1};
                    ulong[] amountNull = null;
                    uint[] halfLives = new uint[] {1};
                    uint[] halfLivesNull = null;
                    uint[] expiryNull = null;
                    ulong[] results = null;
                    keyArray[0] = new byte[] {1};
                    
                     hr = _xb.Increment(null,1, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                      hr = _xb.Increment(null,1,1, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                           
                     }
                     
                     hr = _xb.Increment(null,1,1, 0,0, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                           
                     }

                     hrArray = _xb.Increment(keyNull, amountArray, halfLives, new uint[amountArray.Length],new uint[amountArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null key array returned unexpected HResult array");
                     }
                     
                     hrArray = _xb.Increment(keyArray, amountNull, halfLives, new uint[keyArray.Length],new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null amount array returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLivesNull, new uint[keyArray.Length],new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null half life array returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLives, expiryNull ,new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null absolute returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLives, new uint[keyArray.Length], expiryNull, out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with null sliding expiry returned unexpected HResult array");
                     }


                     
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_Parameter_Empty_Cases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray;
                    ulong result;
                    byte[][] keyArray = new byte[1][];
                    byte[][] keyEmpty = new byte[0][];
                    ulong[] amountArray = new ulong[] {1};
                    ulong[] amountEmpty = new ulong[0];
                    uint[] halfLives = new uint[] {1};
                    uint[] halfLivesEmpty = new uint[0];
                    uint[] expiryEmpty = new uint[0];
                    ulong[] results = null;
                    keyArray[0] = new byte[] {1};
                    
                    hr = _xb.Increment(new byte[0],1, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                      hr = _xb.Increment(new byte[0],1,1, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                           
                     }

                     hr = _xb.Increment(new byte[0],1,1,0,0, out result);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                           
                     }


                     hrArray = _xb.Increment(keyEmpty, amountArray, halfLives, new uint[amountArray.Length],new uint[amountArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty key array returned unexpected HResult array");
                     }
                     
                     hrArray = _xb.Increment(keyArray, amountEmpty, halfLives, new uint[keyArray.Length],new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty amount array returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLivesEmpty, new uint[keyArray.Length],new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty half life array returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLives, expiryEmpty ,new uint[keyArray.Length], out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty absolute returned unexpected HResult array");
                     }

                     hrArray = _xb.Increment(keyArray, amountArray, halfLives, new uint[keyArray.Length], expiryEmpty, out results);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling increment with empty sliding expiry returned unexpected HResult array");
                     }


                     
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }
               [TestCase]
          class N_Parameter_ZeroHalfLife : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] key;
                    ulong amount, result;
                    
                    CreateKeyAmountPair(out key, out amount);

                    hr = _xb.Increment(key, amount, 0, out result);
                     if (hr != HResult.E_INVALIDARG)
                    {
                         throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                     
                    }

                    hr = _xb.Increment(key, amount, 0, 0, 0, out result);
                     if (hr != HResult.E_INVALIDARG)
                    {
                         throw new HResultException(hr, "Calling Increment with null key returned "+hr+" instead of E_INVALIDARG");                     
                    }
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Key_SizeTooLong : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    ulong result;
                    
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    byte[] keyTooLong =  CreateKey(_maxKeyLength + 1);

                     hr = _xb.Increment(keyTooLong, 1, out result);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Increment with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                    hr = _xb.Increment(keyTooLong, 1, 1, out result);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Increment with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }
                     hr = _xb.Increment(keyTooLong, 1, 1, 0, 0, out result);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Increment with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

              [TestCase]
          class N_KeyArray_Invalid_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint[] hrArray;
                    byte[][] key = null;
                    ulong[] amountArray = new ulong[] {1};
                    uint[] halfLives = new uint[] {1};
                    ulong[] results = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);

                    /********* KEY CASES **************/
                    
                    //key[0] = null;
                    key = new byte[1][];
                    key[0] = null;
                    
                    hrArray = _xb.Increment(key, amountArray, halfLives, new uint[key.Length], new uint[key.Length], out results);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling Increment with null key first value returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling Insert with null key first value returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    
                    //key[0] = invalid key, key[1] = valid key, key[2] = invalid key
                    key = new byte[3][];
                    key[0] = new byte[_maxKeyLength + 1];   //key size too long
                    key[1] = new byte[]{2,3,4,5};                   //increment
                    key[2] = null;                                          //null key
                    amountArray = new ulong[] {1, 3, 5};      //just random data
                    halfLives = new uint[] {4, 5, 6};      //just random data

                    hrArray = _xb.Increment(key, amountArray, halfLives, new uint[key.Length], new uint[key.Length], out results);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling insert with null first key array returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling Insert with key size too long returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    if (hrArray[1] != HResult.S_FALSE) 
                    {
                        throw new HResultException(hrArray[1], "Calling Insert with key without reservation returned "+hrArray[1]+" instead of S_FALSE");                           
                    }
                    if (hrArray[2] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[2], "Calling Insert with null key returned "+hrArray[2]+" instead of E_INVALIDARG");                           
                    }
                    if (results == null || results[1] != amountArray[1])
                    {
                        throw new Exception("Calling Increment with two invalid keys and one valid key returned "+((results.Length == 3)?results[1].ToString():"null")+" instead of "+amountArray[1]);       
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

             [TestCase]
          class N_Increment_NonIncrementValue_Small : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    ulong amount = 0, result = 0;
                    
                     // increment a nonincrementable value sized < the incrementable value size
                    byte[] value = new byte[_random.Next(1,(int) _incrementValueSize)];
                    _random.NextBytes(value);
                    CreateKeyAmountPair(out key,out amount);
                    
                     //insert value sized < incrementable value size
                    SetData(key,value,0,0);
                    
                    //try to increment the value
                    hr = _xb.Increment(key,amount,out result);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                       throw new HResultException(hr, "Increment returned "+hr+" instead of E_ACCESSDENIED");
                    }
                    
                    //query to make sure nothing went wrong
                    Query(key,value, HResult.S_OK);

                    Remove(key);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Increment_NonIncrementValue_Same : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    ulong amount = 0, result = 0;

                    // increment a nonincrementable value sized == the incrementable value
                    //insert value sized == incrementable value size
                    
                    byte[] value = new byte[_incrementValueSize];
                    _random.NextBytes(value);
                    CreateKeyAmountPair(out key, out amount);
                    
                    SetData(key,value,0,0);
                    
                    //try to increment the value
                    hr = _xb.Increment(key,amount,out result);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                       throw new HResultException(hr, "Increment returned "+hr+" instead of E_ACCESSDENIED");
                    }
                    
                    //query to make sure nothing went wrong
                    Query(key,value, HResult.S_OK);
                    Remove(key);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
          class N_Increment_NonIncrementValue_Large : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    ulong amount = 0, result = 0;

                    // increment a nonincrementable value sized == the incrementable value
                    //insert value sized == incrementable value size
                    
                    byte[] value = new byte[_random.Next((int) _incrementValueSize+1,(int) _incrementValueSize+1025)];
                    _random.NextBytes(value);
                    CreateKeyAmountPair(out key, out amount);
                    
                    SetData(key,value,0,0);
                    
                    //try to increment the value
                    hr = _xb.Increment(key,amount,out result);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                       throw new HResultException(hr, "Increment returned "+hr+" instead of E_ACCESSDENIED");
                    }
                    
                    //query to make sure nothing went wrong
                    Query(key,value, HResult.S_OK);
                    Remove(key);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncMRU.cs ===
using System;
using System.Diagnostics;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace XBANCTest
{
    [TestGroup, EnvRequirement("Xblobonly")]
     public class XBancFuncMRU : TestNode
     {
        private static uint beginningTotalBytes = 0;
        private static uint lowWaterMark = 0;
        private static uint highWaterMark = 0;
        private static uint bucketNum = 20;
        private static uint? oldLowWaterMark;
        private static uint? oldHighWaterMark;
           
          public override void PreRun()
          {
                //read the total bytes
                //read the low water mark, high water mark
                //adjust the low water mark, high water mark
                //add the tear down delegate
                Report _report = new Report("Log");
                _report.Debug("Removing ALL entries from XBanc");
                XBanc xb = new XBanc();
                //remove all!
                for(int i=0; i<256; i++)
                {
                     byte[] key = {(byte)i};
                     xb.Remove(key, false);
                }
                _report.Debug("Waiting for XBanc to remove ALL entries");
                //wait 30 seconds.
                new SleepInfo("wait 30 seconds for remove to complete", 30*1000);
                 for(int i=0; i<256; i++)
                {
                     byte[] key = {(byte)i};
                     xb.Remove(key, false);
                }

                //get perfcounters to verify
                
                IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucketNum);
                PerformanceCounter XBancTotalBytes = new PerformanceCounter("Xbox Live XBanc Data", "Total bytes", "_Total_", b.CurrentServerName);
                beginningTotalBytes = (uint) XBancTotalBytes.NextValue();
                //determine what to set the low and high counters to
                if (beginningTotalBytes < 2000)
                    lowWaterMark = 10000;
                else
                    lowWaterMark = beginningTotalBytes + 8000;
                highWaterMark = lowWaterMark+5000;

                //get the old values of the low and high water marks.
                oldLowWaterMark = Config.GetUIntSetting(Setting.xbanc_low_water_data_storage_bytes);
                oldHighWaterMark = Config.GetUIntSetting(Setting.xbanc_total_data_storage_bytes);

                //set the new values 
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.xbanc_low_water_data_storage_bytes, lowWaterMark.ToString());
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.xbanc_total_data_storage_bytes, highWaterMark.ToString());

                //wait two minutes for the settings to take hold
                _report.Debug("Waiting for XBanc to pickup the settings change");
                new SleepInfo("wait for XBanc to pickup change", 100*1000);
                

                
          }

          public override void PostRun()
          {
              Report _report = new Report( "Log" );
              _report.Warn( "DESTRUCT!!!" );
              //set the old values back

              if ( oldLowWaterMark.HasValue )
              {
                  Global.XEnv.OverrideSetting( "ALL", "ALL", Setting.xbanc_low_water_data_storage_bytes, oldLowWaterMark.Value.ToString() );
              }

              if ( oldHighWaterMark.HasValue )
              {
                  Global.XEnv.OverrideSetting( "ALL", "ALL", Setting.xbanc_total_data_storage_bytes, oldHighWaterMark.Value.ToString() );
              }

              //wait two minutes for the settings to take hold
              _report.Debug( "Waiting for XBanc to pickup the settings change" );
              new SleepInfo( "wait for XBanc to pickup change", 100 * 1000 );
          }        

    
    
         [TestCase, Description("Insert one value < low water mark, one > low water mark, total size > total data storage bytes")]
         
          class P_Mainline_LWM: XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint sizeLeft = lowWaterMark - beginningTotalBytes;
                    
                    uint firstValueSize = sizeLeft - 2000; 
                    uint secondValueSize = 6000;
                    //get the total value to be below the highwatermark
                    if ((beginningTotalBytes + firstValueSize + secondValueSize) > highWaterMark)
                    {
                        secondValueSize -= (beginningTotalBytes + firstValueSize + secondValueSize) - highWaterMark - 100;
                    }
                    byte[] firstKey = null;
                    byte[] firstValue = new byte[firstValueSize];
                    byte[] secondKey = null;
                    byte[] secondValue = new byte[secondValueSize];
                    //fill the values with random bits                                        
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    //we need two keys that map to the same bucket
                    byte[][] keys = CreateKeyArrayThatMapsToSameBucket(2, bucketNum);
                    if (keys == null) return;
                    
                    firstKey = keys[0];
                    secondKey = keys[1];

                    /***** insert one large value < low water mark, then insert another to set off drainage. *****/
                    
                    //insert value sized firstValueSize bytes
                    InsertSingleItem(firstKey, firstValue);

                    //insert value so that total inserted value >= 16384
                    //insert value sized secondValueSize bytes
                    InsertSingleItem(secondKey, secondValue);
                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.
                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was removed.
                    Query(firstKey, null, HResult.S_FALSE);
                    
                    //check to see if second value was NOT removed.
                    Query(secondKey, secondValue, HResult.S_OK);
                   
                     //remove it for cleanup
                    Remove(secondKey);
                    Remove(firstKey);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          [TestCase, Description("Insert one value < low water mark, one > low water mark, total size > total data storage bytes")]
         
          class P_Mainline_HWM: XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint sizeLeft = lowWaterMark - beginningTotalBytes;
                    
                    uint firstValueSize = sizeLeft - 2000; 
                    uint secondValueSize = 10000;
                    //get the total value to be below the highwatermark
                    int sizeDiff = (int)highWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        secondValueSize += (uint)sizeDiff + 100;
                    }
                     sizeDiff = (int)lowWaterMark - ((int)beginningTotalBytes + (int)secondValueSize);
                     if (sizeDiff < 0)
                     {  
                        //sizediff is negative!
                        if ((-sizeDiff + 500) > secondValueSize)
                        {
                            throw new Exception("Can not perform this test because beginningTotalBytes is too large");
                        }
                        if (beginningTotalBytes + firstValueSize + (uint)((int)secondValueSize + sizeDiff) < highWaterMark)
                        {
                            secondValueSize = (uint)((int)secondValueSize - sizeDiff - 500);
                            firstValueSize += (uint)sizeDiff + 500;
                        }
                        else
                        {
                            secondValueSize = (uint)((int)secondValueSize + sizeDiff - 500);
                        }
                     }
                    
                    byte[] firstKey = null;
                    byte[] firstValue = new byte[firstValueSize];
                    byte[] secondKey = null;
                    byte[] secondValue = new byte[secondValueSize];
                    //fill the values with random bits                                        
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    //we need two keys that map to the same bucket
                    byte[][] keys = CreateKeyArrayThatMapsToSameBucket(2, bucketNum);
                    if (keys == null) return;
                    
                    firstKey = keys[0];
                    secondKey = keys[1];

                    /***** insert one large value < low water mark, then insert another to set off drainage. *****/
                    
                    //insert value sized firstValueSize bytes
                    InsertSingleItem(firstKey, firstValue);

                    //insert value so that total inserted value >= 16384
                    //insert value sized secondValueSize bytes
                    InsertSingleItem(secondKey, secondValue);
                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.
                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was removed.
                    Query(firstKey, null, HResult.S_FALSE);
                    
                    //check to see if second value was NOT removed.
                    Query(secondKey, secondValue, HResult.S_OK);
                   
                     //remove it for cleanup
                    Remove(secondKey);
                    Remove(firstKey);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert 16 1KB values")]
         
          class P_MultipleSimple: XBancFuncTestBase
          {

               override protected void Execute()
               {
                    
                    uint hr;
                    byte[] outBytes=null;

                    //initial starting bytes
                    uint totalBytes = beginningTotalBytes;
                    uint valueSize = 3000;
                    int numValues = 16;

                    totalBytes += valueSize*(uint) numValues;
                    uint numDrained = 0;
                     //i'm too lazy to figure out the formula for this
                     while(totalBytes > lowWaterMark)
                     {
                          numDrained++;
                          totalBytes -= valueSize;
                     }

          
                    _report.Debug("Number of key/values to be drained: "+numDrained);

                    //create 1KB values, fill with random bytes
                    byte[] value = new byte[valueSize];
                    _random.NextBytes(value);
                    
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(numValues, bucketNum);
                    if (keyArray == null) return;
                    

                    /***** insert 16 1KB values, should trigger drainage. *****/
                    for(int i=0; i<numValues; i++)
                    {
                        InsertSingleItem(keyArray[i], value);
                    }

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                     _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);
              
                    for(int i=0; i<numValues; i++)
                    {
                         hr = _xb.Query(keyArray[i], out outBytes);
                         if (i < numDrained)
                         {
                              //this one should be removed
                                if (hr != HResult.S_FALSE)
                                {
                                   throw new HResultException(hr, "Querying for supposedly MRU'd out key of index "+i+" returned: "+hr);
                                }
                         }
                         else
                         {     
                              //this key should not be removed
                              ValidateReturnedData(value, outBytes);
                         }

                         //remove them all for good measure
                         Remove(keyArray[i]);
                         
                    }
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert two values, query for first, insert another to drain second value")]
          class P_QueryForFirst: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    ResultCode = TEST_RESULTS.PASSED;
                    uint firstValueSize = 500;
                    uint secondValueSize = 9000;
                    uint thirdValueSize = 1000;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize + thirdValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        thirdValueSize += (uint)sizeDiff + 100;
                    }
                    
                    byte[] firstKey = null, firstValue = new byte[firstValueSize];
                    byte[] secondKey = null, secondValue = new byte[secondValueSize];
                    byte[] thirdKey = null, thirdValue = new byte[thirdValueSize];
                    //fill the values with random bits
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    _random.NextBytes(thirdValue);

                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(3, bucketNum);
                    if (keyArray == null) return;                    
                    firstKey = keyArray[0];
                    secondKey = keyArray[1];
                    thirdKey = keyArray[2];
                    
                    /***** insert two < low_water values, query for first, insert another > low watermark to set off drainage. *****/

                    InsertSingleItem(firstKey, firstValue);
                    InsertSingleItem(secondKey, secondValue);

                    //query for the first key so that the second key will be removed instead of the first
                    Query(firstKey, firstValue, HResult.S_OK);

                    //insert third key that will trigger drainage
                    InsertSingleItem(thirdKey, thirdValue);
                  
                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 2 second for heartbeat thread to remove values// we need the deleted items from the previous test to be removed by the heartbeat proc, this takes 1.6 seconds
                    _report.Debug("Wait for 2 seconds for heartbeat to remove values");
                    new SleepInfo("Wait for 2 seconds", 2*1000);

                    //check to see if first value was NOT removed.
                    Query(firstKey, firstValue, HResult.S_OK);
                 
                    //check to see if third value was NOT removed.
                    Query(thirdKey, thirdValue, HResult.S_OK);

                    //check to see if second value was removed.
                    Query(secondKey, null, HResult.S_FALSE);
                   
                    Remove(firstKey);
                    Remove(secondKey);
                    Remove(thirdKey);
               }
          }

           [TestCase, Description("Insert two values, setdata first, insert another to drain second value")]
          class P_SetDataFirstValue: XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint firstValueSize = 1024;
                    uint secondValueSize = 2048;
                    uint thirdValueSize = 7024;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize + thirdValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        thirdValueSize += (uint)sizeDiff + 500;
                    }
                    //make sure the right things will be purged
                    sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + thirdValueSize);
                    if (sizeDiff < 0)
                    {  
                        //sizediff is negative!
                        if ((-sizeDiff + 500) > thirdValueSize)
                        {
                            throw new Exception("Can not perform this test because beginningTotalBytes is too large");
                        }
                        if (beginningTotalBytes + firstValueSize + (uint)((int)thirdValueSize + sizeDiff) < lowWaterMark)
                        {
                            thirdValueSize = (uint)((int)thirdValueSize - sizeDiff - 500);
                            firstValueSize += (uint)sizeDiff + 500;
                        }
                        else
                        {
                            thirdValueSize = (uint)((int)thirdValueSize + sizeDiff - 500);
                        }
                    }
                    
                    byte[] firstKey = {56}; 
                    byte[] firstValue = new byte[firstValueSize];
                    byte[] secondKey = {254}; 
                    byte[] secondValue = new byte[secondValueSize];
                    byte[] thirdKey = {7}; 
                    byte[] thirdValue = new byte[thirdValueSize];
                    //fill the values with random bits
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    _random.NextBytes(thirdValue);

                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(3, bucketNum);
                    if (keyArray == null) return;                    
                    firstKey = keyArray[0];
                    secondKey = keyArray[1];
                    thirdKey = keyArray[2];
                    
                    /***** insert two < low_water values, query for first, insert another > low watermark to set off drainage. *****/

                    InsertSingleItem(firstKey, firstValue);
                    InsertSingleItem(secondKey, secondValue);
                    
                    //query for the first key so that the second key will be removed instead of the first
                    SetData(firstKey, firstValue,0,0);
                    
                    //insert third key that will trigger drainage
                    InsertSingleItem(thirdKey, thirdValue);

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was NOT removed.
                    Query(firstKey, firstValue, HResult.S_OK);
                    //check to see if second value was removed.
                    Query(secondKey, null, HResult.S_FALSE);
                    //check to see if third value was NOT removed.
                    Query(thirdKey, thirdValue, HResult.S_OK);
                     //remove it for cleanup
                    Remove(firstKey);
                    Remove(secondKey);
                    Remove(thirdKey);
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

             [TestCase, Description("Insert two values, Insert first again, insert another to drain second value")]
          class P_InsertFirstAgainSameValue: XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint firstValueSize = 5000;
                    uint secondValueSize = 2000;
                    uint thirdValueSize = 2000;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize + thirdValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        thirdValueSize += (uint)sizeDiff + 500;
                    }
                    //make sure the right things will be purged
                    sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + thirdValueSize);
                    if (sizeDiff < 0)
                    {  
                        //sizediff is negative!
                        if ((-sizeDiff + 500) > thirdValueSize)
                        {
                            throw new Exception("Can not perform this test because beginningTotalBytes is too large");
                        }
                        if (beginningTotalBytes + firstValueSize + (uint)((int)thirdValueSize + sizeDiff) < lowWaterMark)
                        {
                            thirdValueSize = (uint)((int)secondValueSize - sizeDiff - 500);
                            firstValueSize += (uint)sizeDiff + 500;
                        }
                        else
                        {
                            thirdValueSize = (uint)((int)thirdValueSize + sizeDiff - 500);
                        }
                    }
                    byte[] firstKey = null, firstValue = new byte[firstValueSize];
                    byte[] secondKey = null, secondValue = new byte[secondValueSize];
                    byte[] thirdKey = null,  thirdValue = new byte[thirdValueSize];
                    //fill the values with random bits
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    _random.NextBytes(thirdValue);
                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(3, bucketNum);
                    if (keyArray == null) return;                    
                    firstKey = keyArray[0];
                    secondKey = keyArray[1];
                    thirdKey = keyArray[2];
                    
                    /***** insert two < low_water values, query for first, insert another > low watermark to set off drainage. *****/

                    InsertSingleItem(firstKey, firstValue);
                   
                    InsertSingleItem(secondKey, secondValue);

                    //insert the first key again so that the second key will be removed instead of the first
                    hr = _xb.Insert(firstKey, firstValue);
                    if (hr != HResult.S_FALSE)
                    {
                         throw new HResultException(hr, "Insert returned "+hr+" instead of S_FALSE");
                    }

                    //insert third key that will trigger drainage
                    InsertSingleItem(thirdKey, thirdValue);

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 second for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was NOT removed.
                    Query(firstKey, firstValue, HResult.S_OK);
                    //check to see if second value was removed.
                    Query(secondKey, null, HResult.S_FALSE);
                 
                     //check to see if third value was NOT removed.
                    Query(thirdKey, thirdValue, HResult.S_OK);
                
                     //remove it for cleanup
                   Remove(firstKey);
                   Remove(secondKey);
                   Remove(thirdKey);

                   ResultCode = TEST_RESULTS.PASSED;
                   
                    
               }
          }

          [TestCase, Description("Insert two values, Insert first again with different value, insert another to drain second value")]
          class P_InsertFirstAgainDiffValue: XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint firstValueSize = 5000;
                    uint secondValueSize = 2000;
                    uint thirdValueSize = 2000;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + firstValueSize + secondValueSize + thirdValueSize);
                    if (sizeDiff > 0) //make sure we can hit the lowWaterMark
                    {
                        thirdValueSize += (uint)sizeDiff + 500;
                    }
                  
                    byte[] firstKey = null, firstValue = new byte[firstValueSize];
                    byte[] secondKey = null, secondValue = new byte[secondValueSize];
                    byte[] thirdKey = null,  thirdValue = new byte[thirdValueSize];
                    //fill the values with random bits
                    _random.NextBytes(firstValue);
                    _random.NextBytes(secondValue);
                    _random.NextBytes(thirdValue);

                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(3, bucketNum);
                    if (keyArray == null) return;
                    firstKey = keyArray[0];
                    secondKey = keyArray[1];
                    thirdKey = keyArray[2];
                    
                    /***** insert two < low_water values, query for first, insert another > low watermark to set off drainage. *****/

                    InsertSingleItem(firstKey, firstValue);
                    InsertSingleItem(secondKey, secondValue);

                    //insert the first key with a different value. This will not count as an access, so that the first key will be removed instead of the second
                    byte[] newFirstValue = _enc.GetBytes("a different value");
                    hr = _xb.Insert(firstKey, newFirstValue);
                    if (hr != HResult.E_ACCESSDENIED)
                    {
                         throw new HResultException(hr, "Insert returned "+hr+" instead of E_ACCESSDENIED");
                    }

                    //insert third key that will trigger drainage
                    InsertSingleItem(thirdKey, thirdValue);

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 seconds for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1*1000);

                    //check to see if first value was removed.
                    Query(firstKey, null, HResult.S_FALSE);
                    
                    //check to see if second value was NOT removed.
                    Query(secondKey, secondValue, HResult.S_OK);
                
                     //check to see if third value was NOT removed.
                    Query(thirdKey, thirdValue, HResult.S_OK);
                     //remove it for cleanup
                    Remove(firstKey);
                    Remove(secondKey);
                    Remove(thirdKey);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert four values, remove fourth, insert fifth and another to drain five previous values")]
          class P_MRURemoveAnAlreadyRemovedValue: XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint fourthValueSize = 2000;
                    uint fifthValueSize = 1000;
                    uint sixthValueSize = 5000;
                    int sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + fourthValueSize + fifthValueSize + 3 * 1024);
                    if (sizeDiff < 0)  //1+2+3+4+5 < LWM
                    {
                        if ((int)fifthValueSize < -sizeDiff)
                        {
                            sizeDiff += (int)fifthValueSize;
                            fifthValueSize = 1;
                            fourthValueSize += (uint)sizeDiff;
                        }
                        else
                        {
                            fifthValueSize += (uint)sizeDiff - 1;
                        }
                    }
                    sizeDiff = (int)lowWaterMark - ((int)beginningTotalBytes + (int)fifthValueSize + (int)sixthValueSize + 3 * 1024);
                    if (sizeDiff > 0)
                    {
                        sixthValueSize += (uint)sizeDiff + 500;
                    }
                      //make sure the right things will be purged
                    sizeDiff = (int)lowWaterMark - (int)(beginningTotalBytes + fifthValueSize + sixthValueSize);
                    if (sizeDiff < 0)
                    {  
                        //sizediff is negative!
                        if ((-sizeDiff + 500) > sixthValueSize)
                        {
                            throw new Exception("Can not perform this test because beginningTotalBytes is too large");
                        }
                        if (beginningTotalBytes + fifthValueSize + (uint)((int)sixthValueSize + sizeDiff) < lowWaterMark)
                        {
                            sixthValueSize = (uint)((int)sixthValueSize - sizeDiff - 500);
                            fifthValueSize += (uint)sizeDiff + 500;
                        }
                        else
                        {
                            sixthValueSize = (uint)((int)sixthValueSize + sizeDiff - 500);
                        }
                    }
                    
                    Random random = new Random();
                    byte[][] firstKeys = {new byte[]{1},new byte[]{2}, new byte[]{3}}; 
                    byte[] fourthKey = {100};
                    byte[] fourthValue = new byte[fourthValueSize];
                    byte[] fifthKey = {150}; 
                    byte[] fifthValue = new byte[fifthValueSize];
                    byte[] sixthKey = {200}; 
                    byte[] sixthValue = new byte[sixthValueSize];
                    //fill the values with random bits
                    random.NextBytes(fourthValue);
                    random.NextBytes(fifthValue);
                    random.NextBytes(sixthValue);

                    //create keys that map to the same server
                    byte[][] keyArray = CreateKeyArrayThatMapsToSameBucket(6, bucketNum);
                    if (keyArray == null) return;
                    firstKeys[0] = keyArray[0];
                    firstKeys[1] = keyArray[1];
                    firstKeys[2] = keyArray[2];
                    fourthKey = keyArray[3];
                    fifthKey = keyArray[4];
                    sixthKey = keyArray[5];

                    for (int i=0; i<3; i++)
                    {
                         InsertSingleItem(firstKeys[i],new byte[1024]);
                    } // 3 * 1024 inserted 
                    
                    InsertSingleItem(fourthKey, fourthValue);
                    InsertSingleItem(fifthKey, fifthValue);

                    //throw things awry by removing the fourth key! 
                    Remove(fourthKey);

                    //insert sixth key that will trigger drainage
                    InsertSingleItem(sixthKey, sixthValue);

                    //the high water mark should have been hit, the heartbeat thread will clean this up, we must wait for this.

                    //wait 1 second for heartbeat thread to remove values
                    _report.Debug("Wait for 1 seconds for heartbeat to remove values");
                    new SleepInfo("Wait for 1 second", 1000);

                    //check to see if sixth value was NOT removed.
                    Query(sixthKey, sixthValue, HResult.S_OK);
                
                    //check to see if fifth value was NOT removed.
                    Query(fifthKey, fifthValue, HResult.S_OK);

                    //check to see if first values were removed.
                     for (int i=0; i<3; i++)
                    {
                         Query(firstKeys[i], null, HResult.S_FALSE);
                    }
                     //check to see if fourth value was removed.
                    Query(fourthKey, null, HResult.S_FALSE);
                   
                                     
                     //remove it for cleanup
                    Remove(sixthKey);
                    Remove(fifthKey);
                    Remove(fourthKey);
                    for (int i=0; i<3; i++)
                    {
                        Remove(firstKeys[i]);
                    }
                 
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncMulti.cs ===
using System;
using System.Threading;
using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace XBANCTest
{
     [TestGroup, EnvRequirement("Xblobonly")]
     public class XBancFuncMulti : TestNode
     {
           [TestCase]
          class P_MultiInsertToDifferentServers : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] expectedHRArray = new uint[20];
                    byte[][] keys = new byte[20][];
                    byte[][] tempKeys = null;
                    byte[][] values = new byte[20][];
                    DateTime ooo = DateTime.Now;
                    long ticksPerSecond = ooo.AddSeconds(1).Ticks - ooo.Ticks;

                    for(int i=0; i<keys.Length; i+=2)
                    {
                           tempKeys = CreateKeyArrayThatMapsToDifferentServers(2);
                           keys[i] = tempKeys[0];
                           keys[i+1] = tempKeys[1];
                    }
                    
                    for(int i=0; i<values.Length; i++)
                    {
                        values[i] = CreateValue();
                        expectedHRArray[i] = HResult.S_OK;
                    }

                    InsertMultipleItems(keys, values);

                    DateTime now = DateTime.Now;
                    double timePassed = 0;
                    DateTime then = DateTime.Now;
                    long ticksPassed = 0;

                    for(int j=1; j<5; j++)
                    {
                        now = DateTime.Now;

                        uint[] hr;
                        byte[][] outvalue;
                        uint[] outseconds = null;
                        
                        hr = _xb.Query(keys,  out outvalue, out outseconds);
                        then = DateTime.Now;
                        
                        if(hr == null || hr.Length !=expectedHRArray.Length)
                        {
                            throw new Exception("Query returned results were null when not expected.");                     
                        }
                        for(int i=0; i< hr.Length; i++)
                        {
                            if (hr[i] != expectedHRArray[i])
                            {
                                throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of "+expectedHRArray[i]+" for the "+i+"th key.");
                            }
                        }
                        if (values != null && outvalue != null)
                        {
                             for(int i=0; i< values.Length; i++)
                            {
                                if(expectedHRArray[i] == HResult.S_OK)
                                {
                                    ValidateReturnedData(values[i], outvalue[i]);
                                }
                            }
                        }

                        
                        timePassed = 0;

                        ticksPassed = then.Ticks - now.Ticks;
                        timePassed = ticksPassed / (double) ticksPerSecond;
                        
                        _report.Debug(j+". querying for "+keys.Length+" existing keys took "+timePassed+" seconds.");

                        now = DateTime.Now;
                    }

                    Remove(keys);
                    ResultCode = TEST_RESULTS.PASSED;
               }
           }
           
            [TestCase]
            class P_MultiInsertToSameBucket: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    DateTime ooo = DateTime.Now;
                    long ticksPerSecond = ooo.AddSeconds(1).Ticks - ooo.Ticks;
                     /***** insert into all into last bucket, bucket 419       *****/
                    byte[][] keys1 = CreateKeyArrayThatMapsToSameBucket(5, 419);
                    byte[][] keys = new byte[keys1.Length+5][];

                    int fastfailtimeoutperiod = (int)Config.GetUIntSetting(Setting.xbanc_fastFailBlockIntervalSeconds);

                    
                    for(int i=0; i<keys1.Length; i++)
                    {
                        keys[i*2] = keys1[i];
                        if ((i*2+1) < keys.Length)
                        {
                            keys[i*2+1] = CreateKey(); //if only 419 is mapped to the dead server, then there is a 1/419 chance this key will be mapped to the dead server
                        }
                    }
                    
                    byte[][] values = new byte[keys.Length][];
                    uint[] hr;
                    uint[] seconds;
                    
                    DateTime now = DateTime.Now;
                    double timePassed = 0;
                    DateTime then = DateTime.Now;
                    long ticksPassed = 0;
                    int countFails = 0;
                    int interation =0;
                    DateTime nanny = DateTime.Now;
                    
                    while((DateTime.Now.Ticks - nanny.Ticks)/ticksPerSecond< fastfailtimeoutperiod + 10)
                    {
                        now = DateTime.Now;

                        hr = _xb.Query(keys, out values, out seconds);

                        then = DateTime.Now;

                        ticksPassed = then.Ticks - now.Ticks;
                        timePassed = ticksPassed / (double) ticksPerSecond;
                        
                        _report.Debug(interation+". querying for "+keys.Length+" existing keys took "+timePassed+" seconds.");

                        countFails = 0;
                        foreach(uint h in hr)
                        {
                            if (HResult.Failed(h))
                                countFails++;
                        }
                        _report.Debug(interation+". querying for "+keys.Length+" encountered "+countFails+" failures.");
                        interation++;
                        
                        Thread.Sleep(500);
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncQuery.cs ===
using System;
using System.Threading;
using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.service;


namespace XBANCTest
{
     public class XBancFuncQuery : TestNode
     {
          [TestCase]
          class P_ReservationExpiration : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    long ticksPerSecond = 10000000;
                    byte[] key = null, value = null;

                    CreateKeyValuePair(out key, out value);

                    DateTime timeNanny = DateTime.Now;
                    QueryCheckTime(key, null, _reservationExpirySeconds, HResult.S_FALSE);

                    long secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                    while (secondsPassed < _reservationExpirySeconds)
                    {
                        secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond; 
                        QueryCheckTime(key, null, _reservationExpirySeconds - (uint)secondsPassed, HResult.S_FALSE);

                        _report.Debug(secondsPassed + " seconds have passed");

                        Thread.Sleep(500);
                        secondsPassed = (DateTime.Now.Ticks - timeNanny.Ticks)/ticksPerSecond;
                    }
                     //sleep for 1000 milliseconds
                     Thread.Sleep(1000);
                     
                    //reservation should have expired
                    // try to insert over the expired reservation, it should not work
                    hr = _xb.Insert(key, value, 0, 0);
                    if (hr != HResult.S_FALSE)
                    {
                          throw new HResultException(hr, "Insert returned "+hr+" instead of S_FALSE");  
                    }

                    //we shouldn't see the inserted data, but we should create a new reservation
                    QueryCheckTime(key, null, _reservationExpirySeconds, HResult.S_FALSE);

                    Remove(key);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Parameter_Null_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] value = null;
                    
                    hr = _xb.Query(null, out value);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Query with null key returned "+hr+" instead of E_INVALIDARG");                     
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

           [TestCase]
          class N_Parameter_Empty_Cases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    byte[] key = new byte[0];
                    byte[] value = null;

                    hr = _xb.Query(key, out value);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Query with empty key returned "+hr+" instead of E_INVALIDARG");                     
                    }
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncLocalCache.cs ===
using System;
using System.Diagnostics;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace XBANCTest
{
    public class XBancFuncLocalCache : TestNode
    {
        
        [TestCase, Description("Insert value, Remove value, Query value which should still be in the local cache")]
        class P_LocalCacheNotExpired : XBancFuncTestBase
        {

            override protected void Execute()
            {
                uint hr;
                byte[] key = null, value = null;

                // Need to use the local cache
                _xb = new XBanc(true);

                CreateKeyValuePair(out key, out value);

                // Set the value in xbanc, and query it
                SetData(key, value);

                // Remove the data from xbanc, but the cache should not be affected
                hr = _xb.Remove(key);

                // Query should check the cache
                Query(key, value, HResult.S_OK);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Insert, Update, wait for expire and then Query and should get new value ")]
        class P_LocalCacheExpired : XBancFuncTestBase
        {

            override protected void Execute()
            {
                uint hr;
                byte[] key = null, value = null, newvalue = null;

                // Need to use the local cache
                _xb = new XBanc(true);

                CreateKeyValuePair(out key, out value);

                // Set the value which will also query the value and put it in the cache
                SetData(key, value);

                newvalue = new byte[_random.Next(1,1024*1024)];
                _random.NextBytes(newvalue);

                // Update the value so it gets updated in xbanc but not in the cache
                hr = _xb.SetData(key, newvalue, 0, 0);

                // Sleep for the expiration
                uint cacheExpire = Convert.ToUInt32(Global.XEnv.GetSetting("xbanc_localCacheItemDuration"));
                Global.RO.Info("Sleep for {0} seconds",cacheExpire);
                new SleepInfo("Sleep for Cache Expire", cacheExpire * 1000);

                // Requery the field, cache should be expired and get the new value from xbanc
                Query(key, newvalue, HResult.S_OK);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Insert, Update, wait for expire and then Query and should get new value ")]
        class N_LocalCacheKeyNotFound : XBancFuncTestBase
        {

            override protected void Execute()
            {
                byte[] key = null, value = null;

                // Need to use the local cache
                _xb = new XBanc(true);

                CreateKeyValuePair(out key, out value);

                // Requery the field, cache should be expired and get the new value from xbanc
                Query(key, value, HResult.S_FALSE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Insert-query value, remove the value from xbanc, wait for expire and then query")]
        class N_LocalCacheQueryRemovedExpiredValue : XBancFuncTestBase
        {

            override protected void Execute()
            {
                uint hr;
                byte[] key = null, value = null;

                // Need to use the local cache
                _xb = new XBanc(true);

                CreateKeyValuePair(out key, out value);

                // Set the value in xbanc, and query it
                SetData(key, value);

                // Remove the data from xbanc, but the cache should not be affected
                hr = _xb.Remove(key);

                // Sleep for the expiration
                uint cacheExpire = Convert.ToUInt32(Global.XEnv.GetSetting("xbanc_localCacheItemDuration"));
                Global.RO.Info("Sleep for {0} seconds", cacheExpire);
                new SleepInfo("Sleep for Cache Expire", cacheExpire * 1000);

                // Query should check the cache, where the value expired, and no longer exists in xbanc
                Query(key, value, HResult.S_FALSE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncRemove.cs ===
using System;
using ServerTestFramework;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace XBANCTest
{
     public class XBancFuncRemove : TestNode
     {
           [TestCase, Description("Remove simple test cases: null paramater, nonexistent key without flag")]
          class P_NonExistentKeys : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray;

                    /***** pass in nonexistent key without match flag *****/
                    hr = _xb.Remove(_enc.GetBytes("Test nonexistent key!!!!!"));
                    if (hr != HResult.S_FALSE)
                    {
                        throw new HResultException(hr, "Remove returned "+hr+" instead of S_FALSE");
                    }

                    /***** pass in nonexistent keys *****/
                    hrArray = _xb.Remove(new byte[][] {_enc.GetBytes("Testnonexistant!"),_enc.GetBytes("Testnonexistan2222t!"), _enc.GetBytes("Testnonexisalskdjflaks;jdftant!")} );
                    if (hrArray == null || hrArray.Length != 3)
                    {
                        throw new Exception("Calling remove with 3 non-existant keys returned an unexpected HResult array");
                    }
                    for(int i=0; i<3; i++)
                    {
                        if (hrArray[i] != HResult.S_FALSE)
                        {
                            throw new HResultException(hrArray[i], "Remove returned "+hrArray[i]+" instead of S_FALSE");
                        }
                    }

                    /***** pass in nonexistent key with match flag true *****/
                    hr = _xb.Remove(_enc.GetBytes("Test nonexistent key!!!!!"),true);
                    if (hr != HResult.S_FALSE)
                    {
                          throw new HResultException(hr, "Remove returned "+hr+" instead of S_FALSE");
                    }
                    
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

           [TestCase]
          class P_MultiRemove: XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hrArray;
                    uint[] expectedHRArray = new uint[4];
                    byte[][] keysToRemove = new byte[4][];
                    byte[][] keysToInsert = null;
                    byte[][] values = new byte[2][];
                    
                    keysToInsert = CreateKeyArrayThatMapsToDifferentServers(2);
                    values[0] = CreateValue();
                    values[1] = CreateValue();

                    InsertMultipleItems(keysToInsert, values, new uint [keysToInsert.Length], new uint [keysToInsert.Length]);

                    byte[][] tempKeys = CreateKeyArrayThatMapsToDifferentServers(2);
                    keysToRemove[0] = keysToInsert[0];
                    keysToRemove[1] = tempKeys[0];
                    keysToRemove[2] = keysToInsert[1];
                    keysToRemove[3] = tempKeys[1];
                    expectedHRArray[0] = HResult.S_OK;
                    expectedHRArray[1] = HResult.S_FALSE;
                    expectedHRArray[2] = HResult.S_OK;
                    expectedHRArray[3] = HResult.S_FALSE;                 
                        

                    /***** Remove the keys *****/
                    hrArray = _xb.Remove(keysToRemove);
                    if (hrArray == null || hrArray.Length != 4)
                    {
                        throw new Exception("Calling remove with 4 keys returned an unexpected HResult array");
                    }
                    for(int i=0; i<hrArray.Length; i++)
                    {
                        if (hrArray[i] != expectedHRArray[i])
                        {
                            throw new HResultException(hrArray[i], "Remove returned "+hrArray[i]+" instead of "+expectedHRArray[i]);
                        }
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
          [TestCase, Description("Remove exact key with true matchexact")]
          
          class P_ExactKeyTrueMatch : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    string[] keys = {      "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key11K",
                                                       "Key2"};
                    string keyToRemove = "Key11K";
                    string[] keysToCheck = {"Key1",
                                                            "Key11",
                                                            "Key1K",
                                                            "Key2"};

                    /***** Valid exact key, true match exact, should only erase one key *****/
                    RemoveTestHelper(keys, keyToRemove, keysToCheck,true,HResult.S_OK);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Remove exact key with false matchexact")]
          
          class P_ExactKeyFalseMatch : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] keys = {      "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key11K",
                                                       "Key2"};
                    string keyToRemove = "Key1K";
                    string[] keysToCheck = {"Key1",
                                                            "Key11",
                                                            "Key11K",
                                                            "Key2"};

                    /***** Valid exact key, false match exact, should only erase one key *****/
                    RemoveTestHelper(keys, keyToRemove, keysToCheck,false,HResult.S_OK);                  
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
          [TestCase, Description("Remove exact and prefixed key with true matchexact")]
          class P_PreFixExactKeyTrueMatch : XBancFuncTestBase
          {
                override protected void Execute()
                {
                    string[] keys = {      "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key11K",
                                                       "Key2"};
                    string keyToRemove = "Key11";
                    string[] keysToCheck = {"Key1",
                                                            "Key1K",
                                                            "Key11K",
                                                            "Key2"};

                    /***** Valid prefix and exact key, true match exact, should only erase one key *****/
                    RemoveTestHelper(keys, keyToRemove, keysToCheck, true,HResult.S_OK);
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }

            [TestCase, Description("Remove subtree by prefix tree with false matchexact")]
          class P_PreFixOnlyKeyFalseMatch : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    string[] keys = {      "a",
                                                       "Z",
                                                       "K",
                                                       "Key",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key11K"};
                                                       
                    string keyToRemove = "Ke";
                    string[] keysToCheck = {"a",
                                                            "Z",
                                                            "K",};
                    string[] deletedKeysToCheck = {  "Key",
                                                                           "Key11",
                                                                           "Key1K",
                                                                           "Key11K"};

                    /***** Valid prefix but non-exact key, false match exact, should erase subtree *****/
                    RemoveTestHelper(keys, keyToRemove, keysToCheck,  false,HResult.S_OK);
                    ResultCode = TEST_RESULTS.PASSED;
                    
                    //verify deleted subtree is indeed deleted
                    foreach(string key in deletedKeysToCheck)
                    {
                        Query(_enc.GetBytes(key), null, HResult.S_FALSE);
                    }
                  
               }
          }

          [TestCase, Description("Remove entire subtree by prefix tree with false matchexact")]
          class P_PreFixKeyEntireFalseMatch : XBancFuncTestBase
          {
                override protected void Execute()
                {
                    string[] keys = {      "A",
                                                   "Key1",
                                                   "Key11",
                                                   "Key1K",
                                                   "K2345678911234567892123456789312345678941234567895123456789612345678971234567898123456789912345678901234567891123456789212345678",
                                                   "Key11K"};
                    string keyToRemove = "K";
                    string[] keysToCheck = {"A"};
                    string[] deletedKeysToCheck = {  "Key1",
                                                                       "Key11",
                                                                       "Key1K",
                                                                       "K2345678911234567892123456789312345678941234567895123456789612345678971234567898123456789912345678901234567891123456789212345678",
                                                                       "Key11K"};
                    
                    /***** Valid entire tree prefix but non-exact key, false match exact, should erase entire subtree *****/
                    RemoveTestHelper(keys, keyToRemove, keysToCheck, false,HResult.S_OK);
                    
                    //verify deleted subtree is indeed deleted
                    foreach(string key in deletedKeysToCheck)
                    {
                        Query(_enc.GetBytes(key), null, HResult.S_FALSE);
                    }
                    
                    ResultCode = TEST_RESULTS.PASSED;
                }
          }

          [TestCase, Description("Remove nonexistent prefix key with true matchexact")]
          class P_NonExistentKeyTrueMatch : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    string[] keys = {      "A",
                                                       "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                    string keyToRemove = "Key1Kj";
                    string[] keysToCheck = {"A",
                                                       "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                                                            
                   /***** invalid key and prefix, true match exact, should erase nothing *****/
                  RemoveTestHelper(keys, keyToRemove, keysToCheck, true,HResult.S_FALSE);
                  ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
           [TestCase, Description("Remove nonexistent prefix key with false matchexact")]
          class P_NonExistentKeyFalseMatch : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    string[] keys = {      "A",
                                                       "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                    string keyToRemove = "Key1Kj";
                    string[]keysToCheck = {"A",
                                                       "Key1",
                                                       "Key11",
                                                       "Key1K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                    
                   /***** invalid key and prefix, false match exact, should erase nothing *****/
                   //2 Since Matt was lazy, the Remove call will return S_OK, even though it did not remove anything.
                  RemoveTestHelper(keys, keyToRemove, keysToCheck, false,HResult.S_OK);
                  ResultCode = TEST_RESULTS.PASSED;
                
                  
               }
          }

         [TestCase, Description("Remove prefix but not exact key with true matchexact")]
          class P_PreFixOnlyKeyTrueMatch : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] keys = {      "A",
                                                       "Key1",
                                                       "Key111",
                                                       "Key111K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};
                    string keyToRemove = "Key11";
                    string[] keysToCheck = { "A",
                                                       "Key1",
                                                       "Key111",
                                                       "Key111K",
                                                       "Key1Kkkkkkkkk",
                                                       "Key11K"};

                   /***** invalid key but valid prefix, true match exact, should erase nothing *****/
                  RemoveTestHelper(keys, keyToRemove, keysToCheck, true,HResult.S_FALSE);
                  ResultCode  = TEST_RESULTS.PASSED;
                
                  
               }
          }
              [TestCase]
          class N_Parameter_Null_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                     uint hr;
                     uint[] hra;
                     byte[] nothing = null;
                     byte[][] nothing2 = null;
                     hr = _xb.Remove(nothing);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Remove with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                     hra = _xb.Remove(nothing2);
                     if(hra != null)
                     {
                          throw new Exception("Calling Remove with null key returned an hresult array that was not null.");                     
                     }
                    

                     hr = _xb.Remove(null,true);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling Remove with null value returned "+hr+" instead of E_INVALIDARG");                           
                     }
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_Parameter_Empty_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray = null;
                    byte[][] keyEmpty = new byte[0][];

                    hr = _xb.Remove(new byte[0]);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling Remove with empty key returned "+hr+" instead of E_INVALIDARG");                                      
                    }

                    hr = _xb.Remove(new byte[0], false);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                         throw new HResultException(hr, "Calling Remove with empty key returned "+hr+" instead of E_INVALIDARG");                        
                    }
                    
                    hrArray = _xb.Insert(keyEmpty, new byte[][] {new byte[] {1}}, new uint[1], new uint[1]);
                    if (hrArray != null)
                    {
                        throw new Exception("Calling remove with empty key array returned unexpected HResult array");
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Key_SizeTooLong : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    byte[] keyTooLong =  new byte[_maxKeyLength + 1];

                    //fill key with some random values.
                    _random.NextBytes(keyTooLong);

                     hr = _xb.Remove(keyTooLong);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Remove with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                     hr = _xb.Remove(keyTooLong, true);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Remove with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\StressLargeClient\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncSequence.cs ===
using System;
using ServerTestFramework;
using xonline.common.service;


namespace XBANCTest
{
     public class XBancFuncSequence : TestNode
     {
          
          [TestCase, Description("Basic Sequence: Query, Insert and Remove")]
          
          class P_QueryInsertRemove : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Insert",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                    /***** call Query, Insert, and remove on the same key (and value) *****/
                    //verify a reservation was made, filled, and the data was successfully removed 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Out of order sequence: Query Remove Insert")]
          
          class P_QueryRemoveInsert : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Remove",
                                                       "Insert"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE};
                    /***** call Query, Remove, and Insert on the same key (and value) *****/
                    //verify a reservation was made, removed, and the insert call failed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Out of order sequence: Query SetData Insert")]
          
          class P_QuerySetDataInsert : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "SetData",
                                                       "Insert",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK};
                    /***** call Query, SetData, and Insert on the same key (and value) *****/
                    //verify a reservation was made, overwritten, and the insert call failed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Out of order sequence: Query SetData Insert")]
          
          class P_QueryInsertSetData : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Insert",
                                                       "SetData",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK, 
                                                       HResult.S_OK}; 
                    /***** call Query, Insert, SetData on the same key (and value) *****/
                    //verify a reservation was made, filled, and setdata returned S_OK
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Out of order sequence: Query Query Insert Insert")]
          
          class P_QueryQueryInsertInsert : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Query",
                                                       "Insert",
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                    /***** call Query, Query, Insert, Insert on the same key (and value) *****/
                    //verify a reservation was made, nothing was returned, filled, and second call to insert failed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Out of order sequence: Query Query Remove Insert")]
          
          class P_QueryQueryRemoveInsert : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Query",
                                                       "Query",
                                                       "Remove",
                                                       "Insert"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE};
                                                      
                    /***** call Query, Query, Remove, Insert on the same key (and value) *****/
                    //verify a reservation was made, nothing was returned, the reservation was removed, and the call to insert failed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Out of order sequence: Insert Query Remove")]
          
          class P_InsertQueryRemove : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK};
                                                      
                    /***** call Insert, Query, Remove on the same key (and value) *****/
                    //verify the insert failed, a reservation was made and removed
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Out of order sequence: Remove Query Insert")]
          
          class P_RemoveQueryInsert : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "Remove",
                                                       "Query",
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_FALSE,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call Remove, Query, Insert on the same key (and value) *****/
                    //verify the remove returned false, a reservation was made and filled 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Out of order sequence: Setdata Query Insert")]
          
          class P_SetDataQueryInsert : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "SetData",
                                                       "Query",
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call SetData, Query, Insert on the same key (and value) *****/
                    //verify the value was written, returned by query, and insert failed 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Sequence: Setdata Query Remove Query Insert")]
          
          class P_SetDataQueryRemoveQueryInsert : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "SetData",
                                                       "Query",
                                                       "Remove",
                                                       "Query",
                                                       "Insert",
                                                       "Query",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK};
                                                      
                    /***** call SetData, Query, Remove, Query, Insert on the same key (and value) *****/
                    //verify the value was written, returned by Query, removed, a reservation was made and filled
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

          [TestCase, Description("Out of order sequence: Setdata Query Insert Remove")]
          
          class P_SetDataQueryInsertRemove : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "SetData",
                                                       "Query",
                                                       "Insert",
                                                       "Remove"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE,
                                                       HResult.S_OK};
                                                      
                    /***** call SetData, Query, Insert, Remove on the same key (and value) *****/
                    //verify the value was written, correct value was returned by query, the insert returned s_false, and data was successfully removed 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }

           [TestCase, Description("Out of order sequence: Setdata Query Remove Insert ")]
          
          class P_SetDataQueryRemoveInsert : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string[] functions = {    
                                                       "SetData",
                                                       "Query",
                                                       "Remove",
                                                       "Insert"};
                    uint[] expectedValues = {
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_OK,
                                                       HResult.S_FALSE};
                                                      
                    /***** call SetData, Query, Remove, Insert on the same key (and value) *****/
                    //verify the value was written, correct value was returned, removed, and the insert call failed 
                    SequenceTestHelper(functions, expectedValues);
                    ResultCode = TEST_RESULTS.PASSED;
                  
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCFuncSetData.cs ===
using System;
using System.Diagnostics;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;



namespace XBANCTest
{
     public class XBancFuncSetData : TestNode
     {
      
             [TestCase]
          class P_Mainline : XBancFuncTestBase
          {
                 /***** valid key, valid value *****/
               override protected void Execute()
               {
                    byte[] key = null;
                    byte[] value = null;
                    
                    CreateKeyValuePair(out key, out value);

                    SetData(key, value);
                     //cleanup
                    Remove(key);

                     //SetData [][] overload
                    byte[][] key2 = null;
                    byte[][] value2 = null;
                    
                    CreateKeyValueArrayPair(out key2, out value2);

                    SetData(key2, value2);
                     //cleanup
                    Remove(key2);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class P_Keys_EdgeCases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] tempkey = null;
                    byte[] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    
                    CreateKeyValuePair(out tempkey, out value);
                    /***** rest of valid key, valid value test cases *****/
                    //according to MSDN there is an implicit cast from integer literal to byte as long as the literal is < 256
                    byte[][] keyTable = { 
                                                            new byte[] {0,0,0,0},    //nonzero length key with no bits set
                                                            new byte[] {5},          // 1 byte length key
                                                            new byte[] {1,2,3,4,5,6,7,8}, //byte aligned key
                                                            new byte[] {1,2,3,4,5,6},     //non-byte aligned key
                                                            CreateKey(_maxKeyLength) // equal to max size key length
                                                       };
                                                       
                    foreach (byte[] key in keyTable)
                    {
                         SetData(key, value);
                          //cleanup
                         Remove(key);
                    }

                     ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

            [TestCase]
           class P_KeyArray_EdgeCases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hr;
                    byte[][] key = new byte[2][];
                    key[0] = new byte[] {34};
                    key[1] = null;
                    byte[][] value = new byte[2][]; //just some random data
                    value[0] = new byte[] {25};
                    value[1] = new byte[] {45};
                    //key[0] = valid, key[1]=invalid
                    
                    hr = _xb.SetData(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hr == null || hr.Length != 2)
                    {
                        throw new Exception("SetData did not return expected HR results");
                    }
                    if (hr[0] != HResult.S_OK)
                    {
                        throw new HResultException(hr[0], "SetData returned "+hr[0]+" instead of S_OK");
                    }
                    if (hr[1] != HResult.E_INVALIDARG)
                    {
                        throw new HResultException(hr[1], "SetData returned "+hr[1]+" instead of E_INVALIDARG");
                    }

                    //remove for cleanup
                    Remove(key[0]);

                    key = new byte[100][];
                    value = new byte[100][];
                    for(int i=0; i<key.Length; i++)
                    {
                        key[i] = CreateKey();
                        value[i] = CreateValue();
                    }

                    SetData(key, value, new uint [key.Length], new uint [key.Length]);

                    //remove for cleanup
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
                    
               }
          }

           [TestCase, Description("Insert version 1 positive paramater testing")]
          class P_Values_EdgeCases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    byte[] key = null;
                    byte[] tempvalue = null;
                    CreateKeyValuePair(out key, out tempvalue);
                    /***** rest of valid key, valid value test cases *****/
                    //according to MSDN there is an implicit cast from integer literal to byte as long as the literal is < 256
                    byte[][] valueTable = { 
                                                            new byte[] {0,0,0,0},    //nonzero length value with no bits set
                                                            new byte[] {5},          // 1 byte length value
                                                            new byte[256000],   //large value size
                                                            new byte[1048576 ] //value sized =  1 mb
                                                       };
                                                       
                    foreach (byte[] value in valueTable)
                    {
                        if (value.Length > 4)
                        {
                            //fill key with some random values.
                            _random.NextBytes(value);
                        }
                         
                        SetData(key, value);
                         //cleanup
                        Remove(key);
                    }
                    
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_MaxAbsolute : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] expiry = null;
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);

                    expiry = new uint[keyArray.Length];
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<expiry.Length; i++)
                    {
                        expiry[i] = _maxUInt;
                        expectedHR[i] = HResult.S_OK;
                        expectedExpiry[i] = _maxUInt - 5;
                    }

                    SetData(key, value, _maxUInt, 0);
                    SetData(keyArray, valueArray, expiry, new uint[keyArray.Length]);
                    
                    //wait to see if the value will expire, it should not.
                    new SleepInfo("Wait for 5 seconds for value to NOT expire",5*1000);
                    //Query to see if value did not expire
                    QueryCheckTime(key, value, _maxUInt - 5, HResult.S_OK);
                    QueryCheckTime(keyArray, valueArray, expectedExpiry, expectedHR);
                    //remove for cleanup
                    Remove(key);
                    Remove(keyArray);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase, Description("Insert version 2 no expiration testing")]
          class P_Expiry_MaxSliding : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    byte[] value = null;
                    byte[] key = null;
                    byte[][] keyArray = null;
                    byte[][] valueArray = null;
                    uint[] expiry = null;
                    uint[] expectedExpiry = null;
                    uint[] expectedHR = null;

                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);

                    expiry = new uint[keyArray.Length];
                    expectedHR = new uint[keyArray.Length];
                    expectedExpiry = new uint[keyArray.Length];
                    for(int i=0; i<expiry.Length; i++)
                    {
                        expiry[i] = _maxUInt;
                        expectedHR[i] = HResult.S_OK;
                        expectedExpiry[i] = _maxUInt;
                    }
                    
                    SetData(key, value, 0,  _maxUInt);
                    SetData(keyArray, valueArray, new uint[keyArray.Length], expiry);
                    //wait to see if the value will expire, it should not.
                    new SleepInfo("Wait for 5 seconds for value to NOT expire",5*1000);
                    //Query to see if value did not expire
                    QueryCheckTime(key, value, _maxUInt, HResult.S_OK); //sliding time updated because we just queried for it
                    QueryCheckTime(keyArray, valueArray, expectedExpiry, expectedHR);
                    //remove for cleanup
                    Remove(key);
                    Remove(keyArray);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class P_Expiry_MultipleSetData : XBancFuncTestBase
          {
                
               override protected void Execute()
               {
                    byte[][] keyArrayInsert = null;
                    byte[][] keyArrayQuery = null;
                    byte[][] valueArray = null;
                    byte[][] expectedQueryValues = null;
                    uint[] absoluteExpiry = null;
                    uint[] slidingExpiry = null;                    
                    uint[] expectedExpiry = null;
                    uint[] expectedHR= null;
                    
                   //70                                 75                          30                      45                  60                  
                    //not sliding expired, not absolute expired, sliding expired, absolute expired, reservation expired, 
                    keyArrayInsert = new byte[4][];
                    valueArray = new byte[4][];
                    absoluteExpiry = new uint[keyArrayInsert.Length];
                    slidingExpiry = new uint[keyArrayInsert.Length];   
                    //for the query checktime call
                    expectedQueryValues = new byte[5][];
                    keyArrayQuery = new byte[5][];
                    expectedHR = new uint[keyArrayQuery.Length];
                    expectedExpiry = new uint[keyArrayQuery.Length];
                    
                    for(int i=0; i<keyArrayInsert.Length; i++)
                    {
                        keyArrayInsert[i] = CreateKey();
                        valueArray[i] = CreateValue();
                        keyArrayQuery[i] = keyArrayInsert[i];
                    }
                    
                    absoluteExpiry[0] = 0;
                    absoluteExpiry[1] = 75;
                    absoluteExpiry[2] = 0;
                    absoluteExpiry[3] = 45;
                    slidingExpiry[0] = 70;
                    slidingExpiry[1] = 0;
                    slidingExpiry[2] = 30;
                    slidingExpiry[3] = 0;

                    //results for the QueryCheckTime
                    keyArrayQuery[4] = CreateKey();
                    
                    expectedHR[0] = HResult.S_OK;
                    expectedHR[1] = HResult.S_OK;
                    expectedHR[2] = HResult.S_FALSE;
                    expectedHR[3] = HResult.S_FALSE;
                    expectedHR[4] = HResult.S_FALSE;
                    expectedExpiry[0] = 70;
                    expectedExpiry[1] = 15;
                    expectedExpiry[2] = _reservationExpirySeconds;
                    expectedExpiry[3] = _reservationExpirySeconds;
                    expectedExpiry[4] = _reservationExpirySeconds;
                    expectedQueryValues[0] = valueArray[0];
                    expectedQueryValues[1] = valueArray[1];
                    expectedQueryValues[2] = null;
                    expectedQueryValues[3] = null;
                    expectedQueryValues[4] = null;
                    //make the reservation for the last case
                    Query(keyArrayQuery[4], null, HResult.S_FALSE);
                    
                    SetData(keyArrayInsert, valueArray, absoluteExpiry, slidingExpiry);

                     //sleep for 60 seocnds, value should expire
                    new SleepInfo("Wait 60 seconds for stuff to expire", 60 * 1000);

                    QueryCheckTime(keyArrayQuery, expectedQueryValues, expectedExpiry, expectedHR);

                    //remove everything for cleanup
                    Remove(keyArrayQuery);

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
         
            [TestCase, Description("SetData valid existent key, valid value smaller than original")]
          
          class P_OverWrite_ValueSizeLessThanOriginal : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);

                    int oldValueLength = value.Length;
                    InsertSingleItem(key, value);
                    
                    sValue = "Smaller value";
                    value = _enc.GetBytes(sValue);
                    int lengthDifference = oldValueLength - value.Length;

                    //get perfcounters to verify
                    uint bucket = HashKeyToBucket(key);
                    IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucket);
                    PerformanceCounter XBancTotalDataBytes = new PerformanceCounter("Xbox Live XBanc Data", "Data bytes", "_Total_", b.CurrentServerName);
                    PerformanceCounter XBancTotalItems = new PerformanceCounter("Xbox Live XBanc Data", "Total cache items", "_Total_", b.CurrentServerName);
                    int oldTotalDataBytes = (int) XBancTotalDataBytes.NextValue();
                    int oldTotalItems = (int) XBancTotalItems.NextValue();

                    /***** Call SetData with value sized smaller than the original *****/
                    SetData(key,value,0,0);
                    // Need to verify that the old value was released and deleted
                    new SleepInfo("Waiting 1 sec", 1*1000);
                    ////Confirm PerfCounter TotalBytesCached and TotalItemsCached dropped by 18 bytes and NO items.
                    int newDataBytes = (int) XBancTotalDataBytes.NextValue();
                    if (oldTotalDataBytes - newDataBytes != lengthDifference)
                    {
                         ResultCode = TEST_RESULTS.FAILED;
                         _report.Fatal("Did not recieve expected Data Bytes perfcounter. newDataBytes = "+newDataBytes+", oldDataBytes = "+oldTotalDataBytes+", expected difference = "+lengthDifference);
                    }
                    int newTotalItems = (int) XBancTotalItems.NextValue();
                    if (oldTotalItems != newTotalItems)
                    {
                         ResultCode = TEST_RESULTS.FAILED;
                         _report.Fatal("Did not recieve expected total items perfcounter. oldTotalItems = "+oldTotalItems+", newTotalItems = "+newTotalItems);

                    }
                    //remove value from cache to clean up
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;

               }
          }

          
          [TestCase, Description("SetData valid existent key, identical value")]
            class P_OverWrite_IdenticalValue : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);

                    InsertSingleItem(key, value);

                     //get perfcounters to verify later
                    uint bucket = HashKeyToBucket(key);
                    IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucket);
                    PerformanceCounter XBancTotalDataBytes = new PerformanceCounter("Xbox Live XBanc Data", "Data bytes", "_Total_", b.CurrentServerName);
                    PerformanceCounter XBancTotalItems = new PerformanceCounter("Xbox Live XBanc Data", "Total cache items", "_Total_", b.CurrentServerName);
                    int oldTotalDataBytes = (int) XBancTotalDataBytes.NextValue();
                    int oldTotalItems = (int) XBancTotalItems.NextValue();
               
                    /***** Call SetData with same value *****/
                    SetData(key,value,0,0);
                   
                    // verify that the old value was released and deleted
                    //"Confirm PerfCounter TotalBytesCached and TotalItemsCached dropped by NO bytes and NO items.
                    int newDataBytes = (int) XBancTotalDataBytes.NextValue();
                    if (oldTotalDataBytes != newDataBytes)
                    {
                         ResultCode = TEST_RESULTS.FAILED;
                         _report.Fatal("Did not recieve expected Data Bytes perfcounter. newDataBytes = "+newDataBytes+", oldDataBytes = "+oldTotalDataBytes+", expected difference = 0");
                    }
                    int newTotalItems = (int) XBancTotalItems.NextValue();
                    if (oldTotalItems != newTotalItems)
                    {
                         ResultCode = TEST_RESULTS.FAILED;
                         _report.Fatal("Did not recieve expected total items perfcounter. oldTotalItems = "+oldTotalItems+", newTotalItems = "+newTotalItems+", expected difference = 0");
                    }
                    //remove value from cache to clean up
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
          [TestCase, Description("SetData valid existent key, same sized value but different contents")]
          class P_OverWrite_SameSizeValueDiffContents : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);

                    InsertSingleItem(key, value);

                    //get perfcounters to verify later
                    uint bucket = HashKeyToBucket(key);
                    IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucket);
                    PerformanceCounter XBancTotalDataBytes = new PerformanceCounter("Xbox Live XBanc Data", "Data bytes", "_Total_", b.CurrentServerName);
                    PerformanceCounter XBancTotalItems = new PerformanceCounter("Xbox Live XBanc Data", "Total cache items", "_Total_", b.CurrentServerName);
                    int oldTotalDataBytes = (int) XBancTotalDataBytes.NextValue();
                    int oldTotalItems = (int) XBancTotalItems.NextValue();
                             
                    sValue = "Setdata value to cache in XBANK";
                    value = _enc.GetBytes(sValue);

                    /***** Call SetData with same sized value but different contents *****/
                    SetData(key,value,0,0);

                     //Need to verify that the old value was released and deleted
                    //Confirm PerfCounter TotalBytesCached and TotalItemsCached dropped by NO bytes and NO items.
                    int newDataBytes = (int) XBancTotalDataBytes.NextValue();
                    if (oldTotalDataBytes != newDataBytes)
                    {
                         ResultCode = TEST_RESULTS.FAILED;
                         _report.Fatal("Did not recieve expected Data Bytes perfcounter. newDataBytes = "+newDataBytes+", oldDataBytes = "+oldTotalDataBytes+", expected difference = 0");
                    }
                    int newTotalItems = (int) XBancTotalItems.NextValue();
                    if (oldTotalItems != newTotalItems)
                    {
                         ResultCode = TEST_RESULTS.FAILED;
                         _report.Fatal("Did not recieve expected total items perfcounter. oldTotalItems = "+oldTotalItems+", newTotalItems = "+newTotalItems+", expected difference = 0");

                    }
                    //remove value from cache to clean up
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;                    

               }
          }

               [TestCase, Description("SetData valid existent key, identical value different expiry data")]
            class P_OverWrite_IdenticalValueDiffExpiry : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);
                    byte[] key2 = CreateKey();
                    byte[][] keyArray = new byte[][]{key2, key2};
                    byte[][] valueArray = new byte[][]{value, value};
                    uint[] absoluteExpiry = new uint[]{0,30};
                    uint[] slidingExpiry = new uint[]{0,0};   
                    uint[] expectedReturnedSeconds = new uint[]{_reservationExpirySeconds,_reservationExpirySeconds};  

                     /***** Call SetData with same value *****/
                    InsertSingleItem(key, value);
                   
                    SetData(key,value,30,0);
                    SetData(keyArray, valueArray, absoluteExpiry, slidingExpiry);
                    
                    //sleep 31 seconds
                    _report.Debug("Sleeping for 31 seconds to wait for value to expire.");
                    new SleepInfo("Wait for 31 seconds",31*1000);

                    //value should be expired            
                    QueryCheckTime(key, null, _reservationExpirySeconds, HResult.S_FALSE);
                    QueryCheckTime(keyArray, null, expectedReturnedSeconds, new uint[]{HResult.S_FALSE, HResult.S_FALSE});
                    //remove value from cache to clean up
                    Remove(key);
                    Remove(keyArray);
                   
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
          
               [TestCase, Description("SetData valid existent key, value size greater than original")]
          class P_OverWrite_ValueSizeGreaterThanOriginal : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    string sValue = "Setdata value to cache in XBANC";
                    byte[] key = CreateKey();
                    byte[] value = _enc.GetBytes(sValue);
                    int oldValueLength = value.Length;

                    //insert original data
                    InsertSingleItem(key, value);

                    //Record XBanc PerfCounters TotalBytesCached and TotalItemsCached.
                     //get perfcounters to verify
                    uint bucket = HashKeyToBucket(key);
                    IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)bucket);
                    PerformanceCounter XBancTotalDataBytes = new PerformanceCounter("Xbox Live XBanc Data", "Data bytes", "_Total_", b.CurrentServerName);
                    PerformanceCounter XBancTotalItems = new PerformanceCounter("Xbox Live XBanc Data", "Total cache items", "_Total_", b.CurrentServerName);
                    int oldTotalDataBytes = (int) XBancTotalDataBytes.NextValue();
                    int oldTotalItems = (int) XBancTotalItems.NextValue();
                    
                    sValue = "Setdata value to cache in XBANC Greater than original!";
                    value = _enc.GetBytes(sValue);
                    int lengthDifference = value.Length - oldValueLength ;

                    /***** Call SetData with greater sized value *****/
                    SetData(key,value,0,0);
                                         
                    //Need to verify, possibly manually, that the old value was released and deleted
                     //Confirm PerfCounter TotalBytesCached and TotalItemsCached increased by 23 bytes and NO items.
                    int newDataBytes = (int) XBancTotalDataBytes.NextValue();
                    if ( newDataBytes - oldTotalDataBytes  != lengthDifference)
                    {
                         ResultCode = TEST_RESULTS.FAILED;
                         _report.Fatal("Did not recieve expected Data Bytes perfcounter. newDataBytes = "+newDataBytes+", oldDataBytes = "+oldTotalDataBytes+", expected difference = "+lengthDifference);
                    }
                    int newTotalItems = (int) XBancTotalItems.NextValue();
                    if (oldTotalItems != newTotalItems)
                    {
                         ResultCode = TEST_RESULTS.FAILED;
                         _report.Fatal("Did not recieve expected total items perfcounter. oldTotalItems = "+oldTotalItems+", newTotalItems = "+newTotalItems);

                    }
                   
                    //remove value from cache to clean up
                    Remove(key);
                    
                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
               [TestCase]
          class N_Parameter_Null_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    uint[] hrArray;
                    byte[] key = null;
                    byte[] value = null;
                    byte[][] keyArray = null;
                    byte[][] keyNull = null;
                    byte[][] valueArray = null;
                    byte[][] valueNull = null;
                    
                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);
                    
                    /**** null key, valid value *****/
               
                     hr = _xb.SetData(null,value,0,0);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling SetData with null key returned "+hr+" instead of E_INVALIDARG");                     
                     }

                     hrArray = _xb.SetData(keyNull, valueArray, new uint[valueArray.Length],new uint[valueArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling SetData with null key array returned unexpected HResult array");
                     }

                     /*** valid key, null value ****/

                     hr = _xb.SetData(key, null,0,0);
                     if (hr != HResult.E_INVALIDARG) 
                     {
                          throw new HResultException(hr, "Calling SetData with null value returned "+hr+" instead of E_INVALIDARG");                           
                     }

                      hrArray = _xb.SetData(keyArray, valueNull,new uint[keyArray.Length],new uint[keyArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling SetData  with null value array returned unexpected HResult array");
                     }
                     
                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

                 [TestCase]
          class N_Parameter_Unequal_Length_Cases : XBancFuncTestBase
          {
               override protected void Execute()
               {
                    uint[] hr;
                    
                    hr = _xb.SetData(new byte[][] {new byte[]{1}},new byte[][] {new byte[]{2},new byte[]{3},new byte[]{4},new byte[]{5}}, new uint[1], new uint[1]);
                    if (hr != null)
                    {
                        throw new Exception("Calling SetData with key array and value array different lengths returned unexpected HResult array");
                    }
                    
                    byte[][] key = new byte[][] {new byte[]{1},new byte[] {2},new byte[]{3}};
                    byte[][] value = new byte[][] {new byte[]{1,2},new byte[] {2,3},new byte[]{3,4,5,6}};

                    hr = _xb.SetData(key, value, new uint[] {0,0,0,0}, new uint[] {0,0,0,0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling SetDAta with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                    hr = _xb.SetData(key, value, new uint[] {0,0,0,0,0}, new uint[] {0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling SetData with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                     hr = _xb.SetData(key, value, new uint[] {0}, new uint[] {0,0} );
                    if (hr != null)
                    {
                        throw new Exception("Calling SetData with key array and expiry arrays different lengths returned unexpected HResult array");
                    }

                     ResultCode = TEST_RESULTS.PASSED;
               }
          }

            [TestCase]
          class N_Parameter_Empty_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    uint[] hrArray;
                    byte[][] keyArray = null;
                    byte[][] keyEmpty = new byte[0][];
                    byte[][] valueArray = null;
                    byte[][] valueEmpty = new byte[0][];
                    
                    CreateKeyValuePair(out key, out value);
                    CreateKeyValueArrayPair(out keyArray, out valueArray);
                    
                    /**** empty key, valid value *****/

                     hr = _xb.SetData(new byte[0], value,0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hr, "Calling setdata with empty key returned "+hr+" instead of E_INVALIDARG");                                      
                    }

                      hrArray = _xb.SetData(keyEmpty, valueArray, new uint[keyEmpty.Length], new uint[keyEmpty.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty key array returned unexpected HResult array");
                     }


                     /***** valid key, empty value ******/
                     hr = _xb.SetData(key, new byte[0],0,0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                         throw new HResultException(hr, "Calling setdata with empty value returned "+hr+" instead of E_INVALIDARG");                        
                    }

                     hrArray = _xb.SetData(keyArray, valueEmpty, new uint[keyArray.Length], new uint[keyArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty value array returned unexpected HResult array");
                     }

                       /***** vaild key, valid value, empty expiries ******/
                      hrArray = _xb.SetData(keyArray, valueArray, new uint[0], new uint[0]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty expiry arrays returned unexpected HResult array");
                     }

                     hrArray = _xb.SetData(keyArray, valueArray, new uint[valueArray.Length], new uint[0]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty sliding expiry array returned unexpected HResult array");
                     }

                     hrArray = _xb.SetData(keyArray, valueArray, new uint[0], new uint[valueArray.Length]);
                     if (hrArray != null)
                     {
                            throw new Exception("Calling setdata with empty absolute expiry array returned unexpected HResult array");   
                     }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

          [TestCase]
          class N_Key_SizeTooLong : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint hr;
                    byte[] key = null;
                    byte[] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);
                    
                    CreateKeyValuePair(out key, out value);

                    /***** key size too long, valid value *****/
                    byte[] keyTooLong =  new byte[_maxKeyLength + 1];
                    //fill key with some random values.
                    _random.NextBytes(keyTooLong);

                     hr = _xb.SetData(keyTooLong, value, 0, 0);
                    if (hr != HResult.E_INVALIDARG) 
                    {
                          throw new HResultException(hr, "Calling Insert with 129 byte key returned "+hr+" instead of E_INVALIDARG");             
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }

                 [TestCase]
          class N_KeyArray_Invalid_Cases : XBancFuncTestBase
          {

               override protected void Execute()
               {
                    uint[] hrArray;
                    byte[][] key = null;
                    byte[][] value = null;
                    int _maxKeyLength = (int)Config.GetUIntSetting(Setting.xbanc_max_key_length);

                    /********* KEY CASES **************/
                    
                    //key[0] = null;
                    key = new byte[1][];
                    key[0] = null;
                    value = new byte[][] {new byte[]{1}};
                    
                    hrArray = _xb.SetData(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling SetData with null key first value returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling setdata with null key first value returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    //key[0] = invalid key, key[1] = valid key w/o reservation, key[2] = invalid key
                    key = new byte[3][];
                    key[0] = new byte[_maxKeyLength + 1];   //key size too long
                    key[1] = new byte[]{2,3,4,5};                   //insert without reservation
                    key[2] = null;                                          //null key
                    value = new byte[][] {new byte[]{1}, new byte[]{3}, new byte[]{5}};      //just random data

                    hrArray = _xb.SetData(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling setdata with null first key array returned unexpected HResult array");
                    }
                    if (hrArray[0] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[0], "Calling setdata with key size too long returned "+hrArray[0]+" instead of E_INVALIDARG");                           
                    }
                    if (hrArray[1] != HResult.S_OK) 
                    {
                        throw new HResultException(hrArray[1], "Calling setdata returned "+hrArray[1]+" instead of S_OK");                           
                    }
                    if (hrArray[2] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[2], "Calling setdata with null key returned "+hrArray[2]+" instead of E_INVALIDARG");                           
                    }

                    /**** VALUE CASES  *****/
                    key = new byte[][] {new byte[]{1}, new byte[]{2}};
                    value = new byte[2][];
                    value[0] = new byte[] {33};
                    value[1] = null;
                    hrArray = _xb.SetData(key, value, new uint[key.Length], new uint[key.Length]);
                    if (hrArray == null)
                    {
                        throw new Exception("Calling setdata with null second value array returned unexpected HResult array");
                    }
                    if (hrArray[1] != HResult.E_INVALIDARG) 
                    {
                        throw new HResultException(hrArray[1], "Calling setdata with null second value array returned "+hrArray[1]+" instead of E_INVALIDARG");                           
                    }

                    ResultCode = TEST_RESULTS.PASSED;
               }
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\Func\XBANCTest.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using xonline.common.diagnostics;
using xonline.common.config;
using xonline.common.service;

[assembly: RootNode(typeof(XBANCTest.XBANCTest))]

namespace XBANCTest
{
    [Owner("KKline"),TestFrequency("Regression"),TestCasePriority(3)]
    public class XBANCTest : TestNode
	{
		public XBANCTest()
		{
            AddChild(new XBancFuncIncrement());
            AddChild(new XBancFuncInsert());
            AddChild(new XBancFuncQuery());
            AddChild(new XBancFuncRemove());
            AddChild(new XBancFuncSequence());
            AddChild(new XBancFuncSetData());
            AddChild(new XBancFuncHighVolume());
            AddChild(new XBancFuncMRU());
            AddChild(new XBancFuncMulti());
            AddChild(new XBancFuncLocalCache());
        }

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            XBancStressManager.Initialize(Global.Config);
        }
    }

        public class XBancFuncTestBase : TestBase
        {
            protected override void Execute()
            {
                throw new Exception("Execute: The method or operation is not implemented.");
            }

            protected ASCIIEncoding _enc = new ASCIIEncoding();
            protected int _incrementValueSize = 20;
            protected string _keyPrefix = "Test";
            protected uint _maxUInt = 4294967295;
            protected ulong _maxULong = 18446744073709551615;
            protected RandomEx _random = new RandomEx();
            protected Report _report = new Report("Log");
            protected uint _reservationExpirySeconds = 60;
            protected XBanc _xb = new XBanc();

            //creates and returns random length and random filled byte[] key and value 
          protected void CreateKeyAmountPair(out byte[] key, out ulong amount)
          {
                int prefixLength = _keyPrefix.Length;
               //create a random length (between 1-128 bytes) key filled with random values, prepended by common prefix 
               byte[] prefix = _enc.GetBytes(_keyPrefix);
               //create random postfix
               byte[] postfix = new byte[_random.Next(1,129-prefixLength)];
               _random.NextBytes(postfix);
                //combine prefix and postfix into key
               key = new byte[prefix.Length + postfix.Length];
              Array.Copy(prefix, 0, key, 0, prefixLength);
              Array.Copy(postfix,0, key , prefixLength, postfix.Length);

               //create a random amount (between 0-MAX_ULONG) 
               amount = (uint) _random.Next(0,999999999);
          }
          protected void CreateKeyAmountArrayPair(out byte[][] key, out ulong[] amount)
          {
                int length = _random.Next(1,25);
                key = new byte[length][];
                amount = new ulong[length];
                for(int i=0; i<length; i++)
                {
                    CreateKeyAmountPair(out key[i], out amount[i]);
                }
          }
          
             //creates a one byte key[] that maps to the same server
          protected byte[][] CreateKeyArrayThatMapsToSameServer(int numKeys)
          {
                //we need each key to map to the same server. to do this we need the bucket map.
                // first get the servers.
                string[] serverList = Config.GetServerListByInterface(Interface.xbanc);

                // now we have to make the bucket map. 
                uint numBuckets = Config.GetBucketCount(Interface.xbanc);
                int[] bucketMap = new int[numBuckets];

                for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                {
                    bucketMap[iBucket] = -1;

                    IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)iBucket);
                    // find this bucket's server in the list of servers
                    for (int iServer = 0; iServer < serverList.Length; iServer++)
                    {
                         if (b.CurrentServerName == serverList[iServer])
                         {
                              // found it.
                              bucketMap[iBucket] = iServer;
                              break;
                         }
                    }
                }

                //create the uNumValues keys that all map to same server
                byte[][] keyArray = new byte[numKeys][];
                byte keyStart= 1;
                keyArray[0] = new byte[] {1};
                for(int i=1; i<numKeys; i++)
                {
                    //make sure the rest of the keys map to the first key's server
                    keyStart++;       
                    keyArray[i] = new byte[] {keyStart};
                    while(keyStart !=1 && bucketMap[HashKeyToBucket(keyArray[i])] != bucketMap[HashKeyToBucket(keyArray[0])])
                    {
                        keyStart++;
                        keyArray[i][0] = keyStart;  
                        
                    }
                    if (keyStart == 0)
                    {
                        //not enough keys to run this test. return
                        _report.Warn("Could not find enough keys to run this test.");
                        return null;
                    }

                }
                return keyArray;
          }

           //creates a one byte key[] that maps to the same server
          protected byte[][] CreateKeyArrayThatMapsToDifferentServers(int numKeys)
          {
                // we need the bucket map.
                // first get the servers.
                string[] serverList = Config.GetServerListByInterface(Interface.xbanc);
                string[] serversWithBuckets = new string[serverList.Length];
                int serversWithBucksLength = 0;
                // now we have to make the bucket map. 
                uint numBuckets = Config.GetBucketCount(Interface.xbanc);
                int[] bucketMap = new int[numBuckets];

                for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                {
                    bucketMap[iBucket] = -1;

                    IBucketServer b = Config.GetBucketServer(Interface.xbanc, (uint)iBucket);
                    // find this bucket's server in the list of servers
                    for (int iServer = 0; iServer < serverList.Length; iServer++)
                    {
                         if (b.CurrentServerName == serverList[iServer])
                         {
                              // found it.
                              bucketMap[iBucket] = iServer;
                              //but it in the serverswithbuckets array, if not already there
                              for(int i=0; i<serversWithBuckets.Length; i++)
                              {
                                    if(serversWithBuckets[i] == null)
                                    {
                                        serversWithBuckets[i] = b.CurrentServerName;
                                        serversWithBucksLength++;
                                        break;
                                    }
                                    if(serversWithBuckets[i] == b.CurrentServerName)
                                    {
                                        break;
                                    }
                              }
                              break;
                         }
                    }
                }
                    
                //create the uNumValues keys that all map to same server
                byte[][] keyArray = new byte[numKeys][];
                if (numKeys > serversWithBucksLength)
                {
                    _report.Warn("There are not enough servers to fufill this request! #Servers = "+serversWithBucksLength+", #keys requested ="+numKeys);
                    for(int i=0; i<numKeys; i++)
                    {
                        keyArray[i] = CreateKey();
                    }
                }
                else
                {
                    //try this numKeys * numberofservers
                    for(int i=0; i<numKeys; i++)
                    {
                        int tries = 0;
                        while (tries < numKeys * serversWithBucksLength * numKeys)
                        {
                            byte[] candidate = CreateKey();
                            //map key to server
                            string server = serverList[bucketMap[HashKeyToBucket(candidate)]];
                            //see if we already have this one
                            for(int j=0; j<serversWithBucksLength; j++)
                            {
                                if (serversWithBuckets[j] == server)
                                {
                                    keyArray[i] = candidate;
                                    serversWithBuckets[j] = "done";
                                    tries += numKeys * serversWithBucksLength * numKeys;
                                }
                            }
                            tries++;
                        }
                        if (keyArray[i] == null)
                        {
                            _report.Warn("Couldn't find suitable keys that mapped to different servers. returning random key.");
                            keyArray[i] = CreateKey();
                        }
                    }
                }
                
                
                return keyArray;
          }

            protected byte[][] CreateKeyArrayThatMapsToSameBucket(int numKeys, uint bucketNum)
            {
                byte[][] keyArray = new byte[numKeys][];
                byte firstDigit = 0, secondDigit = 0, thirdDigit = 0;
                bool useSecond = false, useThird = false;
                while (numKeys!=0)
                {
                    byte[] tempKey=null;
                    if (useSecond == false && useThird == false)
                         tempKey = new byte[] {firstDigit};
                    if (useSecond && useThird == false)
                        tempKey = new byte[] {firstDigit, secondDigit};
                    if (useSecond && useThird)
                        tempKey = new byte[] {firstDigit, secondDigit, thirdDigit};
                    
                    if (HashKeyToBucket(tempKey) == bucketNum)
                    {
                         keyArray[numKeys - 1] = tempKey;
                         numKeys--;
                    }
                    if (firstDigit == 255 && secondDigit == 255 && thirdDigit == 255) return null;
                    if (firstDigit == 255 && secondDigit == 255) { thirdDigit ++; useThird = true;}
                    if (firstDigit == 255) {secondDigit ++; useSecond = true;}

                    firstDigit ++;
                }
                return keyArray;
            }
           
            //creates and returns random length and random filled byte[] key and value 
            protected void CreateKeyValuePair(out byte[] key, out byte[] value)
            {
                int prefixLength = _keyPrefix.Length;
                //create a random length (between 1-128 bytes) key filled with random values, prepended by common prefix 
                byte[] prefix = _enc.GetBytes(_keyPrefix);
                //create random postfix
                byte[] postfix = new byte[_random.Next(1,129-prefixLength)];
                _random.NextBytes(postfix);
                //combine prefix and postfix into key
                key = new byte[prefix.Length + postfix.Length];
                Array.Copy(prefix, 0, key, 0, prefixLength);
                Array.Copy(postfix,0, key , prefixLength, postfix.Length);

                //create a random length (between 1-1024*1024 bytes) key filled with random values 
                value = new byte[_random.Next(1,64*1024)];
                _random.NextBytes(value);
            }

            protected void CreateKeyValueArrayPair(out byte[][] key, out byte[][] value)
            {
                int length = _random.Next(1,25);
                key = new byte[length][];
                value = new byte[length][];
                for(int i=0; i<length; i++)
                {
                    CreateKeyValuePair(out key[i], out value[i]);
                }
            }
            
            //creates and returns random length and random filled byte[] key 
            protected byte[] CreateKey()
            {
                int prefixLength = _keyPrefix.Length;
                //create a random length (between 1-128 bytes) key filled with random values, prepended by common prefix 
                byte[] prefix = _enc.GetBytes(_keyPrefix);
                //create random postfix
                byte[] postfix = new byte[_random.Next(1,129-prefixLength)];
                _random.NextBytes(postfix);
                //combine prefix and postfix into key
                byte[] key = new byte[prefix.Length + postfix.Length];
                Array.Copy(prefix, 0, key, 0, prefixLength);
                Array.Copy(postfix,0, key , prefixLength, postfix.Length);

                return key;
            }
            protected byte[] CreateKey(int size)
            {
                byte[] key;
                 //create key
                int prefixLength = _keyPrefix.Length;
                 byte[] prefix = _enc.GetBytes(_keyPrefix);
                //create random postfix
                byte[] postfix = new byte[size-prefixLength];
                _random.NextBytes(postfix);
                //combine prefix and postfix into key
                key = new byte[prefix.Length + postfix.Length];
                Array.Copy(prefix, 0, key, 0, prefixLength);
                Array.Copy(postfix,0, key , prefixLength, postfix.Length);
                
                return key;
            }
            
              //creates and returns  random length (between 1-1024*1024 bytes) key filled with random values 
            protected byte[] CreateValue()
            {
                byte[] value = new byte[_random.Next(1,64*1024)];
                _random.NextBytes(value);

                return value;
            }

            protected uint HashKeyToBucket(byte[] key)
            {
                uint sum = 0;
                for (int i = 0; i < key.Length; i++)
                {
                    sum += (uint)key[i];
                }

                return sum % 420;
            }
            
            protected void Increment(byte[] key, ulong amount)
            {
                Increment(key, amount, amount, HResult.S_FALSE);
            }
            protected void Increment(byte[][] key, ulong[] amount)
            {
                uint[] expectedHR = new uint[key.Length];
                for(int i=0; i<key.Length; i++)
                {
                    expectedHR[i] = HResult.S_FALSE;
                }
                Increment(key, amount, amount, expectedHR);
            }
            protected void Increment(byte[] key, ulong amount, ulong expectedAmount, uint expectedResult)
            {
                Increment(key, amount, XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE, 0, 0, expectedAmount, expectedResult);
            }
             protected void Increment(byte[][] key, ulong[] amount, ulong[] expectedAmount, uint[] expectedResult)
            {
                uint[] halfLifeSeconds = new uint[key.Length];
                for(int i=0; i<key.Length; i++)
                {
                    halfLifeSeconds[i] = XBancDefs.XBANC_INCREMENT_HALFLIFE_INFINITE;
                }
                Increment(key, amount, halfLifeSeconds, new uint[key.Length], new uint[key.Length], expectedAmount, expectedResult);
            }
               protected void Increment(byte[] key, ulong amount, uint halfLifeSeconds, ulong expectedAmount, uint expectedResult)
            {
                Increment(key, amount, halfLifeSeconds, 0, 0, expectedAmount, expectedResult);
            }
            protected void Increment(byte[] key, ulong amount, uint halfLifeSeconds, uint abs, uint slid, ulong expectedAmount, uint expectedResult)
            {
                uint hr;
                ulong result;
                hr = _xb.Increment(key, amount, halfLifeSeconds, abs, slid, out result);
                if (hr != expectedResult)
                {
                    throw new HResultException(hr, "Increment returned "+hr+" instead of "+expectedResult);
                }
                
                ValidateReturnedDecayData(expectedAmount, result, 0.05);  // within 5% is fine
                       
            }
             protected void Increment(byte[][] key, ulong[] amount, uint[] halfLifeSeconds, uint[] abs, uint[] slid, ulong[] expectedAmount, uint[] expectedResult)
            {
                uint[] hr;
                ulong[] result;
                hr = _xb.Increment(key, amount, halfLifeSeconds, abs, slid, out result);
                if (hr == null || hr.Length != key.Length)
                {
                    throw new Exception("Increment returned unexpected HResult array");
                }
                for(int i=0; i<hr.Length; i++)
                {
                    if (hr[i] != expectedResult[i])
                    {
                        throw new HResultException(hr[i] , "Increment returned "+hr[i] +" instead of "+expectedResult[i]);
                    }
                }
                
                ValidateReturnedDecayData(expectedAmount, result, 0.05);  // within 5% is fine
                       
            }
             
            protected void InsertSingleItem(byte[] key, byte[] value)
            {
                InsertSingleItem(key, value, 0, 0);
            }

            //inserts and queries for item for the Simple Test cases then removes the item, returns result of query
            protected void InsertSingleItem(byte[] key, byte[] value, uint abs, uint slid)
            {
                InsertMultipleItems(new byte[][] {key}, new byte[][] {value}, new uint[] {abs}, new uint[] {slid});
                
               /* uint hr;       
                byte[] outvalue = null;

                //call query to make a reservation
                hr = _xb.Query(key, out outvalue);
                if (hr != HResult.S_FALSE)
                {
                    throw new HResultException(hr, "Query returned "+hr+" instead of S_FALSE.");
                }

                //call insert to put the value in the cache
                hr = _xb.Insert(key, value, abs, slid);
                if (hr != HResult.S_OK)
                {
                    throw new HResultException(hr, "Insert returned "+hr+" instead of S_OK.");
                }

                //call query to check/return the value
                hr = _xb.Query(key,  out outvalue);
                if (hr != HResult.S_OK)
                {
                    throw new HResultException(hr, "Query returned "+hr+" instead of S_OK.");
                }

                ValidateReturnedData(value, outvalue);
                */
                
            }

            protected void InsertMultipleItems(byte[][] key, byte[][] value)
            {
                InsertMultipleItems(key, value, new uint[key.Length], new uint[key.Length]);
            }

            //inserts and queries for item for the Simple Test cases then removes the item, returns result of query
            protected void InsertMultipleItems(byte[][] key, byte[][] value, uint[] abs, uint[] slid)
            {
                uint[] hr;       
                byte[][] outvalue = null;
                uint[] outseconds = null;

                //call query to make reservations
                hr = _xb.Query(key, out outvalue, out outseconds);
                if(hr == null)
                {
                    throw new Exception("Query returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != HResult.S_FALSE)
                    {
                        throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of S_FALSE for the "+i+"th key.");
                    }
                }

                //call insert to put the values in the cache
                hr = _xb.Insert(key, value, abs, slid);
                if(hr == null)
                {
                    throw new Exception("Insert returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != HResult.S_OK)
                    {
                        throw new HResultException(hr[i], "Insert returned "+hr[i]+" instead of S_OK for the "+i+"th key.");
                    }
                }

                //call query to check/return the values
                hr = _xb.Query(key, out outvalue, out outseconds);
                if(hr == null)
                {
                    throw new Exception("Query returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != HResult.S_OK)
                    {
                        throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of S_OK for the "+i+"th key.");
                    }
                }

                ValidateReturnedData(value, outvalue);
            }
            protected void RemoveTestHelper(string[] keys, string keyToRemove, string[] keysToCheck, bool matchExact, uint expectedResults)
            {
                uint hr;
                byte[] value = CreateValue();
                //insert barage of keys
                foreach (string key in keys)
                {
                    byte[] b = _enc.GetBytes(key);
                    InsertSingleItem(b, value);
                }
                //remove sKeyToRemove
                hr = _xb.Remove(_enc.GetBytes(keyToRemove), matchExact);
                if (hr != expectedResults)
                {
                    throw new HResultException(hr, "Remove returned "+hr+" instead of "+expectedResults);
                }

                //Query for SKeyToRemove, leave the reservation, should return nothing
                Query(_enc.GetBytes(keyToRemove), null, HResult.S_FALSE);

                foreach (string key in keysToCheck)
                {
                    byte[] b = _enc.GetBytes(key);
                    Query(b, value, HResult.S_OK);

                    Remove(b);
                }
            }

            protected void SetData(byte[] key, byte[] value)
            {
                SetData(key, value, 0, 0);
            }

            protected void SetData(byte[] key, byte[] value, uint abs, uint slid)
            {
                uint hr;       
                byte[] outvalue = null;
             
                //call insert to put the value in the cache
                hr = _xb.SetData(key, value, abs, slid);
                if (hr != HResult.S_OK)
                {
                    throw new HResultException(hr, "Insert returned "+hr+" instead of S_OK.");
                }

                //call query to check/return the value
                hr = _xb.Query(key,  out outvalue);
                if (hr != HResult.S_OK)
                {
                    throw new HResultException(hr, "Query returned "+hr+" instead of S_OK.");
                }

                ValidateReturnedData(value, outvalue);
            }

            protected void SetData(byte[][] key, byte[][] value)
            {
                SetData(key, value, new uint[key.Length], new uint[value.Length]);
            }

            protected void SetData(byte[][] key, byte[][] value, uint[] abs, uint[] slid)
            {
                uint[] hr;       
                byte[][] outvalue = null;
                uint[] seconds;
             
                //call insert to put the value in the cache
                hr = _xb.SetData(key, value, abs, slid);
                if(hr == null || hr.Length !=key.Length)
                {
                    throw new Exception("SetData returned HR results were null when not expected.");                     
                }
                foreach(uint h in hr)
                {
                    if (h != HResult.S_OK)
                    {
                        throw new HResultException(h, "SetData returned "+h+" instead of S_OK.");
                    }
                }

                //call query to check/return the value
                hr = _xb.Query(key,  out outvalue, out seconds);
                if(hr == null || hr.Length !=key.Length)
                {
                    throw new Exception("Query returned HR results were null when not expected.");                     
                }
                foreach(uint h in hr)
                {
                    if (h != HResult.S_OK)
                    {
                        throw new HResultException(h, "Query returned "+h+" instead of S_OK.");
                    }
                }
                for(int i=0; i<value.Length; i++)
                {
                    ValidateReturnedData(value[i], outvalue[i]);
                }
            }

 //SequenceTestHelper goes through each string passed in functions and performs the function, comparing the result with the corresponding expectedValue
            protected void SequenceTestHelper(string[] functions, uint[] expectedValues)
            {
               uint hr;
               //each sequence will use the same key and value
               byte[] key = null;
               byte[] value = null;
               CreateKeyValuePair(out key, out value);
               
               for (int i=0; i<functions.Length; i++)
               {
                    switch(functions[i])
                    {
                         case "Query":
                              Query(key, value, expectedValues[i]);
                              break;
                              
                         case "Insert":
                              hr = _xb.Insert(key, value);
                              if (hr != expectedValues[i])
                              {
                                    throw new HResultException(hr, "Insert returned "+hr+" instead of "+expectedValues[i]);
                              }
                              break;

                         case "Remove":
                              hr = _xb.Remove(key);
                              if (hr != expectedValues[i])
                              {
                                   throw new HResultException(hr, "Remove returned "+hr+" instead of "+expectedValues[i]);
                              }
                              break;

                         case "SetData":
                              hr = _xb.SetData(key,value,0,0);
                              if (hr != expectedValues[i])
                              {
                                   throw new HResultException(hr, "SetData returned "+hr+" instead of "+expectedValues[i]);
                              }
                              break;
                                   
                    }
               }
          }


            //return a string representation of the passed in byte array
            protected string PrintByteArray(byte[] b)
            {
               if (b.Length == 0) return "";

               string sRet = "";
               for (int i = 0; i < b.Length - 1; i++)
               {
                 sRet += b[i].ToString() + ",";
               }
               sRet += b[b.Length - 1].ToString();
               return sRet;
            }

            protected void QueryCheckTime(byte[] key, byte[] expectedValue, uint expectedSeconds, uint expectedResults)
            {
                uint hr;
                byte[] outvalue;
                uint outtime;
                hr = _xb.Query(key,  out outvalue, out outtime);
                if (hr != expectedResults)
                {
                    throw new HResultException(hr, "Query returned "+hr+" instead of "+expectedResults);
                }
                if (expectedValue != null && expectedResults == HResult.S_OK)
                {
                    ValidateReturnedData(expectedValue, outvalue);
                }
                
                ValidateReturnedTime(expectedSeconds, outtime);
            }
            protected void QueryCheckTime(byte[][] key, byte[][] expectedValues, uint[] expectedSeconds, uint[] expectedResults)
            {
                uint[] hr;
                byte[][] outvalue;
                uint[] outtime;
                hr = _xb.Query(key,  out outvalue, out outtime);
                 if(hr == null || hr.Length != expectedResults.Length)
                {
                    throw new Exception("Query returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != expectedResults[i])
                    {
                        throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of "+expectedResults[i]+" for the "+i+"th key.");
                    }
                }
                if (expectedValues != null && outvalue != null)
                {
                     for(int i=0; i< expectedValues.Length; i++)
                    {
                        if(expectedResults[i] == HResult.S_OK)
                        {
                            ValidateReturnedData(expectedValues[i], outvalue[i]);
                        }
                        
                    }
                }
                for(int i=0; i<expectedSeconds.Length; i++)
                {
                    ValidateReturnedTime(expectedSeconds[i], outtime[i]);
                }
                
                
            }

             protected void Query(byte[] key, byte[] expectedValue, uint expectedResults)
            {
                uint hr;
                byte[] outvalue;
                hr = _xb.Query(key,  out outvalue);
                if (hr != expectedResults)
                {
                    throw new HResultException(hr, "Query returned "+hr+" instead of "+expectedResults);
                }
                if (expectedValue != null && expectedResults == HResult.S_OK)
                {
                    ValidateReturnedData(expectedValue, outvalue);
                }
            }

            protected void Query(byte[][] key, byte[][] expectedValues, uint[] expectedResults)
            {
                uint[] hr;
                byte[][] outvalue;
                uint[] outseconds = null;
                hr = _xb.Query(key,  out outvalue, out outseconds);
                if(hr == null || hr.Length !=expectedResults.Length)
                {
                    throw new Exception("Query returned results were null when not expected.");                     
                }
                for(int i=0; i< hr.Length; i++)
                {
                    if (hr[i] != expectedResults[i])
                    {
                        throw new HResultException(hr[i], "Query returned "+hr[i]+" instead of "+expectedResults[i]+" for the "+i+"th key.");
                    }
                }
                if (expectedValues != null && outvalue != null)
                {
                     for(int i=0; i< expectedValues.Length; i++)
                    {
                        if(expectedResults[i] == HResult.S_OK)
                        {
                            ValidateReturnedData(expectedValues[i], outvalue[i]);
                        }
                    }
                }
            }

            protected void Remove(byte[] key)
            {
               Remove(key, true);
            }

             protected void Remove(byte[] key, bool matchExact)
            {
                uint hr;
                hr = _xb.Remove(key, matchExact);
                if (hr != HResult.S_OK)
                {
                    throw new HResultException(hr, "Remove returned "+hr+" instead of S_OK.");
                }
            }
            protected void Remove(byte[][] key)
            {
                uint[] hr;
                hr = _xb.Remove(key);
                if(hr == null)
                {
                    throw new Exception("Remove returned results were null when not expected.");                     
                }
                foreach(uint h in hr)
                {
                    if (HResult.Failed(h))
                    {
                        throw new HResultException(h, "Remove returned "+h+" instead of S_OK or S_FALSE.");
                    }
                }
            }

            protected void ValidateReturnedData(byte[] value, byte[] outValue)
            {
                Assert.IsTrue(XBanc.CompareByteArrays(value, outValue), "Returned value was not expected");
            }
            
            protected void ValidateReturnedData(ulong value, ulong outValue)
            {
                Assert.IsTrue(value == outValue, "Returned Increment value was not expected");
            }

            protected void ValidateReturnedDecayData(ulong value, ulong outValue, double tolerance)
            {
                _report.Debug("ValidateReturnedData[ulong]: Expecting {0}, got {1}, +/-{2}%", value, outValue, tolerance * 100);
                ulong diff = (ulong)Math.Abs((float)(value - outValue));
                ulong bumper = (ulong)(value * tolerance);
                Assert.IsTrue(diff <= bumper, "Returned Increment value was not expected (outside tolerance)");
            }
            
            protected void ValidateReturnedDecayData(ulong[] value, ulong[] outValue, double tolerance)
            {
                Assert.IsTrue(value.Length == outValue.Length, "Returned values were not expected");
                for(int i=0; i<value.Length; i++)
                {
                    ValidateReturnedDecayData(value[i], outValue[i], tolerance);
                }
            }
              protected void ValidateReturnedData(byte[][] value, byte[][] outValue)
            {
                Assert.IsTrue(value.Length == outValue.Length, "Returned values were not expected");
                for(int i=0; i<value.Length; i++)
                {
                    ValidateReturnedData(value[i], outValue[i]);
                }
            }

            protected void ValidateReturnedTime(uint expectedSeconds, uint outtime)
            {
                Assert.IsTrue(WithinTolerableRange(expectedSeconds,outtime), "Returned time "+outtime+" was not expected time of "+expectedSeconds);
            }

             //returns true if seconds is within one second of expected second
            protected bool WithinTolerableRange(uint seconds, uint expectedSeconds)
            {
                //tolerable range.
                int tol = 2;
                return (Math.Abs((int)seconds - (int)expectedSeconds) <= tol);
            }

            protected void RunIncrementWithDelayTps(uint halflifeSeconds, double tps, uint secondsToRun)
            {
                byte[] key = null;
                ulong amount = 0;
                ulong result;

                ulong incAmount = 1;
                double periodSeconds = 1.0 / tps;

                CreateKeyAmountPair(out key, out amount);

                // Start at 1.. large values won't catch rounding errors as easily
                amount = 1;
                Increment(key, amount);

                double newAmount = amount;
                for(int i=0; i < secondsToRun * tps; i++)
                {
                    DateTime now = DateTime.Now;
                    System.Threading.Thread.Sleep((int)(periodSeconds * 1000));
                    double secondsPassed = (DateTime.Now - now).TotalSeconds;
                    //compute new amount
                    newAmount = incAmount + newAmount * Math.Pow(2, -secondsPassed / (double)halflifeSeconds);

                    // custom increment call and verification
                    uint hr = _xb.Increment(key, incAmount, halflifeSeconds, 0, 0, out result);
                    if (hr != HResult.S_OK)
                    {
                        throw new HResultException(hr, "Increment returned "+hr+" instead of 0");
                    }

                    _report.Debug("Expecting {0} ({1}), got {2}", (ulong)newAmount, newAmount, result);
                    if (result != (ulong)newAmount)
                    {
                        if (Math.Abs((float)((ulong)newAmount - result)) <= 2)
                        {
                            _report.Debug("Off by one or two (ok)");
                        }
                        else
                        {
                            Assert.IsTrue(result == (ulong)newAmount, "Returned Increment value was not expected");
                        }
                    }
                }

                //remove for cleanup
                Remove(key);
                ResultCode = TEST_RESULTS.PASSED;
            }



        }
        /*public class XBANCTest : TestSuite
          {
          override public TestBaseGroupList GetTests()
          {
          TestBaseGroupList tests = new TestBaseGroupList();
          tests.Add(new XBANCFuncInsert());
          tests.Add(new XBANCFuncQuery());
          tests.Add(new XBANCFuncRemove());
          tests.Add(new XBANCFuncSetData());
          tests.Add(new XBANCFuncIncrement());
          tests.Add(new XBANCFuncSequence());
          tests.Add(new XBANCFuncHighVolume());
          tests.Add(new XBANCFuncMRU());
          return tests;
          }
          override public StressTestBaseList GetStressTests()
          {
          StressTestBaseList tests = new StressTestBaseList();
          tests.Add(typeof(XBancStressInsertSmallValue),6);
          tests.Add(typeof(XBancStressInsertMediumValue),4);
          tests.Add(typeof(XBancStressInsertLargeValue),3);
          tests.Add(typeof(XBancStressSetDataSmallValue),8);
          tests.Add(typeof(XBancStressSetDataMediumValue),2);
          tests.Add(typeof(XBancStressSetDataLargeValue),1);
          tests.Add(typeof(XBancStressSetDataExistingKey),4);
          tests.Add(typeof(XBancStressQueryForSmallValue),11);
          tests.Add(typeof(XBancStressQueryForMediumValue),8);
          tests.Add(typeof(XBancStressQueryForLargeValue),8);
          tests.Add(typeof(XBancStressQueryForExpiredKey),8);
          tests.Add(typeof(XBancStressQueryForNonExpiredValue),10);
          tests.Add(typeof(XBancStressIncrementCreateNew),10);
          tests.Add(typeof(XBancStressIncrementExisting),10);
          tests.Add(typeof(XBancStressRemoveOneValue),2);
          tests.Add(typeof(XBancStressRemovePrefix),1);
          tests.Add(typeof(XBancStressInsertExisitingKey),2);
          tests.Add(typeof(XBancStressQueryNonExisitingKey),2);
          tests.Add(typeof(XBancStressRemoveNonExisitingKey),2);

          return tests;
          }


          }*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\Test\StressLargeClient\XBancStressLargeLITE.cs ===
using System;
using ServerTestFramework;

[assembly: RootNode(typeof(XBANCTest.XBancStressLITE))]

namespace XBANCTest
{
    [Owner("KKline"),TestFrequency("Regression")]
    public class XBancStressLITE : TestNode
    {
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            XBancStressManager.Initialize(Global.Config);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xbanc\xbancmgr\main.cs ===
using System;
using System.Globalization;
using System.Collections;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;


public class XBancMgr
{    
    public static XBanc _xb = new XBanc();
    
    public static bool CompareBytes(byte[] rgb1, byte[] rgb2)
    {
        if (rgb1 == rgb2) return true;

        if ((rgb1 == null) || (rgb2 == null)) return false;

        if (rgb1.Length != rgb2.Length) return false;

        for (int i = 0; i < rgb1.Length; i++)
        {
            if (rgb1[i] != rgb2[i]) return false;
        }

        return true;
    }

    public static void DisplayBytes(byte[] rgb)
    {
        if (rgb == null) return;

        uint iLineStart = 0;
        uint dwSize = (uint)rgb.Length;

        while (dwSize > 0)
        {
            for (uint iByte = 0; iByte < 16; iByte++)
            {
                if (iByte == 8)
                {
                    Console.Write("   ");
                }
                if (iLineStart + iByte >= rgb.Length)
                {
                    Console.Write("   ");
                }
                else
                {
                    Console.Write(" " + (rgb[iLineStart + iByte] >> 4).ToString("X") + (rgb[iLineStart + iByte] & 0xF).ToString("X"));
                }
            }

            Console.Write("  ||  ");

            for (uint iByte = 0; iByte < 16; iByte++)
            {
                if (iByte == 8)
                {
                    Console.Write("  ");
                }
                if (iByte < dwSize)
                {
                    Console.Write(((rgb[iLineStart + iByte] >= 32) && (rgb[iLineStart + iByte] < 126)) ? (char)rgb[iLineStart + iByte] : '.');
                }
            }

            Console.Write("\r\n");

            if (dwSize < 16)
            {
                break;
            }

            iLineStart += 16;
            dwSize -= 16;
        }
    }
           
    public static byte[] ParseByteArray(string sBytes)
    {
        if ((sBytes == null) || (sBytes.Length == 0))
        {
            return new byte[0];
        }
        
        ArrayList alBytes = new ArrayList();

        for (int iChar = 0; iChar < sBytes.Length; iChar++)
        {
            if (sBytes[iChar] == '~')
            {
                int hex = Int32.Parse(sBytes.Substring(iChar + 1, 2), NumberStyles.AllowHexSpecifier);
                alBytes.Add((byte)hex);
                iChar += 2;
            }
            else
            {
                alBytes.Add((byte)sBytes[iChar]);
            }
        }

        byte[] rgb = new byte[alBytes.Count];
        for (int iByte = 0; iByte < rgb.Length; iByte++)
        {
            rgb[iByte] = (byte)alBytes[iByte];
        }

        return rgb;
    }

    public static void DoSetDataByKey()
    {
        Console.Write("Enter Key ('~' for escape char): ");
        string sKey = Console.ReadLine();
        byte[] rgbKey = ParseByteArray(sKey);
        Console.Write("Enter Value ('~' for escape char): ");
        string sValue = Console.ReadLine();
        byte[] rgbValue = ParseByteArray(sValue);
        Console.Write("Enter Absolute Expiry (seconds, 0 = infinite): ");
        uint dwAbsolute = Convert.ToUInt32(Console.ReadLine());
        Console.Write("Enter Sliding Expiry (seconds, 0 = infinite): ");
        uint dwSliding = Convert.ToUInt32(Console.ReadLine());

        HResult hr = _xb.SetData(rgbKey, rgbValue, dwAbsolute, dwSliding);
        Console.WriteLine("SetData() returned hr = " + hr);
    } 

    public static void DoRemoveByKey()
    {
        Console.Write("Enter Key ('~' for escape char): ");
        string sKey = Console.ReadLine();
        byte[] rgbKey = ParseByteArray(sKey);

        HResult hr = _xb.Remove(rgbKey);
        Console.WriteLine("Remove() returned hr = " + hr);
    } 

    public static void DoViewByKey()
    {
        Console.Write("Enter Key ('~' for escape char): ");
        string sKey = Console.ReadLine();
        byte[] rgbKey = ParseByteArray(sKey);

        byte[] rgbValue;
        HResult hr = _xb.Query(rgbKey, out rgbValue);
        Console.WriteLine("Query() returned hr = " + hr);
        DisplayBytes(rgbValue);
    } 
    public static void DoRemoveByPrefix()
    {
        Console.WriteLine("WARNING: This is dangerous if large numbers of keys match the prefix.  Be careful with the prefix!");
        Console.Write("Enter Key Prefix ('~' for escape char): ");
        string sKey = Console.ReadLine();
        byte[] rgbKey = ParseByteArray(sKey);

        HResult hr = _xb.Remove(rgbKey, false);
        Console.WriteLine("Remove() returned hr = " + hr);
    } 

    public static void DoSetProfileSetting()
    {
        Console.Write("Enter UserID (decimal): ");
        ulong qwUserID = Convert.ToUInt64(Console.ReadLine());
        Console.Write("Enter TitleID (decimal): ");
        uint dwTitleID = (uint)Convert.ToInt32(Console.ReadLine());
        Console.Write("Enter SettingID (decimal): ");
        uint dwSettingID = (uint)Convert.ToInt32(Console.ReadLine());
        byte[] rgbKey = ProfileDefs.BuildXBancKey(dwSettingID, dwTitleID, qwUserID);

        Console.Write("Enter Value ('~' for escape char): ");
        string sValue = Console.ReadLine();
        byte[] rgbValue = ParseByteArray(sValue);

        HResult hr = _xb.SetData(rgbKey, rgbValue, 0, 0);
        Console.WriteLine("SetData() returned hr = " + hr);
    } 

    public static void DoRemoveProfileSetting()
    {
        Console.Write("Enter UserID (decimal): ");
        ulong qwUserID = Convert.ToUInt64(Console.ReadLine());
        Console.Write("Enter TitleID (decimal): ");
        uint dwTitleID = (uint)Convert.ToInt32(Console.ReadLine());
        Console.Write("Enter SettingID (decimal): ");
        uint dwSettingID = (uint)Convert.ToInt32(Console.ReadLine());
        byte[] rgbKey = ProfileDefs.BuildXBancKey(dwSettingID, dwTitleID, qwUserID);

        HResult hr = _xb.Remove(rgbKey);
        Console.WriteLine("Remove() returned hr = " + hr);
    } 

    public static void DoViewProfileSetting()
    {
        Console.Write("Enter UserID (decimal): ");
        ulong qwUserID = Convert.ToUInt64(Console.ReadLine());
        Console.Write("Enter TitleID (decimal): ");
        uint dwTitleID = (uint)Convert.ToInt32(Console.ReadLine());
        Console.Write("Enter SettingID (decimal): ");
        uint dwSettingID = (uint)Convert.ToInt32(Console.ReadLine());
        byte[] rgbKey = ProfileDefs.BuildXBancKey(dwSettingID, dwTitleID, qwUserID);

        byte[] rgbValue;
        HResult hr = _xb.Query(rgbKey, out rgbValue);
        Console.WriteLine("Query() returned hr = " + hr);
        DisplayBytes(rgbValue);
    } 

    
    
    public static int GetMainMenuSelection()
    {
        Console.WriteLine("");
        Console.WriteLine("XBanc Manager Main Menu:");
        Console.WriteLine("");
        Console.WriteLine("\t 1 - View Data by Key");
        Console.WriteLine("\t 2 - Set Data by Key");
        Console.WriteLine("\t 3 - Remove Data by Key");
        Console.WriteLine("\t 4 - Bulk Remove Data by Key Prefix");
        Console.WriteLine("");
        Console.WriteLine("\t 5 - View Profile Data by Title+User+Setting");
        Console.WriteLine("\t 6 - Set Profile Data by Title+User+Setting");
        Console.WriteLine("\t 7 - Remove Profile Data by Title+User+Setting");
        Console.WriteLine("");
        Console.WriteLine("\t 0 - Quit");
        Console.WriteLine("");
        Console.Write("> ");
        return Convert.ToInt32(Console.ReadLine());
    }

    public static void ShowMainMenu()
    {
        while (true)
        {
            int iSelection = GetMainMenuSelection();
            switch (iSelection)
            {
                case 0:
                    return;
                    
                case 1:
                    DoViewByKey();
                    break;

                case 2:
                    DoSetDataByKey();
                    break;

                case 3:
                    DoRemoveByKey();
                    break;

                case 4:
                    DoRemoveByPrefix();
                    break;

                case 5:
                    DoViewProfileSetting();
                    break;

                case 6:
                    DoSetProfileSetting();
                    break;

                case 7:
                    DoRemoveProfileSetting();
                    break;

                default:
                    Console.WriteLine("Invalid selection.");
                    break;
            }
        }
    }

    public static void Main()
    {
        ShowMainMenu();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\Connection.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Net;
using System.Net.Sockets;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

using System.Threading;
using xonline.common.config;

using MS.Msn.Messenger.Runtime;


namespace xonline.server.XCache
{
    public class ClientConnection
    {
        private TcpStream m_stream = null;

        private int m_cbReceiveBuffer = 0;
        private byte[] m_rgbReceive = null;
        private int m_cbReadUsed = 0;
        private bool m_fDisconnectTriggered = false;
        private int m_cPendingSends = 0;

        public UserRequestContext m_ctxPending;

        private string m_ipAddress = null;
        public string IPAddress
        {
            get 
            {
                if (m_ipAddress == null)
                {
                    try
                    {
                        m_ipAddress = m_stream.IPAddress.ToString() + ":" + m_stream.Port.ToString();
                    }
                    catch (Exception)
                    {
                        m_ipAddress = null;
                    }
                }
                return m_ipAddress;
            }
        }

        public uint IPAddressDword
        {
            get
            {
                try
                {
                    return (uint)System.Net.IPAddress.NetworkToHostOrder((int)ConfigUtil.IpAddressToDword(m_stream.IPAddress));
                }
                catch (Exception)
                {
                    return 0;
                }
            }
        }
        public ushort IPPort
        {
            get
            {
                try
                {
                    return m_stream.Port;
                }
                catch (Exception)
                {
                    return 0;
                }
            }
        }

        ClientConnection(TcpStream stream)
        {
            m_stream = stream;
            m_cbReceiveBuffer = 2 * Config.GetIntSetting(Setting.XCache_SocketBufferSize);
            m_rgbReceive = new byte[m_cbReceiveBuffer];
        }
        
        public static void OnConnect(Object sender, TcpStream stream)
        {
            ClientConnection newClient = new ClientConnection(stream);
            stream.Disconnected += newClient.OnDisconnect;
            
            IAsyncResult arRead = stream.BeginRead(
                newClient.m_rgbReceive, 
                0, 
                newClient.m_cbReceiveBuffer, 
                newClient.OnRead, 
                newClient);

            Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_HIGH, "Connection from: " + newClient.IPAddress);
            XCacheService.Instance.Log("|", "SocketConnect", newClient.IPAddress);
            XCacheCounters.Current.NumConnections.Increment();
            XCacheCounters.Current.ConnectRate.Increment();
        }

        public void OnDisconnect(TcpStream sender, Exception reason)
        {
            m_fDisconnectTriggered = true;
            XCacheCounters.Current.NumConnections.Decrement();

            Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_HIGH, "Disconnected client at " + IPAddress + ".  Reason: " + ((reason == null) ? "{null}" : reason.ToString()));
            XCacheService.Instance.Log("|", "SocketDisconnect", IPAddress, reason);

            // move this to another thread so not to block the IO threads.
            ClientDisconnectContext ctx = new ClientDisconnectContext(this);
            XCacheEngine.QueueContext(ThreadType.eWorker, ctx, null);
        }

        public void OnRead(IAsyncResult ar)
        {
            Debug.Assert(this == (ClientConnection)ar.AsyncState);

            int cbRead = 0;

            try
            {
                // read the bytes delivered.
                cbRead = m_stream.EndRead(ar);
            }
            catch (SocketException se)
            {
                // EndRead can throw a socket exception and not disconnect.
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, IPAddress + ": " + se.ToString());
                DisconnectSocket();
                return;
            }

            // is this a disconnection?
            if (cbRead == 0)
            {
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, IPAddress + ": read 0 bytes.");
                DisconnectSocket();
                return;
            }

            m_cbReadUsed += cbRead;

            try
            {
                // try to parse a message.
                int dwConsumed = XCacheEngine.ConsumeUserRequestBytes(m_rgbReceive, m_cbReadUsed, this);

                if (dwConsumed > 0)
                {
                    Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_LOW, IPAddress + ": message received ( " + dwConsumed + " bytes).");
                    
                    // shift any left over bytes
                    System.Buffer.BlockCopy(m_rgbReceive, dwConsumed, m_rgbReceive, 0, m_cbReadUsed - dwConsumed);
                    m_cbReadUsed -= dwConsumed;
                }
            }
            catch (Exception)
            {
                DisconnectSocket();
                return;
            }

            IAsyncResult arRead = m_stream.BeginRead(
                m_rgbReceive, 
                m_cbReadUsed, 
                m_cbReceiveBuffer - m_cbReadUsed, 
                OnRead, 
                this);
        }

        public void OnWrite(IAsyncResult ar)
        {
            byte[] rgbBuffer = (byte[])ar.AsyncState;

            try
            {
                m_stream.EndWrite(ar);
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_LOW, IPAddress + ": message sent.");

                if ((Interlocked.Decrement(ref m_cPendingSends) <= 0) && m_fDisconnectTriggered)
                {
                    DisconnectSocket();
                }
            }
            catch (SocketException se)
            {
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, IPAddress + ": " + se.ToString());
                DisconnectSocket();
            }
        }

        public void Disconnect()
        {
            m_fDisconnectTriggered = true;
            if (m_cPendingSends == 0)
            {
                DisconnectSocket();
            }
        }

        protected void DisconnectSocket()
        {
            Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, IPAddress + ": Disconnect() called.");

            // close the socket.
            m_stream.Close();
            m_rgbReceive = null;
            m_cbReadUsed = 0;
        }

        public void Send(byte[] rgbBuffer)
        {
            Send(rgbBuffer, rgbBuffer.Length);
        }
        public void Send(byte[] rgbBuffer, int cbSend)
        {
            if (m_fDisconnectTriggered)
            {
                // we're shutting down.  no more sends go.
                return;
            }
            
            Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_LOW, IPAddress + ": sending message (" + rgbBuffer.Length + "bytes).");

            Interlocked.Increment(ref m_cPendingSends);

            IAsyncResult arWrite = m_stream.BeginWrite(
                rgbBuffer,
                0,
                cbSend,
                OnWrite,
                rgbBuffer);
        }
    }

    public class ClientDisconnectContext : XCacheContext
    {
        private ClientConnection m_cliConn;
        
        public ClientDisconnectContext(ClientConnection cliConn)
        {
            m_cliConn = cliConn;
        }

        protected override void ProcessInternal(Object state)
        {
        }
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\LookupTable.cs ===
using System;
using System.Threading;

namespace xonline.server.XCache
{
    // helper class that implements basic hash table operations.
    public interface IXCacheLookupTableHelper<KeyType, ValueType>
    {
        // determine equality between keys.
        bool Equals(KeyType key1, KeyType key2);

        // calculate hash code for a key.
        int GetHashCode(KeyType key);

        // derive the key from a value.
        KeyType GetKey(ValueType item);

        // modify the KeyType component of the item.
        void SetKey(ValueType item, KeyType key);

        // get the next value from the current value. (values must support being part of a collision chain.)
        ValueType GetNext(ValueType item);

        // set the next value on an existing value. (values must support being part of a collision chain.)
        void SetNext(ValueType item, ValueType next);
    }

    public class XCacheLookupTableLockHandle : IDisposable
    {
        protected XCacheLookupTableBase m_table;
        protected int m_iBucket;
        public int LockToken
        {
            get
            {
                return m_iBucket;
            }
        }

        internal XCacheLookupTableLockHandle(XCacheLookupTableBase table, int iBucket)
        {
            m_table = table;
            m_iBucket = iBucket;
        }
        
        public void Dispose()
        {
            m_table.UnlockBucket(LockToken);
        }
    }

    public class XCacheLookupTableBase
    {
        protected int m_cBuckets;
        protected MonitorLock[] m_rgBucketLocks;

        public int NumBuckets 
        {
            get
            {
                return m_cBuckets;
            }
        }

        // lock a bucket.
        public void LockBucket(int iBucket)
        {
            // lock the bucket.
            m_rgBucketLocks[iBucket].Lock();
        }

        // unlock a bucket.
        public void UnlockBucket(int iBucket)
        {
            // unlock the bucket.
            m_rgBucketLocks[iBucket].Unlock();
        }

    }
    public class XCacheLookupTable<KeyType, ValueType> : XCacheLookupTableBase
    {
        protected ValueType[] m_rgBuckets;
        protected IXCacheLookupTableHelper<KeyType, ValueType> m_helper;
        public IXCacheLookupTableHelper<KeyType, ValueType> Helper
        {
            get
            {
                return m_helper;
            }
        }

        // create a new lookup table with the specified number of buckets.
        public XCacheLookupTable(int cBuckets, IXCacheLookupTableHelper<KeyType, ValueType> helper)
        {
            m_cBuckets = cBuckets;
            m_helper = helper;

            // make the buckets.
            m_rgBuckets = new ValueType[m_cBuckets];

            // make the bucket locks.
            m_rgBucketLocks = new MonitorLock[m_cBuckets];
            for (int iLock = 0; iLock < m_cBuckets; iLock++)
            {
                m_rgBucketLocks[iLock] = new MonitorLock();
            }
        }

        // lock a bucket for use.
        public XCacheLookupTableLockHandle LockItemByKey(KeyType key)
        {
            int iBucket = Hash(key);

            LockBucket(iBucket);

            return new XCacheLookupTableLockHandle(this, iBucket);
        }

        // insert this item into the lookup table.
        public void AddLookupItem(XCacheLookupTableLockHandle itemLock, ValueType item)
        {
            // link this item into the chain for this bucket.
            m_helper.SetNext(item, m_rgBuckets[itemLock.LockToken]);
            m_rgBuckets[itemLock.LockToken] = item;
        }

        // find an item given its key.
        public ValueType FindLookupItem(XCacheLookupTableLockHandle itemLock, KeyType key)
        {
            // search the bucket for the key.
            ValueType bucketItem = m_rgBuckets[itemLock.LockToken];
            while (!Object.Equals(bucketItem, default(ValueType)))
            {
                if (m_helper.Equals(key, m_helper.GetKey(bucketItem)))
                {
                    // found it!
                    return bucketItem;
                }

                bucketItem = m_helper.GetNext(bucketItem);
            }

            // didnt find the item.
            return default(ValueType);
        }

        // remove this item from the lookup table.
        public bool RemoveLookupItem(XCacheLookupTableLockHandle itemLock, ValueType item)
        {
            KeyType key = m_helper.GetKey(item);
            
            if (!Object.Equals(m_rgBuckets[itemLock.LockToken], default(ValueType)))
            {
                // check the head pointer first.
                if (m_helper.Equals(key, m_helper.GetKey(m_rgBuckets[itemLock.LockToken])))
                {
                    // head pointer is the match.  just advance the head pointer.
                    m_rgBuckets[itemLock.LockToken] = m_helper.GetNext(m_rgBuckets[itemLock.LockToken]);
                    return true;
                }
                else
                {
                    // start with the next pointer.
                    ValueType bucketItem = m_rgBuckets[itemLock.LockToken];
                    ValueType bucketNext = m_helper.GetNext(bucketItem);
                    while (!Object.Equals(bucketNext, default(ValueType)))
                    {
                        if (m_helper.Equals(key, m_helper.GetKey(bucketNext)))
                        {
                            // found the target to delete.  un-link it from the list.
                            m_helper.SetNext(bucketItem, m_helper.GetNext(bucketNext));
                            return true;
                        }

                        bucketItem = bucketNext;
                        bucketNext = m_helper.GetNext(bucketNext);
                    }
                }
            }

            // didnt find the item.
            return false;
        }

        protected int Hash(KeyType key)
        {
            return (int)((uint)(m_helper.GetHashCode(key)) % m_cBuckets);
        }
    }

    // regular c#, lock() style.
    public class MonitorLock
    {
        public MonitorLock()
        {
        }

        public void Lock()
        {
            Monitor.Enter(this);
        }

        public void Unlock()
        {
            Monitor.Exit(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\msgr\AsyncResult.cs ===
//-----------------------------------------------------------------------
// <copyright file="AsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//     Represents an asynchronous result object.
// </summary>
//
// <history>
//     2007/01/26  sgordon    Moved from the ServiceProxy library to the
//                            Messenger runtime.
//     2007/03/03  sgordon    Added support for the WaitHandle property.
// </history>
//-----------------------------------------------------------------------

namespace MS.Msn.Messenger.Runtime
{
    using System;
    using System.Threading;

    /// <summary>
    /// Generic IAsyncResult implementation. The result type is a generic type.
    /// </summary>
    /// <typeparam name="ResultType">Result that should be returned from the end method</typeparam>
    public class AsyncResult<ResultType> : IAsyncResult
    {
        /// <summary>
        /// The asynchronous callback.
        /// </summary>
        private readonly AsyncCallback callback;

        /// <summary>
        /// The associated state object.
        /// </summary>
        private readonly Object state;

        /// <summary>
        /// Whether the operation has completed.
        /// </summary>
        private bool isCompleted;

        /// <summary>
        /// Whether the operation completed synchronously.
        /// </summary>
        private bool completedSynchronously;

        /// <summary>
        /// The associated result code.
        /// </summary>
        private ResultType result;

        /// <summary>
        /// The associated exception.
        /// </summary>
        private Exception exception;

        /// <summary>
        /// The associated wait handle.
        /// </summary>
        private ManualResetEvent waitHandle;

        /// <summary>
        /// Ctor. Saves off callback and state values to be invoked later.
        /// </summary>
        /// <param name="callback">Callback to invoke when operation completes</param>
        /// <param name="state">State to associate with the operation</param>
        public AsyncResult(AsyncCallback callback, Object state)
        {
            this.callback = callback;
            this.state = state;
        }

        /// <summary>
        /// Returns operation result
        /// </summary>
        public ResultType Result
        {
            get { return this.result; }
        }

        /// <summary>
        /// Gets the associated exception, if any.
        /// </summary>
        public Exception Exception
        {
            get { return this.exception; }
        }

        /// <summary>
        /// AsyncState
        /// </summary>
        public object AsyncState
        {
            get { return this.state; }
        }

        /// <summary>
        /// Gets a WaitHandle that is used to wait for an asynchronous operation to complete.
        /// </summary>
        public WaitHandle AsyncWaitHandle
        {
            get
            {
                lock (this)
                {
                    if (this.waitHandle == null)
                    {
                        this.waitHandle = new ManualResetEvent(false);
                    }

                    // If the caller gets the WaitHandle, and we've already
                    // completed, we need to call Set so that they don't block
                    // forever.
                    if (this.IsCompleted)
                    {
                        try
                        {
                            this.waitHandle.Set();
                        }
                        catch (ObjectDisposedException)
                        {
                        }
                    }
                    }

                return this.waitHandle;
            }
        }

        /// <summary>
        /// <c>true</c> if operation completed synchronously
        /// </summary>
        public bool CompletedSynchronously
        {
            get { return this.completedSynchronously; }
        }

        /// <summary>
        /// <c>true</c> if operation completed
        /// </summary>
        public bool IsCompleted
        {
            get { return this.isCompleted; }
        }

        /// <summary>
        /// The callback that should be called upon completion.
        /// </summary>
        protected AsyncCallback Callback
        {
            get { return this.callback; }
        }

        /// <summary>
        /// Completes the request. Invokes saved off callback to notify caller
        /// that operation has been completed.
        /// </summary>
        /// <param name="result">Operation result</param>
        /// <param name="completedSynchronously"><c>true</c> if completed 
        /// synchronously</param>
        public virtual void CompleteRequest(ResultType result, bool completedSynchronously)
        {
            this.result = result;
            this.completedSynchronously = completedSynchronously;
            this.SignalCompleted();
        }

        /// <summary>
        /// Completes the request. Invokes the saved callback to notify the caller
        /// that the operation has completed with an exception.
        /// </summary>
        /// <param name="exception">The exception that occurred.</param>
        /// <param name="completedSynchronously">Whether the operation completed
        /// synchronously.</param>
        public void CompleteRequest(Exception exception, bool completedSynchronously)
        {
            this.exception = exception;
            this.completedSynchronously = completedSynchronously;
            this.SignalCompleted();
        }

        /// <summary>
        /// More efficient call than grabbing the AsyncWaitHandle - ManualResetEvent
        /// is not created if we've already completed.
        /// </summary>
        public void BlockUntilCompleted()
        {
            lock (this)
            {
                if (this.isCompleted)
                {
                    return;
                }
            }

            this.AsyncWaitHandle.WaitOne();
        }

        /// <summary>
        /// Signals that the async result has completed.
        /// </summary>
        private void SignalCompleted()
        {
            lock (this)
            {
                this.isCompleted = true;

                if (this.waitHandle != null)
                {
                    try
                    {
                        this.waitHandle.Set();
                    }
                    catch (ObjectDisposedException)
                    {
                    }
                }
            }

            if (this.callback != null)
            {
                this.callback(this);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\Engine.cs ===
using System;
using System.Threading;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.XCache
{
    public enum ThreadType : ushort
    {
        eWorker
    }

    public abstract class XCacheContext
    {
        public ThreadType m_threadType;
        public XomRequestTimeElapsed m_waitTime = null;
        
        public void ProcessContext(Object state)
        {
            XCacheEngineCounters.Total.WaitTimeAvg.IncrementBy(m_waitTime.TimeElapsed);
            XCacheEngineCounters.Total.WaitTimeAvgBase.Increment();
            XCacheEngineCounters.Total[this.ToString()].WaitTimeAvg.IncrementBy(m_waitTime.TimeElapsed);
            XCacheEngineCounters.Total[this.ToString()].WaitTimeAvgBase.Increment();

            XomRequestTimeElapsed executionTime = new XomRequestTimeElapsed();
            
            try
            {
                ProcessInternal(state);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.XCACHE_CONTEXT_EXCEPTION, e, "Unhandled exception while processing context.");
            }

            XCacheEngineCounters.Total.CompletionRate.Increment();
            XCacheEngineCounters.Total[this.ToString()].CompletionRate.Increment();
            XCacheEngineCounters.Total.ExecutionTimeAvg.IncrementBy(executionTime.TimeElapsed);
            XCacheEngineCounters.Total.ExecutionTimeAvgBase.Increment();
            XCacheEngineCounters.Total[this.ToString()].ExecutionTimeAvg.IncrementBy(executionTime.TimeElapsed);
            XCacheEngineCounters.Total[this.ToString()].ExecutionTimeAvgBase.Increment();
        }
        
        protected abstract void ProcessInternal(Object state);
    };

    class XCacheEngine
    {            
        // custom thread pool for "worker" threads.  these threads access shared memory and do not block on i/o.
        private static FastThreadPool s_tpWorker;

        public static void Init()
        {
            s_tpWorker = new FastThreadPool("xcache", Environment.ProcessorCount, ThreadPriority.AboveNormal);
        }

        public static void Shutdown()
        {
            s_tpWorker.Shutdown();
        }
        
        public unsafe static int ConsumeUserRequestBytes(byte[] rgbBuffer, int cBytesAvailable, ClientConnection cliConn)
        {
            int dwConsumed = 0;
            UserRequestContext reqCtx = cliConn.m_ctxPending;

            // check for an existing context to fill in.
            if (reqCtx != null)
            {
                // we're continuing a message in progress.
                int cbToWrite = Math.Min(cBytesAvailable, reqCtx.m_rgbEntireMessage.Length - reqCtx.m_dwWriteOffset);
                System.Buffer.BlockCopy(rgbBuffer, 0, reqCtx.m_rgbEntireMessage, reqCtx.m_dwWriteOffset, cbToWrite);
                reqCtx.m_dwWriteOffset += cbToWrite;
                cBytesAvailable -= cbToWrite;
                dwConsumed += cbToWrite;

                if (reqCtx.m_dwWriteOffset == reqCtx.m_rgbEntireMessage.Length)
                {
                    // we've got all the bytes, queue the message.
                    cliConn.m_ctxPending = null;
                    XCacheEngine.QueueContext(ThreadType.eWorker, reqCtx, null);
                }
            }

            // try to parse the message size.
            while (cBytesAvailable >= sizeof(uint))
            {
                uint dwTotalMsgSize = BitConverter.ToUInt32(rgbBuffer, dwConsumed);

                if (dwTotalMsgSize >= XCacheService.Instance.MaxMessageBytes)
                {
                    // message is too big to receive.  this shouldnt happen.
                    string sError = "Invalid message received from: " + cliConn.IPAddress + ".  Size (" + dwTotalMsgSize + ") > " + 
                        Config.GetIntSetting(Setting.XCache_MaxMessageBytes) + ".";
                    Xom.NtEvent(XEvent.Id.XCACHE_MSG_TOO_BIG, sError);
                    throw new ApplicationException(sError);
                }

                // make a new context.
                reqCtx = new UserRequestContext(cliConn);
                reqCtx.m_rgbEntireMessage = new byte[dwTotalMsgSize];

                int cbToWrite = (int)Math.Min(cBytesAvailable, dwTotalMsgSize);
                System.Buffer.BlockCopy(rgbBuffer, dwConsumed, reqCtx.m_rgbEntireMessage, 0, cbToWrite);
                reqCtx.m_dwWriteOffset += cbToWrite;
                cBytesAvailable -= cbToWrite;
                dwConsumed += cbToWrite;

                if (reqCtx.m_dwWriteOffset == dwTotalMsgSize)
                {
                    // we've got all the bytes, queue the message.
                    XCacheEngine.QueueContext(ThreadType.eWorker, reqCtx, null);
                }
                else
                {
                    // don't have enough for this message.  hang onto it.
                    cliConn.m_ctxPending = reqCtx;
                    break;
                }
            }

            return dwConsumed;
        }
        
        public static void QueueContext(ThreadType threadType, XCacheContext ctx, Object state)
        {
            ctx.m_threadType = threadType;
            ctx.m_waitTime = new XomRequestTimeElapsed();
            
            switch (threadType)
            {
            case ThreadType.eWorker:
            default:
                s_tpWorker.QueueUserWorkItem(new WaitCallback(ctx.ProcessContext), state);
                break;
            }
        }
    };


    [XomPerformanceCounterCategoryAttr( "XCache Svc - Engine", "Xbox Live XCache Server Per Context Type Counters" )]
    public class XCacheEngineCounters : XomPerformanceCounterCategory
    {
        public XCacheEngineCounters() : base(true)
        {
        }
                       
        public virtual XCacheEngineCounters this[string sType]
        {
            get
            {
                return (XCacheEngineCounters) GetInstance(sType);
            }
        }

        static public XCacheEngineCounters Total = new XCacheEngineCounters();
        
        [XomPerformanceCounterAttr(
            "Completion Rate", 
            "Total number of all contexts per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompletionRate;

        [XomPerformanceCounterAttr(
            "Context Execution Time (ms)", 
            "Average time (in milliseconds) a context takes to execute.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter ExecutionTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Execution Time Base", 
            "Average time (in milliseconds) a context takes to execute.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter ExecutionTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Context Wait Time (ms)", 
            "Average time (in milliseconds) a context waits to be processed.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter WaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Wait Time Base", 
            "Average time (in milliseconds) a context waits to be processed.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTimeAvgBase;

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\ProjectInstaller.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;
using System.Diagnostics;
using System.Text.RegularExpressions;

using xonline.common.config;
using xonline.common.service;

[RunInstallerAttribute(true)]
public class ProjectInstaller: System.Configuration.Install.Installer
{

    private ServiceInstaller serviceInstaller;
    private ServiceProcessInstaller processInstaller;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public ProjectInstaller()
        {
            // This call is required by the Designer.
            InitializeComponent();
        }

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }


 #region Component Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            processInstaller = new ServiceProcessInstaller();
            serviceInstaller = new XCacheServiceInstaller();
          

#if (DEV_TEST)
            processInstaller.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
#else
            IComponentInfo compInfo = Config.GetComponent(xonline.common.config.Component.xcache);

            LSAUtil.GrantLogonRights( compInfo.Username );

            processInstaller.Account = System.ServiceProcess.ServiceAccount.User;
            processInstaller.Username = compInfo.Username;

            CSetupSecureResolver decoder = new CSetupSecureResolver();
            processInstaller.Password = decoder.UserSecret(compInfo.Password);
#endif
  
            serviceInstaller.ServiceName = "XCache";
            serviceInstaller.DisplayName = "Xbox Live XCache Server";
            serviceInstaller.Description = "Gamertag/XUID mapping service for Xbox Live users";
            serviceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
            serviceInstaller.Committed += new System.Configuration.Install.InstallEventHandler(this.XCache_Committed);

            Installers.Add(serviceInstaller);
            Installers.Add(processInstaller);

            }
#endregion

    private void XCache_Committed(object sender, System.Configuration.Install.InstallEventArgs e)
    {
        System.ServiceProcess.ServiceController svc = new System.ServiceProcess.ServiceController("XCache");
        svc.Start();
     }

    private class XCacheServiceInstaller : ServiceInstaller
    {
        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall(savedState);

            // Walk through each XCache process that's still around after it was uninstalled, and kill it
            foreach (Process p in Process.GetProcessesByName("XCache"))
            {
                p.Kill();
            }

            // Let's take a look and see if there are any services still around named XCache
            bool foundService = true;
            using (ServiceController controller = new ServiceController("XCache"))
            {
                try
                {
                    string x = controller.DisplayName;
                }
                catch (InvalidOperationException ex)
                {
                    if (Regex.IsMatch(ex.Message, "was not found on computer"))
                        foundService = false;
                }
            }

            if (true == foundService)
                throw new Exception("The XCache service is still installed post-uninstallation.");

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\Request.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Diagnostics;
using System.Text;
using System.Globalization;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;

namespace xonline.server.XCache
{
    public class UserRequestContext : XCacheContext
    {
        public byte[] m_rgbEntireMessage;
        public int m_dwWriteOffset;

        public XCacheRequestMsg m_request = null;
        public XCacheResponseMsg m_response = null;
        
        protected ClientConnection m_cliConn;

        public UserRequestContext(ClientConnection cliConn)
        {
            m_cliConn = cliConn;
        }

        protected override void ProcessInternal(Object state)
        {
            try
            {
                ValidateMessage();
                m_response = new XCacheResponseMsg();
                m_response.rgResponses = new XCacheLookupResponseHeader[m_request.cdwRequests];

                for (int iRequest = 0; iRequest < m_request.cdwRequests; iRequest++)
                {
                    XCacheLookupRequestHeader lookup = m_request.rgRequests[iRequest];
                    
                    switch (lookup.eLookupType)
                    {
                    case XCacheLookupType.eXUIDLookup:
                        m_response.rgResponses[iRequest] = ProcessXUIDLookup((XCacheXUIDLookupRequest)lookup);
                        break;
                    case XCacheLookupType.eGamertagLookup:
                        m_response.rgResponses[iRequest] = ProcessGamertagLookup((XCacheGamertagLookupRequest)lookup);
                        break;
                    case XCacheLookupType.ePassportLookup:
                        m_response.rgResponses[iRequest] = ProcessPassportLookup((XCachePassportLookupRequest)lookup);
                        break;

                    case XCacheLookupType.eTeamIDLookup:
                    case XCacheLookupType.eTeamNameLookup:
                        // teams are not supported.
                        m_response.rgResponses[iRequest] = BuildEmptyTeamsResponse(lookup);
                        break;

                    default:
                        throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.XCACHE_UNKNOWN_LOOKUP_TYPE, "Unknown message type: {0}", m_request.rgRequests[iRequest].eLookupType);
                    }
                }

                m_cliConn.Send((byte[])m_response);

                if (XCacheService.Instance.DisconnectSockets)
                {
                    m_cliConn.Disconnect();
                }
            }
            catch(Exception e)
            {
                XEvent.Id eventId = XEvent.Id.XCACHE_PROTOCOL_ERROR;
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    eventId = xrle.EventId;
                }

                StringBuilder sb = new StringBuilder();
                string[] lines = ByteConvert.ToFormattedStrings(m_rgbEntireMessage);
                foreach (string line in lines)
                {
                    sb.AppendLine(line);
                }

                Xom.NtEvent(eventId, e, "XCache could not process request. Request bytes = \r\n{0}", sb.ToString());
                
                // we should only throw in cases where we cannot respond.
                m_cliConn.Disconnect();
            }
        }

        private void ValidateMessage()
        {
            // deserializer should throw on any errors.  if we can read the message, we can process it.
            m_request = new XCacheRequestMsg();
            m_request.ReadBytes(m_rgbEntireMessage);
        }

        private XCacheTeamLookupResponse BuildEmptyTeamsResponse(XCacheLookupRequestHeader request)
        {
            XCacheTeamLookupResponse response = new XCacheTeamLookupResponse();
            response.rgTeams = new XCacheTeamResponseData[request.cdwLookups];
            
            for (int iLookup = 0; iLookup < response.rgTeams.Length; iLookup++)
            {
                response.rgTeams[iLookup] = new XCacheTeamResponseData();
            }
            
            return response;
        }

        private XCacheUserLookupResponse ProcessXUIDLookup(XCacheXUIDLookupRequest request)
        {
            return ProcessUserLookup<ulong>(request.rgqwXUIDs, XCacheService.Instance.UserIDLookups, XCacheCounters.Current.UserIDLookupRate);
        }

        private XCacheUserLookupResponse ProcessGamertagLookup(XCacheGamertagLookupRequest request)
        {
            return ProcessUserLookup<string>(request.rgszGamertags, XCacheService.Instance.GamertagLookups, XCacheCounters.Current.GamertagLookupRate);
        }

        private XCacheUserLookupResponse ProcessPassportLookup(XCachePassportLookupRequest request)
        {
            return ProcessUserLookup<ulong>(request.rgqwPassportPUIDs, XCacheService.Instance.PassportIDLookups, XCacheCounters.Current.PassportLookupRate);
        }

        internal XCacheUserLookupResponse ProcessUserLookup<KeyType>(
            KeyType[] rgKeys, 
            XCacheLookupTable<KeyType, XCacheUserData> table,
            PerformanceCounter rateCounter)
        {
            XCacheUserLookupResponse response = new XCacheUserLookupResponse();
            response.rgUsers = new XCacheUserResponseData[rgKeys.Length];

            for (int iLookup = 0; iLookup < response.rgUsers.Length; iLookup++)
            {
                response.rgUsers[iLookup] = new XCacheUserResponseData();
                
                using (XCacheLookupTableLockHandle lh = table.LockItemByKey(rgKeys[iLookup]))
                {
                    XCacheUserData item = table.FindLookupItem(lh, rgKeys[iLookup]);
                    if (item != null)
                    {
                        response.rgUsers[iLookup].qwUserID = item.qwUserID;
                        response.rgUsers[iLookup].szGamertag = item.sGamertag;
                        response.rgUsers[iLookup].qwPassportPUID = item.qwPassportID;
                    }
                }

                rateCounter.Increment();
            }
            
            return response;
        }
    }

    public class AdminControl
    {
        public static ulong ParseULong(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) return Convert.ToUInt64(s.Substring(2), 16);
            else return Convert.ToUInt64(s, 10);
        }
        
        public static string AdminDisconnect(ControlRequestEventArgs args)
        {
            XCacheService.Instance.DisconnectSockets = true;
            args.Handled = true;
            return "Client sockets will disconnect after each request.\r\n";
        }

        public static string AdminConnect(ControlRequestEventArgs args)
        {
            XCacheService.Instance.DisconnectSockets = false;
            args.Handled = true;
            return "Client sockets will persist after each request.\r\n";
        }

        public static string AdminLookupXUID(ControlRequestEventArgs args)
        {
            ulong xuid = ParseULong(args.CommandArgs[0]);
            args.Handled = true;
            return AdminLookupUser<ulong>(xuid, XCacheService.Instance.UserIDLookups);
        }

        public static string AdminLookupGamertag(ControlRequestEventArgs args)
        {
            string gamertag = args.FullCommand.Substring(args.FullCommand.IndexOf(' ')).Trim();
            args.Handled = true;
            return AdminLookupUser<string>(gamertag, XCacheService.Instance.GamertagLookups);
        }

        public static string AdminLookupPassport(ControlRequestEventArgs args)
        {
            ulong puid = ParseULong(args.CommandArgs[0]);
            args.Handled = true;
            return AdminLookupUser<ulong>(puid, XCacheService.Instance.PassportIDLookups);
        }

        internal static string AdminLookupUser<KeyType>(KeyType key, XCacheLookupTable<KeyType, XCacheUserData> table)
        {
            string sRet = "User not found." + key.ToString();
            
            using (XCacheLookupTableLockHandle lh = table.LockItemByKey(key))
            {
                XCacheUserData item = table.FindLookupItem(lh, key);
                if (item != null)
                {
                    sRet = string.Format("User found:\r\n  UserID = {0}\r\n  Gamertag = \"{1}\"\r\n  Passport = {2}\r\n\r\n",
                        (Puid)item.qwUserID, item.sGamertag ?? "(null)", (Puid)item.qwPassportID);
                }
            }

            return sRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\DBReader.cs ===
using System;
using System.Threading;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Specialized;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.health;

[assembly: XomAreaDefinition(XomAreaName.XCacheDatabase)]

namespace xonline.server.XCache
{
    public class XCacheDatabaseReader
    {
        public const ulong m_qwTestUserIDBase = 0x000A000000000000;
        public const ulong m_qwTestPassportBase = 0x000C000000000000;
        public const string m_sTestGamertagPrefix = "XCTU";
        
        protected PartitionInfo[] m_rgPartitionInfos;

        protected Thread m_threadPoll;
        protected bool m_fShutdown;
        protected bool m_fInitialRead;
        
        public XCacheDatabaseReader()
        {
            m_rgPartitionInfos = new PartitionInfo[0];
        }

        private bool UseDatabaseLocks
        {
            get
            {
                return (Config.GetUIntSetting(Setting.xcache_db_usedatabaselocks) == 1);
            }
        }

        private uint BatchSize
        {
            get
            {
                if (UseDatabaseLocks)
                {
                    return Math.Max(Config.GetUIntSetting(Setting.xcache_db_batchSize), 4);
                }
                else
                    return 5000;
            }
        }

        public void Init()
        {
            try
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    CheckNumPhysicalPartitions(ws);
                }

                m_fShutdown = false;
                m_threadPoll = new Thread(this.ThreadProc);
                m_threadPoll.Start();
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.XCACHE_DBREADER_INIT_FAIL, e, "XCacheDatabaseReader.Init() failed.");
                throw;
            }
        }

        public void Shutdown()
        {
            m_fShutdown = true;

            if (m_threadPoll != null)
            {
                m_threadPoll.Interrupt();
                m_threadPoll.Join();
            }

            m_rgPartitionInfos = new PartitionInfo[0];
            m_fInitialRead = false;
        }
        
        protected class PartitionInfo
        {
            public int m_iPartition;
            public string m_dtUpdateGamertagAdds;
            public string m_dtUpdateGamertagDeletes;
            public string m_dtUpdatePassportAdds;
        }

        public string AdminShowPartitionInfo()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("Partitions:");
            sb.AppendFormat(" {0,3} | {1,20} | {2,20} | {3,20}\r\n", "ID", "GT Adds", "GT Deletes", "Passport Adds");

            PartitionInfo[] rgPartitions = m_rgPartitionInfos;
            for (int iPartition = 0; iPartition < rgPartitions.Length; iPartition++)
            {
                sb.AppendFormat(" {0,-3} | {1,20} | {2,20} | {3,20}\r\n",
                    rgPartitions[iPartition].m_iPartition,
                    rgPartitions[iPartition].m_dtUpdateGamertagAdds,
                    rgPartitions[iPartition].m_dtUpdateGamertagDeletes,
                    rgPartitions[iPartition].m_dtUpdatePassportAdds);
            }

            return sb.ToString();
        }

        protected void CheckNumPhysicalPartitions(WSClient ws)
        {
            uint cPartitions = (uint)ws.PhysicalPartitions;
            if ((cPartitions == 0) || (cPartitions < m_rgPartitionInfos.Length))
            {
                throw new XRLException(HResult.E_UNEXPECTED, XEvent.Id.XCACHE_DBREADER_INVALID_PARTITION_COUNT, "Invalid number of uodb partitions read {0}.  cannot be less than current {1}", cPartitions, m_rgPartitionInfos.Length);
            }

            if (cPartitions == m_rgPartitionInfos.Length)
            {
                return;
            }

            PartitionInfo[] rgPartitions = new PartitionInfo[cPartitions];
            for (int iPart = 0; iPart < m_rgPartitionInfos.Length; iPart++)
            {
                rgPartitions[iPart] = m_rgPartitionInfos[iPart];
            }
            for (int iPart = m_rgPartitionInfos.Length; iPart < rgPartitions.Length; iPart++)
            {
                rgPartitions[iPart] = new PartitionInfo();
                rgPartitions[iPart].m_iPartition = iPart;
                rgPartitions[iPart].m_dtUpdateGamertagAdds = "";
                rgPartitions[iPart].m_dtUpdateGamertagDeletes = "";
                rgPartitions[iPart].m_dtUpdatePassportAdds = "";
            }

            m_rgPartitionInfos = rgPartitions;
        }

        protected void ReadFromDatabase()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                CheckNumPhysicalPartitions(ws);

                for (int iPart = 0; iPart < m_rgPartitionInfos.Length; iPart++)
                {
                    XCacheSyncHealthBlock.LoadDetailsMessage = String.Format("Reading gamertag deletes, partition {0}/{1}\r\n", iPart, m_rgPartitionInfos.Length);
                    while (!m_fShutdown && ReadGamertagDeletes(ws, m_rgPartitionInfos[iPart]) > (BatchSize / 2)) ;
                }
                
                for (int iPart = 0; iPart < m_rgPartitionInfos.Length; iPart++)
                {
                    XCacheSyncHealthBlock.LoadDetailsMessage = String.Format("Reading gamertag adds, partition {0}/{1}\r\n", iPart, m_rgPartitionInfos.Length);
                    while (!m_fShutdown && ReadGamertagAdds(ws, m_rgPartitionInfos[iPart]) > (BatchSize / 2)) ;
                }
                
                for (int iPart = 0; iPart < m_rgPartitionInfos.Length; iPart++)
                {
                    XCacheSyncHealthBlock.LoadDetailsMessage = String.Format("Reading passport adds, partition {0}/{1}\r\n", iPart, m_rgPartitionInfos.Length);
                    while (!m_fShutdown && ReadPassportAdds(ws, m_rgPartitionInfos[iPart]) > (BatchSize / 2)) ;
                }
            }
        }
        
        protected void ThreadProc()
        {
            CreateTestUsers();
            
            while (!m_fShutdown)
            {
                try
                {
                    XomRequestTimeElapsed elapsed = new XomRequestTimeElapsed();

                    try
                    {
                        ReadFromDatabase();

                        if (!m_fInitialRead)
                        {
                            m_fInitialRead = true;
                            XCacheEngine.QueueContext(ThreadType.eWorker, new XCacheInitialLoadCompleteContext(), null);
                        }
                    }
                    catch (Exception e)
                    {
                        XRLException xrle = e as XRLException;
                        XEvent.Id eventId = XEvent.Id.XCACHE_DBREADER_READ_FAIL;
                        
                        if (xrle != null)
                        {
                            eventId = xrle.EventId;
                        }

                        Xom.NtEvent(eventId, e, "XCacheDatabaseReader.ReadFromDatabase() returned failure.");
                    }
                    
                    int pollMs = 1000 * Config.GetIntSetting(Setting.xcache_db_pollingInterval);
                    int elapsedMs = (int)elapsed.MillisecondsElapsed;
                    int sleepMs = pollMs - elapsedMs;

                    Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_NORMAL, "Done reading.  waiting for {0} seconds...", sleepMs / 1000);
                    
                    if ((pollMs - elapsedMs) > 0)
                    {
                        Thread.Sleep(pollMs - elapsedMs);
                    }
                }
                catch (Exception e)
                {
                    XEvent.Id eventId = XEvent.Id.XCACHE_DBTHREAD_EXCEPTION;
                    XRLException xrle = e as XRLException;
                    if (xrle != null)
                    {
                        eventId = xrle.EventId;
                    }
                    Xom.NtEvent(eventId, e, "XCacheDatabaseReader.ThreadProc() threw an exception. ");
                }
            }
        }

        protected uint ReadGamertagAdds(WSClient ws, PartitionInfo partitionInfo)
        {
            Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_NORMAL, "ReadUserGamertagAdds reading partition {0}, starting time: {1}", partitionInfo.m_iPartition, partitionInfo.m_dtUpdateGamertagAdds);

            XCacheDataContext context = new XCacheDataContext();
            List<XCacheDataContext.XCacheGamertagAdd> listAdds = new List<XCacheDataContext.XCacheGamertagAdd>();
            
            ws.ClearParameters();
            ws.PhysicalPartition = partitionInfo.m_iPartition;
            ws.StoredProc = UseDatabaseLocks ? "dbo.p_wbca_get_users_locking" : "dbo.p_wbca_get_users";
            ws.AddParameter("@vc_last", partitionInfo.m_dtUpdateGamertagAdds);
            if (UseDatabaseLocks)
            {
                ws.AddParameter("@i_batch_size", Config.GetIntSetting(Setting.xcache_db_batchSize));
                ws.Command.CommandTimeout = Config.GetIntSetting(Setting.xcache_db_transactionTimeout);
            }

            using (WstDataReader reader = ws.Execute())
            {
                while (reader.HasRows && reader.Read())
                {
                    int bucket = (int)(short)reader["si_hash_bucket"];
                    if (partitionInfo.m_iPartition != ws.GetPhysicalPartition(bucket))
                    {
                        continue;
                    }

                    XCacheDataContext.XCacheGamertagAdd add = new XCacheDataContext.XCacheGamertagAdd();

                    add.qwUserID = (ulong)(long)reader["bi_user_puid"];
                    if (add.qwUserID == 0)
                    {
                        continue;
                    }
                    
                    add.sGamertag = (string)reader["vc_gamertag"];
                    if (string.IsNullOrEmpty(add.sGamertag))
                    {
                        continue;
                    }

                    Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_LOW, 
                        "ReadUserGamertagAdds row {0} gamertag={1}, userid=0x{2:X}, bucket={3}", 
                        listAdds.Count, add.sGamertag, add.qwUserID, bucket);

                    partitionInfo.m_dtUpdateGamertagAdds = (string)reader["dt_datestring"];

                    listAdds.Add(add);
                }

                Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_NORMAL, "ReadUserGamertagAdds returned {0} rows.", listAdds.Count);
            }

            context.rgGamertagAdds = listAdds.ToArray();
            XCacheEngine.QueueContext(ThreadType.eWorker, context, null);

            return (uint)listAdds.Count;
        }

        protected uint ReadGamertagDeletes(WSClient ws, PartitionInfo partitionInfo)
        {
            Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_NORMAL, "ReadGamertagDeletes reading partition {0}, starting time: {1}", partitionInfo.m_iPartition, partitionInfo.m_dtUpdateGamertagDeletes);

            XCacheDataContext context = new XCacheDataContext();
            List<ulong> listDeletes = new List<ulong>();

            ws.ClearParameters();
            ws.PhysicalPartition = partitionInfo.m_iPartition;
            ws.StoredProc = UseDatabaseLocks ? "dbo.p_wbca_get_user_deletes_locking" : "dbo.p_wbca_get_user_deletes";
            ws.AddParameter("@vc_last", partitionInfo.m_dtUpdateGamertagDeletes);
            if (UseDatabaseLocks)
            {
                ws.AddParameter("@i_batch_size", Config.GetIntSetting(Setting.xcache_db_batchSize));
                ws.Command.CommandTimeout = Config.GetIntSetting(Setting.xcache_db_transactionTimeout);
            }

            using (WstDataReader reader = ws.Execute())
            {
                while (reader.HasRows && reader.Read())
                {
                    int bucket = (int)(short)reader["si_hash_bucket"];
                    if (partitionInfo.m_iPartition != ws.GetPhysicalPartition(bucket))
                    {
                        continue;
                    }

                    ulong userid = (ulong)(long)reader["bi_user_puid"];
                    if (userid == 0)
                    {
                        continue;
                    }
                    
                    string gamertag = (string)reader["vc_gamertag"];
                    if (string.IsNullOrEmpty(gamertag))
                    {
                        continue;
                    }

                    Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_LOW, 
                        "ReadUserGamertagDeletes row {0} gamertag={1}, userid=0x{2:X}, bucket={3}", 
                        listDeletes.Count, gamertag, userid, bucket);
                    
                    partitionInfo.m_dtUpdateGamertagDeletes = (string)reader["dt_datestring"];

                    listDeletes.Add(userid);
                }

                Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_NORMAL, "ReadUserGamertagDeletes returned {0} rows.", listDeletes.Count);
            }

            context.rgUserDeletes = listDeletes.ToArray();
            XCacheEngine.QueueContext(ThreadType.eWorker, context, null);

            return (uint)listDeletes.Count;
        }

        protected uint ReadPassportAdds(WSClient ws, PartitionInfo partitionInfo)
        {
            Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_NORMAL, "ReadPassportAdds reading partition {0}, starting time: {1}", partitionInfo.m_iPartition, partitionInfo.m_dtUpdatePassportAdds);

            XCacheDataContext context = new XCacheDataContext();
            List<XCacheDataContext.XCachePassportAdd> listAdds = new List<XCacheDataContext.XCachePassportAdd>();

            ws.ClearParameters();
            ws.PhysicalPartition = partitionInfo.m_iPartition;
            ws.StoredProc = UseDatabaseLocks ? "dbo.p_wbca_get_user_passports_locking" : "dbo.p_wbca_get_user_passports";
            ws.AddParameter("@vc_last", partitionInfo.m_dtUpdatePassportAdds);
            if (UseDatabaseLocks)
            {
                ws.AddParameter("@i_batch_size", Config.GetIntSetting(Setting.xcache_db_batchSize));
                ws.Command.CommandTimeout = Config.GetIntSetting(Setting.xcache_db_transactionTimeout);
            }

            using (WstDataReader reader = ws.Execute())
            {
                while (reader.HasRows && reader.Read())
                {
                    int bucket = (int)(short)reader["si_hash_bucket"];
                    if (partitionInfo.m_iPartition != ws.GetPhysicalPartition(bucket))
                    {
                        continue;
                    }

                    XCacheDataContext.XCachePassportAdd add = new XCacheDataContext.XCachePassportAdd();

                    add.qwUserID = (ulong)(long)reader["bi_user_puid"];
                    if (add.qwUserID == 0)
                    {
                        continue;
                    }
                    
                    add.qwPassportID = (ulong)(long)reader["bi_user_passport_puid"];
                    if (add.qwPassportID == 0)
                    {
                        continue;
                    }

                    Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_LOW, 
                        "ReadUserPassportAdds row {0} passportid={1}, userid=0x{2:X}, bucket={3}", 
                        listAdds.Count, add.qwPassportID, add.qwUserID, bucket);
                    
                    partitionInfo.m_dtUpdatePassportAdds = (string)reader["dt_datestring"];

                    listAdds.Add(add);
                }

                Xom.Trace(XomAreaName.XCacheDatabase, LogLevel.L_NORMAL, "ReadUserPassportAdds returned {0} rows.", listAdds.Count);
            }

            context.rgPassportAdds = listAdds.ToArray();
            XCacheEngine.QueueContext(ThreadType.eWorker, context, null);

            return (uint)listAdds.Count;
        }

        protected void CreateTestUsers()
        {
            int cTestUsers = 0;
            uint dwRandomSeed = 0;
            try
            {
                cTestUsers = Config.GetIntSetting(Setting.xcache_test_num_users);
                dwRandomSeed = Config.GetUIntSetting(Setting.xcache_test_random_seed);
            }
            catch (Exception)
            {
            }

            while (!m_fShutdown && (cTestUsers > 0))
            {
                ulong qwUserID = m_qwTestUserIDBase | dwRandomSeed;
                string sGamertag = m_sTestGamertagPrefix + dwRandomSeed.ToString();
                ulong qwPassportID = m_qwTestPassportBase | dwRandomSeed;

                XCacheLookup.AddGamertagMapping(qwUserID, sGamertag);
                XCacheLookup.AddPassportMapping(qwUserID, qwPassportID);

                dwRandomSeed++;
                cTestUsers--;
            }
        }
    }        

    public class XCacheDataContext : XCacheContext
    {
        public struct XCacheGamertagAdd
        {
            public ulong qwUserID;
            public string sGamertag;
        }

        public struct XCachePassportAdd
        {
            public ulong qwUserID;
            public ulong qwPassportID;
        }
        
        public XCacheGamertagAdd[] rgGamertagAdds;
        public XCachePassportAdd[] rgPassportAdds;
        public ulong[] rgUserDeletes;

        protected override void ProcessInternal(Object state)
        {
            if (rgGamertagAdds != null)
            {
                for (int iUser = 0; iUser < rgGamertagAdds.Length; iUser++)
                {
                    XCacheLookup.AddGamertagMapping(rgGamertagAdds[iUser].qwUserID, rgGamertagAdds[iUser].sGamertag);
                }
            }

            if (rgPassportAdds != null)
            {
                for (int iUser = 0; iUser < rgPassportAdds.Length; iUser++)
                {
                    XCacheLookup.AddPassportMapping(rgPassportAdds[iUser].qwUserID, rgPassportAdds[iUser].qwPassportID);
                }
            }

            if (rgUserDeletes != null)
            {
                for (int iUser = 0; iUser < rgUserDeletes.Length; iUser++)
                {
                    XCacheLookup.RemoveUser(rgUserDeletes[iUser]);
                }
            }
        }
    }

    public class XCacheInitialLoadCompleteContext : XCacheContext
    {
        protected override void ProcessInternal(Object state)
        {
            XCacheService.Instance.IsInitComplete = true;
            Xom.NtEvent(XEvent.Id.XCACHE_INIT_COMPLETE, "Completed initial database sync.  This server is now ready to handle requests.");
        }
    }

    public class XCacheSyncHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Local;

        public static string LoadDetailsMessage;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                if (!XCacheService.Instance.IsInitComplete)
                {
                    report.HealthStatus = HealthStatusEnum.Red;
                    report.ErrorDetails += LoadDetailsMessage ?? "";
                }
                else
                {
                    report.HealthStatus = HealthStatusEnum.Green;
                }
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails += e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\msgr\interop.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;

namespace MS.Msn.Messenger.Runtime
{

    /// <summary>
    /// Some of the imports from Kernel32
    /// </summary>
    internal class Kernel32
    {
        static public IntPtr INVALID_HANDLE_VALUE = (IntPtr)(-1);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 GetQueuedCompletionStatus(
            IntPtr CompletionPort,
            ref Int32 lpNumberOfBytes,
            ref Int32 lpCompletionKey,
            ref IntPtr lpOverlapped,
            Int32 dwMilliseconds
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 PostQueuedCompletionStatus(
            IntPtr CompletionPort,
            Int32 NumberOfBytes,
            Int32 CompletionKey,
            IntPtr lpOverlapped
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 ReadFile(
            IntPtr hFile,
            IntPtr lpBuffer,
            Int32 nNumberOfBytesToRead,
            IntPtr lpNumberOfBytesRead,
            IntPtr lpOverlapped
            );


        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 DuplicateHandle(
            IntPtr hSourceProcessHandle,
            IntPtr hSourceHandle,
            IntPtr hTargetProcessHandle,
            ref IntPtr lpTargetHandle,
            Int32 dwDesiredAccess,
            Int32 bInheritHandle,
            Int32 dwOptions
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 CloseHandle(
            IntPtr hHandle
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr CreateIoCompletionPort(
            IntPtr FileHandle,
            IntPtr ExistingCompletionPort,
            IntPtr CompletionKey,
            Int32 NumberOfConcurrentThreads
            );

        [DllImport("kernel32.dll", EntryPoint = "RtlZeroMemory", SetLastError = true)]
        public static extern void ZeroMemory(
            IntPtr Destination,
            IntPtr Length
            );

        [DllImport("kernel32.dll")]
        public static extern uint GetTickCount();
    }

    /// <summary>
    /// Some of the imports from Winsock
    /// </summary>
    internal class Winsock
    {
        public const int WSA_FLAG_OVERLAPPED = 1;

        [DllImport("ws2_32.dll", EntryPoint = "WSASocketW", SetLastError = true)]
        public static extern IntPtr WSASocket(
            AddressFamily af,
            SocketType type,
            ProtocolType protocol,
            IntPtr lpProtocolInfo,
            int g,
            int dwFlags
            );


        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref Int32 buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref byte buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int getsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref Int32 buffer,
            ref Int32 bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref IntPtr buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int bind(
            IntPtr socket,
            ref sockaddr_in sockaddr,
            int size
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int listen(
            IntPtr socket,
            int backlog
            );

        [DllImport("mswsock.dll", SetLastError = true)]
        public static extern bool AcceptEx(
            IntPtr listenSocket,
            IntPtr acceptSocket,
            IntPtr outputBuffer,
            int receiveDataLength,
            int localAddressLength,
            int remoteAddressLength,
            ref int bytesReceived,
            IntPtr overlapped
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int shutdown(
            IntPtr socket
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int closesocket(
            IntPtr socket
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSARecv(
            IntPtr socket,
            ref WSABUF buf,
            int count,
            ref int readCount,
            ref int flags,
            IntPtr overlapped,
            IntPtr expectNULL
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSASend(
            IntPtr socket,
            ref WSABUF buf,
            int count,
            ref int writeCount,
            int flags,
            IntPtr  overlapped,
            IntPtr expectNULL
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSAGetOverlappedResult(
            IntPtr socket,
            IntPtr overlapped,
            ref int transferedBytes,
            int fWait,
            ref int flags
            );


        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSAIoctl(
            IntPtr socket,
            IOControlCode ioControlCode,
            IntPtr inBuffer,
            int cbInBuffer,
            IntPtr outBuffer,
            int cbOutBuffer,
            ref int bytesReturned,
            IntPtr overlapped,
            IntPtr completionRoutine
            );

        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int getsockname(
            IntPtr socket,
            IntPtr buffer,
            ref int addrSize
            );

        // We use sockaddr_in here in place of sockaddr (these are equivalent)
        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int getpeername(
            IntPtr socket,
            ref sockaddr_in addr,
            ref int addrSize
            );

        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int WSAStartup(
            UInt16 wVersionRequested,
            ref WSADATA lpWSAData
            );


        [StructLayout(LayoutKind.Sequential)]
        public struct tcp_keepalive
        {
            public uint onOff;
            public uint keepAliveTime;
            public uint keepAliveInterval;
        };

        [StructLayout(LayoutKind.Sequential)]
        public struct WSADATA
        {
            ushort wVersion;
            ushort wHighVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256 + 1)]
            byte[] szDescription;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128 + 1)]
            byte[] szSystemStatus;
            ushort iMaxSockets;
            ushort iMaxUdpDg;
            public IntPtr lpVendorInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WSABUF
        {
            public Int32 len;
            public IntPtr buf;
        };

        // Structures "sockaddr_in" and "sockaddr" are interchangeable in API. They
        // represent a different way to access for the same layout. We choose to
        // use sockaddr_in in some APIs that call for sockaddr.
        [StructLayout(LayoutKind.Sequential)]
        public struct sockaddr_in
        {
            public short sin_family;
            public ushort port;
            public int address;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            public byte[] zeroes;

            public ushort sin_port
            {
                get { return (ushort)(((((ushort)port) & 0xFF) << 8) | (((ushort)port) >> 8)); }
            }

            public sockaddr_in(int address, int port)
            {
                sin_family = 2 /* AF_INET*/;
                this.port = (ushort)(((((ushort)port) & 0xFF) << 8) | (((ushort)port) >> 8));
                byte[] bytes = BitConverter.GetBytes(address);
                this.address = address;
                zeroes = new byte[8];
            }

            // Marshal.* makes a linkdemand which is not required by this function
            // This is ok as we are not shipping this dll for use by any other applications other than
            // messenger.  So the FXCOP warning here is not applicable.

            internal static readonly int Size = Marshal.SizeOf(new sockaddr_in());
        };

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\msgr\SocketLayer.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;

using xonline.common.mgmt;

namespace MS.Msn.Messenger.Runtime
{

    /// <summary>
    /// Called when a new socket has been accepted.
    /// </summary>
    /// <param name="acceptedSocketIndex"></param>
    /// <param name="error"></param>
    public delegate void AcceptCallback(int acceptedSocketIndex, SocketError error);

    /// <summary>
    /// Called when a read has been performed.
    /// </summary>
    /// <param name="socketIndex"></param>
    /// <param name="error"></param>
    /// <param name="buffer"></param>
    /// <param name="offset"></param>
    /// <param name="bytes"></param>
    public delegate void ReadCallback(int socketIndex, SocketError error, IntPtr buffer, int offset, int bytes);

    /// <summary>
    /// Called when a write has been performed.
    /// </summary>
    /// <param name="socketIndex"></param>
    /// <param name="error"></param>
    public delegate void WriteCallback(int socketIndex, SocketError error);

    /// <summary>
    /// Exception in the socket handling code.
    /// </summary>
    public class MySocketException : ApplicationException
    {
        /// <summary>
        ///
        /// </summary>
        public MySocketException() { }

        /// <summary>
        ///
        /// </summary>
        /// <param name="error"></param>
        public MySocketException(int error) : base("", new SocketException(error)) { }

        /// <summary>
        ///
        /// </summary>
        /// <param name="message"></param>
        public MySocketException(string message) : base(message) { }
    }


    internal struct MySocket
    {
        // The index into the SocketLayer.sockets array is composed of two
        // parts: the lower 24 bits indicate the actual array index (also
        // referred to as the 'realIndex'), while the upper 8 bits will
        // be incremented sequentially with every reuse of MySocket.
        // This compound number is return to TcpConnectionListener and
        // stored in TxpConnectionUsingSocketLayer.

        internal const int indexBits = 24;
        internal const int indexMask = 0xFFFFFF;
        internal int index;

        internal int nextFree;
        internal IntPtr sock;

        internal bool boundToIoPort;

        internal IntPtr readOverlappedPtr;
        internal IntPtr writeOverlappedPtr;
        internal IntPtr acceptOverlappedPtr;

        ReadCallback onRead;
        WriteCallback onWrite;
        AcceptCallback onAccept;

        int acceptSockIndex;

        IntPtr readBuffer;
        int readBufferSize;
        IntPtr writeBuffer;
        int writeBufferSize;
        int bytesToWrite;
        int bytesWritten;
        object syncObject;

        void Clear()
        { 
            bytesWritten = bytesToWrite = 0;
            onAccept = null;
            onRead = null;
            onWrite = null;
            acceptSockIndex = -1;
        }

        internal static void ClearOverlapped(IntPtr overlappedPtr)
        {
            Kernel32.ZeroMemory(overlappedPtr, (IntPtr)MyOverlapped.Size);
        }

        internal void VerifyIndex(int realIndex)
        {
            if (index != realIndex)
            {
                throw new ObjectDisposedException(
                    String.Format(
                    "Socket {0} must have been cleared out because current index at that slot = {1}.",
                    realIndex, index));
            }
        }


        void OnWrite(SocketError error)
        {
            WriteCallback writeCallback = onWrite;
            if (writeCallback != null)
            {
                writeCallback(index, error);
            }
        }


        bool OperationPending(int error)
        {
            return error == (int)SocketError.InProgress ||
                error == (int)SocketError.IOPending ||
                error == 996 /* ERROR_IO_INCOMPLETE */;
        }

        private void GetPeerIpAddress()
        {
            if (this.ipaddress == null)
            {
                Winsock.sockaddr_in addr = new Winsock.sockaddr_in();
                int addrSize = Winsock.sockaddr_in.Size;

                // An alternative to getpeername() is GetAcceptExSockaddrs(). However,
                // the latter is typically invoked right after AcceptEx(), at which point
                // the socket is not yet completely connected (it will be in IOPending
                // state). It could be because the "on accept" callback must complete
                // first.
                //
                // Attempts to execute getpeername() right after accept were not successful
                // with error codes indicating "not connected" (yet).
                if (Winsock.getpeername(this.sock, ref addr, ref addrSize) == 0)
                {
                    try
                    {
                        Int64 address = 0x00000000FFFFFFFF & Convert.ToInt64(addr.address);
                        this.ipaddress = new IPAddress(address);
                        this.port = addr.sin_port;
                    }
                    catch (Exception)
                    {
                        this.ipaddress = IPAddress.None;
                        this.port = 0;
                    }
                }
                else
                {
                    this.ipaddress = IPAddress.None;
                    this.port = 0;
                }
            }
        }

        internal int Initialize(int newIndex, IntPtr sock, IntPtr readBuffer, int readBufferSize, IntPtr writeBuffer, int writeBufferSize, IntPtr overlappedBuffers)
        {
            Clear();
            if (null == syncObject) syncObject = new Object();
            index = (((index >> indexBits) + 1) << indexBits) + newIndex;
            this.sock = sock;
            this.readBuffer = readBuffer;
            this.readBufferSize = readBufferSize;
            this.writeBuffer = writeBuffer;
            this.writeBufferSize = writeBufferSize;
            this.readOverlappedPtr = overlappedBuffers;
            this.writeOverlappedPtr = AddOffset(overlappedBuffers, MyOverlapped.Size);
            this.acceptOverlappedPtr = AddOffset(overlappedBuffers, MyOverlapped.Size * 2);
            this.ipaddress = null;
            this.port = 0;

            return index;
        }

        static internal IntPtr AddOffset(IntPtr baseAddress, int offset)
        {
            if (offset == 0) return baseAddress;
            return (IntPtr)(baseAddress.ToInt64() + offset);
        }

        internal bool Close(int socketIndex, bool clearIndex)
        {
            bool closedSocket = false;
            bool clearedIndex = false;

            lock (syncObject)
            {
                if (index == socketIndex)
                {
                    if (sock != Kernel32.INVALID_HANDLE_VALUE)
                    {
                        Winsock.shutdown(sock);
                        Winsock.closesocket(sock);
                        sock = Kernel32.INVALID_HANDLE_VALUE;
                        boundToIoPort = false;
                        closedSocket = true;
                    }

                    if (clearIndex)
                    {
                        index &= ~indexMask;
                        clearedIndex = true;
                    }

                    Clear();
                }
            }

            if (closedSocket) 
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionClosed(" + socketIndex.ToString() +")");

            return clearedIndex;
        }

        internal SocketError PostAccept(int socketIndex, IntPtr acceptSocket, int acceptSocketIndex, AcceptCallback acceptCallback)
        {
            SocketError result;

            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (HasOutstandingIO())
                {
                    return SocketError.AlreadyInProgress;
                }

                onAccept = acceptCallback;
                acceptSockIndex = acceptSocketIndex;
                int bytesReceived = 0; // don't care about this.

                ClearOverlapped(acceptOverlappedPtr);
                bool succeeded = Winsock.AcceptEx(
                    sock, acceptSocket, readBuffer, 0,
                    Winsock.sockaddr_in.Size + 16,
                    Winsock.sockaddr_in.Size + 16,
                    ref bytesReceived,
                    acceptOverlappedPtr
                    );
                result = ProcessResult(succeeded);
            }

            // $BUGBUG: should we call OnAccept if operation failed?

            return result;
        }

        internal SocketError PostRead(int socketIndex, ReadCallback readCallback)
        {
            SocketError result;

            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (onRead != null)
                {
                    return SocketError.AlreadyInProgress;
                }

                this.GetPeerIpAddress();

                int bytes = 0;
                int flags = 0;
                Winsock.WSABUF buf;

                buf.buf = readBuffer;
                buf.len = readBufferSize;

                onRead = readCallback;
                ClearOverlapped(readOverlappedPtr);

                bool succeeded = (-1 != Winsock.WSARecv(sock, ref buf, 1, ref bytes, ref flags, readOverlappedPtr, IntPtr.Zero));
                result = ProcessResult(succeeded);
            }

            // $BUGBUG: should we call OnRead if operation failed?

            return result;
        }

        SocketError PostWriteNoStateCheck(int socketIndex, int bufferOffset, int bytesToWrite)
        {
            int bytes = 0;
            int flags = 0;
            Winsock.WSABUF buf;
            SocketError result;

            lock (syncObject)
            {
                if (socketIndex != index) return SocketError.NotConnected;

                buf.buf = AddOffset(writeBuffer, bufferOffset);
                buf.len = bytesToWrite;

                ClearOverlapped(writeOverlappedPtr);

                bool succeeded = (-1 != Winsock.WSASend(sock, ref buf, 1, ref bytes, flags, writeOverlappedPtr, IntPtr.Zero));
                result = ProcessResult(succeeded);
            }

            if (result != SocketError.Success)
            {
                OnWrite(result);
            }

            return result;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        internal SocketError PostWrite(int socketIndex, byte[] buffer, int offset, int bytesToWrite, WriteCallback writeCallback)
        {
            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (onWrite != null)
                {
                    return SocketError.AlreadyInProgress;
                }

                if (this.bytesToWrite + bytesToWrite > writeBufferSize)
                {
                    throw new MySocketException((int)SocketError.MessageSize);
                }

                onWrite = writeCallback;

                Marshal.Copy(buffer, offset, (IntPtr)(writeBuffer.ToInt64() + this.bytesToWrite), bytesToWrite);

                this.bytesToWrite += bytesToWrite;
            }

            if(writeCallback != null)
            {
                return PostWriteNoStateCheck(socketIndex, 0, bytesToWrite);
            }

            return SocketError.Success;
        }

        bool AcceptCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            AcceptCallback acceptCallback = null;
            int acceptSocketIndex = -1;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                acceptSocketIndex = acceptSockIndex;
                acceptCallback = onAccept;

                if (acceptCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, acceptOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    completed = true;
                }

                if (completed)
                {
                    onAccept = null;
                    acceptSockIndex = -1;
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(acceptSocketIndex, false);
                acceptCallback(acceptSocketIndex, socketError);
                return true;
            }

            return false;
        }

        bool WriteCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            bool partialWrite = false;
            WriteCallback writeCallback = null;
            int partialWriteOffset = 0;
            int partialWriteCount = 0;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                writeCallback = onWrite;

                if (writeCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, writeOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    bytesWritten += bytesCount;
                    if (bytesToWrite == bytesWritten)
                    {
                        bytesToWrite = bytesWritten = 0;
                        onWrite = null;
                        completed = true;
                    }
                    else
                    {
                        partialWrite = true;
                        partialWriteOffset = bytesWritten;
                        partialWriteCount = bytesToWrite - bytesWritten;
                    }
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(socketIndex, false);
                writeCallback(socketIndex, socketError);
                return true;
            }

            if (partialWrite)
            {
                //
                // Partial write? Schedule the rest of it.
                //

                PostWriteNoStateCheck(socketIndex, partialWriteOffset, partialWriteCount);
                return true;
            }

            return false;
        }

        bool ReadCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            ReadCallback readCallback = null;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                readCallback = onRead;

                if (readCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, readOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    onRead = null;
                    completed = true;
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(socketIndex, false);
                readCallback(index, socketError, readBuffer, 0, bytesCount);
                return true;
            }

            return false;
        }

        internal void OnCompletion(int index, IntPtr overlappedPtr)
        {
            if (sock == Kernel32.INVALID_HANDLE_VALUE)
            {
                // we have already closed the socket, so we just ignore all the 
                // completion notification for this socket.

                if (overlappedPtr == acceptOverlappedPtr)
                {
                    onAccept = null;
                    return;
                }

                if (overlappedPtr == writeOverlappedPtr)
                {
                    onWrite = null;
                    return;
                }

                if (overlappedPtr == readOverlappedPtr)
                {
                    onRead = null;
                    return;
                }
            }

            //
            // Check if accept got done
            //

            if (overlappedPtr == acceptOverlappedPtr && AcceptCompleted(index)) return;

            //
            // Check if write got done.
            //

            if (overlappedPtr == writeOverlappedPtr && WriteCompleted(index)) return;

            //
            // Check if read got done
            //

            if (overlappedPtr == readOverlappedPtr && ReadCompleted(index)) return;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        SocketError ProcessResult(bool succeeded)
        {
            SocketError result = SocketError.Success;
            if (!succeeded)
            {
                result = (SocketError)Marshal.GetLastWin32Error();
                if (result == SocketError.IOPending)
                {
                    result = SocketError.Success;
                }
                else
                {
                    Close(index, false);
                }
            }

            return result;
        }

        bool HasOutstandingIO()
        {
            return (onAccept != null || onRead != null || onWrite != null);
        }

        private IPAddress ipaddress;
        private ushort port;

        internal IPAddress IPAddress
        {
            get
            {
                return this.ipaddress;
            }
        }
        internal ushort Port
        {
            get
            {
                return this.port;
            }
        }
    }

    /// <summary>
    /// Helper structure with the only purpose being size computation
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct MyOverlapped
    {
        public IntPtr Internal;
        public IntPtr InternalHigh;
        public Int32 Dword;
        public Int32 DwordHigh;
        public IntPtr EventHandle;

        internal static readonly MyOverlapped overlappedZero = new MyOverlapped();

        // Marshal.* makes a linkdemand which is not required by this function
        // This is ok as we are not shipping this dll for use by any other applications other than
        // messenger.  So the FXCOP warning here is not applicable.

        internal static readonly int Size = Marshal.SizeOf(overlappedZero); //IntPtr.Size *3 + 4*2; // sizeof (OVERLAPPED)
    };


    /// <summary>
    /// SocketLayer implementation
    /// </summary>
    public class SocketLayer
    {
        private const int MaxThreads = 2;
        private const int NumberOfInternalSocket = 1;

        MySocket[] sockets;
        IntPtr readBuffers;
        IntPtr writeBuffers;
        IntPtr overlappedBuffers;
        int readBufferSize;
        int writeBufferSize;
        uint tcpKeepAliveTimeout;
        int firstFree;
        int count;
        int lastFree;
        object syncRoot = new Object();
        IntPtr[] ioPorts;
        IntPtr listenIoPort = Kernel32.INVALID_HANDLE_VALUE;
        Thread[] workerThreads;
        Thread[] listenerThreads;
        private int unhandledSocketExceptionCount;
        private int unhandledUnmanagedExceptionCount;

        private int GetRealIndex(int index)
        {
            int newIndex = (index & MySocket.indexMask);
            sockets[newIndex].VerifyIndex(index);

            return newIndex;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="maxSockets"></param>
        /// <param name="readBufferSize"></param>
        /// <param name="writeBufferSize"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public SocketLayer(int maxSockets, int readBufferSize, int writeBufferSize, uint tcpKeepAliveTimeout)
            : this(maxSockets + SocketLayer.NumberOfInternalSocket, readBufferSize, writeBufferSize, tcpKeepAliveTimeout, SocketLayer.MaxThreads)
        {
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="maxSockets"></param>
        /// <param name="readBufferSize"></param>
        /// <param name="writeBufferSize"></param>
        /// <param name="threads"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        private SocketLayer(int maxSockets, int readBufferSize, int writeBufferSize, uint tcpKeepAliveTimeout, int threads)
        {
            Debug.Assert(writeBufferSize >= readBufferSize);

            sockets = new MySocket[maxSockets];

            readBuffers = Marshal.AllocHGlobal(readBufferSize * maxSockets);
            writeBuffers = Marshal.AllocHGlobal(writeBufferSize * maxSockets);
            // one for accept, one for read and one for write
            overlappedBuffers = Marshal.AllocHGlobal(MyOverlapped.Size * 3 * maxSockets);
            this.readBufferSize = readBufferSize;
            this.writeBufferSize = writeBufferSize;
            this.tcpKeepAliveTimeout = tcpKeepAliveTimeout;
            for (int i = 0; i < maxSockets; i++)
            {
                sockets[i].nextFree = i + 1;;
            }

            lastFree = sockets.Length - 1;
            sockets[lastFree].nextFree = -1;

            ioPorts = new IntPtr[threads];
            for (int i = 0; i < ioPorts.Length; i++)
            {
                ioPorts[i] = Kernel32.CreateIoCompletionPort(Kernel32.INVALID_HANDLE_VALUE, IntPtr.Zero, IntPtr.Zero, 0);
                if (ioPorts[i] == IntPtr.Zero)
                {
                    throw new MySocketException(String.Format("Unexpected error trying to create a CompletionPort: {0}", Marshal.GetLastWin32Error()));
                }
            }

            listenIoPort = Kernel32.CreateIoCompletionPort(Kernel32.INVALID_HANDLE_VALUE, IntPtr.Zero, IntPtr.Zero, 0);
            if (listenIoPort == IntPtr.Zero)
            {
                throw new MySocketException(String.Format("Unexpected error trying to create a CompletionPort for listening: {0}", Marshal.GetLastWin32Error()));
            }

            workerThreads = new Thread[threads];
            for (int i = 0; i < workerThreads.Length; i++)
            {
                workerThreads[i] = new Thread(new ParameterizedThreadStart(SocketWorkerRoutine));
                workerThreads[i].Start(ioPorts[i]);
            }

            listenerThreads = new Thread[1];
            for (int i = 0; i < listenerThreads.Length; i++)
            {
                listenerThreads[i] = new Thread(new ParameterizedThreadStart(SocketWorkerRoutine));
                listenerThreads[i].Start(listenIoPort);
            }

            Winsock.WSADATA data = new Winsock.WSADATA();
            int error = Winsock.WSAStartup(0x0202, ref data);
            if (error != 0)
            {
                throw new MySocketException(String.Format("WSAStartup failed!  Error = {0}.", error));
            }
        }

        /// <summary>
        /// Size in bytes of the read buffers.
        /// </summary>
        public int ReadBufferSize
        {
            get { return this.readBufferSize; }
        }

        /// <summary>
        /// Size in bytes of the write buffers.
        /// </summary>
        public int WriteBufferSize
        {
            get { return this.writeBufferSize; }
        }

        /// <summary>
        /// Start listening on the specified port.
        /// </summary>
        /// <param name="ipAddress"></param>
        /// <param name="port"></param>
        /// <returns>The index of the listen socket</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public int Listen(IPAddress ipAddress, int port)
        {
            byte[] addressBytes = ipAddress.GetAddressBytes();
            int SendBufferSize = 256;
            int ReceiveBufferSize = 128;

            //
            // Create socket and set default options.
            //

            IntPtr sock = Winsock.WSASocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, IntPtr.Zero, 0, Winsock.WSA_FLAG_OVERLAPPED);

            if (sock == Kernel32.INVALID_HANDLE_VALUE) throw new MySocketException(Marshal.GetLastWin32Error());

            if (Winsock.setsockopt(sock, SocketOptionLevel.Socket, SocketOptionName.SendBuffer, ref SendBufferSize, sizeof(int)) != 0 ||
                Winsock.setsockopt(sock, SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, ref ReceiveBufferSize, sizeof(int)) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // Enable keep-alives
            //

            int receiveSize = 0;
            Winsock.tcp_keepalive keepalive = new Winsock.tcp_keepalive();
            keepalive.onOff = 0;

            if (tcpKeepAliveTimeout > 0)
            {
                keepalive.onOff = 1;
                keepalive.keepAliveTime = tcpKeepAliveTimeout;
                keepalive.keepAliveInterval = 1000;
            }

            GCHandle hKeepalive = GCHandle.Alloc(keepalive, GCHandleType.Pinned);

            try
            {
                if (Winsock.WSAIoctl(sock, IOControlCode.KeepAliveValues, hKeepalive.AddrOfPinnedObject(), Marshal.SizeOf(keepalive), new IntPtr(0), 0, ref receiveSize, new IntPtr(0), new IntPtr(0)) != 0)
                {
                    Winsock.closesocket(sock);
                    
                    throw new MySocketException(Marshal.GetLastWin32Error());
                }
            }
            finally
            {
                hKeepalive.Free();
            }

            //
            // Bind socket
            //


            Winsock.sockaddr_in sockaddr = new Winsock.sockaddr_in(BitConverter.ToInt32(addressBytes, 0), port);

            if (Winsock.bind(sock, ref sockaddr, Marshal.SizeOf(sockaddr)) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // set listen backlog
            //

            if (Winsock.listen(sock, 5000) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // Allocate entry
            //

            int index = Allocate();
            if (index < 0)
            {
                Winsock.closesocket(sock);
                throw new OutOfMemoryException("Not enough room in the socket array.");
            }

            //
            // Initialize, bind to io port and return
            //

            int returnIndex = sockets[index].Initialize(
                index,
                sock,
                MySocket.AddOffset(readBuffers, readBufferSize * index),
                readBufferSize,
                MySocket.AddOffset(writeBuffers, writeBufferSize * index),
                writeBufferSize,
                MySocket.AddOffset(overlappedBuffers, 3 * index * MyOverlapped.Size)
                );

            IntPtr returnPort = Kernel32.CreateIoCompletionPort(sock, listenIoPort, (IntPtr)returnIndex, 0);
            if (returnPort != listenIoPort)
            {
                int error = Marshal.GetLastWin32Error();
                if (sockets[index].Close(returnIndex, true)) Free(index);

                throw new MySocketException(String.Format("Call to bind the listen socket {0} to the IoPort {1} returned {2} and failed with error {3}.",
                    sock, listenIoPort, returnPort, error));
            }

            return returnIndex;
        }

        /// <summary>
        /// Post an accept on the listen socket
        /// </summary>
        /// <param name="listenSocketIndex"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        public SocketError PostAccept(int listenSocketIndex, AcceptCallback callback)
        {
            int index = GetRealIndex(listenSocketIndex);
            IntPtr listenSocket = sockets[index].sock;
            IntPtr acceptSocket = Winsock.WSASocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, IntPtr.Zero, 0, Winsock.WSA_FLAG_OVERLAPPED);
            int acceptIndex = Allocate();
            if (acceptIndex < 0)
            {
                Winsock.closesocket(acceptSocket);
                return SocketError.TooManyOpenSockets;
            }
            acceptIndex = sockets[acceptIndex].Initialize(
                acceptIndex,
                acceptSocket,
                MySocket.AddOffset(readBuffers, readBufferSize * acceptIndex),
                readBufferSize,
                MySocket.AddOffset(writeBuffers, writeBufferSize * acceptIndex),
                writeBufferSize,
                MySocket.AddOffset(overlappedBuffers, 3 * acceptIndex * MyOverlapped.Size));
            SocketError error = sockets[index].PostAccept(listenSocketIndex, acceptSocket, acceptIndex, callback);
            if (SocketError.Success != error)
            {
                Close(acceptIndex);
            }

            return error;
        }

        /// <summary>
        /// Bind the newly accepted socket to the same io port as teh listen socket
        /// </summary>
        /// <param name="listenSocketIndex"></param>
        /// <param name="acceptSocketIndex"></param>
        /// <param name="sendBufferSize"></param>
        /// <param name="receiveBufferSize"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public void BindToIoPort(int listenSocketIndex, int acceptSocketIndex, int sendBufferSize, int receiveBufferSize)
        {
            listenSocketIndex = GetRealIndex(listenSocketIndex);
            int index = acceptSocketIndex = GetRealIndex(acceptSocketIndex);

            IntPtr listenSocket = sockets[listenSocketIndex].sock;
            IntPtr acceptSocket = sockets[acceptSocketIndex].sock;

            IntPtr returnPort = Kernel32.CreateIoCompletionPort(acceptSocket, ioPorts[acceptSocketIndex % ioPorts.Length], (IntPtr)sockets[acceptSocketIndex].index, 0);
            if (returnPort != ioPorts[acceptSocketIndex % ioPorts.Length])
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "Call to bind the Listen socket to the ioport failed with error {0}.", Marshal.GetLastWin32Error()
                    ));
            }

            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.UpdateAcceptContext, ref listenSocket, IntPtr.Size) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(UpdateAcceptContext) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int noDelay = 1;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Tcp, SocketOptionName.NoDelay, ref noDelay, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(NoDelay) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int keepAlive = (tcpKeepAliveTimeout > 0) ? 1 : 0;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.KeepAlive, ref keepAlive, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(KeepAlive) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int sendBufferSizeOverride = 0;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.SendBuffer, ref sendBufferSizeOverride, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(SendBuffer) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, ref receiveBufferSize, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(ReceiveBuffer) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            sockets[index].boundToIoPort = true;
        }

        /// <summary>
        /// Post a read on an accepted socket
        /// </summary>
        /// <param name="socketIndex"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        public SocketError PostRead(int socketIndex, ReadCallback callback)
        {
            int index = GetRealIndex(socketIndex);
            if (!sockets[index].boundToIoPort) throw new MySocketException("PostWrite must be called after binding the socket to an io port.");
            return sockets[index].PostRead(socketIndex, callback);
        }

        /// <summary>
        /// Post a write on an accepted socket
        /// </summary>
        /// <param name="socketIndex"></param>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="bytesToWrite"></param>
        /// <param name="writeCallback"></param>
        /// <returns></returns>
        public SocketError PostWrite(int socketIndex, byte[] buffer, int offset, int bytesToWrite, WriteCallback writeCallback)
        {
            int index = GetRealIndex(socketIndex);
            if (!sockets[index].boundToIoPort) throw new MySocketException("PostWrite must be called after binding the socket to an io port.");
            return sockets[index].PostWrite(socketIndex, buffer, offset, bytesToWrite, writeCallback);
        }

        /// <summary>
        /// Close the socket
        /// </summary>
        /// <param name="socketIndex"></param>
        public void Close(int socketIndex)
        {
            int index = (socketIndex & MySocket.indexMask);
            if (sockets[index].Close(socketIndex, true)) Free(index);
        }

        /// <summary>
        /// The total number of sockets including listening sockets.
        /// </summary>
        public int ConnectionsCount
        {
            get { return count; }
        }

        /// <summary>
        /// Closedown the socket layer.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public void Close()
        {
            //
            // Get rid of all the threads.
            //

            if (workerThreads != null)
            {
                for (int i = 0; i < workerThreads.Length; i++)
                {
                    Kernel32.PostQueuedCompletionStatus(ioPorts[i], 0, -1, (IntPtr)0);
                }

                for (int i = 0; i < workerThreads.Length; i++)
                    workerThreads[i].Join();

                workerThreads = null;
            }

            if (listenerThreads != null)
            {
                for (int i = 0; i < listenerThreads.Length; i++)
                {
                    Kernel32.PostQueuedCompletionStatus(listenIoPort, 0, -1, (IntPtr)0);
                }

                for (int i = 0; i < listenerThreads.Length; i++)
                    listenerThreads[i].Join();

                listenerThreads = null;
            }

            if (IntPtr.Zero != readBuffers)
            {
                Marshal.FreeHGlobal(readBuffers);
                readBuffers = IntPtr.Zero;
            }

            if (IntPtr.Zero != writeBuffers)
            {
                Marshal.FreeHGlobal(writeBuffers);
                writeBuffers = IntPtr.Zero;
            }

            if (IntPtr.Zero != overlappedBuffers)
            {
                Marshal.FreeHGlobal(overlappedBuffers);
                overlappedBuffers = IntPtr.Zero;
            }

        }

        void SocketWorkerRoutine(object parameter)
        {
            IntPtr ioPort = (IntPtr)parameter;

            //
            // Get completion status and operate.
            //

            while (true)
            {

                try
                {
                    //
                    // Now call GetQueuedCompletionStatus to hang out there.
                    //

                    int bytesRead = 0;
                    int key = -1;
                    IntPtr overlappedPtr = IntPtr.Zero;
                    Kernel32.GetQueuedCompletionStatus(
                        ioPort,
                        ref bytesRead,
                        ref key,
                        ref overlappedPtr,
                        -1);

                    try
                    {
                        if (overlappedPtr != IntPtr.Zero)
                        {
                            int index = (key & MySocket.indexMask);
                            sockets[index].OnCompletion(key, overlappedPtr);
                        }
                        else
                        {
                            int error = Marshal.GetLastWin32Error();
                            Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + string.Format("GetQueuedCompletionStatus returned {0}. Quitting thread.", error) +")");

                            break; // exit the loop/
                        }
                    }
                    catch (Exception e)
                    {
                        unhandledSocketExceptionCount++;
                        Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + e.ToString() +")");
                    }
                }
                catch
                {
                    unhandledUnmanagedExceptionCount++;
                }
            }

        }

        int Allocate()
        {
            lock (syncRoot)
            {
                int i = firstFree;
                if (i >= 0)
                {
                    firstFree = sockets[i].nextFree;
                    count++;
                    sockets[i].nextFree = -1;
                    if (firstFree == -1) lastFree = -1;
                }

                return i;
            }
        }

        void Free(int index)
        {
            if (index >= 0)
            {
                lock (syncRoot)
                {
                    if (sockets[index].nextFree == -1)
                    {
                        if (lastFree >= 0)
                        {
                            sockets[lastFree].nextFree = index;
                        }
                        lastFree = index;
                        if (firstFree < 0) firstFree = lastFree;
                        count--;
                    }
                }
            }
        }

        public IPAddress IPAddress(int index)
        {
            return sockets[GetRealIndex(index)].IPAddress;
        }

        public ushort Port(int index)
        {
            return sockets[GetRealIndex(index)].Port;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\XCacheData.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.XCache
{
    public class XCacheUserData
    {
        public ulong qwUserID;
        public ulong qwPassportID;
        public string sGamertag;

        public XCacheUserData nextUserID;
        public XCacheUserData nextPassportID;
        public XCacheUserData nextGamertag;
    }

    public class XCacheUserIDLookupHelper : IXCacheLookupTableHelper<ulong, XCacheUserData>
    {
        public bool Equals(ulong key1, ulong key2)
        {
            return (key1 == key2);
        }

        public int GetHashCode(ulong key)
        {
            return XCacheLookup.HashULong(key);
        }

        public ulong GetKey(XCacheUserData item)
        {
            return item.qwUserID;
        }

        public void SetKey(XCacheUserData item, ulong key)
        {
            item.qwUserID = key;
        }

        public XCacheUserData GetNext(XCacheUserData item)
        {
            return item.nextUserID;
        }

        public void SetNext(XCacheUserData item, XCacheUserData next)
        {
            item.nextUserID = next;
        }
    }
    
    public class XCachePassportIDLookupHelper : IXCacheLookupTableHelper<ulong, XCacheUserData>
    {
        public bool Equals(ulong key1, ulong key2)
        {
            return (key1 == key2);
        }

        public int GetHashCode(ulong key)
        {
            return XCacheLookup.HashULong(key);
        }

        public ulong GetKey(XCacheUserData item)
        {
            return item.qwPassportID;
        }

        public void SetKey(XCacheUserData item, ulong key)
        {
            item.qwPassportID = key;
        }

        public XCacheUserData GetNext(XCacheUserData item)
        {
            return item.nextPassportID;
        }

        public void SetNext(XCacheUserData item, XCacheUserData next)
        {
            item.nextPassportID = next;
        }
    }
    
    public class XCacheGamertagLookupHelper : IXCacheLookupTableHelper<string, XCacheUserData>
    {
        public bool Equals(string key1, string key2)
        {
            return String.Equals(key1, key2, StringComparison.OrdinalIgnoreCase);
        }

        public int GetHashCode(string key)
        {
            // Despite our efforts to prevent it, gamertags still often differ by only spacing.  This is because when we 
            // decided to change our stance here, we merely FNCed everyone that had a spacing collision.  Some of 
            // those users have not since logged in and performed the name change.  It's possible that once we do 
            // the full xbox1 tagfrag run, this would no longer be the case.  Until then, we cannonize on casing, but 
            // spacing still causes differentiation here.
            return key.ToLower().GetHashCode();
        }

        public string GetKey(XCacheUserData item)
        {
            return item.sGamertag;
        }

        public void SetKey(XCacheUserData item, string key)
        {
            item.sGamertag = key;
        }

        public XCacheUserData GetNext(XCacheUserData item)
        {
            return item.nextGamertag;
        }

        public void SetNext(XCacheUserData item, XCacheUserData next)
        {
            item.nextGamertag = next;
        }
    }
    
    public class XCacheLookup
    {
        public static void AddGamertagMapping(ulong qwUserID, string sGamertag)
        {
            AddUserMapping<string>(qwUserID, sGamertag, XCacheService.Instance.GamertagLookups, XCacheCounters.Current.NumGamertags);
        }

        public static void AddPassportMapping(ulong qwUserID, ulong qwPassportID)
        {
            AddUserMapping<ulong>(qwUserID, qwPassportID, XCacheService.Instance.PassportIDLookups, XCacheCounters.Current.NumPassports);
        }

        internal static void AddUserMapping<KeyType>(
            ulong qwUserID, 
            KeyType key, 
            XCacheLookupTable<KeyType, XCacheUserData> table, 
            PerformanceCounter totalCounter)
        {
            XCacheUserData userData = null;
            XCacheUserData keyData = null;
            KeyType oldKey = default(KeyType);

            // first lookup by userid.
            using (XCacheLookupTableLockHandle lhUser = XCacheService.Instance.UserIDLookups.LockItemByKey(qwUserID))
            {
                userData = XCacheService.Instance.UserIDLookups.FindLookupItem(lhUser, qwUserID);
                if (userData != null)
                {
                    // found the userid.  hold on to his old key.
                    oldKey = table.Helper.GetKey(userData);
                }
                else
                {
                    // we need to add a new userid.
                    userData = new XCacheUserData();
                    userData.qwUserID = qwUserID;
                    XCacheService.Instance.UserIDLookups.AddLookupItem(lhUser, userData);
                    XCacheCounters.Current.NumUsers.Increment();
                }
            }

            // did we have an old key?
            if (!table.Helper.Equals(oldKey, default(KeyType)))
            {
                using (XCacheLookupTableLockHandle lhKey = table.LockItemByKey(oldKey))
                {
                    keyData = table.FindLookupItem(lhKey, oldKey);
                    if (keyData != null)
                    {
                        // remove the index on the old key.
                        table.RemoveLookupItem(lhKey, keyData);
                        totalCounter.Decrement();
                        table.Helper.SetKey(keyData, default(KeyType));
                    }
                }
            }

            // now lookup by new key.
            using (XCacheLookupTableLockHandle lhKey = table.LockItemByKey(key))
            {
                keyData = table.FindLookupItem(lhKey, key);
                if (keyData != null)
                {
                    // remove anything that was already there.
                    table.RemoveLookupItem(lhKey, keyData);
                    totalCounter.Decrement();
                    table.Helper.SetKey(keyData, default(KeyType));
                }

                // update the new key and re-add the index.
                table.Helper.SetKey(userData, key);
                
                table.AddLookupItem(lhKey, userData);
                totalCounter.Increment();
            }
        }

        public static void RemoveUser(ulong qwUserID)
        {
            XCacheUserData userData = null;
            string gamertag = null;
            ulong passport = 0;

            // first lookup by userid.
            using (XCacheLookupTableLockHandle lhUser = XCacheService.Instance.UserIDLookups.LockItemByKey(qwUserID))
            {
                userData = XCacheService.Instance.UserIDLookups.FindLookupItem(lhUser, qwUserID);
                if (userData != null)
                {
                    // found the userid.  hold on to his old stuff.
                    gamertag = userData.sGamertag;
                    passport = userData.qwPassportID;

                    // remove the userid index.
                    XCacheService.Instance.UserIDLookups.RemoveLookupItem(lhUser, userData);
                    XCacheCounters.Current.NumUsers.Decrement();
                    userData.qwUserID = 0;
                }
            }

            // did we have an old gamertag?
            if (gamertag != null)
            {
                using (XCacheLookupTableLockHandle lhGamertag = XCacheService.Instance.GamertagLookups.LockItemByKey(gamertag))
                {
                    XCacheUserData gamertagData = XCacheService.Instance.GamertagLookups.FindLookupItem(lhGamertag, gamertag);
                    if (gamertagData != null)
                    {
                        // remove the index on the old gamertag.
                        XCacheService.Instance.GamertagLookups.RemoveLookupItem(lhGamertag, gamertagData);
                        XCacheCounters.Current.NumGamertags.Decrement();
                        gamertagData.sGamertag = null;
                    }
                }
            }

            // did we have an old passport?
            if (passport != 0)
            {
                using (XCacheLookupTableLockHandle lhPassport = XCacheService.Instance.PassportIDLookups.LockItemByKey(passport))
                {
                    XCacheUserData passportData = XCacheService.Instance.PassportIDLookups.FindLookupItem(lhPassport, passport);
                    if (passportData != null)
                    {
                        // remove the index on the old passport.
                        XCacheService.Instance.PassportIDLookups.RemoveLookupItem(lhPassport, passportData);
                        XCacheCounters.Current.NumPassports.Decrement();
                        passportData.qwPassportID = 0;
                    }
                }
            }
        }

        public static int HashULong(ulong qw)
        {
            // this hash function is taken from http://murmurhash.googlepages.com/
            
            // 'm' and 'r' are mixing constants generated offline.
            // They're not really 'magic', they just happen to work well.
            const uint m = 0x5bd1e995;
            const int r = 24;

            // the algorithm allows for a seed here, but we dont need it.
            uint h = 1;

            // Mix 4 bytes at a time into the hash
            for (int iData = 0; iData < 2; iData++)
            {
                uint k = (uint)(qw >> (32 * iData));

                k *= m;
                k ^= (k >> r);
                k *= m;

                h *= m;
                h ^= k;
            }

            // Do a few final mixes of the hash to ensure the last few
            // bytes are well-incorporated.
            h ^= (h >> 13);
            h *= m;
            h ^= (h >> 15);

            return (int)h;
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\XCache.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Net;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;

using System.Threading;
using xonline.common.config;

using MS.Msn.Messenger.Runtime;

[assembly: ConfigAttribute(xonline.common.config.Component.xcache)]

[assembly: XomAreaDefinition(XomAreaName.XCacheLog)]
[assembly: XomAreaDefinition(XomAreaName.XCacheClient)]
[assembly: XomAreaDefinition(XomAreaName.XCacheDatabase)]
[assembly: XomAreaDefinition(XomAreaName.XCacheLookup)]

namespace xonline.server.XCache
{
    public class XCacheService : System.ServiceProcess.ServiceBase
    {
        private TcpConnectionListener m_ConnListener = null;

        private XCacheLookupTable<ulong, XCacheUserData> m_UserIDLookups = null;
        public XCacheLookupTable<ulong, XCacheUserData> UserIDLookups
        {
            get
            {
                return m_UserIDLookups;
            }
        }

        private XCacheLookupTable<string, XCacheUserData> m_GamertagLookups = null;
        public XCacheLookupTable<string, XCacheUserData> GamertagLookups
        {
            get
            {
                return m_GamertagLookups;
            }
        }
        
        private XCacheLookupTable<ulong, XCacheUserData> m_PassportIDLookups = null;
        public XCacheLookupTable<ulong, XCacheUserData> PassportIDLookups
        {
            get
            {
                return m_PassportIDLookups;
            }
        }

        public bool DisconnectSockets { get; set; }

        private bool m_fRunAsConsole = false;

        private IInterfaceInfo m_iface = null;
        public IInterfaceInfo LocalInterfaceInfo
        {
            get
            {
                return m_iface;
            }
        }

        private static XCacheService _instance = null;
        public static XCacheService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new XCacheService();
                }
                return _instance;
            }
        }

        private XCacheDatabaseReader m_dbReader = null;
        public bool IsInitComplete {get; set; }

        private int m_cbMaxMessageSize;
        public int MaxMessageBytes
        {
            get
            {
                return m_cbMaxMessageSize;
            }
        }
        
        public XCacheService()
        {          
        }

        public void Log(string sDelim, params Object[] args)
        {
            StringBuilder sb = new StringBuilder();
            for (int iArg = 0; iArg < args.Length; iArg++)
            {
                sb.Append((args[iArg] == null) ? "{null}" : args[iArg]);

                if (iArg < args.Length - 1)
                    sb.Append(sDelim);
            }

            Log(sb.ToString());
        }

        public void Log(string output)
        {
            if (m_fRunAsConsole)
            {
                Console.WriteLine(output);
            }
            
            Xom.Log(XomAreaName.XCacheLog, output);
        }
        
        /// <summary>
        /// Set things in motion so your service can do its work.
        /// </summary>
        protected override void OnStart(string[] args)
        {           
            InitService();            
            Xom.NtEvent(XEvent.Id.XCACHE_STARTED, "XCache server has been started.");
        }
 
        /// <summary>
        /// Stop this service.
        /// </summary>
        protected override void OnStop()
        {
            CloseService();
            _instance = null;
            Xom.NtEvent(XEvent.Id.XCACHE_SHUTDOWN, "XCache server has been shutdown.");
        }

        public void Start()
        {
            OnStart(null);
        }

        private void InitService()
        {                   
            try
            {
                Config.Assembly = System.Reflection.Assembly.GetExecutingAssembly();
                XomLoggingControl.Init();

                m_iface = Config.GetInterface(Interface.xcache);
                IVirtualInterfaceInfo ivii = Config.GetVirtualInterface(VirtualInterface.xcache);
                IPEndPoint ipListen = new IPEndPoint(IPAddress.Any, ivii.PortEnd);
                int cbReadBuffer = Config.GetIntSetting(Setting.XCache_SocketBufferSize);
                int cbWriteBuffer = Config.GetIntSetting(Setting.XCache_SocketBufferSize);
                int cMaxSockets = Config.GetIntSetting(Setting.XCache_MaxClientSockets);
                m_cbMaxMessageSize = Config.GetIntSetting(Setting.XCache_MaxMessageBytes);

                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

                m_UserIDLookups = new XCacheLookupTable<ulong, XCacheUserData>(Config.GetIntSetting(Setting.xcache_userid_hash_buckets), new XCacheUserIDLookupHelper());
                m_GamertagLookups = new XCacheLookupTable<string, XCacheUserData>(Config.GetIntSetting(Setting.xcache_gamertag_hash_buckets), new XCacheGamertagLookupHelper());
                m_PassportIDLookups = new XCacheLookupTable<ulong, XCacheUserData>(Config.GetIntSetting(Setting.xcache_passport_hash_buckets), new XCachePassportIDLookupHelper());

                XCacheEngine.Init();

                m_dbReader = new XCacheDatabaseReader();
                m_dbReader.Init();

                m_ConnListener = new TcpConnectionListener(
                    ipListen,
                    cbReadBuffer,
                    cbWriteBuffer,
                    cMaxSockets,
                    0);

                m_ConnListener.Connected += ClientConnection.OnConnect;
                
                m_ConnListener.Start();

                // Register for setting changes
                Config.SettingChange += OnSettingChange;

                xonline.common.health.HealthListener.InitializeHealthListener(Config.ComponentName);
                
                Log("|", "INIT", "XCache Server initialized.");
            }
            catch (Exception e)
            {
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    Xom.NtEvent(xrle.EventId, xrle, "Failed to initialize xcache server.");
                }
                Xom.NtEvent(XEvent.Id.XCACHE_STARTUP_FAILURE, e, "Failed to initialize xcache server.");
                throw;
            }
        }

        private void CloseService()
        {
            Log("|", "SHTDWN", "XCache Server shutting down.");
                
            ((IDisposable)m_ConnListener).Dispose();

            m_dbReader.Shutdown();
            
            XCacheEngine.Shutdown();

            XomLoggingControl.Close();
        }

        string HelpString
        {
            get
            {
                return 
                "\r\nXCache Commands:\r\n\r\n" +
                "\thelp:\tshow this help message.\r\n" +
                "\tdisconnect: close all connections after responding to requests.\r\n" +                
                "\tconnect: retain connections.  (undo for 'disconnect')\r\n" +                
                "\tlookupxuid <userid>: show cached data for a user by xuid.\r\n" +                
                "\tlookupgamertag <gamertag>: show cached data for a user by gamertag.\r\n" +                
                "\tlookuppassport <passportid>: show cached data for a user by puid.\r\n" +   
                "\tshowpartitioninfo: show most recent timestamp collected from each partition.\r\n" +
                "\r\n\tquit:\tshutdown server (console mode only).\r\n";
            }
        }

        string HandleManangementCommand(ControlRequestEventArgs args)
        {
            switch (args.Command.ToLower())
            {
                case "help":
                    // leave handled as false to allow for all handlers to process help.
                    return HelpString;

                case "disconnect":
                    return AdminControl.AdminDisconnect(args);
                    
                case "connect":
                    return AdminControl.AdminConnect(args);
                    
                case "lookupxuid":
                    return AdminControl.AdminLookupXUID(args);

                case "lookupgamertag":
                    return AdminControl.AdminLookupGamertag(args);

                case "lookuppassport":
                    return AdminControl.AdminLookupPassport(args);

                case "showpartitioninfo":
                    args.Handled = true;
                    return m_dbReader.AdminShowPartitionInfo();

                case "quit":
                    args.Handled = true;
                    if (m_fRunAsConsole != true)
                    {
                        return "Server running in service mode.  Cannot quit.";
                    }
                    else
                    {
                        m_fRunAsConsole = false;
                        return "Exiting.";
                    }
                        
                default:
                    return "";
            }
        }

        void RunAsConsole(string[] args)
        {
            OnStart(args);

            try
            {
                Console.WriteLine("Running as console.  Type \"help\" for commands.");

                while (m_fRunAsConsole)
                {
                    string sCommand = Console.ReadLine();
                    string sResponse = "Invalid Command.";
                    try
                    {
                        ControlRequestEventArgs cmdArgs = new ControlRequestEventArgs(sCommand, 0);
                        sResponse = HandleManangementCommand(cmdArgs);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error: " + e.ToString());
                    }

                    Console.WriteLine(sResponse);
                }
            }
            finally
            {
                OnStop();
            }
        }

        // The main entry point for the process
        static void Main(string[] args)
        {           
            XCacheService srv = XCacheService.Instance;
            
            foreach (string sArg in args)
            {
                if (sArg.ToLower().Contains("console"))
                {
                    srv.m_fRunAsConsole = true;
                }
            }

            if (srv.m_fRunAsConsole)
            {
                srv.RunAsConsole(args);
            }
            else
            {
                System.ServiceProcess.ServiceBase.Run(srv);
            }
        }

        //This is implemented solely so that bucket remapping will now succeed. 
        //See config.cs func RefreshInterfaceBuckets() -- if you don't add a bucketchange delegate
        //then the bucket change will NOT update the cache, breaking in Xenon 91109.
        public static void ChangeBucketMap(object sender, InterfaceBucketChangeEventArgs e)
        {
            return;
        }
        
        // -------------------------------------------------------------------------
        // OnSettingChange - handles changes to npdb settings
        // -------------------------------------------------------------------------
        public static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            if (eventArgs.Setting == Setting.XCache_MaxMessageBytes)
            {
                Instance.m_cbMaxMessageSize = Int32.Parse(eventArgs.ValueNew);
            }
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string sResponse = XCacheService.Instance.HandleManangementCommand(args);
                XomControlConnection.SendMessage(sResponse + "\r\n", args.RequestId);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n", args.RequestId);
            }
        }

    }        

    [XomPerformanceCounterCategoryAttr( "XCache Svc", "Xbox Live XCache Server" )]
    public class XCacheCounters : XomPerformanceCounterCategory
    {
        public XCacheCounters() : base(true)
        {
        }
        
        static public XCacheCounters Current = new XCacheCounters();
        
        [XomPerformanceCounterAttr(
            "Connection Rate", 
            "Total number of connections being created per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ConnectRate;
        
        [XomPerformanceCounterAttr(
            "Client Connections", 
            "Total number of connected clients.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumConnections;
        
        [XomPerformanceCounterAttr(
            "UserID Entries", 
            "Total number of UserIDs.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumUsers;
        
        [XomPerformanceCounterAttr(
            "Gamertag Entries", 
            "Total number of Gamertags.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumGamertags;
        
        [XomPerformanceCounterAttr(
            "PassportID Entries", 
            "Total number of PassportIDs.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumPassports;
        
        [XomPerformanceCounterAttr(
            "UserID Lookup Rate", 
            "Number of users looked up by xuid per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter UserIDLookupRate;
        
        [XomPerformanceCounterAttr(
            "Gamertag Lookup Rate", 
            "Number of users looked up by gamertag per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GamertagLookupRate;
        
        [XomPerformanceCounterAttr(
            "PassportID Lookup Rate", 
            "Number of users looked up by passport per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PassportLookupRate;
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\msgr\ConnectionListener.cs ===
using System;
using System.Net;
using System.Threading;
using System.IO;
using System.Net.Sockets;
using System.Diagnostics;

using xonline.common.mgmt;

namespace MS.Msn.Messenger.Runtime
{
    /// <summary>
    /// delegate for IConnectionListener.Connected event
    /// </summary>
    public delegate void ConnectedCallback(object Source, TcpStream c);

    /// <summary>
    /// Interface shared by all connection listeners.
    /// The ConnectionListener generates server-side TcpStream objects
    /// Subclasses included TCPListener and TLSListener
    /// </summary>
    public interface IConnectionListener
    {
        /// <summary>
        ///   This method starts listening for incoming connections
        ///   on the specified end point.
        /// </summary>
        void Start();

        /// <summary>
        /// Stops listening for incoming connections. Existing connections are not affected
        /// </summary>
        void Stop();

        /// <summary>
        /// Event raised when a new connection is created. Protocol handlers
        /// should consume this event.
        /// </summary>
        event ConnectedCallback Connected;
    }

    /// <summary>
    /// TCP Listener class. Implements generic IConnectionListener interface
    /// Provides asynchronous callback events that are raised when an incoming connection request
    /// is received.
    /// </summary>
    public class TcpConnectionListener : IConnectionListener, IDisposable
    {
        private const int MaxAcceptsPending = 1;

        private readonly SocketLayer socketLayer;
        private readonly IPEndPoint endPoint; 
        private readonly int sendBufferSize;
        private readonly int receiveBufferSize;
        private readonly TcpStream.DisconnectedEventHandler connectionDisconnected;

        // socket to listen for incoming connections
        int listenSocketIndex = -1;

        private int connectionCount = 0;
        private int acceptsPending = 0;

        /// <summary>
        /// Event raised when a new incoming Connection is available
        /// </summary>
        public event ConnectedCallback Connected;

        // callback that is called when BeginAccept on listenSocket completes
        AcceptCallback connectionAcceptedCallback;

        private int maxSocketCount;
        
        /// <summary>
        /// Create a TcpConnectionListener bound to the specified ConectionController and listening
        /// on the given IP address and port
        /// </summary>
        public TcpConnectionListener(IPEndPoint endPoint, int readBufferSize, int writeBufferSize, int maxSockets, uint tcpKeepAliveTimeout)
        {
            if (endPoint == null)
            {
                throw new ArgumentNullException("endPoint");
            }

            this.sendBufferSize = writeBufferSize;
            this.receiveBufferSize = readBufferSize;
            this.endPoint = endPoint;

            this.socketLayer = new SocketLayer(maxSockets, readBufferSize, writeBufferSize, tcpKeepAliveTimeout);
            this.maxSocketCount = maxSockets;

            this.connectionAcceptedCallback = new AcceptCallback(this.ConnectionAccepted);
            this.connectionDisconnected = new TcpStream.DisconnectedEventHandler(this.DisconnectedEventHandler);
        }

        public int ConnectionCount
        {
            get { return this.connectionCount; }
        }

        /// <summary>
        /// Start Listening.
        /// This method is called by the server application.
        /// The connection controller internally throttles acceptance of new connections so
        /// it is possible that the listen may be temporarily disabled.
        /// </summary>
        public virtual void Start()
        {
            lock (this)
            {
                if (listenSocketIndex != -1)
                {
                    throw new InvalidOperationException("Stack is already listening on "
                        + endPoint.ToString());
                }

                listenSocketIndex = socketLayer.Listen(endPoint.Address, endPoint.Port);

                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionListenerStart(" + endPoint.ToString() + ")");

                this.PostAccept();
            }
        }

        /// <summary>
        /// This method is called by the server application to stop listening for incoming connections.
        /// Existing connections are not affected.
        /// </summary>
        public virtual void Stop()
        {
            int socketIndex = -1;
            lock (this)
            {
                if (-1 != listenSocketIndex)
                {
                    socketIndex = listenSocketIndex;
                    listenSocketIndex = -1;
                }
            }

            if (-1 != socketIndex)
            {
                socketLayer.Close(socketIndex);
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_HIGH, "MessengerRuntimeEvents.LogTcpConnectionListenerStop()");
            }
        }

        /// <summary>
        /// Check whether we need to post an accept and post one if needed.
        /// Must be called with lock held.
        /// </summary>
        private void PostAccept()
        {
            if (listenSocketIndex != -1)
            {
                if (this.acceptsPending < MaxAcceptsPending)
                {
                    SocketError error = socketLayer.PostAccept(listenSocketIndex, connectionAcceptedCallback);

                    if (error != SocketError.Success)
                    {
                        Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ((int)error).ToString() + ")");

                        if (SocketError.AlreadyInProgress != error && SocketError.TooManyOpenSockets != error)
                            Stop();
                    }
                    else
                    {
                        Interlocked.Increment(ref acceptsPending);
                    }
                }
            }
        }

        /// <summary>
        /// Raise the Connected event.
        /// </summary>
        /// <param name="connection"></param>
        protected void OnConnected(TcpStream connection)
        {
            // indicate the new connection to the protocol layer 
            try
            {
                if (this.Connected != null)
                {
                    this.Connected(this, connection);
                    Interlocked.Increment(ref this.connectionCount);

                    connection.Disconnected += this.connectionDisconnected;
                }
                else
                {
                    connection.Dispose();
                }
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + e.ToString() +")");
                throw;
            }
        }

        /// <summary>
        /// Handle an incoming connection
        /// This function is virtual so that it can be redefined for TlsConnectionListner
        /// </summary>
        /// <param name="connectedSocketIndex"></param>
        protected virtual void OnSocketConnected(int connectedSocketIndex)
        {
            // allow reads and writes
            socketLayer.BindToIoPort(listenSocketIndex, connectedSocketIndex, sendBufferSize, receiveBufferSize);

            // create a TcpConnection object
            TcpStream connection = new TcpStream(connectedSocketIndex, this.socketLayer);

            this.OnConnected(connection);
        }

        /// <summary>
        /// Called by Socket object on completion of BeginAccept
        /// </summary>
        /// <param name="acceptedSocketIndex"></param>
        /// <param name="error"></param>
        private void ConnectionAccepted(int acceptedSocketIndex, SocketError error)
        {
            if (SocketError.Success != error)
            {
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ((int)error).ToString() +")");
            }
            else
            {
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionListenerAccept(" + acceptedSocketIndex.ToString() +")");
            }

            lock (this)
            {
                Interlocked.Decrement(ref this.acceptsPending);
                this.PostAccept();
            }

            if (SocketError.Success != error)
            {
                this.socketLayer.Close(acceptedSocketIndex);
                return;
            }

            TcpStream connection = null;

            try
            {
                // new connection handling
                socketLayer.BindToIoPort(listenSocketIndex, acceptedSocketIndex, sendBufferSize, receiveBufferSize);
                connection = new TcpStream(acceptedSocketIndex, this.socketLayer);

                this.OnConnected(connection);
            }
            catch (Exception ex)
            {
                Xom.Trace(XomAreaName.XCacheClient, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ex.ToString() +")");
                if (connection != null) connection.Dispose();
            }
        }

        public void DisconnectedEventHandler(TcpStream sender, Exception reason)
        {
            int currentCount = Interlocked.Decrement(ref this.connectionCount);

            //
            // Always call PostAccept() to check whether we need to post a new accept.
            //
            // We rely on the lower SocketLayer to enforce the maximum number of simultaneous connections by
            // failing to post accepts when we are at capacity.
            //

            lock (this)
            {
                this.PostAccept();
            }
        }

        void IDisposable.Dispose()
        {
            if (null != socketLayer)
            {
                socketLayer.Close();
            }

            this.Stop();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\QueryTool\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\QueryTool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\inh\msgr\TcpStream.cs ===
//-----------------------------------------------------------------------
// <copyright file="TcpStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
// TcpStream is an abstraction of the network connection.
// TcpConnection and TlsConnection are derived from this class.
// A System.IO.Stream implementation is provided via the Stream property for reading
// and writing. [However it does not derive from Stream because this prevents common 
// functionality from being added to the TcpStream base class]
// </summary>
//-----------------------------------------------------------------------

namespace MS.Msn.Messenger.Runtime
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.Threading;
    using System.IO;
    using System.Net.Sockets;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    /// <summary>
    /// TcpStream is an abstraction of the network connection.
    /// TcpConnection and TlsConnection are derived from this class.
    /// A System.IO.Stream implementation is provided via the Stream property for reading
    /// and writing. [However it does not derive from Stream because this prevents common 
    /// functionality from being added to the TcpStream base class]
    /// </summary>
    public class TcpStream : Stream
    {
        private Queue<WriteAsyncResult> writeBufferQueue = new Queue<WriteAsyncResult>();
        private int sock;
        private SocketLayer socketLayer;
        private ReadCallback readCallback;
        private WriteCallback writeCallback;
        private ReadAsyncResult currentReadState;
        private WriteAsyncResult currentWriteState;
        private bool writePending = false;
        private int firedDisconnected;

        /// <summary>
        /// The TcpStream class is created by the TcpConnectionListener so no public
        /// constructor is exposed.
        /// 
        /// </summary>
        /// <param name="sock">the underlying socket</param>
        /// <param name="socketLayer">parent socket layer</param>
        internal TcpStream(int sock, SocketLayer socketLayer)
            : base()
        {
            this.sock = sock;
            this.socketLayer = socketLayer;
            this.readCallback = new ReadCallback(this.OnReadCompleted);
            this.writeCallback = new WriteCallback(this.OnWriteCompleted);
        }

        /// <summary>
        /// Dispose of this stream and free up the socket.
        /// </summary>
        ~TcpStream()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Disconnect delegate
        /// </summary>
        /// <param name="sender">Stream that is being closed</param>
        /// <param name="reason">exception that was thrown (if any)</param>
        public delegate void DisconnectedEventHandler(TcpStream sender, Exception reason);

        /// <summary>
        /// Event that is invoked when a connection is disconnected
        /// A consumer of this method is the ConnectionController.
        /// </summary>
        public event DisconnectedEventHandler Disconnected;

        /// <summary>
        /// True.  Stream is readable.
        /// </summary>
        public override bool CanRead
        {
            get { return true; }
        }

        /// <summary>
        /// False.  (Stream does not support seek)
        /// </summary>
        public override bool CanSeek
        {
            get { return false; }
        }

        /// <summary>
        /// True.  Stream is writeable.
        /// </summary>
        public override bool CanWrite
        {
            get { return true; }
        }

        /// <summary>
        /// Throws exception.  (Stream does not support seek)
        /// </summary>
        public override long Length
        {
            get { throw new NotSupportedException("Cannot seek."); }
        }

        /// <summary>
        /// Throws exception.  (Stream does not support seek)
        /// </summary>
        public override long Position
        {
            get
            {
                throw new NotSupportedException("Cannot seek.");
            }

            set
            {
                throw new NotSupportedException("Cannot seek.");
            }
        }

        /// <summary>
        /// Socket ID
        /// </summary>
        public int Sock
        {
            get { return this.sock; }
        }

        /// <summary>
        /// Returns the remote IP address.
        /// </summary>
        public IPAddress IPAddress
        {
            get { return this.socketLayer.IPAddress(this.sock); }
        }

        /// <summary>
        /// Returns the remote port.
        /// </summary>
        public ushort Port
        {
            get { return this.socketLayer.Port(this.sock); }
        }

        /// <summary>
        /// Async read.  Blocks until bytes are received.  Should not be used except in testing.
        /// </summary>
        /// <param name="buffer">buffer to copy data to</param>
        /// <param name="offset">offset</param>
        /// <param name="count">max number of bytes to copy</param>
        /// <returns>number of bytes actually read.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            IAsyncResult result = this.BeginRead(buffer, offset, count, null, null);
            return this.EndRead(result);
        }

        /// <summary>
        /// Sync write.  Should only be called in unit tests, etc.  Not efficient.
        /// </summary>
        /// <param name="buffer">data to write</param>
        /// <param name="offset">offset from which to begin writing data</param>
        /// <param name="count">number of bytes to write</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            IAsyncResult result = this.BeginWrite(buffer, offset, count, null, null);
            this.EndWrite(result);
        }

        /// <summary>
        /// Not Supported
        /// </summary>
        /// <param name="offset">ignored</param>
        /// <param name="origin">ignored</param>
        /// <returns>nothing</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("Cannot seek.");
        }

        /// <summary>
        /// Not Supported
        /// </summary>
        /// <param name="value">ignored</param>
        public override void SetLength(long value)
        {
            throw new NotSupportedException("Cannot seek.");
        }

        /// <summary>
        /// Does nothing.  Writes are already flushed immediately.
        /// </summary>
        public override void Flush()
        {
            // Ignored.
        }

        /// <summary>
        /// Supply a buffer to read bytes into if data comes over the stream.
        /// </summary>
        /// <param name="buffer">byte buffer</param>
        /// <param name="offset">offset to start copying data to</param>
        /// <param name="size">number of bytes available in buffer</param>
        /// <param name="callback">callback</param>
        /// <param name="state">async state</param>
        /// <returns>async result</returns>
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback callback, object state)
        {
            // We shouldn't pass in a buffer that is smaller than we might possibly get back.
            if (this.socketLayer.ReadBufferSize > size)
            {
                string message = string.Format(
                    "Buffer passed in is too small ({0} bytes).  Must be at least as big as the socket buffer ({1} bytes)",
                    size,
                    this.socketLayer.ReadBufferSize);

                throw new ArgumentException(message, "size");
            }

            ReadAsyncResult result = new ReadAsyncResult(new BufferOffsetSize(buffer, offset, size, false), callback, state);

            int socketIndex = this.sock;

            if (socketIndex != -1)
            {
                // BUGBUG bgarris: technically we should probably lock on this, but we
                // have a logic bug if we can ever have simultaneous reads, so this shouldn't
                // be a problem.  (MySocket will throw an exception anyway)
                // Ultimately, it should be the MySocket layer that implements
                // a Begin/End pattern to solve this problem, but for now, this should be fine.
                this.currentReadState = result;

                SocketError error = this.socketLayer.PostRead(socketIndex, this.readCallback);
                if (error != SocketError.Success)
                {
                    result.CompleteRequest(error, true);
                }
            }

            return result;
        }

        /// <summary>
        /// End a read - should only be called in the callback passed into beginread,
        /// or (if sync is OK) with the return value of BeginRead.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginRead or passed into the callback.</param>
        /// <param name="result">SocketError.Success if OK.  Some other error if not.</param>
        /// <returns>Number of bytes read</returns>
        public int EndRead(IAsyncResult asyncResult, out SocketError result)
        {
            ReadAsyncResult state = (ReadAsyncResult)asyncResult;
            state.BlockUntilCompleted();

            result = state.Result;
            return state.BytesRead;
        }

        /// <summary>
        /// End a read - should only be called in the callback passed into beginread,
        /// or (if sync is OK) with the return value of BeginRead.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginRead or passed into the callback.</param>
        /// <exception cref="SocketException"></exception>
        /// <returns>Number of bytes read</returns>
        public override int EndRead(IAsyncResult asyncResult)
        {
            SocketError result;
            int bytesRead = this.EndRead(asyncResult, out result);
            if (result != SocketError.Success)
            {
                throw new SocketException((int)result);
            }

            return bytesRead;
        }

        /// <summary>
        /// Post a write.
        /// </summary>
        /// <param name="buffer">backing buffer.  should not be modified while write is being made.</param>
        /// <param name="offset">starting position to begin writing from</param>
        /// <param name="size">number of bytes to write</param>
        /// <param name="callback">callback to make after write is completed.</param>
        /// <param name="state">async state</param>
        /// <returns>async result</returns>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int size, AsyncCallback callback, object state)
        {
            WriteAsyncResult result = new WriteAsyncResult(new BufferOffsetSize(buffer, offset, size, false), callback, state);
            AsyncResult<SocketError> resultToReturn = result;

            int socketIndex = this.sock;

            if (socketIndex == -1)
            {
                result.CompleteRequest(SocketError.Shutdown, true);
                return resultToReturn;  // BUGBUG bgarris: I don't like this comment that seems unsure of why we might
                                        // return here:
                                        // "got disposed?"
            }

            lock (this.writeBufferQueue)
            {
                if (size > this.socketLayer.WriteBufferSize)
                {
                    AggregateWriteAsyncResult parent = new AggregateWriteAsyncResult(result, this.socketLayer.WriteBufferSize, callback, state);
                    foreach (WriteAsyncResult subWrite in parent.SubWrites)
                    {
                        this.writeBufferQueue.Enqueue(subWrite);
                    }

                    resultToReturn = parent;

                    if (this.writePending)
                    {
                        return resultToReturn;
                    }
                    else
                    {
                        // we'll start writing the first one.  note that the result we're returning is still the
                        // parent state.
                        result = CoelesceWrites(socketIndex);
                    }
                }
                else
                {
                    if (this.writePending)
                    {
                        this.writeBufferQueue.Enqueue(result);
                        return resultToReturn;
                    }
                }

                this.writePending = true;
            }

            // we have logic to prevent PostWrite from being called multiple times, so as long as we only
            // assign to currentWriteState right before a PostWrite, we should be fine.
            this.currentWriteState = result;

            SocketError error = this.socketLayer.PostWrite(
                socketIndex,
                this.currentWriteState.Buffer.Buffer,
                this.currentWriteState.Buffer.Offset,
                this.currentWriteState.Buffer.Size,
                this.writeCallback);

            if (error != SocketError.Success)
            {
                this.currentWriteState.CompleteRequest(error, true);
            }

            // this might be an aggregate write or a normal write.
            return resultToReturn;
        }

        /// <summary>
        /// End a write - should only be called in the callback passed into beginwrite,
        /// or (if sync is OK) with the return value of BeginWrite.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginWrite or passed into the callback.</param>
        /// <param name="result">SocketError.Success if OK.  Some other error if not.</param>
        public void EndWrite(IAsyncResult asyncResult, out SocketError result)
        {
            AsyncResult<SocketError> state = (AsyncResult<SocketError>)asyncResult;
            state.BlockUntilCompleted();
            result = state.Result;
        }

        /// <summary>
        /// End a write - should only be called in the callback passed into beginwrite,
        /// or (if sync is OK) with the return value of BeginWrite.
        /// </summary>
        /// <exception cref="SocketException"></exception>
        /// <param name="asyncResult">the async result returned from BeginWrite or passed into the callback.</param>
        public override void EndWrite(IAsyncResult asyncResult)
        {
            SocketError result;
            this.EndWrite(asyncResult, out result);
            if (result != SocketError.Success)
            {
                throw new SocketException((int)result);
            }
        }

        /// <summary>
        /// Dispose and close this socket.
        /// </summary>
        /// <param name="disposing">whether or not we're disposing</param>
        protected override void Dispose(bool disposing)
        {
            int disposeSocketIndex = Interlocked.Exchange(ref this.sock, -1);

            if (disposeSocketIndex != -1)
            {
                this.socketLayer.Close(disposeSocketIndex);
                if (disposing)
                {
                    this.OnDisconnected(null);
                }
            }
        }

        /// <summary>
        /// This function is invoked to raise the Disconnected event
        /// This could happen as a result of a network error or an explicit
        /// call to the Disconnect method
        /// </summary>
        /// <param name="reason">optional exception</param>
        private void OnDisconnected(Exception reason)
        {
            // we have to make sure that Disconnected is only called once
            int fired = Interlocked.Exchange(ref this.firedDisconnected, 1);
            if (this.Disconnected != null && fired != 1)
            {
                this.Disconnected(this, reason);
            }
        }

        private void OnReadCompleted(int socketIndex, SocketError error, IntPtr buffer, int offset, int bytes)
        {
            ReadAsyncResult state = this.currentReadState;

            if (error == SocketError.Success)
            {
                // we should have thrown an exception in BeginRead if the buffer wasn't large enough.
                Debug.Assert(bytes <= state.Buffer.Size);

                buffer = (IntPtr)(buffer.ToInt64() + offset);
                Marshal.Copy(buffer, state.Buffer.Buffer, state.Buffer.Offset, bytes);
            }

            state.CompleteRequest(error, false, bytes);
        }

        // called in the lock
        private WriteAsyncResult CoelesceWrites(int socketIndex)
        {
            MultiWriteAsyncResult states = new MultiWriteAsyncResult(this.socketLayer.WriteBufferSize);

            lock (this.writeBufferQueue)
            {
                while (this.writeBufferQueue.Count > 0)
                {
                    WriteAsyncResult state = this.writeBufferQueue.Peek();
                    if ((states.TotalSize + state.Buffer.Size) > states.MaxSize)
                    {
                        // no more room.
                        break;
                    }
                    
                    states.AddWrite(state);

                    SocketError error = this.socketLayer.PostWrite(
                        socketIndex,
                        state.Buffer.Buffer,
                        state.Buffer.Offset,
                        state.Buffer.Size,
                        null);

                    this.writeBufferQueue.Dequeue();
                }
            }

            // we shouldnt be here if the queue was empty to begin with, and nothing in the queue should be bigger than the
            // max size by itself.  so at least 1 item should have fit in the batch.
            Debug.Assert(states.TotalSize > 0);

            return states;
        }

        private void OnWriteCompleted(int socketIndex, SocketError error)
        {
            WriteAsyncResult state = this.currentWriteState;

            state.CompleteRequest(error, false);
            if (SocketError.Success != error)
            {
                // BUGBUG bgarris: ideally we should complete all of the queued writes with a failure.
                // not changing it now for parity with old code.
                return;
            }

            lock (this.writeBufferQueue)
            {
                if (this.writeBufferQueue.Count == 0)
                {
                    this.writePending = false;
                    return;
                }

                state = CoelesceWrites(socketIndex);
            }

            // we have logic to prevent PostWrite from being called multiple times, so as long as we only
            // assign to currentWriteState right before a PostWrite, we should be fine.
            this.currentWriteState = state;

            error = this.socketLayer.PostWrite(
                socketIndex,
                state.Buffer.Buffer,
                state.Buffer.Offset,
                state.Buffer.Size,
                this.writeCallback);

            if (error != SocketError.Success)
            {
                // we didn't complete synchronously because we were called in the callback of another
                // write.  (Even though this particular PostWrite call technically completed synchronously)
                state.CompleteRequest(error, false);
            }
        }

        internal class ReadAsyncResult : AsyncResult<SocketError>
        {
            private BufferOffsetSize buffer;
            private int bytesRead = 0;

            internal ReadAsyncResult(
                BufferOffsetSize buffer,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.buffer = buffer;
            }

            internal BufferOffsetSize Buffer
            {
                get { return this.buffer; }
            }

            internal int BytesRead
            {
                get { return this.bytesRead; }
                set { this.bytesRead = value; }
            }

            internal void CompleteRequest(SocketError result, bool completedSynchronously, int bytesRead)
            {
                this.bytesRead = bytesRead;
                base.CompleteRequest(result, completedSynchronously);
            }
        }

        internal class WriteAsyncResult : AsyncResult<SocketError>
        {
            private BufferOffsetSize buffer;

            internal WriteAsyncResult(
                BufferOffsetSize buffer,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.buffer = buffer;
            }

            internal BufferOffsetSize Buffer
            {
                get { return this.buffer; }
            }
        }

        internal class MultiWriteAsyncResult : WriteAsyncResult
        {
            static byte[] _emptyBuffer = new byte[0];
            
            private List<WriteAsyncResult> multiWrites;
            private int maxSize;
            private int totalSize;
            
            internal int TotalSize
            {
                get { return totalSize; }
            }

            internal int MaxSize
            {
                get { return maxSize; }
            }

            internal MultiWriteAsyncResult(int maxSize)
                : base(new BufferOffsetSize(_emptyBuffer, 0, 0, false), new AsyncCallback(OnWriteCompleted), null)
            {
                this.maxSize = maxSize;
                multiWrites = new List<WriteAsyncResult>();
            }

            internal void AddWrite(WriteAsyncResult result)
            {
                Debug.Assert((totalSize + result.Buffer.Size) <= maxSize);
                
                multiWrites.Add(result);
                totalSize += result.Buffer.Size;
            }

            public static void OnWriteCompleted(IAsyncResult asyncResult)
            {
                MultiWriteAsyncResult result = (MultiWriteAsyncResult)asyncResult;
                SocketError error = result.Result;

                foreach (WriteAsyncResult write in result.multiWrites)
                {
                    write.CompleteRequest(error, result.CompletedSynchronously);
                }
            }
        }

        /// <summary>
        /// We should use this class if a write is too large to be written in one write.
        /// It breaks the write into smaller chunks, and calls its callback when either
        /// the last one completes, or one of them completes with an error result.
        /// </summary>
        internal class AggregateWriteAsyncResult : AsyncResult<SocketError>
        {
            private List<WriteAsyncResult> subWrites;

            private bool hasAlreadyCompleted;

            internal AggregateWriteAsyncResult(
                WriteAsyncResult result,
                int maxSize,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.subWrites = this.Split(result, maxSize);
                this.hasAlreadyCompleted = false;
            }

            internal List<WriteAsyncResult> SubWrites
            {
                get { return this.subWrites; }
            }

            private List<WriteAsyncResult> Split(WriteAsyncResult result, int maxSize)
            {
                List<WriteAsyncResult> results = new List<WriteAsyncResult>();
                AsyncCallback writeCallback = new AsyncCallback(this.OnWriteCompleted);

                byte[] data = result.Buffer.Buffer;
                int offset = result.Buffer.Offset;
                int size = result.Buffer.Size;

                while (size > maxSize)
                {
                    BufferOffsetSize newBuff = new BufferOffsetSize(data, offset, maxSize, false);
                    WriteAsyncResult write = new WriteAsyncResult(newBuff, writeCallback, false);
                    results.Add(write);
                    offset += maxSize;
                    size -= maxSize;
                }

                // note that the async state is 'true' instead of 'false', to signify that this is the last
                // write.
                results.Add(new WriteAsyncResult(new BufferOffsetSize(data, offset, size, false), writeCallback, true));

                return results;
            }

            private void OnWriteCompleted(IAsyncResult asyncResult)
            {
                // no need for locking - Writes are completed one at a time.
                if (this.hasAlreadyCompleted)
                {
                    // we only want to complete if there is an error, or if we're on the last write.
                    // if we get here, that means we've already completed with an error, so we should
                    // ignore the values of all subsequent operations.
                    return;
                }

                WriteAsyncResult result = (WriteAsyncResult) asyncResult;
                bool isLastWrite = (bool)result.AsyncState;
                SocketError error = result.Result;

                if (isLastWrite || error != SocketError.Success)
                {
                    this.hasAlreadyCompleted = true;
                    this.CompleteRequest(error, result.CompletedSynchronously);
                }
            }
        }

        /// <summary>
        /// Copied from internal System.Net.BufferOffsetSize
        /// </summary>
        internal class BufferOffsetSize
        {
            private byte[] buffer;
            private int offset;
            private int size;

            internal BufferOffsetSize(byte[] buffer, bool copyBuffer)
                : this(buffer, 0, buffer.Length, copyBuffer)
            {
            }

            internal BufferOffsetSize(byte[] buffer, int offset, int size, bool copyBuffer)
            {
                if (copyBuffer)
                {
                    byte[] dst = new byte[size];
                    System.Buffer.BlockCopy(buffer, offset, dst, 0, size);
                    offset = 0;
                    buffer = dst;
                }

                this.buffer = buffer;
                this.offset = offset;
                this.size = size;
            }

            internal byte[] Buffer
            {
                get { return this.buffer; }
            }

            internal int Offset
            {
                get { return this.offset; }
            }

            internal int Size
            {
                get { return this.size; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\Test\xcachetest.cs ===
using System;
using ServerTestFramework;
using xonline.common.config;

[assembly: RootNode(typeof(XCacheTest.XCacheTest))]

namespace XCacheTest
{
    [Owner("CodyLuit"), TestFrequency("Regression"), TestCasePriority(3)]
    public class XCacheTest : TestNode
    {
        public override void PreRun()
        {
            System.Net.IPEndPoint endPoint = Global.XEnv.GetVirtualInterface("xcache");
            VirtualInterfaceInfo viInfo = (VirtualInterfaceInfo)Config.GetVirtualInterface("xcache");
            viInfo.IPAddress = endPoint.Address;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\QueryTool\main.cs ===
using System;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;


public class XCacheTestApp
{
    public static int GetMainMenuSelection()
    {
        Console.WriteLine("XCache Test Main Menu:");
        Console.WriteLine("");
        Console.WriteLine("\t 1 - Lookup User by UserID");
        Console.WriteLine("\t 2 - Lookup User by Gamertag");
        Console.WriteLine("\t 3 - Lookup User by PassportID");
        Console.WriteLine("");
        Console.WriteLine("\t 4 - Lookup Team by TeamID + TitleID");
        Console.WriteLine("\t 5 - Lookup Team by TeamName + TitleID");
        Console.WriteLine("");
        Console.WriteLine("\t 0 - Quit");
        Console.WriteLine("");
        Console.Write("> ");
        return Convert.ToInt32(Console.ReadLine());
    }

    public static void ShowUserInfo(XCacheUserResponseData data)
    {
        Console.WriteLine("UserID = 0x" + data.qwUserID.ToString("X"));
        Console.WriteLine("Gamertag = " + data.szGamertag);
        Console.WriteLine("PassportID = 0x" + data.qwPassportPUID.ToString("X"));
        Console.WriteLine("");
    }

    public static void ShowTeamInfo(uint dwTitleID, ulong qwTeamID, string teamName)
    {
        Console.WriteLine("TeamID = 0x" + qwTeamID.ToString("X"));
        Console.WriteLine("TitleID = 0x" + dwTitleID.ToString("X"));
        Console.WriteLine("TeamName = " + teamName);
        Console.WriteLine("");
    }

    public static void DoUserIDLookup()
    {
        Console.Write("Enter UserID (decimal): ");
        ulong qwUserID = Convert.ToUInt64(Console.ReadLine());
        XCacheUserResponseData resp = XCache.LookupUserByXUID(qwUserID);
        ShowUserInfo(resp);
    }
    
    public static void DoGamertagLookup()
    {
        Console.Write("Enter Gamertag: ");
        string gamertag = Console.ReadLine();
        XCacheUserResponseData resp = XCache.LookupUserByGamertag(gamertag);
        ShowUserInfo(resp);
    }

    public static void DoPassportLookup()
    {
        Console.Write("Enter PassportID (decimal): ");
        ulong qwPassportID = Convert.ToUInt64(Console.ReadLine());
        XCacheUserResponseData resp = XCache.LookupUserByPassport(qwPassportID);
        ShowUserInfo(resp);
    }
    
    public static void DoTeamIDLookup()
    {
        Console.Write("Enter TeamID (decimal): ");
        ulong qwTeamID = Convert.ToUInt64(Console.ReadLine());
        Console.Write("Enter TitleID (decimal): ");
        uint dwTitleID = Convert.ToUInt32(Console.ReadLine());
        string teamName = XCache.LookupTeamName(dwTitleID, qwTeamID);
        ShowTeamInfo(dwTitleID, qwTeamID, teamName);
    }
    
    public static void DoTeamNameLookup()
    {
        Console.Write("Enter TeamName: ");
        string teamName = Console.ReadLine();
        Console.Write("Enter TitleID (decimal): ");
        uint dwTitleID = Convert.ToUInt32(Console.ReadLine());
        ulong qwTeamID = XCache.LookupTeamPUID(dwTitleID, teamName);
        ShowTeamInfo(dwTitleID, qwTeamID, teamName);
    } 
    
    public static void Main()
    {
        while (true)
        {
            switch (GetMainMenuSelection())
            {
                case 0:
                    return;

                case 1:
                    DoUserIDLookup();
                    break;
                
                case 2:
                    DoGamertagLookup();
                    break;
                
                case 3:
                    DoPassportLookup();
                    break;
                
                case 4:
                    DoTeamIDLookup();
                    break;
                
                case 5:
                    DoTeamNameLookup();
                    break;
                
                default:
                    Console.WriteLine("Invalid selection.");
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\Test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\Test\XCacheStress.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Core.Utilities;
using xonline.common.service;
using xonline.common.protocol;

namespace XCacheTest
{
    public class XCacheStressHelpers
    {
        public static ulong m_qwValidUserIDBase = 0; // 0x000A000000000000;
        public static ulong m_qwValidPassportBase = 0; // 0x000C000000000000;
        public static string m_sValidGamertagPrefix = ""; // "XCTU";

        public static ulong m_qwInvalidUserIDBase = 0; // 0x000B000000000000;
        public static ulong m_qwInvalidPassportBase = 0; // 0x000D000000000000;
        public static string m_sInvalidGamertagPrefix = ""; // "INVL";

        public static int s_cTestUsers = 0; // 1000

        static XCacheStressHelpers()
        {
            XmlTextReader reader = new XmlTextReader("SuitesData\\XCache\\XCacheSettings.xml");
            reader.WhitespaceHandling = WhitespaceHandling.None;
            reader.MoveToContent();

            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(reader);

            try
            {
                string validUserIDBaseString = xmlDoc.GetElementsByTagName("ValidUserIDBase")[0].InnerText;
                m_qwValidUserIDBase = UInt64.Parse(validUserIDBaseString.Substring(2, validUserIDBaseString.Length - 3), System.Globalization.NumberStyles.HexNumber);

                string validPassportBaseString = xmlDoc.GetElementsByTagName("ValidPassportBase")[0].InnerText;
                m_qwValidPassportBase = UInt64.Parse(validPassportBaseString.Substring(2, validPassportBaseString.Length - 3), System.Globalization.NumberStyles.HexNumber);

                m_sValidGamertagPrefix = xmlDoc.GetElementsByTagName("ValidGamertagPrefix")[0].InnerText;

                string invalidUserIDBaseString = xmlDoc.GetElementsByTagName("InvalidUserIDBase")[0].InnerText;
                m_qwInvalidUserIDBase = UInt64.Parse(invalidUserIDBaseString.Substring(2, invalidUserIDBaseString.Length - 3), System.Globalization.NumberStyles.HexNumber);

                string invalidPassportBaseString = xmlDoc.GetElementsByTagName("InalidPassportBase")[0].InnerText;
                m_qwInvalidPassportBase = UInt64.Parse(invalidPassportBaseString.Substring(2, invalidPassportBaseString.Length - 3), System.Globalization.NumberStyles.HexNumber);

                m_sInvalidGamertagPrefix = xmlDoc.GetElementsByTagName("InvalidGamertagPrefix")[0].InnerText;

                s_cTestUsers = Convert.ToInt32(xmlDoc.GetElementsByTagName("NumTestUsers")[0].InnerText);
            }
            catch (Exception e)
            {
                Global.RO.Error("XML settings file reading failed:\r\n" + e.Message);
            }
        }

        public static uint GetRandomUserIndex()
        {
            return (uint)RandomEx.GlobalRandGen.Next(s_cTestUsers);
        }

        public static string GetRandomGamertag(bool fValid)
        {
            return (fValid ? m_sValidGamertagPrefix : m_sInvalidGamertagPrefix) + GetRandomUserIndex().ToString();
        }

        public static ulong GetRandomXuid(bool fValid)
        {
            return (fValid ? m_qwValidUserIDBase : m_qwInvalidUserIDBase) | GetRandomUserIndex();
        }

        public static ulong GetRandomPassport(bool fValid)
        {
            return (fValid ? m_qwValidPassportBase : m_qwInvalidPassportBase) | GetRandomUserIndex();
        }

        public static ulong[] GetRandomXuidArray(int cUsers, bool fValid)
        {
            ulong[] rgUsers = new ulong[cUsers];
            for (int iUser = 0; iUser < rgUsers.Length; iUser++)
            {
                rgUsers[iUser] = GetRandomXuid(fValid);
            }

            return rgUsers;
        }
    }

    [StressInstantiate]
    [StressTest(Priority = 10), EnvRequirement("Stress")]
    class CacheStressXUIDLookupMiss : TestBase
    {
        override protected void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;

            try
            {
                ulong puid = XCache.LookupPUID(XCacheStressHelpers.GetRandomGamertag(false));
                if (puid != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
            catch
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressInstantiate]
    [StressTest(Priority = 10), EnvRequirement("Stress")]
    class CacheStressXUIDLookupHit : TestBase
    {
        override protected void Execute()
        {
            ResultCode=TEST_RESULTS.PASSED;
            try
            {
                ulong puid = XCache.LookupPUID(XCacheStressHelpers.GetRandomGamertag(true));
                if (puid == 0) 
                { 
                    ResultCode=TEST_RESULTS.FAILED; 
                }
            }
            catch
            {
                ResultCode=TEST_RESULTS.FAILED;
            }
        }
    }

    [StressInstantiate]
    [StressTest(Priority = 10), EnvRequirement("Stress")]
    class CacheStressPassportLookupMiss : TestBase
    {
        override protected void Execute()
        {
            ResultCode=TEST_RESULTS.PASSED;
            try
            {
                ulong puid = XCache.LookupPUID(XCacheStressHelpers.GetRandomPassport(false));
                if (puid != 0) 
                { 
                    ResultCode=TEST_RESULTS.FAILED; 
                }
            }
            catch
            {
                ResultCode=TEST_RESULTS.FAILED;
            }
        }
    }

    [StressInstantiate]
    [StressTest(Priority = 10), EnvRequirement("Stress")]
    class CacheStressPassportLookupHit : TestBase
    {
        override protected void Execute()
        {
            ResultCode=TEST_RESULTS.PASSED;
            try
            {
                ulong puid = XCache.LookupPUID(XCacheStressHelpers.GetRandomPassport(true));
                if (puid == 0) 
                { 
                    ResultCode=TEST_RESULTS.FAILED; 
                }
            }
            catch
            {
                ResultCode=TEST_RESULTS.FAILED;
            }
        }
    }

    [StressInstantiate]
    [StressTest(Priority = 10), EnvRequirement("Stress")]
    class CacheStressGamerTagLookupMiss : TestBase
    {
        override protected void Execute()
        {
            ResultCode=TEST_RESULTS.PASSED;
            try
            {
                string gamertag = XCache.LookupGamerTag(XCacheStressHelpers.GetRandomXuid(false));
                if (gamertag != XCache.InvalidGamertag) 
                { 
                    ResultCode=TEST_RESULTS.FAILED; 
                }
            }
            catch
            {
                ResultCode=TEST_RESULTS.FAILED;
            }
        }
    }

    [StressInstantiate]
    [StressTest(Priority = 10), EnvRequirement("Stress")]
    class CacheStressGamerTagLookupHit : TestBase
    {
        override protected void Execute()
        {
            ResultCode=TEST_RESULTS.PASSED;
            try
            {
                string gamertag = XCache.LookupGamerTag(XCacheStressHelpers.GetRandomXuid(true));
                if (gamertag == XCache.InvalidGamertag) 
                { 
                    ResultCode=TEST_RESULTS.FAILED; 
                }
            }
            catch
            {
                ResultCode=TEST_RESULTS.FAILED;
            }
        }
    }

    [StressInstantiate]
    [StressTest(Priority = 10), EnvRequirement("Stress")]
    class CacheStressGamerTagLookupHitBatch : TestBase
    {
        override protected void Execute()
        {
            ResultCode=TEST_RESULTS.PASSED;
            try
            {
                string[] rgGamertags = XCache.LookupGamerTags(XCacheStressHelpers.GetRandomXuidArray(100, true));
                foreach (string gamertag in rgGamertags)
                {
                    if (gamertag == XCache.InvalidGamertag) 
                    { 
                        ResultCode=TEST_RESULTS.FAILED; 
                        break;
                    }
                }
            }
            catch
            {
                ResultCode=TEST_RESULTS.FAILED;
            }
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcache\Test\FuncLookup.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using xonline.common.service;
using xonline.common.protocol;


namespace XCacheTest
{
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
    public class FuncLookup : TestNode
    {
        public const ulong TestUserIDBase = 0x000A000000000000;
        public const ulong TestPassportBase = 0x000C000000000000;
        public const string TestGamertagPrefix = "XCTU";
        public static ulong RandomSeed = 0;

        private const uint MaxObjectsPerRequest = 1000;

        private static FriendsCommon fc = new FriendsCommon();

        // TODO: REAL USERS??????

        /*
         * public static string LookupGamerTag(ulong puid)
         */
        #region LookupGamertag by puid

        [TestCase, Description("Basic single gamertag lookup by Puid")]
        class P_LookupGamertagByPuid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string expectedGamertag = FuncLookup.TestGamertagPrefix + RandomSeed.ToString();

                if (!LookupGamertagAndVerify(FuncLookup.TestUserIDBase, expectedGamertag))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Basic single gamertag lookup by invalid Puid")]
        class P_LookupGamertagInvalidPuid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupGamertagAndVerify(0, XCache.InvalidGamertag))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        private static bool LookupGamertagAndVerify(ulong puid, string expectedGamertag)
        {
            string gamertag = null;

            try
            {
                gamertag = XCache.LookupGamerTag(puid);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupGamertag exception caught: " + e.Message);
                return false;
            }

            if (!gamertag.Equals(expectedGamertag))
            {
                Global.RO.Error("Returned gamertag: " + gamertag + " does not match the expected gamertag: " + expectedGamertag);
                return false;
            }

            return true;
        }

        #endregion

        /*
         * public static string[] LookupGamerTags(ulong[] puids)
         */
        #region LookupGamertags by puid

        [TestCase, Description("Basic batch gamertag lookup of 25")]
        class P_LookupGamertagsByPuid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong[] puids = new ulong[25];
                string[] expectedGamertags = new string[25];

                for (int i = 0; i < puids.Length; ++i)
                {
                    puids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    expectedGamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                }

                if (!LookupGamertagsAndVerify(puids, expectedGamertags))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Max batch gamertag lookup of 1000")]
        class P_LookupGamertagsByPuidMaxBatchSize : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong[] puids = new ulong[MaxObjectsPerRequest];
                string[] expectedGamertags = new string[MaxObjectsPerRequest];

                for (int i = 0; i < puids.Length; ++i)
                {
                    puids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    expectedGamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                }

                if (!LookupGamertagsAndVerify(puids, expectedGamertags))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Basic batch gamertag lookup of 25, half of the puids are invalid")]
        class P_LookupGamertagsPartialInvalidPuids : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong[] puids = new ulong[25];
                string[] expectedGamertags = new string[25];

                for (int i = 0; i < puids.Length; ++i)
                {
                    if (i % 2 == 0) // Valid
                    {
                        puids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                        expectedGamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    }
                    else // Invalid
                    {
                        puids[i] = (ulong)i;
                        expectedGamertags[i] = XCache.InvalidGamertag;
                    }
                }

                if (!LookupGamertagsAndVerify(puids, expectedGamertags))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Batch gamertag lookup of 1001")]
        class N_LookupGamertagsByPuidOverMaxBatchSize : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                ulong[] puids = new ulong[MaxObjectsPerRequest + 1];

                for (int i = 0; i < puids.Length; ++i)
                {
                    puids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                }

                try
                {
                    XCache.LookupGamerTags(puids);
                }
                catch (System.ArgumentException e)
                {
                    if (e.Message.Contains("Number of input parameters " + (MaxObjectsPerRequest + 1) + " exceeds maximum allowed (" + MaxObjectsPerRequest + ")"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Empty puid list")]
        class N_LookupGamertagsEmptyPuidList : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    XCache.LookupGamerTags(new ulong[] { });
                }
                catch (System.ArgumentException e)
                {
                    if (e.Message.Contains("puids == null or puids.Length == 0"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Null puid list")]
        class N_LookupGamertagNullPuidList : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    XCache.LookupGamerTags(null);
                }
                catch (System.ArgumentException e)
                {
                    if (e.Message.Contains("puids == null or puids.Length == 0"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        private static bool LookupGamertagsAndVerify(ulong[] puids, string[] expectedGamertags)
        {
            string[] gamertags = null;

            try
            {
                gamertags = XCache.LookupGamerTags(puids);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupGamertags exception caught: " + e.Message);
                return false;
            }

            for (int i = 0; i < expectedGamertags.Length; ++i)
            {
                if (!gamertags[i].Equals(expectedGamertags[i]))
                {
                    Global.RO.Error("Returned gamertag: " + gamertags[i] + " does not match the expected gamertag: " + expectedGamertags[i]);
                    return false;
                }
            }

            return true;
        }

        #endregion

        /*
         * public static ulong LookupPUID(string gamerTag)
         */
        #region LookupPUID by gamertag

        [TestCase, Description("Basic single puid lookup by gamertag")]
        class P_LookupPuidByGamertag : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string gamertag = FuncLookup.TestGamertagPrefix + RandomSeed.ToString();

                if (!LookupPuidAndVerify(gamertag, FuncLookup.TestUserIDBase))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Basic single puid lookup by invalid gamertag")]
        class P_LookupPuidInvalidGamertag : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupPuidAndVerify(XCache.InvalidGamertag, 0))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup puid for empty string")]
        class P_LookupPuidGamertagEmptyString : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupPuidAndVerify("", 0))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Bug#18265: Look up by gamertag which is too long.")]
        class N_LookupPuidGamertagTooLong : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                string gamertag = "1234567890123456";

                try
                {
                    ulong userPuid = XCache.LookupPUID(gamertag);
                }
                catch (System.ArgumentException exp)
                {
                    if (exp.Message.Contains("GamerTag passed 1234567890123456 ( index = 0) is too long"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        private static bool LookupPuidAndVerify(string gamertag, ulong expectedPuid)
        {
            ulong puid = 0;

            try
            {
                puid = XCache.LookupPUID(gamertag);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupPUID exception caught: " + e.Message);
                return false;
            }

            if (puid != expectedPuid)
            {
                Global.RO.Error("Returned puid: " + puid + " does not match the expected puid: " + expectedPuid);
                return false;
            }

            return true;
        }

        #endregion

        /*
         * public static ulong[] LookupPUIDs(string[] gamerTags)
         */
        #region LookupPUIDs by gamertag

        [TestCase, Description("Basic batch puid lookup of 25 gamertags")]
        class P_LookupPuidsByGamertag : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[25];
                ulong[] expectedPuids = new ulong[25];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    expectedPuids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                }

                if (!LookupPuidsAndVerify(gamertags, expectedPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Max batch puid lookup of 1000 gamertags")]
        class P_LookupPuidsByGamertagMaxBatchSize : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[MaxObjectsPerRequest];
                ulong[] expectedPuids = new ulong[MaxObjectsPerRequest];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    expectedPuids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                }

                if (!LookupPuidsAndVerify(gamertags, expectedPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Basic batch puid lookup of 25, half of the gamertags are invalid")]
        class P_LookupPuidsPartialInvalidGamertags : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[25];
                ulong[] expectedPuids = new ulong[25];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    if (i % 2 == 0) // Valid
                    {
                        gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                        expectedPuids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    }
                    else // Invalid
                    {
                        gamertags[i] = XCache.InvalidGamertag;
                        expectedPuids[i] = 0;
                    }
                }

                if (!LookupPuidsAndVerify(gamertags, expectedPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Batch Puid lookup of 1001 using gamertags")]
        class N_LookupPuidsByGamertagOverMaxBatchSize : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                string[] gamertags = new string[MaxObjectsPerRequest + 1];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                }

                try
                {
                    XCache.LookupPUIDs(gamertags);
                }
                catch (System.ArgumentException e)
                {
                    if (e.Message.Contains("Number of input parameters " + (MaxObjectsPerRequest + 1) + " exceeds maximum allowed (" + MaxObjectsPerRequest + ")"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Empty gamertag list")]
        class N_LookupPuidsEmptyGamertagList : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    XCache.LookupPUIDs(new string[] { });
                }
                catch (System.ArgumentException e)
                {
                    if (e.Message.Contains("gamerTags == null or gamerTags.Length == 0"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Lookup batch of users where 1 gamertag is too long")]
        class N_LookupPuidsGamertagTooLong : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                string gamertag = "1234567890123456";

                try
                {
                    ulong[] userPuids = XCache.LookupPUIDs(new string[] { FuncLookup.TestGamertagPrefix + RandomSeed.ToString(), gamertag});
                }
                catch (System.ArgumentException exp)
                {
                    if (exp.Message.Contains("GamerTag passed 1234567890123456 ( index = 1) is too long"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        private static bool LookupPuidsAndVerify(string[] gamertags, ulong[] expectedPuids)
        {
            ulong[] puids = null;

            try
            {
                puids = XCache.LookupPUIDs(gamertags);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupPUIDs exception caught: " + e.Message);
                return false;
            }

            for (int i = 0; i < expectedPuids.Length; ++i)
            {
                if (puids[i] != expectedPuids[i])
                {
                    Global.RO.Error("Returned puid: " + puids[i] + " does not match the expected puid: " + expectedPuids[i]);
                    return false;
                }
            }

            return true;
        }

        #endregion

        /*
         * public static ulong LookupPUID(ulong passportPuid)
         */
        #region LookupPUID by passport puid

        [TestCase, Description("Basic single puid lookup by passport puid")]
        class P_LookupPuidByPassportPuid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupPuidAndVerify(FuncLookup.TestPassportBase, FuncLookup.TestUserIDBase))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Basic single puid lookup by invalid passport puid")]
        class P_LookupPuidInvalidPassportPuid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupPuidAndVerify(0, 0))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        private static bool LookupPuidAndVerify(ulong passportPuid, ulong expectedPuid)
        {
            ulong puid = 0;

            try
            {
                puid = XCache.LookupPUID(passportPuid);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupPUID exception caught: " + e.Message);
                return false;
            }

            if (puid != expectedPuid)
            {
                Global.RO.Error("Returned puid: " + puid + " does not match the expected puid: " + expectedPuid);
                return false;
            }

            return true;
        }

        #endregion

        /*
         * public static ulong[] LookupPUIDs(ulong[] passportPuids)
         */
        #region LookupPUIDs by passport puid

        [TestCase, Description("Basic batch puid lookup of 25 passport puids")]
        class P_LookupPuidsByPassportPuid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong[] passportPuids = new ulong[25];
                ulong[] expectedPuids = new ulong[25];

                for (int i = 0; i < passportPuids.Length; ++i)
                {
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                    expectedPuids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                }

                if (!LookupPuidsAndVerify(passportPuids, expectedPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Max batch puid lookup of 1000 passport puids")]
        class P_LookupPuidsByPassportPuidMaxBatchSize : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong[] passportPuids = new ulong[MaxObjectsPerRequest];
                ulong[] expectedPuids = new ulong[MaxObjectsPerRequest];

                for (int i = 0; i < passportPuids.Length; ++i)
                {
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                    expectedPuids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                }

                if (!LookupPuidsAndVerify(passportPuids, expectedPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Basic batch puid lookup of 25, half of the passport puids are invalid")]
        class P_LookupPuidsPartialInvalidPassportPuids : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong[] passportPuids = new ulong[25];
                ulong[] expectedPuids = new ulong[25];

                for (int i = 0; i < passportPuids.Length; ++i)
                {
                    if (i % 2 == 0) // Valid
                    {
                        passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                        expectedPuids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    }
                    else // Invalid
                    {
                        passportPuids[i] = 0;
                        expectedPuids[i] = 0;
                    }
                }

                if (!LookupPuidsAndVerify(passportPuids, expectedPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Batch Puid lookup of 1001 using passport puids")]
        class N_LookupPuidsByPassportOverMaxBatchSize : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                ulong[] passportPuids = new ulong[MaxObjectsPerRequest + 1];

                for (int i = 0; i < passportPuids.Length; ++i)
                {
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                }

                try
                {
                    XCache.LookupPUIDs(passportPuids);
                }
                catch (System.ArgumentException e)
                {
                    if (e.Message.Contains("Number of input parameters " + (MaxObjectsPerRequest + 1) + " exceeds maximum allowed (" + MaxObjectsPerRequest + ")"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Empty passport puid list")]
        class N_LookupPuidEmptyPassportList : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    XCache.LookupPUIDs(new ulong[] { });
                }
                catch (System.ArgumentException e)
                {
                    if (e.Message.Contains("passportPuids == null or passportPuids.Length == 0"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        private static bool LookupPuidsAndVerify(ulong[] passportPuids, ulong[] expectedPuids)
        {
            ulong[] puids = null;

            try
            {
                puids = XCache.LookupPUIDs(passportPuids);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupPUIDs exception caught: " + e.Message);
                return false;
            }

            for (int i = 0; i < expectedPuids.Length; ++i)
            {
                if (puids[i] != expectedPuids[i])
                {
                    Global.RO.Error("Returned puid: " + puids[i] + " does not match the expected puid: " + expectedPuids[i]);
                    return false;
                }
            }

            return true;
        }

        #endregion

        /*
         * public static XCacheUserResponseData LookupUserByGamertag(string gamertag)
         */
        #region LookupUserByGamertag

        [TestCase, Description("Lookup single user by gamertag")]
        class P_LookupUserByGamertagBasic : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string expectedGamertag = FuncLookup.TestGamertagPrefix + RandomSeed.ToString();

                if (!LookupUserByGamertagAndVerify(expectedGamertag, FuncLookup.TestUserIDBase, FuncLookup.TestPassportBase))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup invalid gamertag")]
        class P_LookupUserByGamertagInvalidGamertag : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupUserByGamertagAndVerify(XCache.InvalidGamertag, 0, 0))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup user who has a gamertag that is too long")]
        class N_LookupUserByGamertagTooLong : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                string gamertag = "1234567890123456";

                try
                {
                    XCacheUserResponseData responseData = XCache.LookupUserByGamertag(gamertag);
                }
                catch (System.ArgumentException exp)
                {
                    if (exp.Message.Contains("GamerTag passed 1234567890123456 ( index = 0) is too long"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Lookup invalid gamertag")]
        class N_LookupUserByGamertagNull : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    XCacheUserResponseData responseData = XCache.LookupUserByGamertag(null);
                }
                catch (Exception e)
                {
                    // LookupUsersByGamertag inside XCacheProxy.cs will throw while trying to take the Length of the gamertag.
                    Global.RO.Info("N_LookupUserByGamertagNull exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        private static bool LookupUserByGamertagAndVerify(string gamertag, ulong userId, ulong passportPuid)
        {
            XCacheUserResponseData responseData = null;

            try
            {
                responseData = XCache.LookupUserByGamertag(gamertag);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupUserByGamertagAndVerify exception caught: " + e.Message);
                return false;
            }

            return VerifyUserResponseData(responseData, gamertag, userId, passportPuid);
        }

        private static bool VerifyUserResponseData(XCacheUserResponseData responseData, string gamertag, ulong userId, ulong passportPuid)
        {
            bool success = true;
            if (!gamertag.Equals(responseData.szGamertag))
            {
                Global.RO.Error("Returned gamertag: " + responseData.szGamertag + " does not match the expected gamertag: " + gamertag);
                success = false;
            }
            if (userId != responseData.qwUserID)
            {
                Global.RO.Error("Returned userId: " + responseData.qwUserID + " does not match the expected userId: " + userId);
                success = false;
            }
            if (passportPuid != responseData.qwPassportPUID)
            {
                Global.RO.Error("Returned passport puid: " + responseData.qwPassportPUID + " does not match the expected passport puid: " + passportPuid);
                success = false;
            }

            return success;
        }

        #endregion

        /*
         * public static XCacheUserResponseData[] LookupUsersByGamertag(string[] gamertags)
         */
        #region LookupUsersByGamertag

        [TestCase, Description("Lookup batch of 25 users by gamertag")]
        class P_LookupUsersByGamertagBatch : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[25];
                ulong[] userIds = new ulong[25];
                ulong[] passportPuids = new ulong[25];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                }

                if (!LookupUsersByGamertagAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of max users (1000) by gamertag")]
        class P_LookupUsersByGamertagBatchMax : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[MaxObjectsPerRequest];
                ulong[] userIds = new ulong[MaxObjectsPerRequest];
                ulong[] passportPuids = new ulong[MaxObjectsPerRequest];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                }

                if (!LookupUsersByGamertagAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of users that are half valid and half invalid gamertags")]
        class P_LookupUsersByGamertagPartialInvalid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[25];
                ulong[] userIds = new ulong[25];
                ulong[] passportPuids = new ulong[25];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    if (i % 2 == 0) // Valid
                    {
                        gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                        userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                        passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                    }
                    else // Invalid
                    {
                        gamertags[i] = XCache.InvalidGamertag;
                        userIds[i] = 0;
                        passportPuids[i] = 0;
                    }
                }

                if (!LookupUsersByGamertagAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of users that is 1 more than max allowed per request")]
        class N_LookupUsersByGamertagBatchOverMax : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[MaxObjectsPerRequest + 1];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                }

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByGamertag(gamertags);

                    for (int i = 0; i < gamertags.Length; ++i)
                    {
                        if (i != gamertags.Length - 1) // first 1000
                        {
                            if (gamertags[i] != responseData[i].szGamertag)
                                ResultCode = TEST_RESULTS.FAILED;
                        }
                        else // last 1
                        {
                            if (responseData[i].szGamertag != XCache.InvalidGamertag ||
                                responseData[i].qwPassportPUID != 0 ||
                                responseData[i].qwUserID != 0)
                                ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_LookupUsersByGamertagBatchOverMax threw an unexpected exception!");
                    Global.RO.Error(e.Message);
                    Global.RO.Error(e.StackTrace);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Lookup batch of users with an empty gamertag list")]
        class N_LookupUsersByGamertagEmptyList : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByGamertag(new string[] { });

                    if (responseData == null || responseData.Length != 0)
                        ResultCode = TEST_RESULTS.FAILED;
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_LookupUsersByGamertagEmptyList exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Lookup batch of users with a null list of gamertags")]
        class N_LookupUsersByGamertagNullList : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByGamertag(null);
                }
                catch (Exception e)
                {
                    // LookupUsersByGamertag inside XCacheProxy.cs will throw while trying to take the Length of the gamertag.
                    Global.RO.Info("N_LookupUsersByGamertagNullList exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Lookup batch of users with one who has a gamertag that is too long")]
        class N_LookupUsersByGamertagTooLong : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                string gamertag = "1234567890123456";

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByGamertag(new string[] { FuncLookup.TestGamertagPrefix + (RandomSeed).ToString(), gamertag });
                }
                catch (System.ArgumentException exp)
                {
                    if (exp.Message.Contains("GamerTag passed 1234567890123456 ( index = 1) is too long"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        private static bool LookupUsersByGamertagAndVerify(string[] gamertags, ulong[] userIds, ulong[] passportPuids)
        {
            XCacheUserResponseData[] responseData = null;

            try
            {
                responseData = XCache.LookupUsersByGamertag(gamertags);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupUserByGamertagAndVerify exception caught: " + e.Message);
                return false;
            }

            return VerifyUserResponseDataArray(responseData, gamertags, userIds, passportPuids);
        }

        private static bool VerifyUserResponseDataArray(XCacheUserResponseData[] responseData, string[] gamertags, ulong[] userIds, ulong[] passportPuids)
        {
            if (responseData == null)
            {
                Global.RO.Error("XCacheUserResponseData was null.");
                return false;
            }

            if (responseData.Length != gamertags.Length || responseData.Length != userIds.Length || responseData.Length != passportPuids.Length)
            {
                Global.RO.Error("Array lengths do not match. ResponseData:" + responseData.Length + " gamertags:" + gamertags.Length + " userIds:" + userIds.Length + " passportPuids:" + passportPuids.Length);
                return false;
            }

            bool success = true;
            for (int i = 0; i < responseData.Length; ++i)
            {
                if (!gamertags[i].Equals(responseData[i].szGamertag))
                {
                    Global.RO.Error("Returned gamertag: " + responseData[i].szGamertag + " does not match the expected gamertag: " + gamertags[i]);
                    success = false;
                }
                if (userIds[i] != responseData[i].qwUserID)
                {
                    Global.RO.Error("Returned userId: " + responseData[i].qwUserID + " does not match the expected userId: " + userIds[i]);
                    success = false;
                }
                if (passportPuids[i] != responseData[i].qwPassportPUID)
                {
                    Global.RO.Error("Returned passport puid: " + responseData[i].qwPassportPUID + " does not match the expected passport puid: " + passportPuids[i]);
                    success = false;
                }
            }
            return success;
        }

        #endregion

        /*
         * public static XCacheUserResponseData LookupUserByXUID(ulong xuid)
         */
        #region LookupUserByXuid

        [TestCase, Description("Lookup single user by xuid")]
        class P_LookupUserByXuidBasic : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupUserByXuidAndVerify(FuncLookup.TestGamertagPrefix + RandomSeed.ToString(), FuncLookup.TestUserIDBase, FuncLookup.TestPassportBase))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup invalid xuid")]
        class P_LookupUserByXuidInvalidXuid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupUserByXuidAndVerify(XCache.InvalidGamertag, 0, 0))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        private static bool LookupUserByXuidAndVerify(string gamertag, ulong userId, ulong passportPuid)
        {
            XCacheUserResponseData responseData = null;

            try
            {
                responseData = XCache.LookupUserByXUID(userId);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupUserByGamertagAndVerify exception caught: " + e.Message);
                return false;
            }

            return VerifyUserResponseData(responseData, gamertag, userId, passportPuid);
        }

        #endregion

        /*
         * public static XCacheUserResponseData[] LookupUsersByXUID(ulong[] xuids)
         */
        #region LookupUsersByGamertag

        [TestCase, Description("Lookup batch of 25 users by xuid")]
        class P_LookupUsersByXuidBatch : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[25];
                ulong[] userIds = new ulong[25];
                ulong[] passportPuids = new ulong[25];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                }

                if (!LookupUsersByXuidAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of max users (1000) by xuid")]
        class P_LookupUsersByXuidBatchMax : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[MaxObjectsPerRequest];
                ulong[] userIds = new ulong[MaxObjectsPerRequest];
                ulong[] passportPuids = new ulong[MaxObjectsPerRequest];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                }

                if (!LookupUsersByXuidAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of users that are half valid and half invalid xuids")]
        class P_LookupUsersByXuidPartialInvalid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[25];
                ulong[] userIds = new ulong[25];
                ulong[] passportPuids = new ulong[25];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    if (i % 2 == 0) // Valid
                    {
                        gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                        userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                        passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                    }
                    else // Invalid
                    {
                        gamertags[i] = XCache.InvalidGamertag;
                        userIds[i] = 0;
                        passportPuids[i] = 0;
                    }
                }

                if (!LookupUsersByXuidAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of users that is 1 more than max allowed per request")]
        class N_LookupUsersByXuidBatchOverMax : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong[] xuids = new ulong[MaxObjectsPerRequest + 1];

                for (int i = 0; i < xuids.Length; ++i)
                {
                    xuids[i] = FuncLookup.TestUserIDBase + (ulong)i;
                }

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByXUID(xuids);

                    for (int i = 0; i < xuids.Length; ++i)
                    {
                        if (i != xuids.Length - 1) // first 1000
                        {
                            if (xuids[i] != responseData[i].qwUserID)
                                ResultCode = TEST_RESULTS.FAILED;
                        }
                        else // last 1
                        {
                            if (responseData[i].szGamertag != XCache.InvalidGamertag ||
                                responseData[i].qwPassportPUID != 0 ||
                                responseData[i].qwUserID != 0)
                                ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_LookupUsersByXuidBatchOverMax threw an unexpected exception!");
                    Global.RO.Error(e.Message);
                    Global.RO.Error(e.StackTrace);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Lookup batch of users with an empty xuid list")]
        class N_LookupUsersByXuidEmptyList : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByXUID(new ulong[] { });

                    if (responseData == null || responseData.Length != 0)
                        ResultCode = TEST_RESULTS.FAILED;
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_LookupUsersByXuidEmptyList exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Lookup batch of users with a null list of xuids")]
        class N_LookupUsersByXuidNullList : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByXUID(null);

                    if (responseData == null || responseData.Length != 0)
                        ResultCode = TEST_RESULTS.FAILED;
                }
                catch (System.ArgumentException e)
                {
                    Global.RO.Error("N_LookupUsersByXuidNullList exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        private static bool LookupUsersByXuidAndVerify(string[] gamertags, ulong[] userIds, ulong[] passportPuids)
        {
            XCacheUserResponseData[] responseData = null;

            try
            {
                responseData = XCache.LookupUsersByXUID(userIds);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupUsersByXuidAndVerify exception caught: " + e.Message);
                return false;
            }

            return VerifyUserResponseDataArray(responseData, gamertags, userIds, passportPuids);
        }

        #endregion

        /*
         * public static XCacheUserResponseData LookupUserByLookupUserByPassportAndVerify(ulong passport)
         */
        #region LookupUserByPassport

        [TestCase, Description("Lookup single user by passport")]
        class P_LookupUserByPassportBasic : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupUserByPassportAndVerify(FuncLookup.TestGamertagPrefix + RandomSeed.ToString(), FuncLookup.TestUserIDBase, FuncLookup.TestPassportBase))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup invalid passport")]
        class P_LookupUserByPassportInvalidPassport : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                if (!LookupUserByPassportAndVerify(XCache.InvalidGamertag, 0, 0))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        private static bool LookupUserByPassportAndVerify(string gamertag, ulong userId, ulong passportPuid)
        {
            XCacheUserResponseData responseData = null;

            try
            {
                responseData = XCache.LookupUserByPassport(passportPuid);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupUserByPassportAndVerify exception caught: " + e.Message);
                return false;
            }

            return VerifyUserResponseData(responseData, gamertag, userId, passportPuid);
        }

        #endregion

        /*
         * public static XCacheUserResponseData[] LookupUsersByLookupUserByPassportAndVerify(ulong[] passports)
         */
        #region LookupUsersByPassport

        [TestCase, Description("Lookup batch of 25 users by passport")]
        class P_LookupUsersByPassportBatch : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[25];
                ulong[] userIds = new ulong[25];
                ulong[] passportPuids = new ulong[25];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                }

                if (!LookupUsersByPassportAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of max users (1000) by passport")]
        class P_LookupUsersByPassportBatchMax : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[MaxObjectsPerRequest];
                ulong[] userIds = new ulong[MaxObjectsPerRequest];
                ulong[] passportPuids = new ulong[MaxObjectsPerRequest];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                    userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                    passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                }

                if (!LookupUsersByPassportAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of users that are half valid and half invalid passports")]
        class P_LookupUsersByPassportPartialInvalid : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                string[] gamertags = new string[25];
                ulong[] userIds = new ulong[25];
                ulong[] passportPuids = new ulong[25];

                for (int i = 0; i < gamertags.Length; ++i)
                {
                    if (i % 2 == 0) // Valid
                    {
                        gamertags[i] = FuncLookup.TestGamertagPrefix + (RandomSeed + (ulong)i).ToString();
                        userIds[i] = FuncLookup.TestUserIDBase + (ulong)i;
                        passportPuids[i] = FuncLookup.TestPassportBase + (ulong)i;
                    }
                    else // Invalid
                    {
                        gamertags[i] = XCache.InvalidGamertag;
                        userIds[i] = 0;
                        passportPuids[i] = 0;
                    }
                }

                if (!LookupUsersByPassportAndVerify(gamertags, userIds, passportPuids))
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("Lookup batch of users that is 1 more than max allowed per request")]
        class N_LookupUsersByPassportBatchOverMax : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                ulong[] passports = new ulong[MaxObjectsPerRequest + 1];

                for (int i = 0; i < passports.Length; ++i)
                {
                    passports[i] = FuncLookup.TestPassportBase + (ulong)i;
                }

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByPassport(passports);

                    for (int i = 0; i < passports.Length; ++i)
                    {
                        if (i != passports.Length - 1) // first 1000
                        {
                            if (passports[i] != responseData[i].qwPassportPUID)
                                ResultCode = TEST_RESULTS.FAILED;
                        }
                        else // last 1
                        {
                            if (responseData[i].szGamertag != XCache.InvalidGamertag ||
                                responseData[i].qwPassportPUID != 0 ||
                                responseData[i].qwUserID != 0)
                                ResultCode = TEST_RESULTS.FAILED;
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_LookupUsersByPassportBatchOverMax threw an unexpected exception!");
                    Global.RO.Error(e.Message);
                    Global.RO.Error(e.StackTrace);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Lookup batch of users with an empty passport list")]
        class N_LookupUsersByPassportEmptyList : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByPassport(new ulong[] { });

                    if (responseData == null || responseData.Length != 0)
                        ResultCode = TEST_RESULTS.FAILED;
                }
                catch (Exception e)
                {
                    Global.RO.Error("N_LookupUsersByPassportEmptyList exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Lookup batch of users with a null list of passports")]
        class N_LookupUsersByPassportNullList : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                try
                {
                    XCacheUserResponseData[] responseData = XCache.LookupUsersByPassport(null);

                    if (responseData == null || responseData.Length != 0)
                        ResultCode = TEST_RESULTS.FAILED;
                }
                catch (System.ArgumentException e)
                {
                    Global.RO.Error("N_LookupUsersByPassportNullList exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        private static bool LookupUsersByPassportAndVerify(string[] gamertags, ulong[] userIds, ulong[] passportPuids)
        {
            XCacheUserResponseData[] responseData = null;

            try
            {
                responseData = XCache.LookupUsersByPassport(passportPuids);
            }
            catch (Exception e)
            {
                Global.RO.Error("LookupUsersByPassportAndVerify exception caught: " + e.Message);
                return false;
            }

            return VerifyUserResponseDataArray(responseData, gamertags, userIds, passportPuids);
        }

        #endregion

        /*
         * public static PUIDAndOwner[] LookupWebID(byte[] webID, uint credType, out uint[] rgdwUserFlags)
         * public static PUIDAndOwner[] LookupWebID(byte[] webID, uint credType)
         * public static PUIDAndOwner LookupWebID(byte[] webID, string GamerTag, uint credType)
         */
        #region LookupByWebID

        [TestCase, Description("")]
        class P_LookupWebIdBasic : TestBase
        {
            PuidName puidName = null;

            public override void PreRun(RUN_TYPE runType)
            {
                UacsCommon uc = new UacsCommon();

                XeUser user = new XeUser(true);
                if (user.Create() == 0)
                    Global.RO.Error("User creation failed!");

                Global.RO.Info("Sleeping 5 seconds for XCache to load user.");
                System.Threading.Thread.Sleep(5000);

                puidName = new PuidName(user.UserPuid, user.Gamertag, uc.GenerateWebId(user.PassportOwnerPuid));

                
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PUIDAndOwner[] pao = XCache.LookupWebID(puidName.WebId, XCache._credentialTypePassport);

                if (pao != null && pao.Length != 0)
                {
                    if (pao[0].PUID != puidName.Puid || pao[0].Owner != true) // Owner is set to true in LookupWebID right now
                        ResultCode = TEST_RESULTS.FAILED;
                }
                else
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("")]
        class P_LookupWebIdInvalidWedId : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                byte[] webId = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 };

                PUIDAndOwner[] pao = XCache.LookupWebID(webId, XCache._credentialTypePassport);

                // Expect nothing
                if (pao != null && pao.Length != 0)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("")]
        class P_LookupWebIdInvalidWedIdAndGamertag : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                byte[] webId = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 };

                PUIDAndOwner pao = XCache.LookupWebID(webId, XCache.InvalidGamertag, XCache._credentialTypePassport);

                // Expect nothing
                if (pao.PUID != 0)
                    ResultCode = TEST_RESULTS.FAILED;

            }
        }

        [TestCase, Description("")]
        class P_LookupWebIdNull : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    PUIDAndOwner pao = XCache.LookupWebID(null, XCache.InvalidGamertag, XCache._credentialTypePassport);
                }
                catch (Exception e)
                {
                    // ConvertWebIDToPassportPUID inside XCacheProxy.cs will throw while trying to access bytes in the webId that don't exist.
                    Global.RO.Info("P_LookupWebIdNull exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("")]
        class P_LookupWebIdInvalidGamertag : TestBase
        {
            PuidName puidName = null;

            public override void PreRun(RUN_TYPE runType)
            {
                UacsCommon uc = new UacsCommon();

                XeUser user = new XeUser(true);
                if (user.Create() == 0)
                    Global.RO.Error("User creation failed!");

                Global.RO.Info("Sleeping 5 seconds for XCache to load user.");
                System.Threading.Thread.Sleep(5000);

                puidName = new PuidName(user.UserPuid, user.Gamertag, uc.GenerateWebId(user.PassportOwnerPuid));
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PUIDAndOwner pao = XCache.LookupWebID(puidName.WebId, XCache.InvalidGamertag, XCache._credentialTypePassport);

                if (pao.PUID != 0)
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("")]
        class N_LookupWebIdTooShort : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                byte[] webId = new byte[] { 0, 0, 0, 0 };

                try
                {
                    PUIDAndOwner pao = XCache.LookupWebID(webId, XCache.InvalidGamertag, XCache._credentialTypePassport);
                }
                catch (Exception e)
                {
                    // ConvertWebIDToPassportPUID inside XCacheProxy.cs will throw while trying to access bytes in the webId that don't exist.
                    Global.RO.Info("N_LookupWebIdTooShort exception caught: " + e.Message);
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        // Should fail???
        [TestCase, Description("")]
        class N_LookupWebIdTooLong : TestBase
        {
            PuidName puidName = null;

            public override void PreRun(RUN_TYPE runType)
            {
                UacsCommon uc = new UacsCommon();

                XeUser user = new XeUser(true);
                if (user.Create() == 0)
                    Global.RO.Error("User creation failed!");

                Global.RO.Info("Sleeping 5 seconds for XCache to load user.");
                System.Threading.Thread.Sleep(5000);
                
                puidName = new PuidName(user.UserPuid, user.Gamertag, uc.GenerateWebId(user.PassportOwnerPuid));
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                byte[] webId = new byte[] { puidName.WebId[0],
                                            puidName.WebId[1],
                                            puidName.WebId[2],
                                            puidName.WebId[3],
                                            puidName.WebId[4],
                                            puidName.WebId[5],
                                            puidName.WebId[6],
                                            puidName.WebId[7],
                                            0, 0, 0, 0 };

                PUIDAndOwner pao = XCache.LookupWebID(webId, puidName.GamerTag, XCache._credentialTypePassport);

                if (pao.PUID != puidName.Puid || pao.Owner != true) // Owner is set to true in LookupWebID right now
                    ResultCode = TEST_RESULTS.FAILED;
            }
        }

        [TestCase, Description("")]
        class N_LookupWebIdGamertagTooLong : TestBase
        {
            PuidName puidName = null;

            public override void PreRun(RUN_TYPE runType)
            {
                UacsCommon uc = new UacsCommon();

                XeUser user = new XeUser(true);
                if (user.Create() == 0)
                    Global.RO.Error("User creation failed!");

                Global.RO.Info("Sleeping 5 seconds for XCache to load user.");
                System.Threading.Thread.Sleep(5000);

                puidName = new PuidName(user.UserPuid, user.Gamertag, uc.GenerateWebId(user.PassportOwnerPuid));
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    PUIDAndOwner pao = XCache.LookupWebID(puidName.WebId, "1234567890123456", XCache._credentialTypePassport);
                }
                catch (System.ArgumentException e)
                {
                    if (e.Message.Contains("GamerTag passed 1234567890123456 is too long"))
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("")]
        class N_LookupWebIdInvalidCredentialType : TestBase
        {
            PuidName puidName = null;

            public override void PreRun(RUN_TYPE runType)
            {
                UacsCommon uc = new UacsCommon();

                XeUser user = new XeUser(true);
                if (user.Create() == 0)
                    Global.RO.Error("User creation failed!");

                Global.RO.Info("Sleeping 5 seconds for XCache to load user.");
                System.Threading.Thread.Sleep(5000);

                puidName = new PuidName(user.UserPuid, user.Gamertag, uc.GenerateWebId(user.PassportOwnerPuid));
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                PUIDAndOwner pao = XCache.LookupWebID(puidName.WebId, puidName.GamerTag, 0);

                // Currently credential type isn't used so this should just pass
                if (pao.PUID == puidName.Puid && pao.Owner == true)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\NYCLock.cs ===
using System;
using System.Threading;

namespace xonline.server.XConnSrv
{
    // It's the spinny that never sleeps!
    public class NYCLock
    {
        protected int m_iThreadID;
        protected int m_cLockDepth;

        protected const int SPIN_COUNT = 0x1000;

        public NYCLock()
        {
        }

        public void Lock()
        {
            int iThreadID = Thread.CurrentThread.ManagedThreadId;
            if (iThreadID == m_iThreadID)
            {
                // already locked by us.
                m_cLockDepth++;
            }
            else
            {
                // spin
                while (Interlocked.CompareExchange(ref m_iThreadID, iThreadID, 0) != 0)
                {
                    for (int iSpin = 0; iSpin < SPIN_COUNT; iSpin++)
                    {
                        if (m_iThreadID == 0)
                        {
                            break;
                        }
                    }
                }

                // now we have the lock.
                m_cLockDepth = 1;
            }
        }

        public void Unlock()
        {
            // reduce lock depth.
            m_cLockDepth--;
            if (m_cLockDepth == 0)
            {
                // all locks released.  yield the lock.
                m_iThreadID = 0;
            }
        }

        public void WriteLock()
        {
            Lock();
        }

        public void ReadLock()
        {
            Lock();
        }

        public void WriteUnlock()
        {
            Unlock();
        }

        public void ReadUnlock()
        {
            Unlock();
        }
    }

    // regular c#, lock{} style.
    public class MonitorLock
    {
        public MonitorLock()
        {
        }

        public void Lock()
        {
            Monitor.Enter(this);
        }

        public void Unlock()
        {
            Monitor.Exit(this);
        }

        public void WriteLock()
        {
            Lock();
        }

        public void ReadLock()
        {
            Lock();
        }

        public void WriteUnlock()
        {
            Unlock();
        }

        public void ReadUnlock()
        {
            Unlock();
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\Engine.cs ===
using System;
using System.Threading;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol.SubNoti;

namespace xonline.server.XConnSrv
{
    public enum ThreadType : ushort
    {
        eWorker,
        eData
    }

    public abstract class XConnSrvContext
    {
        public ThreadType m_threadType;
        public XomRequestTimeElapsed m_waitTime = null;
        
        public void ProcessContext(Object state)
        {
            XConnSrvEngineCounters.Total.WaitTimeAvg.IncrementBy(m_waitTime.TimeElapsed);
            XConnSrvEngineCounters.Total.WaitTimeAvgBase.Increment();
            XConnSrvEngineCounters.Total[this.ToString()].WaitTimeAvg.IncrementBy(m_waitTime.TimeElapsed);
            XConnSrvEngineCounters.Total[this.ToString()].WaitTimeAvgBase.Increment();

            XomRequestTimeElapsed executionTime = new XomRequestTimeElapsed();
            
            try
            {
                ProcessInternal(state);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.XCONNSRV_CONTEXT_EXCEPTION, e, "Unhandled exception while processing context.");
            }

            XConnSrvEngineCounters.Total.CompletionRate.Increment();
            XConnSrvEngineCounters.Total[this.ToString()].CompletionRate.Increment();
            XConnSrvEngineCounters.Total.ExecutionTimeAvg.IncrementBy(executionTime.TimeElapsed);
            XConnSrvEngineCounters.Total.ExecutionTimeAvgBase.Increment();
            XConnSrvEngineCounters.Total[this.ToString()].ExecutionTimeAvg.IncrementBy(executionTime.TimeElapsed);
            XConnSrvEngineCounters.Total[this.ToString()].ExecutionTimeAvgBase.Increment();
        }
        
        public abstract void ProcessInternal(Object state);
    };

    class XConnSrvEngine
    {            
        // custom thread pool for "worker" threads.  these threads access shared memory and do not block on i/o.
        private static FastThreadPool s_tpWorker;
        private static FastThreadPool s_tpData;
        private static LockFreeStack<byte[]> s_lfsBufferPool;

        private static int BYTES_PER_POOLED_BUFFER;

        public static void Init()
        {
            int cDataThreads = Config.GetIntSetting(Setting.XConnSrv_DataThreadpoolSize);
            s_tpWorker = new FastThreadPool("xconnsrv - worker", Environment.ProcessorCount, ThreadPriority.AboveNormal);
            s_tpData = new FastThreadPool("xconnsrv - data", cDataThreads, ThreadPriority.Normal);
            s_lfsBufferPool = new LockFreeStack<byte[]>();
            BYTES_PER_POOLED_BUFFER = Config.GetIntSetting(Setting.XConnSrv_BytesPerPooledBuffer);
        }

        public static void Shutdown()
        {
            s_tpWorker.Shutdown();
        }
        
        public unsafe static int ConsumeUserRequestBytes(byte[] rgbBuffer, int cBytesAvailable, ClientConnection cliConn)
        {
            int dwConsumed = 0;
            UserRequestContext reqCtx = cliConn.m_ctxPending;

            // check for an existing context to fill in.
            if (reqCtx != null)
            {
                // we're continuing a message in progress.
                int cbToWrite = Math.Min(cBytesAvailable, reqCtx.m_rgbEntireMessage.Length - reqCtx.m_dwWriteOffset);
                System.Buffer.BlockCopy(rgbBuffer, 0, reqCtx.m_rgbEntireMessage, reqCtx.m_dwWriteOffset, cbToWrite);
                reqCtx.m_dwWriteOffset += cbToWrite;
                cBytesAvailable -= cbToWrite;
                dwConsumed += cbToWrite;

                if (reqCtx.m_dwWriteOffset == reqCtx.m_rgbEntireMessage.Length)
                {
                    // we've got all the bytes, queue the message.
                    cliConn.m_ctxPending = null;
                    XConnSrvEngine.QueueContext(ThreadType.eWorker, reqCtx, null);
                }
            }

            // try to parse the message size.
            while (cBytesAvailable >= sizeof(BASE_MESSAGE_HEADER))
            {
                int dwMessageSize = 0;

                fixed (byte *pBuffer = &(rgbBuffer[dwConsumed]))
                {
                    BASE_MESSAGE_HEADER *pHeader = (BASE_MESSAGE_HEADER *)pBuffer;
                    dwMessageSize = (int)pHeader->dwTotalSize;
                }

                if (dwMessageSize >= Config.GetIntSetting(Setting.XConnSrv_MaxMessageBytes))
                {
                    // message is too big to receive.  this shouldnt happen.
                    string sError = "Invalid message received from: " + cliConn.IPAddress + ".  Size (" + dwMessageSize + ") > " + 
                        Config.GetIntSetting(Setting.XConnSrv_MaxMessageBytes) + ".";
                    Xom.NtEvent(XEvent.Id.XCONNSRV_MSG_TOO_BIG, sError);
                    throw new ApplicationException(sError);
                }

                // make a new context.
                reqCtx = new UserRequestContext(cliConn);
                reqCtx.m_rgbEntireMessage = new byte[dwMessageSize];

                int cbToWrite = Math.Min(cBytesAvailable, dwMessageSize);
                System.Buffer.BlockCopy(rgbBuffer, dwConsumed, reqCtx.m_rgbEntireMessage, 0, cbToWrite);
                reqCtx.m_dwWriteOffset += cbToWrite;
                cBytesAvailable -= cbToWrite;
                dwConsumed += cbToWrite;

                if (reqCtx.m_dwWriteOffset == dwMessageSize)
                {
                    // we've got all the bytes, queue the message.
                    XConnSrvEngine.QueueContext(ThreadType.eWorker, reqCtx, null);
                }
                else
                {
                    // don't have enough for this message.  hang onto it.
                    cliConn.m_ctxPending = reqCtx;
                    break;
                }
            }

            return dwConsumed;
        }
        
        public static void QueueContext(ThreadType threadType, XConnSrvContext ctx, Object state)
        {
            ctx.m_threadType = threadType;
            ctx.m_waitTime = new XomRequestTimeElapsed();
            
            switch (threadType)
            {
            case ThreadType.eWorker:
                s_tpWorker.QueueUserWorkItem(new WaitCallback(ctx.ProcessContext), state);
                break;
                
            case ThreadType.eData:
            default:
                s_tpData.QueueUserWorkItem(new WaitCallback(ctx.ProcessContext), state);
                break;
            }
        }

        public static byte[] GetSendBuffer(int cbSize)
        {
            if (cbSize > BYTES_PER_POOLED_BUFFER)
            {
                return new byte[cbSize];
            }
            
            byte[] rgbBuffer = s_lfsBufferPool.Pop();
            if (rgbBuffer == null)
            {
                rgbBuffer = new byte[BYTES_PER_POOLED_BUFFER];
                XConnSrvCounters.Current.TotalSendBuffers.Increment();
            }
            else
            {
                XConnSrvCounters.Current.FreeSendBuffers.Decrement();
            }

            return rgbBuffer;
        }

        public static void ReturnSendBuffer(byte[] rgbBuffer)
        {
            if (rgbBuffer.Length == BYTES_PER_POOLED_BUFFER)
            {
                s_lfsBufferPool.Push(rgbBuffer);
                XConnSrvCounters.Current.FreeSendBuffers.Increment();
            }
        }
    };

    [XomPerformanceCounterCategoryAttr( "Connection Svc - Engine", "Xbox Live Connection Server Per Context Type Counters" )]
    public class XConnSrvEngineCounters : XomPerformanceCounterCategory
    {
        public XConnSrvEngineCounters() : base(true)
        {
        }
                       
        public virtual XConnSrvEngineCounters this[string sType]
        {
            get
            {
                return (XConnSrvEngineCounters) GetInstance(sType);
            }
        }

        static public XConnSrvEngineCounters Total = new XConnSrvEngineCounters();
        
        [XomPerformanceCounterAttr(
            "Completion Rate", 
            "Total number of all contexts per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompletionRate;

        [XomPerformanceCounterAttr(
            "Context Execution Time (ms)", 
            "Average time (in milliseconds) a context takes to execute.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter ExecutionTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Execution Time Base", 
            "Average time (in milliseconds) a context takes to execute.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter ExecutionTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Context Wait Time (ms)", 
            "Average time (in milliseconds) a context waits to be processed.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter WaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Wait Time Base", 
            "Average time (in milliseconds) a context waits to be processed.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTimeAvgBase;

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\msgr\AsyncResult.cs ===
//-----------------------------------------------------------------------
// <copyright file="AsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//     Represents an asynchronous result object.
// </summary>
//
// <history>
//     2007/01/26  sgordon    Moved from the ServiceProxy library to the
//                            Messenger runtime.
//     2007/03/03  sgordon    Added support for the WaitHandle property.
// </history>
//-----------------------------------------------------------------------

namespace MS.Msn.Messenger.Runtime
{
    using System;
    using System.Threading;

    /// <summary>
    /// Generic IAsyncResult implementation. The result type is a generic type.
    /// </summary>
    /// <typeparam name="ResultType">Result that should be returned from the end method</typeparam>
    public class AsyncResult<ResultType> : IAsyncResult
    {
        /// <summary>
        /// The asynchronous callback.
        /// </summary>
        private readonly AsyncCallback callback;

        /// <summary>
        /// The associated state object.
        /// </summary>
        private readonly Object state;

        /// <summary>
        /// Whether the operation has completed.
        /// </summary>
        private bool isCompleted;

        /// <summary>
        /// Whether the operation completed synchronously.
        /// </summary>
        private bool completedSynchronously;

        /// <summary>
        /// The associated result code.
        /// </summary>
        private ResultType result;

        /// <summary>
        /// The associated exception.
        /// </summary>
        private Exception exception;

        /// <summary>
        /// The associated wait handle.
        /// </summary>
        private ManualResetEvent waitHandle;

        /// <summary>
        /// Ctor. Saves off callback and state values to be invoked later.
        /// </summary>
        /// <param name="callback">Callback to invoke when operation completes</param>
        /// <param name="state">State to associate with the operation</param>
        public AsyncResult(AsyncCallback callback, Object state)
        {
            this.callback = callback;
            this.state = state;
        }

        /// <summary>
        /// Returns operation result
        /// </summary>
        public ResultType Result
        {
            get { return this.result; }
        }

        /// <summary>
        /// Gets the associated exception, if any.
        /// </summary>
        public Exception Exception
        {
            get { return this.exception; }
        }

        /// <summary>
        /// AsyncState
        /// </summary>
        public object AsyncState
        {
            get { return this.state; }
        }

        /// <summary>
        /// Gets a WaitHandle that is used to wait for an asynchronous operation to complete.
        /// </summary>
        public WaitHandle AsyncWaitHandle
        {
            get
            {
                lock (this)
                {
                    if (this.waitHandle == null)
                    {
                        this.waitHandle = new ManualResetEvent(false);
                    }

                    // If the caller gets the WaitHandle, and we've already
                    // completed, we need to call Set so that they don't block
                    // forever.
                    if (this.IsCompleted)
                    {
                        try
                        {
                            this.waitHandle.Set();
                        }
                        catch (ObjectDisposedException)
                        {
                        }
                    }
                    }

                return this.waitHandle;
            }
        }

        /// <summary>
        /// <c>true</c> if operation completed synchronously
        /// </summary>
        public bool CompletedSynchronously
        {
            get { return this.completedSynchronously; }
        }

        /// <summary>
        /// <c>true</c> if operation completed
        /// </summary>
        public bool IsCompleted
        {
            get { return this.isCompleted; }
        }

        /// <summary>
        /// The callback that should be called upon completion.
        /// </summary>
        protected AsyncCallback Callback
        {
            get { return this.callback; }
        }

        /// <summary>
        /// Completes the request. Invokes saved off callback to notify caller
        /// that operation has been completed.
        /// </summary>
        /// <param name="result">Operation result</param>
        /// <param name="completedSynchronously"><c>true</c> if completed 
        /// synchronously</param>
        public virtual void CompleteRequest(ResultType result, bool completedSynchronously)
        {
            this.result = result;
            this.completedSynchronously = completedSynchronously;
            this.SignalCompleted();
        }

        /// <summary>
        /// Completes the request. Invokes the saved callback to notify the caller
        /// that the operation has completed with an exception.
        /// </summary>
        /// <param name="exception">The exception that occurred.</param>
        /// <param name="completedSynchronously">Whether the operation completed
        /// synchronously.</param>
        public void CompleteRequest(Exception exception, bool completedSynchronously)
        {
            this.exception = exception;
            this.completedSynchronously = completedSynchronously;
            this.SignalCompleted();
        }

        /// <summary>
        /// More efficient call than grabbing the AsyncWaitHandle - ManualResetEvent
        /// is not created if we've already completed.
        /// </summary>
        public void BlockUntilCompleted()
        {
            lock (this)
            {
                if (this.isCompleted)
                {
                    return;
                }
            }

            this.AsyncWaitHandle.WaitOne();
        }

        /// <summary>
        /// Signals that the async result has completed.
        /// </summary>
        private void SignalCompleted()
        {
            lock (this)
            {
                this.isCompleted = true;

                if (this.waitHandle != null)
                {
                    try
                    {
                        this.waitHandle.Set();
                    }
                    catch (ObjectDisposedException)
                    {
                    }
                }
            }

            if (this.callback != null)
            {
                this.callback(this);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\Data.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Collections.ObjectModel;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.protocol.SubNoti;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.health;
using xonline.common.community;

namespace xonline.server.XConnSrv
{
    public delegate void DataRetrievalCompletionProc(string sKey, byte[] rgbValue, Object state);
    public delegate void BulkDataRetrievalCompletionProc(BulkDataRetrievalContext dataCtx, Object state);

    public class BulkDataRetrievalContext : XConnSrvContext
    {
        protected class SingleItem
        {
            public string m_sKey;
            public Object m_keyState;
            public Object m_completionState;
            public DataRetrievalCompletionProc m_completionProc;
        }

        protected bool m_fProcessed = false;
        protected Hashtable m_htItems;
        protected string[] m_rgKeys;
        protected Object[] m_rgKeyStates;
        protected byte[][] m_rgValues;
        protected BulkDataRetrievalCompletionProc m_completionProc;
        protected Object m_completionState;
        
        public int NumObjects
        {
            get
            {
                return m_htItems.Count;
            }
        }

        public BulkDataRetrievalContext() : this(null, null)
        {
        }
        public BulkDataRetrievalContext(BulkDataRetrievalCompletionProc completionProc, Object state)
        {
            m_htItems = new Hashtable();
            m_completionProc = completionProc;
            m_completionState = state;
        }

        public void AddDataObject(DATA_OBJECT_SPECIFIER doSpec)
        {
            AddDataObject(ref doSpec);
        }
        public void AddDataObject(ref DATA_OBJECT_SPECIFIER doSpec)
        {
            AddKey(CacheUtil.GetDataKeyString(ref doSpec), null, null, doSpec);
        }

        public void AddKey(string sKey, Object keyState, DataRetrievalCompletionProc completionProc, Object state)
        {
            SingleItem item = new SingleItem();
            item.m_sKey = sKey;
            item.m_keyState = keyState;
            item.m_completionProc = completionProc;
            item.m_completionState = state;

            m_htItems[sKey] = item;
        }

        public string GetItemKey(int iIndex)
        {
            return m_rgKeys[iIndex];
        }

        public DATA_OBJECT_SPECIFIER GetItemSpecifier(int iIndex)
        {
            SingleItem item = (SingleItem)m_htItems[m_rgKeys[iIndex]];
            if (item.m_completionState is DATA_OBJECT_SPECIFIER)
            {
                return (DATA_OBJECT_SPECIFIER)item.m_completionState;
            }
            else
            {
                return CacheUtil.GetDataKeyFromString(m_rgKeys[iIndex]);
            }
        }

        public byte[] GetItemData(int iIndex)
        {
            return m_rgValues[iIndex];
        }

        public unsafe override void ProcessInternal(Object state)
        {
            if (!m_fProcessed)
            {
                m_rgKeys = new string[m_htItems.Count];
                m_rgKeyStates = new Object[m_htItems.Count];
                int iKey = 0;
                foreach (SingleItem item in m_htItems.Values)
                {
                    m_rgKeys[iKey] = item.m_sKey;
                    m_rgKeyStates[iKey] = item.m_keyState;
                    iKey++;
                }
                
                m_rgValues = MemCache.BulkRequestData(m_rgKeys, m_rgKeyStates);

                for (iKey = 0; iKey < m_rgValues.Length; iKey++)
                {
                    // sanity check the blob.
                    if ((m_rgValues[iKey] == null) || (m_rgValues[iKey].Length == 0))
                    {
                        // make an empty header.  don't throw an event here.
                        m_rgValues[iKey] = DataUtilities.BuildEmptyHeader(GetItemSpecifier(iKey));
                    }
                    else if (m_rgValues[iKey].Length < sizeof(BASE_DATA_HEADER))
                    {
                        // bogus data.
                        Xom.NtEvent(XEvent.Id.XCONNSRV_DATA_TOO_SMALL, "Data returned from MemCache too small (" + ((m_rgValues[iKey] == null) ? "{null}" : m_rgValues[iKey].Length.ToString()) 
                            + " < " + sizeof(BASE_DATA_HEADER) + ") for key: " + m_rgKeys[iKey]);
                        
                        m_rgValues[iKey] = DataUtilities.BuildEmptyHeader(GetItemSpecifier(iKey));
                    }
                    else
                    {
                        fixed (byte *pBuffer = &(m_rgValues[iKey][0]))
                        {
                            BASE_DATA_HEADER *pHeader = (BASE_DATA_HEADER *)pBuffer;
                            if (pHeader->doSpec.wObjectSize != m_rgValues[iKey].Length)
                            {
                                // data integrity error.
                                Xom.NtEvent(XEvent.Id.XCONNSRV_DATA_INTEGRITY_ERROR, "Data size returned from MemCache did not match header (" + m_rgValues[iKey].Length 
                                    + " < " + pHeader->doSpec.wObjectSize + ") for key: " + m_rgKeys[iKey]);

                                m_rgValues[iKey] = DataUtilities.BuildEmptyHeader(GetItemSpecifier(iKey));
                            }
                        }
                    }
                }

                m_fProcessed = true;
                XConnSrvEngine.QueueContext(ThreadType.eWorker, this, null);
            }
            else
            {
                if (m_completionProc != null)
                {
                    // fire the bulk callback.
                    m_completionProc(this, m_completionState);
                }
                else
                {
                    int iKey = 0;
                    foreach (SingleItem item in m_htItems.Values)
                    {
                        // fire each individual callback.
                        item.m_completionProc(item.m_sKey, m_rgValues[iKey], item.m_completionState);
                        iKey++;
                    }
                }
            }            
        }
    }
    
    public class DataPublishContext : XConnSrvContext
    {
        protected string m_sKey;
        protected byte[] m_rgbValue;
        
        public DataPublishContext(string sKey, byte[] rgbValue)
        {
            m_sKey = sKey;
            m_rgbValue = rgbValue;
        }

        public override void ProcessInternal(Object state)
        {
            Xom.Trace(XomAreaName.XConnSrvCache, LogLevel.L_LOW, "Cache: publishing data for key: " + m_sKey);
            
            // write the data into memcache.
            MemCache.PublishData(m_sKey, m_rgbValue);
        }
    }

    public class DataChangeNotificationContext : XConnSrvContext
    {
        public string[] m_rgChangedKeys;
        public Object[] m_rgKeyStates;
        
        public static void OnMemCacheNotification(string[] rgChangedKeys, Object[] rgKeyStates)
        {
            XConnSrvCacheCounters.Current.NotificationBatchesPerSecond.Increment();

            Xom.Trace(XomAreaName.XConnSrvCache, LogLevel.L_NORMAL, "Cache: received notfication key list.");

            DataChangeNotificationContext ctx = new DataChangeNotificationContext(rgChangedKeys, rgKeyStates);
            XConnSrvEngine.QueueContext(ThreadType.eWorker, ctx, null);
        }

        public DataChangeNotificationContext(string[] rgChangedKeys, Object[] rgKeyStates)
        {
            m_rgChangedKeys = rgChangedKeys;
            m_rgKeyStates = rgKeyStates;
        }
        
        public override void ProcessInternal(Object state)
        {
            BulkDataRetrievalContext dataCtx = null;
            int cMaxBatchSize = Config.GetIntSetting(Setting.XConnSrv_BulkGetBatchMaxSize);
            
            for (int iKey = 0; iKey < m_rgChangedKeys.Length; iKey++)
            {
                XConnSrvCacheCounters.Current.NotificationsPerSecond.Increment();

                Xom.Trace(XomAreaName.XConnSrvCache, LogLevel.L_LOW, "Cache: processing notfication for key: " + m_rgChangedKeys[iKey]);

                DataSubscriptionKey key = null;
                DataRetrievalCompletionProc callbackList = null;

                try
                {
                    DATA_OBJECT_SPECIFIER doSpec = CacheUtil.GetDataKeyFromString(m_rgChangedKeys[iKey]);
                    key = new DataSubscriptionKey(ref doSpec);
                }
                catch (Exception)
                {
                    // skip any notification that doesnt parse to a DataSubscriptionKey.  the health check does this.
                    // we dont want any bogus keys terminating our batch.
                    continue;
                }

                // user subscriptions
                XConnSrv.Instance.DataSubscriptions.ProcessCacheNotification(key, ref callbackList);

                // connected user internals
                ClientConnection.ProcessCacheNotification(key, ref callbackList);

                if (callbackList != null)
                {
                    if (dataCtx == null)
                    {
                        dataCtx = new BulkDataRetrievalContext();
                    }
                    
                    dataCtx.AddKey(m_rgChangedKeys[iKey], m_rgKeyStates[iKey], callbackList, key);

                    if (dataCtx.NumObjects >= cMaxBatchSize)
                    {
                        XConnSrvEngine.QueueContext(ThreadType.eData, dataCtx, null);
                        dataCtx = null;
                    }
                }
            }

            // post the remaining contexts.
            if (dataCtx != null)
            {
                XConnSrvEngine.QueueContext(ThreadType.eData, dataCtx, null);
            }
        }

    }

    public class DataUtilities
    {
        public const string DEFAULT_LOCALE = "default";
        
        public static byte[] BuildEmptyHeader(DATA_OBJECT_SPECIFIER doSpec)
        {
            return BuildEmptyHeader(ref doSpec);
        }
        public unsafe static byte[] BuildEmptyHeader(ref DATA_OBJECT_SPECIFIER doSpec)
        {
            byte[] rgbEmptyData = new byte[sizeof(BASE_DATA_HEADER)];
            fixed (byte *pData = &(rgbEmptyData[0]))
            {
                BASE_DATA_HEADER *pHeader = (BASE_DATA_HEADER *)pData;
                pHeader->doSpec = doSpec;
                pHeader->doSpec.wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
                pHeader->dwHeaderFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;
            }

            return rgbEmptyData;
        }

        public unsafe static Hashtable BuildLanguageSpecificCache(byte[] rgbData)
        {
            Hashtable htLocales = null;
            fixed (byte *pData = &(rgbData[0]))
            {
                // language TOC comes after the outer header.
                PER_LANGUAGE_TOC *pTOC = (PER_LANGUAGE_TOC *)(pData + sizeof(BASE_DATA_HEADER));

                // loop the locale strings in the TOC.
                LANGUAGE_TOC_ENTRY *pLanguageOffsets = (LANGUAGE_TOC_ENTRY *)(pData + sizeof(BASE_DATA_HEADER) + sizeof(PER_LANGUAGE_TOC));
                for (ushort iSupported = 0; iSupported < pTOC->wNumLanguages; iSupported++)
                {
                    int offset = sizeof(BASE_DATA_HEADER) + sizeof(PER_LANGUAGE_TOC) + (iSupported * sizeof(LANGUAGE_TOC_ENTRY));

                    // account for the zero-padding on the locale string.
                    int localeLen = 0;
                    while ((rgbData[offset + localeLen] != '\0') && (localeLen < sizeof(ulong))) localeLen++;                    
                    string locale = Encoding.ASCII.GetString(rgbData, offset, localeLen);

                    // find the inner header at the offset for this language as speficied by the TOC.
                    BASE_DATA_HEADER *pInnerHeader = (BASE_DATA_HEADER *)(pData + pLanguageOffsets[iSupported].wOffset);

                    // make a new array to cache.
                    byte[] rgbInnerData = new byte[pInnerHeader->doSpec.wObjectSize];

                    // copy the language specific data to the new buffer.
                    System.Buffer.BlockCopy(rgbData, pLanguageOffsets[iSupported].wOffset, rgbInnerData, 0, rgbInnerData.Length);

                    if (iSupported == 0)
                    {
                        htLocales = new Hashtable(pTOC->wNumLanguages + 1);
                        htLocales[DEFAULT_LOCALE] = rgbInnerData;
                    }

                    htLocales[locale] = rgbInnerData;
                }
                
                return htLocales;
            }
        }
        
        public unsafe static byte[] AdjustDataForLanguage(byte[] rgbData, string[] rgLocales)
        {
            fixed (byte *pData = &(rgbData[0]))
            {
                // language TOC comes after the outer header.
                PER_LANGUAGE_TOC *pTOC = (PER_LANGUAGE_TOC *)(pData + sizeof(BASE_DATA_HEADER));

                // get the locale strings.
                string[] rgSupportedLocales = new string[pTOC->wNumLanguages];
                LANGUAGE_TOC_ENTRY *pLanguageOffsets = (LANGUAGE_TOC_ENTRY *)(pData + sizeof(BASE_DATA_HEADER) + sizeof(PER_LANGUAGE_TOC));
                for (ushort iSupported = 0; iSupported < rgSupportedLocales.Length; iSupported++)
                {
                    int offset = sizeof(BASE_DATA_HEADER) + sizeof(PER_LANGUAGE_TOC) + (iSupported * sizeof(LANGUAGE_TOC_ENTRY));

                    // account for the zero-padding on the locale string.
                    int localeLen = 0;
                    while ((rgbData[offset + localeLen] != '\0') && (localeLen < sizeof(ulong))) localeLen++;                    
                    rgSupportedLocales[iSupported] = Encoding.ASCII.GetString(rgbData, offset, localeLen);
                }

                // find the first matching locale.
                int iLocaleMatch = -1;
                for (int iLocale = 0; (iLocaleMatch == -1) && (iLocale < rgLocales.Length); iLocale++)
                {
                    for (ushort iSupported = 0; iSupported < rgSupportedLocales.Length; iSupported++)
                    {
                        if (rgSupportedLocales[iSupported] == rgLocales[iLocale])
                        {
                            iLocaleMatch = iSupported;
                            break;
                        }
                    }
                }
                if (iLocaleMatch == -1)
                {
                    // no match, use the default.
                    iLocaleMatch = 0;
                }

                // find the inner header at the offset for this language as speficied by the TOC.
                BASE_DATA_HEADER *pInnerHeader = (BASE_DATA_HEADER *)(pData + pLanguageOffsets[iLocaleMatch].wOffset);

                // make a new array to return.
                byte[] rgbInnerData = new byte[pInnerHeader->doSpec.wObjectSize];

                // copy the language specific data to the new buffer.
                System.Buffer.BlockCopy(rgbData, pLanguageOffsets[iLocaleMatch].wOffset, rgbInnerData, 0, rgbInnerData.Length);
                
                return rgbInnerData;
            }
        }

        public unsafe static uint GetDataFlags(byte[] rgbData)
        {
            uint dwFlags;
            fixed (byte *pData = &(rgbData[0]))
            {
                BASE_DATA_HEADER *pDataHeader = (BASE_DATA_HEADER *)pData;
                dwFlags = pDataHeader->dwHeaderFlags;
            }

            return dwFlags;
        }

        public unsafe static bool IsDataAccessible(ulong qwOwnerID, uint dwDataFlags, ClientConnection cliConnViewer, uint dwViewerIndexFlags)
        {
            if ((dwDataFlags & CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE) != 0)
            {
                return true;
            }
            
            if (((dwDataFlags & CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) != 0)
                && cliConnViewer.IsAcceptedFriend(qwOwnerID, dwViewerIndexFlags))
            {
                return true;
            }

            // the data is always shared to the owner himself.
            int[] rgIndices = SubNotiDefs.UserFlagsToIndices(dwViewerIndexFlags);
            for (int iIndex = 0; iIndex < rgIndices.Length; iIndex++)
            {
                if (cliConnViewer.qwUserIDs[rgIndices[iIndex]] == qwOwnerID)
                {
                    return true;
                }
            }

            return false;
        }

        public unsafe static byte[] TruncateData(byte[] rgbData, ushort wMaxSize)
        {
            byte[] rgbTruncated = new byte[wMaxSize];
            
            fixed (byte *pData = &(rgbData[0]))
            {
                BASE_DATA_HEADER *pDataHeader = (BASE_DATA_HEADER *)pData;

                pDataHeader->doSpec.wObjectSize = wMaxSize;
            }

            System.Buffer.BlockCopy(rgbData, 0, rgbTruncated, 0, wMaxSize);
            return rgbTruncated;
        }

        public unsafe static byte[] CustomizeDataForUser(byte[] rgbData, ClientConnection cliConn, uint dwUserIndexFlags, ushort wMaxSize)
        {
            // check privacy.
            fixed (byte *pData = &(rgbData[0]))
            {
                BASE_DATA_HEADER *pDataHeader = (BASE_DATA_HEADER *)pData;
                
                if (!IsDataAccessible(pDataHeader->doSpec.qwOwnerXUID, pDataHeader->dwHeaderFlags, cliConn, dwUserIndexFlags))
                {
                    // data is blocked to this subscriber.
                    Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_LOW, "Data blocked to client " + cliConn.IPAddress + " for key: " 
                        + CacheUtil.GetDataKeyString(ref pDataHeader->doSpec) + " due to privacy policy.");
                    
                    rgbData = BuildEmptyHeader(ref pDataHeader->doSpec);
                }
            }

            // check language specific.
            fixed (byte *pData = &(rgbData[0]))
            {
                BASE_DATA_HEADER *pDataHeader = (BASE_DATA_HEADER *)pData;

                if ((pDataHeader->dwHeaderFlags & CacheUtil.XONLINE_CACHE_DATA_FLAG_LANGUAGE_SPECIFIC) != 0)
                {
                    Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_LOW, "Data to client " + cliConn.IPAddress + " for key: " 
                        + CacheUtil.GetDataKeyString(ref pDataHeader->doSpec) + " adjusted for language id " + cliConn.m_sginfo.LanguageID);

                    rgbData = AdjustDataForLanguage(rgbData, cliConn.LocaleList);
                }
            }

            // check max size.
            if (rgbData.Length > wMaxSize)
            {
                rgbData = TruncateData(rgbData, wMaxSize);
            }
            
            return rgbData;
        }

        public unsafe static byte[] BuildLocationData(ulong qwUserID, uint dwClientIP, ushort wClientPort, SGADDR sgaddr)
        {
            ConnSrvLocation location = new ConnSrvLocation();
            location.OwnerID = qwUserID;
            location.dwClientIP = dwClientIP;
            location.wClientPort = wClientPort;
            location.dwServerIP = (uint)System.Net.IPAddress.NetworkToHostOrder((int)XConnSrv.Instance.LocalInterfaceInfo.IPAddressDword);
            location.sServerName = XConnSrv.Instance.LocalInterfaceInfo.ServerName;
            location.extension.sgaddr = sgaddr;

            return (byte[])location;
        }

        public static string DisplayBytes(byte[] rgb)
        {
            if (rgb == null) return "\r\n";

            StringBuilder sb = new StringBuilder();
            
            string[] lines = ByteConvert.ToFormattedStrings(rgb);
            foreach (string line in lines) 
            {
                sb.AppendLine(line);
            }

            return sb.ToString();
        }
    }

    public class MemCache
    {
        protected static IMemCache s_MemCache = null;

        public static void Init()
        {
            try
            {
                string dllName = Config.GetSetting(Setting.XConnSrv_MemCacheDllName);
                s_MemCache = (IMemCache)Activator.CreateInstance(Type.GetType("xonline.server.XConnSrv.MemCacheImpl," + dllName));

                s_MemCache.RegisterNotificationHandler(DataChangeNotificationContext.OnMemCacheNotification);
                s_MemCache.RegisterNotificationFailureHandler(OnMemCacheNotificationFailure);

                XConnSrv.Instance.Log("Loaded MemCache implementation: " + GetImplementationName() + ".");
            }
            catch (Exception)
            {
                s_MemCache = null;
                XConnSrv.Instance.Log("Could not load MemCache implementation.");
                throw;
            }
        }

        public static void Shutdown()
        {
            s_MemCache.UnregisterHandlers();
        }

        public static string GetImplementationName()
        {
            return s_MemCache.GetImplementationName();
        }

        public static byte[] RequestData(string sKey)
        {
            return RequestData(sKey, null);
        }
        public static byte[] RequestData(string sKey, Object keyState)
        {
            XConnSrvCacheCounters.Current.GetsPerSecond.Increment();
            
            return s_MemCache.RequestData(sKey, keyState);
        }

        public static byte[][] BulkRequestData(string[] rgKeys)
        {
            return BulkRequestData(rgKeys, new Object[rgKeys.Length]);
        }
        public static byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates)
        {
            XConnSrvCacheCounters.Current.GetBatchesPerSecond.Increment();
            XConnSrvCacheCounters.Current.GetsPerSecond.IncrementBy(rgKeys.Length);
            
            return s_MemCache.BulkRequestData(rgKeys, rgKeyStates);
        }

        public static void PublishData(string sKey, byte[] rgbData)
        {
            PublishData(sKey, rgbData, null);
        }
        public static void PublishData(string sKey, byte[] rgbData, Object keyState)
        {
            XConnSrvCacheCounters.Current.PutsPerSecond.Increment();
            
            s_MemCache.PublishData(sKey, rgbData, keyState);
        }

        public static string AdminShowCacheData(string sKey)
        {
            byte[] rgbData = RequestData(sKey);
            if (rgbData == null)
            {
                return "Key (" + sKey + ") not found.\r\n";
            }

            return DataUtilities.DisplayBytes(rgbData);
        }
        
        public static unsafe string AdminShowUserLocation(ulong qwUserID)
        {
            DATA_OBJECT_SPECIFIER doSpec = new DATA_OBJECT_SPECIFIER();
            doSpec.wDataType = (ushort)DATA_TYPES.eConnSrvLocation;
            doSpec.qwOwnerXUID = qwUserID;

            byte[] rgbData = RequestData(CacheUtil.GetDataKeyString(ref doSpec));
            ConnSrvLocation location = (ConnSrvLocation)CacheUtil.ReadCacheItemFromBytes(rgbData);
            if (location == null)
            {
                return "User " + qwUserID.ToString("X") +" not found.\r\n";
            }
            
            IPAddress ipClient = new IPAddress(location.dwClientIP);
            IPAddress ipServer = new IPAddress(location.dwServerIP);

            return "User " + qwUserID.ToString("X") + " was last connected to server " + location.sServerName + "(" + ipServer.ToString()
                + ") from client address " + ipClient.ToString() + ":" + location.wClientPort.ToString() +".\r\n";
        }
        
        public static string AdminDisconnectUser(ulong qwUserID)
        {
            DATA_OBJECT_SPECIFIER doSpec = new DATA_OBJECT_SPECIFIER();
            doSpec.wDataType = (ushort)DATA_TYPES.eConnSrvLocation;
            doSpec.qwOwnerXUID = qwUserID;

            PublishData(CacheUtil.GetDataKeyString(ref doSpec), DataUtilities.BuildEmptyHeader(ref doSpec));
            
            return "Deleted signin info for user " + qwUserID.ToString("X") + ".\r\n";
        }

        public static void OnMemCacheNotificationFailure()
        {
            Xom.NtEvent(XEvent.Id.XCONNSRV_VELOCITY_NOTIFICATION_FAILURE, "Notification(s) missed from data cache: " + s_MemCache.GetImplementationName());
        }

    }

    public class MemCacheHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        private static string _HealthKey = "MemCacheHealth";
        private static byte[] _HealthValue1 = new byte[] {(byte)1};
        private static byte[] _HealthValue2 = new byte[] {(byte)2};

        public static bool CompareByteArrays(byte[] array1, byte[] array2)
        {
            if (array1 == null) return (array2 == null);
            if (array2 == null) return false;
            if (array1.Length != array2.Length) return false;
            for (int i = 0; i < array1.Length; i++)
            {
                if (array1[i] != array2[i]) return false;
            }
            return true;
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                report.ErrorDetails += "\r\nUsing MemCache implementation: " + MemCache.GetImplementationName();

                report.HealthStatus = HealthStatusEnum.Green;
                string localKey = _HealthKey + Config.Server;
                
                report.ErrorDetails += "\r\nWriting health value 1...";
                MemCache.PublishData(localKey, _HealthValue1);
                byte[] rgb = MemCache.RequestData(localKey);
                if (!CompareByteArrays(rgb, _HealthValue1))
                {
                    report.ErrorDetails += "FAILED\r\n";
                    report.HealthStatus = HealthStatusEnum.Red;
                    return;
                }

                report.ErrorDetails += "\r\nWriting health value 2...";
                MemCache.PublishData(localKey, _HealthValue2);
                rgb = MemCache.RequestData(localKey);
                if (!CompareByteArrays(rgb, _HealthValue2))
                {
                    report.ErrorDetails += "FAILED\r\n";
                    report.HealthStatus = HealthStatusEnum.Red;
                    return;
                }
                
                report.ErrorDetails += "\r\nAll good!\r\n";
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails += e.ToString();
            }
        }
    }

    [XomPerformanceCounterCategoryAttr( "Connection Svc - Cache", "Xbox Live Connection Server Cache Operation Counters" )]
    public class XConnSrvCacheCounters : XomPerformanceCounterCategory
    {
        public XConnSrvCacheCounters() : base(true)
        {
        }

        static public XConnSrvCacheCounters Current = new XConnSrvCacheCounters();
        
        [XomPerformanceCounterAttr(
            "Key Gets per Second", 
            "Number of keys read from the cache per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetsPerSecond;

        [XomPerformanceCounterAttr(
            "Get Batches per Second", 
            "Number of get batches issued to the cache per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetBatchesPerSecond;

        [XomPerformanceCounterAttr(
            "Key Puts per Second", 
            "Number of keys written to the cache per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PutsPerSecond;

        [XomPerformanceCounterAttr(
            "Key Notifications per Second", 
            "Number of keys reported changed by the cache per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter NotificationsPerSecond;

        [XomPerformanceCounterAttr(
            "Notification Batches per Second", 
            "Number of notification batches received from the cache per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter NotificationBatchesPerSecond;

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\LookupTable.cs ===
using System;

namespace xonline.server.XConnSrv
{
    public interface ILookupTableItem
    {
        // obtain the key for an item.
        Object Key
        {
            get;
        }

        // get/set the next pointer for an item.
        ILookupTableItem Next
        {
            get;
            set;
        }
    }
    
    public class LookupTable
    {
        protected int m_cBuckets;
        protected ILookupTableItem[] m_rgBuckets;
        protected MonitorLock[] m_rgBucketLocks;

        public int NumBuckets 
        {
            get
            {
                return m_cBuckets;
            }
        }

        // create a new lookup table with the specified number of buckets.
        public LookupTable(int cBuckets)
        {
            m_cBuckets = cBuckets;

            // make the buckets.
            m_rgBuckets = new ILookupTableItem[m_cBuckets];

            // make the bucket locks.
            m_rgBucketLocks = new MonitorLock[m_cBuckets];
            for (int iLock = 0; iLock < m_cBuckets; iLock++)
            {
                m_rgBucketLocks[iLock] = new MonitorLock();
            }
        }

        // lock a bucket for use.
        public int LockItemByKey(Object key)
        {
            int iBucket = Hash(key);

            // lock the bucket.
            m_rgBucketLocks[iBucket].WriteLock();

            return iBucket;
        }

        // unlock a bucket.
        public void UnlockItem(int iLockToken)
        {
            // unlock the bucket.
            m_rgBucketLocks[iLockToken].WriteUnlock();
        }

        // insert this item into the lookup table.
        public void AddLookupItem(int iLockToken, ILookupTableItem item)
        {
            // link this item into the chain for this bucket.
            item.Next = m_rgBuckets[iLockToken];
            m_rgBuckets[iLockToken] = item;
        }

        // find an item given its key.
        public ILookupTableItem FindLookupItem(int iLockToken, Object key)
        {
            // search the bucket for the key.
            ILookupTableItem bucketItem = m_rgBuckets[iLockToken];
            while (bucketItem != null)
            {
                if (key.Equals(bucketItem.Key))
                {
                    // found it!
                    return bucketItem;
                }

                bucketItem = bucketItem.Next;
            }

            // didnt find the item.
            return null;
        }

        // remove this item from the lookup table.
        public bool RemoveLookupItem(int iLockToken, ILookupTableItem item)
        {
            Object key = item.Key;
            
            if (m_rgBuckets[iLockToken] != null)
            {
                // check the head pointer first.
                if (key.Equals(m_rgBuckets[iLockToken].Key))
                {
                    // head pointer is the match.  just advance the head pointer.
                    m_rgBuckets[iLockToken] = m_rgBuckets[iLockToken].Next;
                    return true;
                }
                else
                {
                    // start with the next pointer.
                    ILookupTableItem bucketItem = m_rgBuckets[iLockToken];
                    ILookupTableItem bucketNext = bucketItem.Next;
                    while (bucketNext != null)
                    {
                        if (key.Equals(bucketNext.Key))
                        {
                            // found the target to delete.  un-link it from the list.
                            bucketItem.Next = bucketNext.Next;
                            return true;
                        }

                        bucketItem = bucketNext;
                        bucketNext = bucketNext.Next;
                    }
                }
            }

            // didnt find the item.
            return false;
        }

        protected int Hash(Object key)
        {
            return (int)((uint)(key.GetHashCode()) % m_cBuckets);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\Subscription.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace xonline.server.XConnSrv
{
    public class DataSubscriptionKey
    {
        protected DATA_OBJECT_SPECIFIER m_doSpec;
        public DATA_OBJECT_SPECIFIER DOSpec
        {
            get
            {
                return m_doSpec;
            }
        }

        public DataSubscriptionKey(ref DATA_OBJECT_SPECIFIER doSpec)
        {
            m_doSpec = doSpec;
        }

        public override bool Equals(Object key)
        {
            DataSubscriptionKey _key = key as DataSubscriptionKey;
            return ((_key != null) 
                && (_key.DOSpec.wDataType == m_doSpec.wDataType) 
                && (_key.DOSpec.dwDataSubType == m_doSpec.dwDataSubType) 
                && (_key.DOSpec.qwOwnerXUID == m_doSpec.qwOwnerXUID));
        }

        protected int InternalDataLength
        {
            get
            {
                return 3;
            }
        }
        protected uint GetInternalDataUInt(int index)
        {
            switch (index)
            {
                case 0:
                    return ((uint)m_doSpec.wDataType << 16) ^ (uint)(m_doSpec.qwOwnerXUID >> 32);
                case 1:
                    return (uint)m_doSpec.qwOwnerXUID;
                case 2:
                    return m_doSpec.dwDataSubType;
            }
            
            throw new ArgumentException("GetInternalDataUInt() called with index " + index);
        }

        public override int GetHashCode()
        {
            // this hash function is taken from http://murmurhash.googlepages.com/
            
            // 'm' and 'r' are mixing constants generated offline.
            // They're not really 'magic', they just happen to work well.
            const uint m = 0x5bd1e995;
            const int r = 24;

            // the algorithm allows for a seed here, but we dont need it.
            uint h = 1;

            // Mix 4 bytes at a time into the hash
            for (int iData = 0; iData < InternalDataLength; iData++)
            {
                uint k = GetInternalDataUInt(iData);

                k *= m;
                k ^= (k >> r);
                k *= m;

                h *= m;
                h ^= k;
            }

            // Do a few final mixes of the hash to ensure the last few
            // bytes are well-incorporated.
            h ^= (h >> 13);
            h *= m;
            h ^= (h >> 15);

            return (int)h;
        }
    }
    
    public class SubscriberList : ILookupTableItem, IEnumerable
    {
        protected DataSubscriptionKey m_key;
        Object ILookupTableItem.Key
        {
            get
            {
                return (Object)m_key;
            }
        }

        protected ILookupTableItem m_next;
        ILookupTableItem ILookupTableItem.Next
        {
            get
            {
                return m_next;
            }
            set
            {
                m_next = value;
            }
        }

        protected Subscription m_listHead;

        protected int m_cItems;
        public int Count
        {
            get
            {
                return m_cItems;
            }
        }

        public uint DataFlags;

        public SubscriberList(DataSubscriptionKey key)
        {
            Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_NORMAL, "Creating new subscription list for key:" + CacheUtil.GetDataKeyString(key.DOSpec));
                    
            m_key = key;
            DataFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;
        }

        public Subscription AddSubscriber(ClientConnection cliConn, uint dwUserIndexFlags)
        {
            Subscription newSub = new Subscription(m_key, cliConn, dwUserIndexFlags);

            newSub.AddToList(m_listHead);
            m_listHead = newSub;
            m_cItems++;

            return newSub;
        }

        public void RemoveSubscriber(Subscription sub)
        {
            Subscription next = sub.RemoveFromList();
            if (m_listHead == sub)
            {
                m_listHead = next;
            }
            m_cItems--;
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return new Subscription.SubscriberListEnumerator(m_listHead);
        }
                    
    }

    public class Subscription
    {
        protected DataSubscriptionKey m_key;
        public DataSubscriptionKey Key
        {
            get
            {
                return m_key;
            }
        }
        
        protected ClientConnection m_cliConn;
        public ClientConnection CliConn
        {
            get
            {
                return m_cliConn;
            }
        }

        public uint m_dwUserIndexFlags;
        
        protected Subscription m_Prev;
        protected Subscription m_Next;

        protected XomRequestTimeElapsed m_duration = null;

        public Subscription(DataSubscriptionKey key, ClientConnection cliConn, uint dwUserIndexFlags)
        {
            m_key = key;
            m_cliConn = cliConn;
            m_dwUserIndexFlags = dwUserIndexFlags;
        }

        public void AddToList(Subscription listHead)
        {
            m_duration = new XomRequestTimeElapsed();
            XConnSrvSubscriptionCounters.Total.SubscribesPerSecond.Increment();
            XConnSrvSubscriptionCounters.Total[m_key.DOSpec.wDataType].SubscribesPerSecond.Increment();
            XConnSrvCounters.Current.NumSubscriptions.Increment();
                        
            m_Next = listHead;
            if (listHead != null)
            {
                listHead.m_Prev = this;
            }
        }

        public Subscription RemoveFromList()
        {
            XConnSrvSubscriptionCounters.Total.UnsubscribesPerSecond.Increment();
            XConnSrvSubscriptionCounters.Total[m_key.DOSpec.wDataType].UnsubscribesPerSecond.Increment();
            XConnSrvSubscriptionCounters.Total.SubscriptionDurationAvg.IncrementBy(m_duration.SecondsElapsed);
            XConnSrvSubscriptionCounters.Total[m_key.DOSpec.wDataType].SubscriptionDurationAvg.IncrementBy(m_duration.SecondsElapsed);
            XConnSrvSubscriptionCounters.Total.SubscriptionDurationAvgBase.Increment();
            XConnSrvSubscriptionCounters.Total[m_key.DOSpec.wDataType].SubscriptionDurationAvgBase.Increment();
            XConnSrvCounters.Current.NumSubscriptions.Decrement();
            
            Subscription next = m_Next;
            
            if (m_Prev != null)
            {
                m_Prev.m_Next = m_Next;
            }
            if (m_Next != null)
            {
                m_Next.m_Prev = m_Prev;
            }

            m_Prev = null;
            m_Next = null;

            return next;
        }

        public class SubscriberListEnumerator : IEnumerator
        {
            Subscription m_listHead;
            Subscription m_subCurrent;
            
            public SubscriberListEnumerator(Subscription listHead)
            {
                m_listHead = listHead;
            }

            public bool MoveNext()
            {
                m_subCurrent = (m_subCurrent == null) ? m_listHead : m_subCurrent.m_Next;
                return (m_subCurrent != null);
            }

            public void Reset()
            {
                m_subCurrent = null;
            }

            public object Current
            {
                get
                {
                    return m_subCurrent;
                }
            }
        }           
    }

    public class DataSubscriptionTable
    {
        private LookupTable m_table;

        public DataSubscriptionTable(int cBuckets)
        {
            m_table = new LookupTable(cBuckets);
        }

        public Subscription CreateSubscription(DataSubscriptionKey key, ClientConnection cliConn, uint dwUserIndexFlags)
        {
            Subscription sub = null;
            
            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(key);

            try
            {
                // get the list for this data.
                SubscriberList subscriberList = (SubscriberList)m_table.FindLookupItem(iLockToken, key);
                if (subscriberList == null)
                {
                    // no list.  make a new one.
                    subscriberList = new SubscriberList(key);

                    // add it to the table.
                    m_table.AddLookupItem(iLockToken, subscriberList);
                }

                // make a new subscription from this client.
                sub = subscriberList.AddSubscriber(cliConn, dwUserIndexFlags);
            }
            catch (Exception e)
            {
                // log the exception.
                Xom.NtEvent(XEvent.Id.XCONNSRV_EXCEPTION_WOULD_DEADLOCK, e,
                   "CreateSubscription() threw exception while holding a lock for key " 
                    + CacheUtil.GetDataKeyString(key.DOSpec) + " ."
                );

                throw;
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            // return the new subscription to the caller.            
            return sub;
        }

        public void DeleteSubscription(DataSubscriptionKey key, Subscription sub)
        {
            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(key);

            try
            {
                // get the list for this data.
                SubscriberList subscriberList = (SubscriberList)m_table.FindLookupItem(iLockToken, key);
                if (subscriberList == null)
                {
                    // no list.  nothing to delete here.
                    return;
                }

                // remove the subscription from the data.
                subscriberList.RemoveSubscriber(sub);

                if (subscriberList.Count <= 0)
                {
                    // list is empty.  no one left subscribed to this data.
                    Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_NORMAL, "Removing empty subscription list for key: " + CacheUtil.GetDataKeyString(key.DOSpec));
                    
                    m_table.RemoveLookupItem(iLockToken, subscriberList);
                }
            }
            catch (Exception e)
            {
                // log the exception.++++
                Xom.NtEvent(XEvent.Id.XCONNSRV_EXCEPTION_WOULD_DEADLOCK, e,
                   "DeleteSubscription() threw exception while holding a lock for key " 
                   + CacheUtil.GetDataKeyString(key.DOSpec) + "."
                );

                throw;
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }
        }

        public void ProcessCacheNotification(DataSubscriptionKey key, ref DataRetrievalCompletionProc callbackList)
        {
            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(key);

            try
            {
                // get the list for this data.
                SubscriberList subscriberList = (SubscriberList)m_table.FindLookupItem(iLockToken, key);

                if (subscriberList != null)
                {
                    // we have subscribers for this key.  go get the actual data.
                    callbackList += IssueDataChangeNotifications;
                }
            }
            catch (Exception e)
            {
                // log the exception.
                Xom.NtEvent(XEvent.Id.XCONNSRV_EXCEPTION_WOULD_DEADLOCK, e,
                    "ProcessCacheNotification() threw exception while holding a lock for key " 
                    + CacheUtil.GetDataKeyString(key.DOSpec) + "."
                );

                throw;
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }
        }

        public unsafe void IssueDataChangeNotifications(string sKey, byte[] rgbData, Object state)
        {            
            DataSubscriptionKey key = state as DataSubscriptionKey;

            Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_NORMAL, "Issuing notificaitions to subscribers for key: " + CacheUtil.GetDataKeyString(key.DOSpec));

            uint dwDataFlags = 0;            
            uint dwOldDataFlags = 0;
            Hashtable htLanguageCache = null;

            if ((rgbData == null) || (rgbData.Length < sizeof(BASE_DATA_HEADER)))
            {
                // bogus or no data.  assume we're being notified that the key was deleted.
                rgbData = DataUtilities.BuildEmptyHeader(key.DOSpec);

                // fake the flags to share to everyone.
                dwDataFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;
            }
            else
            {
                // check for data header flags.
                dwDataFlags = DataUtilities.GetDataFlags(rgbData);
            }
            
            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(key);

            // get the list for this data.
            SubscriberList subscriberListMaster = (SubscriberList)m_table.FindLookupItem(iLockToken, key);
            ArrayList subscriberList = null;

            // try block here to guard against leaving without unlocking.
            try
            {
                if (subscriberListMaster != null)
                {
                    // make a copy of the master list that we can iterate over without holding the lock.
                    subscriberList = new ArrayList(subscriberListMaster.Count);
                    
                    foreach (Subscription sub in subscriberListMaster)
                    {
                        subscriberList.Add(sub);
                    }

                    dwOldDataFlags = subscriberListMaster.DataFlags;
                    subscriberListMaster.DataFlags = dwDataFlags;
                }
            }
            catch (Exception e)
            {
                // log the exception.
                Xom.NtEvent(XEvent.Id.XCONNSRV_EXCEPTION_WOULD_DEADLOCK, e,
                    "IssueDataChangeNotifications() threw exception while holding a lock for key " 
                    + CacheUtil.GetDataKeyString(key.DOSpec) + "."
                );

                throw;
            }
            finally
            {
                // unlock the master list.
                m_table.UnlockItem(iLockToken);
            }

            // try block here because we're dealing with data that came from MemCache, which could be malformed.
            try
            {
                if (subscriberList != null)
                {
                    if ((dwDataFlags & CacheUtil.XONLINE_CACHE_DATA_FLAG_LANGUAGE_SPECIFIC) != 0)
                    {
                        // make a cache for languages.
                        htLanguageCache = DataUtilities.BuildLanguageSpecificCache(rgbData);
                    }
                    
                    foreach (Subscription sub in subscriberList)
                    {
                        byte[] rgbCustomData = rgbData;

                        // check language specific.
                        if (htLanguageCache != null)
                        {
                            rgbCustomData = null;
                            
                            // check language specific cache.
                            for (int iLocale = 0; iLocale < sub.CliConn.LocaleList.Length; iLocale++)
                            {
                                if (htLanguageCache[sub.CliConn.LocaleList[iLocale]] != null)
                                {
                                    rgbCustomData = (byte[])htLanguageCache[sub.CliConn.LocaleList[iLocale]];
                                    Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_LOW, "Notificaition to client " + sub.CliConn.IPAddress + " for key: " 
                                        + sKey + " adjusted for language " + sub.CliConn.LocaleList[iLocale]);
                                    
                                    break;
                                }
                            }
                            if (rgbCustomData == null)
                            {
                                // use the default language.
                                rgbCustomData = (byte[])htLanguageCache[DataUtilities.DEFAULT_LOCALE];
                                Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_LOW, "Notificaition to client " + sub.CliConn.IPAddress + " for key: " 
                                    + sKey + " adjusted for default language.");
                            }
                        }

                        // check privacy policy
                        if (!DataUtilities.IsDataAccessible(key.DOSpec.qwOwnerXUID, dwDataFlags, sub.CliConn, sub.m_dwUserIndexFlags))
                        {
                            // data is blocked to this subscriber.
                            Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_LOW, "Notification blocked to client " + sub.CliConn.IPAddress + " for key: " 
                                + sKey + " due to privacy policy.");

                            // check to see if this user was *just* blocked.
                            if (DataUtilities.IsDataAccessible(key.DOSpec.qwOwnerXUID, dwOldDataFlags, sub.CliConn, sub.m_dwUserIndexFlags))
                            {
                                Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_LOW, "Data flags just changed to block notification to client " + sub.CliConn.IPAddress + " for key: " 
                                    + sKey + ".  Sending empty data header.");
                                
                                rgbCustomData = DataUtilities.BuildEmptyHeader(key.DOSpec);
                            }
                            else
                            {
                                // skip this notification.
                                continue;
                            }
                        }

                        // check max size.
                        if (rgbCustomData.Length > sub.Key.DOSpec.wObjectSize)
                        {
                            rgbCustomData = DataUtilities.TruncateData(rgbCustomData, sub.Key.DOSpec.wObjectSize);
                        }

                        // last sanity check
                        if (rgbCustomData.Length < sizeof(BASE_DATA_HEADER))
                        {
                            // something isn't right.  dont send this to the client.
                            Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_LOW, "Notificaition blocked to client " + sub.CliConn.IPAddress + " for key: " 
                                + CacheUtil.GetDataKeyString(key.DOSpec) + " due to data size (" + rgbCustomData.Length + " < " 
                                + sizeof(BASE_DATA_HEADER) + ").");
                            
                            continue;
                        }

                        sub.CliConn.SendNotification(sub, rgbCustomData);
                    }
                }
            }
            catch (Exception e)
            {
                // log the exception.
                Xom.NtEvent(XEvent.Id.XCONNSRV_NOTIFICATION_FORMATTING_ERROR, e,
                    "IssueDataChangeNotifications() threw exception formatting a notification message for key " 
                    + CacheUtil.GetDataKeyString(key.DOSpec) + "."
                );

                throw;
            }
        }

        public string AdminShowSubscribers(string sKey)
        {
            // make a key.
            DATA_OBJECT_SPECIFIER doSpec = CacheUtil.GetDataKeyFromString(sKey);
            DataSubscriptionKey key = new DataSubscriptionKey(ref doSpec);

            StringBuilder sb = new StringBuilder();
            
            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(key);

            try
            {
                // get the list for this data.
                SubscriberList subscriberList = (SubscriberList)m_table.FindLookupItem(iLockToken, key);

                if (subscriberList != null)
                {
                    sb.AppendLine(subscriberList.Count.ToString() + " subscribers found for key " + sKey + " :");
                    
                    int iSub = 0;
                    foreach (Subscription sub in subscriberList)
                    {
                        sb.AppendLine("\t" + iSub + ": " + sub.CliConn.IPAddress + " user flags = 0x" + sub.m_dwUserIndexFlags.ToString("X"));

                        // list all users in each subscription
                        int[] rgIndices = SubNotiDefs.UserFlagsToIndices(sub.m_dwUserIndexFlags);
                        for (int iIndex = 0; iIndex < rgIndices.Length; iIndex++)
                        {
                            sb.AppendLine("\t\t" + rgIndices[iIndex] + ": " + sub.CliConn.qwUserIDs[rgIndices[iIndex]].ToString("X"));
                        }
                        
                        iSub++;
                    }
                }
                else
                {
                    sb.AppendLine("No subscription list found for key " + sKey + ".");
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            return sb.ToString();
        }

    }
    
    [XomPerformanceCounterCategoryAttr( "Connection Svc - Subscriptions", "Xbox Live Connection Server Per Subscription Type Counters" )]
    public class XConnSrvSubscriptionCounters : XomPerformanceCounterCategory
    {
        public XConnSrvSubscriptionCounters() : base(true)
        {
        }
       
        public virtual XConnSrvSubscriptionCounters this[ushort wDataType]
        {
            get
            {
                return (XConnSrvSubscriptionCounters) GetInstance(CacheUtil.DataTypeToString(wDataType));
            }
        }

        static public XConnSrvSubscriptionCounters Total = new XConnSrvSubscriptionCounters();
        
        [XomPerformanceCounterAttr(
            "Subscribes per Second", 
            "Number of subscriptions created per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SubscribesPerSecond;

        [XomPerformanceCounterAttr(
            "UnSubscribes per Second", 
            "Number of subscriptions removed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter UnsubscribesPerSecond;

        [XomPerformanceCounterAttr(
            "Notifications per Second", 
            "Number of notifications issued per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter NotificationsPerSecond;

        [XomPerformanceCounterAttr(
            "Average Subscription Duration (s)", 
            "Average time (in seconds) a subscription is active.", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter SubscriptionDurationAvg;
        
        [XomPerformanceCounterAttr(
            "Average Subscription Duration Base", 
            "Average time a subscription is active.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter SubscriptionDurationAvgBase;

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\Connection.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.ServiceProcess;
using System.Net;
using System.Net.Sockets;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

using System.Threading;
using xonline.common.config;

using MS.Msn.Messenger.Runtime;


namespace xonline.server.XConnSrv
{
    public class ClientConnection
    {
        private TcpStream m_stream = null;

        private int m_cbReceiveBuffer = 0;
        private byte[] m_rgbReceive = null;
        private int m_cbReadUsed = 0;
        private bool m_fDisconnectTriggered = false;
        private int m_cPendingSends = 0;

        public UserRequestContext m_ctxPending;

        private string m_ipAddress = null;
        public string IPAddress
        {
            get 
            {
                if (m_ipAddress == null)
                {
                    try
                    {
                        m_ipAddress = m_stream.IPAddress.ToString() + ":" + m_stream.Port.ToString();
                    }
                    catch (Exception)
                    {
                        m_ipAddress = null;
                    }
                }
                return m_ipAddress;
            }
        }

        public uint IPAddressDword
        {
            get
            {
                try
                {
                    return (uint)System.Net.IPAddress.NetworkToHostOrder((int)ConfigUtil.IpAddressToDword(m_stream.IPAddress));
                }
                catch (Exception)
                {
                    return 0;
                }
            }
        }
        public ushort IPPort
        {
            get
            {
                try
                {
                    return m_stream.Port;
                }
                catch (Exception)
                {
                    return 0;
                }
            }
        }

        private uint m_dwUserIndexFlags;
        public uint dwUserIndexFlags
        {
            get
            {
                return m_dwUserIndexFlags;
            }
        }

        private ulong[] m_qwUserIDs;
        public ulong[] qwUserIDs
        {
            get
            {
                return m_qwUserIDs;
            }
        }

        private int m_dwNotificationSeqNum;
        public uint NotificationSequenceNumber
        {
            get
            {
                return (uint)Interlocked.Increment(ref m_dwNotificationSeqNum);
            }
        }

        public SGInfo m_sginfo;

        private SGADDR m_sgaddr;
        public SGADDR SGAddr
        {
            get
            {
                if (m_sgaddr == null)
                {
                    byte[] rgbAddr = m_sginfo.SGAddr;
                    m_sgaddr = new SGADDR();
                    m_sgaddr.ReadBytes(rgbAddr);
                }
                return m_sgaddr;
            }
        }

        private string[] m_rgLocales;
        public string[] LocaleList
        {
            get
            {
                return m_rgLocales;
            }
        }

        private Hashtable m_htSubscriptions;

        private FriendsList[] m_rgFriendLists;

        ClientConnection(TcpStream stream)
        {
            m_stream = stream;
            m_cbReceiveBuffer = 2 * Config.GetIntSetting(Setting.XConnSrv_SocketBufferSize);
            m_rgbReceive = new byte[m_cbReceiveBuffer];
            m_htSubscriptions = new Hashtable();
            m_qwUserIDs = new ulong[XOn.XONLINE_MAX_LOGON_USERS];
            m_rgFriendLists = new FriendsList[m_qwUserIDs.Length];
        }
        
        public static void OnConnect(Object sender, TcpStream stream)
        {
            ClientConnection newClient = new ClientConnection(stream);
            stream.Disconnected += newClient.OnDisconnect;
            
            IAsyncResult arRead = stream.BeginRead(
                newClient.m_rgbReceive, 
                0, 
                newClient.m_cbReceiveBuffer, 
                newClient.OnRead, 
                newClient);

            Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_HIGH, "Connection from: " + newClient.IPAddress);
            XConnSrv.Instance.Log("|", "SocketConnect", newClient.IPAddress);
            XConnSrvCounters.Current.NumConnections.Increment();
            XConnSrvCounters.Current.ConnectRate.Increment();
        }

        public void OnDisconnect(TcpStream sender, Exception reason)
        {
            m_fDisconnectTriggered = true;
            XConnSrvCounters.Current.NumConnections.Decrement();

            Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_HIGH, "Disconnected client at " + IPAddress + ".  Reason: " + ((reason == null) ? "{null}" : reason.ToString()));
            XConnSrv.Instance.Log("|", "SocketDisconnect", IPAddress, reason);

            // move this to another thread so not to block the IO threads.
            ClientDisconnectContext ctx = new ClientDisconnectContext(this);
            XConnSrvEngine.QueueContext(ThreadType.eWorker, ctx, null);
        }

        public void OnRead(IAsyncResult ar)
        {
            Debug.Assert(this == (ClientConnection)ar.AsyncState);

            int cbRead = 0;

            try
            {
                // read the bytes delivered.
                cbRead = m_stream.EndRead(ar);
            }
            catch (SocketException se)
            {
                // EndRead can throw a socket exception and not disconnect.
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, IPAddress + ": " + se.ToString());
                DisconnectSocket();
                return;
            }

            // is this a disconnection?
            if (cbRead == 0)
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, IPAddress + ": read 0 bytes.");
                DisconnectSocket();
                return;
            }

            m_cbReadUsed += cbRead;

            try
            {
                // try to parse a message.
                int dwConsumed = XConnSrvEngine.ConsumeUserRequestBytes(m_rgbReceive, m_cbReadUsed, this);

                if (dwConsumed > 0)
                {
                    Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_LOW, IPAddress + ": message received ( " + dwConsumed + " bytes).");
                    
                    // shift any left over bytes
                    System.Buffer.BlockCopy(m_rgbReceive, dwConsumed, m_rgbReceive, 0, m_cbReadUsed - dwConsumed);
                    m_cbReadUsed -= dwConsumed;
                }
            }
            catch (Exception)
            {
                DisconnectSocket();
                return;
            }

            IAsyncResult arRead = m_stream.BeginRead(
                m_rgbReceive, 
                m_cbReadUsed, 
                m_cbReceiveBuffer - m_cbReadUsed, 
                OnRead, 
                this);
        }

        public void OnWrite(IAsyncResult ar)
        {
            byte[] rgbBuffer = (byte[])ar.AsyncState;

            try
            {
                m_stream.EndWrite(ar);
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_LOW, IPAddress + ": message sent.");

                XConnSrvEngine.ReturnSendBuffer(rgbBuffer);

                if ((Interlocked.Decrement(ref m_cPendingSends) <= 0) && m_fDisconnectTriggered)
                {
                    DisconnectSocket();
                }
            }
            catch (SocketException se)
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, IPAddress + ": " + se.ToString());
                DisconnectSocket();
            }
        }

        public void Disconnect()
        {
            m_fDisconnectTriggered = true;
            if (m_cPendingSends == 0)
            {
                DisconnectSocket();
            }
        }

        protected void DisconnectSocket()
        {
            Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, IPAddress + ": Disconnect() called.");

            // close the socket.
            m_stream.Close();
            m_rgbReceive = null;
            m_cbReadUsed = 0;
        }

        public void Send(byte[] rgbBuffer)
        {
            Send(rgbBuffer, rgbBuffer.Length);
        }
        public void Send(byte[] rgbBuffer, int cbSend)
        {
            if (m_fDisconnectTriggered)
            {
                // we're shutting down.  no more sends go.
                return;
            }
            
            Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_LOW, IPAddress + ": sending message (" + rgbBuffer.Length + "bytes).");

            Interlocked.Increment(ref m_cPendingSends);

            IAsyncResult arWrite = m_stream.BeginWrite(
                rgbBuffer,
                0,
                cbSend,
                OnWrite,
                rgbBuffer);
        }

        public unsafe void SendNotification(Subscription sub, byte[] rgbData)
        {
            SendNotification(sub.Key, sub.m_dwUserIndexFlags, rgbData);
        }

        public unsafe void SendNotification(DataSubscriptionKey key, uint dwUserIndexFlags, byte[] rgbData)
        {
            // build send buffer.
            int cbSend = sizeof(NOTIFICATION_MESSAGE) + rgbData.Length;
            byte[] rgbSendBuffer = XConnSrvEngine.GetSendBuffer(cbSend);
            fixed (byte *pHeader = &(rgbSendBuffer[0]))
            {
                NOTIFICATION_MESSAGE *pMessage = (NOTIFICATION_MESSAGE *)pHeader;
                pMessage->header.dwProtocolVersion = SubNotiDefs.CURRENT_PROTOCOL_VERSION;
                pMessage->header.dwMessageType = (uint)MESSAGE_TYPES.eDataNotification;
                pMessage->header.dwSeqNum = this.NotificationSequenceNumber;
                pMessage->header.dwUserIndexFlags = dwUserIndexFlags;
                pMessage->header.dwTotalSize = (uint)cbSend;
                pMessage->header.dwHeaderFlags = 0;
                pMessage->dwNumDataObjects = 1;
            }

            Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_LOW, "Issuing notificaitions to client " + this.IPAddress + " for key: " 
                + CacheUtil.GetDataKeyString(key.DOSpec));

            System.Buffer.BlockCopy(rgbData, 0, rgbSendBuffer, sizeof(NOTIFICATION_MESSAGE), rgbData.Length);

            try
            {
                Send(rgbSendBuffer, cbSend);
                
                XConnSrvSubscriptionCounters.Total.NotificationsPerSecond.Increment();
                XConnSrvSubscriptionCounters.Total[key.DOSpec.wDataType].NotificationsPerSecond.Increment();
            }
            catch (Exception)
            {
                // eat any exception here.
            }
        }

        public bool IsAcceptedFriend(ulong qwFriendID, uint dwUserFlags)
        {
            int[] rgUsers = SubNotiDefs.UserFlagsToIndices(dwUserFlags);

            lock (this)
            {
                for (int iUser = 0; iUser < rgUsers.Length; iUser++)
                {
                    if ((m_rgFriendLists[rgUsers[iUser]] != null) && (m_rgFriendLists[rgUsers[iUser]].IsAcceptedBuddy(qwFriendID)))
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        public bool KickDuplicateFromSg(SGADDR primary)
        {
            if ((this.SGAddr != null) && (primary != null) &&
                !this.SGAddr.IsEqual(primary) && (primary.inaSg != 0))
            {
                ClientKickFromSgContext ctx = new ClientKickFromSgContext(this.SGAddr);
                XConnSrvEngine.QueueContext(ThreadType.eData, ctx, null);
                return true;
            }
            return false;
        }

        public void RemoveUser(ulong qwUserID)
        {
            lock (this)
            {
                bool fUpdate = false;
                
                // make a new user array, minus this user.
                ulong[] rgNewUsers = new ulong[m_qwUserIDs.Length];
                for (int iUser = 0; iUser < rgNewUsers.Length; iUser++)
                {
                    if (m_qwUserIDs[iUser] == qwUserID)
                    {
                        // found the user to delete.  we'll actually have a change to make.
                        fUpdate = true;
                    }
                    else
                    {
                        // copy the other users to the new list.
                        rgNewUsers[iUser] = m_qwUserIDs[iUser];
                    }
                }

                if (fUpdate)
                {
                    UpdateUsers(rgNewUsers);
                }
            }
        }

        public void UpdateUsers(ulong[] qwUserIDs)
        {
            lock (this)
            {
                uint dwTeardownFlags = 0;
                ArrayList alLocales = new ArrayList();
                uint[] rgRemapUsers = new uint[m_qwUserIDs.Length];
                uint dwRemapFrom = 0;
                uint dwRemapTo = 0;

                for (int iUser = 0; iUser < m_qwUserIDs.Length; iUser++)
                {
                    if ((m_qwUserIDs[iUser] != 0) && (m_qwUserIDs[iUser] != qwUserIDs[iUser]))
                    {
                        uint dwUserFlag = (uint)(1 << iUser);
                        for(int iRemap = 0; iRemap < m_qwUserIDs.Length; iRemap++)
                        {
                            if (iUser != iRemap && qwUserIDs[iRemap] == m_qwUserIDs[iUser])
                            {
                                // TODO: Performance counter for remapped users?

                                rgRemapUsers[iUser] = (uint)iRemap;
                                dwRemapFrom |= (uint)(1 << iUser);
                                dwRemapTo |= (uint)(1 << iRemap);

                                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_HIGH, IPAddress + "Remapped user " + m_qwUserIDs[iUser].ToString("X") + " from index " + iUser + "to index " + iRemap);
                                break;
                            }
                        }
                    }
                }

                for (int iUser = 0; iUser < m_qwUserIDs.Length; iUser++)
                {
                    if (m_qwUserIDs[iUser] != qwUserIDs[iUser])
                    {
                        uint dwUserFlag = (uint)(1 << iUser);

                        if (m_qwUserIDs[iUser] != 0)
                        {
                            if ((dwRemapFrom & dwUserFlag) == 0)
                            {
                                // remove this connection from the user connections table under this user's index.
                                XConnSrv.Instance.UserConnections.RemoveUserConnection(m_qwUserIDs[iUser]);

                                // a previously connected user is changing.  tear down his subscriptions from this index.
                                dwTeardownFlags |= dwUserFlag;

                                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_HIGH, IPAddress + "Removed user " + m_qwUserIDs[iUser].ToString("X") + " from index " + iUser);
                                XConnSrvCounters.Current.NumUsers.Decrement();
                            }

                            m_dwUserIndexFlags &= ~dwUserFlag;

                            // drop this user's friends list.
                            m_rgFriendLists[iUser] = null;
                        }

                        if (!m_fDisconnectTriggered && (qwUserIDs[iUser] != 0))
                        {
                            if ((dwRemapTo & dwUserFlag) == 0)
                            {
                                // add this connection to the user connections table under this user's index.
                                XConnSrv.Instance.UserConnections.AddUserConnection(qwUserIDs[iUser], this);

                                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_HIGH, IPAddress + "Added user " + qwUserIDs[iUser].ToString("X") + " at index " + iUser);
                                XConnSrvCounters.Current.NumUsers.Increment();
                            }

                            m_dwUserIndexFlags |= dwUserFlag;
                        }
                        
                        m_qwUserIDs[iUser] = qwUserIDs[iUser];
                    }

                    if (m_qwUserIDs[iUser] != 0)
                    {
                        // rebuild the locale list.
                        string[] rgUserLocales = m_sginfo.GetUserLocaleList2(qwUserIDs[iUser], false);
                        if (rgUserLocales != null)
                        {
                            for (int iUserLocale = 0; iUserLocale < rgUserLocales.Length; iUserLocale++)
                            {
                                if (!alLocales.Contains(rgUserLocales[iUserLocale]))
                                {
                                    alLocales.Add(rgUserLocales[iUserLocale]);
                                }
                            }
                        }
                    }
                }

                if (dwRemapFrom != 0)
                {
                    RemapSubscriptions(dwRemapFrom, rgRemapUsers);
                }

                TeardownSubscriptions(dwTeardownFlags);

                m_rgLocales = (string[])alLocales.ToArray(typeof(string));
            }
        }

        protected void RemapSubscriptions(uint dwRemapFromIndexFlags, uint[] rgRemapUsers)
        {
            lock (this)
            {
                // find subscriptions to remap down.
                foreach (Subscription sub in m_htSubscriptions.Values)
                {
                    if ((sub.m_dwUserIndexFlags & dwRemapFromIndexFlags) != 0)
                    {
                        uint dwNewFlags = sub.m_dwUserIndexFlags;
                        for (int iUser = 0; iUser < rgRemapUsers.Length; ++iUser)
                        {
                            uint dwUserFlag = (uint)(1 << iUser);
                            if ((dwRemapFromIndexFlags & sub.m_dwUserIndexFlags & dwUserFlag) != 0)
                            {
                                dwNewFlags &= ~dwUserFlag;
                                dwNewFlags |= (uint)(1 << (int)rgRemapUsers[iUser]);
                            }
                        }
                        sub.m_dwUserIndexFlags = dwNewFlags;
                    }
                }
            }
        }

        protected void TeardownSubscriptions(uint dwTeardownIndexFlags)
        {
            lock (this)
            {
                // find subscriptions to tear down.
                ArrayList alTeardownSubs = new ArrayList();
                foreach (Subscription sub in m_htSubscriptions.Values)
                {
                    if ((sub.m_dwUserIndexFlags & dwTeardownIndexFlags) != 0)
                    {
                        alTeardownSubs.Add(sub);
                    }
                }

                // tear down subscriptions.
                foreach (Subscription sub in alTeardownSubs)
                {
                    RemoveSubscription(sub.Key, dwTeardownIndexFlags);
                }
            }
        }

        protected void RefreshSubscriptions(Hashtable htDataOwners)
        {
            lock (this)
            {
                BulkDataRetrievalContext dataCtx = new BulkDataRetrievalContext(RefreshSubscriptionsComplete, null);
                
                // go through all the subs.
                foreach (Subscription sub in m_htSubscriptions.Values)
                {
                    if (htDataOwners[sub.Key.DOSpec.qwOwnerXUID] != null)
                    {
                        // we have a subscription to something owned by this user.  we need to refresh it.
                        dataCtx.AddDataObject(sub.Key.DOSpec);
                    }
                }

                if (dataCtx.NumObjects > 0)
                {
                    // go get the data.
                    XConnSrvEngine.QueueContext(ThreadType.eData, dataCtx, null);
                }
            }
        }

        protected void RefreshSubscriptionsComplete(BulkDataRetrievalContext dataCtx, Object state)
        {
            lock (this)
            {
                // go through the data items returned.
                for (int iItem = 0; iItem < dataCtx.NumObjects; iItem++)
                {
                    DATA_OBJECT_SPECIFIER doSpec = dataCtx.GetItemSpecifier(iItem);
                    DataSubscriptionKey key = new DataSubscriptionKey(ref doSpec);

                    byte[] rgbItem = dataCtx.GetItemData(iItem);

                    // find our subscription to this data.
                    Subscription sub = (Subscription)m_htSubscriptions[key];
                    if (sub == null)
                    {
                        // we arent subscribed to this anymore.
                        continue;
                    }
                    
                    // do any custom formatting and store the result.
                    byte[] rgCustomData = DataUtilities.CustomizeDataForUser(rgbItem, this, sub.m_dwUserIndexFlags, sub.Key.DOSpec.wObjectSize);

                    SendNotification(sub, rgCustomData);
                }
            }
        }

        public uint NumSubscriptions
        {
            get
            {
                lock (this)
                {
                    return (uint)m_htSubscriptions.Count;
                }
            }
        }

        public void AddSubscription(ref DATA_OBJECT_SPECIFIER doSpec, uint dwUserIndexFlags)
        {
            // make a data key.
            DataSubscriptionKey key = new DataSubscriptionKey(ref doSpec);

            AddSubscription(key, dwUserIndexFlags);
        }

        protected void AddSubscription(DataSubscriptionKey key, uint dwUserIndexFlags)
        {
            lock (this)
            {
                // first check to see if we already have a subscription.
                Subscription sub = m_htSubscriptions[key] as Subscription;
                
                if (sub != null)
                {
                    // just need to add the new index flags.
                    Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_HIGH, IPAddress + ": adding user flags " + dwUserIndexFlags.ToString("X") + 
                        "to existing subscription found for key: " + CacheUtil.GetDataKeyString(key.DOSpec));

                    sub.m_dwUserIndexFlags |= dwUserIndexFlags;
                }
                else
                {
                    // need to actually create a new subscription.
                    Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_HIGH, IPAddress + ": creating new subscription mapping flags " + 
                        dwUserIndexFlags.ToString("X") + "to key: " + CacheUtil.GetDataKeyString(key.DOSpec));

                    // create the subscription.
                    sub = XConnSrv.Instance.DataSubscriptions.CreateSubscription(key, this, dwUserIndexFlags);

                    // add the subscription to the client.
                    m_htSubscriptions.Add(key, sub);
                }
            }
        }

        public void RemoveSubscription(ref DATA_OBJECT_SPECIFIER doSpec, uint dwUserIndexFlags)
        {
            // make a data key.
            DataSubscriptionKey key = new DataSubscriptionKey(ref doSpec);

            RemoveSubscription(key, dwUserIndexFlags);
        }
        
        protected void RemoveSubscription(DataSubscriptionKey key, uint dwUserIndexFlags)
        {
            lock (this)
            {
                Subscription sub = m_htSubscriptions[key] as Subscription;
                
                if (sub == null)
                {
                    // user wasnt actually subscribed.  nothing to do.
                    return;
                }

                // remove the user flags for the unsubscribers.
                Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_HIGH, IPAddress + ": removing user flags " + dwUserIndexFlags.ToString("X") + 
                    "from subscription for key: " + CacheUtil.GetDataKeyString(key.DOSpec));

                sub.m_dwUserIndexFlags &= ~dwUserIndexFlags;

                if (sub.m_dwUserIndexFlags == 0)
                {
                    // no more subscribed users.  remove the subscription from the client.
                    Xom.Trace(XomAreaName.XConnSrvSubscription, LogLevel.L_HIGH, IPAddress + ": removing client subscription for key: " + CacheUtil.GetDataKeyString(key.DOSpec));

                    // remove the subscription from the client.
                    m_htSubscriptions.Remove(key);

                    // delete the subscription from the data.
                    XConnSrv.Instance.DataSubscriptions.DeleteSubscription(key, sub);
                }
            }
        }

        public void SyncSubscriptions(Hashtable htNewSubs, uint dwUserIndexFlags)
        {
            lock (this)
            {
                // figure out what to remove.
                ArrayList alRemoveSubs = new ArrayList();
                foreach (Subscription sub in m_htSubscriptions.Values)
                {
                    object oValue = htNewSubs[sub.Key];
                    if (oValue == null)
                    {
                        alRemoveSubs.Add(sub);
                    }
                }

                foreach (Subscription sub in alRemoveSubs)
                {
                    RemoveSubscription(sub.Key, dwUserIndexFlags);
                }

                // figure out what to add.
                foreach (DictionaryEntry dict in htNewSubs)
                {
                    AddSubscription((DataSubscriptionKey)dict.Key, dwUserIndexFlags);
                }
            }
        }

        public static void ProcessCacheNotification(DataSubscriptionKey key, ref DataRetrievalCompletionProc callbackList)
        {
            ClientConnection cliConn = XConnSrv.Instance.UserConnections.FindUserConnection(key.DOSpec.qwOwnerXUID);
            if (cliConn == null)
            {
                // user not connected.
                return;
            }

            if ((CacheUtil.IsOwnerNotifyType(key.DOSpec.wDataType)) && 
                (OwnerNotifyData.ConnectionType.eConsole == OwnerNotifyData.GetConnectionTypeFromDataSubType(key.DOSpec.dwDataSubType)))
            {
                // online owners are always notified of these types.
                callbackList += cliConn.IssueOwnerNotification;
                // TODO: delete the dequeued data?
            }
            
            switch (key.DOSpec.wDataType)
            {
                case (ushort)DATA_TYPES.eFriendsList:
                case (ushort)DATA_TYPES.eConnSrvLocation:
                    // these types are used by the connection server itself.
                    callbackList += cliConn.InternalUserDataChange;
                    break;
            }
        }
        
        public unsafe void IssueOwnerNotification(string sKey, byte[] rgbData, Object state)
        {
            if ((rgbData == null) || (rgbData.Length < sizeof(BASE_DATA_HEADER)))
            {
                // bogus or no data.  assume we're being notified that the key was deleted.
                return;
            }

            DataSubscriptionKey key = state as DataSubscriptionKey;

            Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, IPAddress + "Issuing notification to owner of key: " + CacheUtil.GetDataKeyString(key.DOSpec));

            // find the owner flag.
            uint dwOwnerFlag = 0;
            for (int iIndex = 0; iIndex < m_qwUserIDs.Length; iIndex++)
            {
                if (m_qwUserIDs[iIndex] == key.DOSpec.qwOwnerXUID)
                {
                    dwOwnerFlag = SubNotiDefs.UserIndicesToFlags(new int[]{iIndex});
                    break;
                }
            }

            if (dwOwnerFlag == 0)
            {
                // owner no longer here?
                return;
            }

            byte[] rgbCustomData = DataUtilities.CustomizeDataForUser(rgbData, this, dwOwnerFlag, (ushort)rgbData.Length);

            this.SendNotification(key, dwOwnerFlag, rgbCustomData);
        }
        
        public void InternalUserDataChange(string sKey, byte[] rgbData, Object state)
        {
            DataSubscriptionKey key = state as DataSubscriptionKey;

            Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_HIGH, IPAddress + "Internal data change: " + CacheUtil.GetDataKeyString(key.DOSpec));

            switch (key.DOSpec.wDataType)
            {
            case (ushort)DATA_TYPES.eConnSrvLocation:
                HandleSigninLocationChange(key, rgbData);
                break;

            case (ushort)DATA_TYPES.eFriendsList:
                HandleFriendsListChange(key, rgbData);
                break;
            }
        }

        public unsafe void HandleSigninLocationChange(DataSubscriptionKey key, byte[] rgbData)
        {
            bool fKickUser = false;
            ConnSrvLocation location = (ConnSrvLocation)CacheUtil.ReadCacheItemFromBytes(rgbData);
            
            if (location == null)
            {
                // bogus or no data.  assume we're being notified that the key was deleted.  why would this happen while we are connected?
                fKickUser = true;

                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, IPAddress + " Signin location for user " + key.DOSpec.qwOwnerXUID.ToString("X") 
                    + " deleted.  Kicking user.");
            }
            else
            {
                try
                {
                    if (location.dwServerIP != (uint)System.Net.IPAddress.NetworkToHostOrder((int)XConnSrv.Instance.LocalInterfaceInfo.IPAddressDword))
                    {
                        // this isn't us.  kick the local connection.
                        fKickUser = true;

                        Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, IPAddress + " Signin location for user " + key.DOSpec.qwOwnerXUID.ToString("X") 
                            + " changed to server " + location.sServerName);
                    }
                }
                catch (Exception)
                {
                    // anything bad with the data blob for this user means we kick him.
                    fKickUser = true;

                    // TODO: throw an event here?
                }
            }

            if (fKickUser)
            {
                if ((location != null) && KickDuplicateFromSg(location.extension.sgaddr))
                {
                    // kicked from the SG, so no reason to keep the old conneciton at all.
                    Disconnect();
                }
                else
                {
                    RemoveUser(key.DOSpec.qwOwnerXUID);
                }
            }
        }

        public unsafe void HandleFriendsListChange(DataSubscriptionKey key, byte[] rgbData)
        {
            FriendsList newFriends = (FriendsList)CacheUtil.ReadCacheItemFromBytes(rgbData);
            
            lock (this)
            {
                // find the user this friends list belongs to.
                for (int iUser = 0; iUser < m_qwUserIDs.Length; iUser++)
                {
                    if (m_qwUserIDs[iUser] == key.DOSpec.qwOwnerXUID)
                    {
                        // diff the lists in case we need to refresh any subscriptions.
                        Hashtable htFriendDiffs = FriendComparer.DiffFriendsLists(m_rgFriendLists[iUser], newFriends);

                        RefreshSubscriptions(htFriendDiffs);
                        
                        // update the friends list.
                        m_rgFriendLists[iUser] = newFriends;

                        break;
                    }
                }
            }
        }

        public static string AdminShowConnectionInfo(ulong qwUserID)
        {
            ClientConnection cliConn = XConnSrv.Instance.UserConnections.FindUserConnection(qwUserID);
            if (cliConn == null)
            {
                return MemCache.AdminShowUserLocation(qwUserID);
            }

            lock (cliConn)
            {
                StringBuilder sb = new StringBuilder();
                
                sb.AppendLine("Connection found for user: " + qwUserID.ToString("X"));
                sb.AppendLine("Client Address: " + cliConn.IPAddress);

                sb.AppendLine("");
                sb.AppendLine("User Index Flags: " + cliConn.dwUserIndexFlags.ToString("X"));           
                sb.AppendLine("Connected users:");
                for (int iUser = 0; iUser < cliConn.qwUserIDs.Length; iUser++)
                {
                    sb.AppendLine("\t" + iUser +" (" + ((uint)(1 << iUser)).ToString("X") +"): " + cliConn.qwUserIDs[iUser].ToString("X"));
                }

                sb.AppendLine("");
                sb.AppendLine("Subscriptions:");
                int iSub = 0;
                foreach (Subscription sub in cliConn.m_htSubscriptions.Values)
                {
                    sb.AppendLine("\t" + iSub + " (" + sub.m_dwUserIndexFlags.ToString("X") + "): " 
                        + CacheUtil.GetDataKeyString(sub.Key.DOSpec));
                    iSub++;
                }

                return sb.ToString();
            }
        }

        public static string AdminShowFriends(ulong qwUserID)
        {
            ClientConnection cliConn = XConnSrv.Instance.UserConnections.FindUserConnection(qwUserID);
            if (cliConn == null)
            {
                return MemCache.AdminShowUserLocation(qwUserID);
            }

            lock (cliConn)
            {
                FriendsList friends = null;
                for (int iUser = 0; iUser < cliConn.qwUserIDs.Length; iUser++)
                {
                    if (cliConn.qwUserIDs[iUser] == qwUserID)
                    {
                         friends = cliConn.m_rgFriendLists[iUser];
                         break;
                    }
                }
                
                if (friends == null)
                {
                    return "No friends list found for user: " + qwUserID.ToString("X") + "\r\n";
                }
                
                StringBuilder sb = new StringBuilder();

                sb.AppendLine(friends.rgUsers.Length + " friends found for user: " + qwUserID.ToString("X"));
                sb.AppendLine("");
                for (int iFriend = 0; iFriend < friends.rgUsers.Length; iFriend++)
                {
                    sb.AppendLine("\t" + iFriend +": " + friends.rgUsers[iFriend].qwXUID.ToString("X") + ", status = " + CacheUtil.GetFriendStatus(friends.rgUsers[iFriend].dwUserFlags));
                }

                return sb.ToString();
           }
        }
        
        public static string AdminShowSGInfo(ulong qwUserID)
        {
            ClientConnection cliConn = XConnSrv.Instance.UserConnections.FindUserConnection(qwUserID);
            if (cliConn == null)
            {
                return MemCache.AdminShowUserLocation(qwUserID);
            }

            return "SGInfo for user " + qwUserID.ToString("X") + ":\r\n" + cliConn.m_sginfo.ToString() + "\r\n";
        }
    }

    public class ClientKickFromSgContext : XConnSrvContext
    {
        private SGADDR m_sgaddr;

        public ClientKickFromSgContext(SGADDR sgaddr)
        {
            m_sgaddr = sgaddr;
        }

        public override void ProcessInternal(Object state)
        {
            if (m_sgaddr != null)
            {
                SGComm.SendKick(m_sgaddr);
            }
        }
    }

    public class ClientDisconnectContext : XConnSrvContext
    {
        private ClientConnection m_cliConn;
        
        public ClientDisconnectContext(ClientConnection cliConn)
        {
            m_cliConn = cliConn;
        }

        public override void ProcessInternal(Object state)
        {
            // log out everyone, remove subs, etc.
            m_cliConn.UpdateUsers(new ulong[m_cliConn.qwUserIDs.Length]);
        }
    }

    public class UserConnectionTableContainer : ILookupTableItem
    {
        protected ulong m_qwUserID;
        Object ILookupTableItem.Key
        {
            get
            {
                return (Object)m_qwUserID;
            }
        }

        protected ILookupTableItem m_next;
        ILookupTableItem ILookupTableItem.Next
        {
            get
            {
                return m_next;
            }
            set
            {
                m_next = value;
            }
        }

        protected ClientConnection m_cliConn;
        public ClientConnection CliConn
        {
            get
            {
                return m_cliConn;
            }
        }

        public UserConnectionTableContainer(ulong qwUserID, ClientConnection cliConn)
        {
            m_qwUserID = qwUserID;
            m_cliConn = cliConn;
        }
    }

    public class UserConnectionTable
    {
        private LookupTable m_table;

        public UserConnectionTable(int cBuckets)
        {
            m_table = new LookupTable(cBuckets);
        }

        public void AddUserConnection(ulong qwUserID, ClientConnection cliConn)
        {
            UserConnectionTableContainer container = null;
            int iLockToken;

            // check for duplicate login on this server.
            while (true)
            {
                // lock the bucket.
                iLockToken = m_table.LockItemByKey(qwUserID);

                try
                {
                    // find the value at this key.
                    container = (UserConnectionTableContainer)m_table.FindLookupItem(iLockToken, qwUserID);
                }
                catch (Exception e)
                {
                    // log the exception.
                    Xom.NtEvent(XEvent.Id.XCONNSRV_EXCEPTION_WOULD_DEADLOCK, e,
                        "AddUserConnection() threw exception while holding a lock for user " 
                        + qwUserID.ToString("X") + " .  ");
                    throw;
                }
                finally
                {
                    m_table.UnlockItem(iLockToken);
                }

                if (container == null)
                {
                    // no duplicate found.
                    break;
                }
                
                // already a connection for this user?  need to remove him from that connection first.
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, cliConn.IPAddress + " Duplicate user " + qwUserID.ToString("X") + " found on connection " 
                    + container.CliConn.IPAddress);

                if (container.CliConn.KickDuplicateFromSg(cliConn.SGAddr))
                {
                    // kicked from the SG, so no reason to keep the old conneciton at all.
                    // remove all users from the connection to make sure we exit this loop immediately.  then disconnect the socket.
                    container.CliConn.UpdateUsers(new ulong[container.CliConn.qwUserIDs.Length]);
                    container.CliConn.Disconnect();
                }
                else
                {
                    // this results in a call to RemoveUserConnection(qwUserID)
                    container.CliConn.RemoveUser(qwUserID);
                }
            }
            
            // reqcquire the lock.
            iLockToken = m_table.LockItemByKey(qwUserID);

            try
            {
                // make a new container.
                container = new UserConnectionTableContainer(qwUserID, cliConn);
                
                // add this connection to the table.
                m_table.AddLookupItem(iLockToken, container);

                // write the location blob to memcache.
                DATA_OBJECT_SPECIFIER doSpec = new DATA_OBJECT_SPECIFIER();
                doSpec.wDataType = (ushort)DATA_TYPES.eConnSrvLocation;
                doSpec.qwOwnerXUID = qwUserID;
                byte[] rgbLocationData = DataUtilities.BuildLocationData(qwUserID, cliConn.IPAddressDword, cliConn.IPPort, cliConn.SGAddr);
                DataPublishContext ctx = new DataPublishContext(CacheUtil.GetDataKeyString(ref doSpec), rgbLocationData);
                XConnSrvEngine.QueueContext(ThreadType.eData, ctx, null);
            }
            catch (Exception e)
            {
                // log the exception.
                Xom.NtEvent(XEvent.Id.XCONNSRV_EXCEPTION_WOULD_DEADLOCK, e,
                  "AddUserConnection() threw exception while holding a lock for user " 
                    + qwUserID.ToString("X") + " .  ");
                throw;
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }
        }

        public ClientConnection FindUserConnection(ulong qwUserID)
        {
            UserConnectionTableContainer container = null;
            
            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(qwUserID);

            try
            {
                // find the value at this key.
                container = (UserConnectionTableContainer)m_table.FindLookupItem(iLockToken, qwUserID);
            }
            catch (Exception e)
            {
                // log the exception.
                Xom.NtEvent(XEvent.Id.XCONNSRV_EXCEPTION_WOULD_DEADLOCK, e,
                  "RemoveUserConnection() threw exception while holding a lock for user " 
                    + qwUserID.ToString("X") + " .  ");
                throw;
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            return (container == null) ? null : container.CliConn;
        }
        
        public void RemoveUserConnection(ulong qwUserID)
        {
            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(qwUserID);

            try
            {
                // find the value at this key.
                UserConnectionTableContainer container = (UserConnectionTableContainer)m_table.FindLookupItem(iLockToken, qwUserID);

                if (container != null)
                {
                    // remove the item from this bucket.
                    m_table.RemoveLookupItem(iLockToken, container);
                }
            }
            catch (Exception e)
            {
                // log the exception.
                Xom.NtEvent(XEvent.Id.XCONNSRV_EXCEPTION_WOULD_DEADLOCK, e,
                  "RemoveUserConnection() threw exception while holding a lock for user " 
                    + qwUserID.ToString("X") + " .  "
                );
                throw;
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }
        }
    }    
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\ProjectInstaller.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.service;

[RunInstallerAttribute(true)]
public class ProjectInstaller: System.Configuration.Install.Installer
{

    private ServiceInstaller serviceInstaller;
    private ServiceProcessInstaller processInstaller;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public ProjectInstaller()
        {
            // This call is required by the Designer.
            InitializeComponent();
        }

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }


 #region Component Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            processInstaller = new ServiceProcessInstaller();
            serviceInstaller = new ServiceInstaller();
          

#if (DEV_TEST)
            processInstaller.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
#else
            IComponentInfo compInfo = Config.GetComponent(xonline.common.config.Component.XConnSrv);

            LSAUtil.GrantLogonRights( compInfo.Username );

            processInstaller.Account = System.ServiceProcess.ServiceAccount.User;
            processInstaller.Username = compInfo.Username;

            CSetupSecureResolver decoder = new CSetupSecureResolver();
            processInstaller.Password = decoder.UserSecret(compInfo.Password);
#endif
  
            serviceInstaller.ServiceName = "XConnSrv";
            serviceInstaller.DisplayName = "Xbox Live Connection Server";
            serviceInstaller.Description = "Subscription/Notification service for Xbox Live connections";
            serviceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
            serviceInstaller.Committed += new System.Configuration.Install.InstallEventHandler(this.XConnSrv_Committed);

            Installers.Add(serviceInstaller);
            Installers.Add(processInstaller);

            }
#endregion

    private void XConnSrv_Committed(object sender, System.Configuration.Install.InstallEventArgs e)
    {
        System.ServiceProcess.ServiceController svc = new System.ServiceProcess.ServiceController("XConnSrv");
        svc.Start();
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\msgr\interop.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;

namespace MS.Msn.Messenger.Runtime
{

    /// <summary>
    /// Some of the imports from Kernel32
    /// </summary>
    internal class Kernel32
    {
        static public IntPtr INVALID_HANDLE_VALUE = (IntPtr)(-1);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 GetQueuedCompletionStatus(
            IntPtr CompletionPort,
            ref Int32 lpNumberOfBytes,
            ref Int32 lpCompletionKey,
            ref IntPtr lpOverlapped,
            Int32 dwMilliseconds
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 PostQueuedCompletionStatus(
            IntPtr CompletionPort,
            Int32 NumberOfBytes,
            Int32 CompletionKey,
            IntPtr lpOverlapped
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 ReadFile(
            IntPtr hFile,
            IntPtr lpBuffer,
            Int32 nNumberOfBytesToRead,
            IntPtr lpNumberOfBytesRead,
            IntPtr lpOverlapped
            );


        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 DuplicateHandle(
            IntPtr hSourceProcessHandle,
            IntPtr hSourceHandle,
            IntPtr hTargetProcessHandle,
            ref IntPtr lpTargetHandle,
            Int32 dwDesiredAccess,
            Int32 bInheritHandle,
            Int32 dwOptions
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 CloseHandle(
            IntPtr hHandle
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr CreateIoCompletionPort(
            IntPtr FileHandle,
            IntPtr ExistingCompletionPort,
            IntPtr CompletionKey,
            Int32 NumberOfConcurrentThreads
            );

        [DllImport("kernel32.dll", EntryPoint = "RtlZeroMemory", SetLastError = true)]
        public static extern void ZeroMemory(
            IntPtr Destination,
            IntPtr Length
            );

        [DllImport("kernel32.dll")]
        public static extern uint GetTickCount();
    }

    /// <summary>
    /// Some of the imports from Winsock
    /// </summary>
    internal class Winsock
    {
        public const int WSA_FLAG_OVERLAPPED = 1;

        [DllImport("ws2_32.dll", EntryPoint = "WSASocketW", SetLastError = true)]
        public static extern IntPtr WSASocket(
            AddressFamily af,
            SocketType type,
            ProtocolType protocol,
            IntPtr lpProtocolInfo,
            int g,
            int dwFlags
            );


        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref Int32 buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref byte buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int getsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref Int32 buffer,
            ref Int32 bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref IntPtr buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int bind(
            IntPtr socket,
            ref sockaddr_in sockaddr,
            int size
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int listen(
            IntPtr socket,
            int backlog
            );

        [DllImport("mswsock.dll", SetLastError = true)]
        public static extern bool AcceptEx(
            IntPtr listenSocket,
            IntPtr acceptSocket,
            IntPtr outputBuffer,
            int receiveDataLength,
            int localAddressLength,
            int remoteAddressLength,
            ref int bytesReceived,
            IntPtr overlapped
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int shutdown(
            IntPtr socket
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int closesocket(
            IntPtr socket
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSARecv(
            IntPtr socket,
            ref WSABUF buf,
            int count,
            ref int readCount,
            ref int flags,
            IntPtr overlapped,
            IntPtr expectNULL
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSASend(
            IntPtr socket,
            ref WSABUF buf,
            int count,
            ref int writeCount,
            int flags,
            IntPtr  overlapped,
            IntPtr expectNULL
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSAGetOverlappedResult(
            IntPtr socket,
            IntPtr overlapped,
            ref int transferedBytes,
            int fWait,
            ref int flags
            );


        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSAIoctl(
            IntPtr socket,
            IOControlCode ioControlCode,
            IntPtr inBuffer,
            int cbInBuffer,
            IntPtr outBuffer,
            int cbOutBuffer,
            ref int bytesReturned,
            IntPtr overlapped,
            IntPtr completionRoutine
            );

        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int getsockname(
            IntPtr socket,
            IntPtr buffer,
            ref int addrSize
            );

        // We use sockaddr_in here in place of sockaddr (these are equivalent)
        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int getpeername(
            IntPtr socket,
            ref sockaddr_in addr,
            ref int addrSize
            );

        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int WSAStartup(
            UInt16 wVersionRequested,
            ref WSADATA lpWSAData
            );


        [StructLayout(LayoutKind.Sequential)]
        public struct tcp_keepalive
        {
            public uint onOff;
            public uint keepAliveTime;
            public uint keepAliveInterval;
        };

        [StructLayout(LayoutKind.Sequential)]
        public struct WSADATA
        {
            ushort wVersion;
            ushort wHighVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256 + 1)]
            byte[] szDescription;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128 + 1)]
            byte[] szSystemStatus;
            ushort iMaxSockets;
            ushort iMaxUdpDg;
            public IntPtr lpVendorInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WSABUF
        {
            public Int32 len;
            public IntPtr buf;
        };

        // Structures "sockaddr_in" and "sockaddr" are interchangeable in API. They
        // represent a different way to access for the same layout. We choose to
        // use sockaddr_in in some APIs that call for sockaddr.
        [StructLayout(LayoutKind.Sequential)]
        public struct sockaddr_in
        {
            public short sin_family;
            public ushort port;
            public int address;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            public byte[] zeroes;

            public ushort sin_port
            {
                get { return (ushort)(((((ushort)port) & 0xFF) << 8) | (((ushort)port) >> 8)); }
            }

            public sockaddr_in(int address, int port)
            {
                sin_family = 2 /* AF_INET*/;
                this.port = (ushort)(((((ushort)port) & 0xFF) << 8) | (((ushort)port) >> 8));
                byte[] bytes = BitConverter.GetBytes(address);
                this.address = address;
                zeroes = new byte[8];
            }

            // Marshal.* makes a linkdemand which is not required by this function
            // This is ok as we are not shipping this dll for use by any other applications other than
            // messenger.  So the FXCOP warning here is not applicable.

            internal static readonly int Size = Marshal.SizeOf(new sockaddr_in());
        };

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\msgr\SocketLayer.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;

using xonline.common.mgmt;

namespace MS.Msn.Messenger.Runtime
{

    /// <summary>
    /// Called when a new socket has been accepted.
    /// </summary>
    /// <param name="acceptedSocketIndex"></param>
    /// <param name="error"></param>
    public delegate void AcceptCallback(int acceptedSocketIndex, SocketError error);

    /// <summary>
    /// Called when a read has been performed.
    /// </summary>
    /// <param name="socketIndex"></param>
    /// <param name="error"></param>
    /// <param name="buffer"></param>
    /// <param name="offset"></param>
    /// <param name="bytes"></param>
    public delegate void ReadCallback(int socketIndex, SocketError error, IntPtr buffer, int offset, int bytes);

    /// <summary>
    /// Called when a write has been performed.
    /// </summary>
    /// <param name="socketIndex"></param>
    /// <param name="error"></param>
    public delegate void WriteCallback(int socketIndex, SocketError error);

    /// <summary>
    /// Exception in the socket handling code.
    /// </summary>
    public class MySocketException : ApplicationException
    {
        /// <summary>
        ///
        /// </summary>
        public MySocketException() { }

        /// <summary>
        ///
        /// </summary>
        /// <param name="error"></param>
        public MySocketException(int error) : base("", new SocketException(error)) { }

        /// <summary>
        ///
        /// </summary>
        /// <param name="message"></param>
        public MySocketException(string message) : base(message) { }
    }


    internal struct MySocket
    {
        // The index into the SocketLayer.sockets array is composed of two
        // parts: the lower 24 bits indicate the actual array index (also
        // referred to as the 'realIndex'), while the upper 8 bits will
        // be incremented sequentially with every reuse of MySocket.
        // This compound number is return to TcpConnectionListener and
        // stored in TxpConnectionUsingSocketLayer.

        internal const int indexBits = 24;
        internal const int indexMask = 0xFFFFFF;
        internal int index;

        internal int nextFree;
        internal IntPtr sock;

        internal bool boundToIoPort;

        internal IntPtr readOverlappedPtr;
        internal IntPtr writeOverlappedPtr;
        internal IntPtr acceptOverlappedPtr;

        ReadCallback onRead;
        WriteCallback onWrite;
        AcceptCallback onAccept;

        int acceptSockIndex;

        IntPtr readBuffer;
        int readBufferSize;
        IntPtr writeBuffer;
        int writeBufferSize;
        int bytesToWrite;
        int bytesWritten;
        object syncObject;

        void Clear()
        { 
            bytesWritten = bytesToWrite = 0;
            onAccept = null;
            onRead = null;
            onWrite = null;
            acceptSockIndex = -1;
        }

        internal static void ClearOverlapped(IntPtr overlappedPtr)
        {
            Kernel32.ZeroMemory(overlappedPtr, (IntPtr)MyOverlapped.Size);
        }

        internal void VerifyIndex(int realIndex)
        {
            if (index != realIndex)
            {
                throw new ObjectDisposedException(
                    String.Format(
                    "Socket {0} must have been cleared out because current index at that slot = {1}.",
                    realIndex, index));
            }
        }


        void OnWrite(SocketError error)
        {
            WriteCallback writeCallback = onWrite;
            if (writeCallback != null)
            {
                writeCallback(index, error);
            }
        }


        bool OperationPending(int error)
        {
            return error == (int)SocketError.InProgress ||
                error == (int)SocketError.IOPending ||
                error == 996 /* ERROR_IO_INCOMPLETE */;
        }

        private void GetPeerIpAddress()
        {
            if (this.ipaddress == null)
            {
                Winsock.sockaddr_in addr = new Winsock.sockaddr_in();
                int addrSize = Winsock.sockaddr_in.Size;

                // An alternative to getpeername() is GetAcceptExSockaddrs(). However,
                // the latter is typically invoked right after AcceptEx(), at which point
                // the socket is not yet completely connected (it will be in IOPending
                // state). It could be because the "on accept" callback must complete
                // first.
                //
                // Attempts to execute getpeername() right after accept were not successful
                // with error codes indicating "not connected" (yet).
                if (Winsock.getpeername(this.sock, ref addr, ref addrSize) == 0)
                {
                    try
                    {
                        Int64 address = 0x00000000FFFFFFFF & Convert.ToInt64(addr.address);
                        this.ipaddress = new IPAddress(address);
                        this.port = addr.sin_port;
                    }
                    catch (Exception)
                    {
                        this.ipaddress = IPAddress.None;
                        this.port = 0;
                    }
                }
                else
                {
                    this.ipaddress = IPAddress.None;
                    this.port = 0;
                }
            }
        }

        internal int Initialize(int newIndex, IntPtr sock, IntPtr readBuffer, int readBufferSize, IntPtr writeBuffer, int writeBufferSize, IntPtr overlappedBuffers)
        {
            Clear();
            if (null == syncObject) syncObject = new Object();
            index = (((index >> indexBits) + 1) << indexBits) + newIndex;
            this.sock = sock;
            this.readBuffer = readBuffer;
            this.readBufferSize = readBufferSize;
            this.writeBuffer = writeBuffer;
            this.writeBufferSize = writeBufferSize;
            this.readOverlappedPtr = overlappedBuffers;
            this.writeOverlappedPtr = AddOffset(overlappedBuffers, MyOverlapped.Size);
            this.acceptOverlappedPtr = AddOffset(overlappedBuffers, MyOverlapped.Size * 2);
            this.ipaddress = null;
            this.port = 0;

            return index;
        }

        static internal IntPtr AddOffset(IntPtr baseAddress, int offset)
        {
            if (offset == 0) return baseAddress;
            return (IntPtr)(baseAddress.ToInt64() + offset);
        }

        internal bool Close(int socketIndex, bool clearIndex)
        {
            bool closedSocket = false;
            bool clearedIndex = false;

            lock (syncObject)
            {
                if (index == socketIndex)
                {
                    if (sock != Kernel32.INVALID_HANDLE_VALUE)
                    {
                        Winsock.shutdown(sock);
                        Winsock.closesocket(sock);
                        sock = Kernel32.INVALID_HANDLE_VALUE;
                        boundToIoPort = false;
                        closedSocket = true;
                    }

                    if (clearIndex)
                    {
                        index &= ~indexMask;
                        clearedIndex = true;
                    }

                    Clear();
                }
            }

            if (closedSocket) 
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionClosed(" + socketIndex.ToString() +")");

            return clearedIndex;
        }

        internal SocketError PostAccept(int socketIndex, IntPtr acceptSocket, int acceptSocketIndex, AcceptCallback acceptCallback)
        {
            SocketError result;

            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (HasOutstandingIO())
                {
                    return SocketError.AlreadyInProgress;
                }

                onAccept = acceptCallback;
                acceptSockIndex = acceptSocketIndex;
                int bytesReceived = 0; // don't care about this.

                ClearOverlapped(acceptOverlappedPtr);
                bool succeeded = Winsock.AcceptEx(
                    sock, acceptSocket, readBuffer, 0,
                    Winsock.sockaddr_in.Size + 16,
                    Winsock.sockaddr_in.Size + 16,
                    ref bytesReceived,
                    acceptOverlappedPtr
                    );
                result = ProcessResult(succeeded);
            }

            // $BUGBUG: should we call OnAccept if operation failed?

            return result;
        }

        internal SocketError PostRead(int socketIndex, ReadCallback readCallback)
        {
            SocketError result;

            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (onRead != null)
                {
                    return SocketError.AlreadyInProgress;
                }

                this.GetPeerIpAddress();

                int bytes = 0;
                int flags = 0;
                Winsock.WSABUF buf;

                buf.buf = readBuffer;
                buf.len = readBufferSize;

                onRead = readCallback;
                ClearOverlapped(readOverlappedPtr);

                bool succeeded = (-1 != Winsock.WSARecv(sock, ref buf, 1, ref bytes, ref flags, readOverlappedPtr, IntPtr.Zero));
                result = ProcessResult(succeeded);
            }

            // $BUGBUG: should we call OnRead if operation failed?

            return result;
        }

        SocketError PostWriteNoStateCheck(int socketIndex, int bufferOffset, int bytesToWrite)
        {
            int bytes = 0;
            int flags = 0;
            Winsock.WSABUF buf;
            SocketError result;

            lock (syncObject)
            {
                if (socketIndex != index) return SocketError.NotConnected;

                buf.buf = AddOffset(writeBuffer, bufferOffset);
                buf.len = bytesToWrite;

                ClearOverlapped(writeOverlappedPtr);

                bool succeeded = (-1 != Winsock.WSASend(sock, ref buf, 1, ref bytes, flags, writeOverlappedPtr, IntPtr.Zero));
                result = ProcessResult(succeeded);
            }

            if (result != SocketError.Success)
            {
                OnWrite(result);
            }

            return result;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        internal SocketError PostWrite(int socketIndex, byte[] buffer, int offset, int bytesToWrite, WriteCallback writeCallback)
        {
            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (onWrite != null)
                {
                    return SocketError.AlreadyInProgress;
                }

                if (this.bytesToWrite + bytesToWrite > writeBufferSize)
                {
                    throw new MySocketException((int)SocketError.MessageSize);
                }

                onWrite = writeCallback;

                Marshal.Copy(buffer, offset, (IntPtr)(writeBuffer.ToInt64() + this.bytesToWrite), bytesToWrite);

                this.bytesToWrite += bytesToWrite;
            }

            if(writeCallback != null)
            {
                return PostWriteNoStateCheck(socketIndex, 0, bytesToWrite);
            }

            return SocketError.Success;
        }

        bool AcceptCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            AcceptCallback acceptCallback = null;
            int acceptSocketIndex = -1;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                acceptSocketIndex = acceptSockIndex;
                acceptCallback = onAccept;

                if (acceptCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, acceptOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    completed = true;
                }

                if (completed)
                {
                    onAccept = null;
                    acceptSockIndex = -1;
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(acceptSocketIndex, false);
                acceptCallback(acceptSocketIndex, socketError);
                return true;
            }

            return false;
        }

        bool WriteCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            bool partialWrite = false;
            WriteCallback writeCallback = null;
            int partialWriteOffset = 0;
            int partialWriteCount = 0;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                writeCallback = onWrite;

                if (writeCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, writeOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    bytesWritten += bytesCount;
                    if (bytesToWrite == bytesWritten)
                    {
                        bytesToWrite = bytesWritten = 0;
                        onWrite = null;
                        completed = true;
                    }
                    else
                    {
                        partialWrite = true;
                        partialWriteOffset = bytesWritten;
                        partialWriteCount = bytesToWrite - bytesWritten;
                    }
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(socketIndex, false);
                writeCallback(socketIndex, socketError);
                return true;
            }

            if (partialWrite)
            {
                //
                // Partial write? Schedule the rest of it.
                //

                PostWriteNoStateCheck(socketIndex, partialWriteOffset, partialWriteCount);
                return true;
            }

            return false;
        }

        bool ReadCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            ReadCallback readCallback = null;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                readCallback = onRead;

                if (readCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, readOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    onRead = null;
                    completed = true;
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(socketIndex, false);
                readCallback(index, socketError, readBuffer, 0, bytesCount);
                return true;
            }

            return false;
        }

        internal void OnCompletion(int index, IntPtr overlappedPtr)
        {
            if (sock == Kernel32.INVALID_HANDLE_VALUE)
            {
                // we have already closed the socket, so we just ignore all the 
                // completion notification for this socket.

                if (overlappedPtr == acceptOverlappedPtr)
                {
                    onAccept = null;
                    return;
                }

                if (overlappedPtr == writeOverlappedPtr)
                {
                    onWrite = null;
                    return;
                }

                if (overlappedPtr == readOverlappedPtr)
                {
                    onRead = null;
                    return;
                }
            }

            //
            // Check if accept got done
            //

            if (overlappedPtr == acceptOverlappedPtr && AcceptCompleted(index)) return;

            //
            // Check if write got done.
            //

            if (overlappedPtr == writeOverlappedPtr && WriteCompleted(index)) return;

            //
            // Check if read got done
            //

            if (overlappedPtr == readOverlappedPtr && ReadCompleted(index)) return;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        SocketError ProcessResult(bool succeeded)
        {
            SocketError result = SocketError.Success;
            if (!succeeded)
            {
                result = (SocketError)Marshal.GetLastWin32Error();
                if (result == SocketError.IOPending)
                {
                    result = SocketError.Success;
                }
                else
                {
                    Close(index, false);
                }
            }

            return result;
        }

        bool HasOutstandingIO()
        {
            return (onAccept != null || onRead != null || onWrite != null);
        }

        private IPAddress ipaddress;
        private ushort port;

        internal IPAddress IPAddress
        {
            get
            {
                return this.ipaddress;
            }
        }
        internal ushort Port
        {
            get
            {
                return this.port;
            }
        }
    }

    /// <summary>
    /// Helper structure with the only purpose being size computation
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct MyOverlapped
    {
        public IntPtr Internal;
        public IntPtr InternalHigh;
        public Int32 Dword;
        public Int32 DwordHigh;
        public IntPtr EventHandle;

        internal static readonly MyOverlapped overlappedZero = new MyOverlapped();

        // Marshal.* makes a linkdemand which is not required by this function
        // This is ok as we are not shipping this dll for use by any other applications other than
        // messenger.  So the FXCOP warning here is not applicable.

        internal static readonly int Size = Marshal.SizeOf(overlappedZero); //IntPtr.Size *3 + 4*2; // sizeof (OVERLAPPED)
    };


    /// <summary>
    /// SocketLayer implementation
    /// </summary>
    public class SocketLayer
    {
        private const int MaxThreads = 2;
        private const int NumberOfInternalSocket = 1;

        MySocket[] sockets;
        IntPtr readBuffers;
        IntPtr writeBuffers;
        IntPtr overlappedBuffers;
        int readBufferSize;
        int writeBufferSize;
        uint tcpKeepAliveTimeout;
        int firstFree;
        int count;
        int lastFree;
        object syncRoot = new Object();
        IntPtr[] ioPorts;
        IntPtr listenIoPort = Kernel32.INVALID_HANDLE_VALUE;
        Thread[] workerThreads;
        Thread[] listenerThreads;
        private int unhandledSocketExceptionCount;
        private int unhandledUnmanagedExceptionCount;

        private int GetRealIndex(int index)
        {
            int newIndex = (index & MySocket.indexMask);
            sockets[newIndex].VerifyIndex(index);

            return newIndex;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="maxSockets"></param>
        /// <param name="readBufferSize"></param>
        /// <param name="writeBufferSize"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public SocketLayer(int maxSockets, int readBufferSize, int writeBufferSize, uint tcpKeepAliveTimeout)
            : this(maxSockets + SocketLayer.NumberOfInternalSocket, readBufferSize, writeBufferSize, tcpKeepAliveTimeout, SocketLayer.MaxThreads)
        {
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="maxSockets"></param>
        /// <param name="readBufferSize"></param>
        /// <param name="writeBufferSize"></param>
        /// <param name="threads"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        private SocketLayer(int maxSockets, int readBufferSize, int writeBufferSize, uint tcpKeepAliveTimeout, int threads)
        {
            Debug.Assert(writeBufferSize >= readBufferSize);

            sockets = new MySocket[maxSockets];

            readBuffers = Marshal.AllocHGlobal(readBufferSize * maxSockets);
            writeBuffers = Marshal.AllocHGlobal(writeBufferSize * maxSockets);
            // one for accept, one for read and one for write
            overlappedBuffers = Marshal.AllocHGlobal(MyOverlapped.Size * 3 * maxSockets);
            this.readBufferSize = readBufferSize;
            this.writeBufferSize = writeBufferSize;
            this.tcpKeepAliveTimeout = tcpKeepAliveTimeout;
            for (int i = 0; i < maxSockets; i++)
            {
                sockets[i].nextFree = i + 1;;
            }

            lastFree = sockets.Length - 1;
            sockets[lastFree].nextFree = -1;

            ioPorts = new IntPtr[threads];
            for (int i = 0; i < ioPorts.Length; i++)
            {
                ioPorts[i] = Kernel32.CreateIoCompletionPort(Kernel32.INVALID_HANDLE_VALUE, IntPtr.Zero, IntPtr.Zero, 0);
                if (ioPorts[i] == IntPtr.Zero)
                {
                    throw new MySocketException(String.Format("Unexpected error trying to create a CompletionPort: {0}", Marshal.GetLastWin32Error()));
                }
            }

            listenIoPort = Kernel32.CreateIoCompletionPort(Kernel32.INVALID_HANDLE_VALUE, IntPtr.Zero, IntPtr.Zero, 0);
            if (listenIoPort == IntPtr.Zero)
            {
                throw new MySocketException(String.Format("Unexpected error trying to create a CompletionPort for listening: {0}", Marshal.GetLastWin32Error()));
            }

            workerThreads = new Thread[threads];
            for (int i = 0; i < workerThreads.Length; i++)
            {
                workerThreads[i] = new Thread(new ParameterizedThreadStart(SocketWorkerRoutine));
                workerThreads[i].Start(ioPorts[i]);
            }

            listenerThreads = new Thread[1];
            for (int i = 0; i < listenerThreads.Length; i++)
            {
                listenerThreads[i] = new Thread(new ParameterizedThreadStart(SocketWorkerRoutine));
                listenerThreads[i].Start(listenIoPort);
            }

            Winsock.WSADATA data = new Winsock.WSADATA();
            int error = Winsock.WSAStartup(0x0202, ref data);
            if (error != 0)
            {
                throw new MySocketException(String.Format("WSAStartup failed!  Error = {0}.", error));
            }
        }

        /// <summary>
        /// Size in bytes of the read buffers.
        /// </summary>
        public int ReadBufferSize
        {
            get { return this.readBufferSize; }
        }

        /// <summary>
        /// Size in bytes of the write buffers.
        /// </summary>
        public int WriteBufferSize
        {
            get { return this.writeBufferSize; }
        }

        /// <summary>
        /// Start listening on the specified port.
        /// </summary>
        /// <param name="ipAddress"></param>
        /// <param name="port"></param>
        /// <returns>The index of the listen socket</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public int Listen(IPAddress ipAddress, int port)
        {
            byte[] addressBytes = ipAddress.GetAddressBytes();
            int SendBufferSize = 256;
            int ReceiveBufferSize = 128;

            //
            // Create socket and set default options.
            //

            IntPtr sock = Winsock.WSASocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, IntPtr.Zero, 0, Winsock.WSA_FLAG_OVERLAPPED);

            if (sock == Kernel32.INVALID_HANDLE_VALUE) throw new MySocketException(Marshal.GetLastWin32Error());

            if (Winsock.setsockopt(sock, SocketOptionLevel.Socket, SocketOptionName.SendBuffer, ref SendBufferSize, sizeof(int)) != 0 ||
                Winsock.setsockopt(sock, SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, ref ReceiveBufferSize, sizeof(int)) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // Enable keep-alives
            //

            int receiveSize = 0;
            Winsock.tcp_keepalive keepalive = new Winsock.tcp_keepalive();
            keepalive.onOff = 0;

            if (tcpKeepAliveTimeout > 0)
            {
                keepalive.onOff = 1;
                keepalive.keepAliveTime = tcpKeepAliveTimeout;
                keepalive.keepAliveInterval = 1000;
            }

            GCHandle hKeepalive = GCHandle.Alloc(keepalive, GCHandleType.Pinned);

            try
            {
                if (Winsock.WSAIoctl(sock, IOControlCode.KeepAliveValues, hKeepalive.AddrOfPinnedObject(), Marshal.SizeOf(keepalive), new IntPtr(0), 0, ref receiveSize, new IntPtr(0), new IntPtr(0)) != 0)
                {
                    Winsock.closesocket(sock);
                    
                    throw new MySocketException(Marshal.GetLastWin32Error());
                }
            }
            finally
            {
                hKeepalive.Free();
            }

            //
            // Bind socket
            //


            Winsock.sockaddr_in sockaddr = new Winsock.sockaddr_in(BitConverter.ToInt32(addressBytes, 0), port);

            if (Winsock.bind(sock, ref sockaddr, Marshal.SizeOf(sockaddr)) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // set listen backlog
            //

            if (Winsock.listen(sock, 5000) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // Allocate entry
            //

            int index = Allocate();
            if (index < 0)
            {
                Winsock.closesocket(sock);
                throw new OutOfMemoryException("Not enough room in the socket array.");
            }

            //
            // Initialize, bind to io port and return
            //

            int returnIndex = sockets[index].Initialize(
                index,
                sock,
                MySocket.AddOffset(readBuffers, readBufferSize * index),
                readBufferSize,
                MySocket.AddOffset(writeBuffers, writeBufferSize * index),
                writeBufferSize,
                MySocket.AddOffset(overlappedBuffers, 3 * index * MyOverlapped.Size)
                );

            IntPtr returnPort = Kernel32.CreateIoCompletionPort(sock, listenIoPort, (IntPtr)returnIndex, 0);
            if (returnPort != listenIoPort)
            {
                int error = Marshal.GetLastWin32Error();
                if (sockets[index].Close(returnIndex, true)) Free(index);

                throw new MySocketException(String.Format("Call to bind the listen socket {0} to the IoPort {1} returned {2} and failed with error {3}.",
                    sock, listenIoPort, returnPort, error));
            }

            return returnIndex;
        }

        /// <summary>
        /// Post an accept on the listen socket
        /// </summary>
        /// <param name="listenSocketIndex"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        public SocketError PostAccept(int listenSocketIndex, AcceptCallback callback)
        {
            int index = GetRealIndex(listenSocketIndex);
            IntPtr listenSocket = sockets[index].sock;
            IntPtr acceptSocket = Winsock.WSASocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, IntPtr.Zero, 0, Winsock.WSA_FLAG_OVERLAPPED);
            int acceptIndex = Allocate();
            if (acceptIndex < 0)
            {
                Winsock.closesocket(acceptSocket);
                return SocketError.TooManyOpenSockets;
            }
            acceptIndex = sockets[acceptIndex].Initialize(
                acceptIndex,
                acceptSocket,
                MySocket.AddOffset(readBuffers, readBufferSize * acceptIndex),
                readBufferSize,
                MySocket.AddOffset(writeBuffers, writeBufferSize * acceptIndex),
                writeBufferSize,
                MySocket.AddOffset(overlappedBuffers, 3 * acceptIndex * MyOverlapped.Size));
            SocketError error = sockets[index].PostAccept(listenSocketIndex, acceptSocket, acceptIndex, callback);
            if (SocketError.Success != error)
            {
                Close(acceptIndex);
            }

            return error;
        }

        /// <summary>
        /// Bind the newly accepted socket to the same io port as teh listen socket
        /// </summary>
        /// <param name="listenSocketIndex"></param>
        /// <param name="acceptSocketIndex"></param>
        /// <param name="sendBufferSize"></param>
        /// <param name="receiveBufferSize"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public void BindToIoPort(int listenSocketIndex, int acceptSocketIndex, int sendBufferSize, int receiveBufferSize)
        {
            listenSocketIndex = GetRealIndex(listenSocketIndex);
            int index = acceptSocketIndex = GetRealIndex(acceptSocketIndex);

            IntPtr listenSocket = sockets[listenSocketIndex].sock;
            IntPtr acceptSocket = sockets[acceptSocketIndex].sock;

            IntPtr returnPort = Kernel32.CreateIoCompletionPort(acceptSocket, ioPorts[acceptSocketIndex % ioPorts.Length], (IntPtr)sockets[acceptSocketIndex].index, 0);
            if (returnPort != ioPorts[acceptSocketIndex % ioPorts.Length])
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "Call to bind the Listen socket to the ioport failed with error {0}.", Marshal.GetLastWin32Error()
                    ));
            }

            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.UpdateAcceptContext, ref listenSocket, IntPtr.Size) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(UpdateAcceptContext) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int noDelay = 1;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Tcp, SocketOptionName.NoDelay, ref noDelay, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(NoDelay) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int keepAlive = (tcpKeepAliveTimeout > 0) ? 1 : 0;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.KeepAlive, ref keepAlive, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(KeepAlive) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int sendBufferSizeOverride = 0;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.SendBuffer, ref sendBufferSizeOverride, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(SendBuffer) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, ref receiveBufferSize, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(ReceiveBuffer) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            sockets[index].boundToIoPort = true;
        }

        /// <summary>
        /// Post a read on an accepted socket
        /// </summary>
        /// <param name="socketIndex"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        public SocketError PostRead(int socketIndex, ReadCallback callback)
        {
            int index = GetRealIndex(socketIndex);
            if (!sockets[index].boundToIoPort) throw new MySocketException("PostWrite must be called after binding the socket to an io port.");
            return sockets[index].PostRead(socketIndex, callback);
        }

        /// <summary>
        /// Post a write on an accepted socket
        /// </summary>
        /// <param name="socketIndex"></param>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="bytesToWrite"></param>
        /// <param name="writeCallback"></param>
        /// <returns></returns>
        public SocketError PostWrite(int socketIndex, byte[] buffer, int offset, int bytesToWrite, WriteCallback writeCallback)
        {
            int index = GetRealIndex(socketIndex);
            if (!sockets[index].boundToIoPort) throw new MySocketException("PostWrite must be called after binding the socket to an io port.");
            return sockets[index].PostWrite(socketIndex, buffer, offset, bytesToWrite, writeCallback);
        }

        /// <summary>
        /// Close the socket
        /// </summary>
        /// <param name="socketIndex"></param>
        public void Close(int socketIndex)
        {
            int index = (socketIndex & MySocket.indexMask);
            if (sockets[index].Close(socketIndex, true)) Free(index);
        }

        /// <summary>
        /// The total number of sockets including listening sockets.
        /// </summary>
        public int ConnectionsCount
        {
            get { return count; }
        }

        /// <summary>
        /// Closedown the socket layer.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public void Close()
        {
            //
            // Get rid of all the threads.
            //

            if (workerThreads != null)
            {
                for (int i = 0; i < workerThreads.Length; i++)
                {
                    Kernel32.PostQueuedCompletionStatus(ioPorts[i], 0, -1, (IntPtr)0);
                }

                for (int i = 0; i < workerThreads.Length; i++)
                    workerThreads[i].Join();

                workerThreads = null;
            }

            if (listenerThreads != null)
            {
                for (int i = 0; i < listenerThreads.Length; i++)
                {
                    Kernel32.PostQueuedCompletionStatus(listenIoPort, 0, -1, (IntPtr)0);
                }

                for (int i = 0; i < listenerThreads.Length; i++)
                    listenerThreads[i].Join();

                listenerThreads = null;
            }

            if (IntPtr.Zero != readBuffers)
            {
                Marshal.FreeHGlobal(readBuffers);
                readBuffers = IntPtr.Zero;
            }

            if (IntPtr.Zero != writeBuffers)
            {
                Marshal.FreeHGlobal(writeBuffers);
                writeBuffers = IntPtr.Zero;
            }

            if (IntPtr.Zero != overlappedBuffers)
            {
                Marshal.FreeHGlobal(overlappedBuffers);
                overlappedBuffers = IntPtr.Zero;
            }

        }

        void SocketWorkerRoutine(object parameter)
        {
            IntPtr ioPort = (IntPtr)parameter;

            //
            // Get completion status and operate.
            //

            while (true)
            {

                try
                {
                    //
                    // Now call GetQueuedCompletionStatus to hang out there.
                    //

                    int bytesRead = 0;
                    int key = -1;
                    IntPtr overlappedPtr = IntPtr.Zero;
                    Kernel32.GetQueuedCompletionStatus(
                        ioPort,
                        ref bytesRead,
                        ref key,
                        ref overlappedPtr,
                        -1);

                    try
                    {
                        if (overlappedPtr != IntPtr.Zero)
                        {
                            int index = (key & MySocket.indexMask);
                            sockets[index].OnCompletion(key, overlappedPtr);
                        }
                        else
                        {
                            int error = Marshal.GetLastWin32Error();
                            Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + string.Format("GetQueuedCompletionStatus returned {0}. Quitting thread.", error) +")");

                            break; // exit the loop/
                        }
                    }
                    catch (Exception e)
                    {
                        unhandledSocketExceptionCount++;
                        Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + e.ToString() +")");
                    }
                }
                catch
                {
                    unhandledUnmanagedExceptionCount++;
                }
            }

        }

        int Allocate()
        {
            lock (syncRoot)
            {
                int i = firstFree;
                if (i >= 0)
                {
                    firstFree = sockets[i].nextFree;
                    count++;
                    sockets[i].nextFree = -1;
                    if (firstFree == -1) lastFree = -1;
                }

                return i;
            }
        }

        void Free(int index)
        {
            if (index >= 0)
            {
                lock (syncRoot)
                {
                    if (sockets[index].nextFree == -1)
                    {
                        if (lastFree >= 0)
                        {
                            sockets[lastFree].nextFree = index;
                        }
                        lastFree = index;
                        if (firstFree < 0) firstFree = lastFree;
                        count--;
                    }
                }
            }
        }

        public IPAddress IPAddress(int index)
        {
            return sockets[GetRealIndex(index)].IPAddress;
        }

        public ushort Port(int index)
        {
            return sockets[GetRealIndex(index)].Port;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\msgr\ConnectionListener.cs ===
using System;
using System.Net;
using System.Threading;
using System.IO;
using System.Net.Sockets;
using System.Diagnostics;

using xonline.common.mgmt;

namespace MS.Msn.Messenger.Runtime
{
    /// <summary>
    /// delegate for IConnectionListener.Connected event
    /// </summary>
    public delegate void ConnectedCallback(object Source, TcpStream c);

    /// <summary>
    /// Interface shared by all connection listeners.
    /// The ConnectionListener generates server-side TcpStream objects
    /// Subclasses included TCPListener and TLSListener
    /// </summary>
    public interface IConnectionListener
    {
        /// <summary>
        ///   This method starts listening for incoming connections
        ///   on the specified end point.
        /// </summary>
        void Start();

        /// <summary>
        /// Stops listening for incoming connections. Existing connections are not affected
        /// </summary>
        void Stop();

        /// <summary>
        /// Event raised when a new connection is created. Protocol handlers
        /// should consume this event.
        /// </summary>
        event ConnectedCallback Connected;
    }

    /// <summary>
    /// TCP Listener class. Implements generic IConnectionListener interface
    /// Provides asynchronous callback events that are raised when an incoming connection request
    /// is received.
    /// </summary>
    public class TcpConnectionListener : IConnectionListener, IDisposable
    {
        private const int MaxAcceptsPending = 1;

        private readonly SocketLayer socketLayer;
        private readonly IPEndPoint endPoint; 
        private readonly int sendBufferSize;
        private readonly int receiveBufferSize;
        private readonly TcpStream.DisconnectedEventHandler connectionDisconnected;

        // socket to listen for incoming connections
        int listenSocketIndex = -1;

        private int connectionCount = 0;
        private int acceptsPending = 0;

        /// <summary>
        /// Event raised when a new incoming Connection is available
        /// </summary>
        public event ConnectedCallback Connected;

        // callback that is called when BeginAccept on listenSocket completes
        AcceptCallback connectionAcceptedCallback;

        private int maxSocketCount;
        
        /// <summary>
        /// Create a TcpConnectionListener bound to the specified ConectionController and listening
        /// on the given IP address and port
        /// </summary>
        public TcpConnectionListener(IPEndPoint endPoint, int readBufferSize, int writeBufferSize, int maxSockets, uint tcpKeepAliveTimeout)
        {
            if (endPoint == null)
            {
                throw new ArgumentNullException("endPoint");
            }

            this.sendBufferSize = writeBufferSize;
            this.receiveBufferSize = readBufferSize;
            this.endPoint = endPoint;

            this.socketLayer = new SocketLayer(maxSockets, readBufferSize, writeBufferSize, tcpKeepAliveTimeout);
            this.maxSocketCount = maxSockets;

            this.connectionAcceptedCallback = new AcceptCallback(this.ConnectionAccepted);
            this.connectionDisconnected = new TcpStream.DisconnectedEventHandler(this.DisconnectedEventHandler);
        }

        public int ConnectionCount
        {
            get { return this.connectionCount; }
        }

        /// <summary>
        /// Start Listening.
        /// This method is called by the server application.
        /// The connection controller internally throttles acceptance of new connections so
        /// it is possible that the listen may be temporarily disabled.
        /// </summary>
        public virtual void Start()
        {
            lock (this)
            {
                if (listenSocketIndex != -1)
                {
                    throw new InvalidOperationException("Stack is already listening on "
                        + endPoint.ToString());
                }

                listenSocketIndex = socketLayer.Listen(endPoint.Address, endPoint.Port);

                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionListenerStart(" + endPoint.ToString() + ")");

                this.PostAccept();
            }
        }

        /// <summary>
        /// This method is called by the server application to stop listening for incoming connections.
        /// Existing connections are not affected.
        /// </summary>
        public virtual void Stop()
        {
            int socketIndex = -1;
            lock (this)
            {
                if (-1 != listenSocketIndex)
                {
                    socketIndex = listenSocketIndex;
                    listenSocketIndex = -1;
                }
            }

            if (-1 != socketIndex)
            {
                socketLayer.Close(socketIndex);
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_HIGH, "MessengerRuntimeEvents.LogTcpConnectionListenerStop()");
            }
        }

        /// <summary>
        /// Check whether we need to post an accept and post one if needed.
        /// Must be called with lock held.
        /// </summary>
        private void PostAccept()
        {
            if (listenSocketIndex != -1)
            {
                if (this.acceptsPending < MaxAcceptsPending)
                {
                    SocketError error = socketLayer.PostAccept(listenSocketIndex, connectionAcceptedCallback);

                    if (error != SocketError.Success)
                    {
                        Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ((int)error).ToString() + ")");

                        if (SocketError.AlreadyInProgress != error && SocketError.TooManyOpenSockets != error)
                            Stop();
                    }
                    else
                    {
                        Interlocked.Increment(ref acceptsPending);
                    }
                }
            }
        }

        /// <summary>
        /// Raise the Connected event.
        /// </summary>
        /// <param name="connection"></param>
        protected void OnConnected(TcpStream connection)
        {
            // indicate the new connection to the protocol layer 
            try
            {
                if (this.Connected != null)
                {
                    this.Connected(this, connection);
                    Interlocked.Increment(ref this.connectionCount);

                    connection.Disconnected += this.connectionDisconnected;
                }
                else
                {
                    connection.Dispose();
                }
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + e.ToString() +")");
                throw;
            }
        }

        /// <summary>
        /// Handle an incoming connection
        /// This function is virtual so that it can be redefined for TlsConnectionListner
        /// </summary>
        /// <param name="connectedSocketIndex"></param>
        protected virtual void OnSocketConnected(int connectedSocketIndex)
        {
            // allow reads and writes
            socketLayer.BindToIoPort(listenSocketIndex, connectedSocketIndex, sendBufferSize, receiveBufferSize);

            // create a TcpConnection object
            TcpStream connection = new TcpStream(connectedSocketIndex, this.socketLayer);

            this.OnConnected(connection);
        }

        /// <summary>
        /// Called by Socket object on completion of BeginAccept
        /// </summary>
        /// <param name="acceptedSocketIndex"></param>
        /// <param name="error"></param>
        private void ConnectionAccepted(int acceptedSocketIndex, SocketError error)
        {
            if (SocketError.Success != error)
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ((int)error).ToString() +")");
            }
            else
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionListenerAccept(" + acceptedSocketIndex.ToString() +")");
            }

            lock (this)
            {
                Interlocked.Decrement(ref this.acceptsPending);
                this.PostAccept();
            }

            if (SocketError.Success != error)
            {
                this.socketLayer.Close(acceptedSocketIndex);
                return;
            }

            TcpStream connection = null;

            try
            {
                // new connection handling
                socketLayer.BindToIoPort(listenSocketIndex, acceptedSocketIndex, sendBufferSize, receiveBufferSize);
                connection = new TcpStream(acceptedSocketIndex, this.socketLayer);

                this.OnConnected(connection);
            }
            catch (Exception ex)
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ex.ToString() +")");
                if (connection != null) connection.Dispose();
            }
        }

        public void DisconnectedEventHandler(TcpStream sender, Exception reason)
        {
            int currentCount = Interlocked.Decrement(ref this.connectionCount);

            //
            // Always call PostAccept() to check whether we need to post a new accept.
            //
            // We rely on the lower SocketLayer to enforce the maximum number of simultaneous connections by
            // failing to post accepts when we are at capacity.
            //

            lock (this)
            {
                this.PostAccept();
            }
        }

        void IDisposable.Dispose()
        {
            if (null != socketLayer)
            {
                socketLayer.Close();
            }

            this.Stop();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\Request.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Diagnostics;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace xonline.server.XConnSrv
{
    public class UserRequestContext : XConnSrvContext
    {
        static UserRequestContext()
        {
            unsafe
            {
                // initialize the request message map.
                s_MessageMap = new MessageHandler[]
                {
                    new MessageHandler((uint)MESSAGE_TYPES.eConnect, (uint)sizeof(CONNECT_MESSAGE), new MessageHandlerProc(ProcessConnectMessage)),
                    new MessageHandler((uint)MESSAGE_TYPES.eDisconnect, (uint)sizeof(DISCONNECT_MESSAGE), new MessageHandlerProc(ProcessDisconnectMessage)),
                    new MessageHandler((uint)MESSAGE_TYPES.eSubscribe, (uint)sizeof(SUBSCRIBE_MESSAGE), new MessageHandlerProc(ProcessSubscribeMessage)),
                    new MessageHandler((uint)MESSAGE_TYPES.eUnsubscribe, (uint)sizeof(UNSUBSCRIBE_MESSAGE), new MessageHandlerProc(ProcessUnsubscribeMessage)),
                    new MessageHandler((uint)MESSAGE_TYPES.eQuery, (uint)sizeof(QUERY_MESSAGE), new MessageHandlerProc(ProcessQueryMessage)),
                    new MessageHandler((uint)MESSAGE_TYPES.ePublish, (uint)sizeof(PUBLISH_MESSAGE), new MessageHandlerProc(ProcessPublishMessage))
                };        
            }
        }

        static MessageHandler[] s_MessageMap = null;

        public byte[] m_rgbEntireMessage;
        public int m_dwWriteOffset;
        
        protected ClientConnection m_cliConn;

        protected uint m_dwMsgType;
        protected uint m_dwSeqNum;
        protected uint m_dwUserIndexFlags;
        
        protected XomRequestTimeElapsed m_timeElapsed = null;
        protected StringBuilder m_sbLogParams = null;
            
        public HResult m_hr = HResult.S_OK;

        public UserRequestContext(ClientConnection cliConn)
        {
            m_cliConn = cliConn;
        }

        public override void ProcessInternal(Object state)
        {
            m_timeElapsed = new XomRequestTimeElapsed();
            
            MessageHandler msgHandler = ValidateMessage();

            if (msgHandler != null)
            {
                AddLogParameter(SubNotiDefs.MessageTypeToString(m_dwMsgType));
                AddLogParameter(m_cliConn.IPAddress);
                AddLogParameter(m_dwUserIndexFlags.ToString("X"));
                AddLogParameter(m_dwSeqNum.ToString("X"));
                
                // call the actual handler for this message type.
                msgHandler.HandleMessageType(this);
            }
            else
            {
                m_cliConn.Disconnect();
            }
        }

        public void AddLogParameter(object logParam)
        {
            if (m_sbLogParams == null)
            {
                m_sbLogParams = new StringBuilder();
            }

            m_sbLogParams.Append(logParam.ToString());
            m_sbLogParams.Append("|");
        }

        private void CompleteAPI()
        {
            // update perfcounters
            XConnSrvAPICounters.Total[m_dwMsgType].RequestsPerSecond.Increment();
            XConnSrvAPICounters.Total.RequestsPerSecond.Increment();
            XConnSrvAPICounters.Total[m_dwMsgType].ResponseTimeAvgBase.Increment();
            XConnSrvAPICounters.Total.ResponseTimeAvgBase.Increment();
            XConnSrvAPICounters.Total[m_dwMsgType].ResponseTimeAvg.IncrementBy(m_timeElapsed.TimeElapsed);
            XConnSrvAPICounters.Total.ResponseTimeAvg.IncrementBy(m_timeElapsed.TimeElapsed);

            if (HResult.Succeeded(m_hr))
            {
                XConnSrvAPICounters.Total[m_dwMsgType].SuccessRate.Increment();
                XConnSrvAPICounters.Total.SuccessRate.Increment();
            }
            else
            {
                XConnSrvAPICounters.Total[m_dwMsgType].FailureRate.Increment();
                XConnSrvAPICounters.Total.FailureRate.Increment();
            }

            XConnSrv.Instance.Log(m_sbLogParams.ToString());
        }

        private unsafe MessageHandler ValidateMessage()
        {
            MessageHandler msgHandler;
            
            fixed (byte *pBuffer = &(m_rgbEntireMessage[0]))
            {
                BASE_MESSAGE_HEADER *pHeader = (BASE_MESSAGE_HEADER *)pBuffer;

                if (pHeader->dwProtocolVersion > SubNotiDefs.CURRENT_PROTOCOL_VERSION)
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_PROTOCOL_VERSION_MISMATCH, "Invalid protocol version (" + pHeader->dwProtocolVersion + ") from client " + m_cliConn.IPAddress + ".");
                    return null;
                }

                if ((pHeader->dwMessageType < SubNotiDefs.MIN_REQUEST_TYPE) ||
                    (pHeader->dwMessageType > SubNotiDefs.MAX_REQUEST_TYPE))
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_MSGTYPE_UNKNOWN, "Unknown message type (" + pHeader->dwMessageType + ") from client " + m_cliConn.IPAddress + ".");
                    return null;
                }

                if (pHeader->dwMessageType != (uint)MESSAGE_TYPES.eConnect)
                {
                    if (m_cliConn.dwUserIndexFlags == 0)
                    {
                      Xom.NtEvent(XEvent.Id.XCONNSRV_MSG_BEFORE_CONNECT, "Message (" + pHeader->dwMessageType + ") received before connect from client " + m_cliConn.IPAddress + ".");
                        return null;
                    }

                    if ((pHeader->dwUserIndexFlags == 0) || 
                        ((m_cliConn.dwUserIndexFlags & pHeader->dwUserIndexFlags) != pHeader->dwUserIndexFlags))
                    {
                      Xom.NtEvent(XEvent.Id.XCONNSRV_USER_INDEX_MISMATCH, "User Index Flags mismatch (" + pHeader->dwUserIndexFlags.ToString("X") + " do not match " + m_cliConn.dwUserIndexFlags.ToString("X") + ") from client " + m_cliConn.IPAddress + ".");
                        return null;
                    }
                }

                msgHandler = s_MessageMap[pHeader->dwMessageType - SubNotiDefs.MIN_REQUEST_TYPE];

                if (pHeader->dwTotalSize < msgHandler.dwMinSize)
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_MSG_TOO_SMALL, "Message too small (" + pHeader->dwTotalSize + ") for type (" + pHeader->dwMessageType + ") from client " + m_cliConn.IPAddress + ".");
                    return null;
                }

                m_dwMsgType = pHeader->dwMessageType;
                m_dwSeqNum = pHeader->dwSeqNum;
                m_dwUserIndexFlags = pHeader->dwUserIndexFlags;
            }

            return msgHandler;
        }

        public static void ProcessConnectMessage(UserRequestContext ctx)
        {
            if (Config.GetBoolSetting(Setting.XConnSrv_UseSGAuth))
            {
                // go get SGInfo.
                GetSGInfoContext sgCtx = new GetSGInfoContext(ctx.m_cliConn.IPAddress, ValidateConnectingUsers, ctx);
                sgCtx.Fetch();
            }
            else
            {
                // skip the context switch.  make a dummy sginfo.
                ValidateConnectingUsers(new SGInfo(0, 0, 0), null, ctx);
            }
        }

        public static unsafe void ValidateConnectingUsers(SGInfo sginfo, Exception excep, Object state)
        {
            UserRequestContext ctx = state as UserRequestContext;
            BulkDataRetrievalContext dataCtx = new BulkDataRetrievalContext(ConnectMessageComplete, ctx);

            if (sginfo == null)
            {
                XEvent.Id eventId = XEvent.Id.XCONNSRV_SGINFO_ERROR;
                ExceptionWithEventId e = excep as ExceptionWithEventId;
                if (e != null)
                {
                    eventId = e.EventId;
                }

                if (excep == null)
                    Xom.NtEvent(eventId, "Error retrieving SGInfo for client: " + ctx.m_cliConn.IPAddress + ".");
                else  {
                    Xom.NtEvent(eventId, e, "Error retrieving SGInfo for client: " + ctx.m_cliConn.IPAddress + ".");
                }
                ctx.m_hr = HResult.XONLINE_E_NO_SESSION;
                goto lDone;
            }
            else
            {
                // save the sginfo.
                ctx.m_cliConn.m_sginfo = sginfo;
            }

            ctx.AddLogParameter(sginfo.ToXomLogString());
            
            fixed (byte *pBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                CONNECT_MESSAGE *pMessage = (CONNECT_MESSAGE *)pBuffer;

                if ((pMessage->header.dwHeaderFlags & SubNotiDefs.XONLINE_CONNSRV_CONNECT_RECONNECT) != 0)
                {
                    ctx.AddLogParameter("RECONNECT");
                }

                if (pMessage->header.dwUserIndexFlags >= (uint)(1 << (int)XOn.XONLINE_MAX_LOGON_USERS))
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_INVALID_USER_FLAGS, "Bad User Index Flags (" + pMessage->header.dwUserIndexFlags.ToString("X") + ") in connection from client " + ctx.m_cliConn.IPAddress + ".");
                    ctx.m_hr = HResult.E_INVALIDARG;
                    goto lDone;
                }

                int[] rgIndices = SubNotiDefs.UserFlagsToIndices(pMessage->header.dwUserIndexFlags);

                if (rgIndices.Length > XOn.XONLINE_MAX_LOGON_USERS)
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_TOO_MANY_USER_FLAGS, "Number of index flags (" + rgIndices.Length +") > XONLINE_MAX_LOGON_USERS in connection from client " + ctx.m_cliConn.IPAddress + ".");
                    ctx.m_hr = HResult.E_INVALIDARG;
                    goto lDone;
                }

                if (rgIndices.Length != pMessage->wNumUsers)
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_NUM_USER_FLAGS_MISMATCH, "Number of index flags (" + rgIndices.Length +") do not match wNumUsers (" + pMessage->wNumUsers + ") in connection from client " + ctx.m_cliConn.IPAddress + ".");
                    ctx.m_hr = HResult.E_INVALIDARG;
                    goto lDone;
                }
                
                ctx.AddLogParameter(pMessage->wNumUsers);

                ulong *rgUserIDs = (ulong *)(pBuffer + sizeof(CONNECT_MESSAGE));
                for (ushort iUser = 0; iUser < pMessage->wNumUsers; iUser++)
                {
                    ctx.AddLogParameter(rgUserIDs[iUser].ToString("X"));

                    // we'll need the friends list for this user.
                    DATA_OBJECT_SPECIFIER doSpec = new DATA_OBJECT_SPECIFIER();
                    doSpec.wDataType = (ushort)DATA_TYPES.eFriendsList;
                    doSpec.qwOwnerXUID = rgUserIDs[iUser];
                    dataCtx.AddDataObject(ref doSpec);

                    // check sginfo for each user.
                    if (Config.GetBoolSetting(Setting.XConnSrv_UseSGAuth) && !sginfo.IsUserPresent(rgUserIDs[iUser]))
                    {
                        ctx.m_hr = HResult.XONLINE_E_USER_NOT_PRESENT;
                        Xom.NtEvent(XEvent.Id.XCONNSRV_USER_NOT_PRESENT, "Userid (" + rgUserIDs[iUser].ToString("X") + ") not present in SGInfo for client: " + ctx.m_cliConn.IPAddress);
                        goto lDone;
                    }

                    // check for duplicate xuids.
                    for (ushort iExistingUser = 0; iExistingUser < iUser; iExistingUser++)
                    {
                        if (rgUserIDs[iExistingUser] == rgUserIDs[iUser])
                        {
                            ctx.m_hr = HResult.E_INVALIDARG;
                            Xom.NtEvent(XEvent.Id.XCONNSRV_DUPLICATE_USER, "Userid (" + rgUserIDs[iUser].ToString("X") + ") appears twice in connect message from client: " + ctx.m_cliConn.IPAddress);
                            goto lDone;
                        }
                    }
                }
            }

        lDone:

            if (HResult.Failed(ctx.m_hr) || (dataCtx.NumObjects == 0))
            {
                // skip getting the data.
                ConnectMessageComplete(null, ctx);
            }
            else
            {
                // go get the data.
                XConnSrvEngine.QueueContext(ThreadType.eData, dataCtx, null);
            }
        }

        public static unsafe void ConnectMessageComplete(BulkDataRetrievalContext dataCtx, Object state)
        {
            UserRequestContext ctx = state as UserRequestContext;

            if (HResult.Failed(ctx.m_hr))
            {
                goto lDone;
            }

            fixed (byte *pBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                CONNECT_MESSAGE *pMessage = (CONNECT_MESSAGE *)pBuffer;

                int[] rgIndices = SubNotiDefs.UserFlagsToIndices(pMessage->header.dwUserIndexFlags);
                ulong[] rgNewUsers = new ulong[ctx.m_cliConn.qwUserIDs.Length];

                ulong *rgUserIDs = (ulong *)(pBuffer + sizeof(CONNECT_MESSAGE));
                for (ushort iUser = 0; iUser < pMessage->wNumUsers; iUser++)
                {
                    rgNewUsers[rgIndices[iUser]] = rgUserIDs[iUser];
                }

                // add the connected users into the connection.
                ctx.m_cliConn.UpdateUsers(rgNewUsers);

                if (dataCtx != null)
                {
                    // add the friends lists.
                    for (int iItem = 0; iItem < dataCtx.NumObjects; iItem++)
                    {
                        // get the friends data blob from the data ctx.
                        byte[] rgbFriendsData = dataCtx.GetItemData(iItem);
                        DATA_OBJECT_SPECIFIER doSpec = dataCtx.GetItemSpecifier(iItem);
                        DataSubscriptionKey key = new DataSubscriptionKey(ref doSpec);

                        // update the user's friends.
                        ctx.m_cliConn.HandleFriendsListChange(key, rgbFriendsData);
                    }
                }
                
                if ((pMessage->header.dwHeaderFlags & SubNotiDefs.XONLINE_CONNSRV_CONNECT_RECONNECT) != 0)
                {
                    XConnSrvCounters.Current.ReconnectRate.Increment();
                }
            }

            // this connection can now process real requests.

        lDone:

            int cbSend = sizeof(CONNECT_REPLY_MESSAGE);
            byte[] rgbResponse = XConnSrvEngine.GetSendBuffer(cbSend);
            fixed (byte *pBuffer = &(rgbResponse[0]))
            {
                CONNECT_REPLY_MESSAGE *pReply = (CONNECT_REPLY_MESSAGE *)pBuffer;

                BuildErrorReply(ref pReply->errorMsg, 
                    (uint)MESSAGE_TYPES.eConnectReply, 
                    ctx.m_dwSeqNum, 
                    ctx.m_dwUserIndexFlags, 
                    (uint)cbSend, 
                    ctx.m_hr);
            }

            ctx.m_cliConn.Send(rgbResponse, cbSend);

            if (HResult.Failed(ctx.m_hr))
            {
                ctx.m_cliConn.Disconnect();
            }

            ctx.AddLogParameter(SubNotiDefs.MessageTypeToString((uint)MESSAGE_TYPES.eConnectReply));
            ctx.AddLogParameter(ctx.m_hr);

            ctx.CompleteAPI();
        }

        public static unsafe void ProcessDisconnectMessage(UserRequestContext ctx)
        {
            fixed (byte *pBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                DISCONNECT_MESSAGE *pMessage = (DISCONNECT_MESSAGE *)pBuffer;

                ctx.AddLogParameter(pMessage->dwReason);
            }

            // build response before we zero out the connection user info.
            int cbSend = sizeof(DISCONNECT_REPLY_MESSAGE);
            byte[] rgbResponse = XConnSrvEngine.GetSendBuffer(cbSend);
            fixed (byte *pBuffer = &(rgbResponse[0]))
            {
                DISCONNECT_REPLY_MESSAGE *pReply = (DISCONNECT_REPLY_MESSAGE *)pBuffer;

                BuildErrorReply(ref pReply->errorMsg, 
                    (uint)MESSAGE_TYPES.eDisconnectReply, 
                    ctx.m_dwSeqNum, 
                    ctx.m_dwUserIndexFlags, 
                    (uint)cbSend, 
                    ctx.m_hr);
            }

            ctx.m_cliConn.Send(rgbResponse, cbSend);

            ctx.m_cliConn.Disconnect();

            ctx.AddLogParameter(SubNotiDefs.MessageTypeToString((uint)MESSAGE_TYPES.eDisconnectReply));
            ctx.AddLogParameter(ctx.m_hr);

            ctx.CompleteAPI();
        }

        public static unsafe void ProcessSubscribeMessage(UserRequestContext ctx)
        {
            // container for any data reads we need to do.
            BulkDataRetrievalContext dataCtx = new BulkDataRetrievalContext(SubscribeMessageComplete, ctx);
            Hashtable htSync = null;

            fixed (byte *pReqBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                SUBSCRIBE_MESSAGE *pMessage = (SUBSCRIBE_MESSAGE *)pReqBuffer;

                if ((pMessage->header.dwHeaderFlags & SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC) != 0)
                {
                    ctx.AddLogParameter("FULLSYNC");
                    htSync = new Hashtable();
                }

                ctx.AddLogParameter(pMessage->dwNumDataObjects);

                if (pMessage->dwNumDataObjects > Config.GetUIntSetting(Setting.XConnSrv_MaxObjectsPerMessage))
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_TOO_MANY_OBJECTS, "ProcessSubscribeMessage: message from client " + 
                        ctx.m_cliConn.IPAddress + " contains too many objects (" + pMessage->dwNumDataObjects + ").");
                    ctx.m_hr = HResult.E_INVALIDARG;
                    goto lDone;
                }

                if ((htSync == null) && ((ctx.m_cliConn.NumSubscriptions + pMessage->dwNumDataObjects) > Config.GetUIntSetting(Setting.XConnSrv_MaxSubscriptionsPerConnection)))
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_TOO_MANY_SUBSCRIPTIONS, "ProcessSubscribeMessage: message from client " + 
                        ctx.m_cliConn.IPAddress + " would make too many subscriptions (" + (ctx.m_cliConn.NumSubscriptions + pMessage->dwNumDataObjects).ToString() + ").");
                    ctx.m_hr = HResult.E_INVALIDARG;
                    goto lDone;
                }

                // loop through the subscriptions to add
                int offsetRequest = sizeof(SUBSCRIBE_MESSAGE);
                for (int iData = 0; iData < pMessage->dwNumDataObjects; iData++)
                {
                    DATA_OBJECT_SPECIFIER *pDataRequest = (DATA_OBJECT_SPECIFIER *)&(pReqBuffer[offsetRequest]);

                    if (htSync != null)
                    {
                        // mark this as a "keeper".
                        try
                        {
                            htSync.Add(new DataSubscriptionKey(ref *pDataRequest), ctx);
                        }
                        catch (ArgumentException)
                        {
                            // don't panic if there is a duplicate key.
                        }
                    }
                    else
                    {
                        // create a subscription.
                        ctx.m_cliConn.AddSubscription(ref *pDataRequest, pMessage->header.dwUserIndexFlags);
                    }

                    // add this item to fetch from memcache.
                    dataCtx.AddDataObject(ref *pDataRequest);

                    ctx.AddLogParameter(CacheUtil.GetDataKeyString(ref *pDataRequest));

                    offsetRequest += sizeof(DATA_OBJECT_SPECIFIER);
                }
            }            

            if (htSync != null)
            {
                ctx.m_cliConn.SyncSubscriptions(htSync, ctx.m_dwUserIndexFlags);
            }
            
        lDone:

            if (HResult.Failed(ctx.m_hr) || (dataCtx.NumObjects == 0))
            {
                // skip getting the data.
                SubscribeMessageComplete(dataCtx, ctx);
            }
            else
            {
                // go get the data.
                XConnSrvEngine.QueueContext(ThreadType.eData, dataCtx, null);
            }
        }            

        public static unsafe void SubscribeMessageComplete(BulkDataRetrievalContext dataCtx, Object state)
        {
            UserRequestContext ctx = state as UserRequestContext;
            object[] rgCustomData = new object[dataCtx.NumObjects];

            // calculate the buffer size;
            int cbResponse = sizeof(SUBSCRIBE_REPLY_MESSAGE);
            for (int iItem = 0; iItem < dataCtx.NumObjects; iItem++)
            {
                DATA_OBJECT_SPECIFIER doSpec = dataCtx.GetItemSpecifier(iItem);
                byte[] rgbItem = dataCtx.GetItemData(iItem);

                // do any custom formatting and store the result.
                rgCustomData[iItem] = (byte[])DataUtilities.CustomizeDataForUser(rgbItem, ctx.m_cliConn, ctx.m_dwUserIndexFlags, doSpec.wObjectSize);
                
                cbResponse += ((byte[])rgCustomData[iItem]).Length;
            }

            // make response buffer.
            byte[] rgbResponse = XConnSrvEngine.GetSendBuffer(cbResponse);

            // build the header.
            fixed (byte *pRespBuffer = &(rgbResponse[0]))
            {
                SUBSCRIBE_REPLY_MESSAGE *pReply = (SUBSCRIBE_REPLY_MESSAGE *)pRespBuffer;

                BuildErrorReply(ref pReply->errorMsg, 
                    (uint)MESSAGE_TYPES.eSubscribeReply, 
                    ctx.m_dwSeqNum, 
                    ctx.m_dwUserIndexFlags, 
                    (uint)cbResponse, 
                    ctx.m_hr);

                pReply->dwNumDataObjects = (uint)dataCtx.NumObjects;
            }

            // copy all the data items.            
            int offsetResponse = sizeof(SUBSCRIBE_REPLY_MESSAGE);
            for (int iItem = 0; iItem < dataCtx.NumObjects; iItem++)
            {
                byte[] rgbItem = (byte[])rgCustomData[iItem];

                System.Buffer.BlockCopy(rgbItem, 0, rgbResponse, offsetResponse, rgbItem.Length);

                offsetResponse += rgbItem.Length;
            }

            ctx.m_cliConn.Send(rgbResponse, cbResponse);

            ctx.AddLogParameter(SubNotiDefs.MessageTypeToString((uint)MESSAGE_TYPES.eSubscribeReply));
            ctx.AddLogParameter(ctx.m_hr);           

            ctx.CompleteAPI();
        }
                
        public static unsafe void ProcessUnsubscribeMessage(UserRequestContext ctx)
        {
            fixed (byte *pReqBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                UNSUBSCRIBE_MESSAGE *pMessage = (UNSUBSCRIBE_MESSAGE *)pReqBuffer;

                ctx.AddLogParameter(pMessage->dwNumDataObjects);

                if (pMessage->dwNumDataObjects > Config.GetUIntSetting(Setting.XConnSrv_MaxObjectsPerMessage))
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_TOO_MANY_OBJECTS, "ProcessUnsubscribeMessage: message from client " + 
                        ctx.m_cliConn.IPAddress + " contains too many objects (" + pMessage->dwNumDataObjects + ").");
                    ctx.m_hr = HResult.E_INVALIDARG;
                    goto lDone;
                }

                // loop through the subscriptions to remove.
                int offsetRequest = sizeof(UNSUBSCRIBE_MESSAGE);
                for (int iData = 0; iData < pMessage->dwNumDataObjects; iData++)
                {
                    DATA_OBJECT_SPECIFIER *pDataRequest = (DATA_OBJECT_SPECIFIER *)&(pReqBuffer[offsetRequest]);

                    // tear down subscription.
                    ctx.m_cliConn.RemoveSubscription(ref *pDataRequest, pMessage->header.dwUserIndexFlags);

                    ctx.AddLogParameter(CacheUtil.GetDataKeyString(ref *pDataRequest));

                    offsetRequest += sizeof(DATA_OBJECT_SPECIFIER);
                }
            }            

        lDone:

            // build a response.            
            int cbSend = sizeof(UNSUBSCRIBE_REPLY_MESSAGE);
            byte[] rgbResponse = XConnSrvEngine.GetSendBuffer(cbSend);
            fixed (byte *pBuffer = &(rgbResponse[0]))
            {
                UNSUBSCRIBE_REPLY_MESSAGE *pReply = (UNSUBSCRIBE_REPLY_MESSAGE *)pBuffer;

                BuildErrorReply(ref pReply->errorMsg, 
                    (uint)MESSAGE_TYPES.eUnsubscribeReply, 
                    ctx.m_dwSeqNum, 
                    ctx.m_dwUserIndexFlags, 
                    (uint)cbSend, 
                    ctx.m_hr);
            }

            ctx.m_cliConn.Send(rgbResponse, cbSend);

            ctx.AddLogParameter(SubNotiDefs.MessageTypeToString((uint)MESSAGE_TYPES.eUnsubscribeReply));
            ctx.AddLogParameter(ctx.m_hr);           

            ctx.CompleteAPI();
        }
        
        public static unsafe void ProcessQueryMessage(UserRequestContext ctx)
        {
            // container for any data reads we need to do.
            BulkDataRetrievalContext dataCtx = new BulkDataRetrievalContext(QueryMessageComplete, ctx);

            fixed (byte *pReqBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                QUERY_MESSAGE *pMessage = (QUERY_MESSAGE *)pReqBuffer;

                ctx.AddLogParameter(pMessage->dwNumDataObjects);

                if (pMessage->dwNumDataObjects > Config.GetUIntSetting(Setting.XConnSrv_MaxObjectsPerMessage))
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_TOO_MANY_OBJECTS, "ProcessQueryMessage: message from client " + 
                        ctx.m_cliConn.IPAddress + " contains too many objects (" + pMessage->dwNumDataObjects + ").");
                    ctx.m_hr = HResult.E_INVALIDARG;
                    goto lDone;
                }

                // loop through the items to fetch.
                int offsetRequest = sizeof(QUERY_MESSAGE);
                for (int iData = 0; iData < pMessage->dwNumDataObjects; iData++)
                {
                    DATA_OBJECT_SPECIFIER *pDataRequest = (DATA_OBJECT_SPECIFIER *)&(pReqBuffer[offsetRequest]);

                    // add this item to fetch from memcache.
                    dataCtx.AddDataObject(ref *pDataRequest);

                    ctx.AddLogParameter(CacheUtil.GetDataKeyString(ref *pDataRequest));

                    offsetRequest += sizeof(DATA_OBJECT_SPECIFIER);
                }
            }            

        lDone:

            if (HResult.Failed(ctx.m_hr) || (dataCtx.NumObjects == 0))
            {
                // skip getting the data.
                QueryMessageComplete(dataCtx, ctx);
            }
            else
            {
                // go get the data.
                XConnSrvEngine.QueueContext(ThreadType.eData, dataCtx, null);
            }
        }            

        public static unsafe void QueryMessageComplete(BulkDataRetrievalContext dataCtx, Object state)
        {
            UserRequestContext ctx = state as UserRequestContext;
            object[] rgCustomData = new object[dataCtx.NumObjects];

            // calculate the buffer size;
            int cbResponse = sizeof(QUERY_REPLY_MESSAGE);
            for (int iItem = 0; iItem < dataCtx.NumObjects; iItem++)
            {
                DATA_OBJECT_SPECIFIER doSpec = dataCtx.GetItemSpecifier(iItem);
                byte[] rgbItem = dataCtx.GetItemData(iItem);

                // do any custom formatting and store the result.
                rgCustomData[iItem] = (byte[])DataUtilities.CustomizeDataForUser(rgbItem, ctx.m_cliConn, ctx.m_dwUserIndexFlags, doSpec.wObjectSize);
                
                cbResponse += ((byte[])rgCustomData[iItem]).Length;
            }

            // make response buffer.
            byte[] rgbResponse = XConnSrvEngine.GetSendBuffer(cbResponse);

            // build the header.
            fixed (byte *pRespBuffer = &(rgbResponse[0]))
            {
                QUERY_REPLY_MESSAGE *pReply = (QUERY_REPLY_MESSAGE *)pRespBuffer;

                BuildErrorReply(ref pReply->errorMsg, 
                    (uint)MESSAGE_TYPES.eQueryReply, 
                    ctx.m_dwSeqNum, 
                    ctx.m_dwUserIndexFlags, 
                    (uint)cbResponse, 
                    ctx.m_hr);

                pReply->dwNumDataObjects = (uint)dataCtx.NumObjects;
            }

            // copy all the data items.            
            int offsetResponse = sizeof(QUERY_REPLY_MESSAGE);
            for (int iItem = 0; iItem < dataCtx.NumObjects; iItem++)
            {
                byte[] rgbItem = (byte[])rgCustomData[iItem];

                System.Buffer.BlockCopy(rgbItem, 0, rgbResponse, offsetResponse, rgbItem.Length);

                offsetResponse += rgbItem.Length;
            }

            ctx.m_cliConn.Send(rgbResponse, cbResponse);

            ctx.AddLogParameter(SubNotiDefs.MessageTypeToString((uint)MESSAGE_TYPES.eQueryReply));
            ctx.AddLogParameter(ctx.m_hr);           

            ctx.CompleteAPI();
        }
        
        public static unsafe void ProcessPublishMessage(UserRequestContext ctx)
        {
            fixed (byte *pReqBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                PUBLISH_MESSAGE *pMessage = (PUBLISH_MESSAGE *)pReqBuffer;

                ctx.AddLogParameter(pMessage->dwNumDataObjects);

                if (pMessage->dwNumDataObjects > Config.GetUIntSetting(Setting.XConnSrv_MaxObjectsPerMessage))
                {
                  Xom.NtEvent(XEvent.Id.XCONNSRV_TOO_MANY_OBJECTS, "ProcessPublishMessage: message from client " + 
                        ctx.m_cliConn.IPAddress + " contains too many objects (" + pMessage->dwNumDataObjects + ").");
                    ctx.m_hr = HResult.E_INVALIDARG;
                    goto lDone;
                }

                // loop through the items to push.
                int offsetRequest = sizeof(PUBLISH_MESSAGE);
                for (int iData = 0; iData < pMessage->dwNumDataObjects; iData++)
                {
                    DATA_OBJECT_SPECIFIER *pDataRequest = (DATA_OBJECT_SPECIFIER *)&(pReqBuffer[offsetRequest]);

                    string sKey = CacheUtil.GetDataKeyString(ref *pDataRequest);
                    ctx.AddLogParameter(sKey);

                    // copy the data
                    byte[] rgbValue = new byte[pDataRequest->wObjectSize];
                    System.Buffer.BlockCopy(ctx.m_rgbEntireMessage, offsetRequest, rgbValue, 0, rgbValue.Length);

                    // make a context to write the data to memcache
                    DataPublishContext dataCtx = new DataPublishContext(sKey, rgbValue);
                    XConnSrvEngine.QueueContext(ThreadType.eWorker, dataCtx, null);

                    offsetRequest += (int)pDataRequest->wObjectSize;
                }
            }

        lDone:

            int cbSend = sizeof(PUBLISH_REPLY_MESSAGE);
            byte[] rgbResponse = XConnSrvEngine.GetSendBuffer(cbSend);
            fixed (byte *pBuffer = &(rgbResponse[0]))
            {
                PUBLISH_REPLY_MESSAGE *pReply = (PUBLISH_REPLY_MESSAGE *)pBuffer;

                BuildErrorReply(ref pReply->errorMsg, 
                    (uint)MESSAGE_TYPES.ePublishReply, 
                    ctx.m_dwSeqNum, 
                    ctx.m_dwUserIndexFlags, 
                    (uint)cbSend, 
                    ctx.m_hr);
            }

            ctx.m_cliConn.Send(rgbResponse, cbSend);

            ctx.AddLogParameter(SubNotiDefs.MessageTypeToString((uint)MESSAGE_TYPES.ePublishReply));
            ctx.AddLogParameter(ctx.m_hr);

            ctx.CompleteAPI();
        }
        
        public static unsafe void ProcessUnsupportedMessage(UserRequestContext ctx)
        {
            uint dwMsgType;
            
            fixed (byte *pBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                BASE_MESSAGE_HEADER *pHeader = (BASE_MESSAGE_HEADER *)pBuffer;
                dwMsgType = pHeader->dwMessageType;
            }

          Xom.NtEvent(XEvent.Id.XCONNSRV_MSGTYPE_UNSUPPORTED, "Unsupported message type (" + dwMsgType + ") from client " + ctx.m_cliConn.IPAddress + ".");

            ctx.m_cliConn.Disconnect();
        }

        public static void BuildErrorReply(ref ERROR_REPLY_MESSAGE errorMsg, uint dwMsgType, uint dwSeqNum, uint dwUserIndexFlags, uint dwSize, HResult hr)
        {
            errorMsg.header.dwProtocolVersion = SubNotiDefs.CURRENT_PROTOCOL_VERSION;
            errorMsg.header.dwMessageType = dwMsgType;
            errorMsg.header.dwSeqNum = dwSeqNum;
            errorMsg.header.dwUserIndexFlags = dwUserIndexFlags;
            errorMsg.header.dwTotalSize = dwSize;
            errorMsg.hr = (int) (uint) hr;
        }

        public delegate void MessageHandlerProc(UserRequestContext ctx);
        
        private class MessageHandler
        {
            public MessageHandler(uint msgType, uint minSize, MessageHandlerProc handler)
            {
                dwMsgType = msgType;
                dwMinSize = minSize;
                HandleMessageType = handler;
            }
            
            public uint dwMsgType;
            public uint dwMinSize;
            public MessageHandlerProc HandleMessageType;
        };
    };

    public delegate void GetSGInfoCompletionProc(SGInfo sginfo, Exception excep, Object state);
    
    public class GetSGInfoContext : XConnSrvContext
    {
        protected SGInfo m_sginfo;
        protected Exception m_excep;
        protected string m_sIPPort;
        protected Object m_completionState;
        protected GetSGInfoCompletionProc m_completionProc;

        public GetSGInfoContext(string sIPPort, GetSGInfoCompletionProc completionProc, Object state)
        {
            m_sIPPort = sIPPort;
            m_completionState = state;
            m_completionProc = completionProc;
        }

        public void Fetch()
        {
            XConnSrvEngine.QueueContext(ThreadType.eData, this, null);
        }

        public override void ProcessInternal(Object state)
        {
            switch (m_threadType)
            {
            case ThreadType.eData:
                
                try
                {
                    m_sginfo = new SGInfo(m_sIPPort);
                }
                catch (Exception e)
                {
                    m_excep = e;
                    m_sginfo = null;
                }

                XConnSrvEngine.QueueContext(ThreadType.eWorker, this, null);
                break;
                
            case ThreadType.eWorker:
                
                m_completionProc(m_sginfo, m_excep, m_completionState);
                break;

            default:
                
                // arrgh?
                Debug.Assert(false, "GetSGInfoContext:ProcessInternal() called on unknown thread type.");
                break;
            }
        }
    }
    

    [XomPerformanceCounterCategoryAttr( "Connection Svc - API", "Xbox Live Connection Server Per API Counters" )]
    public class XConnSrvAPICounters : XomPerformanceCounterCategory
    {
        public XConnSrvAPICounters() : base(true)
        {
        }
               
        public virtual XConnSrvAPICounters this[uint dwMsgType]
        {
            get
            {
                return (XConnSrvAPICounters) GetInstance(SubNotiDefs.MessageTypeToString(dwMsgType));
            }
        }

        static public XConnSrvAPICounters Total = new XConnSrvAPICounters();
        
        [XomPerformanceCounterAttr(
            "Requests per Second", 
            "Number of requests per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Average Response Time (ms)", 
            "Average time (in milliseconds) a request takes to be processed.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter ResponseTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Respone Time Base", 
            "Base for Average time a request takes to be processed.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter ResponseTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Success Rate", 
            "Number of requests succeeded per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SuccessRate;

        [XomPerformanceCounterAttr(
            "Failure Rate", 
            "Number of requests failed per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailureRate;

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\gui\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\XConnSrv.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Net;
using System.Text;
using System.Timers;

using xonline.common.mgmt;
using xonline.common.service;

using System.Threading;
using xonline.common.config;

using MS.Msn.Messenger.Runtime;

[assembly: ConfigAttribute(xonline.common.config.Component.XConnSrv)]

[assembly: XomAreaDefinition(XomAreaName.XConnSrvLog)]
[assembly: XomAreaDefinition(XomAreaName.XConnSrvConnection)]
[assembly: XomAreaDefinition(XomAreaName.XConnSrvSubscription)]
[assembly: XomAreaDefinition(XomAreaName.XConnSrvCache)]
[assembly: XomAreaDefinition(XomAreaName.XConnSrvAPI)]

namespace xonline.server.XConnSrv
{
    public class XConnSrv : System.ServiceProcess.ServiceBase
    {
        private TcpConnectionListener m_ConnListener = null;

        private DataSubscriptionTable m_DataSubscriptions = null;
        public DataSubscriptionTable DataSubscriptions
        {
            get
            {
                return m_DataSubscriptions;
            }
        }

        private UserConnectionTable m_UserConnections = null;
        public UserConnectionTable UserConnections
        {
            get
            {
                return m_UserConnections;
            }
        }

        private bool m_fRunAsConsole = false;

        private IInterfaceInfo m_iface = null;
        public IInterfaceInfo LocalInterfaceInfo
        {
            get
            {
                return m_iface;
            }
        }

        private static XConnSrv _instance = null;
        public static XConnSrv Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new XConnSrv();
                }
                return _instance;
            }
        }
        
        public XConnSrv()
        {          
        }

        public void Log(string sDelim, params Object[] args)
        {
            StringBuilder sb = new StringBuilder();
            for (int iArg = 0; iArg < args.Length; iArg++)
            {
                sb.Append((args[iArg] == null) ? "{null}" : args[iArg]);

                if (iArg < args.Length - 1)
                    sb.Append(sDelim);
            }

            Log(sb.ToString());
        }

        public void Log(string output)
        {
            if (m_fRunAsConsole)
            {
                Console.WriteLine(output);
            }
            
            Xom.Log(XomAreaName.XConnSrvLog, output);
        }
        
        /// <summary>
        /// Set things in motion so your service can do its work.
        /// </summary>
        protected override void OnStart(string[] args)
        {           
            InitService();            
            Xom.NtEvent(XEvent.Id.XCONNSRV_STARTED, "Connection server has been started.");
        }
 
        /// <summary>
        /// Stop this service.
        /// </summary>
        protected override void OnStop()
        {
            CloseService();
            _instance = null;
            Xom.NtEvent(XEvent.Id.XCONNSRV_SHUTDOWN, "Connection server has been shutdown.");
        }

        public void Start()
        {
            OnStart(null);
        }

        private void InitService()
        {                   
            try
            {
                Config.Assembly = System.Reflection.Assembly.GetExecutingAssembly();
                XomLoggingControl.Init();

                m_iface = Config.GetInterface(Interface.XConnSrv);
                IVirtualInterfaceInfo ivii = Config.GetVirtualInterface(VirtualInterface.XConnSrv);
                int cLookupTableBuckets = Config.GetIntSetting(Setting.XConnSrv_NumLookupTableBuckets);
                IPEndPoint ipListen = new IPEndPoint(IPAddress.Any, ivii.Port);
                int cbReadBuffer = Config.GetIntSetting(Setting.XConnSrv_SocketBufferSize);
                int cbWriteBuffer = Config.GetIntSetting(Setting.XConnSrv_SocketBufferSize);
                int cMaxSockets = Config.GetIntSetting(Setting.XConnSrv_MaxClientSockets);
                uint tcpKeepAliveTimeout = Config.GetUIntSetting(Setting.XConnSrv_TCPKeepAliveTimeout);

                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

                m_DataSubscriptions = new DataSubscriptionTable(cLookupTableBuckets);
                m_UserConnections = new UserConnectionTable(cMaxSockets * 2);

                XomPerformanceCounterCategory counters;
                counters = XConnSrvCounters.Current;
                counters = XConnSrvSubscriptionCounters.Total;
                counters = XConnSrvEngineCounters.Total;
                counters = XConnSrvCacheCounters.Current;
                counters = XConnSrvAPICounters.Total;

                XConnSrvEngine.Init();
                MemCache.Init();

                m_ConnListener = new TcpConnectionListener(
                    ipListen,
                    cbReadBuffer,
                    cbWriteBuffer,
                    cMaxSockets,
                    tcpKeepAliveTimeout);

                m_ConnListener.Connected += ClientConnection.OnConnect;
                
                m_ConnListener.Start();

                // Register for setting changes
                Config.InterfaceBucketChange += ChangeBucketMap;
                Config.SettingChange += OnSettingChange;

                xonline.common.health.HealthListener.InitializeHealthListener(Config.ComponentName);
                
                Log("|", "INIT", "Connection Server initialized.");
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.XCONNSRV_STARTUP_FAILURE, e, "Failed to initialize connection server.");
                throw;
            }
        }

        private void CloseService()
        {
            Log("|", "SHTDWN", "Connection Server shutting down.");

            // the self destruct system will activate in 3, 2, 1..
            System.Timers.Timer timer = new System.Timers.Timer(3000);
            timer.Elapsed += new ElapsedEventHandler(delegate(object sender, ElapsedEventArgs e){ Environment.Exit(0); });
            timer.AutoReset = false;
            timer.Enabled = true;
                
            ((IDisposable)m_ConnListener).Dispose();

            MemCache.Shutdown();
            XConnSrvEngine.Shutdown();

            XomLoggingControl.Close();
        }

        string HelpString
        {
            get
            {
                return 
                "\r\nXConnSrv Commands:\r\n\r\n" +
                "\thelp:\tshow this help message.\r\n" +
                "\tuserlocation <userid (decimal)>:\tshow connection server location for a user.\r\n" +                
                "\tshowcachedata <cache key>:\tshow contents of cache for a key.\r\n" +                
                "\tshowsubscribers <cache key>:\tshow subscribers to a key.\r\n" +                
                "\tshowuser <userid (decimal)>:\tshow information stored for a user.\r\n" +
                "\tshowfriends <userid (decimal)>:\tshow friends list stored for a user.\r\n" +
                "\tshowsginfo <userid (decimal)>:\tshow cached SG Info for a user.\r\n" +
                "\tdisconnect <userid (decimal)>:\tforce disconnect a user.\r\n" +
                "\r\n\tquit:\tshutdown server (console mode only).\r\n\r\n";
            }
        }

        string HandleManangementCommand(ControlRequestEventArgs args)
        {
            switch (args.Command.ToLower())
            {
                case "help":
                    // leave handled as false to allow for all handlers to process help.
                    return HelpString;

                case "userlocation":
                    args.Handled = true;
                    return MemCache.AdminShowUserLocation(UInt64.Parse(args.CommandArgs[0]));

                case "showcachedata":
                    args.Handled = true;
                    return MemCache.AdminShowCacheData(args.CommandArgs[0]);
                                                
                case "showsubscribers":
                    args.Handled = true;
                    return DataSubscriptions.AdminShowSubscribers(args.CommandArgs[0]);
                                                
                case "showuser":
                    args.Handled = true;
                    return ClientConnection.AdminShowConnectionInfo(UInt64.Parse(args.CommandArgs[0]));
                        
                case "showfriends":
                    args.Handled = true;
                    return ClientConnection.AdminShowFriends(UInt64.Parse(args.CommandArgs[0]));
                        
                case "showsginfo":
                    args.Handled = true;
                    return ClientConnection.AdminShowSGInfo(UInt64.Parse(args.CommandArgs[0]));
                        
                case "disconnect":
                    args.Handled = true;
                    return MemCache.AdminDisconnectUser(UInt64.Parse(args.CommandArgs[0]));
                        
                case "quit":
                    args.Handled = true;
                    if (m_fRunAsConsole != true)
                    {
                        return "Server running in service mode.  Cannot quit.\r\n";
                    }
                    else
                    {
                        m_fRunAsConsole = false;
                        return "Exiting.\r\n";
                    }
                        
                default:
                    return "";
            }
        }

        void RunAsConsole(string[] args)
        {
            OnStart(args);

            try
            {
                Console.WriteLine("Running as console.  Type \"help\" for commands.");

                while (m_fRunAsConsole)
                {
                    string sCommand = Console.ReadLine();
                    string sResponse = "Invalid Command\r\n";
                    try
                    {
                        ControlRequestEventArgs cmdArgs = new ControlRequestEventArgs(sCommand, 0);
                        sResponse = HandleManangementCommand(cmdArgs);
                    }
                    catch (Exception e)
                    {
                        Console.Write("Error: " + e.ToString() + "\r\n\r\n");
                    }

                    Console.Write(sResponse);
                }
            }
            finally
            {
                OnStop();
            }
        }

        // The main entry point for the process
        static void Main(string[] args)
        {           
            XConnSrv srv = XConnSrv.Instance;
            
            foreach (string sArg in args)
            {
                if (sArg.ToLower().Contains("console"))
                {
                    srv.m_fRunAsConsole = true;
                }
            }

            if (srv.m_fRunAsConsole)
            {
                srv.RunAsConsole(args);
            }
            else
            {
                System.ServiceProcess.ServiceBase.Run(srv);
            }
        }

        //This is implemented solely so that bucket remapping will now succeed. 
        //See config.cs func RefreshInterfaceBuckets() -- if you don't add a bucketchange delegate
        //then the bucket change will NOT update the cache, breaking in Xenon 91109.
        public static void ChangeBucketMap(object sender, InterfaceBucketChangeEventArgs e)
        {
            return;
        }
        
        // -------------------------------------------------------------------------
        // OnSettingChange - handles changes to npdb settings
        // -------------------------------------------------------------------------
        public static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            return;
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string sResponse = XConnSrv.Instance.HandleManangementCommand(args);
                XomControlConnection.SendMessage(sResponse, args.RequestId);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

    }        

    [XomPerformanceCounterCategoryAttr( "Connection Svc", "Xbox Live Connection Server" )]
    public class XConnSrvCounters : XomPerformanceCounterCategory
    {
        public XConnSrvCounters() : base(true)
        {
        }
        
        static public XConnSrvCounters Current = new XConnSrvCounters();
        
        [XomPerformanceCounterAttr(
            "Connection Rate", 
            "Total number of connections being created per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ConnectRate;
        
        [XomPerformanceCounterAttr(
            "Reconnection Rate", 
            "Number of connections being recreated per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ReconnectRate;
        
        [XomPerformanceCounterAttr(
            "Client Connections", 
            "Total number of connected clients.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumConnections;
        
        [XomPerformanceCounterAttr(
            "Connected Users", 
            "Total number of connected users.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumUsers;
        
        [XomPerformanceCounterAttr(
            "Total Subscriptions", 
            "Total number of data subscriptions.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumSubscriptions;
        
        [XomPerformanceCounterAttr(
            "Free Send Buffers", 
            "Number of send buffers free in the buffer pool.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FreeSendBuffers;
        
        [XomPerformanceCounterAttr(
            "Total Send Buffers", 
            "Total number of send buffers.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalSendBuffers;
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\mctest\MCClient.cs ===
using System;
using System.Diagnostics;
using System.Collections;

using xonline.server.XConnSrv;

namespace xonline.test.MCService
{
    public class MCClient : IMemCache
    {
        private static MCClientConnection connection = null;

        public MCClient()
        {
            System.Xml.XmlDocument doc = new System.Xml.XmlDocument();
            string xmlFile = AppDomain.CurrentDomain.BaseDirectory + "MCTest.xml";
            doc.Load(xmlFile);

            // xml
            System.Xml.XmlNode node = doc.FirstChild;
            // mctest
            node = node.NextSibling;
            // servername
            node = node.FirstChild;
            string server = node.InnerText;
            // server port
            node = node.NextSibling;
            string serverPort = node.InnerText;
            
            System.Net.IPEndPoint ep = new System.Net.IPEndPoint(System.Net.IPAddress.Parse(server), Int32.Parse(serverPort));
            connection = new MCClientConnection(ep, server);
        }

        public byte[] RequestData(string key)
        {
            MCGetSingleMsg req = new MCGetSingleMsg(key);
            return connection.IssueRequest(req, true);
        }

        public void PublishData(string key, byte[] data)
        {
            MCSetSingleMsg req = new MCSetSingleMsg(key, data);
            connection.IssueRequest(req, false);
        }

        public DataChangeNotification DataChangeNotificationEvent
        {
            get
            {
                return null;
            }
            set
            {
                MCClientConnection.Notification += value;
            } 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\server\msgr\TcpStream.cs ===
//-----------------------------------------------------------------------
// <copyright file="TcpStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
// TcpStream is an abstraction of the network connection.
// TcpConnection and TlsConnection are derived from this class.
// A System.IO.Stream implementation is provided via the Stream property for reading
// and writing. [However it does not derive from Stream because this prevents common 
// functionality from being added to the TcpStream base class]
// </summary>
//-----------------------------------------------------------------------

namespace MS.Msn.Messenger.Runtime
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.Threading;
    using System.IO;
    using System.Net.Sockets;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    /// <summary>
    /// TcpStream is an abstraction of the network connection.
    /// TcpConnection and TlsConnection are derived from this class.
    /// A System.IO.Stream implementation is provided via the Stream property for reading
    /// and writing. [However it does not derive from Stream because this prevents common 
    /// functionality from being added to the TcpStream base class]
    /// </summary>
    public class TcpStream : Stream
    {
        private Queue<WriteAsyncResult> writeBufferQueue = new Queue<WriteAsyncResult>();
        private int sock;
        private SocketLayer socketLayer;
        private ReadCallback readCallback;
        private WriteCallback writeCallback;
        private ReadAsyncResult currentReadState;
        private WriteAsyncResult currentWriteState;
        private bool writePending = false;
        private int firedDisconnected;

        /// <summary>
        /// The TcpStream class is created by the TcpConnectionListener so no public
        /// constructor is exposed.
        /// 
        /// </summary>
        /// <param name="sock">the underlying socket</param>
        /// <param name="socketLayer">parent socket layer</param>
        internal TcpStream(int sock, SocketLayer socketLayer)
            : base()
        {
            this.sock = sock;
            this.socketLayer = socketLayer;
            this.readCallback = new ReadCallback(this.OnReadCompleted);
            this.writeCallback = new WriteCallback(this.OnWriteCompleted);
        }

        /// <summary>
        /// Dispose of this stream and free up the socket.
        /// </summary>
        ~TcpStream()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Disconnect delegate
        /// </summary>
        /// <param name="sender">Stream that is being closed</param>
        /// <param name="reason">exception that was thrown (if any)</param>
        public delegate void DisconnectedEventHandler(TcpStream sender, Exception reason);

        /// <summary>
        /// Event that is invoked when a connection is disconnected
        /// A consumer of this method is the ConnectionController.
        /// </summary>
        public event DisconnectedEventHandler Disconnected;

        /// <summary>
        /// True.  Stream is readable.
        /// </summary>
        public override bool CanRead
        {
            get { return true; }
        }

        /// <summary>
        /// False.  (Stream does not support seek)
        /// </summary>
        public override bool CanSeek
        {
            get { return false; }
        }

        /// <summary>
        /// True.  Stream is writeable.
        /// </summary>
        public override bool CanWrite
        {
            get { return true; }
        }

        /// <summary>
        /// Throws exception.  (Stream does not support seek)
        /// </summary>
        public override long Length
        {
            get { throw new NotSupportedException("Cannot seek."); }
        }

        /// <summary>
        /// Throws exception.  (Stream does not support seek)
        /// </summary>
        public override long Position
        {
            get
            {
                throw new NotSupportedException("Cannot seek.");
            }

            set
            {
                throw new NotSupportedException("Cannot seek.");
            }
        }

        /// <summary>
        /// Socket ID
        /// </summary>
        public int Sock
        {
            get { return this.sock; }
        }

        /// <summary>
        /// Returns the remote IP address.
        /// </summary>
        public IPAddress IPAddress
        {
            get { return this.socketLayer.IPAddress(this.sock); }
        }

        /// <summary>
        /// Returns the remote port.
        /// </summary>
        public ushort Port
        {
            get { return this.socketLayer.Port(this.sock); }
        }

        /// <summary>
        /// Async read.  Blocks until bytes are received.  Should not be used except in testing.
        /// </summary>
        /// <param name="buffer">buffer to copy data to</param>
        /// <param name="offset">offset</param>
        /// <param name="count">max number of bytes to copy</param>
        /// <returns>number of bytes actually read.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            IAsyncResult result = this.BeginRead(buffer, offset, count, null, null);
            return this.EndRead(result);
        }

        /// <summary>
        /// Sync write.  Should only be called in unit tests, etc.  Not efficient.
        /// </summary>
        /// <param name="buffer">data to write</param>
        /// <param name="offset">offset from which to begin writing data</param>
        /// <param name="count">number of bytes to write</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            IAsyncResult result = this.BeginWrite(buffer, offset, count, null, null);
            this.EndWrite(result);
        }

        /// <summary>
        /// Not Supported
        /// </summary>
        /// <param name="offset">ignored</param>
        /// <param name="origin">ignored</param>
        /// <returns>nothing</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("Cannot seek.");
        }

        /// <summary>
        /// Not Supported
        /// </summary>
        /// <param name="value">ignored</param>
        public override void SetLength(long value)
        {
            throw new NotSupportedException("Cannot seek.");
        }

        /// <summary>
        /// Does nothing.  Writes are already flushed immediately.
        /// </summary>
        public override void Flush()
        {
            // Ignored.
        }

        /// <summary>
        /// Supply a buffer to read bytes into if data comes over the stream.
        /// </summary>
        /// <param name="buffer">byte buffer</param>
        /// <param name="offset">offset to start copying data to</param>
        /// <param name="size">number of bytes available in buffer</param>
        /// <param name="callback">callback</param>
        /// <param name="state">async state</param>
        /// <returns>async result</returns>
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback callback, object state)
        {
            // We shouldn't pass in a buffer that is smaller than we might possibly get back.
            if (this.socketLayer.ReadBufferSize > size)
            {
                string message = string.Format(
                    "Buffer passed in is too small ({0} bytes).  Must be at least as big as the socket buffer ({1} bytes)",
                    size,
                    this.socketLayer.ReadBufferSize);

                throw new ArgumentException(message, "size");
            }

            ReadAsyncResult result = new ReadAsyncResult(new BufferOffsetSize(buffer, offset, size, false), callback, state);

            int socketIndex = this.sock;

            if (socketIndex != -1)
            {
                // BUGBUG bgarris: technically we should probably lock on this, but we
                // have a logic bug if we can ever have simultaneous reads, so this shouldn't
                // be a problem.  (MySocket will throw an exception anyway)
                // Ultimately, it should be the MySocket layer that implements
                // a Begin/End pattern to solve this problem, but for now, this should be fine.
                this.currentReadState = result;

                SocketError error = this.socketLayer.PostRead(socketIndex, this.readCallback);
                if (error != SocketError.Success)
                {
                    result.CompleteRequest(error, true);
                }
            }

            return result;
        }

        /// <summary>
        /// End a read - should only be called in the callback passed into beginread,
        /// or (if sync is OK) with the return value of BeginRead.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginRead or passed into the callback.</param>
        /// <param name="result">SocketError.Success if OK.  Some other error if not.</param>
        /// <returns>Number of bytes read</returns>
        public int EndRead(IAsyncResult asyncResult, out SocketError result)
        {
            ReadAsyncResult state = (ReadAsyncResult)asyncResult;
            state.BlockUntilCompleted();

            result = state.Result;
            return state.BytesRead;
        }

        /// <summary>
        /// End a read - should only be called in the callback passed into beginread,
        /// or (if sync is OK) with the return value of BeginRead.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginRead or passed into the callback.</param>
        /// <exception cref="SocketException"></exception>
        /// <returns>Number of bytes read</returns>
        public override int EndRead(IAsyncResult asyncResult)
        {
            SocketError result;
            int bytesRead = this.EndRead(asyncResult, out result);
            if (result != SocketError.Success)
            {
                throw new SocketException((int)result);
            }

            return bytesRead;
        }

        /// <summary>
        /// Post a write.
        /// </summary>
        /// <param name="buffer">backing buffer.  should not be modified while write is being made.</param>
        /// <param name="offset">starting position to begin writing from</param>
        /// <param name="size">number of bytes to write</param>
        /// <param name="callback">callback to make after write is completed.</param>
        /// <param name="state">async state</param>
        /// <returns>async result</returns>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int size, AsyncCallback callback, object state)
        {
            WriteAsyncResult result = new WriteAsyncResult(new BufferOffsetSize(buffer, offset, size, false), callback, state);
            AsyncResult<SocketError> resultToReturn = result;

            int socketIndex = this.sock;

            if (socketIndex == -1)
            {
                result.CompleteRequest(SocketError.Shutdown, true);
                return resultToReturn;  // BUGBUG bgarris: I don't like this comment that seems unsure of why we might
                                        // return here:
                                        // "got disposed?"
            }

            lock (this.writeBufferQueue)
            {
                if (size > this.socketLayer.WriteBufferSize)
                {
                    AggregateWriteAsyncResult parent = new AggregateWriteAsyncResult(result, this.socketLayer.WriteBufferSize, callback, state);
                    foreach (WriteAsyncResult subWrite in parent.SubWrites)
                    {
                        this.writeBufferQueue.Enqueue(subWrite);
                    }

                    resultToReturn = parent;

                    if (this.writePending)
                    {
                        return resultToReturn;
                    }
                    else
                    {
                        // we'll start writing the first one.  note that the result we're returning is still the
                        // parent state.
                        result = CoelesceWrites(socketIndex);
                    }
                }
                else
                {
                    if (this.writePending)
                    {
                        this.writeBufferQueue.Enqueue(result);
                        return resultToReturn;
                    }
                }

                this.writePending = true;
            }

            // we have logic to prevent PostWrite from being called multiple times, so as long as we only
            // assign to currentWriteState right before a PostWrite, we should be fine.
            this.currentWriteState = result;

            SocketError error = this.socketLayer.PostWrite(
                socketIndex,
                this.currentWriteState.Buffer.Buffer,
                this.currentWriteState.Buffer.Offset,
                this.currentWriteState.Buffer.Size,
                this.writeCallback);

            if (error != SocketError.Success)
            {
                this.currentWriteState.CompleteRequest(error, true);
            }

            // this might be an aggregate write or a normal write.
            return resultToReturn;
        }

        /// <summary>
        /// End a write - should only be called in the callback passed into beginwrite,
        /// or (if sync is OK) with the return value of BeginWrite.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginWrite or passed into the callback.</param>
        /// <param name="result">SocketError.Success if OK.  Some other error if not.</param>
        public void EndWrite(IAsyncResult asyncResult, out SocketError result)
        {
            AsyncResult<SocketError> state = (AsyncResult<SocketError>)asyncResult;
            state.BlockUntilCompleted();
            result = state.Result;
        }

        /// <summary>
        /// End a write - should only be called in the callback passed into beginwrite,
        /// or (if sync is OK) with the return value of BeginWrite.
        /// </summary>
        /// <exception cref="SocketException"></exception>
        /// <param name="asyncResult">the async result returned from BeginWrite or passed into the callback.</param>
        public override void EndWrite(IAsyncResult asyncResult)
        {
            SocketError result;
            this.EndWrite(asyncResult, out result);
            if (result != SocketError.Success)
            {
                throw new SocketException((int)result);
            }
        }

        /// <summary>
        /// Dispose and close this socket.
        /// </summary>
        /// <param name="disposing">whether or not we're disposing</param>
        protected override void Dispose(bool disposing)
        {
            int disposeSocketIndex = Interlocked.Exchange(ref this.sock, -1);

            if (disposeSocketIndex != -1)
            {
                this.socketLayer.Close(disposeSocketIndex);
                if (disposing)
                {
                    this.OnDisconnected(null);
                }
            }
        }

        /// <summary>
        /// This function is invoked to raise the Disconnected event
        /// This could happen as a result of a network error or an explicit
        /// call to the Disconnect method
        /// </summary>
        /// <param name="reason">optional exception</param>
        private void OnDisconnected(Exception reason)
        {
            // we have to make sure that Disconnected is only called once
            int fired = Interlocked.Exchange(ref this.firedDisconnected, 1);
            if (this.Disconnected != null && fired != 1)
            {
                this.Disconnected(this, reason);
            }
        }

        private void OnReadCompleted(int socketIndex, SocketError error, IntPtr buffer, int offset, int bytes)
        {
            ReadAsyncResult state = this.currentReadState;

            if (error == SocketError.Success)
            {
                // we should have thrown an exception in BeginRead if the buffer wasn't large enough.
                Debug.Assert(bytes <= state.Buffer.Size);

                buffer = (IntPtr)(buffer.ToInt64() + offset);
                Marshal.Copy(buffer, state.Buffer.Buffer, state.Buffer.Offset, bytes);
            }

            state.CompleteRequest(error, false, bytes);
        }

        // called in the lock
        private WriteAsyncResult CoelesceWrites(int socketIndex)
        {
            MultiWriteAsyncResult states = new MultiWriteAsyncResult(this.socketLayer.WriteBufferSize);

            lock (this.writeBufferQueue)
            {
                while (this.writeBufferQueue.Count > 0)
                {
                    WriteAsyncResult state = this.writeBufferQueue.Peek();
                    if ((states.TotalSize + state.Buffer.Size) > states.MaxSize)
                    {
                        // no more room.
                        break;
                    }
                    
                    states.AddWrite(state);

                    SocketError error = this.socketLayer.PostWrite(
                        socketIndex,
                        state.Buffer.Buffer,
                        state.Buffer.Offset,
                        state.Buffer.Size,
                        null);

                    this.writeBufferQueue.Dequeue();
                }
            }

            // we shouldnt be here if the queue was empty to begin with, and nothing in the queue should be bigger than the
            // max size by itself.  so at least 1 item should have fit in the batch.
            Debug.Assert(states.TotalSize > 0);

            return states;
        }

        private void OnWriteCompleted(int socketIndex, SocketError error)
        {
            WriteAsyncResult state = this.currentWriteState;

            state.CompleteRequest(error, false);
            if (SocketError.Success != error)
            {
                // BUGBUG bgarris: ideally we should complete all of the queued writes with a failure.
                // not changing it now for parity with old code.
                return;
            }

            lock (this.writeBufferQueue)
            {
                if (this.writeBufferQueue.Count == 0)
                {
                    this.writePending = false;
                    return;
                }

                state = CoelesceWrites(socketIndex);
            }

            // we have logic to prevent PostWrite from being called multiple times, so as long as we only
            // assign to currentWriteState right before a PostWrite, we should be fine.
            this.currentWriteState = state;

            error = this.socketLayer.PostWrite(
                socketIndex,
                state.Buffer.Buffer,
                state.Buffer.Offset,
                state.Buffer.Size,
                this.writeCallback);

            if (error != SocketError.Success)
            {
                // we didn't complete synchronously because we were called in the callback of another
                // write.  (Even though this particular PostWrite call technically completed synchronously)
                state.CompleteRequest(error, false);
            }
        }

        internal class ReadAsyncResult : AsyncResult<SocketError>
        {
            private BufferOffsetSize buffer;
            private int bytesRead = 0;

            internal ReadAsyncResult(
                BufferOffsetSize buffer,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.buffer = buffer;
            }

            internal BufferOffsetSize Buffer
            {
                get { return this.buffer; }
            }

            internal int BytesRead
            {
                get { return this.bytesRead; }
                set { this.bytesRead = value; }
            }

            internal void CompleteRequest(SocketError result, bool completedSynchronously, int bytesRead)
            {
                this.bytesRead = bytesRead;
                base.CompleteRequest(result, completedSynchronously);
            }
        }

        internal class WriteAsyncResult : AsyncResult<SocketError>
        {
            private BufferOffsetSize buffer;

            internal WriteAsyncResult(
                BufferOffsetSize buffer,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.buffer = buffer;
            }

            internal BufferOffsetSize Buffer
            {
                get { return this.buffer; }
            }
        }

        internal class MultiWriteAsyncResult : WriteAsyncResult
        {
            static byte[] _emptyBuffer = new byte[0];
            
            private List<WriteAsyncResult> multiWrites;
            private int maxSize;
            private int totalSize;
            
            internal int TotalSize
            {
                get { return totalSize; }
            }

            internal int MaxSize
            {
                get { return maxSize; }
            }

            internal MultiWriteAsyncResult(int maxSize)
                : base(new BufferOffsetSize(_emptyBuffer, 0, 0, false), new AsyncCallback(OnWriteCompleted), null)
            {
                this.maxSize = maxSize;
                multiWrites = new List<WriteAsyncResult>();
            }

            internal void AddWrite(WriteAsyncResult result)
            {
                Debug.Assert((totalSize + result.Buffer.Size) <= maxSize);
                
                multiWrites.Add(result);
                totalSize += result.Buffer.Size;
            }

            public static void OnWriteCompleted(IAsyncResult asyncResult)
            {
                MultiWriteAsyncResult result = (MultiWriteAsyncResult)asyncResult;
                SocketError error = result.Result;

                foreach (WriteAsyncResult write in result.multiWrites)
                {
                    write.CompleteRequest(error, result.CompletedSynchronously);
                }
            }
        }

        /// <summary>
        /// We should use this class if a write is too large to be written in one write.
        /// It breaks the write into smaller chunks, and calls its callback when either
        /// the last one completes, or one of them completes with an error result.
        /// </summary>
        internal class AggregateWriteAsyncResult : AsyncResult<SocketError>
        {
            private List<WriteAsyncResult> subWrites;

            private bool hasAlreadyCompleted;

            internal AggregateWriteAsyncResult(
                WriteAsyncResult result,
                int maxSize,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.subWrites = this.Split(result, maxSize);
                this.hasAlreadyCompleted = false;
            }

            internal List<WriteAsyncResult> SubWrites
            {
                get { return this.subWrites; }
            }

            private List<WriteAsyncResult> Split(WriteAsyncResult result, int maxSize)
            {
                List<WriteAsyncResult> results = new List<WriteAsyncResult>();
                AsyncCallback writeCallback = new AsyncCallback(this.OnWriteCompleted);

                byte[] data = result.Buffer.Buffer;
                int offset = result.Buffer.Offset;
                int size = result.Buffer.Size;

                while (size > maxSize)
                {
                    BufferOffsetSize newBuff = new BufferOffsetSize(data, offset, maxSize, false);
                    WriteAsyncResult write = new WriteAsyncResult(newBuff, writeCallback, false);
                    results.Add(write);
                    offset += maxSize;
                    size -= maxSize;
                }

                // note that the async state is 'true' instead of 'false', to signify that this is the last
                // write.
                results.Add(new WriteAsyncResult(new BufferOffsetSize(data, offset, size, false), writeCallback, true));

                return results;
            }

            private void OnWriteCompleted(IAsyncResult asyncResult)
            {
                // no need for locking - Writes are completed one at a time.
                if (this.hasAlreadyCompleted)
                {
                    // we only want to complete if there is an error, or if we're on the last write.
                    // if we get here, that means we've already completed with an error, so we should
                    // ignore the values of all subsequent operations.
                    return;
                }

                WriteAsyncResult result = (WriteAsyncResult) asyncResult;
                bool isLastWrite = (bool)result.AsyncState;
                SocketError error = result.Result;

                if (isLastWrite || error != SocketError.Success)
                {
                    this.hasAlreadyCompleted = true;
                    this.CompleteRequest(error, result.CompletedSynchronously);
                }
            }
        }

        /// <summary>
        /// Copied from internal System.Net.BufferOffsetSize
        /// </summary>
        internal class BufferOffsetSize
        {
            private byte[] buffer;
            private int offset;
            private int size;

            internal BufferOffsetSize(byte[] buffer, bool copyBuffer)
                : this(buffer, 0, buffer.Length, copyBuffer)
            {
            }

            internal BufferOffsetSize(byte[] buffer, int offset, int size, bool copyBuffer)
            {
                if (copyBuffer)
                {
                    byte[] dst = new byte[size];
                    System.Buffer.BlockCopy(buffer, offset, dst, 0, size);
                    offset = 0;
                    buffer = dst;
                }

                this.buffer = buffer;
                this.offset = offset;
                this.size = size;
            }

            internal byte[] Buffer
            {
                get { return this.buffer; }
            }

            internal int Offset
            {
                get { return this.offset; }
            }

            internal int Size
            {
                get { return this.size; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\mctest\MCClientConnection.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Timers;
using System.Net;
using System.Net.Sockets;

using xonline.server.XConnSrv;

namespace xonline.test.MCService
{
    public class MCClientConnection
    {
        private bool _shutdown;
        private ReaderWriterLock _rwlShutdown;
        private bool _socketHealthy;
        private ReaderWriterLock _rwlSocketHealthy;
        private Socket _socket;
        private IPEndPoint _endPoint;
        private string _serverName;
        private Queue _sendQueue;
        private AutoResetEvent _sendQueueEvent;
        private Hashtable _waitTable;
        private Thread _sendThread;
        private ManualResetEvent _sendThreadStarted;
        private Thread _receiveThread;
        private ManualResetEvent _receiveThreadStarted;
        private System.Timers.Timer _timeoutTimer;

        private const int LOCK_TIMEOUT = 30000;
        private const int THREAD_START_TIMEOUT = 30000;
        private const int SEND_QUEUE_TIMEOUT = 1000;
        private const int REPLY_TIMEOUT = 60000;
        private const int SEND_TIMEOUT = 60000;

        public static event DataChangeNotification Notification;

        // Initializes a Connection to the Test Gateway server
        // indicated in the provided interfaceInfo. After this call
        // completes, the caller can safely begin to queue IGContext
        // objects using Enqueue()
        public MCClientConnection(IPEndPoint endPoint, string serverName)
        {
            // This contains the IP:port info we need to connect to
            _endPoint = endPoint;

            // we use the server name to match connections to buckets.
            _serverName = serverName;

            // Any send or receive action has to be prepared to deal with 
            // socket failures, and re-establish communications automatically.
            // This flag (and correponding lock) allow the send and receive
            // threads to communicate to each other when the socket goes
            // bad.
            _socketHealthy = false;
            _rwlSocketHealthy = new ReaderWriterLock();

            // Used to signal that the class should close the socket and
            // end the threads.
            _shutdown = false;
            _rwlShutdown = new ReaderWriterLock();

            // We call GetSocket() here to create the initial socket and connect
            // it to the INH server. That way, if there are any fundamental
            // communications problems, this thread will see the SocketException
            // right away, and won't have to wait until a Send attempt fails
            // and leaves an exception in the PresenceFDContext.
            try
            {
                GetSocket();
            }
            catch (SocketException e)
            {
                System.Diagnostics.Debug.WriteLine(e);
                // dont puke here if the server isnt up yet.
                //XomNtEvent(XEvent.Id.PRESENCE_COMM_45, "Could not establish socket to " + _serverName + ".  The server is probably not running yet.\r\n" + e.ToString());
            }

            // This is a queue of IGContexts that contains requests
            // to be sent to the Test Gateway server. It is syncronized because it is
            // shared between the request threads (which calls Init)
            // and the SendThread.
            _sendQueue = Queue.Synchronized(new Queue());

            // When a new item is put into the queue, this event is signaled,
            // which will wake up the SendThread if it has gone to sleep
            _sendQueueEvent = new AutoResetEvent(false);

            // This is a table of PresenceFDContexts (indexed by the
            // frontdoorSeqNum member) which have been sent to the INH
            // server, and are waiting on a response from the INH server
            // It is syncronized because it is shared between the SendThread,
            // the ReceiveThread, and the calling thread (via the Timeout method)
            _waitTable = Hashtable.Synchronized(new Hashtable());

            _sendThreadStarted = new ManualResetEvent(false);
            _sendThread = new Thread(new ThreadStart(this.SendThread));
            _sendThread.IsBackground = true;
            _sendThread.Start();

            _receiveThreadStarted = new ManualResetEvent(false);
            _receiveThread = new Thread(new ThreadStart(this.ReceiveThread));
            _receiveThread.IsBackground = true;
            _receiveThread.Start();

            // Kick off the timeout timer, set the interval to one half the context timeout. This should
            // mean we'll expire the context within 150% of the specified timeout, but we won't be
            // spending an inordinate amount of time looking for expired contexts.
            // The value of REPLY_TIMEOUT/2 is long compared to the amount of time we expect
            // TimeoutExpiredContext to take, so we set AutoReset to true and don't worry about
            // overlapping calls to the method.
            int interval = REPLY_TIMEOUT / 2;

            _timeoutTimer = new System.Timers.Timer(interval);
            _timeoutTimer.Elapsed += new ElapsedEventHandler(this.TimeoutExpiredContexts);
            _timeoutTimer.AutoReset = true;
            _timeoutTimer.Start();
        }

        public void Shutdown()
        {
            _rwlShutdown.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlShutdown.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    // set the shutdown flag, which will tell the send and receive
                    // threads to begin shutting down
                    _shutdown = true;
                }
                finally
                {
                    _rwlShutdown.DowngradeFromWriterLock(ref lc);
                }

                // stop the timer
                _timeoutTimer.Stop();

                // wait for the send and receive threads to shutdown
                _sendThread.Join();
                _receiveThread.Join();
            }
            finally
            {
                _rwlShutdown.ReleaseReaderLock();
            }
        }

        public bool ShuttingDown()
        {
            _rwlShutdown.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                return _shutdown;
            }
            finally
            {
                _rwlShutdown.ReleaseReaderLock();
            }
        }

        // Places a MCContext on the queue to be sent to
        // the connected INH server by SendThread, and signals the SendThread
        // to wake up. 
        // 
        // If ctx.fWaitForResponse is true then the context will be placed in
        // the hashtable of contexts waiting for a response from the INH server,
        // and when a response is received, ctx.event will be signaled. The caller
        // should call ctx.event.WaitOne with an appropriate timeout. If the event
        // is signaled, then the caller can complete the call.
        public byte[] IssueRequest(MCMessage Request, bool WaitForResponse)
        {            
            if (ShuttingDown())
            {
                throw new Exception("Enqueue called while Connection was shutting down");
            }

            MCContext fdctx = new MCContext(Request, WaitForResponse);
            _sendQueue.Enqueue(fdctx);
            _sendQueueEvent.Set();

            if (WaitForResponse)
            {
                fdctx.AsyncWaitHandle.WaitOne();
                return (byte[])(fdctx.Response);
            }
            else
            {
                return null;
            }
        }

        public void SendThread()
        {
            // signal the constructor that the thread is up and running
            _sendThreadStarted.Set();

            // keep processing work items on the queue until we break out of
            // this loop because the _shutdown flag is set
            while (true)
            {
                try
                {
                    if (!ShuttingDown())
                    {
                        // Wait for an item to be put on the queue
                        if (_sendQueueEvent.WaitOne(SEND_QUEUE_TIMEOUT, false))
                        {
                            // we have work to do
                            DrainSendQueue();
                        }
                    }
                    else
                    {
                        // need to protect the break statement at the bottom of this block, or else errors can prevent this thread from exiting.
                        try
                        {
                            // kill the socket. If we don't do this, the receive
                            // thread will never exit.
                            _socket.Shutdown(SocketShutdown.Send);
                            byte[] recvBuffer = new byte[1024];

                            // drain the receive buffer
                            while (_socket.Receive(recvBuffer) > 0);

                            // now close it
                            _socket.Close();
                        }
                        catch (Exception e)
                        {
                            System.Diagnostics.Debug.WriteLine(e);
                            //XomNtEvent(XEvent.Id.PRESENCE_COMM_46,
                            //    "Unexpected Exception thrown while shutting down SendThread for connection to INH at "
                            //    + _interfaceInfo.IPAddressString
                            //    + " Exception.Type: "
                            //    + e.GetType().ToString()
                            //    + " Exception.Message:"
                            //    + e.Message
                            //    + " Exception.StackTrace:"
                            //    + e.StackTrace);
                        }
                        
                        // we're shutting down, so break out of the loop
                        break;
                    }
                }
                catch (Exception e)
                {
                    System.Diagnostics.Debug.WriteLine(e);
                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    //XomNtEvent(XEvent.Id.PRESENCE_COMM_0,
                    //    "Unexpected Exception thrown in SendThread for connection to INH at "
                    //   + _interfaceInfo.IPAddressString
                    //    + " Exception.Type: "
                    //    + e.GetType().ToString()
                    //    + " Exception.Message:"
                    //    + e.Message
                    //    + " Exception.StackTrace:"
                    //    + e.StackTrace);
                }
            }
        }

        public void ReceiveThread()
        {
            // signal the constructor that the thread is up and running
            _receiveThreadStarted.Set();

            // keep receiving messages until we break out of
            // this loop because the _shutdown flag is set
            while (true)
            {
                try
                {
                    if (!ShuttingDown())
                    {
                        // dont try to receive if the socket is dead.
                        if (IsSocketHealthy())
                        {
                            ReceiveMessage();
                        }
                        else
                        {
                            Thread.Sleep(1000);
                        }
                    }
                    else
                    {
                        // we're shutting down, so break out of the loop
                        break;
                    }
                }
                catch (Exception e)
                {
                    System.Diagnostics.Debug.WriteLine(e);
                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    //XomNtEvent(XEvent.Id.PRESENCE_COMM_1,
                    //    "Unexpected Exception thrown in ReceiveThread for InhConnection to "
                    //    + _interfaceInfo.IPAddressString
                    //    + " Exception.Type: "
                    //    + e.GetType().ToString()
                    //    + " Exception.Message:"
                    //    + e.Message
                    //    + " Exception.StackTrace:"
                    //    + e.StackTrace);
                }
            }
        }

        public void DrainSendQueue()
        {
            // loop until queue is empty
            while (true)
            {
                MCContext fdctx = (MCContext)_sendQueue.Dequeue();
                if (fdctx != null)
                {
                    // queue is syncronized
                    try
                    {
                        if (fdctx.fWaitForResponse)
                        {
                            // store the current time in the context
                            fdctx.waitTableAdded = DateTime.Now;

                            // wait table inherits this reference.
                            _waitTable.Add(fdctx.frontdoorSeqNum, fdctx);
                        }
                        // now do the send
                        Socket s = GetSocket();
                        s.Send(fdctx.rgbRequest);
                        if (!fdctx.fWaitForResponse)
                        {
                            fdctx.CompleteRequest();
                        }
                    }
                    catch (Exception e)
                    {
                        // record the exception in the context object
                        fdctx.excep = e;

                        // removes the item from the wait table, regardless of if it's there or not.
                        _waitTable.Remove(fdctx.frontdoorSeqNum);

                        fdctx.CompleteRequest();

                        if (e is SocketException)
                        {
                            // record the exception in the event log
                            //XomNtEvent(XEvent.Id.PRESENCE_COMM_2,
                            //    "SocketException thrown calling Socket.Send() to "
                            //    + _interfaceInfo.IPAddressString + ":" + 
                            //    + _interfaceInfo.Port
                            //    + ". The front door will attempt to re-connect to the Presence INH server."
                            //    + " The health of the Presence INH server and the network should be checked."
                            //    + " SocketException.Message:"
                            //    + e.Message
                            //    + " SocketException.StackTrace:"
                            //    + e.StackTrace);

                             // invalidate the socket so the next call to 
                             // GetSocket reconnects it.
                             InvalidateSocket();
                        }
                    }
                }
                else
                {
                    // queue is empty, break out of the loop and go
                    // back to sleep.
                    break;
                }
            }
        }

        public void TimeoutExpiredContexts(object sender, ElapsedEventArgs eventArgs)
        {
            // make sure this event hasn't fired after the timer has been
            if (!_timeoutTimer.Enabled)
            {
                return;
            }

            // make sure we're not already shutting down
            if (ShuttingDown())
            {
                return;
            }

            try
            {
                ArrayList alRemoves = new ArrayList();;

                // iteration is not threadsafe even on a synchronized hashtable, so we need to lock
                // the sync root
                lock (_waitTable.SyncRoot) 
                {                    
                    foreach (DictionaryEntry de in _waitTable)
                    {
                        MCContext fdctx = (MCContext)de.Value;
                        if ((DateTime.Now - fdctx.waitTableAdded) > new TimeSpan(0,0,0,0,REPLY_TIMEOUT))
                        {
                            alRemoves.Add(fdctx);
                        }
                    }

                    System.Collections.IEnumerator enumRemoves = alRemoves.GetEnumerator();
                    while (enumRemoves.MoveNext())
                    {
                        MCContext fdctx = (MCContext)enumRemoves.Current;
                        
                        _waitTable.Remove(fdctx.frontdoorSeqNum);
                        fdctx.excep = new TimeoutException("Request timed out waiting for response");
                        fdctx.CompleteRequest();
                    }
                }
            }
            catch (Exception e)
            {
                System.Diagnostics.Debug.WriteLine(e);
                // log this exception to the event log - not much more we can do with it.
                //XomNtEvent(XEvent.Id.PRESENCE_COMM_4,
                //    "Unexpected Exception thrown in InhConnection.TimeoutExpiredContexts"
                //    + " Exception.Type: "
                //    + e.GetType().ToString()
                //    + " Exception.Message:"
                //    + e.Message
                //    + " Exception.StackTrace:"
                //    + e.StackTrace);
            }
        }

        public void ReceiveMessage()
        {
            try
            {
                Socket sock = GetSocket();
                MCMessageHeader header = new MCMessageHeader();
                int cBytes;
                int cTotalBytes;

                // Get the next header
                byte[] headerBuf = new byte[header.Size()];
                cTotalBytes = 0;
                while (cTotalBytes < header.Size())
                {
                    cBytes = sock.Receive(headerBuf, cTotalBytes, (int) header.Size() - cTotalBytes, SocketFlags.None);
                    if (cBytes == 0)
                    {
                        throw new ApplicationException( "XPNFD.InhConnection.ReceiveMessage: Received 0 bytes");
                    }
                    else
                    {
                        cTotalBytes += cBytes;
                    }
                }

                header.ReadBytes(headerBuf);

                MCMessageData Data = MCMessageData.GetInstance(header);

                // Get the body
                byte[] bodyBuf = new byte[header.dwMsgLen];
                cTotalBytes = 0;
                while (cTotalBytes < header.dwMsgLen)
                {
                    cBytes = sock.Receive(bodyBuf, cTotalBytes, (int) header.dwMsgLen - cTotalBytes, SocketFlags.None);
                    if (cBytes == 0)
                    {
                        throw new ApplicationException( "XPNFD.InhConnection.ReceiveMessage: Received 0 bytes");
                    }
                    else
                    {
                        cTotalBytes += cBytes;
                    }
                }
                Data.ReadBytes(bodyBuf);

                if (Data is MCGetSingleResponseData)
                {
                    MCGetSingleResponseData msgData = Data as MCGetSingleResponseData;
                    
                    // this data was requested
                    // find the matching MCContext in the wait table
                    // the hashtable class may store null references, but we never add one
                    // to the table, so we can skip calling Contains()
                    // this hashtable is synchronized, but we need to check for and
                    // remove the context from the hashtable as an atomic operation
                    MCContext fdctx;
                    lock (_waitTable.SyncRoot)
                    {
                        fdctx = (MCContext)_waitTable[header.dwSeqNum];
                        _waitTable.Remove(header.dwSeqNum);
                    }

                    if (fdctx != null)
                    {
                        fdctx.Response = msgData._data;
                        fdctx.CompleteRequest();
                    }

                    // TODO: Debug output
                    string debugOutput = "GET SINGLE RESPONSE: key=" + msgData._key + " (size " + msgData._keyLength + ") data=";
                    if(msgData._data != null)
                        foreach (byte b in msgData._data)
                            debugOutput += b + ", ";
                    debugOutput += "(size " + msgData._dataSize + ")";
                    Console.WriteLine(debugOutput);
                }
                else if (Data is MCNotificationResponseData)
                {
                    MCNotificationResponseData msgData = Data as MCNotificationResponseData;

                    if (Notification != null)
                        Notification(msgData._keys); // needs to be string[]

                    // TODO: Debug output
                    string debugOutput = "GET NOTIFICATION RESPONSE: keys= ";
                    if (msgData._keys != null)
                        foreach (string s in msgData._keys)
                            debugOutput += s + ", ";
                    debugOutput += "(size " + msgData._keysSize + ")";
                    Console.WriteLine(debugOutput);
                }
            }
            catch (Exception e)
            {
                // Any exceptions at all leave the stream in a bad state. We could be half way
                // through a message, or the socket could have failed, or ?
                // In any of these situations, we invalidate the socket, so we will 
                // reconnect. If there are messages already in the receive buffer,
                // they are going to be lost.
                // Any affected contexts will eventually be timed out and removed from the wait
                // table. Since we didn't successfully receive a complete message
                // we don't really trust the sequence number enough to associate this
                // exception with any particular PresenceFDContext, so we don't do anything
                // with the exception except log it.
                // However, during a shutdown, the send thread kills the socket for us,
                // so if we are shutting down, we just eat the exception and move merrily
                // along
                if (!ShuttingDown())
                {
                    InvalidateSocket();
                    System.Diagnostics.Debug.WriteLine(e);
                    //XomNtEvent(XEvent.Id.PRESENCE_COMM_5,
                    //    "Unexpected Exception thrown in ReceiveMessage"
                    //    + " Exception.Type: "
                    //    + e.GetType().ToString()
                    //    + " Exception.Message:"
                    //    + e.Message
                    //    + " Exception.StackTrace:"
                    //    + e.StackTrace);
                }
            }
        }

        // returns the server name associated with this connection.
        public string GetServerName()
        {
            return _serverName;
        }

        public bool IsSocketHealthy()
        {
            _rwlSocketHealthy.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                return _socketHealthy;
            }
            finally
            {
                _rwlSocketHealthy.ReleaseReaderLock();
            }
        }
        
        /// <summary>
        /// Gets the current socket connection, verifying the health of the socket
        /// and (re)connecting it if required
        /// </summary>
        /// <returns></returns>
        public Socket GetSocket()
        {
            _rwlSocketHealthy.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                if (_socketHealthy == false)
                {
                    LockCookie lc = _rwlSocketHealthy.UpgradeToWriterLock(LOCK_TIMEOUT);
                    try
                    {
                        // create a new socket
                        _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
                            ProtocolType.Tcp);

                        // connect to the specified INH server
                        _socket.Connect(_endPoint);

                        // Send a HELLO message
                        MCHelloMsg msg = new MCHelloMsg("Testing");
                        if (msg == null)
                        {
                            throw new ApplicationException("IGClient.IGConnection.GetSocket: new IGHelloMsg() returned null.");
                        }

                        _socket.Send((byte[])msg);

                        // the socket is now healthy and ready to go
                        _socketHealthy = true;
                    }
                    finally
                    {
                        _rwlSocketHealthy.DowngradeFromWriterLock(ref lc);
                    }
                }
                return _socket;
            }
            finally
            {
                _rwlSocketHealthy.ReleaseReaderLock();
            }
        }

        /// <summary> 
        /// Marks the socket as unhealthy, so it will get re-created the next time it
        /// is needed. It attempts to shut the socket down gracefully, which may or
        /// may not succeed.
        /// </summary>
        public void InvalidateSocket()
        {
            _rwlSocketHealthy.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                if (_socketHealthy == true)
                {
                    LockCookie lc = _rwlSocketHealthy.UpgradeToWriterLock(LOCK_TIMEOUT);
                    try
                    {
                        // the socket is no longer healthy
                        _socketHealthy = false;

                        // try to shut the socket down gracefully, which may or may
                        // not work... Regardless, the next time send or receive
                        // needs the socket, it will call GetSocket() again which
                        // will create a new socket and re-connect to the INH server
                        _socket.Shutdown(SocketShutdown.Send);
                        byte[] recvBuffer = new byte[1024];

                        // drain the receive buffer
                        while (_socket.Receive(recvBuffer) > 0);

                        _socket.Close();
                    }
                    finally
                    {
                        _rwlSocketHealthy.DowngradeFromWriterLock(ref lc);
                    }
                }
            }
            finally
            {
                _rwlSocketHealthy.ReleaseReaderLock();
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\gui\XCSTAMain.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using System.Drawing;
using System.Windows.Forms;

using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol.SubNoti;

namespace XConnSrvTestApp
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class XCSTAMain : System.Windows.Forms.Form
	{
        private System.Windows.Forms.Button btnConnect;
        private TextBox txtServer;
        private TextBox txtUserId;
        private TabControl tabControl1;
        private TabPage tabCache;
        private DataGridView dgMemCache;
        private DataGridViewTextBoxColumn Key;
        private DataGridViewTextBoxColumn Data;
        private TabPage tabConnections;
        private TabPage tabData;
        private Label label1;
        private ComboBox cbDataType;
        private Button btnSet;
        private Label lblData;
        private TextBox txtData;
        private TextBox txtOwnerXuid;
        private Label lblOwnerXuid;
        private Button btnRandomUserIdData;
        private ListBox lbNotify;
        private Button btnNotify;
        private TextBox txtNotify;
        private Label lblNotify;
        private Label UserIDLabel;
        private Label ClientNameLabel;
        private TextBox txtSubType;
        private Label label2;
        private Button btnPopulate;
        private CheckBox chkShareFriends;
        private CheckBox chkShareEveryone;
        private Button btnRandomUserIdConnections;

        public byte[] dataPayload = null;

        public static XCSTAMain Instance = null;

		public XCSTAMain()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();
            InitializeData();

            Instance = this;
        }

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.btnConnect = new System.Windows.Forms.Button();
            this.txtServer = new System.Windows.Forms.TextBox();
            this.txtUserId = new System.Windows.Forms.TextBox();
            this.btnRandomUserIdConnections = new System.Windows.Forms.Button();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabCache = new System.Windows.Forms.TabPage();
            this.dgMemCache = new System.Windows.Forms.DataGridView();
            this.Key = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Data = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.tabData = new System.Windows.Forms.TabPage();
            this.btnPopulate = new System.Windows.Forms.Button();
            this.chkShareFriends = new System.Windows.Forms.CheckBox();
            this.chkShareEveryone = new System.Windows.Forms.CheckBox();
            this.txtSubType = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.lblNotify = new System.Windows.Forms.Label();
            this.lbNotify = new System.Windows.Forms.ListBox();
            this.btnNotify = new System.Windows.Forms.Button();
            this.txtNotify = new System.Windows.Forms.TextBox();
            this.btnRandomUserIdData = new System.Windows.Forms.Button();
            this.btnSet = new System.Windows.Forms.Button();
            this.lblData = new System.Windows.Forms.Label();
            this.txtData = new System.Windows.Forms.TextBox();
            this.txtOwnerXuid = new System.Windows.Forms.TextBox();
            this.lblOwnerXuid = new System.Windows.Forms.Label();
            this.label1 = new System.Windows.Forms.Label();
            this.cbDataType = new System.Windows.Forms.ComboBox();
            this.tabConnections = new System.Windows.Forms.TabPage();
            this.UserIDLabel = new System.Windows.Forms.Label();
            this.ClientNameLabel = new System.Windows.Forms.Label();
            this.tabControl1.SuspendLayout();
            this.tabCache.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.dgMemCache)).BeginInit();
            this.tabData.SuspendLayout();
            this.tabConnections.SuspendLayout();
            this.SuspendLayout();
            // 
            // btnConnect
            // 
            this.btnConnect.Location = new System.Drawing.Point(76, 58);
            this.btnConnect.Name = "btnConnect";
            this.btnConnect.Size = new System.Drawing.Size(115, 20);
            this.btnConnect.TabIndex = 3;
            this.btnConnect.Text = "Create Connection";
            this.btnConnect.Click += new System.EventHandler(this.CreateConnectionClick);
            // 
            // txtServer
            // 
            this.txtServer.Location = new System.Drawing.Point(76, 6);
            this.txtServer.Name = "txtServer";
            this.txtServer.Size = new System.Drawing.Size(154, 20);
            this.txtServer.TabIndex = 0;
            this.txtServer.Text = "MATTCHIL-2K8";
            this.txtServer.KeyDown += new System.Windows.Forms.KeyEventHandler(this.EnterPressedConnection);
            // 
            // txtUserId
            // 
            this.txtUserId.Location = new System.Drawing.Point(76, 32);
            this.txtUserId.Name = "txtUserId";
            this.txtUserId.Size = new System.Drawing.Size(154, 20);
            this.txtUserId.TabIndex = 1;
            this.txtUserId.KeyDown += new System.Windows.Forms.KeyEventHandler(this.EnterPressedConnection);
            // 
            // btnRandomUserIdConnections
            // 
            this.btnRandomUserIdConnections.Location = new System.Drawing.Point(236, 32);
            this.btnRandomUserIdConnections.Name = "btnRandomUserIdConnections";
            this.btnRandomUserIdConnections.Size = new System.Drawing.Size(110, 19);
            this.btnRandomUserIdConnections.TabIndex = 2;
            this.btnRandomUserIdConnections.Text = "Random User ID";
            this.btnRandomUserIdConnections.UseVisualStyleBackColor = true;
            this.btnRandomUserIdConnections.Click += new System.EventHandler(this.btnRandomUserIdConnections_Click);
            // 
            // tabControl1
            // 
            this.tabControl1.Controls.Add(this.tabCache);
            this.tabControl1.Controls.Add(this.tabData);
            this.tabControl1.Controls.Add(this.tabConnections);
            this.tabControl1.Location = new System.Drawing.Point(12, 12);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(609, 541);
            this.tabControl1.TabIndex = 0;
            // 
            // tabCache
            // 
            this.tabCache.Controls.Add(this.dgMemCache);
            this.tabCache.Location = new System.Drawing.Point(4, 22);
            this.tabCache.Name = "tabCache";
            this.tabCache.Padding = new System.Windows.Forms.Padding(3);
            this.tabCache.Size = new System.Drawing.Size(601, 515);
            this.tabCache.TabIndex = 0;
            this.tabCache.Text = "Cache";
            this.tabCache.UseVisualStyleBackColor = true;
            // 
            // dgMemCache
            // 
            this.dgMemCache.AllowUserToAddRows = false;
            this.dgMemCache.AllowUserToResizeColumns = false;
            this.dgMemCache.AllowUserToResizeRows = false;
            this.dgMemCache.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.dgMemCache.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.Key,
            this.Data});
            this.dgMemCache.EditMode = System.Windows.Forms.DataGridViewEditMode.EditProgrammatically;
            this.dgMemCache.Location = new System.Drawing.Point(6, 6);
            this.dgMemCache.MultiSelect = false;
            this.dgMemCache.Name = "dgMemCache";
            this.dgMemCache.Size = new System.Drawing.Size(589, 503);
            this.dgMemCache.TabIndex = 3;
            // 
            // Key
            // 
            this.Key.Frozen = true;
            this.Key.HeaderText = "Key";
            this.Key.Name = "Key";
            // 
            // Data
            // 
            this.Data.Frozen = true;
            this.Data.HeaderText = "Data";
            this.Data.MinimumWidth = 100;
            this.Data.Name = "Data";
            this.Data.Width = 500;
            // 
            // tabData
            // 
            this.tabData.Controls.Add(this.btnPopulate);
            this.tabData.Controls.Add(this.chkShareFriends);
            this.tabData.Controls.Add(this.chkShareEveryone);
            this.tabData.Controls.Add(this.txtSubType);
            this.tabData.Controls.Add(this.label2);
            this.tabData.Controls.Add(this.lblNotify);
            this.tabData.Controls.Add(this.lbNotify);
            this.tabData.Controls.Add(this.btnNotify);
            this.tabData.Controls.Add(this.txtNotify);
            this.tabData.Controls.Add(this.btnRandomUserIdData);
            this.tabData.Controls.Add(this.btnSet);
            this.tabData.Controls.Add(this.lblData);
            this.tabData.Controls.Add(this.txtData);
            this.tabData.Controls.Add(this.txtOwnerXuid);
            this.tabData.Controls.Add(this.lblOwnerXuid);
            this.tabData.Controls.Add(this.label1);
            this.tabData.Controls.Add(this.cbDataType);
            this.tabData.Location = new System.Drawing.Point(4, 22);
            this.tabData.Name = "tabData";
            this.tabData.Padding = new System.Windows.Forms.Padding(3);
            this.tabData.Size = new System.Drawing.Size(601, 515);
            this.tabData.TabIndex = 2;
            this.tabData.Text = "Data";
            this.tabData.UseVisualStyleBackColor = true;
            // 
            // btnPopulate
            // 
            this.btnPopulate.Location = new System.Drawing.Point(307, 81);
            this.btnPopulate.Name = "btnPopulate";
            this.btnPopulate.Size = new System.Drawing.Size(110, 20);
            this.btnPopulate.TabIndex = 17;
            this.btnPopulate.Text = "Populate Fields";
            this.btnPopulate.UseVisualStyleBackColor = true;
            this.btnPopulate.Click += new System.EventHandler(this.btnPopulate_Click);
            // 
            // chkShareFriends
            // 
            this.chkShareFriends.AutoSize = true;
            this.chkShareFriends.Enabled = false;
            this.chkShareFriends.Location = new System.Drawing.Point(308, 33);
            this.chkShareFriends.Name = "chkShareFriends";
            this.chkShareFriends.Size = new System.Drawing.Size(91, 17);
            this.chkShareFriends.TabIndex = 16;
            this.chkShareFriends.Text = "Share Friends";
            this.chkShareFriends.UseVisualStyleBackColor = true;
            // 
            // chkShareEveryone
            // 
            this.chkShareEveryone.AutoSize = true;
            this.chkShareEveryone.Enabled = false;
            this.chkShareEveryone.Location = new System.Drawing.Point(308, 9);
            this.chkShareEveryone.Name = "chkShareEveryone";
            this.chkShareEveryone.Size = new System.Drawing.Size(102, 17);
            this.chkShareEveryone.TabIndex = 15;
            this.chkShareEveryone.Text = "Share Everyone";
            this.chkShareEveryone.UseVisualStyleBackColor = true;
            // 
            // txtSubType
            // 
            this.txtSubType.Location = new System.Drawing.Point(84, 31);
            this.txtSubType.Name = "txtSubType";
            this.txtSubType.Size = new System.Drawing.Size(217, 20);
            this.txtSubType.TabIndex = 14;
            this.txtSubType.TextChanged += new System.EventHandler(this.txtSubType_TextChanged);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(25, 34);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(53, 13);
            this.label2.TabIndex = 13;
            this.label2.Text = "Sub Type";
            // 
            // lblNotify
            // 
            this.lblNotify.AutoSize = true;
            this.lblNotify.Location = new System.Drawing.Point(6, 193);
            this.lblNotify.Name = "lblNotify";
            this.lblNotify.Size = new System.Drawing.Size(34, 13);
            this.lblNotify.TabIndex = 12;
            this.lblNotify.Text = "Notify";
            // 
            // lbNotify
            // 
            this.lbNotify.FormattingEnabled = true;
            this.lbNotify.Location = new System.Drawing.Point(9, 210);
            this.lbNotify.Name = "lbNotify";
            this.lbNotify.SelectionMode = System.Windows.Forms.SelectionMode.MultiSimple;
            this.lbNotify.Size = new System.Drawing.Size(151, 290);
            this.lbNotify.TabIndex = 5;
            // 
            // btnNotify
            // 
            this.btnNotify.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.btnNotify.Location = new System.Drawing.Point(166, 236);
            this.btnNotify.Name = "btnNotify";
            this.btnNotify.Size = new System.Drawing.Size(96, 20);
            this.btnNotify.TabIndex = 7;
            this.btnNotify.Text = "Notify";
            this.btnNotify.Click += new System.EventHandler(this.btnNotify_Click);
            // 
            // txtNotify
            // 
            this.txtNotify.AcceptsReturn = true;
            this.txtNotify.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.txtNotify.Location = new System.Drawing.Point(166, 210);
            this.txtNotify.Name = "txtNotify";
            this.txtNotify.Size = new System.Drawing.Size(429, 20);
            this.txtNotify.TabIndex = 6;
            // 
            // btnRandomUserIdData
            // 
            this.btnRandomUserIdData.Location = new System.Drawing.Point(307, 55);
            this.btnRandomUserIdData.Name = "btnRandomUserIdData";
            this.btnRandomUserIdData.Size = new System.Drawing.Size(110, 20);
            this.btnRandomUserIdData.TabIndex = 2;
            this.btnRandomUserIdData.Text = "Random User ID";
            this.btnRandomUserIdData.UseVisualStyleBackColor = true;
            this.btnRandomUserIdData.Click += new System.EventHandler(this.btnRandomUserIdData_Click);
            // 
            // btnSet
            // 
            this.btnSet.Location = new System.Drawing.Point(84, 107);
            this.btnSet.Name = "btnSet";
            this.btnSet.Size = new System.Drawing.Size(112, 25);
            this.btnSet.TabIndex = 4;
            this.btnSet.Text = "Set";
            this.btnSet.UseVisualStyleBackColor = true;
            this.btnSet.Click += new System.EventHandler(this.btnSet_Click);
            // 
            // lblData
            // 
            this.lblData.AutoSize = true;
            this.lblData.Location = new System.Drawing.Point(48, 85);
            this.lblData.Name = "lblData";
            this.lblData.Size = new System.Drawing.Size(30, 13);
            this.lblData.TabIndex = 5;
            this.lblData.Text = "Data";
            // 
            // txtData
            // 
            this.txtData.Location = new System.Drawing.Point(84, 81);
            this.txtData.Name = "txtData";
            this.txtData.Size = new System.Drawing.Size(217, 20);
            this.txtData.TabIndex = 3;
            this.txtData.TextChanged += new System.EventHandler(this.txtData_TextChanged);
            // 
            // txtOwnerXuid
            // 
            this.txtOwnerXuid.Location = new System.Drawing.Point(84, 55);
            this.txtOwnerXuid.Name = "txtOwnerXuid";
            this.txtOwnerXuid.Size = new System.Drawing.Size(217, 20);
            this.txtOwnerXuid.TabIndex = 1;
            this.txtOwnerXuid.TextChanged += new System.EventHandler(this.txtOwnerXuid_TextChanged);
            // 
            // lblOwnerXuid
            // 
            this.lblOwnerXuid.AutoSize = true;
            this.lblOwnerXuid.Location = new System.Drawing.Point(17, 58);
            this.lblOwnerXuid.Name = "lblOwnerXuid";
            this.lblOwnerXuid.Size = new System.Drawing.Size(62, 13);
            this.lblOwnerXuid.TabIndex = 2;
            this.lblOwnerXuid.Text = "Owner Xuid";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(21, 9);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(57, 13);
            this.label1.TabIndex = 1;
            this.label1.Text = "Data Type";
            // 
            // cbDataType
            // 
            this.cbDataType.FormattingEnabled = true;
            this.cbDataType.Location = new System.Drawing.Point(84, 6);
            this.cbDataType.Name = "cbDataType";
            this.cbDataType.Size = new System.Drawing.Size(217, 21);
            this.cbDataType.TabIndex = 0;
            this.cbDataType.SelectedIndexChanged += new System.EventHandler(this.cbDataType_SelectedIndexChanged);
            // 
            // tabConnections
            // 
            this.tabConnections.Controls.Add(this.UserIDLabel);
            this.tabConnections.Controls.Add(this.ClientNameLabel);
            this.tabConnections.Controls.Add(this.btnConnect);
            this.tabConnections.Controls.Add(this.btnRandomUserIdConnections);
            this.tabConnections.Controls.Add(this.txtServer);
            this.tabConnections.Controls.Add(this.txtUserId);
            this.tabConnections.Location = new System.Drawing.Point(4, 22);
            this.tabConnections.Name = "tabConnections";
            this.tabConnections.Padding = new System.Windows.Forms.Padding(3);
            this.tabConnections.Size = new System.Drawing.Size(601, 515);
            this.tabConnections.TabIndex = 1;
            this.tabConnections.Text = "Connections";
            this.tabConnections.UseVisualStyleBackColor = true;
            // 
            // UserIDLabel
            // 
            this.UserIDLabel.AutoSize = true;
            this.UserIDLabel.Location = new System.Drawing.Point(27, 35);
            this.UserIDLabel.Name = "UserIDLabel";
            this.UserIDLabel.Size = new System.Drawing.Size(43, 13);
            this.UserIDLabel.TabIndex = 5;
            this.UserIDLabel.Text = "User ID";
            // 
            // ClientNameLabel
            // 
            this.ClientNameLabel.AutoSize = true;
            this.ClientNameLabel.Location = new System.Drawing.Point(6, 9);
            this.ClientNameLabel.Name = "ClientNameLabel";
            this.ClientNameLabel.Size = new System.Drawing.Size(64, 13);
            this.ClientNameLabel.TabIndex = 4;
            this.ClientNameLabel.Text = "Client Name";
            // 
            // XCSTAMain
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(633, 565);
            this.Controls.Add(this.tabControl1);
            this.MaximizeBox = false;
            this.Name = "XCSTAMain";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.Text = "XConnSrv Test";
            this.tabControl1.ResumeLayout(false);
            this.tabCache.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.dgMemCache)).EndInit();
            this.tabData.ResumeLayout(false);
            this.tabData.PerformLayout();
            this.tabConnections.ResumeLayout(false);
            this.tabConnections.PerformLayout();
            this.ResumeLayout(false);

		}

        void Rows_CollectionChanged(object sender, System.ComponentModel.CollectionChangeEventArgs e)
        {
            if (e.Action == System.ComponentModel.CollectionChangeAction.Remove)
            {
                DataGridViewRow removed = (DataGridViewRow)e.Element;
                string key = (string)removed.Cells[0].Value;
                MCServerNetwork._memCache.Set(key, null);
            }
        }
		#endregion

        private void InitializeData()
        {
            txtUserId.Text = "123456789";
            txtOwnerXuid.Text = "123456789";
            txtSubType.Text = "0";
            cbDataType.DataSource = new string[]{
                "eFriendsList",
                "eBasicPresence",
                "eExtendedPresence",
                "eRichPresenceString",
                "eBasicProfile",
                "eExtendedProfile",
                "eAvatar",
                "ePartyInfo"
                };
            this.dgMemCache.Rows.CollectionChanged += new System.ComponentModel.CollectionChangeEventHandler(Rows_CollectionChanged);
            foreach (string key in MCServerNetwork._memCache._cache.Keys)
            {
                lbNotify.Items.Add(key);
            }
            lbNotify.SelectedIndexChanged += new EventHandler(lbNotify_SelectedIndexChanged);
            MCServerNetwork._memCache.DataChanged += new FakeMemCache.DataChangeEventHandler(_memCache_DataChanged);
        }

        void lbNotify_SelectedIndexChanged(object sender, EventArgs e)
        {
            string notify = "";
            ICollection selectedItems = lbNotify.SelectedItems;
            foreach (string s in selectedItems)
            {
                notify += s;
                notify += ";";
            }
            txtNotify.Text = notify;
        }

        private void _memCache_DataChanged(object oSender, FakeMemCache.DataChangeEventArgs args)
        {
            switch (args.ChangeType)
            {
                case FakeMemCache.FMC_DataChanges.FMC_Add:
                    {
                        dgMemCache.Rows.Add(args.Key, Hexer.tohex(args.Data));
                        lbNotify.Items.Add(args.Key);
                        lbNotify.Update();
                        break;
                    }
                case FakeMemCache.FMC_DataChanges.FMC_Delete:
                    {
                        DataGridViewRow toRemove = null;
                        foreach (DataGridViewRow dgvRow in dgMemCache.Rows)
                        {
                            string key = args.Key;
                            if ((string)dgvRow.Cells[0].Value == key)
                            {
                                toRemove = dgvRow;
                                break;
                            }
                        }
                        if (toRemove != null)
                        {
                            dgMemCache.Rows.Remove(toRemove);
                        }
                        lbNotify.Items.Remove(args.Key);
                        lbNotify.Update();
                        break;
                    }
                case FakeMemCache.FMC_DataChanges.FMC_Update:
                    {
                        DataGridViewRow toUpdate = null;
                        foreach (DataGridViewRow dgvRow in dgMemCache.Rows)
                        {
                            string key = args.Key;
                            if ((string)dgvRow.Cells[0].Value == key)
                            {
                                toUpdate = dgvRow;
                                break;
                            }
                        }
                        if (toUpdate != null)
                        {
                            toUpdate.Cells[1].Value = Hexer.tohex(args.Data);
                            dgMemCache.Update();
                        }

                        break;
                    }
                default:
                    break;
            }
        }

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
            XConnSrvTest.XConnSrvMemCache.Initialize();
			Application.Run(new XCSTAMain());
		}

        private void CreateConnectionClick(object sender, System.EventArgs e)
        {
            CreateConnection();
        }

		private void CreateConnection()
		{
            try
            {
                ulong idUser = UInt64.Parse(txtUserId.Text);
                // TODO: Temporary single user fix
                UserConnection pBlack = new UserConnection(txtServer.Text, new int[] { 1 }, new ulong[] { idUser });
                pBlack.Show();
            }
            catch (Exception ex)
            {
                System.Windows.Forms.MessageBox.Show(ex.Message);
            }
		}

        private void btnSet_Click(object sender, EventArgs e)
        {
            string ownerXuid = txtOwnerXuid.Text;
            string data = txtData.Text;
            string type = (string)cbDataType.SelectedValue;
            string subtype = txtSubType.Text;
            byte[] byteData = (dataPayload != null) ? dataPayload : System.Text.Encoding.ASCII.GetBytes(data);

            DATA_OBJECT_SPECIFIER setData = new DATA_OBJECT_SPECIFIER();
            unsafe
            {
                setData.wObjectSize = (ushort)((ushort)byteData.Length + sizeof(BASE_DATA_HEADER));
            }
            setData.qwOwnerXUID = UInt64.Parse(ownerXuid);
            setData.wDataType = (ushort)Enum.Parse(typeof(DATA_TYPES), type, true);
            setData.dwDataSubType = UInt32.Parse(subtype);
            XConnSrvTest.XConnSrvMemCache.InsertDataObject(setData, byteData);
        }

        private void btnRandomUserIdData_Click(object sender, EventArgs e)
        {
            Random rnd = new Random();
            ulong userId = Convert.ToUInt64(rnd.Next());
            txtOwnerXuid.Text = userId.ToString();
            txtOwnerXuid.Update();
        }

        private void btnRandomUserIdConnections_Click(object sender, EventArgs e)
        {
            Random rnd = new Random();
            ulong userId = Convert.ToUInt64(rnd.Next());
            txtUserId.Text = userId.ToString();
            txtUserId.Update();
        }

        private void btnNotify_Click(object sender, EventArgs e)
        {
            string sNotify = this.txtNotify.Text;
            if (sNotify != null && sNotify.Length > 0)
            {
                try
                {
                    if(sNotify[sNotify.Length - 1] == ';')
                    {
                        sNotify = sNotify.Substring(0,sNotify.Length - 1);
                    }
                    string[] sNotifications = sNotify.Split(';');
                    MCNotificationResponse response = new MCNotificationResponse(sNotifications);
                    MCServerNetwork.Notify(response);
                }
                catch { }
            }

        }

        private void EnterPressedConnection(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                CreateConnection();
            }
        }

        private void btnPopulate_Click(object sender, EventArgs e)
        {
            string type = (string)cbDataType.SelectedValue;
            DATA_TYPES dt = (DATA_TYPES)Enum.Parse(typeof(DATA_TYPES), type, true);
            switch (dt)
            {
                case DATA_TYPES.eBasicPresence:
                    BasicPresenceData basicPres = new BasicPresenceData();
                    basicPres.ShowDialog(this);
                    break;
                default:
                    MessageBox.Show("Unsupported type.");
                    return;
            }

            txtData.Text = "<Populated Fields>";
            txtData.Enabled = false;
        }

        private void txtData_TextChanged(object sender, EventArgs e)
        {
            dataPayload = null;
        }

        private void cbDataType_SelectedIndexChanged(object sender, EventArgs e)
        {
            dataPayload = null;
            txtData.Enabled = true;
            txtData.Clear();
        }

        private void txtSubType_TextChanged(object sender, EventArgs e)
        {
            dataPayload = null;
            txtData.Enabled = true;
            txtData.Clear();
        }

        private void txtOwnerXuid_TextChanged(object sender, EventArgs e)
        {
            dataPayload = null;
            txtData.Enabled = true;
            txtData.Clear();
        }
	}

    [RunInstaller(true)]
    public class XConnSrvTestInstaller :
        XomPerformanceCounterInstall
    {
        public override void Install(IDictionary stateSaver)
        {
            // needs stflive in the working directory.  
            // TODO:  How to load it from parent directory?
            InstallCategory(Type.GetType("ServerTestFramework.LiveService.XConnSrv.ProtocolConnectionCounters,stflive"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\gui\UserConnection.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Windows.Forms;
using System.Net;
using System.IO;

using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;

using xonline.common.protocol.SubNoti;

namespace XConnSrvTestApp
{
	/// <summary>
	/// Summary description for Game.
	/// </summary>
	public class UserConnection : System.Windows.Forms.Form
    {
        private System.Windows.Forms.TextBox txtSubscribe;
        private System.Windows.Forms.Button btnSubscribe;
        private DataGridView dgvSubscribes;
        private Label lblUserId;
        private Label lblServer;
        private TextBox txtUserId;
        private TextBox txtServer;
        private DataGridViewTextBoxColumn Key;
        private DataGridViewTextBoxColumn Data;
        private ListBox lbSubscribe;

		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

        public UserConnection(string sServerName, int[] rgUserIndices, ulong[] rgUserIds)
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();
            InitializeData();
            // TODO: Temp compiler happiness
            this.idUser = rgUserIds[0];
            this.sServerName = sServerName;
            this.txtUserId.Text = idUser.ToString();
            this.txtServer.Text = sServerName;
            ConnSrv.CreateInstance(sServerName, sServerName, 3700);
            // TODO: Temp hax
            _connection = new PNConnection(sServerName, new int[] {rgUserIndices[0]}, new ulong[] {rgUserIds[0]});
            _connection.Connect();
		}
       
        private readonly ulong idUser;
        private readonly string sServerName;
        private readonly PNConnection _connection = null;

        private void InitializeData()
        {
            MCServerNetwork._memCache.DataChanged += new FakeMemCache.DataChangeEventHandler(_memCache_DataChanged);
            foreach (string key in MCServerNetwork._memCache._cache.Keys)
            {
                lbSubscribe.Items.Add(key);
            }
            lbSubscribe.SelectedIndexChanged += new EventHandler(lbSubscribe_SelectedIndexChanged);
        }

        void lbSubscribe_SelectedIndexChanged(object sender, EventArgs e)
        {
            string subscribeTo = "";
            ICollection selectedItems = lbSubscribe.SelectedItems;
            foreach (string s in selectedItems)
            {
                subscribeTo += s;
                subscribeTo += ";";
            }
            txtSubscribe.Text = subscribeTo;
        }

        private void _memCache_DataChanged(object oSender, FakeMemCache.DataChangeEventArgs args)
        {
            switch (args.ChangeType)
            {
                case FakeMemCache.FMC_DataChanges.FMC_Add:
                    {
                        lbSubscribe.Items.Add(args.Key);
                        lbSubscribe.Update();
                        break;
                    }
                case FakeMemCache.FMC_DataChanges.FMC_Delete:
                    {
                        lbSubscribe.Items.Remove(args.Key);
                        lbSubscribe.Update();
                        break;
                    }
                default:
                    break;
            }
        }

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
                if (_connection != null)
                {
                    try
                    {
                        if (_connection.Connected)
                        {
                            _connection.Disconnect(0);
                        }
                    }
                    catch { }
                }
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.txtSubscribe = new System.Windows.Forms.TextBox();
            this.btnSubscribe = new System.Windows.Forms.Button();
            this.dgvSubscribes = new System.Windows.Forms.DataGridView();
            this.Key = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.Data = new System.Windows.Forms.DataGridViewTextBoxColumn();
            this.lblUserId = new System.Windows.Forms.Label();
            this.lblServer = new System.Windows.Forms.Label();
            this.txtUserId = new System.Windows.Forms.TextBox();
            this.txtServer = new System.Windows.Forms.TextBox();
            this.lbSubscribe = new System.Windows.Forms.ListBox();
            ((System.ComponentModel.ISupportInitialize)(this.dgvSubscribes)).BeginInit();
            this.SuspendLayout();
            // 
            // txtSubscribe
            // 
            this.txtSubscribe.AcceptsReturn = true;
            this.txtSubscribe.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.txtSubscribe.Location = new System.Drawing.Point(169, 408);
            this.txtSubscribe.Name = "txtSubscribe";
            this.txtSubscribe.Size = new System.Drawing.Size(251, 20);
            this.txtSubscribe.TabIndex = 0;
            // 
            // btnSubscribe
            // 
            this.btnSubscribe.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.btnSubscribe.Location = new System.Drawing.Point(169, 434);
            this.btnSubscribe.Name = "btnSubscribe";
            this.btnSubscribe.Size = new System.Drawing.Size(96, 20);
            this.btnSubscribe.TabIndex = 1;
            this.btnSubscribe.Text = "Subscribe";
            this.btnSubscribe.Click += new System.EventHandler(this.btnSubscribe_Click);
            // 
            // dgvSubscribes
            // 
            this.dgvSubscribes.AllowUserToAddRows = false;
            this.dgvSubscribes.AllowUserToResizeColumns = false;
            this.dgvSubscribes.AllowUserToResizeRows = false;
            this.dgvSubscribes.CellBorderStyle = System.Windows.Forms.DataGridViewCellBorderStyle.None;
            this.dgvSubscribes.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            this.dgvSubscribes.Columns.AddRange(new System.Windows.Forms.DataGridViewColumn[] {
            this.Key,
            this.Data});
            this.dgvSubscribes.Location = new System.Drawing.Point(12, 32);
            this.dgvSubscribes.MultiSelect = false;
            this.dgvSubscribes.Name = "dgvSubscribes";
            this.dgvSubscribes.ReadOnly = true;
            this.dgvSubscribes.Size = new System.Drawing.Size(408, 369);
            this.dgvSubscribes.TabIndex = 3;
            // 
            // Key
            // 
            this.Key.HeaderText = "Key";
            this.Key.Name = "Key";
            this.Key.ReadOnly = true;
            // 
            // Data
            // 
            this.Data.HeaderText = "Data";
            this.Data.MinimumWidth = 100;
            this.Data.Name = "Data";
            this.Data.ReadOnly = true;
            this.Data.Width = 500;
            // 
            // lblUserId
            // 
            this.lblUserId.AutoSize = true;
            this.lblUserId.Location = new System.Drawing.Point(24, 9);
            this.lblUserId.Name = "lblUserId";
            this.lblUserId.Size = new System.Drawing.Size(38, 13);
            this.lblUserId.TabIndex = 4;
            this.lblUserId.Text = "UserId";
            // 
            // lblServer
            // 
            this.lblServer.AutoSize = true;
            this.lblServer.Location = new System.Drawing.Point(227, 9);
            this.lblServer.Name = "lblServer";
            this.lblServer.Size = new System.Drawing.Size(38, 13);
            this.lblServer.TabIndex = 5;
            this.lblServer.Text = "Server";
            // 
            // txtUserId
            // 
            this.txtUserId.Enabled = false;
            this.txtUserId.Location = new System.Drawing.Point(68, 6);
            this.txtUserId.Name = "txtUserId";
            this.txtUserId.Size = new System.Drawing.Size(114, 20);
            this.txtUserId.TabIndex = 6;
            this.txtUserId.TabStop = false;
            // 
            // txtServer
            // 
            this.txtServer.Enabled = false;
            this.txtServer.Location = new System.Drawing.Point(271, 6);
            this.txtServer.Name = "txtServer";
            this.txtServer.Size = new System.Drawing.Size(114, 20);
            this.txtServer.TabIndex = 7;
            // 
            // lbSubscribe
            // 
            this.lbSubscribe.FormattingEnabled = true;
            this.lbSubscribe.Location = new System.Drawing.Point(12, 408);
            this.lbSubscribe.Name = "lbSubscribe";
            this.lbSubscribe.SelectionMode = System.Windows.Forms.SelectionMode.MultiSimple;
            this.lbSubscribe.Size = new System.Drawing.Size(151, 238);
            this.lbSubscribe.TabIndex = 8;
            // 
            // UserConnection
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(432, 658);
            this.Controls.Add(this.lbSubscribe);
            this.Controls.Add(this.txtServer);
            this.Controls.Add(this.txtUserId);
            this.Controls.Add(this.lblServer);
            this.Controls.Add(this.lblUserId);
            this.Controls.Add(this.dgvSubscribes);
            this.Controls.Add(this.btnSubscribe);
            this.Controls.Add(this.txtSubscribe);
            this.MaximizeBox = false;
            this.Name = "UserConnection";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.Text = "Connection";
            ((System.ComponentModel.ISupportInitialize)(this.dgvSubscribes)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

		}
		#endregion

        private void btnSubscribe_Click(object sender, EventArgs e)
        {
            string subscribeTo = txtSubscribe.Text;
            if (subscribeTo != null && subscribeTo.Length > 0)
            {
                try
                {
                    if(subscribeTo[subscribeTo.Length - 1] == ';')
                    {
                        subscribeTo = subscribeTo.Substring(0,subscribeTo.Length - 1);
                    }
                    string[] sSubscribes = subscribeTo.Split(';');
                    DATA_OBJECT_SPECIFIER[] subscribes = new DATA_OBJECT_SPECIFIER[sSubscribes.Length];
                    for (int j = 0; j < subscribes.Length; j++)
                    {
                        string[] XUIDandDataType = sSubscribes[j].Split(':');
                        subscribes[j].wObjectSize = 100;
                        subscribes[j].qwOwnerXUID = Hexer.fromhex(XUIDandDataType[1]);
                        subscribes[j].wDataType = (ushort)Enum.Parse(typeof(DATA_TYPES), XUIDandDataType[0], true);
                    }
                    SUBSCRIBE_REPLY subscribereply = _connection.Subscribe(subscribes);
                    for (int i = 0; i < subscribereply.rgDataObjects.Length; i++ )
                    {
                        // TODO: this assumes order of responses
                        dgvSubscribes.Rows.Add(SubNotiDefs.GetDataKeyString(subscribes[i]), Hexer.tohex(subscribereply.rgDataObjects[i].data));
                    }
                }
                catch { }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\gui\BasicPresenceData.Designer.cs ===
﻿namespace XConnSrvTestApp
{
    partial class BasicPresenceData
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.txtGamertag = new System.Windows.Forms.TextBox();
            this.txtTitleID = new System.Windows.Forms.TextBox();
            this.txtLastSeen = new System.Windows.Forms.TextBox();
            this.txtSessionID = new System.Windows.Forms.TextBox();
            this.txtState = new System.Windows.Forms.TextBox();
            this.btnOK = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(32, 29);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(63, 13);
            this.label1.TabIndex = 0;
            this.label1.Text = "szGamertag";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(43, 55);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(52, 13);
            this.label2.TabIndex = 1;
            this.label2.Text = "dwTitleID";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(32, 81);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(63, 13);
            this.label3.TabIndex = 2;
            this.label3.Text = "mtLastSeen";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(26, 107);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(69, 13);
            this.label4.TabIndex = 3;
            this.label4.Text = "qwSessionID";
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(49, 133);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(46, 13);
            this.label5.TabIndex = 4;
            this.label5.Text = "dwState";
            // 
            // txtGamertag
            // 
            this.txtGamertag.Location = new System.Drawing.Point(101, 26);
            this.txtGamertag.Name = "txtGamertag";
            this.txtGamertag.Size = new System.Drawing.Size(178, 20);
            this.txtGamertag.TabIndex = 5;
            // 
            // txtTitleID
            // 
            this.txtTitleID.Location = new System.Drawing.Point(101, 52);
            this.txtTitleID.Name = "txtTitleID";
            this.txtTitleID.Size = new System.Drawing.Size(178, 20);
            this.txtTitleID.TabIndex = 6;
            // 
            // txtLastSeen
            // 
            this.txtLastSeen.Location = new System.Drawing.Point(101, 78);
            this.txtLastSeen.Name = "txtLastSeen";
            this.txtLastSeen.Size = new System.Drawing.Size(178, 20);
            this.txtLastSeen.TabIndex = 7;
            // 
            // txtSessionID
            // 
            this.txtSessionID.Location = new System.Drawing.Point(101, 104);
            this.txtSessionID.Name = "txtSessionID";
            this.txtSessionID.Size = new System.Drawing.Size(178, 20);
            this.txtSessionID.TabIndex = 8;
            // 
            // txtState
            // 
            this.txtState.Location = new System.Drawing.Point(101, 130);
            this.txtState.Name = "txtState";
            this.txtState.Size = new System.Drawing.Size(178, 20);
            this.txtState.TabIndex = 9;
            // 
            // btnOK
            // 
            this.btnOK.Location = new System.Drawing.Point(150, 156);
            this.btnOK.Name = "btnOK";
            this.btnOK.Size = new System.Drawing.Size(75, 23);
            this.btnOK.TabIndex = 10;
            this.btnOK.Text = "OK";
            this.btnOK.UseVisualStyleBackColor = true;
            this.btnOK.Click += new System.EventHandler(this.btnOK_Click);
            // 
            // BasicPresenceData
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(318, 207);
            this.Controls.Add(this.btnOK);
            this.Controls.Add(this.txtState);
            this.Controls.Add(this.txtSessionID);
            this.Controls.Add(this.txtLastSeen);
            this.Controls.Add(this.txtTitleID);
            this.Controls.Add(this.txtGamertag);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "BasicPresenceData";
            this.Padding = new System.Windows.Forms.Padding(9);
            this.ShowIcon = false;
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "BasicPresenceData";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.TextBox txtGamertag;
        private System.Windows.Forms.TextBox txtTitleID;
        private System.Windows.Forms.TextBox txtLastSeen;
        private System.Windows.Forms.TextBox txtSessionID;
        private System.Windows.Forms.TextBox txtState;
        private System.Windows.Forms.Button btnOK;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\mctest\MCProtocol.cs ===
using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using xonline.common.service;

namespace xonline.test.MCService
{
    public class MCDefs
    {
        public const uint MC_PROTOCOL_VERSION_CURRENT = 1;
        public const uint MC_MESSAGE_HEADER_SIZE = 16;
    }

    public enum MC_MSG_TYPES
    {
        // request types:
        MCMSG_MIN_REQ           = 1000,
        MCMSG_HELLO_REQ         = 1000,
        MCMSG_GET_SINGLE_REQ    = 1001,
        MCMSG_SET_SINGLE_REQ    = 1002,
        MCMSG_MAX_REQ           = 1002,

        // response types:
        MCMSG_MIN_RESP          = 1100,
        MCMSG_GET_SINGLE_RESP   = 1100,
        MCMSG_NOTIFICATION_RESP = 1101,
        MCMSG_MAX_RESP          = 1101,
    };

    public class MCMessage : WireData
    {
        public MCMessageHeader _Header;
        public MCMessageData   _Data;

        public MCMessage()
        {
        }

        public MCMessage(MC_MSG_TYPES eType, MCMessageData Data)
        {
            _Header = new MCMessageHeader(eType);
            _Data = Data;
            _Header.dwMsgLen = (uint)(_Data.Size());
        }

        public override int Size()
        {
            return (_Header != null ? _Header.Size() : 0) + (_Data != null ? _Data.Size() : 0);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            _Header.WriteStream(binaryWriter);
            _Data.WriteStream(binaryWriter);
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            _Header = new MCMessageHeader();
            _Header.ReadStream(binaryReader);

            _Data = MCMessageData.GetInstance(_Header);
            _Data.ReadStream(binaryReader);
            return this;
        }
    }

    public class MCMessageHeader : WireData
    {
        public uint dwProtocolVersion;
        public uint dwMsgType;
        public uint dwMsgLen;
        public uint dwSeqNum;

        public MCMessageHeader()
        {
        }

        public MCMessageHeader(MC_MSG_TYPES eType)
        {
            dwProtocolVersion = MCDefs.MC_PROTOCOL_VERSION_CURRENT;
            dwMsgType = (uint)eType;
        }

        public override int Size()
        {
            return (int)MCDefs.MC_MESSAGE_HEADER_SIZE;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - IGMessageHeader::WriteStream binaryWriter is null");
            }

            binaryWriter.Write(dwProtocolVersion);
            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
        }
    
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancMessageHeader::ReadStream binaryReader is null");
            }

            dwProtocolVersion = binaryReader.ReadUInt32();
            dwMsgType = binaryReader.ReadUInt32();
            dwMsgLen = binaryReader.ReadUInt32();
            dwSeqNum = binaryReader.ReadUInt32();
           
            return this;
        }
    } 

    public class MCMessageData : WireData
    {
        public static MCMessageData GetInstance(MCMessageHeader Header)
        {
            MCMessageData data = null;
            switch (Header.dwMsgType)
            {
                case (uint)MC_MSG_TYPES.MCMSG_HELLO_REQ:
                    data = new MCHelloMsgData();
                    break;
                case (uint)MC_MSG_TYPES.MCMSG_GET_SINGLE_REQ:
                    data = new MCGetSingleMsgData();
                    break;
                case (uint)MC_MSG_TYPES.MCMSG_SET_SINGLE_REQ:
                    data = new MCSetSingleMsgData();
                    break;
                case (uint)MC_MSG_TYPES.MCMSG_GET_SINGLE_RESP:
                    data = new MCGetSingleResponseData();
                    break;
                case (uint)MC_MSG_TYPES.MCMSG_NOTIFICATION_RESP:
                    data = new MCNotificationResponseData();
                    break;
            }

            return data;
        }
    }

    public class MCHelloMsg : MCMessage
    {
        public MCHelloMsg(string Description)
            : base(MC_MSG_TYPES.MCMSG_HELLO_REQ, new MCHelloMsgData(Description))
        {
        }
    }

    public class MCHelloMsgData : MCMessageData
    {
        [WireInfo(NullTerminate = true, ArraySize = 79)]
        public string szDescription;

        public MCHelloMsgData()
        {
        }

        public MCHelloMsgData(string Description)
        {
            szDescription = Description;
        }

        public override int Size()
        {
            return 80;
        }
    }

    public class MCGetSingleMsg : MCMessage
    {
        public MCGetSingleMsg(string key) : base(MC_MSG_TYPES.MCMSG_GET_SINGLE_REQ, new MCGetSingleMsgData(key))
        {
        }
    }

    public class MCGetSingleMsgData : MCMessageData
    {
        public ushort _keyLength; // Includes the '\0'
        [WireInfo(SizeParam = "_keyLength", NullTerminate = true)]
        public string _key; // ASCII Null terminated

        public MCGetSingleMsgData()
        {
        }

        public MCGetSingleMsgData(string key)
        {
            if (key != null)
                _keyLength = (ushort)key.Length;
            else
                _keyLength = 0;
            _key = key;
        }

        public override int Size()
        {
            return sizeof(ushort) +
                   ((_key == null) ? 0 : _key.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_keyLength);

            if (_key != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_key));
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - ReadStream binaryReader is null");
            }

            _keyLength = binaryReader.ReadUInt16();

            if (_keyLength > 0)
            {
                _key = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_keyLength));
            }

            return this;
        }
    }

    public class MCSetSingleMsg : MCMessage
    {
        public MCSetSingleMsg(string key, byte[] data)
            : base(MC_MSG_TYPES.MCMSG_SET_SINGLE_REQ, new MCSetSingleMsgData(key, data))
        {
        }
    }

    public class MCSetSingleMsgData : MCMessageData
    {
        public ushort _keyLength; // Includes the '\0'
        [WireInfo(SizeParam = "_keyLength", NullTerminate = true)]
        public string _key; // ASCII Null terminated

        public uint _dataSize;
        [WireInfo(SizeParam = "_dataSize")]
        public byte[] _data;

        public MCSetSingleMsgData()
        {
        }

        public MCSetSingleMsgData(string key, byte[] data)
        {
            if (key != null)
                _keyLength = (ushort)key.Length;
            else
                _keyLength = 0;
            _key = key;

            if (data != null)
                _dataSize = (uint)data.Length;
            else
                _dataSize = 0;
            _data = data;
        }

        public override int Size()
        {
            return sizeof(ushort) +
                   ((_key == null) ? 0 : _key.Length) +
                   sizeof(uint) +
                   ((_data == null) ? 0 : _data.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_keyLength);

            if (_key != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_key));
            }

            binaryWriter.Write(_dataSize);

            if (_data != null)
            {
                binaryWriter.Write(_data);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - ReadStream binaryReader is null");
            }

            _keyLength = binaryReader.ReadUInt16();

            if (_keyLength > 0)
            {
                _key = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_keyLength));
            }

            _dataSize = binaryReader.ReadUInt32();
            _data = new byte[_dataSize];
            if (_dataSize > 0)
            {
                _data = binaryReader.ReadBytes((int)_dataSize);
            }

            return this;
        }
    }

    public class MCGetSingleResponse : MCMessage
    {
        public MCGetSingleResponse(string key, byte[] data)
            : base(MC_MSG_TYPES.MCMSG_GET_SINGLE_RESP, new MCGetSingleResponseData(key, data))
        {
        }
    }

    public class MCGetSingleResponseData : MCMessageData
    {
        public ushort _keyLength; // Includes the '\0'
        [WireInfo(SizeParam = "_keyLength", NullTerminate = true)]
        public string _key; // ASCII Null terminated

        public uint _dataSize;
        [WireInfo(SizeParam = "_dataSize")]
        public byte[] _data;

        public MCGetSingleResponseData()
        {
        }

        public MCGetSingleResponseData(string key, byte[] data)
        {
            if (key != null)
                _keyLength = (ushort)key.Length;
            else
                _keyLength = 0;
            _key = key;

            if (data != null)
                _dataSize = (uint)data.Length;
            else
                _dataSize = 0;
            _data = data;
        }

        public override int Size()
        {
            return sizeof(ushort) +
                   ((_key == null) ? 0 : _key.Length) +
                   sizeof(uint) +
                   ((_data == null) ? 0 : _data.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_keyLength);

            if (_key != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_key));
            }

            binaryWriter.Write(_dataSize);

            if (_data != null)
            {
                binaryWriter.Write(_data);
            }
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - ReadStream binaryReader is null");
            }

            _keyLength = binaryReader.ReadUInt16();

            if (_keyLength > 0)
            {
                _key = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_keyLength));
            }

            _dataSize = binaryReader.ReadUInt32();
            _data = new byte[_dataSize];
            if (_dataSize > 0)
            {
                _data = binaryReader.ReadBytes((int)_dataSize);
            }

            return this;
        }
    }

    public class MCNotificationResponse : MCMessage
    {
        public MCNotificationResponse(string[] keys)
            : base(MC_MSG_TYPES.MCMSG_NOTIFICATION_RESP, new MCNotificationResponseData(keys))
        {
        }
    }

    public class MCNotificationResponseData : MCMessageData
    {
        public uint _keysSize;

        [WireInfo(SizeParam = "_keysSize")]
        public ushort[] _keysLengths;

        [WireInfo(SizeParam = "_keysSize")]
        public string[] _keys;

        public MCNotificationResponseData()
        {
        }

        public MCNotificationResponseData(string[] keys)
        {
            if (keys != null)
                _keysSize = (ushort)keys.Length;
            else
                _keysSize = 0;

            _keys = keys;

            // Store the lengths of each string
            _keysLengths = new ushort[_keysSize];
            for (int i = 0; i < _keysSize; ++i)
                _keysLengths[i] = (ushort)_keys[i].Length;
        }

        public override int Size()
        {
            int totalSize = 0;

            totalSize += sizeof(uint);

            for (int i = 0; i < _keysSize; ++i)
            {
                if (_keys[i] != null)
                    totalSize += _keysLengths[i];
            }

            return totalSize;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_keysSize);

            foreach (ushort length in _keysLengths)
                binaryWriter.Write(length);

            foreach(string key in _keys)
                if(key != null)
                    binaryWriter.Write(Encoding.ASCII.GetBytes(key));
        }

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - ReadStream binaryReader is null");
            }

            _keysSize = binaryReader.ReadUInt32();

            if (_keysSize > 0)
            {
                _keysLengths = new ushort[_keysSize];
                _keys = new string[_keysSize];

                for (int i = 0; i < _keysSize; ++i)
                {
                    _keysLengths[i] = binaryReader.ReadUInt16();
                }

                for (int i = 0; i < _keysSize; ++i)
                {
                    byte[] bytes = binaryReader.ReadBytes((int)_keysLengths[i]);
                    _keys[i] = Encoding.ASCII.GetString(bytes);
                }
            }

            return this;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\mctest\MCContext.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Web;

namespace xonline.test.MCService
{
    public class MCContext : IAsyncResult
    {
        public uint frontdoorSeqNum = 0;
        private ManualResetEvent callCompletedEvent = null;
        private bool isCompleted = false;
        public byte[] rgbRequest = null;
        public uint dwBytesLeft = 0;
        public bool fWaitForResponse;
        public byte[] Response;

        public DateTime waitTableAdded = DateTime.Now;

        public Exception excep = null;

        private static int _seqNum;
        
        static MCContext()
        {
            _seqNum = 0;
        }

        public MCContext(MCMessage Request, bool _fWaitForResponse)
        {
            frontdoorSeqNum = NewSeqNum();
            Request._Header.dwSeqNum = frontdoorSeqNum;
            rgbRequest = (byte[])Request;
            dwBytesLeft = 0;
            isCompleted = false;
            excep = null;
            callCompletedEvent = null;
            fWaitForResponse = _fWaitForResponse;
            Response = null;
        }

        // IAsyncResult interface property implementations
        public object AsyncState
        {
            get
                {
                    return null;
                }
        }

        public bool CompletedSynchronously
        {
            get
                {
                    return(false);
                }
        }

        public bool IsCompleted
        {
            get
                {
                    return(isCompleted);
                }
        }

        public WaitHandle AsyncWaitHandle
        {
            get
                { 
                    if (callCompletedEvent == null)
                    {
                        callCompletedEvent = new ManualResetEvent(false);
                    }
                    
                    return callCompletedEvent;
                }
        }


        // This does the work required to tell ASP.Net that an async call
        // is complete.
        public void CompleteRequest()
        {
            isCompleted = true;

            if (callCompletedEvent != null)
            {
                callCompletedEvent.Set();
            }
        }

        private static uint NewSeqNum()
        {
            uint seqNum = unchecked((uint)Interlocked.Increment(ref _seqNum));
            if (seqNum == 0)
            {
                // we never want to use 0 as a seqNum because it is not considered
                // a valid sequence number. So get a different one until it is not zero.
                // Note recursion.
                seqNum = NewSeqNum();
            }
            return seqNum;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\gui\BasicPresenceData.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Reflection;
using System.Windows.Forms;

using xonline.common.protocol.SubNoti;

namespace XConnSrvTestApp
{
    partial class BasicPresenceData : Form
    {
        public BasicPresenceData()
        {
            InitializeComponent();
        }

        #region Assembly Attribute Accessors

        public string AssemblyTitle
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyTitleAttribute), false);
                if (attributes.Length > 0)
                {
                    AssemblyTitleAttribute titleAttribute = (AssemblyTitleAttribute)attributes[0];
                    if (titleAttribute.Title != "")
                    {
                        return titleAttribute.Title;
                    }
                }
                return System.IO.Path.GetFileNameWithoutExtension(Assembly.GetExecutingAssembly().CodeBase);
            }
        }

        public string AssemblyVersion
        {
            get
            {
                return Assembly.GetExecutingAssembly().GetName().Version.ToString();
            }
        }

        public string AssemblyDescription
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyDescriptionAttribute), false);
                if (attributes.Length == 0)
                {
                    return "";
                }
                return ((AssemblyDescriptionAttribute)attributes[0]).Description;
            }
        }

        public string AssemblyProduct
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyProductAttribute), false);
                if (attributes.Length == 0)
                {
                    return "";
                }
                return ((AssemblyProductAttribute)attributes[0]).Product;
            }
        }

        public string AssemblyCopyright
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCopyrightAttribute), false);
                if (attributes.Length == 0)
                {
                    return "";
                }
                return ((AssemblyCopyrightAttribute)attributes[0]).Copyright;
            }
        }

        public string AssemblyCompany
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCompanyAttribute), false);
                if (attributes.Length == 0)
                {
                    return "";
                }
                return ((AssemblyCompanyAttribute)attributes[0]).Company;
            }
        }
        #endregion

        private unsafe void btnOK_Click(object sender, EventArgs e)
        {
            byte[] rgbData = new byte[sizeof(BASIC_PRESENCE_DATA)];
            fixed (byte* pData = rgbData)
            {
                BASIC_PRESENCE_DATA* pBlob = (BASIC_PRESENCE_DATA*)pData;
                pBlob->dwTitleID = UInt32.Parse(txtTitleID.Text);
                pBlob->mtLastSeen = UInt32.Parse(txtLastSeen.Text);
                pBlob->qwSessionID = UInt64.Parse(txtSessionID.Text);
                pBlob->dwState = UInt32.Parse(txtState.Text);

                byte[] rgbGamertag = System.Text.Encoding.ASCII.GetBytes(txtGamertag.Text);
                System.Buffer.BlockCopy(rgbGamertag, 0, rgbData, sizeof(BASE_DATA_HEADER), rgbGamertag.Length);

            }
            XCSTAMain.Instance.dataPayload = new byte[sizeof(BASIC_PRESENCE_DATA) - sizeof(BASE_DATA_HEADER)];
            System.Buffer.BlockCopy(rgbData, sizeof(BASE_DATA_HEADER), XCSTAMain.Instance.dataPayload, 0, XCSTAMain.Instance.dataPayload.Length);
            this.Close();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\PresenceStateUpdater\PresenceStateUpdater.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using xonline.common.diagnostics;
using xonline.common.config;
using xonline.common.service;

[assembly: RootNode(typeof(AccelTest.AccelTest))]

namespace AccelTest
{
    [Owner("KKline"),TestFrequency("Regression")]
    public class AccelTest : TestNode
    {
        public override void PreRun(RUN_TYPE runType)
        {
            if (runType != RUN_TYPE.STRESS)
            {
                return;
            }

            AccelStressManager.Initialize(Global.Config);
        }
        
    }
        /*
          override public StressTestBaseList GetStressTests()
          {
          StressTestBaseList tests = new StressTestBaseList();
          tests.Add(typeof(AccelStressInsertSmallValue),6);
          tests.Add(typeof(AccelStressInsertMediumValue),4);
          tests.Add(typeof(AccelStressInsertLargeValue),3);
          tests.Add(typeof(AccelStressSetDataSmallValue),8);
          tests.Add(typeof(AccelStressSetDataMediumValue),2);
          tests.Add(typeof(AccelStressSetDataLargeValue),1);
          tests.Add(typeof(AccelStressSetDataExistingKey),4);
          tests.Add(typeof(AccelStressQueryForSmallValue),11);
          tests.Add(typeof(AccelStressQueryForMediumValue),8);
          tests.Add(typeof(AccelStressQueryForLargeValue),8);
          tests.Add(typeof(AccelStressQueryForExpiredKey),8);
          tests.Add(typeof(AccelStressQueryForNonExpiredValue),10);
          tests.Add(typeof(AccelStressIncrementCreateNew),10);
          tests.Add(typeof(AccelStressIncrementExisting),10);
          tests.Add(typeof(AccelStressRemoveOneValue),2);
          tests.Add(typeof(AccelStressRemovePrefix),1);
          tests.Add(typeof(AccelStressInsertExisitingKey),2);
          tests.Add(typeof(AccelStressQueryNonExisitingKey),2);
          tests.Add(typeof(AccelStressRemoveNonExisitingKey),2);

          return tests;
          }


          }*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\mctest-generatenotifs\MCClient.cs ===
using System;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;

using xonline.common.mgmt;
using xonline.common.protocol.SubNoti;
using xonline.server.XConnSrv;

namespace xonline.server.XConnSrv
{
    public class MemCacheImpl : IMemCache
    {
        static event DataChangeNotification Notification;

        const string c_SpecialTimerXUID = "93CFBBBBBBBBB";
        const uint c_SpecialTimerTitleId = 0xAAAABBBB;
        
        Thread m_Thread = null;
        SortedDictionary<string, NotificationSchedule> m_Schedules;

        // Milliseconds between notification checks.  Implicitly also the
        // smallest notification schedule
        const int c_NotificationInterval = 100;

        private int m_NotificationsPerSend = 1;

        public MemCacheImpl()
        {
            m_Schedules = new SortedDictionary<string, NotificationSchedule>();

            // Register the xmgmtcmd handler
            //
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

            // Start the worker thread that will generate notifications
            //
            m_Thread = new Thread(new ThreadStart(ThreadWorker));
            m_Thread.Start();
        }

        ~MemCacheImpl()
        {
            if (m_Thread != null)
                m_Thread.Abort();
        }

        public string GetImplementationName()
        {
            return "MCTest-GenerateNotifs";
        }

        public byte[][] BulkRequestData(string[] rgKeys, object[] rgKeyStates)
        {
            List<byte[]> dataList = new List<byte[]>();

            foreach (string key in rgKeys)
                dataList.Add(RequestData(key, null));

            return dataList.ToArray();
        }

        public byte[] RequestData(string key, object keyState)
        {
            Console.WriteLine("[MCClient] RequestData({0})", key);

            byte[] rgBytes = null;

            // Special case the timer XUID
            if (key.Contains(c_SpecialTimerXUID))
            {
                Console.WriteLine("[MCClient]   Send special-case response");

                DATA_OBJECT_SPECIFIER data;

                try
                {
                    data = CreateObjectFromKey(key);
                }
                catch (FormatException ex)
                {
                    Console.WriteLine("[MCClient]   Failed to create object: {0}", ex.Message);
                    return null;
                }

                byte[] basicPresence = CreateBasicPresenceData(
                    0x00001001, // ONLINE | 360
                    c_SpecialTimerTitleId
                    );

                return GetDataObjectBytes(data, basicPresence);
            }

            // If this key doesn't exist, add this key to the schedule list
            if (!m_Schedules.ContainsKey(key))
            {
                DATA_OBJECT_SPECIFIER data;

                try
                {
                    data = CreateObjectFromKey(key);
                }
                catch (FormatException ex)
                {
                    Console.WriteLine("[MCClient]   Failed to create object: {0}", ex.Message);
                    return null;
                }

                // Add each of the defined patterns to the schedule
                //
                uint delayMs = (uint)(4000 + (m_Schedules.Count * 500)); // 4, 4.5, 5, 5.5 seconds...

                NotificationSchedule schedule = new NotificationSchedule(delayMs);
                Pattern pattern = new Pattern((ushort)(m_Schedules.Count + 1), 4);
                byte[] actualObject = null;

                for (int i = 0; i < pattern.NumItems; ++i)
                {
                    actualObject = null;

                    if (data.wDataType == (ushort)DATA_TYPES.eBasicPresence)
                    {
                        byte[] basicPresence = CreateBasicPresenceData(
                            0x00001001, // ONLINE | 360
                            pattern.GetNextBasic()
                            );
                        actualObject = GetDataObjectBytes(data, basicPresence);
                    }
                    else if (data.wDataType == (ushort)DATA_TYPES.eRichPresenceString)
                    {
                        byte[] richPresence = CreateRichPresenceData(pattern.GetNextRich());
                        actualObject = GetDataObjectBytes(data, richPresence);
                    }

                    schedule.AddData(actualObject);
                }

                // Associate the generated schedule with the data object
                //
                lock (m_Schedules)
                {
                    m_Schedules.Add(key, schedule);
                }

                Console.WriteLine("[MCClient]    Created schedule for {0} with {1} items", key, pattern.NumItems);
            }

            // Only return data we have
            if (m_Schedules.ContainsKey(key))
            {
                Console.WriteLine("[MCClient]   Returning data for {0}", key);
                rgBytes = m_Schedules[key].GetNextData();
            }

            return rgBytes;
        }

        public void PublishData(string key, byte[] data, object keyState)
        {
            Console.WriteLine("[MCClient] PublishData({0}, {1} bytes)", key, data.Length);
        }

        public DataChangeNotification DataChangeNotificationEvent
        {
            get { return Notification; }
            set { Notification += value; }
        }

        public void RegisterNotificationHandler(DataChangeNotification notificationCallback)
        {
            Console.WriteLine("[MCClient] RegisterNotificationHandler {0}", notificationCallback.Method.Name);
            Notification += notificationCallback;
        }

        public void RegisterNotificationFailureHandler(DataChangeFailureNotification failureCallback)
        {
            Console.WriteLine("[MCClient] RegisterNotificationFailureHandler {0}", failureCallback.Method.Name);
        }

        public void UnregisterHandlers()
        {
            Console.WriteLine("[MCClient] UnregisterHandlers");
        }

        public void ThreadWorker()
        {
            List<string> notifKeys = new List<string>();

            while (true)
            {
                notifKeys.Clear();

                // Create a list of keys to send notifications for
                //
                lock (m_Schedules)
                {
                    foreach (string key in m_Schedules.Keys)
                    {
                        if (m_Schedules[key].ShouldExecute)
                            notifKeys.Add(key);
                    }
                }

                if (notifKeys.Count > 0)
                {
                    object[] rgNullObjs = new object[notifKeys.Count];

                    Console.WriteLine(
                        "[MCClient] Sending {0} notifications for {1}",
                        m_NotificationsPerSend,
                        String.Join(", ", notifKeys.ToArray())
                        );

                    for (int i = 0; i < m_NotificationsPerSend; ++i)
                    {
                        Notification(notifKeys.ToArray(), rgNullObjs);
                    }
                }

                Thread.Sleep(c_NotificationInterval);
            }
        }

        DATA_OBJECT_SPECIFIER CreateObjectFromKey(string key)
        {
            // dataType:XUID:dataSubType
            string[] keyParts = key.Split(':');

            if (keyParts.Length != 3)
            {
                throw new FormatException(
                    String.Format("Key \"{0}\" could not be parsed", key)
                    );
            }

            // Parse the components of the string
            //
            ushort dwDataSubType, wDataType, wObjectSize;
            ulong qwOwnerXUID;

            switch (keyParts[0])
            {
                case "eBasicPresence":
                    unsafe
                    {
                        wDataType = (ushort)DATA_TYPES.eBasicPresence;
                        wObjectSize = (ushort)sizeof(BASIC_PRESENCE_DATA);
                    }
                    break;
                
                case "eRichPresenceString":
                    unsafe
                    {
                        wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                        wObjectSize = (ushort)sizeof(RICH_PRESENCE_DATA);
                    }
                    break;

                default:
                    throw new FormatException(
                        String.Format("Unhandled wDataType \"{0}\"", keyParts[0])
                        );
            }

            if (!ulong.TryParse(keyParts[1], System.Globalization.NumberStyles.HexNumber, null, out qwOwnerXUID))
            {
                throw new FormatException(
                    String.Format("Could not parse \"{0}\" as ulong", keyParts[1])
                    );
            }

            if (!ushort.TryParse(keyParts[2], out dwDataSubType))
            {
                throw new FormatException(
                    String.Format("Could not parse \"{0}\" as ushort", keyParts[2])
                    );
            }

            // Create the actual object
            //
            DATA_OBJECT_SPECIFIER data = new DATA_OBJECT_SPECIFIER();
            data.dwDataSubType = dwDataSubType;
            data.qwOwnerXUID = qwOwnerXUID;
            data.wDataType = wDataType;
            data.wObjectSize = wObjectSize;

            return data;
        }

        public byte[] CreateBasicPresenceData(uint state, uint titleId)
        {
            byte[] data = null;
            BASIC_PRESENCE_DATA basic = new BASIC_PRESENCE_DATA();
            basic.dwState = state;
            basic.dwTitleID = titleId;

            unsafe
            {
                fixed (BASIC_PRESENCE_DATA* bpp = (&basic))
                {
                    data = new byte[sizeof(BASIC_PRESENCE_DATA) - sizeof(BASE_DATA_HEADER)];

                    byte* d = (byte*)bpp;
                    for (int j = 0; j < data.Length; ++j)
                    {
                        data[j] = d[j + sizeof(BASE_DATA_HEADER)];
                    }
                }
            }

            return data;
        }

        public byte[] CreateRichPresenceData(ushort cbRichPresence)
        {
            byte[] data = null;
            RICH_PRESENCE_DATA rich = new RICH_PRESENCE_DATA();
            rich.cbRichPresence = cbRichPresence;

            unsafe
            {
                fixed (RICH_PRESENCE_DATA* rpp = (&rich))
                {
                    data = new byte[sizeof(RICH_PRESENCE_DATA) - sizeof(BASE_DATA_HEADER)];

                    byte* d = (byte*)rpp;
                    for (int j = 0; j < data.Length; ++j)
                    {
                        data[j] = d[j + sizeof(BASE_DATA_HEADER)];
                    }
                }
            }

            return data;
        }

        public byte[] GetDataObjectBytes(DATA_OBJECT_SPECIFIER dataObject, byte[] data)
        {
            byte[] actualData = null;

            if (data != null)
            {
                unsafe
                {
                    actualData = new byte[sizeof(BASE_DATA_HEADER) + data.Length];
                    fixed (byte* pActualData = &actualData[0])
                    {
                        BASE_DATA_HEADER* pHeader = (BASE_DATA_HEADER*)pActualData;
                        pHeader->doSpec = dataObject;
                        pHeader->dwHeaderFlags = (uint)SubNotiDefs.XONLINE_CONNSRV_DATA_FLAG_SHARE_EVERYONE;
                    }
                    data.CopyTo(actualData, sizeof(BASE_DATA_HEADER));
                }
            }

            return actualData;
        }

        public void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            StringBuilder sBuilder = new StringBuilder();
            int menuCounter = 0;

            try
            {
                switch (args.Command)
                {
                    case "help":
                        sBuilder.AppendLine();
                        sBuilder.AppendLine("MCClient Commands:");
                        sBuilder.AppendLine();
                        sBuilder.AppendLine("\tremoveschedule [*|index]");
                        sBuilder.AppendLine("\t\tRemoves the schedule at the given index, or all profiles");
                        sBuilder.AppendLine("\t\tif '*' is specified.");
                        sBuilder.AppendLine();
                        sBuilder.AppendLine("\tsetnotifrate [value]");
                        sBuilder.AppendLine("\t\tSets the number of notifications sent per schedule timer.");
                        sBuilder.AppendLine();
                        sBuilder.AppendLine("\tshowschedules");
                        sBuilder.AppendLine("\t\tShow all enabled schedules");
                        sBuilder.AppendLine();
                        sBuilder.AppendLine("\tupdatefreq [*|index] [frequency]");
                        sBuilder.AppendLine("\t\tUpdates the frequency for the schedule at the given index.");
                        sBuilder.AppendLine("\t\tThe index can be viewed with the \"showschedules\" command.");
                        sBuilder.AppendLine();
                        sBuilder.AppendLine("\twillrocks");
                        sBuilder.AppendLine("\t\tGospel truth.");
                        sBuilder.AppendLine();

                        XomControlConnection.SendMessage(sBuilder.ToString(), args.RequestId);

                        break;
                    case "removeschedule":
                        args.Handled = true;
                        int removeIndex = -1;

                        if (args.CommandArgs.Length != 1 ||
                            (args.CommandArgs[0] != "*" && !int.TryParse(args.CommandArgs[0], out removeIndex)))
                        {
                            sBuilder.AppendLine("Usage: removeschedule [*|index]");
                        }
                        else
                        {
                            if (args.CommandArgs[0] == "*")
                            {
                                lock (m_Schedules)
                                {
                                    m_Schedules.Clear();
                                }

                                sBuilder.AppendLine("Removed all schedules");
                            }
                            else if (removeIndex < 0 || removeIndex >= m_Schedules.Count)
                                sBuilder.AppendLine("Invalid index specified");
                            else
                            {
                                lock (m_Schedules)
                                {
                                    foreach (string key in m_Schedules.Keys)
                                    {
                                        if (menuCounter++ == removeIndex)
                                        {
                                            m_Schedules.Remove(key);
                                            sBuilder.AppendLine(String.Format("Removed schedule {0}", key));
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        XomControlConnection.SendMessage(sBuilder.ToString(), args.RequestId);

                        break;
                    case "setnotifrate":
                        args.Handled = true;

                        int newRate = 0;

                        if (args.CommandArgs.Length != 1 ||
                            !int.TryParse(args.CommandArgs[0], out newRate))
                        {
                            sBuilder.AppendLine(String.Format("Current notifications per schedule is {0}", m_NotificationsPerSend));
                        }
                        else
                        {
                            m_NotificationsPerSend = newRate;
                            sBuilder.AppendLine(String.Format("Set notifications per schedule to {0}", newRate));
                        }
                        break;
                    case "showschedules":
                        args.Handled = true;

                        if (m_Schedules.Count == 0)
                            sBuilder.AppendLine("No schedules are defined");

                        lock (m_Schedules)
                        {
                            foreach (string key in m_Schedules.Keys)
                            {
                                sBuilder.AppendLine();
                                sBuilder.AppendLine(String.Format("\t[{0}] - {1}", menuCounter, key));
                                sBuilder.AppendLine(String.Format("\t\tCurrentIndex  = {0}", m_Schedules[key].CurrentIndex));
                                sBuilder.AppendLine(String.Format("\t\tDataListCount = {0}", m_Schedules[key].DataListCount));
                                sBuilder.AppendLine(String.Format("\t\tFrequencyMs   = {0}", m_Schedules[key].FrequencyMs));
                                sBuilder.AppendLine(String.Format("\t\tLastExecution = {0}", m_Schedules[key].LastExecution));

                                menuCounter++;
                            }
                        }

                        if (m_Schedules.Count > 0)
                            sBuilder.AppendLine();

                        XomControlConnection.SendMessage(sBuilder.ToString(), args.RequestId);

                        break;
                    case "updatefreq":
                        args.Handled = true;

                        int scheduleIndex = -1;
                        uint frequency = 0;

                        if (args.CommandArgs.Length != 2 ||
                            (args.CommandArgs[0] != "*" && !int.TryParse(args.CommandArgs[0], out scheduleIndex)) ||
                            !uint.TryParse(args.CommandArgs[1], out frequency))
                        {
                            sBuilder.AppendLine("Usage: updatefreq [*|index] [frequency]");
                        }
                        else
                        {
                            if (args.CommandArgs[0] == "*")
                            {
                                if (m_Schedules.Count == 0)
                                    sBuilder.AppendLine("No schedules to update");
                                else
                                {
                                    lock (m_Schedules)
                                    {
                                        foreach (NotificationSchedule schedule in m_Schedules.Values)
                                            schedule.FrequencyMs = frequency;
                                    }

                                    sBuilder.AppendLine("Updated frequency for all schedules");
                                }
                            }
                            else if (scheduleIndex < 0 || scheduleIndex >= m_Schedules.Count)
                            {
                                sBuilder.AppendLine("Invalid schedule number");
                            }
                            else
                            {
                                lock (m_Schedules)
                                {
                                    foreach (string key in m_Schedules.Keys)
                                    {
                                        if (menuCounter++ == scheduleIndex)
                                        {
                                            m_Schedules[key].FrequencyMs = frequency;

                                            sBuilder.AppendLine(String.Format("Updated frequency for {0}", key));
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        XomControlConnection.SendMessage(sBuilder.ToString(), args.RequestId);
                        break;
                    case "willrocks":
                        args.Handled = true;
                        sBuilder.AppendLine("yeah he does");
                        XomControlConnection.SendMessage(sBuilder.ToString(), args.RequestId);
                        break;
                }
            }
            catch (Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }
    }

    /// <summary>
    /// Unique data members that identify a basic presence record
    /// </summary>
    public struct BasicPresenceEntry
    {
        public uint State;
        public uint TitleId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\PresenceStateUpdater\PresenceStateUpdaterManager.cs ===
using System;
using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Core.Utilities;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;
using xonline.common.protocol.SubNoti;
using xonline.server.XConnSrv;
using xonline.common.community;



namespace AccelTest
{
     public class AccelStressManager 
     {
          public static Report _report = new Report("Log");
          
          //these variables keep track of value sizes to make querying for different types of values much easier (also use for other small things)
          private static List<uint> proppedTitles = new List<uint>();
         private static Acceleration accel = new Acceleration();
         private static RandomEx _random = new RandomEx();
         private static ulong _baseXuid = 0;
         private static int _xuidCount = 0;
         private static List<ulong> onlineXuids = new List<ulong>();

         //protected static IMemCache s_MemCache = null;
         protected static ASCIIEncoding _enc = new ASCIIEncoding();
          
         
          public AccelStressManager() 
          {
          }

         public static ulong GetRandomXuid()
         {
             int increase = _random.Next(_xuidCount);
             return (_baseXuid + (ulong) increase);
         }

         public static ulong GetRandomOnlineXuid()
         {
             ulong xuid = 0;
             lock (onlineXuids)
             {
                 if (onlineXuids.Count == 0)
                 {
                     _report.Info("No online xuids detected. Returning 0...");
                 }
                 else
                 {
                     int index = _random.Next(onlineXuids.Count);
                     xuid = onlineXuids[index];
                 }
             }
             return xuid;
         }


        private static BasicPresence BuildBasicPresence(ulong qwUserID, uint title, uint state)
        {
            //getgamertag
            //string[] retval = XCache.LookupGamerTags(new ulong[] { qwUserID });
            //string gamertag = retval[0];
            string gamertag = "OX" + qwUserID.ToString("X");

            BasicPresence basic = new BasicPresence();
            basic.OwnerID = qwUserID;
            basic.sGamertag = gamertag;
            basic.dwTitleID = title;
            basic.dwState = state;
            basic.HeaderFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;

            return basic;
        }

        private static LimitedPresence BuildLimitedPresence(ulong qwUserID, uint title, uint state)
        {
            //getgamertag
            //string[] retval = XCache.LookupGamerTags(new ulong[] { qwUserID });
            //string gamertag = retval[0];
            string gamertag = "OX" + qwUserID.ToString("X");

            LimitedPresence limited = new LimitedPresence();
            limited.OwnerID = qwUserID;
            limited.sGamertag = gamertag;
            limited.dwTitleID = title;
            limited.dwState = state;
            limited.HeaderFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;

            return limited;
        }

        private static LanguageSpecificData BuildRichPresence(Dictionary<string, string> localesWithStrings, ulong qwUserID)
        {
            // get the locales for this title.
            string[] locales = new string[localesWithStrings.Count];
            string[] localizedStrings = new string[localesWithStrings.Count];
            localesWithStrings.Keys.CopyTo(locales, 0);
            localesWithStrings.Values.CopyTo(localizedStrings, 0);

            LanguageSpecificData lsBlob = new LanguageSpecificData(DATA_TYPES.eRichPresenceString);
            lsBlob.OwnerID = qwUserID;
            lsBlob.HeaderFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | CacheUtil.XONLINE_CACHE_DATA_FLAG_LANGUAGE_SPECIFIC;
            lsBlob.rgLocales = locales;
            lsBlob.rgInnerBlobs = new BaseDataHeader[localizedStrings.Length];

            for (int iString = 0; iString < localizedStrings.Length; iString++)
            {
                RichPresenceData rich = new RichPresenceData();
                rich.header = lsBlob.header;
                rich.sRichPresence = localizedStrings[iString];
                
                lsBlob.rgInnerBlobs[iString] = rich;
            }

            return lsBlob;
        }


         public static void InsertRichPresenceBlob(ulong qwUserID)
         {
             //build the RP blob
             int randomNum = _random.Next(5000);
             string englishRPString = "Custom RichPresence string from StateUpdater tool #" + randomNum.ToString();

             Dictionary<string, string> temp = new Dictionary<string, string>();
             //
             temp.Add("en-US", "en-US " + englishRPString); // ENGLISH
             temp.Add("es-ES", "es-ES " + englishRPString); // SPANISH
             temp.Add("fr-FR", "fr-FR " + englishRPString); // FRENCH
             temp.Add("de-DE", "de-DE " + englishRPString); // GERMAN
             temp.Add("it-IT", "it-IT " + englishRPString); // ITALIAN
             temp.Add("ja-JP", "ja-JP " + englishRPString); // JAPANESE
             temp.Add("ko-KR", "ko-KR " + englishRPString); // KOREAN
             temp.Add("zh-CN", "zh-CN " + englishRPString); // SIMPLIFIED CHINESE
             temp.Add("pl-PL", "pl-PL " + englishRPString); // POLISH
             temp.Add("pt-PT", "pt-PT " + englishRPString); // PORTUGUESE
             temp.Add("ru-RU", "ru-RU " + englishRPString); // RUSSIAN
             //temp.Add("zh-CHT","zh-CHT " + englishRPString); // TRADITIONAL CHINESE


             LanguageSpecificData lsBlob = BuildRichPresence(temp, qwUserID);
             CacheUtil.OverwriteCache(lsBlob);
         }
         
        private static uint XONLINE_FRIENDSTATE_FLAG_ONLINE =                    0x00000001;
        private static uint XONLINE_FRIENDSTATE_FLAG_PLAYING =                   0x00000002;
        //private static uint XONLINE_FRIENDSTATE_FLAG_VOICE =                     0x00000008;
        private static uint XONLINE_FRIENDSTATE_FLAG_JOINABLE=                   0x00000010;
        private static uint XONLINE_FRIENDSTATE_FLAG_JOINABLE_FRIENDS_ONLY=      0x00000100;
        private static uint XONLINE_FRIENDSTATE_ENUM_AWAY=                       0x00010000;
        private static uint XONLINE_FRIENDSTATE_ENUM_BUSY=                       0x00020000;
        //private static uint XONLINE_FRIENDSTATE_ENUM_CONSOLE_XBOX1=              0x00000000;
        private static uint XONLINE_FRIENDSTATE_ENUM_CONSOLE_XBOX360=            0x00001000;
        //private static uint XONLINE_FRIENDSTATE_ENUM_CONSOLE_WINPC=              0x00002000;
        private static uint XONLINE_FRIENDSTATE_FLAG_PARTY_JOINABLE=             0x00000200;
        private static uint XONLINE_FRIENDSTATE_FLAG_PARTY_JOINABLE_FRIENDS_ONLY=0x00000400;
        private static uint XONLINE_FRIENDSTATE_FLAG_PARTY_PLAYING=              0x00000800;
        //private static uint XONLINE_FRIENDSTATE_MASK_PARTY_COUNTER=              0x00300000;

         private static uint BuildRandomOnlineState()
         {
             uint state = 0x1001; //online on a x360
             int num = _random.Next(0, 2);
             if (num == 0)
             {
                 state |= XONLINE_FRIENDSTATE_FLAG_PLAYING;
             }
             num = _random.Next(0, 2);
             if (num == 0)
             {
                 state |= XONLINE_FRIENDSTATE_FLAG_JOINABLE;
             }
             num = _random.Next(0, 2);
             if (num == 0)
             {
                 state |= XONLINE_FRIENDSTATE_FLAG_JOINABLE_FRIENDS_ONLY;
             }
             num = _random.Next(0, 2);
             if (num == 0)
             {
                 num = _random.Next(0, 2);
                 if (num == 0)
                 {
                     state |= XONLINE_FRIENDSTATE_ENUM_AWAY;
                 }
                 else
                 {
                     state |= XONLINE_FRIENDSTATE_ENUM_BUSY;
                 }
             }
             num = _random.Next(0, 2);
             if (num == 0)
             {
                 state |= XONLINE_FRIENDSTATE_FLAG_PARTY_PLAYING;
                 state |= XONLINE_FRIENDSTATE_FLAG_PARTY_JOINABLE;
                 state |= XONLINE_FRIENDSTATE_FLAG_PARTY_JOINABLE_FRIENDS_ONLY;
             }
             num = _random.Next(0, 2);
             if (num == 0)
             {
                 state |= XONLINE_FRIENDSTATE_FLAG_PARTY_PLAYING;
             }

             return state;
         }

         public static void LogInLogOut(ulong qwUserID)
         {
             uint state = 0x0;
             //see if he is online
             bool online = false;
             lock (onlineXuids)
             {
                 if (onlineXuids.Contains(qwUserID))
                 {
                     online = true;
                 }
             }
             if (online == false)
             {
                 //log him in
                 state = XONLINE_FRIENDSTATE_FLAG_ONLINE | XONLINE_FRIENDSTATE_ENUM_CONSOLE_XBOX360;
             }
             
             //start out in dashboard
             uint title = 0xFFFE07D1;

             InsertBasicPresence(qwUserID, title, state);

         }

         public static void UpdateBasicPresenceBlob(ulong qwUserID)
         {
             //should be online
             bool online = false;
             lock (onlineXuids)
             {
                 if (onlineXuids.Contains(qwUserID))
                 {
                     online = true;
                 }
             }
             if (online == false)
             {
                 _report.Warn("User not online, can't call update basic presence blob on offline user.");
                 return;
             }

             //start out with basic stuff
             uint title = 0xFFFE07D1;
             uint state = BuildRandomOnlineState();

             InsertBasicPresence(qwUserID, title, state);
             
         }

         private static void InsertBasicPresence(ulong qwUserID, uint title, uint state)
         {
             BasicPresence basic = BuildBasicPresence(qwUserID, title, state);
             CacheUtil.OverwriteCache(basic);

             LimitedPresence limited = BuildLimitedPresence(qwUserID, title, state);
             CacheUtil.OverwriteCache(limited);

             //correct the onlinexuids list
             bool online = false;
             if ((state & XONLINE_FRIENDSTATE_FLAG_ONLINE) > 0)
             {
                 online = true;
             }

             lock (onlineXuids)
             {
                 bool exists = false;
                 if (onlineXuids.Contains(qwUserID))
                 {
                     exists = true;
                 }
                 if (online && !exists)
                 {
                     onlineXuids.Add(qwUserID);
                 }
                 if (!online && exists)
                 {
                     onlineXuids.Remove(qwUserID);
                 }
             }
         }

          //read settings from xml file, make bucket map using Config
          //returns -1 if no xml settings file found
          public static int Initialize(XmlDocument config)
          {
               int retval = 0;

              //load the XML file that will give us the XUIDS to play with
               XmlNode StressSettings = config.SelectSingleNode("descendant::XUIDInfo");
               _report.Info("Beginning Initialization, this should take a few minutes");
               if (StressSettings == null) 
               {
                   _report.Error("Did not correctly parse PresenceStateUpdater.xml. Did you pass it in when initialize?");
                   throw new Exception("Could not parse XMLDocument. Please be sure StateUpdater.XML is passed into the initialization parameters when launching this DLL.");
               }
               else
               {
                    //read in the settings from the xml file
                   string bx = StressSettings.SelectSingleNode("BaseXUID").InnerXml;
                   _baseXuid = (ulong) Int64.Parse(bx);
                   string xc = StressSettings.SelectSingleNode("Count").InnerXml;
                   _xuidCount = (int) Int32.Parse(xc);
                   _report.Info("base xuid = " + _baseXuid.ToString() + " and count = " + _xuidCount);
               }

                //should add for version 2.0 of this tool
                //load the memcache (acceleration)
                //try
                //{
                //    string dllName = Config.GetSetting(Setting.XConnSrv_MemCacheDllName);
                //    _report.Info("dll found named " + dllName);
                //    s_MemCache = (IMemCache)Activator.CreateInstance(Type.GetType("xonline.server.XConnSrv.MemCacheImpl," + dllName));

                //    _report.Info("Loaded MemCache implementation: " + dllName + ".");
                //}
                //catch (Exception e)
                //{
                //    s_MemCache = null;
                //    _report.Error("Could not load MemCache implementation.\n"+e.ToString());
                //}



               _report.Info("Initialization Done!");
               return retval;
          }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\mctest-generatenotifs\NotificationSchedule.cs ===
﻿using System;
using System.Collections.Generic;
using xonline.common.protocol.SubNoti;

namespace xonline.server.XConnSrv
{
    class NotificationSchedule
    {
        private int m_CurrentIndex;
        private uint m_FrequencyMs;
        private DateTime m_LastExecution;
        private List<byte[]> m_DataList;

        // Constructor
        //
        public NotificationSchedule(uint frequencyMs)
        {
            m_FrequencyMs = frequencyMs;
            m_LastExecution = DateTime.Now;
            m_DataList = new List<byte[]>();
            m_CurrentIndex = 0;
        }

        // Properties
        //
        public int CurrentIndex
        {
            get { return m_CurrentIndex; }
        }

        public uint FrequencyMs
        {
            set { m_FrequencyMs = value; }
            get { return m_FrequencyMs; }
        }

        public int DataListCount
        {
            get { return m_DataList.Count; }
        }

        public DateTime LastExecution
        {
            get { return m_LastExecution; }
        }

        public bool ShouldExecute
        {            
            get
            {
                TimeSpan ts = DateTime.Now.Subtract(m_LastExecution);
                return ts.TotalMilliseconds > m_FrequencyMs;
            }
        }

        // Methods
        //
        public byte[] GetNextData()
        {
            if (m_DataList.Count == 0)
                throw new IndexOutOfRangeException("Must add data before calling GetNextData()");

            byte[] rgReturnData = m_DataList[m_CurrentIndex];

            if (++m_CurrentIndex >= m_DataList.Count)
                m_CurrentIndex = 0;

            m_LastExecution = DateTime.Now;

            return rgReturnData;
        }

        public void AddData(byte[] data)
        {
            m_DataList.Add(data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\PresenceStateUpdater\PresenceStateUpdaterFunctions.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.protocol;
using xonline.common.service;
using ServerTestFramework.Core.Utilities;

namespace AccelTest
{
    [StressInstantiate]
    class AccelStressTestBase : TestBase
    {
        public static AccelStressManager _xbsm = new AccelStressManager();
    }

    [StressTest, EnvRequirement("Stress")]
    class AccelLogInLogOutUsers : AccelStressTestBase
    {
        private static Report _report = new Report("Log");

        override protected void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;

            ulong xuid = AccelStressManager.GetRandomXuid();
            try
            {
                AccelStressManager.LogInLogOut(xuid);
            }
            catch (Exception e)
            {
                AccelStressManager._report.Warn(e.ToString());
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [StressTest, EnvRequirement("Stress")]
    class AccelUpdateBasicPresence : AccelStressTestBase
    {
        private static Report _report = new Report("Log");

        override protected void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;

            ulong xuid = AccelStressManager.GetRandomOnlineXuid();
            try
            {
                AccelStressManager.UpdateBasicPresenceBlob(xuid);
            }
            catch (Exception e)
            {
                AccelStressManager._report.Warn(e.ToString());
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }



    [StressTest, EnvRequirement("Stress")]
    class AccelUpdateRichPresence : AccelStressTestBase
    {
        private static Report _report = new Report("Log");

        override protected void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;

            ulong xuid = AccelStressManager.GetRandomOnlineXuid();
            try
            {
                AccelStressManager.InsertRichPresenceBlob(xuid);
            }
            catch (Exception e)
            {
                AccelStressManager._report.Warn(e.ToString());
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\mctest-generatenotifs\Pattern.cs ===
﻿using System;

namespace xonline.server.XConnSrv
{
    class Pattern
    {
        private ushort m_BasicValue = 1, m_RichValue = 1;
        private ushort m_PatternId, m_NumItems;

        public ushort NumItems
        {
            get { return m_NumItems; }
        }

        public ushort PatternId
        {
            get { return m_PatternId; }
        }

        public Pattern(ushort patternId, ushort numItems)
        {
            if (patternId == 0)
                throw new ArgumentException("patternId must be greater than 0");

            if (numItems == 0)
                throw new ArgumentException("numItems must be greater than 0");

            m_PatternId = patternId;
            m_NumItems = numItems;
        }

        public uint GetNextBasic()
        {
            uint retValue = (uint)((m_PatternId << 16) + m_BasicValue);

            if (++m_BasicValue > m_NumItems)
                m_BasicValue = 1;

            return retValue;
        }

        public ushort GetNextRich()
        {
            ushort retValue = m_RichValue;

            if (++m_RichValue > m_NumItems)
                m_RichValue = 1;

            return retValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncConnectNeg.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Negative tests for Connect
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncConnect_NegativeCases : TestNode
    {
        /// <summary>
        /// Connect multiple users to the same index. The connection is expected to be dropped
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class MultipleUsersSameIndex : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);

                // Create initial connection, with 2 users, both on the same index. TryConnectAndVerify should fail when it tests
                // that a connection exists
                connection = users[0].Xbox.ConnectionServerConnection; //new PNConnection(users[0].Xbox.XboxId);
                CONNECT_REPLY reply = connection.Connect(new int[] { 0, 0 }, new ulong[] { users[0].UserId, users[1].UserId });
                Assert.IsTrue((uint)reply.hr == HResult.E_INVALIDARG, "Invalid arg returned");

                Global.RO.Info("Sleeping 1 second to let Connection Server be happy...");
                Thread.Sleep(1000);

                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "User0 at index 0");
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 1), "User0 at index 1");
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 0), "User1 at index 0");
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "User1 at index 1");
            }
        }

        /// <summary>
        /// Connects the same user to multiple indices. Expected to work
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class MultipleIndicesSameUser : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);

                for (int i = 1; i < XConnSrvTestHelpers.MAX_LOGON_USERS; ++i)
                {
                    int[] userIndices = new int[i + 1];
                    ulong[] userIds = new ulong[i + 1];

                    for (int j = 0; j <= i; ++j)
                    {
                        userIndices[j] = j;
                        userIds[j] = users[i].UserId;
                    }

                    // Create connection, with 1 user on multiple indices, connection is expected to fail
                    if (XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Sends the connect message with mismatched lengths of indices and userIds, having more Ids
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class MismatchedIndicesIdsSizesMoreIds : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);

                int[] userIndices = new int[] { 0 };
                ulong[] userIds = new ulong[] { users[0].UserId, users[1].UserId };

                // Create initial connection, with 2 users on only 1 index
                if (XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.E_INVALIDARG, userIndices, userIds, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify there is no connection remaining. Should be added on server.

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Sends the connect message with mismatched lengths of indices and userIds, having more indices
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class MismatchedIndicesIdsSizesMoreIndices : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);

                int[] userIndices = new int[] { 0, 1 };
                ulong[] userIds = new ulong[] { users[0].UserId };

                connection = users[0].Xbox.ConnectionServerConnection;

                // Create initial connection, with 2 users on only 1 index
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.E_INVALIDARG, userIndices, userIds, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("Sleeping 1 second to let Connection Server be happy...");
                Thread.Sleep(1000);

                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "User at index 0");
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 1), "User at index 1");

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Sends the disconnect message before sending the connect message
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class DisconnectBeforeConnect : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);

                PNConnection connection = new PNConnection(users[0].Xbox.XboxId);

                try
                {
                    DISCONNECT_REPLY reply = connection.Disconnect(0);
                    Assert.IsTrue(true, "Should not reach here.");
                }
                catch (Exception)
                {
                    //Calling disconnect before connect results in timeout exception and connection closed. 
                    //Talked with dev and he is not too worried about disconnect calls, so swallowing this exception.
                }

                
            }
        }

        /// <summary>
        /// Attemps to connect a 5th user after 4 are already connected
        /// </summary>
        [Ignore("Only passes if SG bit is set on t_settings for xconnsrv.")]
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class Add5thUserToConnection : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(5, false, false);

                // Create initial connection with 1 user
                int[] UserIndices = new int[] { 0 };
                //Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // We are connected with only user index 0. Now try adding 3 more users to the connection.
                for (int i = 1; i < users.Length - 1; i++)
                {
                    try
                    {
                        UserIndices = new int[i + 1];
                        ulong[] userIds = new ulong[i + 1];

                        for (int j = 0; j <= i; ++j)
                        {
                            UserIndices[j] = j;
                            userIds[j] = users[j].UserId;
                        }
                        if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, userIds, users[i].Xbox.XboxId))
                            ResultCode = TEST_RESULTS.FAILED;
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error("Connect (for additional users) Failed: " + e.Message);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                //Add the 5th user.
                UserIndices = new int[5];
                ulong[] Ids = new ulong[5];
                for (int j = 0; j < 5; j++)
                {
                    UserIndices[j] = j;
                    Ids[j] = users[j].UserId;
                }
                try
                {
                    //expect invalid arg.
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.E_INVALIDARG, UserIndices, Ids, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                }
                catch (Exception)
                {
                    //This is expected exception. Ignore it.
                }

                //at this point since last call failed, everyone is disconnected.
                for (int j = 0; j < 5; j++)
                {
                    if (XConnSrvTestHelpers.IsUserConnected(users[j].UserId, j))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Attempts to connect with no users or indices
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class ConnectNoUsers : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);

                // Connect with no users
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[0], new ulong[0], users[0].Xbox.XboxId))
                {
                    Global.RO.Error("Connection not created with no users.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Attempts to connect one valid (connected to SG) and one invalid user at the same time
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class ConnectOneValidOneInvalidUser : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create two users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, false, true);
                PNUser validUser = users[0];
                PNUser invalidUser = users[1];

                // Sign in the valid user
                validUser.Connect(users[0].Xbox);
                validUser.Alive();

                // Connect with both valid and invalid users
                if (XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { validUser.UserId, invalidUser.UserId }, users[0].Xbox.XboxId))
                {
                    Global.RO.Error("Connection was created with an invalid user.");
                    ResultCode = TEST_RESULTS.FAILED;

                    // Disconnect
                    XConnSrvTestHelpers.TryDisconnectAndVerify(connection);
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncConnect.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Connect
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(3)]
    [Owner("Shailesh")]
    public class FuncConnect_PostiveCases : TestNode
    {
        /// <summary>
        /// Basic BVT Test which connects a single user on a single connection then disconnect
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVT_SingleUser : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create one user.
                PNUser testuser = PNUsersBuilder.GetLiveXenonUsers(1, true, false)[0];

                //Connect at UserIndex 0
                Assert.IsTrue(XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { testuser.UserId }, testuser.Xbox.XboxId), "Connected.");

                //Disconnect
                Assert.IsTrue(XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }));
            }
        }

        /// <summary>
        /// Connect a single user on each of 4 indices, one at a time, on a different connection, then disconnect
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class Basic_SameUserDifferentIndicesWithNewConnection : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);

                for (int i = 0; i < XConnSrvTestHelpers.MAX_LOGON_USERS; i++)
                {
                    //Use all index one by one.
                    int[] UserIndices = new int[] { i };
                    //Connect with new connection every time.
                    connection = new PNConnection(users[0].Xbox.XboxId);
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    //Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, UserIndices))
                        ResultCode = TEST_RESULTS.FAILED;

                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connect a single user on each of 4 indices, one at a time, on the same connection, then disconnect
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class Basic_SameUserDifferentIndicesReuseConnection : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);

                for (int i = 0; i < XConnSrvTestHelpers.MAX_LOGON_USERS; i++)
                {
                    //Use all index one by one.
                    int[] UserIndices = new int[] { i };
                    //Connect with same connection every time.
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connect 4 different users on the same index on on different connections then disconnect
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class Basic_RotateDifferentUserOnSameIndexWithNewConnection : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, false);

                //Use same index for all attempts
                int[] UserIndices = new int[] { 0 };

                for (int i = 0; i < users.Length; i++)
                {
                    //Connect with new connection every time.
                    connection = new PNConnection(users[i].Xbox.XboxId);
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[i].UserId }, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    //Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, UserIndices))
                        ResultCode = TEST_RESULTS.FAILED;
                }
                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connect 4 different users on the same index on the same connection then disconnect
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class Basic_RotateDifferentUserOnSameIndexReuseConnection : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);

                //Use same index for all attempts
                int[] UserIndices = new int[] { 0 };

                for (int i = 0; i < users.Length; i++)
                {
                    //Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[i].UserId }, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connect 4 different users on different indices on different connections then disconnect
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class Basic_RotateDifferentUserOnDifferentIndicesWithNewConnection : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, false);

                for (int i = 0; i < users.Length; i++)
                {
                    int[] UserIndices = new int[] { i };
                    //Connect with new connection every time.

                    connection = new PNConnection(users[i].Xbox.XboxId);
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[i].UserId }, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    //Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, UserIndices))
                        ResultCode = TEST_RESULTS.FAILED;
                }
                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connect 4 different users on different indices (disconnecting the previous) on the same connection then disconnect
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class Basic_RotateDifferentUserOnDifferentIndicesReuseConnection : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);

                for (int i = 0; i < users.Length; i++)
                {
                    int[] UserIndices = new int[] { i };
                    //Connect 
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[i].UserId }, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connect 2 users at a time (0+2 then 1+3) to the same connection then disconnect
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class Basic_UserPairConnecting : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);

                int[] UserIndices;
                
                //Try first pair of users.
                UserIndices = new int[] { 0, 2 };
                //Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                //Try second pair of user.
                UserIndices = new int[] { 1, 3 };
                //Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[2].UserId, users[3].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, UserIndices))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connect all 4 users at the same time to the same connection then disconnect
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class Basic_FourUsersConnecting : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);

                int[] UserIndices;

                UserIndices = new int[] { 0, 1, 2, 3 };
                //Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[0].UserId, users[1].UserId, users[2].UserId, users[3].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, UserIndices))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 different times on different indicies with different connections, but using the same
        /// xbox console, then disconnects
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class Basic_UseNewConnectionEachTimeFromOneConsole : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;
                Hashtable connections = new Hashtable();

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);

                for (int i = 0; i < users.Length; i++)
                {
                    int[] UserIndices = new int[] { i };

                    //create new connection to create 4 individual connections.
                    connection = new PNConnection(users[i].Xbox.XboxId);

                    //Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[i].UserId }, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    connections.Add(i, connection);
                }
                for (int i = 0; i < users.Length; i++)
                {
                    int[] UserIndices = new int[] { i };
                    //Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connections[i] as PNConnection, UserIndices))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users, one at a time, adding a new user each time, on the same connection
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class Basic_FourUsersConnectingOneByOne : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);

                int[] UserIndices=null;
                ulong[] userIds;
                for (int i = 0; i < users.Length; i++)
                {
                    UserIndices = new int[i + 1];
                    userIds = new ulong[i + 1];
                    //build user indice..
                    for (int j = 0; j <= i; j++)
                    {
                        UserIndices[j] = j;
                        userIds[j] = users[j].UserId;

                    }
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, userIds, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, UserIndices))
                    ResultCode = TEST_RESULTS.FAILED;

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users, one at a time, adding a new user each time, and then disconnects one user at a
        /// time by calling connect with 1 user less each time
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class Basic_FourUsersConnectingAndDisconnectingOneByOne : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);

                int[] UserIndices=null;
                ulong[] userIds;
                for (int i = 0; i < users.Length; i++)
                {
                    UserIndices = new int[i + 1];
                    userIds = new ulong[i + 1];
                    //build user indice..
                    for (int j = 0; j <= i; j++)
                    {
                        UserIndices[j] = j;
                        userIds[j] = users[j].UserId;

                    }
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, userIds, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                }
                //Now call connect in reverse order so that it will disconnect users.
                for (int i = users.Length - 1; i >= 0; i--)
                {
                    UserIndices = new int[i + 1];
                    userIds = new ulong[i + 1];
                    //build user indice..
                    for (int j = 0; j <= i; j++)
                    {
                        UserIndices[j] = j;
                        userIds[j] = users[j].UserId;

                    }
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, userIds, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                //Disconnect the last guy
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, UserIndices))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates 32 connects and connects 1 unique user on each, then disconnects
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class Basic_Create32Connection : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;
                Hashtable connections = new Hashtable();

                //Create users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(32, true, false);

                for (int i = 0; i < users.Length; i++)
                {
                    int[] UserIndices = new int[] { 0 };
                    //create new connection to create 32 individual connections.
                    connection = new PNConnection(users[i].Xbox.XboxId);
                    //Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, new ulong[] { users[i].UserId }, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;
                    connections.Add(i, connection);
                }

                for (int i = 0; i < users.Length; i++)
                {
                    int[] UserIndices = new int[] { 0 };
                    //Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connections[i] as PNConnection, UserIndices))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Basic reconnect test. Connects a single user, disconnects, reconnects, then disconnects again
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ReconnectSingleUser : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                // Create one user
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);

                PNConnection connection = null;
                // Connect at UserIndex 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                connection = null;
                // Reconnect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId, true))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Sends reconnect call before normal connect call
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class ReconnectBeforeConnect : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);

                // Connect at UserIndex 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId, true))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                connection = null;
                // Reconnect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects with 2 users on indices 0+1, disconnects, reconnects with 2 new users on indicies 0+1
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class ReconnectWithDifferentUsersSameIndicesThanConnect : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(4, true, true);

                // Connect at UserIndex 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                connection = null;
                // Reconnect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[2].UserId, users[3].UserId }, users[0].Xbox.XboxId, true))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects with users 0+1, disconnects, reconnects with users 2+3
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class ReconnectWithDifferentUsersAndIndicesThanConnect : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(4, true, true);

                // Connect at UserIndex 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                connection = null;
                // Reconnect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 2, 3 }, new ulong[] { users[2].UserId, users[3].UserId }, users[0].Xbox.XboxId, true))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects with users 0+1, disconnects, reconnects with users 0+1+2+3
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class ReconnectWithSameAndDifferentUsersThanConnect : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(4, true, true);

                // Connect at UserIndex 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                connection = null;
                // Reconnect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1, 2, 3 }, new ulong[] { users[0].UserId, users[1].UserId, users[2].UserId, users[3].UserId }, users[0].Xbox.XboxId, true))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects a single user, reconnects with the same user without disconnecting
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class ReconnectWhileConnected : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);

                // Connect at UserIndex 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Reconnect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId, true))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncFriendsList.cs ===
﻿using System;
using System.Collections.Generic;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;
namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Singleton Connection
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(1)]
    public class FuncMemCacheFriendsListTests : TestNode
    {
        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVT_MemCacheFriendsListNotifications: TestBase
        {
            override protected void Execute()
            {
                /*
                 * Steps:
                 * Create user A
                 * Make subscription to eFriendList
                 * Create 5 users
                 * Call MakeFriend with user A for all
                 * See that 5 notifications are received.
                 * Noe: Request and Accept both will trigger change.
                 */
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Create live users
                PNUser[] friends = PNUsersBuilder.GetLiveXenonUsers(2, true, false);

                foreach (PNUser friend in friends)
                {
                    fc.MakeFriend(users[0], friend);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(3000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], friends) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                // Re Subscribe to friendslist for verifying reply
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, friends.Length);

                //Logoff test user
                fc.LogoffUser(users[0]);
                //Logoff friends.
                foreach (PNUser u in friends)
                {
                    fc.LogoffUser(u);
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MemCacheFriendsListUpdatedForDeleteFriend : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                // Subscribe to friendslist
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Create live users
                PNUser[] friends = PNUsersBuilder.GetLiveXenonUsers(2, true, false);

                foreach (PNUser friend in friends)
                {
                    fc.MakeFriend(users[0], friend);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(5000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], friends) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                //subscribe again to see subscribe reply.
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, friends.Length);                

                foreach (PNUser friend in friends)
                {
                    fc.DeleteFriend(users[0], friend);
                    Thread.Sleep(2000);
                }

                Thread.Sleep(5000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] {}) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Logoff test user
                fc.LogoffUser(users[0]);
                //Logoff friends.
                foreach (PNUser u in friends)
                {
                    fc.LogoffUser(u);
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MemCacheFriendsListUpdatedForFriendRequest : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                // Subscribe to friendslist
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Create live users
                PNUser[] friends = PNUsersBuilder.GetLiveXenonUsers(2, true, false);

                //get request from first guy
                fc.RequestFriend(friends[0], users[0]);

                //Wait for some time to receive notification.
                Thread.Sleep(3000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] {}, new PNUser[] {friends[0]}, new PNUser[] {}) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                //subscribe again to see subscribe reply.
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);

                //send request to second guy.
                fc.RequestFriend(friends[1], users[0]);
                
                Thread.Sleep(3000);

                //verify # of notificatioons
                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, friends, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                //Subscribe again and see what you get. 
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 2);

                //Logoff test user
                fc.LogoffUser(users[0]);
                //Logoff friends.
                foreach (PNUser u in friends)
                {
                    fc.LogoffUser(u);
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MemCacheFriendsListUpdatedForAcceptingFriendRequest : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                // Subscribe to friendslist
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Create live users
                PNUser[] friends = PNUsersBuilder.GetLiveXenonUsers(2, true, false);

                //get request from first guy wait and verify notifications.
                fc.RequestFriend(friends[0], users[0]);
                Thread.Sleep(2000);
                
                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { friends[0] }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);

                //accept
                fc.AcceptFriend(users[0], friends[0]);
                Thread.Sleep(2000);
                
                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { friends[0] }, new PNUser[] { }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);

                //Other way around.
                //get request from first guy wait and verify notifications.
                fc.RequestFriend(users[0], friends[1] );
                Thread.Sleep(2000);
                
                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { friends[0] }, new PNUser[] { }, new PNUser[] { friends[1] }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");
                
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 2);

                //accept
                fc.AcceptFriend(friends[1], users[0]);
                Thread.Sleep(2000);
                
                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { friends[0], friends[1] }, new PNUser[] { }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 2);

                //Logoff test user
                fc.LogoffUser(users[0]);
                //Logoff friends.
                foreach (PNUser u in friends)
                {
                    fc.LogoffUser(u);
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MemCacheFriendsListUpdatedForRejectingFriendRequest : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                // Subscribe to friendslist
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Create live users
                PNUser[] friends = PNUsersBuilder.GetLiveXenonUsers(2, true, false);

                //get request from first guy wait and verify notifications.
                fc.RequestFriend(friends[0], users[0]);
                Thread.Sleep(2000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { friends[0] }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);

                //Reject.
                fc.RejectFriend(users[0], friends[0]);
                Thread.Sleep(2000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Other way around.
                //get request from first guy wait and verify notifications.
                fc.RequestFriend(users[0], friends[1]);
                Thread.Sleep(2000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { }, new PNUser[] { friends[1] }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                //subscribe again to see subscribe reply.
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);

                //send request to second guy.
                fc.RejectFriend(friends[1], users[0]);
                Thread.Sleep(2000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Logoff test user
                fc.LogoffUser(users[0]);
                //Logoff friends.
                foreach (PNUser u in friends)
                {
                    fc.LogoffUser(u);
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MemCacheFriendsListUpdatedForNeveringFriendRequest : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                // Subscribe to friendslist
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Create live users
                PNUser[] friends = PNUsersBuilder.GetLiveXenonUsers(2, true, false);

                //get request from first guy wait and verify notifications.
                fc.RequestFriend(friends[0], users[0]);
                Thread.Sleep(2000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { friends[0] }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                //subscribe again to see subscribe reply.
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);

                //send request to second guy.
                fc.RejectFriend(users[0], friends[0], true);
                Thread.Sleep(2000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                //Subscribe again and see what you get. 
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Other way around.
                //get request from first guy wait and verify notifications.
                fc.RequestFriend(users[0], friends[1]);
                Thread.Sleep(2000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { }, new PNUser[] { friends[1] }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                //subscribe again to see subscribe reply.
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);

                //send request to second guy.
                fc.RejectFriend(friends[1], users[0], true);
                Thread.Sleep(2000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                //Subscribe again and see what you get. 
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                //Logoff test user
                fc.LogoffUser(users[0]);
                //Logoff friends.
                foreach (PNUser u in friends)
                {
                    fc.LogoffUser(u);
                }
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MemCacheFriendsListUpdatedForMakeFriendPostSubscribe : TestBase
        {
            override protected void Execute()
            {
                /*
                create user
                create 3 peer
                set privacy to friendsonly & logoff
                subscribe basic
                log on
                no notification
                request accept friends
                logoff
                clear stuff
                settitledata
                see notification arrives.
                */
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and connect him.
                PNUser[] testuser = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = testuser[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(testuser[0].UserId, 0), "Connection.Connected");

                //Create live users
                PNUser[] liveusers = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                foreach (PNUser u in liveusers)
                {
                    XConnSrvTestHelpers.SetPrivacy(u, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(u);
                }
                Thread.Sleep(2000);

                DATA_OBJECT_SPECIFIER[] basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, liveusers);
                DATA_OBJECT_SPECIFIER[] rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, liveusers);
                SUBSCRIBE_REPLY basicReply = connection.Subscribe(basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(testuser[0].UserId, basic, basicReply), "Subscription verified.");
                SUBSCRIBE_REPLY richReply = connection.Subscribe(rich);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(testuser[0].UserId, rich, richReply), "Subscription verified.");

                //hook in to notified event of this connection.
                NotificationManager mgr = new NotificationManager();
                connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr.OnNotification);

                foreach (PNUser u in liveusers)
                {
                    fc.LogonUser(u);
                }
                Thread.Sleep(10000);

                //verify notification received.
                //Assert.IsTrue(mgr.BasicNotificationCountPerIndex[0] == 2, "No basic notifications found."); //idealy this should be 0, but for the first time
                //Assert.IsTrue(mgr.RichNotificiationCountPerIndex[0] == 2, "No rich notifications found.");  //we are going to get one per user additional..

                // These will be empty because we aren't friends, but we are just looking for basic notification arrival anyways
                for (int i = 0; i < basic.Length; ++i)
                {
                    basic[i].wObjectSize = 20;
                    rich[i].wObjectSize = 20;
                }

                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, basic, 0, 2), "VerifyNotificationsReceived failed for basic presence");
                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, rich, 0, 2, null), "VerifyNotificationsReceived failed for rich presence");

                //log them off
                foreach (PNUser u in liveusers)
                {
                    fc.LogoffUser(u);
                }

                //be friend with one of this 2.
                fc.MakeFriend(testuser[0], liveusers[0]);

                Thread.Sleep(3000);

                //mgr.BasicNotificationCountPerIndex[0] = 0;
                //mgr.RichNotificiationCountPerIndex[0] = 0;
                connection.ClearNotificationRecievedList();

                //log them on.
                foreach (PNUser u in liveusers)
                {
                    fc.LogonUser(u);
                }
                Thread.Sleep(3000);
                //verify notification received.
                //Assert.IsTrue(mgr.BasicNotificationCountPerIndex[0] >= 1 && mgr.BasicNotificationCountPerIndex[0] <= 2, "Basic notifications found: " + mgr.BasicNotificationCountPerIndex[0].ToString());
                //Assert.IsTrue(mgr.RichNotificiationCountPerIndex[0] == 1, "rich notifications found: " + mgr.RichNotificiationCountPerIndex[0].ToString());

                for (int i = 0; i < basic.Length; ++i)
                {
                    basic[i].wObjectSize = 56;
                }

                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, new DATA_OBJECT_SPECIFIER[] { basic[0] }, 0, 2), "VerifyNotificationsReceived failed for basic presence");
                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, new DATA_OBJECT_SPECIFIER[] { rich[0] } , 0, 2, null), "VerifyNotificationsReceived failed for rich presence");

                //log them off
                foreach (PNUser u in liveusers)
                {
                    fc.LogoffUser(u);
                }

                //be friend with other guy , other way around.
                fc.MakeFriend(testuser[0], liveusers[1]);
                Thread.Sleep(3000);
                
                //mgr.BasicNotificationCountPerIndex[0] = 0;
                //mgr.RichNotificiationCountPerIndex[0] = 0;

                connection.ClearNotificationRecievedList();

                foreach (PNUser u in liveusers)
                {
                    fc.LogonUser(u);
                }
                Thread.Sleep(5000);
                //verify notification received.
                //Assert.IsTrue(mgr.BasicNotificationCountPerIndex[0] == 2, "Basic notifications found: " + mgr.BasicNotificationCountPerIndex[0].ToString());
                //Assert.IsTrue(mgr.RichNotificiationCountPerIndex[0] == 2, "rich notifications found: " + mgr.RichNotificiationCountPerIndex[0].ToString());

                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, basic, 0, 2), "VerifyNotificationsReceived failed for basic presence");
                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, rich, 0, 2, null), "VerifyNotificationsReceived failed for rich presence");

                //Logoff test user
                fc.LogoffUser(testuser[0]);
                //Logoff friends.
                foreach (PNUser u in liveusers)
                {
                    fc.LogoffUser(u);
                }
            }
        }
        
        //[TestCase]
        //public class MemCacheFriendsListUpdatedForFriendGamerTagChanged : TestBase
        //{
        //}

        //[DoNotRunDaily()]
        //[TestCase]
        //public class AddOver100 : TestBase
        //{ 
        //    //see MemCache works. (no op in real world as there can't be more than 100 friends. but see if this is possible test by direct injection to MemCache)
        //}

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class AddBuddyOnSameConsole : TestBase
        { 
            override protected void Execute()
            { 
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;
                XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId);
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "Connection.Connected");

                // Subscribe to friendslist
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[1].UserId, 0);

                fc.MakeFriend(users[0], users[1]);

                //Wait for some time to receive notification over the same connection
                Thread.Sleep(5000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { users[1] }, new PNUser[] { }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");
                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[1], new PNUser[] { users[0] }, new PNUser[] { }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                // Re Subscribe to friendslist for verifying reply
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class AddBuddyFromWeb : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId}, users[0].Xbox.XboxId);
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                // Subscribe to friendslist
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 0);

                PNUser[] webusers = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                fc.LogoffUser(webusers[0]);
                webusers[0].WebAlive();
                webusers[0].AddBuddy(users[0]); // Sends friend request only

                //Wait for some time to receive notification over the same connection
                Thread.Sleep(3000);

                Assert.IsTrue(XConnSrvTestHelpers.VerifyFriendsListNotifications(connection, users[0], new PNUser[] { }, new PNUser[] { webusers[0] }, new PNUser[] { }) == true, "VerifyFriendsListNotifications failed. Connection given did not receive notifications with the owner and friends given.");

                // Re Subscribe to friendslist for verifying reply
                SubscribetoFriendsListAndVerifyFriendsCount(ref connection, users[0].UserId, 1);
            }
        }

        public static void SubscribetoFriendsListAndVerifyFriendsCount(ref PNConnection connection, ulong userId, int friendsCount)
        {
            DATA_OBJECT_SPECIFIER[] friendsSpecifier = XConnSrvTestHelpers.GetFriendsListDataObjectSpecifierArray(userId);
            SUBSCRIBE_REPLY flSubscribeReply = connection.Subscribe(friendsSpecifier);
            Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(userId, friendsSpecifier, flSubscribeReply), "Subscription verified.");
            Assert.IsTrue(flSubscribeReply.rgDataObjects.Length == 1, "Got back doSpec.");
            ulong[] friendsid = null;
            uint count = XConnSrvTestHelpers.GetFriendsListFriends(flSubscribeReply.rgDataObjects[0], out friendsid);
            Assert.IsTrue(friendsCount == count, "Friends Count verified. Expected: " + friendsCount + " Actual: " + count);
        }
    }

    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(3)]
    public class FuncXConnSrvFriendsListTests : TestNode
    {
        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVT_XConnSrvFriendsList : TestBase
        {
            override protected void Execute()
            {
                /*
                 * Steps:
                 * Create userA
                 * Create userB
                 * Create 5 live users
                 * set privacy to friends only.
                 * MakeFriends with userA
                 * Log off them
                 * A and B subscribes to basic & Rich presence
                 * Log those 5 users on.
                 * Verify that A received 5 notifications, and B dont have any.
                 * Call SetTitleData on those 5 guys
                 * Verify that A received 5 notifications, and B dont have any.
                 */
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;
                PNConnection connection2 = null;
                uint totalFriends = 5;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                connection2 = users[1].Xbox.ConnectionServerConnection;
                XConnSrvTestHelpers.TryConnectAndVerify(ref connection2, HResult.S_OK, new int[] { 0 }, new ulong[] { users[1].UserId }, users[1].Xbox.XboxId);
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 0), "Connection.Connected");

                //Get Dataobject Specifier for basic presence
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = totalFriends;
                builder.CreateUsers(users[0]); //this will also make him friend..
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicsubscribeReply = connection.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");
                //second guy subscribe but isn't friend.
                basicsubscribeReply = connection2.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");

                Thread.Sleep(2000);

                //Verify using xmgmt.
                ulong[] friendsIds = null;
                int fCount = 0;
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(totalFriends == fCount, "Number of friends for user 1: " +  fCount);
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[1].UserId, out friendsIds);
                Assert.IsTrue(0 == fCount, "Number of friends for user 1: " + fCount); 

                foreach (PNUser user in builder.Friends)
                {
                    XConnSrvTestHelpers.SetPrivacy(user, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(user);
                }
                Thread.Sleep(3000);

                //hook in to notified event of this connection.
                //NotificationManager mgr1 = new NotificationManager();
                //connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr1.OnNotification);
                //NotificationManager mgr2 = new NotificationManager();
                //connection2.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr2.OnNotification);
                connection.ClearNotificationRecievedList();
                connection2.ClearNotificationRecievedList();
                
                //log them on.
                foreach (PNUser user in builder.Friends)
                {
                    fc.LogonUser(user);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(5000);

                //only user 1 should  get the notiification.
                //Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] >= 1 && mgr1.BasicNotificationCountPerIndex[0] <= totalFriends * 2, "Verified friendsListNotification.  Recieved=" + mgr1.BasicNotificationCountPerIndex[0]);
                //Assert.IsTrue(mgr2.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr2.BasicNotificationCountPerIndex[0] + " notifications");

                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscribes_basic, 0, 5), "Did not receive notifications as expected.");
                Assert.IsTrue(connection2.GetTotalNotificationsLength() == 0, "Received more than 0 notifications on connection2.");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class XConnSrvFriendsListUpdatedForDeleteFriend : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;
                PNConnection connection2 = null;
                uint totalFriends = 5;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                connection2 = users[1].Xbox.ConnectionServerConnection;
                XConnSrvTestHelpers.TryConnectAndVerify(ref connection2, HResult.S_OK, new int[] { 0 }, new ulong[] { users[1].UserId }, users[1].Xbox.XboxId);
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 0), "Connection.Connected");

                //Get Dataobject Specifier for basic presence
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = totalFriends;
                builder.CreateUsers(users[0]); //this will also make him friend..
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicsubscribeReply = connection.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");
                //second guy subscribe but isn't friend.
                basicsubscribeReply = connection2.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");

                Thread.Sleep(2000); // Sleep so all friend relationships are finalized

                //Verify using xmgmt.
                ulong[] friendsIds = null;
                int fCount = 0;
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(totalFriends == fCount, "Number of friends for user 1: " + fCount);
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[1].UserId, out friendsIds);
                Assert.IsTrue(0 == fCount, "Number of friends for user 1: " + fCount); 

                foreach (PNUser user in builder.Friends)
                {
                    XConnSrvTestHelpers.SetPrivacy(user, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(user);
                }
                Thread.Sleep(3000);

                //hook in to notified event of this connection.
                //NotificationManager mgr1 = new NotificationManager();
                //connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr1.OnNotification);
                //NotificationManager mgr2 = new NotificationManager();
                //connection2.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr2.OnNotification);
                connection.ClearNotificationRecievedList();
                connection2.ClearNotificationRecievedList();

                //log them on.
                foreach (PNUser user in builder.Friends)
                {
                    fc.LogonUser(user);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(3000);

                //only user 1 should  get the notiification.
                //Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] >= 1 && mgr1.BasicNotificationCountPerIndex[0] <= totalFriends * 2, "Verified friendsListNotification.  Recieved=" + mgr1.BasicNotificationCountPerIndex[0]);
                //Assert.IsTrue(mgr2.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr2.BasicNotificationCountPerIndex[0] + " notifications");

                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscribes_basic, 0, 5), "Did not receive notifications as expected.");
                Assert.IsTrue(connection2.GetTotalNotificationsLength() == 0, "Received more than 0 notifications on connection2.");

                //Now remove friend for Friend 1.
                foreach (PNUser user in builder.Friends)
                {
                    fc.DeleteFriend(users[0], user);
                }

                foreach (PNUser user in builder.Friends)
                {
                    fc.LogoffUser(user);
                }
                Thread.Sleep(3000);

                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(0 == fCount, "Number of friends for user 1: " + fCount);
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[1].UserId, out friendsIds);
                Assert.IsTrue(0 == fCount, "Number of friends for user 1: " + fCount);

                //mgr1.BasicNotificationCountPerIndex[0] = 0;
                //mgr2.BasicNotificationCountPerIndex[0] = 0;
                connection.ClearNotificationRecievedList();
                connection2.ClearNotificationRecievedList();

                //relogon
                foreach (PNUser user in builder.Friends)
                {
                    fc.LogonUser(user);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(5000);

                //no one should  get the notiification.
                //Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr1.BasicNotificationCountPerIndex[0] + " notifications");
                //Assert.IsTrue(mgr2.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr2.BasicNotificationCountPerIndex[0] + " notifications");

                Assert.IsTrue(connection.GetTotalNotificationsLength() == 0, "Received more than 0 notifications on connection.");
                Assert.IsTrue(connection2.GetTotalNotificationsLength() == 0, "Received more than 0 notifications on connection2.");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class XConnSrvFriendsListUpdatedForFriendRequest : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;
                uint totalFriends = 2;
                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                //Get Dataobject Specifier for basic presence
                PNUser[] requested = PNUsersBuilder.GetLiveXenonUsers(totalFriends, true, false);
                DATA_OBJECT_SPECIFIER[] subscribes_basic  = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, requested);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicsubscribeReply = connection.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");

                foreach (PNUser p in requested)
                {
                    XConnSrvTestHelpers.SetPrivacy(p, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(p);
                }

                fc.RequestFriend(users[0], requested[0]);
                fc.RequestFriend(requested[1], users[0]);
                Thread.Sleep(3000);

                ulong[] friendsIds = null;
                int fCount = 0;
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(2 == fCount, "Number of friends for user 1: " + fCount);


                //hook in to notified event of this connection.
                //NotificationManager mgr1 = new NotificationManager();
                //connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr1.OnNotification);
                connection.ClearNotificationRecievedList();

                //log them on.
                foreach (PNUser p in requested)
                {
                    fc.LogonUser(p);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(3000);

                //should  not get the notiification.
                //Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr1.BasicNotificationCountPerIndex[0] + " notifications");
                Assert.IsTrue(connection.GetTotalNotificationsLength() == 0, "Received more than 0 notifications on connection.");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class XConnSrvFriendsListUpdatedForAcceptingFriendRequest : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;
                uint totalFriends = 2;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                //Get Dataobject Specifier for basic presence
                PNUser[] requested = PNUsersBuilder.GetLiveXenonUsers(totalFriends, true, false);
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, requested);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicsubscribeReply = connection.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");

                foreach (PNUser p in requested)
                {
                    XConnSrvTestHelpers.SetPrivacy(p, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(p);
                }

                fc.RequestFriend(users[0], requested[0]);
                fc.RequestFriend(requested[1], users[0]);
                Thread.Sleep(3000);

                ulong[] friendsIds = null;
                int fCount = 0;
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(totalFriends == fCount, "Number of friends for user 1: " + fCount); 


                //hook in to notified event of this connection.
                //NotificationManager mgr1 = new NotificationManager();
                //connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr1.OnNotification);
                connection.ClearNotificationRecievedList();

                //log them on.
                foreach (PNUser p in requested)
                {
                    fc.LogonUser(p);
                }


                //Wait for some time to receive notification.
                Thread.Sleep(3000);

                //should  not get the notiification.
                //Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr1.BasicNotificationCountPerIndex[0] + " notifications");
                Assert.IsTrue(connection.GetTotalNotificationsLength() == 0, "Received more than 0 notifications on connection.");

                foreach (PNUser p in requested)
                {
                    XConnSrvTestHelpers.SetPrivacy(p, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(p);
                }

                //Accept
                fc.AcceptFriend(requested[0], users[0]);
                fc.AcceptFriend(users[0], requested[1]);

                Thread.Sleep(3000);

                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(totalFriends == fCount, "Number of friends for user 1: " + fCount);

                //mgr1.BasicNotificationCountPerIndex[0] = 0;
                connection.ClearNotificationRecievedList();

                //log them on.
                foreach (PNUser p in requested)
                {
                    fc.LogonUser(p);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(3000);
                
                //Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] == totalFriends, "Recieved " + mgr1.BasicNotificationCountPerIndex[0] + " notifications");
                Assert.IsTrue(XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscribes_basic, 0, 5), "Did not receive notifications as expected.");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class XConnSrvFriendsListUpdatedForRejectingFriendRequest : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                //Get Dataobject Specifier for basic presence
                PNUser[] requested = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, requested);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicsubscribeReply = connection.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");

                foreach (PNUser p in requested)
                {
                    XConnSrvTestHelpers.SetPrivacy(p, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(p);
                }

                fc.RequestFriend(users[0], requested[0]);
                fc.RequestFriend(requested[1], users[0]);
                Thread.Sleep(3000);

                ulong[] friendsIds = null;
                int fCount = 0;
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(2 == fCount, "Number of friends for user 1: " + fCount);

                //hook in to notified event of this connection.
                //NotificationManager mgr1 = new NotificationManager();
                //connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr1.OnNotification);
                connection.ClearNotificationRecievedList();

                //log them on.
                foreach (PNUser p in requested)
                {
                    fc.LogonUser(p);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(3000);

                //should  not get the notiification.
                //Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr1.BasicNotificationCountPerIndex[0] + " notifications");
                Assert.IsTrue(connection.GetTotalNotificationsLength() == 0, "Received more than 0 notifications on connection.");

                foreach (PNUser p in requested)
                {
                    XConnSrvTestHelpers.SetPrivacy(p, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(p);
                }

                fc.RejectFriend(requested[0], users[0]);
                fc.RejectFriend(users[0], requested[1]);
                Thread.Sleep(3000);

                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(0 == fCount, "Number of friends for user 1: " + fCount);

                //mgr1.BasicNotificationCountPerIndex[0] = 0;
                connection.ClearNotificationRecievedList();

                //log them on.
                foreach (PNUser p in requested)
                {
                    fc.LogonUser(p);
                }

                //Wait for some time to receive notification.
                Thread.Sleep(5000);

               // Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr1.BasicNotificationCountPerIndex[0] + " notifications");
                Assert.IsTrue(connection.GetTotalNotificationsLength() == 0, "Received more than 0 notifications on connection.");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class VerifyFriendListForLogonAndLogOff : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                //Get Dataobject Specifier for basic presence
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users[0]); //this will also make him friend..
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicsubscribeReply = connection.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");

                fc.LogoffUser(users[0]);
                Thread.Sleep(3000);

                ulong[] friendsIds = null;
                int fCount = 0;
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(0 == fCount, "Number of friends for user 1: " + fCount);

                Global.RO.Info("Establishing new connection...");
                connection = null;
                fc.LogonUser(users[0]);
                connection = users[0].Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                Thread.Sleep(3000);
                // Subscribe to basic
                basicsubscribeReply = connection.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(5 == fCount, "Number of friends for user 1: " + fCount);
                fc.LogoffUser(users[0]);
                Thread.Sleep(3000);
                fCount = XConnSrvTestHelpers.GetXConnSrvFriendListUsingXMgmtC(users[0].UserId, out friendsIds);
                Assert.IsTrue(0 == fCount, "Number of friends for user 1: " + fCount);
            }
        }
    }

    public class NotificationManager
    {
        //            // subscribe to notifications
        //_connection.Notified += new ConnSrvConnection.NotifiedEventHandler(OnNotification);
        public int[] FriendsListNotificationCountPerIndex = new int[4];
        public int[] BasicNotificationCountPerIndex = new int[4];
        public int[] RichNotificiationCountPerIndex = new int[4];
        public void OnNotification(object oSender, ConnSrvConnection.NotifiedEventArgs args)
        {
            lock (this)
            { 
                DATA_NOTIFICATION dn = (DATA_NOTIFICATION)args.In;
                if (dn != null)
                {
                    uint dwUserIndexFlags = dn.header.dwUserIndexFlags;
                    int[] indexes = SubNotiDefs.UserFlagsToIndices(dwUserIndexFlags);
                    foreach (int index in indexes)
                    {
                        DATA_TYPES  notityp  = DATA_TYPES.eBasicPresence;
                        if (dn.rgDataObjects[0] != null)
                            notityp =  (DATA_TYPES)Enum.Parse(typeof(DATA_TYPES), dn.rgDataObjects[0].wDataType.ToString(), true);
                        if (notityp == DATA_TYPES.eFriendsList)
                        {
                            Global.RO.Debug("type: " + notityp.ToString() + " " + dn.rgDataObjects[0].qwOwnerXUID );
                            FriendsListNotificationCountPerIndex[index]++;
                        }
                        else if (notityp == DATA_TYPES.eBasicPresence)
                        {
                            Global.RO.Debug("type: " + notityp.ToString() + " " + dn.rgDataObjects[0].qwOwnerXUID );
                            BasicNotificationCountPerIndex[index]++;
                        }
                        else if (notityp == DATA_TYPES.eRichPresenceString)
                        {
                            Global.RO.Debug("type: " + notityp.ToString() + " " + dn.rgDataObjects[0].qwOwnerXUID );
                            RichNotificiationCountPerIndex[index]++;
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncNotification.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.FakeSG;

using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Notifications.
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(1)]
    public class FuncNotification_PositiveCases : TestNode
    {
        /// <summary>
        /// BVT Test Case that subscribes a single user to a single friend and triggers a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVT_Notification : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;

                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);

                DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);

                // subscribe basic
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(basicsub, new int[] { 0 });

                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                Thread.Sleep(2000);

                connection.ClearNotificationRecievedList();
                XConnSrvTestHelpers.SendNotifications(basicsub);

                // Verify the notifications expected were received
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, basicsub, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                // TODO: In the future use local information to verify correct data was returned for basic and rich presence
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)basicsub.Length, (uint)basicsub.Length+1))
                //    ResultCode = TEST_RESULTS.FAILED;
                
                // Unsubscribe and verify we were unsubscribed w/ xmgmt
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, basicsub, unsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates one subscription to each type of user (offline friend remote, offline friend same console,
        /// online friend remote, online friend same console, etc) and creates a notification for each
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Ignore("Not working implementation.")] // NOT EXECUTED
        public class NotificationFromUserTypes : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                /*
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = XConnSrvTestHelpers.GetLiveXenonUsers(1, true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscriptions for Friends
                XConnSrvTestHelpers.DataObjectSpecifierBuilder builderFriends = new XConnSrvTestHelpers.DataObjectSpecifierBuilder();

                builderFriends.Online_Friends = 1;
                builderFriends.Online_Friends_PrivBlocked = 1;
                //builderFriends.Online_Friends_PrivFriends = 1;
                //builderFriends.Online_Friends_SameConsole = 1;
                //builderFriends.Online_Friends_SameConsole_PrivBlocked = 1;
                //builderFriends.Online_Friends_SameConsole_PrivFriends = 1;

                //builderFriends.Offline_Friends = 1;
                //builderFriends.Offline_Friends_PrivBlocked = 1;
                //builderFriends.Offline_Friends_PrivFriends = 1;
                //builderFriends.Offline_Friends_SameConsole = 1;
                //builderFriends.Offline_Friends_SameConsole_PrivBlocked = 1;
                //builderFriends.Offline_Friends_SameConsole_PrivFriends = 1;

                builderFriends.CreateRequiredSubscribees();
                builderFriends.AddSubscriberPNUser(users[0]);
                DATA_OBJECT_SPECIFIER[] subscriptionsFriends = builderFriends.GetDataObjectSpecifierArray(DATA_TYPES.eBasicPresence);

                // Since we will make friends/subscriptions in the builder, we may have some unwanted notifications, clear them
                Thread.Sleep(1000);
                connection.ClearNotificationRecievedList();

                // Now issue a notification for each of the types
                for (int i = 0; i < subscriptionsFriends.Length; ++i)
                {
                    // Issue notification
                    XConnSrvTestHelpers.SendNotifications(subscriptionsFriends[i]);

                    XConnSrvTestHelpers.SubscribeeDetails sd = builderFriends.GetSubscribeeDetailsFromDoSpec(subscriptionsFriends[i]);

                    if (sd != null)
                    {
                        int privacy = sd.PrivacySetting;

                        // Receive notification
                        if (connection.VerifyIndividualNotificationReceived(subscriptionsFriends[i], 0, 5) == (privacy == 0 ? true : false))
                            ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Error("DOSpec not found in builder.");
                        ResultCode = TEST_RESULTS.FAILED;
                        break;
                    }
                }

                //// Create subscriptions for Peers
                //XConnSrvTestHelpers.DataObjectSpecifierBuilder builderPeers = new XConnSrvTestHelpers.DataObjectSpecifierBuilder();

                //builderPeers.Online_Peers = 1;
                //builderPeers.Online_Peers_PrivBlocked = 1;
                ////builderPeers.Online_Peers_PrivFriends = 1;
                ////builderPeers.Online_Peers_SameConsole = 1;
                ////builderPeers.Online_Peers_SameConsole_PrivBlocked = 1;
                ////builderPeers.Online_Peers_SameConsole_PrivFriends = 1;

                ////builderPeers.Offline_Peers = 1;
                ////builderPeers.Offline_Peers_PrivBlocked = 1;
                ////builderPeers.Offline_Peers_PrivFriends = 1;
                ////builderPeers.Offline_Peers_SameConsole = 1;
                ////builderPeers.Offline_Peers_SameConsole_PrivBlocked = 1;
                ////builderPeers.Offline_Peers_SameConsole_PrivFriends = 1;

                //builderPeers.CreateRequiredSubscribees();
                //builderPeers.AddSubscriberPNUser(users[0]);
                //DATA_OBJECT_SPECIFIER[] subscriptionsPeers = builderPeers.GetDataObjectSpecifierArray(DATA_TYPES.eBasicPresence);

                //// Since we will make friends/subscriptions in the builder, we may have some unwanted notifications, clear them
                //Thread.Sleep(1000);
                //connection.ClearNotificationRecievedList();

                //// Now issue a notification for each of the types
                //for (int i = 0; i < subscriptionsPeers.Length; ++i)
                //{
                //    // Issue notification
                //    XConnSrvTestHelpers.SendNotifications(subscriptionsPeers[i]);

                //    XConnSrvTestHelpers.SubscribeeDetails sd = builderPeers.GetSubscribeeDetailsFromDoSpec(subscriptionsPeers[i]);

                //    if (sd != null)
                //    {
                //        int privacy = sd.PrivacySetting;

                //        // Receive notification
                //        if (connection.VerifyIndividualNotificationReceived(subscriptionsPeers[i], 0, 5) == ((privacy == 0 || privacy == 2) ? true : false))
                //            ResultCode = TEST_RESULTS.FAILED;
                //    }
                //    else
                //    {
                //        Global.RO.Error("DOSpec not found in builder.");
                //        ResultCode = TEST_RESULTS.FAILED;
                //        break;
                //    }
                //}

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
                 */
            }
        }

        /// <summary>
        /// Creates one subscription to each data type (Basic Presence, Rich Presence, etc) and
        /// creates a notification for each
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Ignore("Not all types are implemented so failures occur.")]
        public class NotificationFromDataTypes : TestBase
        {
            /// <summary>
            /// This will be used to insert data for all data types besides friends list and basic presence since that will already be done for us.
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            void pnub_PNUserCreationEvent(object sender, PNUserCreationEventArgs e)
            {
                // Set Rich Presence
                XConnSrvTestHelpers.SetTitleData(e.User);

                // Insert all other data types needed
                for (ushort type = SubNotiDefs.MIN_DATA_TYPE; type <= SubNotiDefs.MAX_DATA_TYPE; ++type)
                {
                    if (type != (ushort)DATA_TYPES.eFriendsList && type != (ushort)DATA_TYPES.eBasicPresence && type != (ushort)DATA_TYPES.eRichPresenceString)
                    {
                        unsafe
                        {
                            DATA_OBJECT_SPECIFIER doSpec = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser((DATA_TYPES)type, e.User);

                            byte[] data = new byte[doSpec.wObjectSize - sizeof(BASE_DATA_HEADER)];

                            XConnSrvMemCache.InsertDataObject(doSpec, data);
                        }
                    }
                }
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);

                // Create subscriptions
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.PNUserCreationEvent += new EventHandler<PNUserCreationEventArgs>(pnub_PNUserCreationEvent);
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);

                DATA_OBJECT_SPECIFIER[][] subscriptions = new DATA_OBJECT_SPECIFIER[SubNotiDefs.MAX_DATA_TYPE - SubNotiDefs.MIN_DATA_TYPE + 1][];
                for (ushort i = SubNotiDefs.MIN_DATA_TYPE; i <= SubNotiDefs.MAX_DATA_TYPE; ++i)
                {
                    subscriptions[i - SubNotiDefs.MIN_DATA_TYPE] = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers((DATA_TYPES)i, pnub.Friends);
                }

                // Connect
                connection = users[0].Xbox.ConnectionServerConnection;
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe to all data types
                for (int i = 0; i < subscriptions.Length; i++)
                {
                    SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions[i], new int[] { 0 });
                    if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions[i], subscribeReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }
                Global.RO.Info("Subscribed for all data types.");
                // Now issue a notification for each type
                for (int i = 0; i < subscriptions.Length; ++i)
                {
                    // Issue notification
                    Global.RO.Info("Issuing notification for " + subscriptions[i][0].qwOwnerXUID.ToString());
                    connection.ClearNotificationRecievedList();
                    XConnSrvTestHelpers.SendNotifications(subscriptions[i]);

                    // Receive notification
                    if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, subscriptions[i][0], 0, 5))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates 32 users on different consoles who all subscribe to the same subscription. A notification
        /// is triggered and we verify all 32 users receive it.
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class MassNotifications : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection[] connections = new PNConnection[32];

                for (int i = 0; i < connections.Length; ++i)
                {
                    connections[i] = null;
                }

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers((uint)connections.Length, true, false);

                // Create subscriptions
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);

                for (int i = 0; i < users.Length; ++i)
                {

                    // Connect at index 0
                    connections[i] = users[i].Xbox.ConnectionServerConnection;
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connections[i], HResult.S_OK, new int[] { 0 }, new ulong[] { users[i].UserId }, users[i].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    // Subscribe
                    SUBSCRIBE_REPLY subscribeReply = connections[i].Subscribe(subscription, new int[] { 0 });
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscription, subscribeReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                foreach (PNConnection conn in connections)
                    conn.ClearNotificationRecievedList();

                XConnSrvTestHelpers.SendNotifications(subscription);

                for (int i = 0; i < users.Length; ++i)
                {
                    // Verify notification received
                    if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connections[i], subscription, 0, 5))
                        ResultCode = TEST_RESULTS.FAILED;

                    // Verify the corrent number of notifications were received
                    // TODO: In the future use local information to verify correct data was returned for basic and rich presence
                    //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connections[i], (uint)subscription.Length, (uint)subscription.Length +1))
                    //    ResultCode = TEST_RESULTS.FAILED;

                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connections[i]))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Create 1 user subscribed to 1 piece of data, update that data in the cache, and verify that a notification
        /// is sent to the subscribed user
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class NotificationFromUpdatingData : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);

                // Create subscriptions
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);

                // Connect
                connection = users[0].Xbox.ConnectionServerConnection;
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Update data for subscription[0] and expect notification to be sent (InsertDataObject creates a notification)
                byte[] smallerData = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

                DATA_OBJECT_SPECIFIER subscriptionSmaller = subscriptions[0];
                unsafe
                {
                    subscriptionSmaller.wObjectSize = (ushort)(sizeof(BASE_DATA_HEADER) + smallerData.Length);
                }
                XConnSrvMemCache.InsertDataObject(subscriptionSmaller, smallerData);

                // Get notification
                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, subscriptionSmaller, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// A single user subscribes to data, which is then updated to be a larger size, and verifies that the
        /// user gets a notification of the correct size
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class NotificationFromDataSizeIncrease : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Connect

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscriptions
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);


                // Update data to a larger size, triggering a notification
                DATA_OBJECT_SPECIFIER subscriptionBigger = new DATA_OBJECT_SPECIFIER();
                subscriptionBigger = subscription[0];
                BasicPresence basic = new BasicPresence();
                int basicSize = basic.Size();

                subscriptionBigger.wObjectSize = (ushort)(basicSize + 4);

                unsafe
                {
                    byte[] data = new byte[basicSize - sizeof(BASE_DATA_HEADER) + 4];
                    XConnSrvMemCache.InsertDataObject(subscriptionBigger, data, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);
                }

                // Verify notifications were received for the original, smaller size, subscription
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscription, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connect 4 users on the same box, subscribe 3 of them to the same data, issue a notification and confirm
        /// that only those 3 users received the notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class MultipleUsersSameSubscriptionsSameBox : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscriptions
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Offline_Friends = 5;
                pnub.Online_Friends = 5;
                pnub.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);
                DATA_OBJECT_SPECIFIER[] subscriptions_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, pnub.Friends);
                connection.Unsubscribe(subscriptions);

                int[] userIndices = new int[XConnSrvTestHelpers.MAX_LOGON_USERS];
                ulong[] userIds = new ulong[XConnSrvTestHelpers.MAX_LOGON_USERS];

                for (int i = 0; i < XConnSrvTestHelpers.MAX_LOGON_USERS; ++i)
                {
                    userIndices[i] = i;
                    userIds[i] = users[i].UserId;
                }

                // Subscribe only the first 3 users
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions, new int[] { 0, 1 , 2 });
                for (int i = 0; i < 3; ++i)
                {
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscriptions, subscribeReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Issue Notifications
                connection.ClearNotificationRecievedList();
                XConnSrvTestHelpers.SendNotifications(subscriptions);

                // Get notification for 3 subscribed users
                for (int i = 0; i < 3; ++i)
                {
                    if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscriptions, (uint)i, 5))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Make sure that the unsubscribed user didn't get a notification
                if (XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscriptions, 3, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                // TODO: In the future use local information to verify correct data was returned for basic and rich presence
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)subscriptions.Length, (uint)subscriptions.Length+1))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates 2 xboxs with 2 users on each, the first user on each is subscribed to the same data. A notification
        /// is sent and is verified that only the first user on both consoles receives it.
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class NotificationPartialUsersMultipleConsoles : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection1 = null;
                PNConnection connection2 = null;

                // Create one user.
                PNUser[] users1 = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection1 = users1[0].Xbox.ConnectionServerConnection;
                PNUser[] users2 = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection2 = users2[0].Xbox.ConnectionServerConnection;

                // Create subscriptions
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(new PNUser[] { users1[0], users1[1], users2[0], users2[1] });

                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);
                DATA_OBJECT_SPECIFIER[] subscription_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, pnub.Friends);
                connection1.Unsubscribe(subscription, new int[] { 0, 1 });
                connection2.Unsubscribe(subscription, new int[] { 0, 1 });

                // Subscribe users on connection1
                SUBSCRIBE_REPLY subscribeReply1 = connection1.Subscribe(subscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users1[0].UserId, subscription, subscribeReply1))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe users on connection2
                SUBSCRIBE_REPLY subscribeReply2 = connection2.Subscribe(subscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users2[0].UserId, subscription, subscribeReply2))
                    ResultCode = TEST_RESULTS.FAILED;

                // Trigger notification
                connection1.ClearNotificationRecievedList();
                connection2.ClearNotificationRecievedList();
                XConnSrvTestHelpers.SendNotifications(subscription);

                // Verify notifications were received correctly only for the first user on each connection
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection1, subscription, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;
                if (XConnSrvTestHelpers.VerifyNotificationsReceived(connection1, subscription, 1, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection2, subscription, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;
                if (XConnSrvTestHelpers.VerifyNotificationsReceived(connection2, subscription, 1, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                // TODO: In the future use local information to verify correct data was returned for basic and rich presence
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection1, (uint)subscription.Length, (uint)subscription.Length+1))
                //    ResultCode = TEST_RESULTS.FAILED;
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection2, (uint)subscription.Length, (uint)subscription.Length+1))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection1))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection2))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// A single user creates a subscription, disconnects, and then when a notification is sent, verifies it isn't
        /// to the disconnected user.
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class NoNotificationForDisconnectedUser : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);

                // Create subscriptions
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);

                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);

                // Connect
                connection = users[0].Xbox.ConnectionServerConnection;
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions, new int[] { 0, 1 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect user 1
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Send Notification
                connection.ClearNotificationRecievedList();
                XConnSrvTestHelpers.SendNotifications(subscriptions);

                // Get notification for only user 0
                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, subscriptions[0], 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Expect to not get a notification for user 1
                if (XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, subscriptions[0], 1, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// A single user subscribes to data, which is then Set to the same thing, verifies the user
        /// gets a notification still
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class NotificationDataUpdatedToSame : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create two users - [0] == subscriber, [1] == subscribee
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);

                // Create subscription manually and insert it into memcache
                DATA_OBJECT_SPECIFIER[] subscription = new DATA_OBJECT_SPECIFIER[1];
                byte[] data = null;
                BasicPresence basic = new BasicPresence();
                int basicSize = basic.Size();

                subscription[0].wObjectSize = (ushort)basicSize;
                subscription[0].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                subscription[0].dwDataSubType = 0;
                subscription[0].qwOwnerXUID = users[1].UserId;

                unsafe
                {
                    data = new byte[basicSize - sizeof(BASE_DATA_HEADER)];
                }
                XConnSrvMemCache.InsertDataObject(subscription[0], data, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                System.Threading.Thread.Sleep(2000);

                // Connect
                connection = users[0].Xbox.ConnectionServerConnection;
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Update the data in the cache with the same data
                XConnSrvMemCache.InsertDataObject(subscription[0], data, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                System.Threading.Thread.Sleep(2000);

                // Verify a notification was received
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscription, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                // TODO: In the future use local information to verify correct data was returned for basic and rich presence
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)subscription.Length, (uint)subscription.Length+1))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// This verifies that if we subscribe to something which does not yet exist in the cache, that once
        /// it is added, a notification is sent to the subscribee
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class NotificationUnexistantDataExists : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create two users
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                PNUser[] subscribee = PNUsersBuilder.GetLiveXenonUsers(1, false, false);

                System.Threading.Thread.Sleep(2000);

                // Connect
                connection = users[0].Xbox.ConnectionServerConnection;
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscription manually
                DATA_OBJECT_SPECIFIER[] subscription = new DATA_OBJECT_SPECIFIER[1];
                subscription[0].wObjectSize = (ushort)(new BasicPresence()).Size();
                subscription[0].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                subscription[0].dwDataSubType = 0;
                subscription[0].qwOwnerXUID = subscribee[0].UserId;

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Log in the subscribee so that the data is populated
                FriendsCommon fc = new FriendsCommon();
                subscribee[0].Connect(subscribee[0].Xbox);
                fc.LogonUser(subscribee[0]);

                // Make sure the data is populated and the notification is received
                System.Threading.Thread.Sleep(2000);

                // Verify notification was received
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscription, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                // TODO: In the future use local information to verify correct data was returned for basic and rich presence
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 2)) 
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// This verifies that if we subscribe to something which exists, that when it is removed from the cache
        /// we get a notification with a sizeof(BASE_DATA_HEADER)
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class NotificationReceivedWhenDataRemoved : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);

                // Remove subscription[0] from the cache, expect a notification to be sent
                XConnSrvMemCache.InsertDataObject(subscription[0], null);

                DATA_OBJECT_SPECIFIER subscriptionEmptyHeader = new DATA_OBJECT_SPECIFIER();
                subscriptionEmptyHeader = subscription[0];
                unsafe
                {
                    subscriptionEmptyHeader.wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
                }

                // Verify notification was received
                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, subscriptionEmptyHeader, 0, 5))
                {
                    Global.RO.Error("No notification received after removing data from cache.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// This subscribes a user absolutely then normally to the same object, triggers a notification, and
        /// verify only 1 notification is received
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class DuplicateSubscribeSingleNotification : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);

                // Connect
                connection = users[0].Xbox.ConnectionServerConnection;
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscription
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);

                // Subscribe to user1 absolutely and verify
                SUBSCRIBE_REPLY subscriptionReply1 = connection.Subscribe(subscriptions, new int[] { 0 }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscriptionReply1))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe to user1 again, but normally and verify
                SUBSCRIBE_REPLY subscriptionReply2 = connection.Subscribe(subscriptions, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscriptionReply2))
                    ResultCode = TEST_RESULTS.FAILED;

                SUBSCRIBE_REPLY subscriptionReply3 = connection.Subscribe(subscriptions, new int[] { 0 });

                // Send Notification
                connection.ClearNotificationRecievedList();
                XConnSrvTestHelpers.SendNotifications(subscriptions);

                // Verify notification was received
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscriptions, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                // TODO: In the future use local information to verify correct data was returned for basic and rich presence
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)subscriptions.Length, (uint)subscriptions.Length + 1))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Make subscriptions to users on the same console and get notifications
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class NotificationFromSubscriptionOnSameConsole : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);

                // Connect both users
                connection = users[0].Xbox.ConnectionServerConnection;
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                {
                    Global.RO.Error("Connection was not created.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                // Create subscription manually to each other
                DATA_OBJECT_SPECIFIER[] subscription0 = new DATA_OBJECT_SPECIFIER[1];
                DATA_OBJECT_SPECIFIER[] subscription1 = new DATA_OBJECT_SPECIFIER[1];

                subscription0[0].wObjectSize = (ushort)(new BasicPresence()).Size();
                subscription1[0].wObjectSize = subscription0[0].wObjectSize;
                subscription0[0].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                subscription1[0].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                subscription0[0].dwDataSubType = 0;
                subscription1[0].dwDataSubType = 0;
                subscription0[0].qwOwnerXUID = users[1].UserId;
                subscription1[0].qwOwnerXUID = users[0].UserId;

                // Update the data to be shared to everyone (defaults to blocked) and trigger a notification
                byte[] data = null;

                unsafe
                {
                    data = new byte[subscription0[0].wObjectSize - sizeof(BASE_DATA_HEADER)];
                }

                // Give the same data for both objects because we don't care
                XConnSrvMemCache.InsertDataObject(subscription0[0], data, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);
                XConnSrvMemCache.InsertDataObject(subscription1[0], data, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                System.Threading.Thread.Sleep(2000);


                SUBSCRIBE_REPLY subscription0Reply = connection.Subscribe(subscription0, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription0, subscription0Reply))
                    ResultCode = TEST_RESULTS.FAILED;

                SUBSCRIBE_REPLY subscription1Reply = connection.Subscribe(subscription1, new int[] { 1 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscription1, subscription1Reply))
                    ResultCode = TEST_RESULTS.FAILED;
                
                connection.ClearNotificationRecievedList();
                XConnSrvTestHelpers.SendNotifications(subscription0);
                XConnSrvTestHelpers.SendNotifications(subscription1);

                // Verify notification was received
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscription0, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, subscription1, 1, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                // TODO: In the future use local information to verify correct data was returned for basic and rich presence
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)(subscription0.Length), (uint)(subscription0.Length+1) ))
                //    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class TestPresenceIntegration : TestBase 
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, false, false);

                // Create subscriptions
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Friends = 1;
                pnub.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Friends);

                PNXbox xbox = new PNXbox(true);
                users[0].Connect(xbox);
                FriendsCommon fc = new FriendsCommon();
                fc.LogonUser(users[0]);
                connection = users[0].Xbox.ConnectionServerConnection;

                //subscribe basic.
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                connection.ClearNotificationRecievedList();
                XConnSrvTestHelpers.SendNotifications(basicsub);

                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, basicsub, 0, 5))
                    ResultCode = TEST_RESULTS.FAILED;

                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, basicsub, unsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                //Should trigger disconnect.
                users[0].Disconnect();

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates 2 users on a connection and subscribes them to each other, disconnect them, and
        /// make sure no notifications are received
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class NoNotificationWhenNoOneSignedIn : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);

                // Connect both users
                connection = users[0].Xbox.ConnectionServerConnection;
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                {
                    Global.RO.Error("Connection was not created.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                // Create subscription manually to each other
                DATA_OBJECT_SPECIFIER[] subscription0 = new DATA_OBJECT_SPECIFIER[1];
                DATA_OBJECT_SPECIFIER[] subscription1 = new DATA_OBJECT_SPECIFIER[1];

                subscription0[0].wObjectSize = (ushort)(new BasicPresence()).Size();
                subscription1[0].wObjectSize = subscription0[0].wObjectSize;
                subscription0[0].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                subscription1[0].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                subscription0[0].dwDataSubType = 0;
                subscription1[0].dwDataSubType = 0;
                subscription0[0].qwOwnerXUID = users[1].UserId;
                subscription1[0].qwOwnerXUID = users[0].UserId;

                SUBSCRIBE_REPLY subscription0Reply = connection.Subscribe(subscription0, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription0, subscription0Reply))
                    ResultCode = TEST_RESULTS.FAILED;

                SUBSCRIBE_REPLY subscription1Reply = connection.Subscribe(subscription1, new int[] { 1 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscription1, subscription1Reply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Remove all connected users
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[0], new ulong[0], users[0].Xbox.XboxId))
                {
                    Global.RO.Error("Connected users was not updated.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                System.Threading.Thread.Sleep(3000);

                // Try Forcing Notifications
                connection.ClearNotificationRecievedList();
                XConnSrvTestHelpers.SendNotifications(subscription0);
                XConnSrvTestHelpers.SendNotifications(subscription1);

                System.Threading.Thread.Sleep(3000);

                // See if we got any notifications...
                if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 0))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        
        /// <summary>
        /// Simple case for owner notify functionality
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class OwnerNotifyBasic : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;

                Thread.Sleep(2000);

                connection.ClearNotificationRecievedList();

                // write some data.
                string payload = "some data";
                OwnerNotifyData data = new OwnerNotifyData();
                data.DataType = (ushort)DATA_TYPES.eToastQueue;
                data.OwnerID = users[0].UserId;
                data.TargetConnectionType = OwnerNotifyData.ConnectionType.eConsole;
                data.jsonPayload = payload;
                CacheUtil.OverwriteCache(data);

                Thread.Sleep(2000);
                // Verify the notifications expected were received
                OwnerNotifyData notif = (OwnerNotifyData)CacheUtil.ReadCacheItemFromBytes((byte[])(connection.NotificationsReceived[0].rgDataObjects[0]));
                Assert.IsTrue(notif.jsonPayload == data.jsonPayload, string.Format("payloads do not match: ({0}) != ({1})", notif.jsonPayload, data.jsonPayload));
                
                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Language specific case for owner notify functionality
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class OwnerNotifyLanguageSpecific : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;

                Thread.Sleep(2000);

                connection.ClearNotificationRecievedList();

                // write some data.
                LanguageSpecificData lsBlob = new LanguageSpecificData(DATA_TYPES.eToastQueue);
                lsBlob.OwnerID = users[0].UserId;
                lsBlob.DataSubType = OwnerNotifyData.BuildDataSubType(OwnerNotifyData.ConnectionType.eConsole);
                lsBlob.rgLocales = new string[] {"en-US", "fr-FR"};
                lsBlob.rgInnerBlobs = new BaseDataHeader[lsBlob.rgLocales.Length];
                
                string enPayload = "some data";
                OwnerNotifyData enData = new OwnerNotifyData();
                enData.DataType = (ushort)DATA_TYPES.eToastQueue;
                enData.OwnerID = users[0].UserId;
                enData.TargetConnectionType = OwnerNotifyData.ConnectionType.eConsole;
                enData.jsonPayload = enPayload;                
                
                string frPayload = "le dete";
                OwnerNotifyData frData = new OwnerNotifyData();
                frData.DataType = (ushort)DATA_TYPES.eToastQueue;
                frData.OwnerID = users[0].UserId;
                frData.TargetConnectionType = OwnerNotifyData.ConnectionType.eConsole;
                frData.jsonPayload = frPayload;

                lsBlob.rgInnerBlobs[0] = enData;
                lsBlob.rgInnerBlobs[1] = frData;
                CacheUtil.OverwriteCache(lsBlob);

                Thread.Sleep(2000);
                // Verify the notifications expected were received
                OwnerNotifyData notif = (OwnerNotifyData)CacheUtil.ReadCacheItemFromBytes((byte[])(connection.NotificationsReceived[0].rgDataObjects[0]));
                Assert.IsTrue(notif.jsonPayload == enData.jsonPayload, string.Format("payloads do not match: ({0}) != ({1})", notif.jsonPayload, enData.jsonPayload));
                
                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, new int[] { 0 }))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncQuery.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;

using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Query
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncQuery_PostiveCases : TestNode
    {
        [TestCase]
        public void P_Mainline()
        {
            PNConnection connection = null;
            try
            {
                ulong[] UserIds = new ulong[] { 987654321 };
                int[] UserIndices = new int[] { 1 };
                //Connect at UserIndex 0
                XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, UserIds, 0);

                int numQueries = 5;
                Random rand = new Random();
                byte[][] data;
                data = new byte[numQueries][];
                DATA_OBJECT_SPECIFIER[] queries = new DATA_OBJECT_SPECIFIER[numQueries];
                for (int j = 0; j < numQueries; j++)
                {
                    data[j] = new byte[rand.Next(10, 50)];

                    // TODO: object size does not have to match exactly.  It exceptioned when I changed this.  Why??  Supplied value was 0.
                    queries[j].wObjectSize = (ushort)((ushort)data[j].Length + (ushort)16);
                    queries[j].qwOwnerXUID = (ulong)(987654321 + j);
                    queries[j].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                    rand.NextBytes(data[j]);
                    XConnSrvMemCache.InsertDataObject(queries[j], data[j]);
                }
                
                QUERY_REPLY queryReply = connection.Query(queries);
                Assert.IsTrue(queryReply.dwNumDataObjects == queries.Length, "Reply should have same length as request");
                Assert.IsTrue(queryReply.rgDataObjects.Length == queries.Length, "Reply should have same length as request");

                for (int j = 0; j < queries.Length; j++)
                {
                    // TODO:  watch for order
                    Assert.IsTrue(queries[j].qwOwnerXUID == queryReply.rgDataObjects[j].qwOwnerXUID, "Same users in response");
                    byte[] queryReplyData = queryReply.rgDataObjects[j].data;
                    byte[] suppliedData = data[j];
                    Assert.IsTrue(queryReplyData.Length == data[j].Length, "Data should match supplied length.");
                    for (int curByte = 0; curByte < data[j].Length; curByte++)
                    {
                        Assert.IsTrue(queryReplyData[curByte] == suppliedData[curByte], "Data should match");
                    }
                }

            }
            finally
            {
                connection.Disconnect(0);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncPerfCounters.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;

using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.config;
using xonline.common.community;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for XConnSrv Performance Counters.
    /// </summary>
    [TestGroup, EnvRequirement("Manual")]
    public class FuncPerfCounters_PositiveCases : TestNode
    {
        /// <summary>
        /// Creates 50 connections with a single user on a each connection, verifies the connection count, disconnects
        /// every connection, verifies the counter is at 0
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class ClientConnections : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                int CSServerCount = Global.XEnv.GetServerListByComponent("xconnsrv").Length;
                long sumConnectionBefore = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Client Connections";
                    clientConnCounter.InstanceName = "_total_";
                    sumConnectionBefore = sumConnectionBefore + clientConnCounter.RawValue;
                }

                int totalConnections = 50;
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers((uint)totalConnections, true, false);

                Thread.Sleep(5000);

                long sumConnectionAfter = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Client Connections";
                    clientConnCounter.InstanceName = "_total_";
                    sumConnectionAfter = sumConnectionAfter + clientConnCounter.RawValue;
                }

                Assert.IsTrue(sumConnectionAfter - sumConnectionBefore == totalConnections, "All newly created connections accounted for. Before: " + sumConnectionBefore + " After: " + sumConnectionAfter);

                foreach (PNUser usr in users)
                {
                    usr.Xbox.ConnectionServerConnection.Disconnect();
                }

                Thread.Sleep(5000);

                long sumConnectionAfterDisconnect = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Client Connections";
                    clientConnCounter.InstanceName = "_total_";
                    sumConnectionAfterDisconnect = sumConnectionAfterDisconnect + clientConnCounter.RawValue;
                }

                Assert.IsTrue(sumConnectionBefore == sumConnectionAfterDisconnect, "Back to where we were. Before: " + sumConnectionBefore + " After: " + sumConnectionAfterDisconnect);
            }
        }

        /// <summary>
        /// Creates 40 users, 4 users per connection, verifies the user count, disconnects every connection + user, verifies
        /// the counter is at 0
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class ConnectedUsers : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                int CSServerCount = Global.XEnv.GetServerListByComponent("xconnsrv").Length;
                long connUsersBegin = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter connUsersCounter = new PerformanceCounter();
                    connUsersCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[0];
                    connUsersCounter.CategoryName = "XBL Connection Svc";
                    connUsersCounter.CounterName = "Connected Users";
                    connUsersCounter.InstanceName = "_total_";
                    connUsersBegin = connUsersBegin + connUsersCounter.RawValue;
                }

                int totalUsers = 40; // multiple of 4 plz
                
                PNUser[] users = new PNUser[totalUsers];

                for (int i = 0; i < totalUsers; i+=4)
                {
                    PNUser[] singleConnUsers = PNUsersBuilder.GetLiveXenonUsers(4, true, true);
                    for (int j = 0; j < 4; ++j)
                    {
                        users[i + j] = singleConnUsers[j];
                    }
                }

                Thread.Sleep(5000);

                // Counter should be totalUsers larger than when we started
                long connUsersAfter = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter connUsersCounter = new PerformanceCounter();
                    connUsersCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[0];
                    connUsersCounter.CategoryName = "XBL Connection Svc";
                    connUsersCounter.CounterName = "Connected Users";
                    connUsersCounter.InstanceName = "_total_";
                    connUsersAfter = connUsersAfter + connUsersCounter.RawValue;
                }

                if (connUsersAfter != connUsersBegin + totalUsers)
                {
                    Global.RO.Error("" + totalUsers + " users were connected, but the counter only counts " + (connUsersBegin + totalUsers - connUsersAfter) + " users.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("" + totalUsers + " users were successfully counted after connecting.");
                }

                foreach (PNUser usr in users)
                {
                    usr.Xbox.ConnectionServerConnection.Disconnect();
                }

                Thread.Sleep(5000);

                // Counter should be the same as when we started now
                long connUsersAfterDisconnect = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter connUsersCounter = new PerformanceCounter();
                    connUsersCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[0];
                    connUsersCounter.CategoryName = "XBL Connection Svc";
                    connUsersCounter.CounterName = "Connected Users";
                    connUsersCounter.InstanceName = "_total_";
                    connUsersAfterDisconnect = connUsersAfterDisconnect + connUsersCounter.RawValue;
                }

                if (connUsersAfterDisconnect != connUsersBegin)
                {
                    Global.RO.Error("The counter is incorrect after " + totalUsers + " disconnected. Begin: " + connUsersBegin + " End: " + connUsersAfterDisconnect);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("" + totalUsers + " users were successfully uncounted after disconnecting.");
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a single user on a single connection and subscribes to 50 friends' basic presence and 50 friends' rich
        /// presence, verifies the subscription count, unsubscribes from rich, then unsubscribes from basic, verifies the 
        /// counter is at 0
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class TotalSubscriptions : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

               

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                PNConnection connection = users[0].Xbox.ConnectionServerConnection;

                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Offline_Friends = 20;
                builder.Online_Friends = 20;
                builder.Offline_Peers = 10;
                builder.CreateUsers(users[0]);
                
                PNUser[] allSubscribees = new PNUser[builder.Friends.Length + builder.Peers.Length];
                Array.Copy(builder.Friends, 0, allSubscribees, 0, builder.Friends.Length);
                Array.Copy(builder.Peers, 0, allSubscribees, builder.Friends.Length, builder.Peers.Length);

                DATA_OBJECT_SPECIFIER[] basicSubscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, allSubscribees);
                DATA_OBJECT_SPECIFIER[] richSubscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, allSubscribees);
                connection.Unsubscribe(basicSubscriptions);
                connection.Unsubscribe(richSubscriptions);

                //record the precondition
                int CSServerCount = Global.XEnv.GetServerListByComponent("xconnsrv").Length;
                long sumSubsBefore = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumSubsBefore = sumSubsBefore + clientConnCounter.RawValue;
                }

                // Subscribe to basic presence and verify
                SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basicSubscriptions);
                Assert.IsTrue((uint)basicSubscribeReply.hr == HResult.S_OK, "Subscribed.");

                long sumBasicSubsAfter = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumBasicSubsAfter = sumBasicSubsAfter + clientConnCounter.RawValue;
                }
                Assert.AreEqual(sumBasicSubsAfter - sumSubsBefore, basicSubscriptions.Length, "All basic subscriptions accounted for.");
                
                // Subscribe to rich presence and verify
                SUBSCRIBE_REPLY richSubscribeReply = connection.Subscribe(richSubscriptions);
                Assert.IsTrue((uint)richSubscribeReply.hr == HResult.S_OK, "Subscribed.");

                long sumRichSubsAfter = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumRichSubsAfter = sumRichSubsAfter + clientConnCounter.RawValue;
                }

                Assert.AreEqual(sumRichSubsAfter - sumBasicSubsAfter , richSubscriptions.Length, "All Rich subscriptions accounted for.");

                // Unsubscribe from rich and basic presence and verify
                UNSUBSCRIBE_REPLY richUnsubscribeReply = connection.Unsubscribe(richSubscriptions);
                if (HResult.Failed((uint)richUnsubscribeReply.hr))
                    throw new HResultException((uint)richUnsubscribeReply.hr, "Unsubscribe Failed");
                UNSUBSCRIBE_REPLY basicUnsubscribeReply = connection.Unsubscribe(basicSubscriptions);
                if (HResult.Failed((uint)basicUnsubscribeReply.hr))
                    throw new HResultException((uint)basicUnsubscribeReply.hr, "Unsubscribe Failed");

                long sumSubsAfterUnsubscribe = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumSubsAfterUnsubscribe = sumSubsAfterUnsubscribe + clientConnCounter.RawValue;
                }
                Assert.AreEqual(sumSubsAfterUnsubscribe , sumSubsBefore, "Subscription count same as before.");
            }
        }

        /// <summary>
        /// Creates a single user on a single connection, connects normally, then reconnects several times in a row and verifies
        /// that the counter is not 0, then pauses and confirms it is 0, then repeats with more reconnects. At the end a total
        /// number of reconnects is verified.
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class ReconnectRate : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PerformanceCounter reconnectRateCounter = new PerformanceCounter();
                reconnectRateCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[0];
                reconnectRateCounter.CategoryName = "XBL Connection Svc";
                reconnectRateCounter.CounterName = "Reconnection Rate";
                reconnectRateCounter.InstanceName = "_total_";

                long reconnectRateBegin = reconnectRateCounter.RawValue;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                PNConnection connection = users[0].Xbox.ConnectionServerConnection ;

                reconnectRateCounter.NextValue();

                // Now lets reconnect a few times
                for (int i = 0; i < 20; ++i)
                {
                    connection.Connect(true);
                }

                if (reconnectRateCounter.NextValue() == 0.0)
                {
                    Global.RO.Error("Reconnect rate was not positive.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Reconnect rate was positive.");
                }

                Thread.Sleep(3000);

                if (reconnectRateCounter.NextValue() != 0.0)
                {
                    Global.RO.Error("Reconnect rate was not 0 as expected.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Reconnect rate was 0 as expected.");
                }

                Thread.Sleep(3000);

                // Now lets reconnect a few more times
                for (int i = 0; i < 20; ++i)
                {
                    connection.Connect(true);
                }

                long reconnectRateThree = reconnectRateCounter.RawValue;

                if (reconnectRateCounter.NextValue() == 0.0)
                {
                    Global.RO.Error("Reconnect rate was not positive.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Reconnect rate was positive.");
                }

                long reconnectRateEnd = reconnectRateCounter.RawValue;

                if (reconnectRateEnd - reconnectRateBegin != 40)
                {
                    Global.RO.Error("Total Reconnects not counted.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Info("Correct number of reconnects counted total.");
                }
                
                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }

    //[TestGroup]
    //public class BasicTests : TestNode
    //{
    //    [TestCase]
    //    public class HealthCheck : TestBase
    //    {
    //        override protected void Execute()
    //        {
    //            string[] servers = Config.GetServerListByInterface(Interface.XConnSrv);
    //            foreach (string server in servers)
    //            {
    //                try
    //                {
    //                    DoHealthCheck(server);
    //                }
    //                catch (Exception e)
    //                {
    //                    Global.RO.Error("XConnSrv Healthcheck failed on " + server + Environment.NewLine + "Exception: " + e.Message + Environment.NewLine + "StackTrace: " + e.StackTrace);
    //                    // do not rethrow, continue with next server
    //                }
    //            }
 
    //        }

    //        private void DoHealthCheck(string server)
    //        {
    //            byte[] postData = new byte[0];
    //            byte[] responseData;
    //            string xErr;
    //            HResult hr;

    //            IInterfaceInfo iinfo = Config.GetInterface(server, Interface.xmatchfd_int);
    //            string url = iinfo.Url + iinfo.VDir + "/health.ashx";
    //            WebClient myWebClient = new WebClient();
    //            try
    //            {
    //                Log("[MatchAdmin.HealthCheck]: Posting request to " + server + " (" + url +
    //                    ") to ensure match component is loaded");

    //                // match is service 6 - must have this header or xrlscan will reject
    //                // the request
    //                myWebClient.Headers.Add("Content-Type", "xon/6");

    //                responseData = myWebClient.UploadData(url, "POST", postData);

    //                hr = HResult.S_OK;
    //                xErr = myWebClient.ResponseHeaders["X-Err"];
    //                if (xErr != null)
    //                {
    //                    hr = HResult.Parse(xErr);
    //                }
    //                if (HResult.Failed(hr))
    //                {
    //                    LogError("[MatchAdmin.HealthCheck]: Health Check Failed with X-Err: " + hr);
    //                }
    //            }
    //            catch (WebException e)
    //            {
    //                LogError("[MatchAdmin.HealthCheck]: Health Check Failed by throwing WebException, e.Message: " + e.Message);
    //            }
    //        }
    //    }
        
    //    [TestCase, DoNotRunDaily]
    //    public class ServiceRestart : TestBase
    //    {
    //        override protected void Execute()
    //        {
    //            string[] servers = Config.GetServerListByInterface(Interface.XConnSrv);
    //            foreach (string server in servers)
    //            {
    //                try
    //                {
    //                    RestartXConnServerService(server);
    //                }
    //                catch (Exception e)
    //                {
    //                    Global.RO.Error("XConnSrv Service Failed to start on " + server + Environment.NewLine + "Exception: " + e.Message + Environment.NewLine + "StackTrace: " + e.StackTrace);
    //                    // do not rethrow, continue with next server
    //                }
    //            }
    //        }

    //        private void RestartXConnServerService(string server)
    //        {
    //            System.ServiceProcess.ServiceController sc = new System.ServiceProcess.ServiceController("XConnSrv", server);
    //            if (sc.Status == System.ServiceProcess.ServiceControllerStatus.Running)
    //            {
    //                sc.Stop();
    //                sc.WaitForStatus(System.ServiceProcess.ServiceControllerStatus.Stopped);
    //            }
    //            sc.Start();
    //            sc.WaitForStatus(System.ServiceProcess.ServiceControllerStatus.Running);
    //        }
    //    }

    //}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncPublish.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Publish
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncPublish_PostiveCases : TestNode
    {
        public static void IsValidDataPublished(byte[] PublishedData, byte[] SubmittedData, DATA_OBJECT_SPECIFIER DOSpec)
        {
            unsafe
            {
                fixed (byte* pPublishedData = PublishedData)
                {
                    DATA_OBJECT_SPECIFIER* pDOSpec = (DATA_OBJECT_SPECIFIER*)pPublishedData;
                    Assert.IsTrue(pDOSpec->wObjectSize == DOSpec.wObjectSize, String.Format("Incorrect Size Published. Expected {0}, Got {1}",DOSpec.wObjectSize, pDOSpec->wObjectSize));
                    Assert.IsTrue(pDOSpec->wDataType == DOSpec.wDataType, String.Format("Incorrect Data Type Published. Expected {0}, Got {1}", DOSpec.wDataType, pDOSpec->wDataType));
                    Assert.IsTrue(pDOSpec->dwDataSubType == DOSpec.dwDataSubType,  String.Format("Incorrect Size Published. Expected {0}, Got {1}", DOSpec.dwDataSubType, pDOSpec->dwDataSubType));
                    Assert.IsTrue(pDOSpec->qwOwnerXUID == DOSpec.qwOwnerXUID, String.Format("Incorrect Size Published. Expected {0}, Got {1}", DOSpec.dwDataSubType, pDOSpec->dwDataSubType));
                }

                // Since the data contains both the data object specifier as well as the data, we need to change the size to get it all
                Assert.IsTrue(SubmittedData.Length == PublishedData.Length - sizeof(BASE_DATA_HEADER), String.Format("Expected Length of the published data does not match submitted.Expected {0}, Got {1}", SubmittedData.Length, PublishedData.Length - sizeof(BASE_DATA_HEADER)));

                for (int i = 0; i < SubmittedData.Length; i++)
                {
                    Assert.IsTrue(SubmittedData[i] == PublishedData[i + sizeof(BASE_DATA_HEADER)], "Published Data is incorrect");
                }
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVT_Publish : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                try
                {
                    PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                    connection = users[0].Xbox.ConnectionServerConnection;

                    byte[] dataAvatar = new byte[1000];
                    DATA_OBJECT_SPECIFIER doSpec_avatar = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eAvatar, users[0].UserId);

                    PUBLISH_REPLY reply = connection.Publish(new DATA_OBJECT_SPECIFIER[] { doSpec_avatar }, new byte[][] { dataAvatar });
                    Assert.IsTrue(HResult.S_OK == (uint)reply.hr, String.Format("Publish return value unexpected. Expected {0}, Got {1}", HResult.S_OK, reply.hr));

                    byte[] cacheDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpec_avatar));
                    IsValidDataPublished(cacheDataAvatar, dataAvatar, doSpec_avatar);
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                finally
                {
                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class Publish_Non_Zero_User_Index : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                try
                {
                    PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                    connection = users[0].Xbox.ConnectionServerConnection;

                    // Connect at UserIndex 0 and 1
                    //Assert.IsTrue(XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId), "Connect Failed");

                    byte[] dataAvatar = new byte[1000];
                    DATA_OBJECT_SPECIFIER doSpec_avatar = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eAvatar, users[1].UserId);

                    PUBLISH_REPLY reply = connection.Publish(new DATA_OBJECT_SPECIFIER[] { doSpec_avatar }, new byte[][] { dataAvatar });
                    Assert.IsTrue(HResult.S_OK == (uint)reply.hr, String.Format("Publish return value unexpected. Expected {0}, Got {1}", HResult.S_OK, reply.hr));

                    byte[] cacheDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpec_avatar));
                    IsValidDataPublished(cacheDataAvatar, dataAvatar, doSpec_avatar);
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                finally
                {
                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class Publish_Multiple_DOS : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                try
                {
                    PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                    connection = users[0].Xbox.ConnectionServerConnection;

                    byte[] dataAvatar = new byte[1000];
                    byte[] dataBasicProfile = new byte[0];
                    byte[][] data_basic = new byte[2][];
                    data_basic[0] = dataAvatar;
                    data_basic[1] = dataBasicProfile;

                    ulong userId = users[0].UserId;
                    DATA_OBJECT_SPECIFIER doSpec_avatar = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eAvatar, userId);
                    DATA_OBJECT_SPECIFIER doSpec_basicProfile = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eBasicProfile, userId);
                    DATA_OBJECT_SPECIFIER[] doSpecs_basic = new DATA_OBJECT_SPECIFIER[] { doSpec_avatar, doSpec_basicProfile };

                    PUBLISH_REPLY reply = connection.Publish(doSpecs_basic, data_basic);
                    Assert.IsTrue(HResult.S_OK == (uint)reply.hr, String.Format("Publish return value unexpected. Expected {0}, Got {1}", HResult.S_OK, reply.hr));

                    byte[] cacheDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[0]));
                    byte[] cacheDataBasicProfile = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[1]));

                    IsValidDataPublished(cacheDataAvatar, dataAvatar, doSpec_avatar);
                    IsValidDataPublished(cacheDataBasicProfile, dataBasicProfile, doSpec_basicProfile);
                }
                catch(Exception ex)
                {
                    Global.RO.Error(ex.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                finally
                {
                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class Publish_Empty : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                try
                {
                    PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                    connection = users[0].Xbox.ConnectionServerConnection;

                    DATA_OBJECT_SPECIFIER doSpec_avatar = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eAvatar, users[0].UserId);
                    
                    unsafe
                    {
                        doSpec_avatar.wObjectSize = (ushort)sizeof(DATA_OBJECT_SPECIFIER);
                    }

                    PUBLISH_REPLY reply = connection.Publish(new DATA_OBJECT_SPECIFIER[] { doSpec_avatar }, new byte[][] { new byte[0] });
                    Assert.IsTrue(HResult.S_OK == (uint)reply.hr, String.Format("Publish return value unexpected. Expected {0}, Got {1}", HResult.S_OK, reply.hr));

                    byte[] cacheDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpec_avatar));
                    IsValidDataPublished(cacheDataAvatar, new byte[0], doSpec_avatar);
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                finally
                {
                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class PublishQuery_PartyInfo : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                // make a user
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                PNUser user = users[0];

                // make a party blob
                byte[] partyBlob = new byte[256];
                RandomEx.GlobalRandGen.NextBytes(partyBlob);

                // make a specifier
                DATA_OBJECT_SPECIFIER dos = new DATA_OBJECT_SPECIFIER();
                dos.qwOwnerXUID = user.UserId;
                dos.wDataType = (ushort)DATA_TYPES.ePartyInfo;
                dos.wObjectSize = (ushort)((new BaseDataHeader()).Size() + partyBlob.Length);

                // send the publish
                PNConnection connection = user.Xbox.ConnectionServerConnection;
                PUBLISH_REPLY reply = connection.Publish(new DATA_OBJECT_SPECIFIER[] { dos }, new byte[][] { partyBlob });
                Assert.IsTrue(HResult.S_OK == (uint)reply.hr, String.Format("Publish return value unexpected. Expected {0}, Got {1}", HResult.S_OK, reply.hr));

                // query back the publised data
                QUERY_REPLY queryReply = connection.Query(new DATA_OBJECT_SPECIFIER[] { dos });
                Assert.IsTrue(HResult.S_OK == (uint)queryReply.hr, String.Format("Query return value unexpected. Expected {0}, Got {1}", HResult.S_OK, queryReply.hr));
                Assert.IsTrue(1 == queryReply.dwNumDataObjects, String.Format("Query unexpected number of objects returned. Expected {0}, Got {1}", 1, queryReply.dwNumDataObjects));
                Assert.IsTrue(xonline.common.service.Acceleration.CompareByteArrays(queryReply.rgDataObjects[0].data, partyBlob), String.Format("Query returned unmatched data"));

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }


    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2), Ignore]
    public class FuncPublish_NegativeCases : TestNode
    {
        public static void HasDataChanged(byte[] orig, byte[] postPublish)
        {
            // Since the data contains both the data object specifier as well as the data, we need to change the size to get it all
            Assert.IsTrue(orig.Length == postPublish.Length, String.Format("Expected Length of the published data does not match submitted.Expected {0}, Got {1}", orig.Length, postPublish.Length));

            for (int i = 0; i < orig.Length; i++)
            {
                Assert.IsTrue(orig[i] == postPublish[i], "Published Data is changed");
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class Publish_Not_Publishable : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                try
                {
                    PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                    connection = users[0].Xbox.ConnectionServerConnection;

                    byte[] dataBasicPresence = new byte[10];
                    DATA_OBJECT_SPECIFIER doSpec_basicPresence = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eBasicPresence, users[0].UserId);

                    byte[] origDataBasicPresence = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpec_basicPresence));

                    PUBLISH_REPLY reply = connection.Publish(new DATA_OBJECT_SPECIFIER[] { doSpec_basicPresence }, new byte[][] { dataBasicPresence });

                    byte[] cacheDataBasicPresence = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpec_basicPresence));

                    HasDataChanged(origDataBasicPresence, cacheDataBasicPresence);

                    Assert.IsTrue(!(HResult.S_OK == (uint)reply.hr), "Publish should not have been successful.");
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                finally
                {
                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class Publish_Not_Publishable_Multiple : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                try
                {
                    PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                    connection = users[0].Xbox.ConnectionServerConnection;

                    byte[] dataAvatar = new byte[1000];
                    byte[] dataBasicPresence = new byte[10];
                    byte[][] data_basic = new byte[2][];
                    data_basic[0] = dataAvatar;
                    data_basic[1] = dataBasicPresence;

                    ulong userId = users[0].UserId;
                    DATA_OBJECT_SPECIFIER doSpec_avatar = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eAvatar, userId);
                    DATA_OBJECT_SPECIFIER doSpec_basicPresence = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eBasicPresence, userId);
                    DATA_OBJECT_SPECIFIER[] doSpecs_basic = new DATA_OBJECT_SPECIFIER[] { doSpec_avatar, doSpec_basicPresence };

                    byte[] origDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[0]));
                    byte[] origDataBasicPresence = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[1]));

                    PUBLISH_REPLY reply = connection.Publish(doSpecs_basic, data_basic);

                    byte[] cacheDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[0]));
                    byte[] cacheDataBasicPresence = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[1]));

                    HasDataChanged(origDataAvatar, cacheDataAvatar);
                    HasDataChanged(origDataBasicPresence, cacheDataBasicPresence);

                    Assert.IsTrue(!(HResult.S_OK == (uint)reply.hr), "Publish should not have been successful.");
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                finally
                {
                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class Publish_Not_Owner : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                try
                {
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                //TODO: Vefify that connection has the reference to correct user.
                connection = users[0].Xbox.ConnectionServerConnection;

                byte[] dataAvatar = new byte[1000];
                DATA_OBJECT_SPECIFIER doSpec_avatar = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eAvatar, users[1].UserId);

                byte[] origDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpec_avatar));

                PUBLISH_REPLY reply = connection.Publish(new DATA_OBJECT_SPECIFIER[] { doSpec_avatar }, new byte[][] { dataAvatar });

                byte[] cacheDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpec_avatar));

                HasDataChanged(origDataAvatar, cacheDataAvatar);

                Assert.IsTrue(!(HResult.S_OK == (uint)reply.hr), "Publish should not have been successful.");

                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                finally
                {
                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class Publish_Not_Owner_Multiple : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                try
                {
                    PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                   //TODO: Vefify that connection has the reference to correct user.
                    connection = users[0].Xbox.ConnectionServerConnection;

                    byte[] dataAvatar = new byte[1000];
                    byte[] dataBasicPresence = new byte[10];
                    byte[][] data_basic = new byte[2][];
                    data_basic[0] = dataAvatar;
                    data_basic[1] = dataBasicPresence;

                    ulong userId = users[2].UserId;
                    DATA_OBJECT_SPECIFIER doSpec_avatar = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eAvatar, userId);
                    DATA_OBJECT_SPECIFIER doSpec_basicPresence = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eBasicPresence, userId);
                    DATA_OBJECT_SPECIFIER[] doSpecs_basic = new DATA_OBJECT_SPECIFIER[] { doSpec_avatar, doSpec_basicPresence };

                    byte[] origDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[0]));
                    byte[] origDataBasicPresence = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[1]));

                    PUBLISH_REPLY reply = connection.Publish(doSpecs_basic, data_basic);

                    byte[] cacheDataAvatar = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[0]));
                    byte[] cacheDataBasicPresence = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(doSpecs_basic[1]));

                    HasDataChanged(origDataAvatar, cacheDataAvatar);
                    HasDataChanged(origDataBasicPresence, cacheDataBasicPresence);

                    Assert.IsTrue(!(HResult.S_OK == (uint)reply.hr), "Publish should not have been successful.");
                }
                catch (Exception ex)
                {
                    Global.RO.Error(ex.Message);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                finally
                {
                    // Disconnect
                    if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Ignore]
        public class Publish_Invalid_Data_Type : TestBase
        {
            override protected void Execute()
            {
                // Need to adjust common code to enable this case
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Ignore]
        public class Publish_Too_Many_Objects : TestBase
        {
            override protected void Execute()
            {
                // Is this case necessary?
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncSingleConnectionTests.cs ===
﻿
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Singleton Connection
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(1)]
    public class FuncSingleConnectionTests : TestNode
    {
        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVTSingleUser : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create Live user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;

                
                //Keep the connection and dump stuff to velocity
                string newLocation = "shailesh2";
                XConnSrvTestHelpers.ChangeServerLocation(users[0].UserId, connection.ClientIPAddr.ToString(), connection.ClientIPPort, newLocation);

                //See that user is not connected any more..
                Thread.Sleep(2000);
                Assert.IsTrue(false ==XConnSrvTestHelpers.IsUserConnected(users[0].UserId,0), "Connection.Connected");

                string xmgmtcoutput = string.Empty;
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[0].UserId.ToString(), out xmgmtcoutput);
                
                Assert.IsTrue(xmgmtcoutput.Contains("User " + String.Format("{0:X}", users[0].UserId) + " was last connected to server " + newLocation), "Server location data found.");

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;

            }
        }

        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVTMultiUser : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create Live user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;


                //Keep the connection and dump stuff to velocity
                string newLocation = "shailesh2";
                XConnSrvTestHelpers.ChangeServerLocation(users[0].UserId, connection.ClientIPAddr.ToString(), connection.ClientIPPort, newLocation);

                //See that user is not connected any more..
                Thread.Sleep(2000);
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                Assert.IsTrue(true == XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "Connection.Connected");

                string xmgmtcoutput = string.Empty;
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[0].UserId.ToString(), out xmgmtcoutput);

                Assert.IsTrue(xmgmtcoutput.Contains("User " + String.Format("{0:X}", users[0].UserId) + " was last connected to server " + newLocation), "Server location data found.");
                Assert.IsTrue(false == xmgmtcoutput.Contains("User " + String.Format("{0:X}", users[1].UserId) + " was last connected to server " + newLocation), "Server location data found.");


                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;

            }
        }

        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MultiUserVerifySubscriptions1: TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                int CSServerCount = Global.XEnv.GetServerListByComponent("xconnsrv").Length;
                long sumSubsBefore = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumSubsBefore = sumSubsBefore + clientConnCounter.RawValue;
                }

                //Create Live user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true); //this will create 2 subscription for 2 users in alive.
                connection = users[0].Xbox.ConnectionServerConnection;

                ////Connect user.ClientIPAddr
                //Assert.AreEqual(true, XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId), "Connection established.");

                //Get DOS.
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users[0]); //this will create 5 + 10 + 10 subscription total.
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscribes_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Friends);

                //Keep the connection and dump stuff to velocity
                XConnSrvTestHelpers.ChangeServerLocation(users[0].UserId, connection.ClientIPAddr.ToString(), connection.ClientIPPort, "shailesh2");

                //See that user is not connected any more..this should reduce the total subs by 11.
                Thread.Sleep(2000);
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                Assert.IsTrue(true == XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "Connection.Connected");
                
                FriendsCommon fc = new FriendsCommon();

                // Log off everyone except 1
                for (int i = 0; i < builder.Friends.Length - 1; ++i)
                    fc.LogoffUser(builder.Friends[i]);

                //Check the subscriptions.
                long sumSubsAfter = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumSubsAfter = sumSubsAfter + clientConnCounter.RawValue;
                }

                // We log everyone off except 1, meaning there will be 1 basic and 1 rich subscription remaining.
                Assert.IsTrue(sumSubsAfter - sumSubsBefore == 2, "Incorrect number of subscriptions remaining. Before: " + sumSubsBefore + " After: " + sumSubsAfter);

            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MultiUserVerifySubscriptions2 : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                int CSServerCount = Global.XEnv.GetServerListByComponent("xconnsrv").Length;
                long sumSubsBefore = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumSubsBefore = sumSubsBefore + clientConnCounter.RawValue;
                }

                //Create Live user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                //Get DOS.
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscribes_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Friends);

                //Keep the connection and dump stuff to velocity
                XConnSrvTestHelpers.ChangeServerLocation(users[0].UserId, connection.ClientIPAddr.ToString(), connection.ClientIPPort, "shailesh2");

                //See that user is not connected any more..
                Thread.Sleep(2000);
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                Assert.IsTrue(true == XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "Connection.Connected");

                FriendsCommon fc = new FriendsCommon();

                // Log off everyone except 1
                for (int i = 0; i < builder.Friends.Length - 1; ++i)
                    fc.LogoffUser(builder.Friends[i]);

                //Check the subscriptions.
                long sumSubsAfter = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumSubsAfter = sumSubsAfter + clientConnCounter.RawValue;
                }

                // We log everyone off except 1, meaning there will be 1 basic and 1 rich subscription remaining.
                Assert.IsTrue(sumSubsAfter - sumSubsBefore == 2, "Incorrect number of subscriptions remaining. Before: " + sumSubsBefore + " After: " + sumSubsAfter);

            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class SingleUserVerifySubscriptions : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                int CSServerCount = Global.XEnv.GetServerListByComponent("xconnsrv").Length;
                long sumSubsBefore = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumSubsBefore = sumSubsBefore + clientConnCounter.RawValue;
                }

                //Create Live user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                //Get DOS.
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscribes_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Friends);

                //Keep the connection and dump stuff to velocity
                XConnSrvTestHelpers.ChangeServerLocation(users[0].UserId, connection.ClientIPAddr.ToString(), connection.ClientIPPort, "shailesh2");

                //See that user is not connected any more..
                Thread.Sleep(2000);
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");

                FriendsCommon fc = new FriendsCommon();
                foreach (PNUser u in builder.Friends)
                    fc.LogoffUser(u);

                //Check the subscriptions.
                long sumSubsAfter = 0;
                for (int i = 0; i < CSServerCount; i++)
                {
                    PerformanceCounter clientConnCounter = new PerformanceCounter();
                    clientConnCounter.MachineName = Global.XEnv.GetServerListByComponent("xconnsrv")[i];
                    clientConnCounter.CategoryName = "XBL Connection Svc";
                    clientConnCounter.CounterName = "Total Subscriptions";
                    clientConnCounter.InstanceName = "_total_";
                    sumSubsAfter = sumSubsAfter + clientConnCounter.RawValue;
                }

                Assert.IsTrue(sumSubsAfter == sumSubsBefore , "All subscriptions are gone. Before: " + sumSubsBefore + " After: " + sumSubsAfter);

            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Ignore("Not implemented.")]
        public class ChangeServerContinuePlaying : TestBase
        {
            //same step as single bvt but then continue using that user's new connection.
            //required more than 1 functional connection servers.
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SameUseronOneConnection : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                //Create Live user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;

                //connect twice
                CONNECT_REPLY reply = connection.Connect(new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[0].UserId });
                if ((uint)reply.hr != HResult.E_INVALIDARG)
                    ResultCode = TEST_RESULTS.FAILED;

                Thread.Sleep(1000);

                //Verify connection.
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                Assert.IsTrue(false == XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 1), "Connection.Connected");

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameUserOnTwoConnectionDifferentXbox : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;
                PNConnection connection2 = null;

                //Create Live user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                //Verify connection that both are connected
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected Index0");
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "Connection.Connected Index1");

                //Query both users one by one to see that they are in there.
                string xmgmtcoutput = string.Empty;
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[0].UserId.ToString(), out xmgmtcoutput);
                Assert.IsTrue(xmgmtcoutput.Contains(String.Format("{0:X}", users[0].UserId)), "Both user found in xmgmt string.");
                Assert.IsTrue(xmgmtcoutput.Contains(String.Format("{0:X}", users[1].UserId)), "Both user found in xmgmt string.");
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[1].UserId.ToString(), out xmgmtcoutput);
                Assert.IsTrue(xmgmtcoutput.Contains(String.Format("{0:X}", users[0].UserId)), "Both user found in xmgmt string.");
                Assert.IsTrue(xmgmtcoutput.Contains(String.Format("{0:X}", users[1].UserId)), "Both user found in xmgmt string.");

                //Change xbox for one user
                PNXbox xbox = new PNXbox(true);
                users[0].Xbox = xbox;
                users[0].Reconnect();
                connection2 = users[0].Xbox.ConnectionServerConnection;

                //Verify connection.
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[0].UserId.ToString(), out xmgmtcoutput);
                Assert.IsTrue(true == xmgmtcoutput.Contains(String.Format("{0:X}", users[0].UserId)), "User0 found on this connection.");
                Assert.IsTrue(false == xmgmtcoutput.Contains(String.Format("{0:X}", users[1].UserId)), "User1 not found on this connection.");
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[1].UserId.ToString(), out xmgmtcoutput);
                Assert.IsTrue(true == xmgmtcoutput.Contains(String.Format("{0:X}", users[1].UserId)), "User1 found on this connection.");
                Assert.IsTrue(false == xmgmtcoutput.Contains(String.Format("{0:X}", users[0].UserId)), "User0 not found on this connection.");
                
                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameUserOnTwoConnectionSameXbox : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;
                PNConnection connection2 = null;

                //Create Live user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                //Verify connection that both are connected
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected Index0");
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "Connection.Connected Index1");

                //Query both users one by one to see that they are in there.
                string xmgmtcoutput = string.Empty;
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[0].UserId.ToString(), out xmgmtcoutput);
                Assert.IsTrue(xmgmtcoutput.Contains(String.Format("{0:X}", users[0].UserId)), "Both user found in xmgmt string.");
                Assert.IsTrue(xmgmtcoutput.Contains(String.Format("{0:X}", users[1].UserId)), "Both user found in xmgmt string.");
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[1].UserId.ToString(), out xmgmtcoutput);
                Assert.IsTrue(xmgmtcoutput.Contains(String.Format("{0:X}", users[0].UserId)), "Both user found in xmgmt string.");
                Assert.IsTrue(xmgmtcoutput.Contains(String.Format("{0:X}", users[1].UserId)), "Both user found in xmgmt string.");

                //connect again on same xbox but new connection
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection2, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                //Verify connection.
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(users[0].UserId, 0), "Connection.Connected");
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[0].UserId.ToString(), out xmgmtcoutput);
                Assert.IsTrue(true == xmgmtcoutput.Contains(String.Format("{0:X}", users[0].UserId)), "User0 found on this connection.");
                Assert.IsTrue(false == xmgmtcoutput.Contains(String.Format("{0:X}", users[1].UserId)), "User1 not found on this connection.");
                ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv showuser " + users[1].UserId.ToString(), out xmgmtcoutput);
                Assert.IsTrue(true == xmgmtcoutput.Contains(String.Format("{0:X}", users[1].UserId)), "User1 found on this connection.");
                Assert.IsTrue(false == xmgmtcoutput.Contains(String.Format("{0:X}", users[0].UserId)), "User0 not found on this connection.");

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncSubscribeNeg.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Diagnostics;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Negative Tests for Subscribe
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncSubscribe_NegativeCases : TestNode
    {
        /// <summary>
        /// Creates a subscription for a single user to an invalid XUID
        /// 
        /// NOTE: It is currently valid to make a subscription to an invalid XUID
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SubscribeInvalidXUID : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscriptions with invalid XUID
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscription_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Friends);

                connection.Unsubscribe(subscription);
                connection.Unsubscribe(subscription_rich);

                subscription[0].qwOwnerXUID = 0; // INVALID?

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Should we have any subscriptions?
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);

                if (user0_basic_subscriptions.Length != subscription.Length)
                {
                    Global.RO.Error("The number of subscriptions was not expected.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a subscription for a single user to an invalid Data Type
        /// 
        /// NOTE: It is currently valid to make a subscription to an invalid Data Type
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SubscribeInvalidDataType : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription with an invalid DataType
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                subscription[0].wDataType = SubNotiDefs.MAX_DATA_TYPE + 1; // INVALID

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Should we have any subscriptions??
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, SubNotiDefs.MAX_DATA_TYPE + 1);

                if (user0_basic_subscriptions.Length != subscription.Length)
                {
                    Global.RO.Error("The number of subscriptions was not expected.");
                    ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a subscription for a single user, although the subscription length is 0 and contains nothing
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SubscribeTo0DataObjects : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription with an invalid DataType
                DATA_OBJECT_SPECIFIER[] subscriptions = new DATA_OBJECT_SPECIFIER[0];

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a single user and sends 2 identical subscriptions at the same time
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SubscribeMultipleSame : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription array with 2 of the same item in it
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] basic_subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                DATA_OBJECT_SPECIFIER[] subscriptions = new DATA_OBJECT_SPECIFIER[2];
                subscriptions[0] = basic_subscription[0];
                subscriptions[1] = basic_subscription[0];

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions);

                //verify
                Assert.IsTrue(subscribeReply.dwNumDataObjects == 1, "Reply num objects should have same length as request");
                Assert.IsTrue(subscribeReply.rgDataObjects.Length == 1, "Reply should have same length as request");
                Assert.IsTrue(subscriptions[0].wDataType == subscribeReply.rgDataObjects[0].wDataType, "Data type should be the same in response");
                Assert.IsTrue(subscriptions[0].qwOwnerXUID == subscribeReply.rgDataObjects[0].qwOwnerXUID, "OwnerXuid should be same.");
                Assert.IsTrue(XConnSrvTestHelpers.IsUserSubscribedTo(users[0].UserId, subscriptions[0].qwOwnerXUID, (DATA_TYPES)subscriptions[0].wDataType), "Subscribed.");

                // Verify that there is only 1 subscription
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);

                if (user0_basic_subscriptions.Length != 1)
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a user with a single subscription, but tries to unsubscribe from something not subscribed to
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class UnsubscribeFromNotSubscribed : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Friends = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Friends);

                // Create unsubscription
                PNUsersBuilder builderUnsubscribe = new PNUsersBuilder();
                builderUnsubscribe.Online_Friends = 1;
                builderUnsubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] unsubscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderUnsubscribe.Friends);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(unsubscription);

                // S_OK is expected
                if (HResult.Failed((uint)unsubscribeReply.hr))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify correct unsubscriptions
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscription, unsubscribeReply);

                // Verify existing subscription is still valid (length 1, correct user id)
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);

                if (user0_basic_subscriptions.Length != 1)
                {
                    Global.RO.Error("Subscriptions length is not 1.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    if (user0_basic_subscriptions[0] != subscription[0].qwOwnerXUID)
                    {
                        Global.RO.Error("Owner XUID is not correct.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a user with a single subscription and tries to unsubscribe from it with an invalid XUID
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class UnsubscribeInvalidXUID : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Peers = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Peers);
                DATA_OBJECT_SPECIFIER[] subscription_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builderSubscribe.Peers);

                // Create unsubscription (invalid XUID)
                PNUsersBuilder builderUnsubscribe = new PNUsersBuilder();
                builderUnsubscribe.Online_Peers = 1;
                builderUnsubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] unsubscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Peers);
                DATA_OBJECT_SPECIFIER[] unsubscriptio_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builderSubscribe.Peers);
                unsubscription[0].qwOwnerXUID = 0; // INVALID?

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(unsubscription);

                // S_OK is expected
                if (HResult.Failed((uint)unsubscribeReply.hr))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify correct unsubscriptions
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscription, unsubscribeReply);

                // Verify existing subscription for user 0 still valid
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                if (user0_basic_subscriptions.Length != 1)
                    ResultCode = TEST_RESULTS.FAILED;
                else
                {
                    if (user0_basic_subscriptions[0] != subscription[0].qwOwnerXUID)
                    {
                        Global.RO.Error("Owner XUID is not correct.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a user with a single subscription and tries to unsubscribe from it with an invalid Data Type
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class UnsubscribeInvalidDataType : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Peers = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Peers);
                DATA_OBJECT_SPECIFIER[] subscription_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builderSubscribe.Peers);

                // Create unsubscription (invalid data type)
                PNUsersBuilder builderUnsubscribe = new PNUsersBuilder();
                builderUnsubscribe.Online_Peers = 1;
                builderUnsubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] unsubscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Peers);
                unsubscription[0].wDataType = SubNotiDefs.MAX_DATA_TYPE + 1; // INVALID

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(unsubscription);

                // S_OK is expected
                if (HResult.Failed((uint)unsubscribeReply.hr))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify correct unsubscriptions
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscription, unsubscribeReply);

                // Verify existing subscription for user 0 still valid
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                if (user0_basic_subscriptions.Length != 1)
                    ResultCode = TEST_RESULTS.FAILED;
                else
                {
                    if (user0_basic_subscriptions[0] != subscription[0].qwOwnerXUID)
                    {
                        Global.RO.Error("Owner XUID is not correct.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a user with a single subscription and attempts to unsubscribe from 0 items
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class UnsubscribeFrom0DataObjects : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Friends = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Friends);

                // Create unsubscription
                DATA_OBJECT_SPECIFIER[] unsubscription = new DATA_OBJECT_SPECIFIER[0];

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(unsubscription);

                // S_OK is expected
                if (HResult.Failed((uint)unsubscribeReply.hr))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify correct unsubscriptions
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscription, unsubscribeReply);

                // Verify existing subscription for user 0 still valid
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                if (user0_basic_subscriptions.Length != 1)
                    ResultCode = TEST_RESULTS.FAILED;
                else
                {
                    if (user0_basic_subscriptions[0] != subscription[0].qwOwnerXUID)
                    {
                        Global.RO.Error("Owner XUID is not correct.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a single user with a single subscription and then sends 2 indentical unsubscriptions at the same time
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class UnsubscribeMultipleSame : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Friends = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Friends);

                // Create unsubscriptions
                DATA_OBJECT_SPECIFIER[] unsubscriptions = new DATA_OBJECT_SPECIFIER[2];
                unsubscriptions[0] = subscription[0];
                unsubscriptions[1] = subscription[0];

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(unsubscriptions);

                // S_OK is expected
                if (HResult.Failed((uint)unsubscribeReply.hr))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify correct unsubscriptions
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscription, unsubscribeReply);

                // Verify user 0 has 0 subscriptions
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);

                if (user0_basic_subscriptions.Length != 0)
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates 2 users with different subscriptions on the same xbox and user 1 attempts to unsubscribe from
        /// subscriptions only user 0 is subscribed to
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class UnsubscribeIncorrectUserId : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription for user 0
                PNUsersBuilder builderSubscribe0 = new PNUsersBuilder();
                builderSubscribe0.Online_Peers = 1;
                builderSubscribe0.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription_user0 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe0.Peers);

                // Create a subscription for user 1
                PNUsersBuilder builderSubscribe1 = new PNUsersBuilder();
                builderSubscribe1.Online_Peers = 1;
                builderSubscribe1.CreateUsers(users[1]);
                DATA_OBJECT_SPECIFIER[] subscription_user1 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe1.Peers);

                // Subscribe user 0
                SUBSCRIBE_REPLY subscribeReply_user0 = connection.Subscribe(subscription_user0, new int[] { 0 });
                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription_user0, subscribeReply_user0))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe user 1
                SUBSCRIBE_REPLY subscribeReply_user1 = connection.Subscribe(subscription_user1, new int[] { 1 });
                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscription_user1, subscribeReply_user1))
                    ResultCode = TEST_RESULTS.FAILED;

                // Now try to have user 1 unsubscribe from user 0's subscriptions
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscription_user0, new int[] { 1 });

                // S_OK is expected
                if (HResult.Failed((uint)unsubscribeReply.hr))
                    ResultCode = TEST_RESULTS.FAILED;
                
                // Verify existing subscription for user 0 still valid
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                if (user0_basic_subscriptions.Length != subscription_user0.Length)
                    ResultCode = TEST_RESULTS.FAILED;
                else
                {
                    if (user0_basic_subscriptions[0] != subscription_user0[0].qwOwnerXUID)
                    {
                        Global.RO.Error("Owner XUID is not correct.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Verify existing subscription for user 1 still valid
                ulong[] user1_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                if (user1_basic_subscriptions.Length != subscription_user1.Length)
                    ResultCode = TEST_RESULTS.FAILED;
                else
                {
                    if (user1_basic_subscriptions[0] != subscription_user1[0].qwOwnerXUID)
                    {
                        Global.RO.Error("Owner XUID is not correct.");
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates 3 users, 2 of which are subscribed to the same thing, and attempts to unsubscribe all 3 from it
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class PartialSubscriptionFullUnsubscription : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(3, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                int[] userIndices = new int[3];
                ulong[] userIds = new ulong[3];

                for (int j = 0; j < 3; ++j)
                {
                    userIndices[j] = j;
                    userIds[j] = users[j].UserId;
                }

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription for users 0 and 1
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Friends = 1;
                builderSubscribe.CreateUsers(new PNUser[] { users[0], users[1] });
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Friends);

                // Subscribe users 0 and 1
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription, new int[] { 0, 1 });

                // Verify expected data in reply is correct
                for (int j = 0; j < 2; ++j)
                {
                    if (!XConnSrvTestHelpers.VerifySubscription(users[j].UserId, subscription, subscribeReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Now try to unsubscribe from that data for everyone (user 2 hasn't subscribed to it)
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscription);

                // S_OK is expected
                if (HResult.Failed((uint)unsubscribeReply.hr))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify correct unsubscriptions
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscription, unsubscribeReply);
                XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscription, unsubscribeReply);
                
                // Verify there are no subscriptions left for users 0 and 1
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                if (user0_basic_subscriptions.Length != 0)
                    ResultCode = TEST_RESULTS.FAILED;

                ulong[] user1_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                if (user1_basic_subscriptions.Length != 0)
                    ResultCode = TEST_RESULTS.FAILED;

                // Confirm user 2 still has 0 subscriptions
                ulong[] user2_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[2].UserId, DATA_TYPES.eBasicPresence);
                if (user2_basic_subscriptions.Length != 0)
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a user and subscribes to the same thing 3 times, then attempts to unsubscribe from it 3 times
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SubscribeUnsubscribeMultipleTimes : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Friends = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Friends);

                for (int i = 0; i < 3; ++i)
                {
                    // Subscribe
                    SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);

                    // Verify expected data in reply is correct
                    if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                        ResultCode = TEST_RESULTS.FAILED;

                    // Confirm there is always just 1 subscription
                    ulong[] user2_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                    if (user2_basic_subscriptions.Length != subscription.Length)
                        ResultCode = TEST_RESULTS.FAILED;
                }

                for (int i = 0; i < 3; ++i)
                {
                    UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscription);

                    // S_OK is expected
                    if (HResult.Failed((uint)unsubscribeReply.hr))
                        ResultCode = TEST_RESULTS.FAILED;

                    // Verify correct unsubscriptions
                    XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscription, unsubscribeReply);

                    // Confirm there are always no subscriptions
                    ulong[] user2_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                    if (user2_basic_subscriptions.Length != 0)
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Sends the subscribe message before sending the connect message
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SubscribeBeforeConnect : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);

                PNConnection connection = new PNConnection(users[0].Xbox.XboxId);

                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Friends = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Friends);

                try
                {
                    SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (Exception /*e*/)
                {
                    // Timeout expected
                }

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Sends the unsubscribe message before sending the connect message
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class UnsubscribeBeforeConnect : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);

                PNConnection connection = new PNConnection(users[0].Xbox.XboxId);

                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Friends = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Friends);

                try
                {
                    UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscription);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (Exception /*e*/)
                {
                    // Timeout expected
                }

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(0)]
        public class SubscribeMaxObjectsPerMessagePlusOne : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint maxObjectPerMessage = uint.Parse(Global.XEnv.GetSetting("XConnSrv_MaxObjectsPerMessage"));

                PNConnection connection = null;
                PNUser testuser = PNUsersBuilder.GetLiveXenonUsers(1, true, false)[0];
                connection = testuser.Xbox.ConnectionServerConnection;

                // Connect users
                Assert.IsTrue(XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { testuser.UserId }, testuser.Xbox.XboxId));

                //create 1000 users
                PNUser[] bulkusers = PNUsersBuilder.GetLiveXenonUsers(maxObjectPerMessage + 1, true, false);

                DATA_OBJECT_SPECIFIER[] basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, bulkusers);
                DATA_OBJECT_SPECIFIER[] rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, bulkusers);

                SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basic, new int[] { 0 });
                Assert.IsTrue((uint)basicSubscribeReply.hr == HResult.E_INVALIDARG, "Invalid Argument");

                SUBSCRIBE_REPLY richSubscribeReply = connection.Subscribe(rich, new int[] { 0 });
                Assert.IsTrue((uint)richSubscribeReply.hr == HResult.E_INVALIDARG);
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(0)]
        public class SubscribeMaxSubPerConnectionPlusOne : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint maxSubsPerConnection = uint.Parse(Global.XEnv.GetSetting("XConnSrv_MaxSubscriptionsPerConnection"));

                PNConnection connection = null;
                PNUser testuser = PNUsersBuilder.GetLiveXenonUsers(1, true, false)[0];
                connection = testuser.Xbox.ConnectionServerConnection;

                // Connect users
                Assert.IsTrue(XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { testuser.UserId }, testuser.Xbox.XboxId));
                int total = 0;
                uint increment = 100;
                while (total < maxSubsPerConnection)
                {
                    total = (int)(total + increment);
                    PNUser[] bulkusers = PNUsersBuilder.GetLiveXenonUsers(increment, true, false);
                    DATA_OBJECT_SPECIFIER[] basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, bulkusers);
                    SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basic, new int[] { 0 });
                    Assert.IsTrue(basicSubscribeReply.hr == HResult.S_OK, "Subscribe successful");
                    Assert.IsTrue(basicSubscribeReply.rgDataObjects.Length == increment, "basicSubscribeReply.rgDataObjects.Length: " + basicSubscribeReply.rgDataObjects.Length + " --- increment: " + increment);
                    Global.RO.Info("Subscribed to " + total.ToString());
                }

                PNUser[] onemore = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                DATA_OBJECT_SPECIFIER[] basicplus1 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, onemore);
                SUBSCRIBE_REPLY basicSubscribeReplyplus1 = connection.Subscribe(basicplus1, new int[] { 0 });
                Assert.IsTrue((uint)basicSubscribeReplyplus1.hr == HResult.E_INVALIDARG, "Invalid Argument");
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SubscribeWithoutConnectedUser : TestBase
        {
            protected override void Execute()
            {
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                PNConnection conn = users[0].Xbox.ConnectionServerConnection;
                
                // Create a subscription
                PNUsersBuilder builderSubscribe = new PNUsersBuilder();
                builderSubscribe.Online_Friends = 1;
                builderSubscribe.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builderSubscribe.Friends);
                DATA_OBJECT_SPECIFIER[] subscription_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builderSubscribe.Friends);

                //connect without any user.
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref conn, HResult.S_OK, new int[] { }, new ulong[] { }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                //This should throw.
                try
                {
                    SUBSCRIBE_REPLY subscribeReply = conn.Subscribe(subscription);

                    Global.RO.Error("Subscribe should have thrown an exception.");
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (Exception)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncLanguageSpecific.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using xonline.common.community;


//using ServerTestFramework.LiveService.FakeSG;
//using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.GI;


using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Language Specific blobs in Velocity.
    /// 
    /// Random Rich Presence for your clairification pleasure:
    /// 
    /// console language = 1
    /// user language = 2
    ///
    /// Order of precedence:
    /// 1) Language 1, Country Code
    /// 2) Language 1, Default Country for Language 1
    /// 3) Language 2, Country Code (if L2 != L1)
    /// 4) Language 2, Default County for Language 2 (if L2 != L1)
    /// 5) Default Language for Country Code, Country Code
    ///
    /// "de-DE" = GERMAN
    /// "en-US" = ENGLISH
    /// "es-ES" = SPANISH
    /// "fr-FR" = FRENCH
    /// "it-IT" = ITALIAN
    /// "ja-JP" = JAPANESE
    /// "ko-KR" = KOREAN
    /// "pl-PL" = POLISH
    /// "pt-PT" = PORTUGUESE
    /// "ru-RU" = RUSSIAN
    /// "zh-TW" = TRADITIONAL CHINESE
    /// "zh-CHT" = TRADITIONAL CHINESE (Testing only?)
    /// "zh-CN" = SIMPLIFIED CHINESE
    /// "zh-CHS" = SIMPLIFIED CHINESE (Testing only?)
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(3)]
    public class FuncLanguageSpecific_PositiveCases : TestNode
    {
        /// <summary>
        /// BVT Test Case for Rich Presence blob, uses step #1
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVT_UseLanguage1AndCountryCode : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.EN;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.EN;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.US;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["en-US"];

                System.Threading.Thread.Sleep(2000);

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Create expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// The pair of Language 1 + Country Code does not give a valid locale, so it goes to step #2 and gets the default
        /// country code for Language 1, which is ES, thus getting es-ES
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class DefaultToLanguage1sCountryCode : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.ES;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.EN;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.US;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["es-ES"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Steps #1 and #2 are not valid, so it goes to step #3 and uses Language 2 and Country code, this getting fr-FR
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class DefaultToLanguage2AndCountryCode : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.FR;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.FR;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["fr-FR"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Steps #1, #2, and #3 are not valid, so it goes to step #4 and uses the default country for Language 2, which is
        /// PL, thus getting pl-PL
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class DefaultToLanguage2sCountryCode : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.PL;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.US;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["pl-PL"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Steps #1, #2, #3, and #4 fail, so it goes to step #5 and uses the default language for the country code, which is
        /// fr, thus getting fr-FR
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class DefaultToCountryCodesLanguageAndCountryCode : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.FR;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["fr-FR"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// All steps fail so it must default to the default rich presence string, which is the first in the list,
        /// which in our case is de-DE
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class DefaultToDefault : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.MX;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["de-DE"]; // Default since it is first in the list

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// All locales in the header are pointing to the same single Rich Presence string in the blob
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class AllLocalesPointingToSameString : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.MX;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                Dictionary<string, string> localesWithStrings = new Dictionary<string, string>()
                {
                    {"en-US", "THIS IS ENGLISH"},
                    {"de-DE", "THIS IS ENGLISH"},
                    {"ru-RU", "THIS IS ENGLISH"},
                    {"zh-CN", "THIS IS ENGLISH"}
                };

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(localesWithStrings, subscribee.UserId);

                string expectedRichPresString = localesWithStrings["ru-RU"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Uses the last locale in the TOC
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class UseLastLanguage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.EN;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.CN;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["zh-CN"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users are logged onto a single xbox and they each have different language settings. One user has
        /// unsupported languages and country and would default to the default string, and the other has an unsupported language 1
        /// but a supported language 2. They both subscribe to the same user and the expectation is to get the 2nd
        /// user's string.
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class TwoUsersSameConsoleDifferentLanguages : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] subscribers = PNUsersBuilder.GetLiveXenonUsers(2, true, true);

                PNUser[] users2 = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                PNUser subscribee = users2[0];

                // Set subscriber region values
                subscribers[0].Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscribers[0].LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscribers[0].CountryId = (byte)PresenceTitleConfig.CountryId.MX;

                subscribers[1].LanguageId = (byte)PresenceTitleConfig.LanguageId.EN;
                subscribers[1].CountryId = (byte)PresenceTitleConfig.CountryId.MX;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { subscribers[0].UserId, subscribers[1].UserId }, subscribers[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["en-US"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0, 1 });

                if (!XConnSrvTestHelpers.VerifySubscription(subscribers[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(subscribers[1].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 1, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users are logged onto a single xbox and they each have different language settings. User1 has de-DE (default)
        /// available as a step #3, and user0 has en-CA, which should default to en-US in step #2. We expect en-US since even
        /// though user1 has an earlier locale, the server loops through the user's locale's first, and user0 is at the top so
        /// it will use en-US.
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class TwoUsersSameConsoleMixedSettings : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] subscribers = PNUsersBuilder.GetLiveXenonUsers(2, true, true);

                PNUser[] users2 = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                PNUser subscribee = users2[0];

                // Set subscriber region values
                subscribers[0].Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.EN;
                subscribers[0].LanguageId = (byte)PresenceTitleConfig.LanguageId.ZH;
                subscribers[0].CountryId = (byte)PresenceTitleConfig.CountryId.CA;

                subscribers[1].LanguageId = (byte)PresenceTitleConfig.LanguageId.DE;
                subscribers[1].CountryId = (byte)PresenceTitleConfig.CountryId.DE;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { subscribers[0].UserId, subscribers[1].UserId }, subscribers[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.BuildAndInsertRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["en-US"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)((expectedRichPresString.Length + 1) * 2 + sizeof(BASE_DATA_HEADER)); // The +1 is because there is a seperator byte at the beginning. Why???
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                System.Threading.Thread.Sleep(2000);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0, 1 });

                if (!XConnSrvTestHelpers.VerifySubscription(subscribers[0].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(subscribers[1].UserId, richSubscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                XConnSrvTestHelpers.SendNotifications(richSubscription);

                // Created expected DOS
                DATA_OBJECT_SPECIFIER[] expectedDOS = XConnSrvTestHelpers.CreateExpectedRichPresenceDOS(richSubscription[0], expectedRichPresString);

                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 0, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, expectedDOS[0], 1, 5, expectedRichPresString))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify the corrent number of notifications were received
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, (uint)expectedDOS.Length))
                //    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// This will manually change one offset to be out of range of the blob
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class OffsetOutOfRange : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                PNUser subscriber = users[0];
                PNUser subscribee = users[1];

                // Set subscriber region values
                subscriber.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.EN;
                subscriber.LanguageId = (byte)PresenceTitleConfig.LanguageId.EN;
                subscriber.CountryId = (byte)PresenceTitleConfig.CountryId.US;

                // Connecton user index 0
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                byte[] dataBlob = XConnSrvTestHelpers.BuildRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, subscribee.UserId);

                unsafe
                {
                    // Get a pointer to the english entry (it is 2nd) to change its offset
                    fixed(byte* englishBytes = &dataBlob[sizeof(PER_LANGUAGE_TOC) + sizeof(LANGUAGE_TOC_ENTRY)])
                    {
                        LANGUAGE_TOC_ENTRY* englishEntry = (LANGUAGE_TOC_ENTRY*)englishBytes;
                        englishEntry->wOffset = (ushort)dataBlob.Length; // Put the offset outside the range of the array
                    }
                }

                string expectedRichPresString = XConnSrvTestHelpers.defaultLocales["en-US"];

                // Create subscription
                DATA_OBJECT_SPECIFIER[] richSubscription = new DATA_OBJECT_SPECIFIER[1];
                unsafe
                {
                    richSubscription[0].wObjectSize = (ushort)(dataBlob.Length + sizeof(BASE_DATA_HEADER));
                }
                richSubscription[0].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                richSubscription[0].dwDataSubType = 0;
                richSubscription[0].qwOwnerXUID = subscribee.UserId;

                // Insert into Velocity
                XConnSrvMemCache.InsertDataObject(richSubscription[0], dataBlob,
                    CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | CacheUtil.XONLINE_CACHE_DATA_FLAG_LANGUAGE_SPECIFIC);

                System.Threading.Thread.Sleep(2000);

                // Subscribe - expect a timeout
                try
                {
                    SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });
                }
                catch (Exception /*e*/)
                {
                    //Expect to catch the timeout
                    Global.RO.Info("Timeout exception caught.");
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// This test inserts real Rich Presence data through the Presence FD using SetTitleData with a GIBlob for Pong
        /// and checks the returned string for accuracy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class RichPresenceBySetTitleData : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription DOS for desired user type
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Offline_Peers = 1;
                builder.CreateUsers(users[0]); 
                DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Peers);
                DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Peers);

                richsub[0].wObjectSize = 100; // Expected size for rich presence string

                // Size change for rich presence subscription reply since initial logon creates a rich presence reply the sizeof(BASE_DATA_HEADER)
                DATA_OBJECT_SPECIFIER richsubSubReply = richsub[0];
                unsafe
                {
                    richsubSubReply.wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
                }

                DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
                Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
                Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

                PNUser subscribee = builder.Peers[0];

                FriendsCommon fc = new FriendsCommon();
                fc.LogonUser(subscribee, Pong.TitleId);

                // Subscribe to basic and rich presence
                SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                    Assert.IsTrue(false, "Subscription to basic presence failed.");

                SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, new DATA_OBJECT_SPECIFIER[] { richsubSubReply }, subscribeReplyRich))
                    Assert.IsTrue(false, "Subscription to rich presence failed.");

                // Verify privacy in header
                if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyBasic, 0))
                    Assert.IsTrue(false, "Basic Presence subscription reply header privacy is invalid.");

                if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyRich, 0))
                    Assert.IsTrue(false, "Rich Presence subscription reply header privacy is invalid.");
                
                // Make friends so that notifications can be sent
                fc.RequestFriend(users[0], subscribee);
                fc.AcceptFriend(subscribee, users[0]);

                Thread.Sleep(3000);
                connection.ClearNotificationRecievedList();

                // Update state and rich presence via SetTitleData to trigger notifications
                XConnSrvTestHelpers.SetTitleData(subscribee);

                Thread.Sleep(3000);

                // Verify the corrent number of notifications were received, if we should expect any
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 2, 2))
                //    Assert.IsTrue(false, "Incorrect number of notifications received.");

                SUBSCRIPTION_DATA subData = connection.GetNotification(richsub[0], false);

                if (!XConnSrvTestHelpers.VerifyRichPresString(subData.data, "Single Player: Medium paddle, Fast ball"))
                    Assert.IsTrue(false, "Rich Presence string returned does not match the expected string.");

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    Assert.IsTrue(false, "Disconnect failed.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\XConnSrvMemCache.cs ===
using System;
using System.Xml;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace XConnSrvTest
{
	public class XConnSrvMemCache
	{
        private static bool s_fInitialized = false;

		public static void Initialize()
		{
            if (!s_fInitialized)
            {
                lock (typeof(XConnSrvMemCache))
                {
                    if (!s_fInitialized)
                    {
                        MCServerNetwork.Initialize();
                        s_fInitialized = true;
                    }
                }
            }
		}

        private static string GenerateKey(DATA_OBJECT_SPECIFIER dataObject)
        {
            return CacheUtil.GetDataKeyString(dataObject);
        }
        public static void InsertDataObject(DATA_OBJECT_SPECIFIER dataObject, byte[] data)
        {
            InsertDataObject(dataObject, data, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);
        }
        public static void InsertDataObject(DATA_OBJECT_SPECIFIER dataObject, byte[] data, int privacySetting)
        {
            byte[] actualData = null;
            if (data != null)
            {
                unsafe
                {
                    actualData = new byte[sizeof(BASE_DATA_HEADER) + data.Length];
                    fixed (byte* pActualData = &actualData[0])
                    {
                        BASE_DATA_HEADER* pHeader = (BASE_DATA_HEADER*)pActualData;
                        pHeader->doSpec = dataObject;
                        pHeader->dwHeaderFlags = (uint)privacySetting;
                    }
                    data.CopyTo(actualData, sizeof(BASE_DATA_HEADER));
                }
            }

            string dataKeyString = GenerateKey(dataObject);

            MCServerNetwork._memCache.Set(dataKeyString, actualData);

            // Generate a notification when we set new data in case of fakemc since it doesn't do it automatically.
            if (MCServerNetwork._memCache.GetType() == typeof(FakeMemCache))
            {
                MCNotificationResponse response = new MCNotificationResponse(new string[] { dataKeyString });
                MCServerNetwork.Notify(response);
            }

            //Global.RO.Info("Data inserted into MemCache");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\XConnSrvStress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.service;
using xonline.common.protocol;

namespace XConnSrvTest
{
    [StressInstantiate, StressTest]
    public class Logon : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                bool reconnect = false;

                // We first attempt to get a user who has been disconnected somehow and needs to reconnect
                user = StressUserList.GetReconnect();
                if (user == null)
                    user = StressUserList.GetOffline();
                else
                    reconnect = true;

                if (user != null)
                {
                    if (reconnect == false)
                        user.Connect();
                    else
                    {
                        Global.RO.Warn("Reconnecting disconnected user...");
                        user.Reconnect();
                    }
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch(Exception e)
            {
                Global.RO.Error("Logon exception caught:\n" + e.Message);

                if (user != null)
                {
                    // Disconnect will return the user
                    user.Disconnect();
                }
            }
        }
    }

    [StressInstantiate, StressTest]
    public class Reconnect : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnline();
                if (user != null)
                {
                    user.Reconnect();
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Reconnect exception caught:\n" + e.Message);

                if (user != null)
                {
                    // Disconnect will return the user
                    user.Disconnect();
                }
            }
        }
    }



    [StressInstantiate, StressTest]
    public class Logoff : TestBase
    {
        protected override void Execute()
        {
            StressUser user = StressUserList.GetOnline();
            if (user != null)
            {
                user.Disconnect();
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
            }
        }
    }

    [StressInstantiate, StressTest]
    public class Publish : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnline();
                if (user != null && user.IsConnected)
                {
                    user.Publish();
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Subscribe exception caught:\n" + e.Message);
            }
            finally
            {
            }
        }
    }


    [StressInstantiate, StressTest]
    public class Subscribe : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnline();
                if (user != null && user.IsConnected)
                {
                    user.Subscribe();
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Subscribe exception caught:\n" + e.Message);
            }
            finally
            {
            }
        }
    }

    [StressInstantiate, StressTest]
    public class Unsubscribe : TestBase
    {
        protected override void Execute()
        {
            ResultCode = TEST_RESULTS.NOT_EXECUTED;

            StressUser user = StressUserList.GetOnlineSubscribed();
            if (user != null)
            {
                if (user.SubscriptionCount > 0 && user.IsConnected)
                {
                    user.Unsubscribe();
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    user.Return();
                }
            }
        }
    }

    [StressInstantiate, StressTest]
    public class ChangeState : TestBase
    {
        private static int _index = 0;

        //private static Random _rand = new Random();

        protected override void Execute()
        {
            ulong userId = 0;

            lock (this)
            {
                userId = StressUser._changeStateBasePuid + (ulong)_index;
                _index = (_index + 1) % StressUser._changeStatePuidCount;
            }

            //userId = StressUser._changeStateBasePuid + (ulong)_rand.Next(StressUser._changeStatePuidCount);

            try
            {
                if (userId != 0)
                {
                    StressUser.InsertBasicPresenceIntoCache(userId);
                    StressUser.InsertRichPresenceIntoCache(userId);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("ChangeState exception caught:\n" + e.Message);
                ResultCode = TEST_RESULTS.FAILED;
            }
            finally
            {
            }
        }
    }

    [StressInstantiate, StressTest]
    public class MessageTimeOutHeartbeat : TestBase
    {
        protected override void Execute()
        {
            StressConnSrvMessageQueue.TimeOut();

            ResultCode = TEST_RESULTS.PASSED;
        }
    }

    [StressInstantiate, StressTest]
    public class StressInfoDump : TestBase
    {
        protected override void Execute()
        {
            ResultCode = TEST_RESULTS.NOT_EXECUTED;

            Global.RO.Info("\nOffline Queue Size: {0}\nReconnect Queue Size: {1}\nOnline Queue Size: {2}\nOnline+Subscriptions Queue Size: {3}",
                           new object[] { StressUserList.OfflineCount(),
                                          StressUserList.ReconnectCount(),
                                          StressUserList.OnlineCount(),
                                          StressUserList.OnlineSubscribedCount() });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncPrivacy.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

using System.Runtime.InteropServices;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Privacy.
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(3)]
    public class FuncPrivacy_PositiveCases : TestNode
    {
        /// <summary>
        /// BVT Test for Privacy 
        /// </summary>
        [TestCase]
        public class BVT_Privacy : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription DOS for desired user type
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Offline_Friends = 1;
                builder.Offline_Peers_SameConsole_PrivBlocked = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, new PNUser[] { builder.Friends[0], builder.Peers[0] });
                DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, new PNUser[] { builder.Friends[0], builder.Peers[0] });

                //// Size change for rich presence since initial logon creates a rich presence reply the sizeof(BASE_DATA_HEADER)
                //unsafe
                //{
                //    richsub[0].wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
                //}

                DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
                Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
                Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

                PNUser openFriend = builder.Friends[0];
                PNUser blockedPeer = builder.Peers[0];

                // Clear out any notifications we may have received
                System.Threading.Thread.Sleep(1000);
                connection.ClearNotificationRecievedList();

                // Logon user so that rich presence blobs are inserted with the correct privacy flags
                FriendsCommon fc = new FriendsCommon();
                fc.LogonUser(openFriend);
                fc.LogonUser(blockedPeer);

                Thread.Sleep(2000);

                // Subscribe to basic and rich presence
                SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                    Assert.IsTrue(false, "Subscription to basic presence failed.");

                SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich))
                    Assert.IsTrue(false, "Subscription to rich presence failed.");

                // Verify privacy in header
                if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyBasic, 0))
                    Assert.IsTrue(false, "Basic Presence subscription reply header privacy is invalid.");

                if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyRich, 0))
                    Assert.IsTrue(false, "Rich Presence subscription reply header privacy is invalid.");


                // Verify the corrent number of notifications were received, if we should expect any
                if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 3))
                    Assert.IsTrue(false, "Incorrect number of notifications received.");

                ///////////////////////////////////// TODOOOOOOOOOOOOOOOOOOOOOOOOOOO
                //if (!connection.VerifyNotificationPrivacy(subscribeePrivacy))
                //    Assert.IsTrue(false, "Incorrect privacy type received.");

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    Assert.IsTrue(false, "Disconnect failed.");

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        static void builder_PNUserCreationEvent(object sender, PNUserCreationEventArgs e)
        {
            XConnSrvTestHelpers.SetTitleData(e.User);
        }

        static void BasicPrivacyNotificationTest(bool friend, int subscribeePrivacy)
        {
            PNConnection connection = null;

            // Create one user.
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscription DOS for desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            //builder.PNUserCreationEvent += new EventHandler<PNUserCreationEventArgs>(builder_PNUserCreationEvent);
            switch (subscribeePrivacy)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    if (friend) builder.Offline_Friends = 1;
                    else builder.Offline_Peers = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    if (friend) builder.Offline_Friends_PrivFriends = 1;
                    else builder.Offline_Peers_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    if (friend) builder.Offline_Friends_PrivBlocked = 1;
                    else builder.Offline_Peers_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users);

            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friend ? builder.Friends : builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, friend ? builder.Friends : builder.Peers);

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = friend ? builder.Friends[0] : builder.Peers[0];
            bool isBlocked = true;
            if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
                isBlocked = false;
            else if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS && friend)
                isBlocked = false;
            
            // Subscribe to basic and rich presence
            SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic, isBlocked))
                Assert.IsTrue(false, "Subscription to basic presence failed.");

            SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich, isBlocked))
                Assert.IsTrue(false, "Subscription to rich presence failed.");

            // If this isn't done, the user will get 1 empty rich presence notification (Bug #136703)
            FriendsCommon fc = new FriendsCommon();
            fc.LogonUser(subscribee);
            fc.LogoffUser(subscribee);

            // Clear out any notifications we may have received
            System.Threading.Thread.Sleep(5000);
            connection.ClearNotificationRecievedList();

            // Log on subscribee so new data is inserted into velocity
            fc.LogonUser(subscribee, Pong.TitleId);

            System.Threading.Thread.Sleep(2000);

            XConnSrvTestHelpers.SetTitleData2(subscribee);

            System.Threading.Thread.Sleep(2000);

            // Verify notifications received
            if (!isBlocked)
            {
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, totalsubs, 0, 5, XConnSrvTestHelpers.RichPresenceString2))
                    Assert.IsTrue(false, "Did not receive notifications as expected.");
            }

            uint expectedNotis = 0;
            // 3 => FriendsCommon.LogonUser calls Alive() which sends 1 basic and 1 rich, and then SetTitleData() which
            // sends 1 basic
            if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
            {
                expectedNotis += 2;
            }
            else if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS)
            {
                if (friend) expectedNotis += 2;
            }

            if (expectedNotis == 0)
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 0, 0), "Received notifications unexpectedly.");
            }
            else
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 10), "Did not receive notifications as expected.");
            }

            if (isBlocked)
            {
                Global.RO.Info("Checking for offline notification...");
                SUBSCRIPTION_DATA sd;
                sd = connection.GetNotification(basicsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
                sd = connection.GetNotification(richsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
            }
            
            if (!XConnSrvTestHelpers.VerifyNotificationPrivacy(connection, subscribeePrivacy))
                Assert.IsTrue(false, "Incorrect privacy type received.");

            //Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        static void BasicPrivacyPendingFriendNotificationTest(int subscribeePrivacy)
        {
            PNConnection connection = null;

            // Create one user.
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscription DOS for desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            switch (subscribeePrivacy)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    builder.Offline_Peers = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    builder.Offline_Peers_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    builder.Offline_Peers_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users[0]);
            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Peers);

            // Size change for rich presence since initial logon creates a rich presence reply the sizeof(BASE_DATA_HEADER)
            //unsafe
            //{
            //    richsub[0].wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
            //}

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = builder.Peers[0];

            // Send friend request
            FriendsCommon fc = new FriendsCommon();
            fc.RequestFriend(users[0], subscribee);

            Thread.Sleep(1000);

            // Subscribe to basic and rich presence
            SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                Assert.IsTrue(false, "Subscription to basic presence failed.");

            SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich))
                Assert.IsTrue(false, "Subscription to rich presence failed.");

            // If this isn't done, the user will get 1 empty rich presence notification (Bug #136703)
            fc.LogonUser(subscribee);
            fc.LogoffUser(subscribee);

            // Clear out any notifications we may have received
            System.Threading.Thread.Sleep(5000);
            connection.ClearNotificationRecievedList();

            // Log on subscribee so new data is inserted into velocity
            fc.LogonUser(subscribee, subscribee.Xbox);

            System.Threading.Thread.Sleep(2000);

            XConnSrvTestHelpers.SetTitleData2(subscribee);

            System.Threading.Thread.Sleep(2000);

            // Pending friend is treated like peer
            bool isBlocked = (subscribeePrivacy == 0) || (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

            // Verify notifications received
            if (!isBlocked)
            {
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, totalsubs, 0, 5, XConnSrvTestHelpers.RichPresenceString2))
                    Assert.IsTrue(false, "Did not receive notifications as expected.");
            }

            // Verify the corrent number of notifications were received, if we should expect any (min of 0, max of 4 (logon * 2, setTitleData * 2)
            if(subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 10), "Did not receive notifications as expected.");
            }
            else
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 0, 0), "Received notifications unexpectedly.");
            }

            if (isBlocked)
            {
                Global.RO.Info("Checking for offline notification...");
                SUBSCRIPTION_DATA sd;
                sd = connection.GetNotification(basicsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
                sd = connection.GetNotification(richsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
            }

            if (!XConnSrvTestHelpers.VerifyNotificationPrivacy(connection, subscribeePrivacy))
                Assert.IsTrue(false, "Incorrect privacy type received.");

            //Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        static void PrivacyChangesNotificationTest(bool friend, int subscribeePrivacyStart, int subscribeePrivacyEnd, bool expectNotification)
        {
            PNConnection connection = null;

            // Create one user.
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscription to desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            switch (subscribeePrivacyStart)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    if (friend) builder.Offline_Friends = 1;
                    else builder.Offline_Peers = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    if (friend) builder.Offline_Friends_PrivFriends = 1;
                    else builder.Offline_Peers_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    if (friend) builder.Offline_Friends_PrivBlocked = 1;
                    else builder.Offline_Peers_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users[0]);
            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friend ? builder.Friends : builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, friend ? builder.Friends : builder.Peers);

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = friend ? builder.Friends[0] : builder.Peers[0];

            // We need to get the blobs into velocity of subscriberPrivacyStart privacy type.
            FriendsCommon fc = new FriendsCommon();
            fc.LogonUser(subscribee, subscribee.Xbox);

            // Sleep to confirm the data is set
            System.Threading.Thread.Sleep(1000);

            // Subscribe to basic and rich presence
            SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                Assert.IsTrue(false, "Subscription to basic presence failed.");

            SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich))
                Assert.IsTrue(false, "Subscription to rich presence failed.");

            XConnSrvTestHelpers.SetTitleData(subscribee);
            Thread.Sleep(5000);

            connection.ClearNotificationRecievedList();

            // Log the user off (notifications for rich + basic removal will be sent with subscriberPrivacyStart)
            fc.LogoffUser(subscribee);
            Thread.Sleep(2000);

            bool isBlockedStart = ((subscribeePrivacyStart == 0) || ((subscribeePrivacyStart == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) && !friend));

            if(isBlockedStart)
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 0, 0), "Received notifications unexpectedly.");
            }
            else
            {
                // We just want to make sure they got at least 1 if they should get any - we cannot be exact with batching
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 10), "Did not receive notifications as expected.");
            }

            // Update privacy
            XConnSrvTestHelpers.SetPrivacy(subscribee, subscribeePrivacyEnd);

            Thread.Sleep(3000);
            connection.ClearNotificationRecievedList();

            // Log the user back on (notifications for rich +  basic creation will be sent, plus 1 more basic for SetTitleDAta with subsciberPrivacyEnd)
            fc.LogonUser(subscribee, subscribee.Xbox);

            XConnSrvTestHelpers.SetTitleData2(subscribee);
            Thread.Sleep(2000);

            bool isBlocked = ((subscribeePrivacyStart == 0) && (subscribeePrivacyEnd == 0)) ||
                             ((subscribeePrivacyStart == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) && (subscribeePrivacyEnd == 0) && !friend) ||
                             ((subscribeePrivacyStart == 0) && (subscribeePrivacyEnd == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) && !friend);

            // Verify notifications received
            if (!isBlocked)
            {
                // We just want to make sure they got at least 1 if they should get any - we cannot be exact with batching
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 10), "Did not receive notifications as expected.");

                if ((friend && subscribeePrivacyStart == 0 && subscribeePrivacyEnd == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE) ||
                    (friend && subscribeePrivacyStart == 0 && subscribeePrivacyEnd == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) ||
                    (!friend && subscribeePrivacyStart == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS && subscribeePrivacyEnd == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE) ||
                    (!friend && subscribeePrivacyStart == 0 && subscribeePrivacyEnd == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE))
                {
                    if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, totalsubs, 0, 5, XConnSrvTestHelpers.RichPresenceString2))
                        Assert.IsTrue(false, "Did not receive notifications as expected.");
                }
                // Can't check this anymore since we clear the notifications
                //else
                //{
                //    if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, totalsubs, 0, 5, XConnSrvTestHelpers.RichPresenceString1))
                //        Assert.IsTrue(false, "Did not receive notifications as expected.");
                //}
            }
            else
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 0, 0), "Received notifications unexpectedly.");
            }

            if (isBlocked)
            {
                Global.RO.Info("Checking for offline notification...");
                SUBSCRIPTION_DATA sd;
                sd = connection.GetNotification(basicsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
                sd = connection.GetNotification(richsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
            }

            //Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        static void FriendStatusChangesNotificationTest(bool friendStart, int subscribeePrivacy, bool friendEnd)
        {
            PNConnection connection = null;

            // Create one user.
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscription to desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            switch (subscribeePrivacy)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    if (friendStart) builder.Offline_Friends = 1;
                    else builder.Offline_Peers = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    if (friendStart) builder.Offline_Friends_PrivFriends = 1;
                    else builder.Offline_Peers_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    if (friendStart) builder.Offline_Friends_PrivBlocked = 1;
                    else builder.Offline_Peers_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users[0]);
            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friendStart ? builder.Friends : builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, friendStart ? builder.Friends : builder.Peers);

            //unsafe
            //{
            //    richsub[0].wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
            //}

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = friendStart ? builder.Friends[0] : builder.Peers[0];

            if (!friendStart)
            {
                // Subscribe to basic and rich presence
                SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                    Assert.IsTrue(false, "Subscription to basic presence failed.");

                SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich))
                    Assert.IsTrue(false, "Subscription to rich presence failed.");
            }

            // If this isn't done, the user will get 1 empty rich presence notification (Bug #136703)
            FriendsCommon fc = new FriendsCommon();
            fc.LogonUser(subscribee);
            fc.LogoffUser(subscribee);

            connection.ClearNotificationRecievedList();

            // Log the user on (notifications for rich + basic + basic will be sent)
            fc.LogonUser(subscribee, subscribee.Xbox);
            XConnSrvTestHelpers.SetTitleData(subscribee);

            System.Threading.Thread.Sleep(2000);

            // Update friend status
            if (friendEnd)
                fc.MakeFriend(users[0], subscribee);
            else
                fc.DeleteFriend(users[0], subscribee);

            System.Threading.Thread.Sleep(2000);
            connection.ClearNotificationRecievedList();

            XConnSrvTestHelpers.SetTitleData2(subscribee);

            System.Threading.Thread.Sleep(1000);

            // Log the user off (notifications for rich + basicwill be sent)
            fc.LogoffUser(subscribee);
            System.Threading.Thread.Sleep(2000);

            bool isBlocked = (subscribeePrivacy == 0);

            // Verify notifications received
            if (!isBlocked)
            {
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, totalsubs, 0, 5, XConnSrvTestHelpers.RichPresenceString2))
                    Assert.IsTrue(false, "Did not receive notifications as expected.");
            }

            // Calculate the total number of expectations expected. We must count both start at finish since the start will come into play when the
            // notifications are sent when the user logs off, and the end will come into play when the user logs back in
            uint expectedNotis = 0;
            if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
            {
                expectedNotis += 2;
            }
            else if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS)
            {
                if (friendStart) expectedNotis += 2;
                if (friendEnd) expectedNotis += 2;
            }

            // Verify the corrent number of notifications were received, if we should expect any
            if (expectedNotis == 0)
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 0, 0), "Received notifications unexpectedly.");
            }
            else
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 10), "Did not receive notifications as expected.");
            }

            if (isBlocked)
            {
                Global.RO.Info("Checking for offline notification...");
                SUBSCRIPTION_DATA sd;
                sd = connection.GetNotification(basicsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
                sd = connection.GetNotification(richsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
            }

            //Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        static void SameConsoleNotificationTest(bool friend, int subscribeePrivacy)
        {
            FriendsCommon fc = new FriendsCommon();
            PNConnection connection = null;

            // Create two users on the same console
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscriptions to desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            switch (subscribeePrivacy)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    if (friend) builder.Offline_Friends_SameConsole = 1;
                    else builder.Offline_Peers_SameConsole = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    if (friend) builder.Offline_Friends_SameConsole_PrivFriends = 1;
                    else builder.Offline_Peers_SameConsole_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    if (friend) builder.Offline_Friends_SameConsole_PrivBlocked = 1;
                    else builder.Offline_Peers_SameConsole_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users);
            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friend ? builder.Friends : builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, friend? builder.Friends : builder.Peers);

            //unsafe
            //{
            //    richsub[0].wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
            //}

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = friend ? builder.Friends[0] : builder.Peers[0];

            // Make our users friends if they should be
            //if (user1Friend)
            //    fc.MakeFriend(users[0], subscribee);
            //else
            //{
                // Subscribe to basic and rich presence
                SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                    Assert.IsTrue(false, "Subscription to basic presence failed for user 0.");

                SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich))
                    Assert.IsTrue(false, "Subscription to rich presence failed for user 0.");
            //}

            // If this isn't done, the user will get 1 empty rich presence notification (Bug #136703)
            fc.LogonUser(subscribee);
            fc.LogoffUser(subscribee);

            System.Threading.Thread.Sleep(15000);
            connection.ClearNotificationRecievedList();

            // Log on subscribee so new data is inserted into velocity
            fc.LogonUser(subscribee, subscribee.Xbox);

            System.Threading.Thread.Sleep(2000);

            XConnSrvTestHelpers.SetTitleData2(subscribee);

            System.Threading.Thread.Sleep(2000);

            bool isBlocked = (subscribeePrivacy == 0) || (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS && !friend);

            // Verify notifications received
            if (!isBlocked)
            {
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, totalsubs, 0, 5, XConnSrvTestHelpers.RichPresenceString2))
                    Assert.IsTrue(false, "Did not receive notifications as expected.");
            }

            // We are on the same console: everything should be visible
            uint expectedNotis = 0; // TODO: 3

            if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
            {
                expectedNotis += 2; // TODO: 3
            }
            else if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS)
            {
                if (friend) expectedNotis += 2; // TODO: 3
            }

            // Verify the corrent number of notifications were received, if we should expect any
            if (expectedNotis == 0)
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 0, 0), "Received notifications unexpectedly.");
            }
            else
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 8), "Did not receive notifications as expected.");
            }

            if (isBlocked)
            {
                Global.RO.Info("Checking for offline notification...");
                SUBSCRIPTION_DATA sd;
                sd = connection.GetNotification(basicsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
                sd = connection.GetNotification(richsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
            }

            //Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        static void MixedFriendsSameConsoleNotificationTest(bool user1Friend, bool user2Friend, int subscribeePrivacy)
        {
            FriendsCommon fc = new FriendsCommon();
            PNConnection connection = null;

            // Create two users on the same console
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscriptions to desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            switch (subscribeePrivacy)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    builder.Offline_Peers = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    builder.Offline_Peers_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    builder.Offline_Peers_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users);
            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Peers);

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = builder.Peers[0];

            // Make our users friends if they should be
            if (user1Friend)
                fc.MakeFriend(users[0], subscribee);
            else
            {
                // Subscribe to basic and rich presence
                users[0].Xbox.SendSubscribeForUser(users[0].UserId, basicsub);
                users[0].Xbox.SendSubscribeForUser(users[0].UserId, richsub);
            }

            if (user2Friend)
                fc.MakeFriend(users[1], subscribee);
            else
            {
                users[1].Xbox.SendSubscribeForUser(users[1].UserId, basicsub);
                users[1].Xbox.SendSubscribeForUser(users[1].UserId, richsub);
            }

            // If this isn't done, the user will get 1 empty rich presence notification (Bug #136703)
            fc.LogonUser(subscribee);
            fc.LogoffUser(subscribee);

            System.Threading.Thread.Sleep(5000);
            connection.ClearNotificationRecievedList();

            // Log on subscribee so new data is inserted into velocity
            fc.LogonUser(subscribee, subscribee.Xbox);

            System.Threading.Thread.Sleep(2000);

            XConnSrvTestHelpers.SetTitleData2(subscribee);

            System.Threading.Thread.Sleep(2000);

            bool isBlocked = (subscribeePrivacy == 0) || (!user1Friend && !user1Friend && subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

            // Verify notifications received
            if (!isBlocked)
            {
                if (!XConnSrvTestHelpers.VerifyNotificationsReceived(connection, totalsubs, 0, 5, XConnSrvTestHelpers.RichPresenceString2))
                    Assert.IsTrue(false, "Did not receive notifications as expected.");
            }

            uint expectedNotis = 0;
            if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
            {
                expectedNotis += 2;
            }
            else if (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS)
            {
                if (user1Friend || user2Friend) expectedNotis += 2;
            }

            // Verify the corrent number of notifications were received, if we should expect any
            if (expectedNotis == 0)
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 0, 0), "Received notifications unexpectedly.");
            }
            else
            {
                Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 10), "Did not receive notifications as expected.");
            }

            if (isBlocked)
            {
                Global.RO.Info("Checking for offline notification...");
                SUBSCRIPTION_DATA sd;
                sd = connection.GetNotification(basicsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
                sd = connection.GetNotification(richsub[0], true);
                Assert.IsTrue(sd == null, "Should receive null data.");
            }

            //Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        static void BasicPrivacySubscriptionReplyTest(bool friend, bool sameConsole, int subscribeePrivacy)
        {
            PNConnection connection = null;

            // Create one user.
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscription DOS for desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            switch (subscribeePrivacy)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    if (friend)
                        if (sameConsole) builder.Offline_Friends_SameConsole = 1;
                        else builder.Offline_Friends = 1;
                    else
                        if (sameConsole) builder.Offline_Peers_SameConsole = 1;
                        else builder.Offline_Peers = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    if (friend)
                        if (sameConsole) builder.Offline_Friends_SameConsole_PrivFriends = 1;
                        else builder.Offline_Friends_PrivFriends = 1;
                    else
                        if (sameConsole) builder.Offline_Peers_SameConsole_PrivFriends = 1;
                        else builder.Offline_Peers_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    if (friend)
                        if(sameConsole) builder.Offline_Friends_SameConsole_PrivBlocked = 1;
                        else builder.Offline_Friends_PrivBlocked = 1;
                    else
                        if (sameConsole) builder.Offline_Peers_SameConsole_PrivBlocked = 1;
                        else builder.Offline_Peers_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users[0]);
            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friend ? builder.Friends : builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, friend ? builder.Friends : builder.Peers);

            //// Size change for rich presence since initial logon creates a rich presence reply the sizeof(BASE_DATA_HEADER)
            //unsafe
            //{
            //    richsub[0].wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
            //}

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = friend ? builder.Friends[0] : builder.Peers[0];

            FriendsCommon fc = new FriendsCommon();
            fc.LogonUser(subscribee);

            Thread.Sleep(2000);

            // Subscribe to basic and rich presence
            SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                Assert.IsTrue(false, "Subscription to basic presence failed.");

            SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich))
                Assert.IsTrue(false, "Subscription to rich presence failed.");

            // Verify privacy in header
            if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyBasic, (!friend && subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) ? 0 : subscribeePrivacy))
                Assert.IsTrue(false, "Basic Presence subscription reply header privacy is invalid.");

            if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyRich, (!friend && subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) ? 0 : subscribeePrivacy))
                Assert.IsTrue(false, "Rich Presence subscription reply header privacy is invalid.");

            // Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        static void BasicPrivacyFriendPendingSubscriptionReplyTest(int subscribeePrivacy)
        {
            PNConnection connection = null;

            // Create one user.
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscription DOS for desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            switch (subscribeePrivacy)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    builder.Offline_Peers = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    builder.Offline_Peers_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    builder.Offline_Peers_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users[0]);
            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Peers);

            //// Size change for rich presence since initial logon creates a rich presence reply the sizeof(BASE_DATA_HEADER)
            //unsafe
            //{
            //    richsub[0].wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
            //}

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = builder.Peers[0];

            // Send friend request
            FriendsCommon fc = new FriendsCommon();
            fc.RequestFriend(users[0], subscribee);
            fc.LogonUser(subscribee);

            Thread.Sleep(2000);

            // Subscribe to basic and rich presence
            SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                Assert.IsTrue(false, "Subscription to basic presence failed.");

            SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich))
                Assert.IsTrue(false, "Subscription to rich presence failed.");

            // Verify privacy in header
            if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyBasic, (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) ? 0 : subscribeePrivacy))
                Assert.IsTrue(false, "Basic Presence subscription reply header privacy is invalid.");

            if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyRich, (subscribeePrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS) ? 0 : subscribeePrivacy))
                Assert.IsTrue(false, "Rich Presence subscription reply header privacy is invalid.");

            // Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        static void MixedFriendsSameConsoleSubscriptionReplyTest(bool user1Friend, bool user2Friend, int subscribeePrivacy)
        {
            PNConnection connection = null;

            // Create two users on the same console
            PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
            connection = users[0].Xbox.ConnectionServerConnection;

            // Create subscriptions to desired user type
            PNUsersBuilder builder = new PNUsersBuilder();
            switch (subscribeePrivacy)
            {
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE:
                    builder.Offline_Peers = 1;
                    break;
                case CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS:
                    builder.Offline_Peers_PrivFriends = 1;
                    break;
                case 0: // Blocked
                    builder.Offline_Peers_PrivBlocked = 1;
                    break;
            }
            builder.CreateUsers(users);
            DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Peers);
            DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Peers);

            //// TODO: Temporary size change for rich presence since initial logon creates a rich presence reply the sizeof(BASE_DATA_HEADER)
            //unsafe
            //{
            //    richsub[0].wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
            //}

            DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
            Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
            Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

            PNUser subscribee = builder.Peers[0];

            FriendsCommon fc = new FriendsCommon();
            fc.LogonUser(subscribee);

            Thread.Sleep(2000);

            // Make user1 friends if they should be
            if (user1Friend)
                fc.MakeFriend(users[0], subscribee);

            Thread.Sleep(2000);

            // Subscribe user1 to basic and rich presence
            SUBSCRIBE_REPLY subscribeReplyBasic0;
            SUBSCRIBE_REPLY subscribeReplyRich0;
            users[0].Xbox.SendSubscribeForUser(users[0].UserId, basicsub,false, out subscribeReplyBasic0);
            users[0].Xbox.SendSubscribeForUser(users[0].UserId, richsub, false, out subscribeReplyRich0);
            //SUBSCRIBE_REPLY subscribeReplyBasic0 = connection.Subscribe(basicsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic0))
                Assert.IsTrue(false, "Subscription to basic presence failed for user 0.");

            //SUBSCRIBE_REPLY subscribeReplyRich0 = connection.Subscribe(richsub, new int[] { 0 });
            if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich0))
                Assert.IsTrue(false, "Subscription to rich presence failed for user 0.");

            // Verify privacy in header
            if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyBasic0, (!user1Friend && !user2Friend) ? 0 : subscribeePrivacy))
                Assert.IsTrue(false, "Basic Presence subscription reply header privacy is invalid.");

            if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyRich0, (!user1Friend && !user2Friend) ? 0 : subscribeePrivacy))
                Assert.IsTrue(false, "Rich Presence subscription reply header privacy is invalid.");

            // Make user2 friends if they should be
            if (user2Friend)
                fc.MakeFriend(users[1], subscribee);

            // Subscribe user2 to basic and rich presence
            SUBSCRIBE_REPLY subscribeReplyBasic1;// = connection.Subscribe(basicsub, new int[] { 1 });
            users[1].Xbox.SendSubscribeForUser(users[1].UserId, basicsub,false, out subscribeReplyBasic1);
            if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, basicsub, subscribeReplyBasic1))
                Assert.IsTrue(false, "Subscription to basic presence failed for user 1.");

            SUBSCRIBE_REPLY subscribeReplyRich1 ;//= connection.Subscribe(richsub, new int[] { 1 });
            users[1].Xbox.SendSubscribeForUser(users[1].UserId, richsub, false, out subscribeReplyRich1);
            if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, richsub, subscribeReplyRich1))
                Assert.IsTrue(false, "Subscription to rich presence failed for user 1.");

            // Verify privacy in header
            //TODO: CHECK: Following is failing because it is getting wrong bit in subscribe reply.
            //if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyBasic1, (!user1Friend && !user2Friend) ? 0 : subscribeePrivacy))
            //    Assert.IsTrue(false, "Basic Presence subscription reply header privacy is invalid.");

            //if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyRich1, (!user1Friend && !user2Friend) ? 0 : subscribeePrivacy))
            //    Assert.IsTrue(false, "Rich Presence subscription reply header privacy is invalid.");

            //Disconnect
            if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                Assert.IsTrue(false, "Disconnect failed.");
        }

        #region NOTIFICATION_BASIC
        /// <summary>
        /// User subscribes to Friend with open privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BasicNotificationFriendOpen : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with friends-only privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BasicNotificationFriendFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        
        /// <summary>
        /// User subscribes to Friend with blocked privacy and doesn't expect a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BasicNotificationFriendBlocked : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyNotificationTest(true, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with open privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BasicNotificationPeerOpen : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with friends-only privacy and doesn't expect a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BasicNotificationPeerFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with blocked privacy and doesn't expect a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BasicNotificationPeerBlocked : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyNotificationTest(false, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region NOTIFICATION_BASIC_PENDING_FRIEND
        /// <summary>
        /// User requests friendship to User with open privacy and then subscribes and expects a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class PendingFriendNotificationOpen : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyPendingFriendNotificationTest(CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User requests friendship to User with friends-only privacy and then subscribes and does not expect a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class PendingFriendNotificationFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyPendingFriendNotificationTest(CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User requests friendship to User with blocked privacy and then subscribes and does not expect a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class PendingFriendNotificationBlocked : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyPendingFriendNotificationTest(0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region NOTIFICATION_CHANGE_PRIVACY
        /// <summary>
        /// User subscribes to Friend with open privacy, Friend changes privacy to friends-only, expects a notification
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class ChangePrivacyNotificationFriendOpenToFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        /// <summary>
        /// User subscribes to Friend with open privacy, Friend changes privacy to blocked, doesn't expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationFriendOpenToBlocked : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, 0, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with friends-only privacy, Friend changes privacy to open, expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationFriendFriendsOnlyToOpen : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with friends-only privacy, Friend changes privacy to blocked, doesn't expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationFriendFriendsOnlyToBlocked : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, 0, false);
                
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with blocked privacy, Friend changes privacy to open, expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationFriendBlockedToOpen : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(true, 0, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with blocked privacy, Friend changes privacy to friends-only, expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationFriendBlockedToFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(true, 0, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with open privacy, Peer changes privacy to friends-only, expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationPeerOpenToFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with open privacy, Peer changes privacy to blocked, doesn't expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationPeerOpenToBlocked : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, 0, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with friends-only privacy, Peer changes privacy to open, expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationPeerFriendsOnlyToOpen : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with friends-only privacy, Peer changes privacy to blocked, doesn't expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationPeerFriendsOnlyToBlocked : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, 0, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with blocked privacy, Peer changes privacy to open, expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationPeerBlockedToOpen : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(false, 0, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with blocked privacy, Peer changes privacy to friends-only, expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangePrivacyNotificationPeerBlockedToFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                PrivacyChangesNotificationTest(false, 0, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region NOTIFICATION_CHANGE_FRIEND_STATUS
        /// <summary>
        /// User subscribes to Friend with open privacy, friendship is ended and Friend becomes Peer
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class ChangeFriendStatusNotificationOpenFriendToPeer : TestBase
        {
            override protected void Execute()
            {
                FriendStatusChangesNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with friends-only privacy, friendship is ended and Friend becomes Peer
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Ignore]
        public class ChangeFriendStatusNotificationFriendsOnlyFriendToPeer : TestBase
        {
            override protected void Execute()
            {
                FriendStatusChangesNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with blocked privacy, friendship is ended and Friend becomes Peer
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangeFriendStatusNotificationBlockedFriendToPeer : TestBase
        {
            override protected void Execute()
            {
                FriendStatusChangesNotificationTest(true, 0, false);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with open privacy, friendship is made and Peer becomes Friend
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangeFriendStatusNotificationOpenPeerToFriend : TestBase
        {
            override protected void Execute()
            {
                FriendStatusChangesNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with friends-only privacy, friendship is made and Peer becomes Friend
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangeFriendStatusNotificationFriendsOnlyPeerToFriend : TestBase
        {
            override protected void Execute()
            {
                FriendStatusChangesNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with blocked privacy, friendship is made and Peer becomes Friend
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class ChangeFriendStatusNotificationBlockedPeerToFriend : TestBase
        {
            override protected void Execute()
            {
                FriendStatusChangesNotificationTest(false, 0, true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region NOTIFICATION_SAME_CONSOLE
        /// <summary>
        /// User subscribes to friend on same console with open privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleNotificationFriendOpen : TestBase
        {
            override protected void Execute()
            {
                SameConsoleNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to friend on same console with friends-only privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleNotificationFriendFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                SameConsoleNotificationTest(true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to friend on same console with blocked privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleNotificationFriendBlocked : TestBase
        {
            override protected void Execute()
            {
                SameConsoleNotificationTest(true, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to peer on same console with open privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleNotificationPeerOpen : TestBase
        {
            override protected void Execute()
            {
                SameConsoleNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to peer on same console with friends-only privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleNotificationPeerFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                SameConsoleNotificationTest(false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to peer on same console with blocked privacy and expects a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleNotificationPeerBlocked : TestBase
        {
            override protected void Execute()
            {
                SameConsoleNotificationTest(false, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region NOTIFICATION_SAME_CONSOLE_MIXED_RELATIONSHIP
        /// <summary>
        /// Two users on the same console subscribe to a shared friend with open privacy and expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationFriendFriendOpen : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared friend with friends-only privacy and expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationFriendFriendFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared friend with blocked privacy and do not expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationFriendFriendBlocked : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(true, true, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared peer with open privacy and expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationPeerPeerOpen : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(false, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared peer with friends-only privacy and do not expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationPeerPeerFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(false, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared peer with blocked privacy and do not expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationPeerPeerBlocked : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(false, false, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users (one a friend, one a peer) on the same console subscribe to a user with open privacy and expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationFriendPeerOpen : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users (one a friend, one a peer) on the same console subscribe to a user with friends-only privacy and expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationFriendPeerFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users (one a friend, one a peer) on the same console subscribe to a user with blocked privacy and do not expect a notification
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedNotificationFriendPeerBlocked : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleNotificationTest(true, false, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region SUBSCRIPTION_REPLY_BASIC
        /// <summary>
        /// User subscribes to Friend with open privacy
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BasicSubscriptionReplyFriendOpen : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with friends-only privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class BasicSubscriptionReplyFriendFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend with blocked privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class BasicSubscriptionReplyFriendBlocked : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(true, false, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with open privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class BasicSubscriptionReplyPeerOpen : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(false, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with friends-only privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class BasicSubscriptionReplyPeerFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(false, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer with blocked privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class BasicSubscriptionReplyPeerBlocked : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(false, false, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region SUBSCRIPTION_REPLY_BASIC_PENDING_FRIEND
        /// <summary>
        /// User requests friendship to User with open privacy and then subscribes
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BasicSubscriptionReplyPendingFriendOpen : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyFriendPendingSubscriptionReplyTest(CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User requests friendship to User with friends-only privacy and then subscribes
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class BasicSubscriptionReplyPendingFriendFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyFriendPendingSubscriptionReplyTest(CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User requests friendship to User with blocked privacy and then subscribes
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class BasicSubscriptionReplyPendingFriendBlocked : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacyFriendPendingSubscriptionReplyTest(0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region SUBSCRIPTION_REPLY_SAME_CONSOLE
        /// <summary>
        /// User subscribes to Friend on the same console with open privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleSubscriptionReplyFriendOpen : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend on the same console with friends-only privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleSubscriptionReplyFriendFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Friend on the same console with blocked privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleSubscriptionReplyFriendBlocked : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(true, true, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer on the same console with open privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleSubscriptionReplyPeerOpen : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(false, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer on the same console with friends-only privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleSubscriptionReplyPeerFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(false, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// User subscribes to Peer on the same console with blocked privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleSubscriptionReplyPeerBlocked : TestBase
        {
            override protected void Execute()
            {
                BasicPrivacySubscriptionReplyTest(false, true, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region SUBSCRIPTION_REPLY_SAME_CONSOLE_MIXED_RELATIONSHIP
        /// <summary>
        /// Two users on the same console subscribe to a shared friend with open privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyFriendFriendOpen : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared friend with friends-only privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyFriendFriendFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared friend with blocked privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyFriendFriendBlocked : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(true, true, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared peer with open privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyPeerPeerOpen : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(false, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared peer with friends-only privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyPeerPeerFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(false, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users on the same console subscribe to a shared peer with blocked privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyPeerPeerBlocked : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(false, false, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users (one a friend, one a peer) on the same console subscribe to a user with open privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyFriendPeerOpen : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users (one a friend, one a peer) on the same console subscribe to a user with friends-only privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyFriendPeerFriendsOnly : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Two users (one a friend, one a peer) on the same console subscribe to a user with blocked privacy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SameConsoleMixedSubscriptionReplyFriendPeerBlocked : TestBase
        {
            override protected void Execute()
            {
                MixedFriendsSameConsoleSubscriptionReplyTest(true, false, 0);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        #endregion

        #region MISC
        /// <summary>
        /// One user subscribes to 2 users who have different relationships (1 friend, 1 peer) with the subscriber and
        /// verifies that the privacy for each entry in the reply is valid
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class MultipleMixedSubscriptionReply : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription DOS for desired user type
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Offline_Friends = 1;
                builder.Offline_Peers_PrivBlocked = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, new PNUser[] { builder.Friends[0], builder.Peers[0] });
                DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, new PNUser[] { builder.Friends[0], builder.Peers[0] });

                // Size change for rich presence since initial logon creates a rich presence reply the sizeof(BASE_DATA_HEADER)
                unsafe
                {
                    richsub[0].wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
                }

                DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
                Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
                Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

                PNUser openFriend = builder.Friends[0];
                PNUser blockedPeer = builder.Peers[0];

                // Logon user so that rich presence blobs are inserted with the correct privacy flags
                FriendsCommon fc = new FriendsCommon();
                fc.LogonUser(openFriend);
                fc.LogonUser(blockedPeer);

                Thread.Sleep(2000);

                // Subscribe to basic and rich presence
                SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                    Assert.IsTrue(false, "Subscription to basic presence failed.");

                SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richsub, subscribeReplyRich))
                    Assert.IsTrue(false, "Subscription to rich presence failed.");

                // Verify privacy in header
                if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyBasic, new int[] { CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, 0 }, basicsub))
                    Assert.IsTrue(false, "Basic Presence subscription reply header privacy is invalid.");

                if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyRich, new int[] { CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, 0 }, richsub))
                    Assert.IsTrue(false, "Rich Presence subscription reply header privacy is invalid.");

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    Assert.IsTrue(false, "Disconnect failed.");

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// A single user subscribes to a peer, manually make friends (request + accept), then confirm
        /// notifications are sent without logging off/on
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class FriendsManuallyGetNotification : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                // Create one user.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription DOS for desired user type
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Offline_Peers_PrivFriends = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Peers);
                DATA_OBJECT_SPECIFIER[] richsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Peers);

                richsub[0].wObjectSize = 100; // Expected size for rich presence string

                // Size change for rich presence subscription reply since initial logon creates a rich presence reply the sizeof(BASE_DATA_HEADER)
                DATA_OBJECT_SPECIFIER richsubSubReply = richsub[0];
                unsafe
                {
                    richsubSubReply.wObjectSize = (ushort)sizeof(BASE_DATA_HEADER);
                }

                DATA_OBJECT_SPECIFIER[] totalsubs = new DATA_OBJECT_SPECIFIER[basicsub.Length + richsub.Length];
                Array.Copy(basicsub, 0, totalsubs, 0, basicsub.Length);
                Array.Copy(richsub, 0, totalsubs, basicsub.Length, richsub.Length);

                PNUser subscribee = builder.Peers[0];

                FriendsCommon fc = new FriendsCommon();
                fc.LogonUser(subscribee, Pong.TitleId);

                // Subscribe to basic and rich presence
                SUBSCRIBE_REPLY subscribeReplyBasic = connection.Subscribe(basicsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicsub, subscribeReplyBasic))
                    Assert.IsTrue(false, "Subscription to basic presence failed.");

                SUBSCRIBE_REPLY subscribeReplyRich = connection.Subscribe(richsub, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, new DATA_OBJECT_SPECIFIER[] { richsubSubReply }, subscribeReplyRich))
                    Assert.IsTrue(false, "Subscription to rich presence failed.");

                // Verify privacy in header
                if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyBasic, 0))
                    Assert.IsTrue(false, "Basic Presence subscription reply header privacy is invalid.");

                if (!XConnSrvTestHelpers.VerifyPrivacyInSubscriptionReply(subscribeReplyRich, 0))
                    Assert.IsTrue(false, "Rich Presence subscription reply header privacy is invalid.");

                byte[] accel_data_before = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(richsub[0]));
                unsafe
                {
                    fixed (byte* accelData = &(accel_data_before[0]))
                    {
                        BASE_DATA_HEADER* prpData = (BASE_DATA_HEADER*)accelData;

                        Global.RO.Error("Header Flags before becoming friends: " + prpData->dwHeaderFlags);
                    }
                }
                
                // Make friends so that notifications can be sent
                fc.RequestFriend(users[0], subscribee);
                fc.AcceptFriend(subscribee, users[0]);

                Thread.Sleep(5000);
                connection.ClearNotificationRecievedList();

                byte[] accel_data_after = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(richsub[0]));
                unsafe
                {
                    fixed (byte* accelData = &(accel_data_after[0]))
                    {
                        BASE_DATA_HEADER* prpData = (BASE_DATA_HEADER*)accelData;

                        Global.RO.Error("Header Flags after becoming friends: " + prpData->dwHeaderFlags);
                    }
                }

                // Update state and rich presence via SetTitleData to trigger notifications
                subscribee.State = subscribee.State | XonPresNoti.P_STATE_ENUM_AWAY;

                GIBlob gi = new GIBlob();
                gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.SinglePlayer);
                gi.AddContext((uint)Pong.Context.GameSize, (uint)Pong.GameSize.Medium);
                gi.AddContext((uint)Pong.Context.GameSpeed, (uint)Pong.GameSpeed.Fast);
                subscribee.SetTitleData(gi.GetBytes());

                Thread.Sleep(3000);

                // Verify the corrent number of notifications were received, if we should expect any
                //if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 2, 2))
                //    Assert.IsTrue(false, "Incorrect number of notifications received.");

                if (!XConnSrvTestHelpers.VerifyNotificationPrivacy(connection, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS))
                    Assert.IsTrue(false, "Incorrect privacy type received.");

                SUBSCRIPTION_DATA subData = connection.GetNotification(richsub[0], false);

                XConnSrvTestHelpers.VerifyRichPresString(subData.data, "Single Player: Medium paddle, Fast ball");

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    Assert.IsTrue(false, "Disconnect failed.");

            }
        }
        #endregion

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class LogOffTriggersNotification : TestBase
        {
            override protected void Execute()
            {
                FriendsCommon fc = new FriendsCommon();
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                //Create test user alive and ocnnect him.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;

                //Get Dataobject Specifier for basic presence
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 2;
                builder.CreateUsers(users[0]); //this will also make him friend..
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicsubscribeReply = connection.Subscribe(subscribes_basic);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, basicsubscribeReply), "Subscription verified.");

                foreach (PNUser user in builder.Friends)
                {
                    XConnSrvTestHelpers.SetPrivacy(user, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                    fc.LogoffUser(user);
                }

                Thread.Sleep(5000);

                //hook in to notified event of this connection.
                NotificationManager mgr1 = new NotificationManager();
                connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr1.OnNotification);

                Thread.Sleep(5000);

                //only user 1 should  get the notiification.
                Assert.IsTrue(mgr1.BasicNotificationCountPerIndex[0] == 0, "Recieved " + mgr1.BasicNotificationCountPerIndex[0] + " notifications");
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Ignore]
        public class MultiStepPrivacySettingChange : TestBase
        {
            override protected void Execute()
            {
                /* User B   relation with A     priv setting
                 * 1         Peer                Open
                 * 2         Peer                FO
                 * 3         Peer                Blocked
                 * 4         Friend              Blocked
                 * 5         Friend              FO
                 * 6         Friend              Open
                 * 7         Peer                Open
                 * 8         Peer                FO
                 * 9         Peer                Blocked
                 */
                FriendsCommon fc = new FriendsCommon();
                PNConnection connection = null;
                int curBasicNotiCount = 0;
                int curRichNotiCount = 0;
                ResultCode = TEST_RESULTS.PASSED;

                //Create test user alive and ocnnect him.

                PNUser userA = fc.CreateXenonUser(true);
                PNUser userB = fc.CreateXenonUser(true);

                //Get Dataobject Specifier for basic presence
                DATA_OBJECT_SPECIFIER[] basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, new PNUser[] { userB });
                DATA_OBJECT_SPECIFIER[] rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, new PNUser[] { userB });

                //recreate to avoid redundant offline notification
                connection = userA.Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(userA.UserId, 0), "Connection.Connected");
                // Subscribe 
                SUBSCRIBE_REPLY basicreply;
                SUBSCRIBE_REPLY richreply;
                userA.Xbox.SendSubscribeForUser(userA.UserId, basic);
                userA.Xbox.SendSubscribeForUser(userA.UserId, rich);
                fc.LogoffUser(userA);
                fc.LogonUser(userA);
                connection = userA.Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(userA.UserId, 0), "Connection.Connected");

                userA.Xbox.SendSubscribeForUser(userA.UserId, basic, false, out basicreply);
                userA.Xbox.SendSubscribeForUser(userA.UserId, rich, false, out richreply);
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(userA.UserId, basic, basicreply), "Subscription verified.");
                Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(userA.UserId, rich, richreply), "Subscription verified.");
                //hook in to notified event of this connection.
                NotificationManager mgr = new NotificationManager();
                connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr.OnNotification);

                //1: Peer Open
                Global.RO.Debug("Case 1: Open Peer");
                XConnSrvTestHelpers.SetPrivacy(userB, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);
                fc.LogoffUser(userB);
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogoffUser 1");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogoffUser 1");
                
                fc.LogonUser(userB);
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogonUser 1");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogonUser 1");

                //2. Peer FO
                Global.RO.Debug("Case 2: FO Peer");
                XConnSrvTestHelpers.SetPrivacy(userB, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                fc.LogoffUser(userB);
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogoffUser 2");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogoffUser 2");
                
                fc.LogonUser(userB);
                //No increment for count. Shouldn't receive notification.
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogonUser 2");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogonUser 2");

                //3. Peer Blocked.
                Global.RO.Debug("Case 3: Blocked Peer");
                XConnSrvTestHelpers.SetPrivacy(userB, 0);
                fc.LogoffUser(userB);
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogoffUser 3");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogoffUser 3");

                fc.LogonUser(userB);
                //No increment for count. Shouldn't receive notification.
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogonUser 3");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogonUser 3");

                //4. Friend Blocked.
                Global.RO.Debug("Case 4: Blocked Friend");
                fc.MakeFriend(userA, userB);
                curBasicNotiCount++; curRichNotiCount++;
                curBasicNotiCount++; curRichNotiCount++;    //friends notification.
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "MakeFriend 4");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "MakeFriend 4");

                //5. Friend FO
                Global.RO.Debug("Case 5: FO Friend");
                XConnSrvTestHelpers.SetPrivacy(userB, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                fc.LogoffUser(userB);
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogoffUser 5");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogoffUser 5");

                fc.LogonUser(userB);
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogonUser 5");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogonUser 5");

                //6. Friend Open.
                Global.RO.Debug("Case 6: Open Friend");
                XConnSrvTestHelpers.SetPrivacy(userB, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);
                fc.LogoffUser(userB);
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogoffUser 6");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogoffUser 6");

                fc.LogonUser(userB);
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogonUser 6");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogonUser 6");

                //7. Peer Open
                Global.RO.Debug("Case 7: Open Peer");
                fc.DeleteFriend(userA, userB);
                curBasicNotiCount++; curRichNotiCount++;
                curBasicNotiCount++; curRichNotiCount++;
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "DeleteFriend 7");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "DeleteFriend 7");

                //8. Peer FO
                Global.RO.Debug("Case 8: FO Peer");
                XConnSrvTestHelpers.SetPrivacy(userB, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);
                fc.LogoffUser(userB);
                curBasicNotiCount++; curRichNotiCount++;
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogoffUser 8");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogoffUser 8");

                fc.LogonUser(userB);
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogonUser 8");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogonUser 8");

                //9. Peer Blocked.
                Global.RO.Debug("Case 9: Blocked Peer");
                XConnSrvTestHelpers.SetPrivacy(userB, 0);
                fc.LogoffUser(userB);
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogoffUser 9");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogoffUser 9");

                fc.LogonUser(userB);
                Thread.Sleep(2000);
                Assert.AreEqual(mgr.BasicNotificationCountPerIndex[0], curBasicNotiCount, "LogonUser 9");
                Assert.AreEqual(mgr.RichNotificiationCountPerIndex[0], curRichNotiCount, "LogonUser 9");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class CloakedUserGoesShared: TestBase
        {
            protected override void Execute()
            {
                PNConnection connection = null;
                ResultCode = TEST_RESULTS.PASSED;

                FriendsCommon fc = new FriendsCommon();
                PNUser observer = fc.CreateXenonUser(true);
                PNUser cloaked = fc.CreateXenonUser(true);

                fc.MakeFriend(observer, cloaked);

                XConnSrvTestHelpers.SetPrivacy(cloaked, 0); //set as blocked
                fc.LogoffUser(cloaked);
                Thread.Sleep(2000);

                //hook in to event
                connection = observer.Xbox.ConnectionServerConnection;
                NotificationManager mgr = new NotificationManager();
                connection.Notified += new ConnSrvConnection.NotifiedEventHandler(mgr.OnNotification);

                //logon cloaked. should not get noti.
                fc.LogonUser(cloaked, true); //logon appear offline
                Thread.Sleep(2000);
                Assert.IsTrue(mgr.BasicNotificationCountPerIndex[0] == 0, "Received > 0 basic notifications from logging on");
                Assert.IsTrue(mgr.RichNotificiationCountPerIndex[0] == 0, "Received > 0 rich notifications from logging on");

                //make it shared and logoff.
                XConnSrvTestHelpers.SetPrivacy(cloaked, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);
                fc.LogoffUser(cloaked);
                Thread.Sleep(2000);
                Assert.IsTrue(mgr.BasicNotificationCountPerIndex[0] > 0, "Did not receive a basic notification from logging off");
                Assert.IsTrue(mgr.RichNotificiationCountPerIndex[0] > 0, "Did not receive a rich notification from logging off");
            }
        }

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class PSBugNum26122 : TestBase
        {
            protected override void Execute()
            {
                PNConnection connection = null;
                ResultCode = TEST_RESULTS.PASSED;

                FriendsCommon fc = new FriendsCommon();
                PNUser userA = fc.CreateXenonUser(true);
                PNUser userB = fc.CreateXenonUser(true);

                DATA_OBJECT_SPECIFIER[] basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, new PNUser[] { userB });
                DATA_OBJECT_SPECIFIER[] rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, new PNUser[] { userB });
                rich[0].wObjectSize = 20; // We expect an empty rich presence string since there is no title

                fc.MakeFriend(userA, userB);

                fc.LogoffUser(userA);
                fc.LogoffUser(userB);

                //Test start.
                fc.LogonUser(userA);
                connection = userA.Xbox.ConnectionServerConnection;
                Assert.IsTrue(XConnSrvTestHelpers.IsUserConnected(userA.UserId, 0), "Connection.Connected");
                
                connection.ClearNotificationRecievedList();

                //logon b and see that you got the noti.
                fc.LogonUser(userB);
                Thread.Sleep(2000);
                
                Assert.IsTrue(XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, basic[0], 0, 1) == true, "Did not get first basic notification.");
                Assert.IsTrue(XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, rich[0], 0, 1, null) == true, "Did not get first rich notification.");
                connection.ClearNotificationRecievedList();

                //set the privacy to blocked.
                XConnSrvTestHelpers.SetPrivacy(userB, 0);
                fc.LogoffUser(userB);
                Thread.Sleep(3000);

                basic[0].wObjectSize = 20; // We expect the basic notification to be empty since it is blocked now

                Assert.IsTrue(XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, basic[0], 0, 1) == true, "Did not get second basic notification.");
                Assert.IsTrue(XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, rich[0], 0, 1, null) == true, "Did not get second rich notification.");
                connection.ClearNotificationRecievedList();

                //check that now we dont get any more noti.
                fc.LogonUser(userB);
                Thread.Sleep(3000);

                Assert.IsTrue(connection.GetTotalNotificationsLength() == 0, "Got notifications when user came online with blocked privacy!");
            }
        }

        /// <summary>
        /// This was the issue where XConnSrv would get into a deadlock when the following happens:
        ///     User A is subscribed to User B
        ///     User B has privacy set to friends only
        ///     User B has a notification to send
        ///     XConnSrv iterates through User A's (as well as all other User B subscribers) friend list to see if they are friends and a notification should be sent
        ///     User A disconnects while their friend list is being traversed
        ///     Bam, there it is -> deadlock
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class PSBugNum37361 : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                // Create 1000 users.
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1000, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);

                // Create the 1 user with privacy set to friends only 
                PNUsersBuilder pnub = new PNUsersBuilder();
                pnub.Online_Peers_PrivFriends = 1;
                pnub.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] basicsub = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, pnub.Peers);

                // Everyone subscribe to the single user
                for (int i = 0; i < users.Length; ++i)
                {
                    SUBSCRIBE_REPLY subscribeReply = users[i].Xbox.ConnectionServerConnection.Subscribe(basicsub, new int[] { 0 });
                }

                XConnSrvTestHelpers.SendNotifications(basicsub);

                // Disconnect one user at a time while sending notifications
                for (int i = 0; i < users.Length; ++i)
                {
                    XConnSrvTestHelpers.SendNotifications(basicsub);
                    users[i].Xbox.ConnectionServerConnection.Disconnect();
                    Global.RO.Warn(i + " Disconnected.");
                }

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\StressUser.cs ===
// StressUser.cs
//
//	Wrapper for stress related state of a PNUser
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;


// TODO:
// 
//     Make users have friends
//         - If we do this the "real" way, we could affect other stress tests using the same users (Would need our own users)
//         - Insert directly into Acceleration? (How are friends list storage going to change for Berlin?)
//
//     Subscribe to friends
//         - Do the numbers in the XML include these friends or beyond friends?
//         - Add a value in the XML for how many friends to have? (Only works if we manually insert data)
//
//     Have the correct percentage of users with privacy settings
//         - Open, Friends Only, Blocked
//         

namespace XConnSrvTest
{
    public class StressConnSrvMessageQueue
    {
        private static Queue s_MessageQueue = Queue.Synchronized(new Queue());

        public static uint s_uiTimeOutSeconds = 5;

        public class StressConnSrvMessageQueueItem
        {
            private ConnSrvMessageAsyncResult _ctx = null;
            private DateTime _dt;

            public StressConnSrvMessageQueueItem(ConnSrvMessageAsyncResult innerCtx)
            {
                _ctx = innerCtx;
                _dt = DateTime.UtcNow;
            }

            public bool IsCompleted
            {
                get
                {
                    return _ctx.IsCompleted;
                }
            }

            public bool IsExpired
            {
                get
                {
                    if (_ctx.IsCompleted)
                        return false;
                    else
                        return _dt.AddSeconds(s_uiTimeOutSeconds) < DateTime.UtcNow;
                }
            }

            public void TimeOut()
            {
                _ctx.TimeOut();
            }
        }

        public static void Add(IAsyncResult ctx)
        {
            StressConnSrvMessageQueueItem queueItem = new StressConnSrvMessageQueueItem((ConnSrvMessageAsyncResult)ctx);
            lock (s_MessageQueue.SyncRoot)
            {
                s_MessageQueue.Enqueue(queueItem);
            }
        }


        public static void TimeOut()
        {
            lock(s_MessageQueue.SyncRoot)
            {
                while(s_MessageQueue.Count > 0)
                {
                    StressConnSrvMessageQueueItem front = s_MessageQueue.Peek() as StressConnSrvMessageQueueItem;
                    if (front.IsExpired)
                    {
                        front.TimeOut();
                    }
                    else if(!front.IsCompleted)
                    {
                        break;
                    }
                    s_MessageQueue.Dequeue();
                }
            }
        }
    }

	public class StressUser
	{
        public static uint DefaultUserFlags = 0x02606700;       // English (1<<25), Silver tier (0x6) user in the US (0x67)
        public static byte[] _basicPresenceBlob = null;
        public static DATA_OBJECT_SPECIFIER _basicPresenceDOS;
        public static byte[] _richPresenceBlob = null;
        public static DATA_OBJECT_SPECIFIER _richPresenceDOS;

        private PNConnection _connection = null;
        private PNXbox _xbox = null;

        // Fixed state data 
        private ulong _userId;
        private string _gamertag;
        private uint _userFlags;

        private ulong[] _userIds = null;
        private int[] _userIndices = null;
        private ulong _xboxId = 0;

        private int _realSubscriptionMin = 0; // "real" meaning subscribing to a user who exists and may update their state (Could trigger notifications)
        private int _realSubscriptionMax = 0;
        private int _fakeSubscriptionMin = 0; // "fake" meaning subscribing to an invalid user where a notification will never be triggered
        private int _fakeSubscriptionMax = 0;

        // Data loaded from XML
        private static int _minimumRealSubscriptions = 100;
        private static int _realUnsubscribesPerCall = 5;
        private static int _minimumFakeSubscriptions = 100;
        private static int _fakeUnsubscribesPerCall = 5;
        private static ulong _fakeBasePuidOffset = 1000000;
        public static ulong _changeStateBasePuid = 0;
        public static int _changeStatePuidCount = 0;

		////////////////////////////////////////////////
		// Ctor 
		//
		public StressUser( PuidName puidName )
		{
            _userId = puidName.Puid;
            _gamertag = puidName.GamerTag;
            _userIds = new ulong[] { _userId };
            _userIndices = new int[] { 1 };
            _userFlags = DefaultUserFlags;


            //unsafe
            //{
            //    uint numFriends = 100;

            //    // Insert Data
            //    int size = (int)(sizeof(USER_LIST_DATA) + numFriends * sizeof(USER_DATA));
            //    byte[] data = new byte[size];

            //    if (data != null)
            //    {
            //        fixed (byte* pData = &data[0])
            //        {
            //            USER_LIST_DATA* pUserList = (USER_LIST_DATA*)pData;
            //            pUserList->header.doSpec.wObjectSize = (ushort)size;
            //            pUserList->header.doSpec.wDataType = (ushort)DATA_TYPES.eFriendsList;
            //            pUserList->header.doSpec.dwDataSubType = 0;
            //            pUserList->header.doSpec.qwOwnerXUID = _userId;
            //            pUserList->header.dwHeaderFlags = 0;
            //            pUserList->dwListVersion = 0;
            //            pUserList->dwNumUsers = numFriends;

            //            // Share friends only
            //            pUserList->header.dwHeaderFlags |= CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS;

            //            USER_DATA* rgUsers = (USER_DATA*)(pUserList + 1);
            //            for (ulong friend = 0; (uint)friend < numFriends; ++friend)
            //            {
            //                rgUsers[friend].qwXUID = StressUserList.basePuid + ((_userId - StressUserList.basePuid + 1 + friend) % (ulong)StressUserList.puidCount);
            //                rgUsers[friend].dwUserFlags = 0;
            //            }
            //        }
            //    }
            //}
            
		}

        public static void Initialize()
        {
            XmlTextReader reader = new XmlTextReader("SuitesData\\XConnSrv\\XConnSrvStressSettings.xml");
            reader.WhitespaceHandling = WhitespaceHandling.None;
            reader.MoveToContent();

            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(reader);

            _minimumRealSubscriptions = Convert.ToInt32(xmlDoc.GetElementsByTagName("MinimumRealSubscriptions")[0].InnerText);
            _realUnsubscribesPerCall = Convert.ToInt32(xmlDoc.GetElementsByTagName("RealUnsubscribesPerCall")[0].InnerText);

            _minimumFakeSubscriptions = Convert.ToInt32(xmlDoc.GetElementsByTagName("MinimumFakeSubscriptions")[0].InnerText);
            _fakeUnsubscribesPerCall = Convert.ToInt32(xmlDoc.GetElementsByTagName("FakeUnsubscribesPerCall")[0].InnerText);

            _fakeBasePuidOffset = Convert.ToUInt64(xmlDoc.GetElementsByTagName("FakeBasePuidOffset")[0].InnerText);

            bool useStfPuids = Convert.ToBoolean(xmlDoc.GetElementsByTagName("UseStfUsers")[0].InnerText);

            if (useStfPuids)
            {
                _changeStateBasePuid = StressUserList.basePuid;
                _changeStatePuidCount = StressUserList.puidCount;
            }
            else
            {
                _changeStateBasePuid = Convert.ToUInt64(xmlDoc.GetElementsByTagName("BasePuid")[0].InnerText);
                _changeStatePuidCount = Convert.ToInt32(xmlDoc.GetElementsByTagName("PuidCount")[0].InnerText);
            }

            Global.RO.Warn("\n" +
                           "Minimum Real Subscriptions:   " + _minimumRealSubscriptions + "\n" +
                           "Real Unsubscribes per Call:   " + _realUnsubscribesPerCall + "\n" +
                           "Minimum Fake Subscriptions:   " + _minimumFakeSubscriptions + "\n" +
                           "Fake Unsubscribes per Call:   " + _fakeUnsubscribesPerCall + "\n" +
                           "Use Default Puids:            " + useStfPuids + "\n" +
                           "Change State Base Puid:       " + _changeStateBasePuid + "\n" +
                           "Change State Puid Count:      " + _changeStatePuidCount);

            // Set up basic presence blob that will be put into Acceleration
            unsafe
            {
                _basicPresenceDOS.wDataType = (ushort)DATA_TYPES.eBasicPresence;
                _basicPresenceDOS.dwDataSubType = 0;
                _basicPresenceDOS.wObjectSize = (ushort)(new BasicPresence()).Size();
                _basicPresenceDOS.qwOwnerXUID = 0;

                _basicPresenceBlob = new byte[_basicPresenceDOS.wObjectSize];
                fixed (byte* pData = _basicPresenceBlob)
                {
                    BASE_DATA_HEADER* pHeader = (BASE_DATA_HEADER*)pData;
                    pHeader->doSpec.wDataType = _basicPresenceDOS.wDataType;
                    pHeader->doSpec.dwDataSubType = _basicPresenceDOS.dwDataSubType;
                    pHeader->doSpec.wObjectSize = _basicPresenceDOS.wObjectSize;
                    pHeader->doSpec.qwOwnerXUID = _basicPresenceDOS.qwOwnerXUID;
                    pHeader->dwHeaderFlags = (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;
                    //pHeader->dwHeaderFlags = (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS;
                }
            }

            // Set up rich presence blob that will be put into Acceleration
            unsafe
            {
                byte[] richPresData = XConnSrvTestHelpers.BuildRichPresenceBlob(XConnSrvTestHelpers.defaultLocales, 0);

                _richPresenceDOS.wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                _richPresenceDOS.dwDataSubType = 0;
                _richPresenceDOS.wObjectSize = (ushort)(richPresData.Length + sizeof(BASE_DATA_HEADER));
                _richPresenceDOS.qwOwnerXUID = 0;

                // Create our final blob with header
                _richPresenceBlob = new byte[richPresData.Length + sizeof(BASE_DATA_HEADER)];
                System.Buffer.BlockCopy(richPresData, 0, _richPresenceBlob, sizeof(BASE_DATA_HEADER), richPresData.Length);

                // Not we must fill in the header
                fixed (byte* pData = _richPresenceBlob)
                {
                    BASE_DATA_HEADER* pHeader = (BASE_DATA_HEADER*)pData;
                    pHeader->doSpec.wDataType = _richPresenceDOS.wDataType;
                    pHeader->doSpec.dwDataSubType = _richPresenceDOS.dwDataSubType;
                    pHeader->doSpec.wObjectSize = _richPresenceDOS.wObjectSize;
                    pHeader->doSpec.qwOwnerXUID = _richPresenceDOS.qwOwnerXUID;
                    pHeader->dwHeaderFlags = (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | CacheUtil.XONLINE_CACHE_DATA_FLAG_LANGUAGE_SPECIFIC;
                    //pHeader->dwHeaderFlags = (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS | CacheUtil.XONLINE_CACHE_DATA_FLAG_LANGUAGE_SPECIFIC;
                }
            }
        }

        public void Connect()
        {
            _xbox = new PNXbox(true); // yes, please auto-process my notifications
            _xboxId = _xbox.XboxId;
            _realSubscriptionMin = 0;
            _realSubscriptionMax = 0;
            _fakeSubscriptionMin = 0;
            _fakeSubscriptionMax = 0;

            if (_connection != null)
            {
                _connection.Disconnect();
            }

            _connection = new PNConnection(_xboxId, false);
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.AddUser(_xboxId, _userId, _userFlags);

            IAsyncResult result = _connection.BeginConnect(_userIndices, _userIds, new AsyncCallback(OnConnect));
            StressConnSrvMessageQueue.Add(result);
        }

        public void Reconnect()
        {
            _realSubscriptionMin = 0;
            _realSubscriptionMax = 0;
            _fakeSubscriptionMin = 0;
            _fakeSubscriptionMax = 0;

            // This shouldn't happen, but just in case
            if (_connection == null)
                _connection = new PNConnection(_xboxId, false);

            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.AddUser(_xboxId, _userId, _userFlags);
            IAsyncResult result = _connection.BeginConnect(_userIndices, _userIds, true, new AsyncCallback(OnConnect));
            StressConnSrvMessageQueue.Add(result);
        }

        public void OnConnect(IAsyncResult asy)
        {
            try
            {
                _connection.OnConnect(asy);

                CONNECT_REPLY response = asy.AsyncState as CONNECT_REPLY;
                if (response.hr != 0)
                    Global.RO.Error("OnConnect hr: " + response.hr);
            }
            catch
            {
                DisconnectConnection();
            }
            finally
            {
                Return();
            }
        }

        public void Disconnect()
        {
            
            if (_connection != null && _connection.Connected)
            {
                DisconnectConnection();
            }

            Return();
        }

        private void DisconnectConnection()
        {
            try
            {
                _connection.Disconnect();
                _connection = null;
            }
            catch { }
        }

        public static void InsertBasicPresenceIntoCache(ulong userId)
        {
            _basicPresenceDOS.qwOwnerXUID = userId;
            unsafe
            {
                fixed (byte* pData = _basicPresenceBlob)
                {
                    BASE_DATA_HEADER* pHeader = (BASE_DATA_HEADER*)pData;
                    pHeader->doSpec.qwOwnerXUID = userId;
                }
            }

            MCServerNetwork._memCache.Set(CacheUtil.GetDataKeyString(_basicPresenceDOS), _basicPresenceBlob);
        }

        public static void InsertRichPresenceIntoCache(ulong userId)
        {
            _richPresenceDOS.qwOwnerXUID = userId;
            unsafe
            {
                fixed (byte* pData = _richPresenceBlob)
                {
                    BASE_DATA_HEADER* pHeader = (BASE_DATA_HEADER*)pData;
                    pHeader->doSpec.qwOwnerXUID = userId;
                }
            }

            MCServerNetwork._memCache.Set(CacheUtil.GetDataKeyString(_richPresenceDOS), _richPresenceBlob);
        }

        private int GetRealSubscriptionLength()
        {
            int length = 0;
            if (_realSubscriptionMin < _realSubscriptionMax)
            {
                length = _realSubscriptionMax - _realSubscriptionMin;
            }
            else if(_realSubscriptionMax < _realSubscriptionMin)
            {
                length = (StressUserList.puidCount + _realSubscriptionMax) - _realSubscriptionMin;
            }

            return length;
        }

        private int GetFakeSubscriptionLength()
        {
            int length = 0;
            if (_fakeSubscriptionMin < _fakeSubscriptionMax)
            {
                length = _fakeSubscriptionMax - _fakeSubscriptionMin;
            }
            else if (_fakeSubscriptionMax < _fakeSubscriptionMin)
            {
                length = (StressUserList.puidCount + _fakeSubscriptionMax) - _fakeSubscriptionMin;
            }

            return length;
        }

        private int ModifyRealSubscriptionMax(int difference)
        {
            _realSubscriptionMax = ((_realSubscriptionMax + difference) % StressUserList.puidCount);
            return _realSubscriptionMax;
        }

        private int ModifyRealSubscriptionMin(int difference)
        {
            _realSubscriptionMin = ((_realSubscriptionMin + difference) % StressUserList.puidCount);
            return _realSubscriptionMin;
        }

        private int ModifyFakeSubscriptionMax(int difference)
        {
            _fakeSubscriptionMax = ((_fakeSubscriptionMax + difference) % StressUserList.puidCount);
            return _fakeSubscriptionMax;
        }

        private int ModifyFakeSubscriptionMin(int difference)
        {
            _fakeSubscriptionMin = ((_fakeSubscriptionMin + difference) % StressUserList.puidCount);
            return _fakeSubscriptionMin;
        }

        public void Publish()
        {
            if (_connection != null && _connection.Connected)
            {
                byte[] dataAvatar = new byte[1000];
                byte[] dataBasicProfile = new byte[0];
                byte[][] data_basic = new byte[2][];
                data_basic[0] = dataAvatar;
                data_basic[1] = dataBasicProfile;

                DATA_OBJECT_SPECIFIER doSpec_avatar = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eAvatar, _userId);
                DATA_OBJECT_SPECIFIER doSpec_basicProfile = SubscriptionBuilder.GetDataObjectSpecifierForSingleUser(DATA_TYPES.eBasicProfile, _userId);
                DATA_OBJECT_SPECIFIER[] doSpecs_basic = new DATA_OBJECT_SPECIFIER[] { doSpec_avatar, doSpec_basicProfile };

                IAsyncResult result = _connection.BeginPublish(doSpecs_basic, data_basic, new AsyncCallback(OnPublish));
                StressConnSrvMessageQueue.Add(result);
            }
        }

        public void OnPublish(IAsyncResult asy)
        {
            Return();
        }


        public void Subscribe()
        {
            if (_connection != null && _connection.Connected)
            {

                // INVESTIGATION FOR INSERTING FRIENDS LIST MANUALLY
                // If this is our first time subscribing, we need to get the real friends list from Acceleration
                //if (_friendXuids == null)
                //{
                //    DATA_OBJECT_SPECIFIER friendsListDOS = new DATA_OBJECT_SPECIFIER();

                //    friendsListDOS.wDataType = (ushort)DATA_TYPES.eFriendsList;
                //    friendsListDOS.dwDataSubType = 0;
                //    friendsListDOS.wObjectSize = (ushort)(sizeof(USER_LIST_DATA) + sizeof(USER_DATA) * 100); // Max size
                //    friendsListDOS.qwOwnerXUID = 0;

                //    byte[] friendsListData = MCServerNetwork._memCache.Get(CacheUtil.GetDataKeyString(friendsListDOS));

                //    if (friendsListData.Length == 0)
                //    {
                //        Assert.IsTrue(false, "Friends List does not exist in Acceleration!");
                //    }
                //    else
                //    {
                //        unsafe
                //        {
                //            // Read the data



                //            m_cbData = sizeof(USER_LIST_DATA) + cdwFriends * sizeof(USER_DATA);
                //            m_pData = new BYTE[m_cbData];
                //            if (m_pData != NULL)
                //            {
                //                USER_LIST_DATA* pUserList = (USER_LIST_DATA*)m_pData;
                //                pUserList->doSpec.wObjectSize = (WORD)m_cbData;
                //                pUserList->doSpec.wDataType = eFriendsList;
                //                pUserList->doSpec.dwDataSubType = 0;
                //                pUserList->doSpec.qwOwnerXUID = qwUserID;
                //                pUserList->dwHeaderFlags = 0;
                //                pUserList->dwListVersion = dwListVersion;
                //                pUserList->dwNumUsers = cdwFriends;

                //                if (fShareEveryone) pUserList->dwHeaderFlags |= XONLINE_CONNSRV_DATA_FLAG_SHARE_EVERYONE;
                //                if (fShareFriends) pUserList->dwHeaderFlags |= XONLINE_CONNSRV_DATA_FLAG_SHARE_FRIENDS;

                //                USER_DATA* rgUsers = (USER_DATA*)(pUserList + 1);
                //                for (DWORD dwFriend = 0; dwFriend < cdwFriends; dwFriend++)
                //                {
                //                    rgUsers[dwFriend].qwXUID = rgFriends[dwFriend].GetBuddyID();
                //                    rgUsers[dwFriend].dwUserFlags = rgFriends[dwFriend].GetStatus();
                //                }
                //            }
                //        }
                //    }
                //}
                /////////////

                int numRealSubs = 0;
                int numFakeSubs = 0;

                // This is the first time we are subscribing, lets start at the puid after ours'
                if (_realSubscriptionMin == 0 && _realSubscriptionMax == 0)
                {
                    numRealSubs = _minimumRealSubscriptions;
                    _realSubscriptionMin = (int)(((_userId - StressUserList.basePuid) + 1) % (ulong)StressUserList.puidCount);
                    _realSubscriptionMax = _realSubscriptionMin;

                    numFakeSubs = _minimumFakeSubscriptions;
                    _fakeSubscriptionMin = _realSubscriptionMin;
                    _fakeSubscriptionMax = _fakeSubscriptionMin;
                }
                else
                {
                    numRealSubs = _minimumRealSubscriptions - GetRealSubscriptionLength();
                    numFakeSubs = _minimumFakeSubscriptions - GetFakeSubscriptionLength();
                }

                //Global.RO.Warn("/n" +
                //               "Real subscriptions made: " + numRealSubs +
                //               "Fake subscriptions made: " + numFakeSubs);

                // We double the subscription to account for both rich and basic subscriptions
                DATA_OBJECT_SPECIFIER[] subscribes = new DATA_OBJECT_SPECIFIER[(numRealSubs * 2) + (numFakeSubs * 2)];

                //
                // Real Subscriptions
                //
                for (int i = 0; i < numRealSubs; ++i)
                {
                    // Basic Presence
                    unsafe
                    {
                        subscribes[i * 2].wObjectSize = _basicPresenceDOS.wObjectSize;
                    }
                    subscribes[i * 2].qwOwnerXUID = StressUserList.basePuid + (ulong)ModifyRealSubscriptionMax(1);
                    subscribes[i * 2].wDataType = (ushort)DATA_TYPES.eBasicPresence;

                    //Rich Presence
                    unsafe
                    {
                        // TODO: This size is larger (whole blob) than expected (only english string) in the response.
                        subscribes[(i * 2) + 1].wObjectSize = _richPresenceDOS.wObjectSize;
                    }
                    subscribes[(i * 2)+ 1].qwOwnerXUID = subscribes[i * 2].qwOwnerXUID;
                    subscribes[(i * 2) + 1].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                }

                //
                // Fake Subscriptions
                //
                for (int i = numRealSubs; i < numRealSubs + numFakeSubs; ++i)
                {
                    // Basic Presence
                    unsafe
                    {
                        subscribes[i * 2].wObjectSize = _basicPresenceDOS.wObjectSize;
                    }
                    subscribes[i * 2].qwOwnerXUID = StressUserList.basePuid + _fakeBasePuidOffset + (ulong)ModifyFakeSubscriptionMax(1);
                    subscribes[i * 2].wDataType = (ushort)DATA_TYPES.eBasicPresence;

                    //Rich Presence
                    unsafe
                    {
                        // TODO: This size is larger (whole blob) than expected (only english string) in the response.
                        subscribes[(i * 2) + 1].wObjectSize = _richPresenceDOS.wObjectSize;
                    }
                    subscribes[(i * 2) + 1].qwOwnerXUID = subscribes[i * 2].qwOwnerXUID;
                    subscribes[(i * 2) + 1].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                }

                IAsyncResult result = _connection.BeginSubscribe(subscribes, SubNotiDefs.UserIndicesToFlags(_userIndices), 0, new AsyncCallback(OnSubscribe));
                StressConnSrvMessageQueue.Add(result);
            }
        }

        public void OnSubscribe(IAsyncResult asy)
        {
            try
            {
                //_connection.OnSubscribe(asy);
            }
            catch
            {
                DisconnectConnection();
            }
            finally
            {
                Return();
            }
        }

        public void Unsubscribe()
        {
            if (_connection != null && _connection.Connected /*&& GetSubscriptionLength() > 0*/)
            {
                // We double the unsubscription to account for both rich and basic subscriptions
                DATA_OBJECT_SPECIFIER[] unsubscribes = new DATA_OBJECT_SPECIFIER[(_realUnsubscribesPerCall * 2) + (_fakeUnsubscribesPerCall * 2)];

                //Global.RO.Warn("/n" +
                //               "Real unsubscriptions made: " + _realUnsubscribesPerCall +
                //               "Fake unsubscriptions made: " + _fakeUnsubscribesPerCall);

                //
                // Real Unsubscriptions
                //
                for (int i = 0; i < _realUnsubscribesPerCall; ++i)
                {
                    // Basic Presence
                    unsafe
                    {
                        unsubscribes[i * 2].wObjectSize = _basicPresenceDOS.wObjectSize;
                    }
                    unsubscribes[i * 2].qwOwnerXUID = StressUserList.basePuid + (ulong)ModifyRealSubscriptionMin(1);
                    unsubscribes[i * 2].wDataType = (ushort)DATA_TYPES.eBasicPresence;

                    //Rich Presence
                    unsafe
                    {
                        // TODO: This size is larger (whole blob) than expected (only english string) in the response.
                        unsubscribes[(i * 2) + 1].wObjectSize = _richPresenceDOS.wObjectSize;
                    }
                    unsubscribes[(i * 2) + 1].qwOwnerXUID = unsubscribes[i * 2].qwOwnerXUID;
                    unsubscribes[(i * 2) + 1].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                }

                //
                // Fake Unsubscriptions
                //
                for (int i = _realUnsubscribesPerCall; i < _realUnsubscribesPerCall + _fakeUnsubscribesPerCall; ++i)
                {
                    // Basic Presence
                    unsafe
                    {
                        unsubscribes[i * 2].wObjectSize = _basicPresenceDOS.wObjectSize;
                    }
                    unsubscribes[i * 2].qwOwnerXUID = StressUserList.basePuid + _fakeBasePuidOffset + (ulong)ModifyFakeSubscriptionMin(1);
                    unsubscribes[i * 2].wDataType = (ushort)DATA_TYPES.eBasicPresence;

                    //Rich Presence
                    unsafe
                    {
                        // TODO: This size is larger (whole blob) than expected (only english string) in the response.
                        unsubscribes[(i * 2) + 1].wObjectSize = _richPresenceDOS.wObjectSize;
                    }
                    unsubscribes[(i * 2) + 1].qwOwnerXUID = unsubscribes[i * 2].qwOwnerXUID;
                    unsubscribes[(i * 2) + 1].wDataType = (ushort)DATA_TYPES.eRichPresenceString;
                }

                IAsyncResult result = _connection.BeginUnsubscribe(unsubscribes, SubNotiDefs.UserIndicesToFlags(_userIndices), new AsyncCallback(OnUnsubscribe));
                StressConnSrvMessageQueue.Add(result);
            }
        }

        public void OnUnsubscribe(IAsyncResult asy)
        {
            try
            {
                //_connection.OnUnsubscribe(asy);
            }
            catch
            {
                DisconnectConnection();
            }
            finally
            {
                Return();
            }
        }

        public void Return()
        {
            if (_connection != null && _connection.Connected)
            {
                if (SubscriptionCount >= (_minimumRealSubscriptions + _minimumFakeSubscriptions))
                {
                    StressUserList.AddOnlineSubscribed(this);
                }
                else
                {
                    StressUserList.AddOnline(this);
                }
            }
            else
            {
                StressUserList.AddOffline(this);
            }
        }

        public ulong UserId
        {
            get
            {
                return _userId;
            }
        }

        public int SubscriptionCount
        {
            get
            {
                return GetRealSubscriptionLength() + GetFakeSubscriptionLength();
            }
        }

        public bool IsConnected
        {
            get
            {
                return _connection.Connected;
            }
        }

        public PNConnection Connection
        {
            get
            {
                return _connection;
            }
        }
	}

	////////////////////////////////////////////////
	// Stress User List 
	//	Manages the list of Stress Users
	//
	public class StressUserList
	{
        public static ulong basePuid = 0;
		public static int puidCount;
        static Queue Online = Queue.Synchronized(new Queue());
        static Queue OnlineSubscribed = Queue.Synchronized(new Queue());
        static Queue Offline = Queue.Synchronized(new Queue());
        static Queue Reconnect = Queue.Synchronized(new Queue()); // Users that need to reconnect because of a failure
        //static System.Collections.Specialized.NameValueCollection Subscribed = new System.Collections.Specialized.NameValueCollection();
        public static int RequiredMinimumSubscriptions = 1;


		static StressUserList()
		{
            BulkUserSet userSet = STFLiveGlobal.GetUserSet("xenon");
            puidCount = (int)userSet.Count;
            basePuid = userSet.Base;
			CPUIDList puidList = userSet.GetPuidList();

			for( int i = 0; i < puidList.GetSize(); ++i )
			{
                StressUser user = new StressUser( puidList[i] );
                Offline.Enqueue(user);
			}
		}

        public static void AddOnline(StressUser user)
        {
            lock (Online.SyncRoot)
            {
                Online.Enqueue(user);
            }
        }

        public static void AddOnlineSubscribed(StressUser user)
        {
            lock (OnlineSubscribed.SyncRoot)
            {
                OnlineSubscribed.Enqueue(user);
            }
        }

        public static void AddOffline(StressUser user)
        {
            lock (Offline.SyncRoot)
            {
                Offline.Enqueue(user);
            }
        }

        public static void AddReconnect(StressUser user)
        {
            lock (Reconnect.SyncRoot)
            {
                user.Connection.EstablishConnection();
                Reconnect.Enqueue(user);
            }
        }

        public static StressUser GetOffline()
        {
            StressUser[] users = GetOffline(1);
            if(users != null)
            {
                return users[0];
            }
            return null;
        }

        public static StressUser[] GetOffline(ushort NumUsers)
        {
            StressUser[] users = null;
            lock(Offline.SyncRoot)
            {
                if (Offline.Count >= NumUsers)
                {
                    users = new StressUser[NumUsers];
                    for (int iUser = 0; iUser < NumUsers; iUser++)
                    {
                        users[iUser] = (StressUser)Offline.Dequeue();
                    }
                }
            }
            return users;
        }

        public static StressUser GetReconnect()
        {
            StressUser[] users = GetReconnect(1);
            if (users != null)
            {
                return users[0];
            }
            return null;
        }

        public static StressUser[] GetReconnect(ushort NumUsers)
        {
            StressUser[] users = null;
            lock (Reconnect.SyncRoot)
            {
                if (Reconnect.Count >= NumUsers)
                {
                    users = new StressUser[NumUsers];
                    for (int iUser = 0; iUser < NumUsers; iUser++)
                    {
                        users[iUser] = (StressUser)Reconnect.Dequeue();
                    }
                }
            }
            return users;
        }

        public static StressUser GetOnline()
        {
            StressUser[] users = GetOnline(1);
            if(users != null)
            {
                return users[0];
            }
            return null;
        }

        public static StressUser[] GetOnline(ushort NumUsers)
        {
            StressUser[] users = null;
            lock (Online.SyncRoot)
            {
                if (Online.Count >= NumUsers)
                {
                    users = new StressUser[NumUsers];
                    for (int iUser = 0; iUser < NumUsers; iUser++)
                    {
                        try
                        {
                            StressUser user = (StressUser)Online.Dequeue();
                            if (user.IsConnected)
                                users[iUser] = user;
                            else
                            {
                                --iUser;
                                AddReconnect(user);
                            }
                        }
                        catch (InvalidOperationException /*e*/)
                        {
                            Global.RO.Warn("Ran out of users in the Online Queue.");
                            return null;
                        }
                    }
                }
            }
            return users;
        }

        public static StressUser GetOnlineSubscribed()
        {
            StressUser[] users = GetOnlineSubscribed(1);
            if (users != null)
            {
                return users[0];
            }
            return null;
        }

        public static StressUser[] GetOnlineSubscribed(ushort NumUsers)
        {
            StressUser[] users = null;
            lock (OnlineSubscribed.SyncRoot)
            {
                if (OnlineSubscribed.Count >= NumUsers)
                {
                    users = new StressUser[NumUsers];
                    for (int iUser = 0; iUser < NumUsers; iUser++)
                    {
                        try
                        {
                            StressUser user = (StressUser)OnlineSubscribed.Dequeue();
                            if (user.IsConnected)
                                users[iUser] = user;
                            else
                            {
                                --iUser;
                                AddReconnect(user);
                            }
                        }
                        catch (InvalidOperationException /*e*/) // If the queue is empty and we try to dequeue
                        {
                            Global.RO.Warn("Ran out of users in the Online+Subscribed Queue.");
                            return null;
                        }
                    }
                }
            }
            return users;
        }

        public static int OfflineCount()
        {
            return Offline.Count;
        }

        public static int OnlineCount()
        {
            return Online.Count;
        }

        public static int OnlineSubscribedCount()
        {
            return OnlineSubscribed.Count;
        }
        public static int ReconnectCount()
        {
            return Reconnect.Count;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\XConnSrvTest.cs ===
using System;
using System.Xml;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using ServerTestFramework;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol.SubNoti;
using ServerTestFramework.LiveService.XConnSrv;

[assembly: RootNode(typeof(XConnSrvTest.XConnSrvSuite))]

namespace XConnSrvTest
{
	/// <summary>
	/// <TestSuite>Connection Server Test Plan</TestSuite>
	///	<Tester>Paul Lyttle</Tester>
    ///	<Tester>Cody Luitjens</Tester>
    ///	<Tester>Shailesh Shah</Tester>
    ///	<Developer>Matt Childerston</Developer>
	///	<PM>TBD</PM>
	///	<Status>Draft</Status>
	/// </summary>
	///	<remarks>
	///	<Goal>Functional positive and negative test cases covering connection server features.</Goal>
	///	<NonGoal>nongoal</NonGoal>
	///	<Description>
	///		<p>
	///			Presence server previously was the one of two servers used for maintaining
	///		user state in Xbox Live. The current service has been combined into 
	///		a single server which handles presence records, messaging, notification and
	///		teams. The test suites for each portion of presence however will continue 
	///		be maintained as three seperate suites.
	///		</p>
	///
	///		<p>
	///			Presence functional tests cover all of the 'P' messages that are exposed 
	///		on the presence front door sans teams messages. These are as follows:
	///		</p>
	///
	///		<p>
	///		<table class="test_data">
    ///			<tr><td>Connect           </td><td>Accept a new socket connection to a connection server using connection protocol</td></tr>
    ///			<tr><td>Disconnect        </td><td>Disconnect via connection protocol and closes socket</td></tr>
    ///		</table>
	///		</p>
	/// </Description>
	/// </remarks>
    [Owner("shailesh"),/* TestFrequency("Daily"), TestCasePriority(3),*/ ServerTestFramework.Description("Connection Server - Presence notification test case")]
	public class XConnSrvSuite : TestNode
	{
        private static Report ro = new Report("UnhandledException");

		////////////////////////////////////////////////
		// Initialize
		//
        public override void PreRun(RUN_TYPE runType)
        {
            InstallAccelerationCounters();
            XomPerformanceCounterCategory.InitPerfCtrs();
            ProtocolConnectionCounters.InitPerfCtrs();

            UnhandledExceptionVortex.UnhandledException += new UnhandledExceptionEventHandler(UnhandledExceptionHandler);

            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence_int).ToString());
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                StressUser.Initialize();
            }

            // Initialize the fake mem cache
            // TODO: detect if the fake mem cache is
            // configured correctly on the server by sending a request
            // and verifying the round trip
            XConnSrvMemCache.Initialize();
        }

        public void UnhandledExceptionHandler(Object sender, UnhandledExceptionEventArgs e)
        {
            Object ex = e.ExceptionObject;
            ro.Debug(ex.ToString());
        }

        protected void InstallAccelerationCounters()
        {
            //Install Acceleration perf counters, here we run the installer locally and this should load the acceleration dll
            Hashtable hash = new Hashtable();
            xonline.common.mgmt.XomPerformanceCounterInstall xInstall = new xonline.common.mgmt.XomPerformanceCounterInstall();
            xInstall.Context = new System.Configuration.Install.InstallContext("localinstall.log", null);
            try
            {
                xInstall.Install(hash);
                xInstall.Commit(hash);
            }
            catch (Exception e)
            {
                Global.RO.Error(e.Message);
                Global.RO.Warn("Usually restarting stfgui should fix the error if counters cannot be installed the first time...");
            }
        }
	}

    [RunInstaller(true)]
    public class XConnSrvTestInstaller :
        XomPerformanceCounterInstall
    {
        public override void Install(IDictionary stateSaver)
        {
            // needs stflive in the working directory.  
            // TODO:  How to load it from parent directory?
            InstallCategory(Type.GetType("ServerTestFramework.LiveService.XConnSrv.ProtocolConnectionCounters,stflive"));
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\FuncSubscribe.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace XConnSrvTest
{
    /// <summary>
    /// Functional Tests for Subscribe
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncSubscribe_PostiveCases : TestNode
    {
        /// <summary>
        /// Basic BVT test which subscribes and unsubscribes a single user from basic and rich presence
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class BVT_Subscribe : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;

                ulong[] UserIds = new ulong[] { users[0].UserId };
                int[] UserIndices = new int[] { 0 };

                // Connect at UserIndex 0 
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, UserIndices, UserIds, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Offline_Friends = 5;
                builder.Online_Friends = 5;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscribes_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscribes_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Friends);

                // Subscribe to basic presence and verify
                SUBSCRIBE_REPLY subscribereply_basic = connection.Subscribe(subscribes_basic);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_basic, subscribereply_basic))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe to rich presence and verify
                SUBSCRIBE_REPLY subscribereply_rich = connection.Subscribe(subscribes_rich);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscribes_rich, subscribereply_rich))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe from rich presence and verify
                UNSUBSCRIBE_REPLY unsubrep_rich = connection.Unsubscribe(subscribes_rich, UserIndices);
                if (HResult.Failed((uint)unsubrep_rich.hr))
                    throw new HResultException((uint)unsubrep_rich.hr, "Unsubscribe Failed");

                // Unsubscribe from basic presence and verify
                UNSUBSCRIBE_REPLY unsubrep_basic = connection.Unsubscribe(subscribes_basic, UserIndices);
                if (HResult.Failed((uint)unsubrep_basic.hr))
                    throw new HResultException((uint)unsubrep_basic.hr, "Unsubscribe Failed");

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection, UserIndices))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users, one at a time, and makes the same subscriptions for all of them,
        /// then unsubscribes 1 user at a time
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class SubscribeUnsubscribeIndividually : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;
                // Create subscription
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                for (int i = 0; i < users.Length; ++i)
                {
                    int[] userIndices = new int[i + 1];
                    ulong[] userIds = new ulong[i + 1];

                    for (int j = 0; j <= i; ++j)
                    {
                        userIndices[j] = j;
                        userIds[j] = users[j].UserId;
                    }

                    // Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    // Subscribe
                    
                    SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscriptions, new int[] { i });

                    // Verify expected data in reply is correct
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscriptions, subscriptionReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Unsubscribe 1 user at a time
                for (int i = 0; i < users.Length; ++i)
                {
                    int[] userIndicesDisconnect = new int[] { i };
                    ulong[] userIdsDisconnect = new ulong[] { users[i].UserId };

                    UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscriptions, userIndicesDisconnect);
                    
                    // Verify correct unsubscriptions
                    XConnSrvTestHelpers.VerifyUnsubscription(users[i].UserId, subscriptions, unsubscribeReply);

                    ulong[] sub = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[i].UserId, DATA_TYPES.eBasicPresence);
                    //Assert.IsTrue(sub.Length == 0); //failing.
                    // TODO: check others.
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Adds one user at a time to the existing connection, creating the same subscriptions
        /// for everyone connected, then unsubscribes all 4 users with a single call
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class UnsubscribeAllUsersLoggedOn : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                int[] userIndices = null;
                ulong[] userIds = null;

                for (int i = 0; i < users.Length; ++i)
                {
                    userIndices = new int[i + 1];
                    userIds = new ulong[i + 1];

                    for (int j = 0; j <= i; ++j)
                    {
                        userIndices[j] = j;
                        userIds[j] = users[j].UserId;
                    }

                    // Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    // Subscribe
                    SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscriptions, new int[] { i });

                    // Verify expected data in reply is correct
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscriptions, subscriptionReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Ubsubscribe everyone connected
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscriptions, userIndices);

                // Verify correct unsubscriptions
                for (int i = 0; i < users.Length; ++i)
                {
                    XConnSrvTestHelpers.VerifyUnsubscription(users[i].UserId, subscriptions, unsubscribeReply);
                    XConnSrvTestHelpers.VerifyUnsubscription(users[i].UserId, subscriptions, unsubscribeReply);
                    ulong[] sub = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[i].UserId, DATA_TYPES.eBasicPresence);
                    Assert.IsTrue(sub.Length == 0);
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class SubscribeUnsubscribeUserPairsAtATime2 : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                int[] userIndices = new int[XConnSrvTestHelpers.MAX_LOGON_USERS];
                ulong[] userIds = new ulong[XConnSrvTestHelpers.MAX_LOGON_USERS];

                for (int j = 0; j < XConnSrvTestHelpers.MAX_LOGON_USERS; ++j)
                {
                    userIndices[j] = j;
                    userIds[j] = users[j].UserId;
                }

                // Create subscriptions for users 0 and 2
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(new PNUser[] { users[0], users[2] });
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Create subscriptions for users 1 and 3
                PNUsersBuilder builder2 = new PNUsersBuilder();
                builder2.Online_Friends = 5;
                builder2.CreateUsers(new PNUser[] { users[1], users[3] });
                DATA_OBJECT_SPECIFIER[] subscriptions2 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder2.Friends);

                // Unsubscribe users 1 and 3
                UNSUBSCRIBE_REPLY unsubscribeReply2 = connection.Unsubscribe(subscriptions, new int[] { 1, 3 });
                users[1].Xbox.SendUnsubscribeForUser(users[1].UserId, subscriptions, out unsubscribeReply2);
                XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscriptions2, unsubscribeReply2);
                ulong[] sub = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);

                users[3].Xbox.SendUnsubscribeForUser(users[3].UserId, subscriptions, out unsubscribeReply2);
                XConnSrvTestHelpers.VerifyUnsubscription(users[3].UserId, subscriptions2, unsubscribeReply2);
                sub = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[3].UserId, DATA_TYPES.eBasicPresence);

                users[0].Xbox.SendUnsubscribeForUser(users[0].UserId, subscriptions, out unsubscribeReply2);
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscriptions2, unsubscribeReply2);
                sub = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);

                users[2].Xbox.SendUnsubscribeForUser(users[2].UserId, subscriptions, out unsubscribeReply2);
                XConnSrvTestHelpers.VerifyUnsubscription(users[2].UserId, subscriptions2, unsubscribeReply2);
                sub = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[2].UserId, DATA_TYPES.eBasicPresence);

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users and subscriptions in pairs (0+2, 1+3), then unsubscribes 2 users at a time (1+3, 0+2)
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class SubscribeUnsubscribeUserPairsAtATime : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                int[] userIndices = new int[XConnSrvTestHelpers.MAX_LOGON_USERS];
                ulong[] userIds = new ulong[XConnSrvTestHelpers.MAX_LOGON_USERS];

                for (int j = 0; j < XConnSrvTestHelpers.MAX_LOGON_USERS; ++j)
                {
                    userIndices[j] = j;
                    userIds[j] = users[j].UserId;
                }


                // Create subscriptions for users 0 and 2
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(new PNUser[] { users[0], users[2] });
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe only to users 0 and 2 and verify
                SUBSCRIBE_REPLY subscriptionsReply = connection.Subscribe(subscriptions, new int[] { 0, 2 });

                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscriptionsReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[2].UserId, subscriptions, subscriptionsReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscriptions for users 1 and 3
                PNUsersBuilder builder2 = new PNUsersBuilder();
                builder2.Online_Friends = 5;
                builder2.CreateUsers(new PNUser[] { users[1], users[3] });
                DATA_OBJECT_SPECIFIER[] subscriptions2 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder2.Friends);

                // Subscribe only to users 1 and 3 and verify
                SUBSCRIBE_REPLY subscriptionsReply2 = connection.Subscribe(subscriptions2, new int[] { 1, 3 });

                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscriptions2, subscriptionsReply2))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[3].UserId, subscriptions2, subscriptionsReply2))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe users 1 and 3
                UNSUBSCRIBE_REPLY unsubscribeReply2 = connection.Unsubscribe(subscriptions, new int[] { 1, 3 });

                // Verify correct remaining subscriptions for all 4 users
                for (int i = 0; i < users.Length; ++i)
                {
                    if (i == 1 || i == 3)
                    {
                        XConnSrvTestHelpers.VerifyUnsubscription(users[i].UserId, subscriptions2, unsubscribeReply2);
                        ulong[] sub = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[i].UserId, DATA_TYPES.eBasicPresence);
                        //Assert.IsTrue(sub.Length == 0);
                    }
                    else
                    {
                        ulong[] sub = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                        //TODO: Need proper verification. right now  this will fetch subs for entire connection.
                        //Assert.IsTrue(sub.Length == subscriptions.Length);
                    }
                }

                // Unsubscribe users 0 and 2
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscriptions, new int[] { 0, 2 });

                // Verify correct unsubscriptions for remaining users
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscriptions, unsubscribeReply);
                ulong[] sub_user0 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                //Assert.IsTrue(sub_user0.Length == 0);

                XConnSrvTestHelpers.VerifyUnsubscription(users[2].UserId, subscriptions, unsubscribeReply);
                ulong[] sub_user2 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[2].UserId, DATA_TYPES.eBasicPresence);
                //Assert.IsTrue(sub_user2.Length == 0);

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Gives 1 user multiple subscriptions, but only unsubscribes from a partial set of the subscriptions
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class UnsubscribePartial : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect user
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create 2 subscriptions
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscriptions_basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscriptions_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Friends);

                DATA_OBJECT_SPECIFIER[] subscriptions = new DATA_OBJECT_SPECIFIER[2];
                subscriptions[0] = subscriptions_basic[0];
                subscriptions[1] = subscriptions_rich[0];

                // Subscribe
                SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscriptions);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscriptionReply))
                    ResultCode = TEST_RESULTS.FAILED;

                ulong[] sub_basic = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_basic.Length == 1);
                ulong[] sub_rich = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eRichPresenceString);
                Assert.IsTrue(sub_rich.Length == 1);

                // Ubsubscribe from only the subscriptions_basic
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscriptions_basic);

                // Verify correct unsubscriptions (basic subscription removed, rich remains)
                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscriptions, unsubscribeReply);
                ulong[] sub_basic_removed = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_basic_removed.Length == 0);

                ulong[] sub_rich_remains = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eRichPresenceString);
                Assert.IsTrue(sub_rich_remains.Length == 1);

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 2 users and makes the same subscriptions for both of them, then unsubscribes only 1 user
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class Subscribe2UsersUnsubscribe1 : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscriptions
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Peers = 5;
                builder.CreateUsers(new PNUser[] { users[0], users[1] });
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Peers);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions);

                // Verify subscriptions
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscriptions, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe only user 1
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscriptions, new int[] { 1 });

                // Verify correct unsubscriptions (user 1 totally removed, user 0 fully remains subscribed)
                XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscriptions, unsubscribeReply);
                ulong[] sub_user1 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                //TODO: Assert.IsTrue(sub_user1.Length == 0);

                ulong[] sub_user0 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user0.Length == subscriptions.Length);

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 2 users make the same subscriptions/unsubscriptions from different consoles
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class SubscribeUnsubscribeSameFromDifferentConsoles : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection1 = null;
                PNConnection connection2 = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                connection1 = users[0].Xbox.ConnectionServerConnection;
                connection2 = users[1].Xbox.ConnectionServerConnection;

                // Connect user 1 to index 0 on console 1
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection1, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Connect user 2 to index 0 on console 2
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection2, HResult.S_OK, new int[] { 0 }, new ulong[] { users[1].UserId }, users[1].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscriptions
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(new PNUser[] { users[0], users[1] });
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe with user 0
                SUBSCRIBE_REPLY subscribe0Reply = connection1.Subscribe(subscriptions);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscribe0Reply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe with user 1
                SUBSCRIBE_REPLY subscribe1Reply = connection2.Subscribe(subscriptions);
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscriptions, subscribe1Reply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe user 1
                UNSUBSCRIBE_REPLY unsubscribe1Reply = connection1.Unsubscribe(subscriptions);

                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscriptions, unsubscribe1Reply);
                ulong[] sub_user0 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user0.Length == 0);

                ulong[] sub_user1_verify = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user1_verify.Length == subscriptions.Length);

                // Unsubscribe user 2
                UNSUBSCRIBE_REPLY unsubscribe2Reply = connection2.Unsubscribe(subscriptions);

                XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscriptions, unsubscribe2Reply);
                ulong[] sub_user1 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user1.Length == 0);

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection1))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection2))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 2 users make overlapping (some same, some different) subscriptions/unsubscriptions from different consoles
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class SubscribeUnsubscribeOverlappedFromDifferentConsoles : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection1 = null;
                PNConnection connection2 = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, false);
                connection1 = users[0].Xbox.ConnectionServerConnection;
                connection2 = users[1].Xbox.ConnectionServerConnection;

                // Connect user 0 to index 0 on console 1
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection1, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Connect user 1 to index 0 on console 2
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection2, HResult.S_OK, new int[] { 0 }, new ulong[] { users[1].UserId }, users[1].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscriptions for user 0
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscriptions_user0 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Create subscriptiosn for user 1, create 3 new subscriptions and use 2 that user 0 has (overlap)
                PNUsersBuilder builder2 = new PNUsersBuilder();
                builder2.Online_Friends = 3;
                builder2.CreateUsers(users[1]);
                DATA_OBJECT_SPECIFIER[] subscriptions_partial_user1 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder2.Friends);

                DATA_OBJECT_SPECIFIER[] subscriptions_user1 = new DATA_OBJECT_SPECIFIER[5];
                subscriptions_user1[0] = subscriptions_partial_user1[0];
                subscriptions_user1[1] = subscriptions_partial_user1[1];
                subscriptions_user1[2] = subscriptions_partial_user1[2];
                subscriptions_user1[3] = subscriptions_user0[3];
                subscriptions_user1[4] = subscriptions_user0[4];

                // Subscribe with user 0 and verify
                SUBSCRIBE_REPLY subscribeReply = connection1.Subscribe(subscriptions_user0);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions_user0, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe with user 1 and verify
                SUBSCRIBE_REPLY subscribe1Reply = connection2.Subscribe(subscriptions_user1);
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscriptions_user1, subscribe1Reply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe user 0 and verify user 1 wasn't affected
                UNSUBSCRIBE_REPLY unsubscribeReply = connection1.Unsubscribe(subscriptions_user0);

                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscriptions_user0, unsubscribeReply);
                ulong[] sub_user0 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user0.Length == 0);

                ulong[] sub_user1_confirm = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user1_confirm.Length == subscriptions_user1.Length);

                // Unsubscribe user 1
                UNSUBSCRIBE_REPLY unsubscribe1Reply = connection2.Unsubscribe(subscriptions_user1);
                XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscriptions_user1, unsubscribe1Reply);
                ulong[] sub_user1 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user1.Length == 0);

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection1))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection2))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 2 users make overlapping (some same, some different) subscriptions/unsubscriptions from same console
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class SubscribeUnsubscribeOverlappedFromSameConsoles : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscriptions for user 0
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscriptions_user0 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Create subscriptiosn for user 1, create 3 new subscriptions and use 2 that user 0 has (overlap)
                PNUsersBuilder builder2 = new PNUsersBuilder();
                builder2.Online_Friends = 3;
                builder2.CreateUsers(users[1]);
                DATA_OBJECT_SPECIFIER[] subscriptions_partial_user1 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder2.Friends);
                DATA_OBJECT_SPECIFIER[] subscriptions_partial_user1_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder2.Friends);

                //unsubscribe first.
                UNSUBSCRIBE_REPLY u1 = connection.Unsubscribe(subscriptions_partial_user1, new int[] { 1 });
                UNSUBSCRIBE_REPLY u2 = connection.Unsubscribe(subscriptions_partial_user1_rich, new int[] { 1 });
                XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscriptions_partial_user1, u1);
                XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscriptions_partial_user1_rich, u2);
                ulong[] len1 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(len1.Length == 0);
                ulong[] len2 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eRichPresenceString);
                Assert.IsTrue(len2.Length == 0);

                DATA_OBJECT_SPECIFIER[] subscriptions_user1 = new DATA_OBJECT_SPECIFIER[5];
                subscriptions_user1[0] = subscriptions_partial_user1[0];
                subscriptions_user1[1] = subscriptions_partial_user1[1];
                subscriptions_user1[2] = subscriptions_partial_user1[2];
                subscriptions_user1[3] = subscriptions_user0[3];
                subscriptions_user1[4] = subscriptions_user0[4];

                // Subscribe with user 0 and verify
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions_user0, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions_user0, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe with user 1 and verify
                SUBSCRIBE_REPLY subscribe1Reply = connection.Subscribe(subscriptions_user1, new int[] { 1 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscriptions_user1, subscribe1Reply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Unsubscribe user 0 and verify user 1 wasn't affected
                UNSUBSCRIBE_REPLY unsubscribeReply = connection.Unsubscribe(subscriptions_user0, new int[] { 0 });

                XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, subscriptions_user0, unsubscribeReply);
                ulong[] sub_user0 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                //Assert.IsTrue(sub_user0.Length == 0);

                ulong[] sub_user1_confirm = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user1_confirm.Length == subscriptions_user1.Length);

                // Unsubscribe user 1
                UNSUBSCRIBE_REPLY unsubscribe1Reply = connection.Unsubscribe(subscriptions_user1, new int[] { 1 });
                XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscriptions_user1, unsubscribe1Reply);
                ulong[] sub_user1 = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user1.Length == 0);

                //Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }


        /// <summary>
        /// Connects 2 users and makes the same subscriptions for both of them, then disconnects 1 user at a time
        /// and confirms the subscriptions are torn down
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class UnsubscribeWhenDisconnect : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscriptions
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(new PNUser[] { users[0], users[1] });
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptions, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscriptions, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Send new connect with only user 0, thus disconnecting user 1
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify existing subscriptions for user 0 are still valid and that user 1's subscriptions are gone
                ulong[] sub_user0_confirm = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);
                Assert.IsTrue(sub_user0_confirm.Length == subscriptions.Length);

                Assert.IsTrue(! XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "Should not be connected");

                // TODO: Confirm user 1's subscriptions have been torn down

                // Disconnect, which will remove the connection, and should clean up user 0's subscriptions
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                Assert.IsTrue(!XConnSrvTestHelpers.IsUserConnected(users[1].UserId, 1), "Should not be connected");

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }
        
        /// <summary>
        /// Connects 4 users at then subscribes one user at a time absolutely to a different subscription, then
        /// confirms that user is subscribed
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class SubscribeAbsoluteOneAtATimeDiffSub : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = XConnSrvTestHelpers.MAX_LOGON_USERS;
                builder.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                for (int i = 0; i < users.Length; ++i)
                {
                    int[] userIndices = new int[i + 1];
                    ulong[] userIds = new ulong[i + 1];

                    for (int j = 0; j <= i; ++j)
                    {
                        userIndices[j] = j;
                        userIds[j] = users[j].UserId;
                    }

                    // Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    // Subscribe
                    SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(new DATA_OBJECT_SPECIFIER[] { subscriptions[i] }, new int[] { i }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);

                    // Verify expected data in reply is correct
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, new DATA_OBJECT_SPECIFIER[] { subscriptions[i] }, subscriptionReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Confirm that each user has only one subscription
                for (int i = 0; i < users.Length; ++i)
                {
                    if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[i].UserId, DATA_TYPES.eBasicPresence).Length != 1)
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users and then subscribes one user at a time absolutely to the same subscription, then
        /// confirms that all users have their correct subscriptions
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class SubscribeAbsoluteOneAtATimeSameSub : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                for (int i = 0; i < users.Length; ++i)
                {
                    int[] userIndices = new int[i + 1];
                    ulong[] userIds = new ulong[i + 1];

                    for (int j = 0; j <= i; ++j)
                    {
                        userIndices[j] = j;
                        userIds[j] = users[j].UserId;
                    }

                    // Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    // Subscribe
                    SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscriptions, new int[] { i }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);

                    // Verify expected data in reply is correct
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscriptions, subscriptionReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Confirm that everyone has only one subscription
                for (int j = 0; j < users.Length; ++j)
                {
                    if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[j].UserId, DATA_TYPES.eBasicPresence).Length != subscriptions.Length)
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users and then subscribes the first 3 one user at a time to the same subscription, then
        /// subscribes the 4th user absolutely to the same thing and verifies everyone has the correct subscriptions
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class Subscribe3Same1SameAbsoluteLast : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 1;
                builder.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe one user at a time, for all users but the last, but must connect all 4
                for (int i = 0; i < users.Length; ++i)
                {
                    int[] userIndices = new int[i + 1];
                    ulong[] userIds = new ulong[i + 1];

                    for (int j = 0; j <= i; ++j)
                    {
                        userIndices[j] = j;
                        userIds[j] = users[j].UserId;
                    }

                    // Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (i < users.Length - 1)
                    {
                        // Subscribe
                        SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscription, new int[] { i });

                        // Verify expected data in reply is correct
                        if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscription, subscriptionReply))
                            ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Subscribe the final user absolutely (should remove all other subscriptions)
                SUBSCRIBE_REPLY subscriptionReplyAb = connection.Subscribe(subscription, new int[] { users.Length - 1 }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[users.Length - 1].UserId, subscription, subscriptionReplyAb))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify that everyone has only one subscription
                for (int i = 0; i < users.Length; ++i)
                {
                    if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[i].UserId, DATA_TYPES.eBasicPresence).Length != 1)
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users and then subscribes the first 3 one user at a time to the same subscription, then
        /// subscribes the 4th user absolutely to something else and verifies everyone has a subscription
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class Subscribe3Same1DiffAbsoluteLast : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 2;
                builder.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscriptions_rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Friends);
                connection.Unsubscribe(subscriptions, new int[] { 0, 1, 2, 3 });
                connection.Unsubscribe(subscriptions_rich, new int[] { 0, 1, 2, 3 });

                DATA_OBJECT_SPECIFIER[] subscription1 = new DATA_OBJECT_SPECIFIER[] { subscriptions[0] };
                DATA_OBJECT_SPECIFIER[] subscription2 = new DATA_OBJECT_SPECIFIER[] { subscriptions[1] };

                // Subscribe one user at a time, for all users but the last, but must connect all 4
                for (int i = 0; i < users.Length; ++i)
                {
                    int[] userIndices = new int[i + 1];
                    ulong[] userIds = new ulong[i + 1];

                    for (int j = 0; j <= i; ++j)
                    {
                        userIndices[j] = j;
                        userIds[j] = users[j].UserId;
                    }

                    // Connect
                    if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (i < users.Length - 1)
                    {
                        // Subscribe
                        SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscription1, new int[] { i });

                        // Verify expected data in reply is correct
                        if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscription1, subscriptionReply))
                            ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                // Subscribe the final user absolutely (different from the others though)
                SUBSCRIBE_REPLY subscriptionReplyAb = connection.Subscribe(subscription2, new int[] { users.Length - 1 }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[users.Length - 1].UserId, subscription2, subscriptionReplyAb))
                    ResultCode = TEST_RESULTS.FAILED;

                // Confirm that every user still has 1 subscription
                for (int i = 0; i < users.Length; ++i)
                {
                    if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[i].UserId, DATA_TYPES.eBasicPresence).Length != 1)
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users and then subscribes the first 2 users absolutely, then 2 normally and confirms all
        /// 4 still have valid subscriptions
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SubscribeAbsoluteFirst : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 1;
                builder.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                int[] userIndices = new int[XConnSrvTestHelpers.MAX_LOGON_USERS];
                ulong[] userIds = new ulong[XConnSrvTestHelpers.MAX_LOGON_USERS];

                for (int i = 0; i < users.Length; ++i)
                {
                    userIndices[i] = i;
                    userIds[i] = users[i].UserId;
                }

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe absolutely for users 0 and 1
                SUBSCRIBE_REPLY subscriptionReplyAb = connection.Subscribe(subscription, new int[] { 0, 1 }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscriptionReplyAb))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscription, subscriptionReplyAb))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe to the final 2 users normally
                SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscription, new int[] { 2, 3 });

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[2].UserId, subscription, subscriptionReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[3].UserId, subscription, subscriptionReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Confirm that everyone has subscriptions
                for (int i = 0; i < users.Length; ++i)
                {
                    if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[i].UserId, DATA_TYPES.eBasicPresence).Length != subscription.Length)
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects 4 users and subscribes all 4 to the same 2 subscriptions, then subscribes only 2 users
        /// absolutely to 1 of the 2 previous subscriptions
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SubscribeNormalAllAbsolutePartial : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscription
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 2;
                builder.CreateUsers(users);
                DATA_OBJECT_SPECIFIER[] subscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscription2only = new DATA_OBJECT_SPECIFIER[] { subscriptions[1] };

                int[] userIndices = new int[XConnSrvTestHelpers.MAX_LOGON_USERS];
                ulong[] userIds = new ulong[XConnSrvTestHelpers.MAX_LOGON_USERS];

                for (int i = 0; i < users.Length; ++i)
                {
                    userIndices[i] = i;
                    userIds[i] = users[i].UserId;
                }

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe to 2 subscriptions for all 4 users
                SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscriptions);

                // Verify expected data in reply is correct
                for (int i = 0; i < users.Length; ++i)
                {
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscriptions, subscriptionReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Re-subscribe to only the 2nd subscription for the first 2 users only
                // (This should remove the 2nd subscription from users 2 and 3, but leave the first subscription for all 4)
                SUBSCRIBE_REPLY subscriptionReplyAb = connection.Subscribe(subscription2only, new int[] { 0, 1 }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription2only, subscriptionReplyAb))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, subscription2only, subscriptionReplyAb))
                    ResultCode = TEST_RESULTS.FAILED;

                // Confirm that everyone has the correct subscriptions
                for (int i = 0; i < users.Length; ++i)
                {
                    int expectedSubscriptionLength = (i == 0 || i == 1) ? subscription2only.Length : subscriptions.Length;
                    if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[i].UserId, DATA_TYPES.eBasicPresence).Length != expectedSubscriptionLength)
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// This test tries to simulate a real set of subscription calls by doing the following:
        ///  - Connect user0
        ///  - user0 subscribes to 4 friends
        ///  - user0 subscribes to 2 more items
        ///  - user0 subscribes to 7 total items absolutely (6 old, 1 new)
        ///  - user0 subscribes to 2 more items
        ///  - user0 unsubscribes from all
        ///  - user0 disconnects
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class SubscribeMixedSquence : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscriptions
                //PNUsersBuilder builder = new PNUsersBuilder();
                //builder.Online_Friends = 4;
                //builder.CreateRequiredSubscribees();
                //builder.AddSubscriberPNUser(users[0]);
                //DATA_OBJECT_SPECIFIER[] subscriptionFirst4 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence);
                //builder.Online_Friends = 2;
                //builder.Online_Friends = 2;
                //builder.CreateRequiredSubscribees();
                //DATA_OBJECT_SPECIFIER[] subscriptionSecond2 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence);
                //builder.Online_Friends = 1;
                //builder.CreateRequiredSubscribees();
                //DATA_OBJECT_SPECIFIER[] subscriptionThird1 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence);
                //builder.Online_Friends = 2;
                //builder.CreateRequiredSubscribees();
                //DATA_OBJECT_SPECIFIER[] subscriptionFourth2 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence);

                PNUser[] friends;
                FriendsCommon fc = new FriendsCommon();
                //Get 4 friends
                friends = PNUsersBuilder.GetLiveXenonUsers(4, true, true);
                fc.MakeFriends(users[0], friends);
                DATA_OBJECT_SPECIFIER[] subscriptionFirst4 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friends);
                //Get 2 more friends.
                friends = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                fc.MakeFriends(users[0], friends);
                DATA_OBJECT_SPECIFIER[] subscriptionSecond2 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friends);
                //Get 1 more.
                friends = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                fc.MakeFriends(users[0], friends);
                DATA_OBJECT_SPECIFIER[] subscriptionThird1 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friends);
                //Get 2 more.
                friends = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                fc.MakeFriends(users[0], friends);
                DATA_OBJECT_SPECIFIER[] subscriptionFourth2 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, friends);
                
                DATA_OBJECT_SPECIFIER[] subscriptionAbsolute = new DATA_OBJECT_SPECIFIER[7];
                subscriptionAbsolute[0] = subscriptionFirst4[0];
                subscriptionAbsolute[1] = subscriptionFirst4[1];
                subscriptionAbsolute[2] = subscriptionFirst4[2];
                subscriptionAbsolute[3] = subscriptionFirst4[3];
                subscriptionAbsolute[4] = subscriptionSecond2[0];
                subscriptionAbsolute[5] = subscriptionSecond2[1];
                subscriptionAbsolute[6] = subscriptionThird1[0];

                // Subscribe normally - First (4 subscriptions) - and verify
                SUBSCRIBE_REPLY subscriptionReplyFirst = connection.Subscribe(subscriptionFirst4, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptionFirst4, subscriptionReplyFirst))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe normally - Second (2 subscriptions) - and verify
                SUBSCRIBE_REPLY subscriptionReplySecond = connection.Subscribe(subscriptionSecond2, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptionSecond2, subscriptionReplySecond))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe absolute - (7 subscriptions - 6 old, 1 new) - and verify
                SUBSCRIBE_REPLY subscriptionReplyAbs = connection.Subscribe(subscriptionAbsolute, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptionAbsolute, subscriptionReplyAbs))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe normally - Fourth (2 subscriptions) - and verify
                SUBSCRIBE_REPLY subscriptionReplyFourth = connection.Subscribe(subscriptionFourth2, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptionFourth2, subscriptionReplyFourth))
                    ResultCode = TEST_RESULTS.FAILED;

                // Confirm that there are 9 subscriptions total
                if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence).Length != 9)
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// A single user connects and subscribes to one item, then subscribes absolutely to an empty list
        /// and verifies all previous subscriptions were removed
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class Subscribe0UsersAbsolute : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, false);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create regular and empty subscriptions
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 4;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription1 = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscriptionEmpty = new DATA_OBJECT_SPECIFIER[0];

                // Subscribe normally and verify
                SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscription1, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription1, subscriptionReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Confirm we have 1 subscription
                if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence).Length != subscription1.Length)
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe absolutely and verify
                SUBSCRIBE_REPLY subscriptionEmptyReply = connection.Subscribe(subscriptionEmpty, new int[] { 0 }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptionEmpty, subscriptionEmptyReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify there are no subscriptions remaining. (Since we said absolutely we want 0 subscriptions)
                if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence).Length != 0)
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Subscribe to a subset of the data (smaller wObjectSize)
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class SubscribeSmallerObjSize : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create regular subscription, and a copy that has a smaller object size
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] subscriptionSmaller = new DATA_OBJECT_SPECIFIER[] { subscription[0] };
                subscriptionSmaller[0].wObjectSize = 22;

                // Subscribe normally and verify we got back the correct size
                SUBSCRIBE_REPLY subscriptionReply = connection.Subscribe(subscriptionSmaller, new int[] { 0 });
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscriptionSmaller, subscriptionReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Confirm we have 1 subscription
                if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence).Length != subscriptionSmaller.Length)
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates a single user and sends 2 identical subscriptions after each other
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class SubscribeMultipleSame : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create a subscription array with 2 of the same item in it
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 1;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] basic_subscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe first time
                SUBSCRIBE_REPLY subscribeReply1 = connection.Subscribe(basic_subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basic_subscription, subscribeReply1))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe second time
                SUBSCRIBE_REPLY subscribeReply2 = connection.Subscribe(basic_subscription);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basic_subscription, subscribeReply2))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify that there is only 1 subscription
                ulong[] user0_basic_subscriptions = XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence);

                if (user0_basic_subscriptions.Length != 1)
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates and connects 4 users and then subscribes each user to the other 3 users on the xbox
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SubscribeToUsersOnSameConsole : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(XConnSrvTestHelpers.MAX_LOGON_USERS, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                int[] userIndices = new int[XConnSrvTestHelpers.MAX_LOGON_USERS];
                ulong[] userIds = new ulong[XConnSrvTestHelpers.MAX_LOGON_USERS];

                for (int j = 0; j < XConnSrvTestHelpers.MAX_LOGON_USERS; ++j)
                {
                    userIndices[j] = j;
                    userIds[j] = users[j].UserId;
                }

                // Connect users
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, userIndices, userIds, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                for (int i = 0; i < XConnSrvTestHelpers.MAX_LOGON_USERS; ++i)
                {
                    // Create subscription manually
                    DATA_OBJECT_SPECIFIER[] subscriptions = new DATA_OBJECT_SPECIFIER[XConnSrvTestHelpers.MAX_LOGON_USERS - 1];
                    int dosIndex = 0;
                    for (int j = 0; j < XConnSrvTestHelpers.MAX_LOGON_USERS; ++j)
                    {
                        if (j != i)
                        {
                            subscriptions[dosIndex].wObjectSize = (ushort)(new BasicPresence()).Size();
                            subscriptions[dosIndex].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                            subscriptions[dosIndex].dwDataSubType = 0;
                            subscriptions[dosIndex].qwOwnerXUID = users[j].UserId;

                            ++dosIndex;
                        }
                    }

                    // Subscribe
                    SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscriptions, new int[] { i });

                    // Verify expected data in reply is correct
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscriptions, subscribeReply))
                        ResultCode = TEST_RESULTS.FAILED;

                    if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                        ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// <summary>
        /// Creates a single user and subscribes to both Basic and Rich Presence of several users, then subscribes
        /// absolutely to only Basic presence and verifies the Rich Presence subscriptions were torn down
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class SubscribeAbsolutelyToSubsetOfUser : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect users
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscriptions
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 2;
                builder.Offline_Friends = 2;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] basicSubscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);
                DATA_OBJECT_SPECIFIER[] richSubscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, builder.Friends);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basicSubscription, new int[] { 0 });

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicSubscription, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe to rich
                SUBSCRIBE_REPLY richSubscribeReply = connection.Subscribe(richSubscription, new int[] { 0 });

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscription, richSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Subscribe to basic absolutely (should remove rich subscriptions)
                SUBSCRIBE_REPLY basicSubscribeReplyAb = connection.Subscribe(basicSubscription, new int[] { 0 }, SubNotiDefs.XONLINE_CONNSRV_SUBSCRIBE_ABSOLUTE_SYNC);

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicSubscription, basicSubscribeReplyAb))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify that there are the correct number of subscriptions
                if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence).Length != basicSubscription.Length)
                    ResultCode = TEST_RESULTS.FAILED;
                if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eRichPresenceString).Length != 0)
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects a single user and subscribes to himself
        /// 
        /// Note: This is currently not possible on the client since it checks for a self subscription
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class SubscribeToSelf : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Connect user
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[0].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Create subscription manually
                DATA_OBJECT_SPECIFIER[] subscription = new DATA_OBJECT_SPECIFIER[1];
                subscription[0].wObjectSize = (ushort)(new BasicPresence()).Size();
                subscription[0].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                subscription[0].dwDataSubType = 0;
                subscription[0].qwOwnerXUID = users[0].UserId;

                // Subscribe
                SUBSCRIBE_REPLY subscribeReply = connection.Subscribe(subscription, new int[] { 0 });

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, subscription, subscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Connects a single user on a connection and makes subscriptions. Then a different user logs onto
        /// the same index, booting off the previous user, and confirms the previous user's subscriptions
        /// were tore down as well
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public class SubscriptionsRemovedWhenUserChanges : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                // Create subscriptions
                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 5;
                builder.Offline_Friends = 5;
                builder.CreateUsers(users[0]);
                DATA_OBJECT_SPECIFIER[] basicSubscription = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, builder.Friends);

                // Subscribe to basic
                SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basicSubscription, new int[] { 0 });

                // Verify expected data in reply is correct
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicSubscription, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify that there are the correct number of subscriptions
                if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[0].UserId, DATA_TYPES.eBasicPresence).Length != basicSubscription.Length)
                    ResultCode = TEST_RESULTS.FAILED;

                // Connect other user at the same index, disconnecting the previous
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { users[1].UserId }, users[1].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                // Verify that the new user has no subscriptions
                // TODO? There is no way to see subscriptions for an invalid user id
                if (XConnSrvTestHelpers.GetXmgmtSubscriptionInfoForUser(users[1].UserId, DATA_TYPES.eBasicPresence).Length != 0)
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// Creates the maximum number of subscriptions possible for a single connection.
        /// 100 friends * 4 users + 800 other peers (basic + rich each)
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        [Ignore("out of 100 MakeFriends call, it surely fails on one of them..:(")]
        public class MaximumSubscriptions : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                PNConnection connection = null;
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);
                connection = users[0].Xbox.ConnectionServerConnection;


                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 50;
                builder.Offline_Friends = 49;
                builder.Online_Peers = 400;
                builder.Offline_Peers = 400;
                builder.CreateUsers(users);

                PNUser[] totalUsers = new PNUser[builder.Friends.Length + builder.Peers.Length];
                Array.Copy(builder.Friends, 0, totalUsers, 0, builder.Friends.Length);
                Array.Copy(builder.Peers, 0, totalUsers, builder.Friends.Length, builder.Peers.Length);

                DATA_OBJECT_SPECIFIER[] basicSubscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, totalUsers);
                DATA_OBJECT_SPECIFIER[] richSubscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, totalUsers);

                Global.RO.Info("900 users created.");

                // Subscribe to basic presence and verify
                SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basicSubscriptions);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicSubscriptions, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, basicSubscriptions, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[2].UserId, basicSubscriptions, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[3].UserId, basicSubscriptions, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("Basic Presence subscriptions made and verified.");

                // Subscribe to rich presence and verify
                SUBSCRIBE_REPLY richSubscribeReply = connection.Subscribe(richSubscriptions);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, richSubscriptions, richSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, richSubscriptions, richSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[2].UserId, richSubscriptions, richSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[3].UserId, richSubscriptions, richSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("Rich Presence subscriptions made and verified.");

                // Unsubscribe from rich presence and verify
                UNSUBSCRIBE_REPLY richUnsubscribeReply = connection.Unsubscribe(richSubscriptions);
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, richSubscriptions, richUnsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, richSubscriptions, richUnsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[2].UserId, richSubscriptions, richUnsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[3].UserId, richSubscriptions, richUnsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("Rich Presence unsubscribed from and verified.");

                // Unsubscribe from basic presence and verify
                UNSUBSCRIBE_REPLY basicUnsubscribeReply = connection.Unsubscribe(basicSubscriptions);
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[0].UserId, basicSubscriptions, basicUnsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, basicSubscriptions, basicUnsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[2].UserId, basicSubscriptions, basicUnsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[3].UserId, basicSubscriptions, basicUnsubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info("Basic Presence unsubscribed from and verified.");

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(1), AsyncGroup(0)]
        public class SubscribeMaxObjectsPerMessage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint maxObjectPerMessage = uint.Parse(Global.XEnv.GetSetting("XConnSrv_MaxObjectsPerMessage"));

                PNConnection connection = null;
                PNUser testuser = PNUsersBuilder.GetLiveXenonUsers(1, true, false)[0];

                // Connect users
                Assert.IsTrue( XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { testuser.UserId }, testuser.Xbox.XboxId));

                //create 1000 users
                PNUser[] bulkusers = PNUsersBuilder.GetLiveXenonUsers(maxObjectPerMessage, true, false);

                DATA_OBJECT_SPECIFIER[] basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, bulkusers);
                DATA_OBJECT_SPECIFIER[] rich = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, bulkusers);

                SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basic, new int[] { 0 });
                //Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(testuser.UserId, basic, basicSubscribeReply));
                Assert.IsTrue(HResult.S_OK == (uint)basicSubscribeReply.hr, "Subscribe successful.");

                SUBSCRIBE_REPLY richSubscribeReply = connection.Subscribe(rich, new int[] { 0 });
                Assert.IsTrue(HResult.S_OK == (uint)richSubscribeReply.hr, "Subscribe successful.");
            } 
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), AsyncGroup(0)]
        public class SubscribeMaxSubPerConnection : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                uint maxSubsPerConnection = uint.Parse(Global.XEnv.GetSetting("XConnSrv_MaxSubscriptionsPerConnection"));

                PNConnection connection = null;
                PNUser testuser = PNUsersBuilder.GetLiveXenonUsers(1, true, false)[0];

                // Connect users
                Assert.IsTrue(XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0 }, new ulong[] { testuser.UserId }, testuser.Xbox.XboxId));
                int total =0;
                uint increment = 100;
                while (total < maxSubsPerConnection)
                {
                    total = (int)(total + increment);
                    PNUser[] bulkusers = PNUsersBuilder.GetLiveXenonUsers(increment, true, false);
                    DATA_OBJECT_SPECIFIER[] basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, bulkusers);
                    SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basic, new int[] { 0 });
                    Assert.IsTrue(HResult.S_OK == (uint)basicSubscribeReply.hr, "Subscribe successful.");
                    Assert.IsTrue(basicSubscribeReply.rgDataObjects.Length == increment, "basicSubscribeReply.rgDataObjects.Length: " + basicSubscribeReply.rgDataObjects.Length + " --- increment: " + increment);
                    Global.RO.Info("Subscribed : " + total);
                }
            }
        }

        /// <summary>
        /// Connects 2 users, makes subscriptions for each user, then sends the connect message again, and verifies that
        /// the subscriptions still remain
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public class SendConnectPairAfterSubscribe : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.NOT_EXECUTED;
                PNConnection connection = null;

                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(2, true, true);
                connection = users[0].Xbox.ConnectionServerConnection;

                PNUsersBuilder builder = new PNUsersBuilder();
                builder.Online_Friends = 4;
                builder.Offline_Peers = 4;
                builder.CreateUsers(users);

                PNUser[] totalUsers = new PNUser[builder.Friends.Length + builder.Peers.Length];
                Array.Copy(builder.Friends, 0, totalUsers, 0, builder.Friends.Length);
                Array.Copy(builder.Peers, 0, totalUsers, builder.Friends.Length, builder.Peers.Length);

                DATA_OBJECT_SPECIFIER[] basicSubscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, totalUsers);
                DATA_OBJECT_SPECIFIER[] richSubscriptions = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eRichPresenceString, totalUsers);

                connection.Unsubscribe(basicSubscriptions);
                connection.Unsubscribe(richSubscriptions);

                // Subscribe to basic presence and verify
                SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basicSubscriptions);
                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicSubscriptions, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, basicSubscriptions, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Connect both users again
                if (!XConnSrvTestHelpers.TryConnectAndVerify(ref connection, HResult.S_OK, new int[] { 0, 1 }, new ulong[] { users[0].UserId, users[1].UserId }, users[0].Xbox.XboxId))
                    ResultCode = TEST_RESULTS.FAILED;

                if (!XConnSrvTestHelpers.VerifySubscription(users[0].UserId, basicSubscriptions, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;
                if (!XConnSrvTestHelpers.VerifySubscription(users[1].UserId, basicSubscriptions, basicSubscribeReply))
                    ResultCode = TEST_RESULTS.FAILED;

                // Disconnect
                if (!XConnSrvTestHelpers.TryDisconnectAndVerify(connection))
                    ResultCode = TEST_RESULTS.FAILED;

                if (ResultCode != TEST_RESULTS.FAILED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// This test is meant to reproduce a bug. If users 0-3 subscribe to user 4, in order, then if user 2 unsubscribes,
        /// followed by user 1, and then a notification is triggered, only user 3 will get a notification, not user 0.
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
        public class Unsubscribe2InMiddleInvalidatesSubscriptionList : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                // Create five users, each on a different Xbox
                PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(5, true, false, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE, true);

                // Create basic DOS subscription to user 4
                DATA_OBJECT_SPECIFIER[] subscription = new DATA_OBJECT_SPECIFIER[1];

                subscription[0].wObjectSize = (ushort)(new BasicPresence()).Size();
                subscription[0].wDataType = (ushort)DATA_TYPES.eBasicPresence;
                subscription[0].dwDataSubType = 0;
                subscription[0].qwOwnerXUID = users[4].UserId;

                // Have users 0-3 subscribe to 4
                for (int i = 0; i < 4; ++i)
                {
                    SUBSCRIBE_REPLY subscriptionReply = users[i].Xbox.ConnectionServerConnection.Subscribe(subscription, new int[] { 0 });
                    if (!XConnSrvTestHelpers.VerifySubscription(users[i].UserId, subscription, subscriptionReply))
                        ResultCode = TEST_RESULTS.FAILED;
                }

                // Unsubscribe users 2 and then 1, so only 0 and 3 remain
                UNSUBSCRIBE_REPLY unsubscribeReply2 = users[2].Xbox.ConnectionServerConnection.Unsubscribe(subscription);
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[2].UserId, subscription, unsubscribeReply2))
                    ResultCode = TEST_RESULTS.FAILED;

                UNSUBSCRIBE_REPLY unsubscribeReply1 = users[1].Xbox.ConnectionServerConnection.Unsubscribe(subscription);
                if (!XConnSrvTestHelpers.VerifyUnsubscription(users[1].UserId, subscription, unsubscribeReply1))
                    ResultCode = TEST_RESULTS.FAILED;

                System.Threading.Thread.Sleep(1000);

                users[0].Xbox.ConnectionServerConnection.ClearNotificationRecievedList();
                users[3].Xbox.ConnectionServerConnection.ClearNotificationRecievedList();

                System.Threading.Thread.Sleep(1000);

                // Logon user so that presence blobs are inserted and notifications triggered
                FriendsCommon fc = new FriendsCommon();
                fc.LogoffUser(users[4]);
                Thread.Sleep(2000);

                // Verify the corrent number of notifications were received
                if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(users[0].Xbox.ConnectionServerConnection, 1, 1))
                    Assert.IsTrue(false, "Incorrect number of notifications received.");
                else
                    Global.RO.Info("" + users[0].Xbox.ConnectionServerConnection.GetTotalNotificationsLength() + " notifications received.");

                if (!XConnSrvTestHelpers.VerifyTotalNotificationsReceived(users[3].Xbox.ConnectionServerConnection, 1, 1))
                    Assert.IsTrue(false, "Incorrect number of notifications received.");
                else
                    Global.RO.Info("" + users[3].Xbox.ConnectionServerConnection.GetTotalNotificationsLength() + " notifications received.");

                if (ResultCode == TEST_RESULTS.NOT_EXECUTED)
                    ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public class MultiplePeopleSubscriedToOneGuy : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;
                PNConnection connection = null;

                FriendsCommon fc = new FriendsCommon();
                PNUser user = fc.CreateXenonUser(true);
                fc.LogoffUser(user);

                DATA_OBJECT_SPECIFIER[] basic = SubscriptionBuilder.GetDataObjectSpecifierArrayForUsers(DATA_TYPES.eBasicPresence, new PNUser[] { user });

                PNUser[] people = fc.CreateXenonUsers(100, true);

                for (int i = 0; i< people.Length; i++)
                {
                    connection = people[i].Xbox.ConnectionServerConnection;
                    SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basic);
                    Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(people[i].UserId, basic, basicSubscribeReply), "Subscription verified.");
                }

                string xmgmtOutput = XConnSrvTestHelpers.RunXmgmtCommand("showsubscribers", user.UserId, "eBasicPresence:" + Hexer.tohex(user.UserId) + ":0:1");
                Assert.IsTrue(xmgmtOutput.StartsWith("100"));

                fc.LogonUser(user);
                Thread.Sleep(10000);

                for (int i = 0; i < people.Length; i++)
                {
                    connection = people[i].Xbox.ConnectionServerConnection;
                    Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1, 2), "Received notification.");
                }

                fc.LogoffUser(user);
                Thread.Sleep(10000);

                //log off 0-9 and 90-99
                for (int i = 0; i < 10; i++)
                    fc.LogoffUser(people[i]);
                for (int i=90;i<100;i++)
                    fc.LogoffUser(people[i]);
                for (int i=40;i<50;i++)
                    fc.LogoffUser(people[i]);

                for (int i = 0; i < people.Length; i++)
                {
                    if (people[i].LoggedOn)
                    {
                        connection = people[i].Xbox.ConnectionServerConnection;
                        connection.ClearNotificationRecievedList();
                    }
                }

                xmgmtOutput = XConnSrvTestHelpers.RunXmgmtCommand("showsubscribers", user.UserId, "eBasicPresence:" + Hexer.tohex(user.UserId) + ":0:1");
                Assert.IsTrue(xmgmtOutput.StartsWith("70"));

                fc.LogonUser(user);
                Thread.Sleep(10000);
                
                for (int i = 0; i < people.Length; i++)
                {
                    if (people[i].LoggedOn)
                    {
                        connection = people[i].Xbox.ConnectionServerConnection;
                        Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1), "Received notification.");
                    }
                }

                fc.LogoffUser(user);
                Thread.Sleep(10000);

                for (int i = 0; i < people.Length; i++)
                {
                    if (!people[i].LoggedOn)
                    {
                        fc.LogonUser(people[i]);
                        connection = people[i].Xbox.ConnectionServerConnection;
                        SUBSCRIBE_REPLY basicSubscribeReply = connection.Subscribe(basic);
                        Assert.IsTrue(XConnSrvTestHelpers.VerifySubscription(people[i].UserId, basic, basicSubscribeReply), "Subscription verified.");
                    }
                }

                //clear list.
                for (int i = 0; i < people.Length; i++)
                {
                    if (people[i].LoggedOn)
                    {
                        connection = people[i].Xbox.ConnectionServerConnection;
                        connection.ClearNotificationRecievedList();
                    }
                }

                xmgmtOutput = XConnSrvTestHelpers.RunXmgmtCommand("showsubscribers", user.UserId, "eBasicPresence:" + Hexer.tohex(user.UserId) + ":0:1");
                Assert.IsTrue(xmgmtOutput.StartsWith("100"));

                fc.LogonUser(user);
                Thread.Sleep(10000);

                for (int i = 0; i < 100; i++)
                {
                    connection = people[i].Xbox.ConnectionServerConnection;
                    Assert.IsTrue(XConnSrvTestHelpers.VerifyTotalNotificationsReceived(connection, 1), "Received notification.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\CryptoKeyBase.cs ===
using System;
using System.Security.Cryptography;

using xonline.common.service;

namespace xonline.server.xcrypto.fd
{
    public class CryptoKey : IDisposable
    {
        public CryptoKey(KeyInfo ki)
        {
            _disposed = false;

            CspParameters cspParams = new CspParameters();
            cspParams.ProviderName = ki.Provider;
            cspParams.KeyContainerName = ki.Container;
            cspParams.KeyNumber = ki.KeyNumber;
            cspParams.ProviderType = PROV_RSA_FULL;
            cspParams.Flags = CspProviderFlags.NoPrompt | CspProviderFlags.UseMachineKeyStore | CspProviderFlags.UseExistingKey;

            try
            {
                // As long as this is the last thing we do, we don't need to worry about disposing during our constructor
                // since this is the only thing we actually dispose.
                _provider = new RSACryptoServiceProvider(cspParams);
            }
            catch (Exception e)
            {
                throw new XRLException( HResult.XONLINE_E_XCRYPTO_KEY_ERROR,
                                        XEvent.Id.XCRYPTO_CRYPTO_KEY_ERROR, 
                                        e, 
                                        "Error loading RSACryptoServiceProvider: Unable to load KeyNumber:{0} in container '{1}', using provider '{2}'", 
                                        cspParams.KeyNumber, 
                                        cspParams.KeyContainerName, 
                                        cspParams.ProviderName);
            }
        }

        public byte[] Sign(byte[] sha1)
        {
            VerifyByteArrayLen(sha1, 20, true, "sha1");

            byte[] signature = _provider.SignHash(sha1, SHA_OID);

            // http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.aspx
            // *Interoperation with the Microsoft Cryptographic API (CAPI)*
            // Unlike the RSA implementation in unmanaged CAPI, the RSACryptoServiceProvider class reverses the
            // order of an encrypted array of bytes after encryption and before decryption. By default, data 
            // encrypted by the RSACryptoServiceProvider class cannot be decrypted by the CAPI CryptDecrypt 
            // function and data encrypted by the CAPI CryptEncrypt method cannot be decrypted by the 
            // RSACryptoServiceProvider class.
            //
            // Since we used to implement this with p/Invoke calls into the native CAPI, we reverse the signature
            // in both sign and verify. This makes it work with both the native and managed versions.
            Array.Reverse(signature);

            return signature;
        }

        public bool VerifySignature(byte[] sha1, byte[] sig)
        {
            VerifyByteArrayLen(sha1, 20, true, "sha1");

            // http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.aspx
            // *Interoperation with the Microsoft Cryptographic API (CAPI)*
            // Unlike the RSA implementation in unmanaged CAPI, the RSACryptoServiceProvider class reverses the
            // order of an encrypted array of bytes after encryption and before decryption. By default, data 
            // encrypted by the RSACryptoServiceProvider class cannot be decrypted by the CAPI CryptDecrypt 
            // function and data encrypted by the CAPI CryptEncrypt method cannot be decrypted by the 
            // RSACryptoServiceProvider class.
            //
            // Since we used to implement this with p/Invoke calls into the native CAPI, we reverse the signature
            // in both sign and verify. This makes it work with both the native and managed versions.
            //
            // We don't want to muck with the caller's array...
            byte[] localSig = new byte[sig.Length];
            Array.Copy(sig, localSig, sig.Length);
            Array.Reverse(localSig);
            sig = null; // Now we will throw an exception if we use this in the future, rather than having a subtle bug.

            // In light of CL 582970, this line is what the equivalent of what would cause DC requests in that bug
            // so instead of specifying the SHA1_OID, passing in null, as that is the default.
            return _provider.VerifyHash(sha1, null, localSig);
        }

        public byte[] Decrypt(byte[] cipher)
        {
            // NOTE: This may or may not apply. I'm guessing it does--we'll see.
            //
            // http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.aspx
            // *Interoperation with the Microsoft Cryptographic API (CAPI)*
            // Unlike the RSA implementation in unmanaged CAPI, the RSACryptoServiceProvider class reverses the
            // order of an encrypted array of bytes after encryption and before decryption. By default, data 
            // encrypted by the RSACryptoServiceProvider class cannot be decrypted by the CAPI CryptDecrypt 
            // function and data encrypted by the CAPI CryptEncrypt method cannot be decrypted by the 
            // RSACryptoServiceProvider class.
            //
            // Since we used to implement this with p/Invoke calls into the native CAPI, we reverse the signature
            // in both sign and verify. This makes it work with both the native and managed versions.
            //
            // We don't want to muck with the caller's array...
            byte[] localCipher = (byte[])cipher.Clone();
            Array.Reverse(localCipher);
            cipher = null; // Now we will throw an exception if we use this in the future, rather than having a subtle bug.

            return _provider.Decrypt(localCipher, true /*fOAEP--controls padding; not positive this is correct*/);
        }

        public byte[] Encrypt(byte[] data)
        {
            // NOTE: This may or may not apply. I'm guessing it does--we'll see.
            //
            // http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.aspx
            // *Interoperation with the Microsoft Cryptographic API (CAPI)*
            // Unlike the RSA implementation in unmanaged CAPI, the RSACryptoServiceProvider class reverses the
            // order of an encrypted array of bytes after encryption and before decryption. By default, data 
            // encrypted by the RSACryptoServiceProvider class cannot be decrypted by the CAPI CryptDecrypt 
            // function and data encrypted by the CAPI CryptEncrypt method cannot be decrypted by the 
            // RSACryptoServiceProvider class.
            //
            // Since we used to implement this with p/Invoke calls into the native CAPI, we reverse the signature
            // in both encrypt and decrypt. This makes it work with both the native and managed versions.
            //
            // We don't want to muck with the caller's array...
            byte[] localData = (byte[])data.Clone();
            data = null; // Now we will throw an exception if we use this in the future, rather than having a subtle bug.

            byte[] encryptedArray = _provider.Encrypt(localData, true);
            Array.Reverse(encryptedArray);

            return encryptedArray;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~CryptoKey()
        {
            Dispose(false);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (_provider != null)
                {
                    _provider.Clear();
                }
                _disposed = true;
            }
        }

        private void VerifyByteArrayLen(byte[] bytes, int minLen, bool exact, string name)
        {
            if (exact)
            {
                if (bytes.Length != minLen)
                {
                    throw new XRLExceptionWithoutEvent( HResult.E_INVALIDARG, 
                                                        "{0} has length of {1}, but it must be exactly {2}.", 
                                                        name, 
                                                        bytes.Length, 
                                                        minLen );
                }
            }
            else
            {
                if (bytes.Length < minLen)
                {
                    throw new XRLExceptionWithoutEvent( HResult.E_INVALIDARG, 
                                                        "{0} has length of {1}, but it must be at least {2}.", 
                                                        name, 
                                                        bytes.Length, 
                                                        minLen );
                }
            }
        }

        private const int PROV_RSA_FULL = 1;
        private static string SHA_OID = CryptoConfig.MapNameToOID("SHA1");
        private readonly RSACryptoServiceProvider _provider;
        private bool _disposed;            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\Block_NCipher.cs ===
using System;
using System.Collections.Specialized;
using System.Security.Cryptography;

using xonline.common.xcrypto;
using xonline.common.health;


namespace xonline.server.xcrypto.fd
{
    internal class NCipher : IHealthBlock
    {
        public ResourceTypeEnum ResourceType { get { return ResourceTypeEnum.Remote; } }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            CryptoKeyCache.TestCryptoKeyCache();

            byte[] hash = GenerateHash();

            EContainerClasses[] containerClasses = new EContainerClasses[] {EContainerClasses.Drm, EContainerClasses.Asset };
            foreach (EContainerClasses containerClass in containerClasses)
            {
                CryptoKey key = CryptoKeyCache.Cache.GetCryptoKey(containerClass);

                try
                {
                    if (!TestSigningKey(key, hash))
                    {
                        report.HealthStatus = HealthStatusEnum.Red;
                        report.ErrorDetails = String.Format("Unable to sign and verify signature with container class {0}.", containerClass);
                        return;
                    }
                }
                catch (CryptographicException ce)
                {
                    report.HealthStatus = HealthStatusEnum.Red;
                    report.ErrorDetails = String.Format("Error accessing container class {0}.\r\n{1}", containerClass, ce.ToString());
                    return;
                }
            }

            report.HealthStatus = HealthStatusEnum.Green;
        }

        private static byte[] GenerateHash()
        {
            Random rand = new Random();
            byte[] data = new byte[1024];
            rand.NextBytes(data);
            SHA1Managed sha1 = new SHA1Managed();
            return sha1.ComputeHash(data);
        }

        private static bool TestSigningKey(CryptoKey key, byte[] hash)
        {
            byte[] sig = key.Sign(hash);
            return key.VerifySignature(hash, sig);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\CryptoSettings.cs ===
using System;
using xonline.common.config;
using xonline.common.xcrypto;
using xonline.common.service;

namespace xonline.server.xcrypto.fd
{
    public static class CryptoSettings
    {
        public static void CacheCurrentSettings()
        {
            _useNCipher = KeyTypeSettingsUtil.UseNCipher;
            _useTestKey = KeyTypeSettingsUtil.UseTestKey;
            _useXMacsKey = KeyTypeSettingsUtil.UseXMacsKey;

            ValidateSettings();
        }

        private static void ValidateSettings()
        {
            if (!_useNCipher && !_useTestKey)
            {
                throw new XRLException( HResult.XONLINE_E_XCRYPTO_CONFIG_ERROR, 
                                        XEvent.Id.XCRYPTO_CONFIG_ERROR, 
                                        "We're using production keys, but not nCipher. This cannot possibly be intended." );
            }
        }

        public static bool UseNCipher { get { return _useNCipher; } }
        public static bool UseTestKey { get { return _useTestKey; } }
        public static bool UseXMacsKey { get { return _useXMacsKey; } }

        private static bool _useNCipher = false;
        private static bool _useTestKey = false;
        private static bool _useXMacsKey = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\KeyBlobs.cs ===
using System;

namespace xonline.server.xcrypto.fd
{
    public static class TestKeyBlobs
    {
        /*
    
        This is the format of the key bytes below.
    
        KEY_HEADER:
            BYTE    bType;                  // PRIVATEKEYBLOB = 0x07
            BYTE    bVersion;               // 0x02
            WORD    reserved;               // 0x00,0x00
            DWORD   aiKeyAlg;               // can be either of the following:
                CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE   |ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0x24,0x00,0x00
                CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0xA4,0x00,0x00
            DWORD   magic;                  // RSA_PRIV_MAGIC = 0x52,0x53,0x41,0x32 (0x32415352)
            DWORD   bitlen;                 // # of bits in modulus = 0x00,0x08,0x00,0x00
            DWORD   pubexp;                 // public exponent = 0x03,0x00,0x00,0x00
        MODULUS DATA FOLLOWS
    
        */

        public static byte[] testXMacsKeyPrvEnc = new byte[1172]
        {
                0x07,0x02,0x00,0x00,0x00,0xA4,0x00,0x00, 0x52,0x53,0x41,0x32,0x00,0x08,0x00,0x00,
                0x03,0x00,0x00,0x00,0xFB,0x37,0x45,0x77, 0xFB,0xDF,0xC9,0xD8,0x74,0x53,0xA4,0x98,
                0x0F,0x45,0x0D,0x14,0xD3,0x09,0x29,0x2C, 0xF6,0x2F,0x71,0xBD,0xDE,0x10,0xCA,0xF6,
                0xF8,0x7A,0x9B,0xCE,0x6F,0x39,0xA7,0xBF, 0x2B,0x37,0x73,0x1A,0x8D,0x45,0x36,0x4C,
                0xA3,0xC2,0x1A,0xC7,0x92,0x60,0xE1,0xDE, 0xC0,0xEC,0x69,0xF1,0x02,0xFD,0x23,0xA4,
                0x9E,0xF5,0xDE,0xED,0x4F,0x35,0xEF,0xD8, 0x11,0x0C,0x52,0x2F,0x1E,0x1A,0xC3,0x86,
                0x0E,0xC8,0x8F,0x80,0x91,0xFA,0xBE,0x7A, 0x85,0x3D,0x58,0xF7,0x2A,0x6F,0x24,0x92,
                0x1F,0xEC,0xA5,0xB5,0xC9,0x1D,0x5F,0x3C, 0x2F,0x02,0x0F,0xF3,0xF9,0x36,0x85,0xF9,
                0x1F,0x5F,0xFA,0x83,0x26,0xA3,0xCD,0x05, 0x8C,0x31,0x94,0xF0,0xC5,0x89,0x1A,0x24,
                0x23,0x8A,0x2E,0x57,0x23,0xDC,0x1C,0x65, 0x81,0x1D,0x2A,0xCD,0xF1,0xA2,0xC3,0xFC,
                0xC5,0x36,0x53,0x7B,0xC8,0x69,0xF9,0x54, 0x89,0xE1,0x6A,0xB5,0xA4,0x75,0x19,0xAF,
                0x89,0xA9,0x27,0x4F,0x47,0xF0,0xCD,0xD6, 0x72,0x88,0xAF,0x68,0xB5,0xCC,0xB4,0x85,
                0xC3,0x16,0xBA,0x4B,0xF8,0x49,0xBF,0x9A, 0x85,0xC3,0x11,0xE1,0x84,0xFE,0x53,0x03,
                0x55,0x18,0xDC,0x74,0xBB,0x16,0xEB,0x0F, 0x97,0xC5,0xE1,0xAF,0xFE,0x34,0x76,0x90,
                0xF3,0xD6,0x06,0xF4,0x90,0xA9,0x15,0xB2, 0xF5,0xE8,0x91,0x81,0xE5,0x8E,0xA2,0x68,
                0xEB,0x93,0x07,0x12,0x0E,0x48,0x63,0x0E, 0x6F,0xA5,0xF8,0x52,0x62,0xB1,0x1B,0x02,
                0xE4,0x8F,0x08,0x05,0x22,0x41,0x77,0x08, 0x14,0xEF,0x05,0xD7,0x38,0x23,0x5B,0x5A,
                0x89,0x83,0xA3,0xA3,0x1D,0x1E,0x0E,0x52, 0xD1,0x94,0xB9,0x2F,0xD9,0x10,0x77,0x82,
                0x0E,0xBC,0x16,0xB3,0x59,0x79,0xCC,0xE9, 0x6B,0x71,0x95,0xF6,0x36,0xEC,0x68,0xF9,
                0xC1,0x13,0xB4,0xE4,0x09,0xAE,0x0F,0x62, 0xE0,0x5D,0xC3,0x69,0x42,0x92,0x35,0xE5,
                0xC7,0xD2,0x34,0x70,0x2F,0x8B,0x91,0x27, 0x2C,0x9D,0xF9,0xE8,0x32,0x2E,0x20,0x7D,
                0x54,0x85,0xC6,0x8D,0xCD,0xE8,0xE6,0x82, 0x64,0xDE,0xC1,0x90,0x26,0x1C,0xDB,0x04,
                0xF1,0xF2,0xA8,0x88,0x4E,0x0B,0x15,0x09, 0xE9,0xE1,0x02,0x6E,0xF3,0xCE,0x47,0x88,
                0x03,0xF4,0x5B,0x99,0xCD,0x1F,0x9B,0xAC, 0x4F,0x2E,0xB0,0x56,0x8D,0x58,0xA8,0xDB,
                0x99,0xBF,0x4E,0x34,0x3C,0x0F,0x45,0x8A, 0xF5,0xEB,0xD6,0x79,0xC9,0x71,0xEC,0x28,
                0x47,0xD1,0x24,0xD5,0xF7,0xB2,0xAE,0x9F, 0x67,0xC3,0x53,0xEF,0x56,0x3F,0x3F,0xD3,
                0x5B,0xA0,0xA6,0xC1,0xAB,0x50,0x1B,0xE9, 0xE9,0x85,0x65,0x6E,0xC4,0xF1,0xDD,0xE8,
                0xC8,0x6B,0xAE,0xE5,0xE0,0x97,0x37,0x86, 0x94,0x08,0x19,0xF9,0xE1,0x71,0xB2,0x80,
                0x70,0xEF,0xF4,0x6D,0x7F,0x54,0xBF,0xAA, 0xAB,0x16,0xD9,0x3F,0x3A,0x23,0xA3,0x98,
                0xA8,0x1A,0x5E,0xA2,0x2D,0x18,0xB1,0xC2, 0xBF,0x6D,0x67,0x78,0x2D,0x17,0xE0,0x40,
                0xBB,0x43,0xC1,0xB1,0x00,0xFD,0x48,0xFD, 0x9D,0x8C,0x94,0x32,0x8A,0xC6,0x75,0x8F,
                0xC6,0xCA,0xF6,0xDC,0x72,0x63,0xAB,0x50, 0xD3,0x1D,0x73,0x00,0xDB,0x4F,0x13,0x84,
                0x14,0xB5,0x0A,0x5B,0x24,0x39,0x66,0xCB, 0xBA,0x81,0x56,0x62,0x8F,0xA2,0x0F,0x5E,
                0x78,0x83,0x8A,0xC4,0x13,0x14,0xB4,0x36, 0x36,0x63,0x26,0x75,0x3B,0x0B,0xFA,0x56,
                0xB4,0xD2,0xB9,0xCC,0x3B,0xA6,0xDD,0x9B, 0xF2,0xA0,0x63,0xA4,0x24,0x48,0x9B,0xFB,
                0x2B,0x0D,0x78,0x98,0x06,0x74,0x0A,0xEC, 0xEA,0x93,0xD7,0x9B,0x81,0x61,0xCE,0x98,
                0xDA,0xE1,0xCD,0x4A,0xCA,0x5C,0xB6,0x6F, 0x1D,0xBE,0xFB,0x45,0x77,0xC9,0x6A,0x53,
                0x38,0xAE,0xD9,0xB3,0x33,0x9B,0x44,0x57, 0x98,0xE9,0x2B,0x0B,0x6F,0xBD,0x3C,0x03,
                0xF6,0xA1,0x70,0xB0,0x89,0x07,0x0E,0x06, 0x46,0x41,0x57,0x49,0xA2,0x34,0x85,0x05,
                0xAD,0xA2,0x92,0xBB,0x33,0x15,0x12,0x73, 0x8A,0xC9,0xCA,0x39,0x5E,0x90,0xC5,0xE7,
                0xBB,0x7F,0x34,0x78,0x7D,0x5F,0x83,0xB1, 0xA3,0xF2,0x39,0x51,0x86,0xF6,0xF2,0xC5,
                0x84,0x8B,0x18,0x8E,0x4F,0x77,0x74,0x6A, 0x9A,0xD7,0x37,0x4A,0x8F,0x7F,0x7F,0x37,
                0x3D,0xC0,0x19,0x81,0x72,0xE0,0xBC,0xF0, 0x9B,0xAE,0x43,0xF4,0x82,0xF6,0x93,0xF0,
                0x85,0xF2,0x1E,0x99,0x40,0x65,0x7A,0x59, 0xB8,0x05,0x66,0xFB,0xEB,0x4B,0xCC,0x55,
                0xA0,0x9F,0xF8,0xF3,0x54,0x38,0x2A,0xC7, 0xC7,0xB9,0x90,0x2A,0x7C,0x17,0xC2,0x65,
                0x70,0xBC,0x3E,0x6C,0x1E,0x10,0x76,0x2C, 0xD5,0xF3,0x44,0x50,0x1E,0xBA,0xEA,0xD5,
                0x7C,0x82,0x2B,0x21,0xAB,0xA8,0x30,0xFE, 0x13,0xB3,0x0D,0x77,0xB1,0xD9,0xA3,0x5F,
                0x84,0xDC,0xF9,0x3D,0xF7,0xEC,0x1C,0x8B, 0x37,0x69,0xF7,0xAA,0x3C,0x35,0x62,0xAD,
                0x0D,0xCE,0xB1,0x3C,0x18,0x26,0x44,0x32, 0x27,0x01,0x8F,0x41,0x0A,0x17,0xB5,0x3E,
                0x50,0x02,0x07,0x83,0xAB,0x5E,0x1A,0xAE, 0x1A,0x59,0x5C,0x6C,0xAB,0xC6,0xE8,0x44,
                0xE0,0xB2,0x86,0xF2,0xF1,0x64,0x69,0x47, 0x6E,0x35,0xE1,0xD0,0x93,0x21,0x35,0x79,
                0x30,0x69,0x16,0x87,0x0E,0x50,0xE6,0x73, 0x19,0x16,0x4F,0x3D,0x68,0x48,0xE4,0xF2,
                0x36,0x9D,0x06,0x36,0x14,0xB2,0x26,0x94, 0xCE,0x38,0x2E,0x66,0x39,0xE6,0xE5,0x8A,
                0x4C,0x6D,0x65,0xE8,0xDA,0x29,0x33,0xFC, 0xFF,0x96,0xCB,0xC7,0x3B,0x1E,0x30,0xBB,
                0x7F,0x21,0x92,0xE7,0x0C,0xAC,0xA4,0x00, 0x8A,0x58,0x74,0xC8,0xBA,0xDF,0x9C,0x1A,
                0x04,0xC6,0x83,0xF6,0xAE,0x3D,0x59,0x5F, 0xF9,0x7D,0x0E,0x13,0xDE,0x09,0xC1,0x0F,
                0xD7,0x71,0x18,0x20,0xA7,0x1E,0xEE,0x12, 0xAA,0x2F,0xF3,0xF4,0xE7,0x79,0xAD,0xB2,
                0x83,0x00,0x7D,0xBC,0x9B,0x44,0xB0,0x03, 0xD7,0xAF,0x7D,0x26,0x83,0x57,0x49,0xD7,
                0x18,0x9B,0x8A,0xBF,0x33,0xD5,0x80,0x3B, 0xC0,0x25,0xA4,0xE5,0xEC,0x21,0x02,0x63,
                0x49,0x52,0x7B,0xAD,0x58,0xA2,0xEA,0xE4, 0x79,0xE0,0xB9,0xCF,0x45,0xD6,0xDE,0xEE,
                0xF1,0xAA,0xA0,0xF0,0x97,0x00,0x0B,0xB3, 0xF0,0x25,0xBA,0x85,0x0E,0x1D,0xEB,0x5E,
                0x16,0x39,0x7C,0x7E,0x38,0x78,0x8F,0xB7, 0xF3,0x7F,0x70,0x19,0xDC,0x99,0x5A,0x2B,
                0xEC,0x60,0x6E,0xD9,0xD6,0xF6,0x95,0x4D, 0x54,0xDF,0xD5,0x39,0x1E,0x91,0x44,0xFC,
                0x38,0x1E,0xE2,0xD4,0xB0,0x11,0xBB,0xD4, 0xB2,0xCE,0x47,0xBD,0x0B,0x5F,0x86,0x66,
                0xF6,0x46,0x6B,0xF8,0x83,0x3C,0x6C,0x75, 0x92,0x82,0x44,0xB8,0x48,0x4E,0x14,0xBE,
                0x97,0x23,0xAA,0xD3,0x6B,0x3D,0x13,0xEE, 0x00,0x69,0x71,0x33,0xA1,0x6C,0x82,0xA8,
                0x2E,0xCF,0x8C,0xA7,0x85,0x46,0xA6,0x38, 0x06,0x41,0x47,0xCE,0x6D,0x4E,0x66,0x1F,
                0xB1,0x1B,0xC5,0x34,0xDA,0x4A,0x89,0xE4, 0xA1,0x05,0x75,0xF0,0x78,0x88,0x78,0xAE,
                0xD7,0xB9,0x26,0xDD,0xFA,0xDB,0xD4,0x11, 0x59,0x82,0xB6,0x40,0x03,0xFF,0x37,0x02,
                0x8E,0x65,0x3D,0xA3,0x27,0x0F,0xF2,0x5F, 0x0F,0xD9,0xEB,0x1F,0xFF,0xCD,0x4E,0x60,
                0xA2,0xE4,0x59,0x4D,0x0B,0x71,0x0E,0xCC, 0xA3,0xF0,0x0B,0x01,0x99,0xB4,0xC1,0x45,
                0xF2,0xB7,0xAF,0xB6,0x5E,0x85,0x97,0x09, 0x4A,0x6E,0x50,0x37,0xEC,0x20,0xBD,0x56,
                0xED,0x5F,0xB0,0x58,0xC1,0x80,0x4F,0xB0, 0x62,0x9F,0xAE,0xE4,0x25,0xC2,0x3C,0x3C,
                0x06,0xAD,0x17,0x6D,
        };

        //
        // We don't use the public key, but it's a good idea to have RSA keys around
        // in pairs.
        //
        public static byte[] testXMacsKeyPubEnc = new byte[276]
        {
                0x06,0x02,0x00,0x00,0x00,0xA4,0x00,0x00, 0x52,0x53,0x41,0x31,0x00,0x08,0x00,0x00,
                0x03,0x00,0x00,0x00,0xFB,0x37,0x45,0x77, 0xFB,0xDF,0xC9,0xD8,0x74,0x53,0xA4,0x98,
                0x0F,0x45,0x0D,0x14,0xD3,0x09,0x29,0x2C, 0xF6,0x2F,0x71,0xBD,0xDE,0x10,0xCA,0xF6,
                0xF8,0x7A,0x9B,0xCE,0x6F,0x39,0xA7,0xBF, 0x2B,0x37,0x73,0x1A,0x8D,0x45,0x36,0x4C,
                0xA3,0xC2,0x1A,0xC7,0x92,0x60,0xE1,0xDE, 0xC0,0xEC,0x69,0xF1,0x02,0xFD,0x23,0xA4,
                0x9E,0xF5,0xDE,0xED,0x4F,0x35,0xEF,0xD8, 0x11,0x0C,0x52,0x2F,0x1E,0x1A,0xC3,0x86,
                0x0E,0xC8,0x8F,0x80,0x91,0xFA,0xBE,0x7A, 0x85,0x3D,0x58,0xF7,0x2A,0x6F,0x24,0x92,
                0x1F,0xEC,0xA5,0xB5,0xC9,0x1D,0x5F,0x3C, 0x2F,0x02,0x0F,0xF3,0xF9,0x36,0x85,0xF9,
                0x1F,0x5F,0xFA,0x83,0x26,0xA3,0xCD,0x05, 0x8C,0x31,0x94,0xF0,0xC5,0x89,0x1A,0x24,
                0x23,0x8A,0x2E,0x57,0x23,0xDC,0x1C,0x65, 0x81,0x1D,0x2A,0xCD,0xF1,0xA2,0xC3,0xFC,
                0xC5,0x36,0x53,0x7B,0xC8,0x69,0xF9,0x54, 0x89,0xE1,0x6A,0xB5,0xA4,0x75,0x19,0xAF,
                0x89,0xA9,0x27,0x4F,0x47,0xF0,0xCD,0xD6, 0x72,0x88,0xAF,0x68,0xB5,0xCC,0xB4,0x85,
                0xC3,0x16,0xBA,0x4B,0xF8,0x49,0xBF,0x9A, 0x85,0xC3,0x11,0xE1,0x84,0xFE,0x53,0x03,
                0x55,0x18,0xDC,0x74,0xBB,0x16,0xEB,0x0F, 0x97,0xC5,0xE1,0xAF,0xFE,0x34,0x76,0x90,
                0xF3,0xD6,0x06,0xF4,0x90,0xA9,0x15,0xB2, 0xF5,0xE8,0x91,0x81,0xE5,0x8E,0xA2,0x68,
                0xEB,0x93,0x07,0x12,0x0E,0x48,0x63,0x0E, 0x6F,0xA5,0xF8,0x52,0x62,0xB1,0x1B,0x02,
                0xE4,0x8F,0x08,0x05,0x22,0x41,0x77,0x08, 0x14,0xEF,0x05,0xD7,0x38,0x23,0x5B,0x5A,
                0x89,0x83,0xA3,0xA3,
        };
    
        
        // this key can be used for signing/verifying signatures
        public static byte[] testDrmKeyPrvSig = new byte[1172]
        {
            0x07,0x02,0x00,0x00,0x00,0x24,0x00,0x00, 0x52,0x53,0x41,0x32,0x00,0x08,0x00,0x00,
            0x03,0x00,0x00,0x00,0xa5,0x29,0xf1,0x27, 0x87,0xcd,0x12,0x92,0x3f,0xa8,0x59,0x2f,
            0xdd,0xd1,0xba,0xb3,0x7e,0x2d,0xb4,0xd1, 0xb2,0x62,0x30,0x65,0x94,0xa9,0x89,0x63,
            0x7f,0x2f,0x5b,0x2f,0xac,0x43,0x54,0x66, 0x16,0x46,0x0a,0xc1,0x18,0x64,0xeb,0xf9,
            0xb2,0x38,0x07,0x78,0xe5,0xec,0x3c,0x61, 0x39,0xc8,0x26,0xc4,0x3e,0xe9,0x6d,0x42,
            0x59,0x92,0xdd,0x62,0x04,0xf0,0x29,0x19, 0x04,0x81,0xae,0xca,0x19,0xf9,0x4c,0x48,
            0xae,0x86,0xc5,0x6d,0x88,0x52,0xcc,0x32, 0x54,0x31,0x8a,0xfb,0x63,0xb2,0x3c,0x43,
            0x42,0x98,0x9e,0x25,0x8d,0xd3,0x3e,0x97, 0xa3,0x71,0xca,0x07,0x40,0xfd,0xd2,0xa3,
            0x56,0xa9,0x44,0x4e,0xb4,0x7d,0x92,0x23, 0xee,0x5e,0x1a,0xb8,0x95,0xf3,0xf9,0x02,
            0xc7,0x04,0xf7,0xa8,0xce,0x24,0x90,0x30, 0x5c,0xe2,0x82,0x77,0x77,0x99,0x39,0xbe,
            0x4f,0x19,0x05,0x7d,0x5d,0x55,0xb0,0x68, 0x74,0x91,0xef,0x82,0xa9,0xf5,0x11,0x91,
            0x7b,0xfa,0x4d,0xa7,0xb1,0xb0,0x76,0x21, 0x87,0x3f,0xa1,0xdd,0x56,0xd1,0xdc,0xbd,
            0x90,0x9d,0xd6,0x7d,0x33,0x78,0xda,0x80, 0x6f,0xee,0xa7,0x5c,0xb4,0xdd,0xba,0x31,
            0x5b,0x61,0xd2,0x63,0x00,0xe8,0xc5,0x97, 0x2a,0x76,0xfc,0x8e,0xfe,0xaa,0xb3,0x18,
            0xff,0x7a,0x3c,0x6e,0x6e,0x63,0xa8,0xef, 0xa8,0x98,0xe8,0x78,0xf7,0xbc,0x49,0xcc,
            0x82,0xf7,0x02,0x96,0xc6,0x88,0x58,0x4e, 0x84,0xd6,0x58,0x77,0xc0,0x4a,0xa1,0x30,
            0xd5,0x35,0x3f,0x1f,0x84,0x1c,0x8e,0x06, 0xe6,0xf6,0xa0,0xdd,0x3d,0xc3,0x7b,0xec,
            0xeb,0x62,0xff,0xb5,0x7b,0xed,0x1b,0x19, 0xdf,0x3f,0x0e,0x5b,0xe2,0xba,0x0b,0x5a,
            0x9b,0x04,0x7e,0xae,0xe7,0x4f,0x8e,0xdb, 0x20,0x6e,0xac,0x03,0x49,0x83,0x54,0x23,
            0x18,0xdd,0xec,0xbc,0x3b,0x2f,0x39,0x7d, 0xa7,0x1e,0xdf,0x47,0xca,0x84,0xbf,0x2b,
            0x6a,0x11,0x51,0xa6,0x2d,0xf4,0xca,0x2b, 0x1e,0xf6,0x0c,0xcd,0x6c,0xa8,0x5c,0x84,
            0x45,0x0e,0x53,0x26,0xb0,0x85,0x01,0xb9, 0x9b,0x67,0x2f,0x4f,0x83,0x9d,0x1e,0xea,
            0xcc,0xff,0x66,0x77,0x27,0x9f,0x22,0x07, 0x1a,0xa8,0xff,0x0e,0x3d,0x3a,0x06,0x33,
            0xd2,0x81,0x91,0x9e,0x09,0x0f,0xe0,0x0d, 0xd3,0x1b,0x9a,0x76,0x17,0x04,0x6c,0x7c,
            0x5f,0x54,0xfc,0x4a,0x9c,0xa1,0x38,0x4e, 0x79,0xbb,0x9c,0xa9,0xd6,0xd7,0x20,0x35,
            0x6d,0x17,0xb7,0xea,0x5f,0x4b,0xb3,0x61, 0xed,0x8d,0xeb,0x8b,0xcf,0xf7,0x4f,0xb6,
            0xa5,0xc7,0x05,0x50,0xad,0x00,0x6d,0xb7, 0xf0,0xea,0xa6,0x9e,0xc5,0xa8,0xf2,0xae,
            0x19,0x3f,0xfd,0xbc,0xa9,0xf1,0x2f,0x8d, 0x18,0x3a,0xcf,0xfa,0x25,0xe0,0x04,0x47,
            0xf2,0xab,0xfd,0xb4,0x9b,0x0d,0x9b,0xa6, 0xb0,0x65,0x0d,0x4a,0xc0,0x2d,0xaa,0x29,
            0xce,0xe6,0x17,0xfd,0xdf,0xcc,0x87,0x38, 0xe9,0xd7,0xc7,0xf8,0x4b,0xbe,0xcb,0xe6,
            0x8e,0xc8,0xec,0x39,0xf1,0x4c,0x03,0xb2, 0xb6,0x06,0xd9,0x38,0x47,0xee,0x0d,0xac,
            0x51,0x5e,0xfe,0xc8,0xe7,0x5e,0xd2,0xb0, 0xcd,0x26,0x89,0xfb,0xd2,0x23,0xae,0xcb,
            0xfd,0xec,0x9a,0x16,0x4c,0x04,0xfe,0x8e, 0x7b,0xe1,0x50,0xf3,0x8e,0x4b,0xc5,0xb5,
            0xfb,0x74,0x80,0xc6,0xa7,0xf3,0x67,0xbb, 0x94,0x2a,0xb4,0x3c,0xec,0xd1,0x07,0x3c,
            0x12,0x03,0x54,0x74,0x9a,0x8a,0x09,0x3d, 0x6b,0x49,0xc8,0x57,0xdb,0xac,0x8d,0x17,
            0x10,0x3e,0xf3,0x7d,0xd2,0x74,0x7b,0x53, 0x1a,0xbf,0x94,0xda,0x86,0x58,0x2a,0x1d,
            0x9c,0x0b,0x36,0xc4,0x73,0x4d,0x87,0x72, 0x69,0xf9,0x5d,0x33,0xf3,0x1a,0x93,0xad,
            0x83,0x09,0xe2,0x6e,0x75,0xae,0xab,0xd0, 0x67,0x9a,0x1f,0x8a,0x57,0xbe,0x69,0xf1,
            0xdd,0xff,0x99,0x4f,0x1a,0x6a,0x6c,0xaf, 0x66,0xc5,0xff,0x09,0x7e,0xd1,0xae,0xcc,
            0x36,0x01,0x61,0x14,0xb1,0xb4,0xea,0xb3, 0x8c,0x12,0xbc,0xf9,0x64,0xad,0xf2,0x52,
            0xea,0xe2,0x52,0x87,0xbd,0x6b,0xd0,0xde, 0x50,0xd2,0xbd,0x1b,0x8f,0x3a,0x6b,0x23,
            0x9e,0x0f,0x7a,0x9c,0x3f,0x32,0x22,0x41, 0x9e,0x5e,0xf2,0x07,0x35,0xa5,0x8a,0x79,
            0x6e,0xda,0x03,0xe0,0xc8,0x55,0xf3,0x24, 0x4b,0x47,0x6f,0x14,0xd9,0xc5,0xa1,0x74,
            0x66,0x7f,0x53,0xd3,0x1b,0xa1,0xca,0x08, 0xbb,0x26,0x8a,0xfc,0xc3,0xea,0xad,0x84,
            0xa1,0x72,0xfe,0xcd,0x67,0x5e,0x67,0xc4, 0x75,0xee,0x08,0xdc,0x2a,0xc9,0xc6,0x1b,
            0x34,0xef,0x0f,0xfe,0x3f,0x33,0x05,0x7b, 0x9b,0x3a,0x85,0x50,0xdd,0x7e,0x32,0xef,
            0x09,0xdb,0x9d,0x26,0xf6,0xdd,0xac,0x76, 0x24,0xaf,0x90,0xd0,0x84,0x49,0x09,0xc8,
            0x8b,0xe9,0xfe,0x85,0x9a,0x94,0xe1,0x75, 0xde,0x19,0x06,0xfd,0xe1,0x17,0x74,0x32,
            0xa9,0x48,0x67,0x64,0xdd,0x02,0x54,0x5f, 0x52,0x96,0xe0,0x4c,0x5f,0x32,0x2e,0x79,
            0x52,0xa3,0x55,0x84,0x8d,0xd8,0xd0,0x92, 0x37,0xc7,0xa5,0xa5,0x24,0x47,0x8f,0x27,
            0x4e,0x3c,0xd0,0x2b,0x9e,0xfd,0xd8,0x4c, 0xfe,0x2c,0x31,0x6e,0x8e,0x33,0xd2,0x41,
            0xc4,0xe4,0xed,0xa3,0x35,0x09,0xff,0xb5, 0x47,0xad,0x83,0x5e,0x15,0x4e,0xd3,0x33,
            0xdc,0xb8,0x61,0x58,0x66,0xa8,0x10,0x21, 0x1c,0x66,0x8e,0x7a,0xf8,0xfb,0xa5,0x0b,
            0x82,0xda,0xc2,0x61,0xa8,0xa9,0x33,0xf5, 0xf8,0x1b,0x28,0x3b,0xef,0xd5,0xd9,0x04,
            0x86,0xe1,0xa7,0xe0,0x92,0xc7,0x78,0x1a, 0xc9,0x13,0xcb,0xea,0x15,0xe8,0xcc,0xb4,
            0xbb,0x2b,0xd5,0x3d,0x3d,0x54,0xbc,0x4c, 0xca,0x63,0xa3,0x72,0x49,0x7f,0x0c,0x05,
            0xb5,0xdd,0x12,0x2b,0x0a,0x83,0x5c,0x78, 0xc4,0x1a,0x96,0x0a,0x7f,0xa9,0x29,0x19,
            0xf4,0x79,0xfe,0x5b,0x33,0x4b,0xc1,0xc8, 0xd1,0xff,0x65,0xc7,0xb3,0xa3,0xfe,0x69,
            0xbd,0x03,0x7a,0x23,0xf1,0x3d,0x7b,0xd4, 0xc0,0x5b,0x93,0x2c,0x59,0xfe,0xd6,0x60,
            0xde,0x0c,0xf6,0x78,0x84,0x6c,0x47,0x3d, 0xe4,0x48,0x3d,0x54,0x70,0xff,0x19,0x5a,
            0xe4,0xfc,0x7a,0x68,0xbd,0x9c,0xe4,0x09, 0x47,0x48,0x08,0x1e,0x61,0xb7,0x44,0xb8,
            0x83,0x13,0xf7,0xd4,0xa2,0x13,0x6b,0x1a, 0xaa,0x2b,0x7a,0xac,0x31,0xbe,0x41,0xfa,
            0x36,0xd4,0x4b,0x28,0xf5,0xee,0x6e,0xa6, 0x57,0xac,0xcb,0x77,0xea,0x5b,0x70,0xed,
            0xbe,0x7a,0xb4,0x7e,0x12,0x99,0x5d,0x90, 0xac,0x74,0x6f,0x0e,0x39,0x8e,0xd0,0xe7,
            0x50,0x45,0x1e,0xf3,0x87,0x3a,0x3d,0x84, 0xfb,0x2b,0x73,0x67,0x75,0x35,0x0d,0x10,
            0x94,0xa5,0x7f,0xfa,0xdd,0x6d,0xb5,0x75, 0x3d,0xec,0x01,0xa5,0x4f,0x66,0x26,0xd4,
            0xdf,0x10,0xae,0xa8,0x93,0xe3,0xca,0x45, 0xf8,0x60,0x4a,0x57,0xc6,0xa3,0xb6,0x60,
            0x52,0xfc,0x33,0x1a,0x21,0xcb,0xf9,0xc0, 0x04,0xd5,0xc0,0x93,0xe4,0xe0,0x3d,0x29,
            0x0b,0x69,0xe4,0x53,0x22,0x50,0x3c,0xab, 0x9f,0x49,0xc5,0x3d,0x78,0x3e,0x27,0x21,
            0x92,0xeb,0x36,0xed,0xaa,0x9a,0x2e,0x65, 0x1c,0xa4,0xfd,0x09,0xff,0x71,0x22,0xbb,
            0x54,0xa7,0x7d,0x49,0xf4,0xec,0x1a,0xf5, 0xc5,0x65,0xf0,0xa5,0x4f,0xd3,0xdb,0x32,
            0x57,0xfa,0x01,0x64,0x84,0xb0,0xe5,0xde, 0x02,0x8f,0x90,0x4f,0x80,0xdc,0xc0,0x75,
            0xe3,0x23,0x2a,0x6a,0xad,0xbd,0x5e,0x04, 0x44,0x4f,0x6b,0x3e,0x29,0x82,0x52,0x48,
            0x9d,0xec,0x54,0x79 };
    
        // this key can be used for encrypting/decrypting
        public static byte[] testDrmKeyPrvEnc = new byte[1172]
        {
            0x07,0x02,0x00,0x00,0x00,0xA4,0x00,0x00, 0x52,0x53,0x41,0x32,0x00,0x08,0x00,0x00,
            0x03,0x00,0x00,0x00,0xa5,0x29,0xf1,0x27, 0x87,0xcd,0x12,0x92,0x3f,0xa8,0x59,0x2f,
            0xdd,0xd1,0xba,0xb3,0x7e,0x2d,0xb4,0xd1, 0xb2,0x62,0x30,0x65,0x94,0xa9,0x89,0x63,
            0x7f,0x2f,0x5b,0x2f,0xac,0x43,0x54,0x66, 0x16,0x46,0x0a,0xc1,0x18,0x64,0xeb,0xf9,
            0xb2,0x38,0x07,0x78,0xe5,0xec,0x3c,0x61, 0x39,0xc8,0x26,0xc4,0x3e,0xe9,0x6d,0x42,
            0x59,0x92,0xdd,0x62,0x04,0xf0,0x29,0x19, 0x04,0x81,0xae,0xca,0x19,0xf9,0x4c,0x48,
            0xae,0x86,0xc5,0x6d,0x88,0x52,0xcc,0x32, 0x54,0x31,0x8a,0xfb,0x63,0xb2,0x3c,0x43,
            0x42,0x98,0x9e,0x25,0x8d,0xd3,0x3e,0x97, 0xa3,0x71,0xca,0x07,0x40,0xfd,0xd2,0xa3,
            0x56,0xa9,0x44,0x4e,0xb4,0x7d,0x92,0x23, 0xee,0x5e,0x1a,0xb8,0x95,0xf3,0xf9,0x02,
            0xc7,0x04,0xf7,0xa8,0xce,0x24,0x90,0x30, 0x5c,0xe2,0x82,0x77,0x77,0x99,0x39,0xbe,
            0x4f,0x19,0x05,0x7d,0x5d,0x55,0xb0,0x68, 0x74,0x91,0xef,0x82,0xa9,0xf5,0x11,0x91,
            0x7b,0xfa,0x4d,0xa7,0xb1,0xb0,0x76,0x21, 0x87,0x3f,0xa1,0xdd,0x56,0xd1,0xdc,0xbd,
            0x90,0x9d,0xd6,0x7d,0x33,0x78,0xda,0x80, 0x6f,0xee,0xa7,0x5c,0xb4,0xdd,0xba,0x31,
            0x5b,0x61,0xd2,0x63,0x00,0xe8,0xc5,0x97, 0x2a,0x76,0xfc,0x8e,0xfe,0xaa,0xb3,0x18,
            0xff,0x7a,0x3c,0x6e,0x6e,0x63,0xa8,0xef, 0xa8,0x98,0xe8,0x78,0xf7,0xbc,0x49,0xcc,
            0x82,0xf7,0x02,0x96,0xc6,0x88,0x58,0x4e, 0x84,0xd6,0x58,0x77,0xc0,0x4a,0xa1,0x30,
            0xd5,0x35,0x3f,0x1f,0x84,0x1c,0x8e,0x06, 0xe6,0xf6,0xa0,0xdd,0x3d,0xc3,0x7b,0xec,
            0xeb,0x62,0xff,0xb5,0x7b,0xed,0x1b,0x19, 0xdf,0x3f,0x0e,0x5b,0xe2,0xba,0x0b,0x5a,
            0x9b,0x04,0x7e,0xae,0xe7,0x4f,0x8e,0xdb, 0x20,0x6e,0xac,0x03,0x49,0x83,0x54,0x23,
            0x18,0xdd,0xec,0xbc,0x3b,0x2f,0x39,0x7d, 0xa7,0x1e,0xdf,0x47,0xca,0x84,0xbf,0x2b,
            0x6a,0x11,0x51,0xa6,0x2d,0xf4,0xca,0x2b, 0x1e,0xf6,0x0c,0xcd,0x6c,0xa8,0x5c,0x84,
            0x45,0x0e,0x53,0x26,0xb0,0x85,0x01,0xb9, 0x9b,0x67,0x2f,0x4f,0x83,0x9d,0x1e,0xea,
            0xcc,0xff,0x66,0x77,0x27,0x9f,0x22,0x07, 0x1a,0xa8,0xff,0x0e,0x3d,0x3a,0x06,0x33,
            0xd2,0x81,0x91,0x9e,0x09,0x0f,0xe0,0x0d, 0xd3,0x1b,0x9a,0x76,0x17,0x04,0x6c,0x7c,
            0x5f,0x54,0xfc,0x4a,0x9c,0xa1,0x38,0x4e, 0x79,0xbb,0x9c,0xa9,0xd6,0xd7,0x20,0x35,
            0x6d,0x17,0xb7,0xea,0x5f,0x4b,0xb3,0x61, 0xed,0x8d,0xeb,0x8b,0xcf,0xf7,0x4f,0xb6,
            0xa5,0xc7,0x05,0x50,0xad,0x00,0x6d,0xb7, 0xf0,0xea,0xa6,0x9e,0xc5,0xa8,0xf2,0xae,
            0x19,0x3f,0xfd,0xbc,0xa9,0xf1,0x2f,0x8d, 0x18,0x3a,0xcf,0xfa,0x25,0xe0,0x04,0x47,
            0xf2,0xab,0xfd,0xb4,0x9b,0x0d,0x9b,0xa6, 0xb0,0x65,0x0d,0x4a,0xc0,0x2d,0xaa,0x29,
            0xce,0xe6,0x17,0xfd,0xdf,0xcc,0x87,0x38, 0xe9,0xd7,0xc7,0xf8,0x4b,0xbe,0xcb,0xe6,
            0x8e,0xc8,0xec,0x39,0xf1,0x4c,0x03,0xb2, 0xb6,0x06,0xd9,0x38,0x47,0xee,0x0d,0xac,
            0x51,0x5e,0xfe,0xc8,0xe7,0x5e,0xd2,0xb0, 0xcd,0x26,0x89,0xfb,0xd2,0x23,0xae,0xcb,
            0xfd,0xec,0x9a,0x16,0x4c,0x04,0xfe,0x8e, 0x7b,0xe1,0x50,0xf3,0x8e,0x4b,0xc5,0xb5,
            0xfb,0x74,0x80,0xc6,0xa7,0xf3,0x67,0xbb, 0x94,0x2a,0xb4,0x3c,0xec,0xd1,0x07,0x3c,
            0x12,0x03,0x54,0x74,0x9a,0x8a,0x09,0x3d, 0x6b,0x49,0xc8,0x57,0xdb,0xac,0x8d,0x17,
            0x10,0x3e,0xf3,0x7d,0xd2,0x74,0x7b,0x53, 0x1a,0xbf,0x94,0xda,0x86,0x58,0x2a,0x1d,
            0x9c,0x0b,0x36,0xc4,0x73,0x4d,0x87,0x72, 0x69,0xf9,0x5d,0x33,0xf3,0x1a,0x93,0xad,
            0x83,0x09,0xe2,0x6e,0x75,0xae,0xab,0xd0, 0x67,0x9a,0x1f,0x8a,0x57,0xbe,0x69,0xf1,
            0xdd,0xff,0x99,0x4f,0x1a,0x6a,0x6c,0xaf, 0x66,0xc5,0xff,0x09,0x7e,0xd1,0xae,0xcc,
            0x36,0x01,0x61,0x14,0xb1,0xb4,0xea,0xb3, 0x8c,0x12,0xbc,0xf9,0x64,0xad,0xf2,0x52,
            0xea,0xe2,0x52,0x87,0xbd,0x6b,0xd0,0xde, 0x50,0xd2,0xbd,0x1b,0x8f,0x3a,0x6b,0x23,
            0x9e,0x0f,0x7a,0x9c,0x3f,0x32,0x22,0x41, 0x9e,0x5e,0xf2,0x07,0x35,0xa5,0x8a,0x79,
            0x6e,0xda,0x03,0xe0,0xc8,0x55,0xf3,0x24, 0x4b,0x47,0x6f,0x14,0xd9,0xc5,0xa1,0x74,
            0x66,0x7f,0x53,0xd3,0x1b,0xa1,0xca,0x08, 0xbb,0x26,0x8a,0xfc,0xc3,0xea,0xad,0x84,
            0xa1,0x72,0xfe,0xcd,0x67,0x5e,0x67,0xc4, 0x75,0xee,0x08,0xdc,0x2a,0xc9,0xc6,0x1b,
            0x34,0xef,0x0f,0xfe,0x3f,0x33,0x05,0x7b, 0x9b,0x3a,0x85,0x50,0xdd,0x7e,0x32,0xef,
            0x09,0xdb,0x9d,0x26,0xf6,0xdd,0xac,0x76, 0x24,0xaf,0x90,0xd0,0x84,0x49,0x09,0xc8,
            0x8b,0xe9,0xfe,0x85,0x9a,0x94,0xe1,0x75, 0xde,0x19,0x06,0xfd,0xe1,0x17,0x74,0x32,
            0xa9,0x48,0x67,0x64,0xdd,0x02,0x54,0x5f, 0x52,0x96,0xe0,0x4c,0x5f,0x32,0x2e,0x79,
            0x52,0xa3,0x55,0x84,0x8d,0xd8,0xd0,0x92, 0x37,0xc7,0xa5,0xa5,0x24,0x47,0x8f,0x27,
            0x4e,0x3c,0xd0,0x2b,0x9e,0xfd,0xd8,0x4c, 0xfe,0x2c,0x31,0x6e,0x8e,0x33,0xd2,0x41,
            0xc4,0xe4,0xed,0xa3,0x35,0x09,0xff,0xb5, 0x47,0xad,0x83,0x5e,0x15,0x4e,0xd3,0x33,
            0xdc,0xb8,0x61,0x58,0x66,0xa8,0x10,0x21, 0x1c,0x66,0x8e,0x7a,0xf8,0xfb,0xa5,0x0b,
            0x82,0xda,0xc2,0x61,0xa8,0xa9,0x33,0xf5, 0xf8,0x1b,0x28,0x3b,0xef,0xd5,0xd9,0x04,
            0x86,0xe1,0xa7,0xe0,0x92,0xc7,0x78,0x1a, 0xc9,0x13,0xcb,0xea,0x15,0xe8,0xcc,0xb4,
            0xbb,0x2b,0xd5,0x3d,0x3d,0x54,0xbc,0x4c, 0xca,0x63,0xa3,0x72,0x49,0x7f,0x0c,0x05,
            0xb5,0xdd,0x12,0x2b,0x0a,0x83,0x5c,0x78, 0xc4,0x1a,0x96,0x0a,0x7f,0xa9,0x29,0x19,
            0xf4,0x79,0xfe,0x5b,0x33,0x4b,0xc1,0xc8, 0xd1,0xff,0x65,0xc7,0xb3,0xa3,0xfe,0x69,
            0xbd,0x03,0x7a,0x23,0xf1,0x3d,0x7b,0xd4, 0xc0,0x5b,0x93,0x2c,0x59,0xfe,0xd6,0x60,
            0xde,0x0c,0xf6,0x78,0x84,0x6c,0x47,0x3d, 0xe4,0x48,0x3d,0x54,0x70,0xff,0x19,0x5a,
            0xe4,0xfc,0x7a,0x68,0xbd,0x9c,0xe4,0x09, 0x47,0x48,0x08,0x1e,0x61,0xb7,0x44,0xb8,
            0x83,0x13,0xf7,0xd4,0xa2,0x13,0x6b,0x1a, 0xaa,0x2b,0x7a,0xac,0x31,0xbe,0x41,0xfa,
            0x36,0xd4,0x4b,0x28,0xf5,0xee,0x6e,0xa6, 0x57,0xac,0xcb,0x77,0xea,0x5b,0x70,0xed,
            0xbe,0x7a,0xb4,0x7e,0x12,0x99,0x5d,0x90, 0xac,0x74,0x6f,0x0e,0x39,0x8e,0xd0,0xe7,
            0x50,0x45,0x1e,0xf3,0x87,0x3a,0x3d,0x84, 0xfb,0x2b,0x73,0x67,0x75,0x35,0x0d,0x10,
            0x94,0xa5,0x7f,0xfa,0xdd,0x6d,0xb5,0x75, 0x3d,0xec,0x01,0xa5,0x4f,0x66,0x26,0xd4,
            0xdf,0x10,0xae,0xa8,0x93,0xe3,0xca,0x45, 0xf8,0x60,0x4a,0x57,0xc6,0xa3,0xb6,0x60,
            0x52,0xfc,0x33,0x1a,0x21,0xcb,0xf9,0xc0, 0x04,0xd5,0xc0,0x93,0xe4,0xe0,0x3d,0x29,
            0x0b,0x69,0xe4,0x53,0x22,0x50,0x3c,0xab, 0x9f,0x49,0xc5,0x3d,0x78,0x3e,0x27,0x21,
            0x92,0xeb,0x36,0xed,0xaa,0x9a,0x2e,0x65, 0x1c,0xa4,0xfd,0x09,0xff,0x71,0x22,0xbb,
            0x54,0xa7,0x7d,0x49,0xf4,0xec,0x1a,0xf5, 0xc5,0x65,0xf0,0xa5,0x4f,0xd3,0xdb,0x32,
            0x57,0xfa,0x01,0x64,0x84,0xb0,0xe5,0xde, 0x02,0x8f,0x90,0x4f,0x80,0xdc,0xc0,0x75,
            0xe3,0x23,0x2a,0x6a,0xad,0xbd,0x5e,0x04, 0x44,0x4f,0x6b,0x3e,0x29,0x82,0x52,0x48,
            0x9d,0xec,0x54,0x79
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\CryptoKeyCache.cs ===
using System;
using System.Collections.Generic;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.xcrypto;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.xcrypto.fd
{
    class CryptoKeyCache
    {
        public static CryptoKeyCache Cache
        {
            get
            {
                if (_singleton == null)
                {
                    lock(_lockObj)
                    {
                        if (_singleton == null)
                        {
                           _singleton = CryptoKeyCache.CreateInstance();
                        }
                    }
                }
                return _singleton;
            }
        }

        private static CryptoKeyCache CreateInstance()
        {
            try
            {
                XCryptoMgmt.Init();
                CryptoSettings.CacheCurrentSettings();
                CryptoKeyCache cache = new CryptoKeyCache();

                Xom.NtEvent(XEvent.Id.XCRYPTO_INIT_SUCCESS, "CryptoKeyCache successfully created.");
                return cache;
            }
            catch(Exception e)
            {
                throw new XRLException( HResult.XONLINE_E_XCRYPTO_CACHE_ERROR, 
                                        XEvent.Id.XCRYPTO_CONFIG_ERROR, 
                                        e, 
                                        "Error creating new CryptoKeyCache. This is most likely a configuration issue. See inner exception for more detail." );
            }
        }

        private CryptoKeyCache()
        {
            _disposed = false;
            _keyCache = CryptoKeyFactory.CreateKeys();
        }

        public static void TestCryptoKeyCache()
        {
            CryptoKeyCache ckc = Cache;
        }

        public static void RefreshCache()
        {
            CryptoKeyCache oldCache;

            lock(_lockObj)
            {
                oldCache = _singleton;
                _singleton = CryptoKeyCache.CreateInstance();
            }

            try
            {
                if (oldCache != null)
                {
                    oldCache.Dispose();
                }
            }
            catch(Exception e)
            {
                throw new XRLException( HResult.XONLINE_E_XCRYPTO_ERROR, 
                                        XEvent.Id.XCRYPTO_GENERIC_ERROR, 
                                        e, 
                                        "Failed to dispose old CryptoKeyCache after refreshing.  See inner exception for more detail." );
            }

            Xom.NtEvent(XEvent.Id.XCRYPTO_INIT_SUCCESS, "CryptoKeyCache successfully refreshed.");            
        }

        public void InsertKey(EContainerClasses containerClass, CryptoKey ck)
        {
            _keyCache.Add(containerClass, ck);
        }

        public CryptoKey GetCryptoKey(EContainerClasses containerClass)
        {
            return _keyCache[containerClass];
        }

        // Implement the Dispose pattern without implementing IDisposable. Since we
        // are currently implemented as a singleton we don't want to let people
        // call Dispose on us. We only need this for initialization and tear-down.
        private void Dispose()
        {
            Dispose(true);
        }

        private void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    foreach (CryptoKey ck in _keyCache.Values)
                    {
                        ck.Dispose();
                    }
                }
                _disposed = true;
            }
        }

        private static volatile CryptoKeyCache _singleton;
        private static object _lockObj = new object();
        private bool _disposed;

        private Dictionary<EContainerClasses, CryptoKey> _keyCache;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\KeyInfo.cs ===
using System;
using System.Security.Cryptography;

using xonline.common.xcrypto;

namespace xonline.server.xcrypto.fd
{
    public class KeyInfo
    {
        protected const string c_nCipherProvider = "nCipher Enhanced Cryptographic Provider";
        protected const string c_CAPIProvider = "Microsoft Enhanced Cryptographic Provider v1.0";
        protected const int AT_KEYEXCHANGE = 1;
        protected const int AT_SIGNATURE = 2;        

        public static KeyInfo[] CryptoKeys = new KeyInfo[] {
            new KeyInfo( EContainerClasses.Drm,
                         XCryptoKeyType.Production,
                         c_nCipherProvider,
                         "Drm",
                         AT_SIGNATURE),

            new KeyInfo( EContainerClasses.Asset,
                         XCryptoKeyType.Production,
                         c_nCipherProvider,
                         "Assets",
                         AT_SIGNATURE),

            new KeyInfo( EContainerClasses.XMacs,
                         XCryptoKeyType.Production,
                         c_nCipherProvider,
                         "masterxmacskey",
                         AT_KEYEXCHANGE),

            new KeyInfo( EContainerClasses.XMacsTest,
                         XCryptoKeyType.Production,
                         c_nCipherProvider,
                         "masterxmacskeytest",
                         AT_KEYEXCHANGE), // Test key for allowing devkits to prod.  This should use nCipher, no need for blobs.

            new KeyInfo( EContainerClasses.Token,
                         XCryptoKeyType.Production,
                         c_nCipherProvider,
                         "SNTokens",
                         AT_KEYEXCHANGE),

            new KeyInfo( EContainerClasses.Drm,
                         XCryptoKeyType.Test,
                         c_CAPIProvider,
                         "DrmTest",
                         AT_SIGNATURE,
                         TestKeyBlobs.testDrmKeyPrvSig),

            new KeyInfo( EContainerClasses.Asset,
                         XCryptoKeyType.Test,
                         c_CAPIProvider,
                         "DrmTest",
                         AT_SIGNATURE,
                         TestKeyBlobs.testDrmKeyPrvSig),  // In test, we do use the same keys for asset and drm.

            new KeyInfo( EContainerClasses.Token,
                         XCryptoKeyType.Test,
                         c_CAPIProvider,
                         "DrmTest",
                         AT_KEYEXCHANGE,
                         TestKeyBlobs.testDrmKeyPrvEnc),  // In test, we do use the same keys for asset, drm, and token

            new XMacsTestKeyInfo(), // This is for testing, but it could use nCipher or CAPI so it's a special case.
            };

        public KeyInfo( EContainerClasses containerClass,
                        XCryptoKeyType keyType,
                        string provider,
                        string container,
                        int keyNumber,
                        params byte[][] keyList)
        {
            _containerClass = containerClass;
            _keyType = keyType;
            _provider = provider;
            _container = container;
            _keyNumber = keyNumber;
            _keyList = keyList;
        }

        public string DebugString()
        {
            return String.Format("Container class:{0} KeyType:{1} Provider:{2}, Container:{3}, KeyNumber:{4}",
                        Enum.GetName(typeof(EContainerClasses), _containerClass),
                        Enum.GetName(typeof(XCryptoKeyType), _keyType),
                        _provider,
                        _container,
                        _keyNumber
                    );
        }

        public EContainerClasses ContainerClass { get { return _containerClass; } }
        public XCryptoKeyType KeyType { get { return _keyType; } }
        public virtual string Provider { get { return _provider; } }
        public string Container { get { return _container; } }
        public int KeyNumber { get { return _keyNumber; } }
        public virtual byte[][] Keys { get { return _keyList; } }

        private EContainerClasses _containerClass;
        private XCryptoKeyType _keyType;
        private string _provider;
        private string _container;
        private int _keyNumber;
        private byte[][] _keyList;
    }

    public class XMacsTestKeyInfo : KeyInfo
    {
        public XMacsTestKeyInfo() : 
            base( EContainerClasses.XMacsTest,
                  XCryptoKeyType.Test,
                  null,
                  "masterxmacskeytest",
                  AT_KEYEXCHANGE,
                  null )
        {
        }

        private byte[][] _keyList = { TestKeyBlobs.testXMacsKeyPrvEnc, TestKeyBlobs.testXMacsKeyPubEnc };

        public override string Provider 
        { 
            get { return CryptoSettings.UseNCipher ? c_nCipherProvider : c_CAPIProvider; }
        }

        public override byte[][] Keys
        {
            get { return CryptoSettings.UseNCipher ? null : _keyList; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\CryptoKeyFactory.cs ===
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using xonline.common.service;
using xonline.common.xcrypto;

namespace xonline.server.xcrypto.fd
{
    public static class CryptoKeyFactory
    {
        public static Dictionary<EContainerClasses, CryptoKey> CreateKeys()
        {
            List<XCryptoKeyType> keyTypes = DetermineKeyTypes();
            Dictionary<EContainerClasses, CryptoKey> createdKeys = new Dictionary<EContainerClasses,CryptoKey>();

            foreach(KeyInfo ki in KeyInfo.CryptoKeys)
            {
                if(keyTypes.Contains(ki.KeyType))
                {
                    EContainerClasses container = ki.ContainerClass;

                    // Special XMacs Rules.
                    if( container == EContainerClasses.XMacs ||
                        container == EContainerClasses.XMacsTest )
                    {
                        // If the setting isn't there, don't make it.
                        if(!CryptoSettings.UseXMacsKey)
                            continue;

                        // If there's no production XMacs key, we want to make
                        // the test one look like the real one.
                        if(container == EContainerClasses.XMacsTest &&
                           !keyTypes.Contains(XCryptoKeyType.Production))
                        {
                            container = EContainerClasses.XMacs;
                        }
                    }

                    try
                    {
                        InstallKeyBlobs(ki);
                        createdKeys.Add(container, new CryptoKey(ki));
                    }
                    catch(Exception e)
                    {
                        throw new XRLException( HResult.XONLINE_E_XCRYPTO_ERROR, 
                                                XEvent.Id.XCRYPTO_GENERIC_ERROR,
                                                e, 
                                                "Failed to create crypto key, see inner exception for details. Key Info: {0}", 
                                                ki.DebugString() );
                    }
                }
            }

            return createdKeys;
        }

        private static List<XCryptoKeyType> DetermineKeyTypes()
        {
            List<XCryptoKeyType> types = new List<XCryptoKeyType>();

            if(CryptoSettings.UseNCipher)
            {
                types.Add(XCryptoKeyType.Production);
            }

            if(CryptoSettings.UseTestKey)
            {
                types.Add(XCryptoKeyType.Test);
            }

            return types;
        }

        private static void InstallKeyBlobs(KeyInfo ki)
        {
            // This is copied from KeyBase, but yeah.  I feel bad.
            const int PROV_RSA_FULL = 1;

            if( ki.Keys.Length > 0 )
            {
                // Get the provider and delete it--if it exists, this will 
                // delete it and if not, this will do nothing.
                CspParameters cspParams = new CspParameters();
                cspParams.ProviderName = ki.Provider; 
                cspParams.ProviderType = PROV_RSA_FULL;
                cspParams.KeyContainerName = ki.Container;
                cspParams.KeyNumber = ki.KeyNumber;
                cspParams.Flags = CspProviderFlags.NoPrompt | CspProviderFlags.UseMachineKeyStore;

                using (RSACryptoServiceProvider provider = new RSACryptoServiceProvider(cspParams))
                {
                    provider.PersistKeyInCsp = false;
                }

                // Now get the provider, and persists it, and add the blobs.
                using (RSACryptoServiceProvider provider = new RSACryptoServiceProvider(cspParams))
                {
                    provider.PersistKeyInCsp = true;

                    foreach (byte[] blob in ki.Keys)
                    {
                        provider.ImportCspBlob(blob);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\XCryptoDecrypt.cs ===
using System;
using System.Web;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.xcrypto.fd
{
    internal sealed class XCryptoDecrypt : XCryptoOperationBase<XCryptoDecryptRequest>
    {
        protected override XRLObject2 PerformCryptoAction(XCryptoDecryptRequest request, CryptoKey ck)
        {
            XCryptoDecryptResponse response = new XCryptoDecryptResponse();
            response.clear = new XCryptoData(ck.Decrypt(request.cipher.data));
            return response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\XConnSrv\test\stf\XConnSrvTestHelpers.cs ===
using System;
using System.Net;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.XConnSrv.FakeMC;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using System.Reflection;
using System.Linq;
using xonline.common.community;

namespace XConnSrvTest
{
    /// <summary>
    /// Helper functions for all XConnSrv tests
    /// </summary>
    public class XConnSrvTestHelpers
    {
        public static uint MAX_LOGON_USERS = 4;

        public static bool TryConnectAndVerify(ref PNConnection conn, uint desiredHResult, int[] userIndices, ulong[] userIds, ulong xboxId)
        {
            return TryConnectAndVerify(ref conn, desiredHResult, userIndices, userIds, xboxId, false);
        }

        public static bool TryConnectAndVerify(ref PNConnection conn, uint desiredHResult, int[] userIndices, ulong[] userIds, ulong xboxId, bool reconnect)
        {
            try
            {
                if (conn == null)
                {
                    conn = new PNConnection(xboxId);
                    //conn.Notified += new ConnSrvConnection.NotifiedEventHandler(conn_Notified);
                }

                CONNECT_REPLY reply = conn.Connect(userIndices, userIds, reconnect);

                //Verify Rreply.
                if (!HResult.Equals((uint)reply.hr, desiredHResult))
                    throw new HResultException((uint)reply.hr, "Unexpected HResult.");
                //Verify using xmgmt that user XX is connected with userindex YY.
                for (int i = 0; i < userIds.Length; i++)
                {
                    Global.RO.Info("Sleeping 1 second to let Connection Server be happy...");
                    Thread.Sleep(1000);

                    bool connected = XConnSrvTestHelpers.IsUserConnected(userIds[i], userIndices[i]);
                    if (desiredHResult != HResult.S_OK && connected)
                        throw new ApplicationException("User " + userIds[0].ToString() + " should not be connected at " + userIndices[i].ToString());
                    if (desiredHResult == HResult.S_OK && !connected)
                        throw new ApplicationException("User " + userIds[0].ToString() + " should be connected at " + userIndices[i].ToString());
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Connect Failed: " + e.Message);
                return false;
            }
            Global.RO.Info("Connection established.");
            return true;
        }

        public static bool TryDisconnectAndVerify(PNConnection conn, int[] userIndices)
        {
            try
            {
                DISCONNECT_REPLY reply = conn.Disconnect(0, userIndices);
                if (HResult.Failed((uint)reply.hr))
                    throw new HResultException((uint)reply.hr, "Disconnect Failed");
            }
            catch (Exception e)
            {
                Global.RO.Warn("Disconnect Failed: " + e.Message);
                //return false;
            }
            Global.RO.Info("Connection terminated for given index.");
            return true;
        }

        public static bool TryDisconnectAndVerify(PNConnection conn)
        {
            try
            {
                DISCONNECT_REPLY reply = conn.Disconnect(0);
                if (HResult.Failed((uint)reply.hr))
                    throw new HResultException((uint)reply.hr, "Disconnect Failed");
            }
            catch (Exception e)
            {
                Global.RO.Error("Disconnect Failed: " + e.Message);
                //return false;
            }
            Global.RO.Info("Connection terminated.");
            return true;
        }

        public static bool VerifySubscription(ulong ownerXuid, DATA_OBJECT_SPECIFIER[] subscriptions, SUBSCRIBE_REPLY subscribeReply)
        {
            return VerifySubscription(ownerXuid, subscriptions, subscribeReply, false);
        }

        /// <summary>
        /// Verifies the overall subscription length match for the subscription request and reply, as well as
        /// object size, data type, and owner XUID for each subscription
        /// </summary>
        /// <returns></returns>
        public static bool VerifySubscription(ulong ownerXuid, DATA_OBJECT_SPECIFIER[] subscriptions, SUBSCRIBE_REPLY subscribeReply, bool blockedPrivacy)
        {
            Assert.IsTrue(subscribeReply.dwNumDataObjects == subscriptions.Length, "Reply num objects should have same length as request");
            Assert.IsTrue(subscribeReply.rgDataObjects.Length == subscriptions.Length, "Reply should have same length as request");

            for (int j = 0; j < subscriptions.Length; j++)
            {
                bool bFound = false;
                foreach (SUBSCRIPTION_DATA sd in subscribeReply.rgDataObjects)
                {
                    if (subscriptions[j].qwOwnerXUID == sd.qwOwnerXUID && subscriptions[j].wDataType == sd.wDataType)
                    {
                        if (blockedPrivacy) // Since the privacy is blocked, we will get back no data.
                        {
                            Assert.IsTrue(subscribeReply.rgDataObjects[j].wObjectSize == 20, "Object size should be 20 since the privacy is blocked"); // 20 == sizeof(BASE_DATA_HEADER)
                            Assert.IsTrue(subscribeReply.rgDataObjects[j].data.Length == 0, "Data length should be 0 since privacy is blocked.");
                        }

                        bFound = true;
                        break;
                    }
                }
                
                Assert.IsTrue(bFound, "Owner XUID should be found in Subscribe reply.");
            }

            // Verify with xmgmt.
            for (int j = 0; j < subscriptions.Length; j++)
            {
                if (! XConnSrvTestHelpers.IsUserSubscribedTo(ownerXuid, subscriptions[j].qwOwnerXUID, (DATA_TYPES) subscriptions[j].wDataType))
                    return false;
            }
            Global.RO.Info("Subscribe verified for user:" + ownerXuid.ToString());
            return true;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static bool VerifyUnsubscription(ulong ownerXuid, DATA_OBJECT_SPECIFIER[] subscriptions, UNSUBSCRIBE_REPLY unsubscribeReply)
        {
            if (HResult.Failed((uint)unsubscribeReply.hr))
                throw new HResultException((uint)unsubscribeReply.hr, "Unsubscribe Failed");

            // Verify with xmgmt
            for (int j = 0; j < subscriptions.Length; j++)
            {
                if (XConnSrvTestHelpers.IsUserSubscribedTo(ownerXuid, subscriptions[j].qwOwnerXUID, (DATA_TYPES)subscriptions[j].wDataType))
                    return false;
            }

            Global.RO.Info("Unsubscribe complete for given DOS.");
            return true;
        }
        // public unsafe void HandleFriendsListChange(DataSubscriptionKey key, byte[] rgbData)
        //{
        //    USER_DATA[] rgNewFriends = null;
            
        //    if ((rgbData != null) && (rgbData.Length >= sizeof(USER_LIST_DATA)))
        //    {
        //        fixed (byte *pData = &(rgbData[0]))
        //        {
        //            USER_LIST_DATA *pUserList = (USER_LIST_DATA *)pData;
        //            USER_DATA *pNewFriends = (USER_DATA *)(pData + sizeof(USER_LIST_DATA));

        //            // make a new friends array.
        //            rgNewFriends = new USER_DATA[pUserList->dwNumUsers];
        //            for (int iFriend = 0; iFriend < rgNewFriends.Length; iFriend++)
        //            {
        //                // copy the friends over.
        //                rgNewFriends[iFriend] = pNewFriends[iFriend];
        //            }
        //        }
        //    }

        public static unsafe uint GetFriendsListFriends(SUBSCRIPTION_DATA data, out ulong[] friendsId)
        {
            byte[] drBytes = (byte[])data;
            FriendsList friends = (FriendsList)CacheUtil.ReadCacheItemFromBytes(drBytes);
            if ((friends == null) || (friends.rgUsers == null))
            {
                friendsId = null;
                return 0;
            }
            friendsId = new ulong[friends.rgUsers.Length];
            for (int i = 0; i < friends.rgUsers.Length; i++)
            {
                friendsId[i] = friends.rgUsers[i].qwXUID;
            }
            return (uint)friendsId.Length;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="userIndex"></param>
        /// <returns></returns>
        public static bool IsUserConnected(ulong userId, int userIndex)
        {
            string xmgmtcoutput = string.Empty;
            try
            {
                xmgmtcoutput = RunXmgmtCommand("showuser", userId);
            }
            catch (Exception)
            {
                return false;                
            }

            //verify user is connected
            if (!xmgmtcoutput.Contains("Connection found for user: " + String.Format("{0:X}", userId)))
            {
                Global.RO.Warn("User is not connected.");
                return false;
            }

            string[] lines = xmgmtcoutput.Split(Environment.NewLine.ToCharArray());
            foreach (string line in lines)
            {
                //verify user index
                if (line.StartsWith("\t" + userIndex.ToString()))
                {
                    string[] vals = line.Split(":".ToCharArray());
                    if (vals[1].Trim() == String.Format("{0:X}", userId))
                        return true;
                }
            }

            Global.RO.Warn("User is not connected.");
            return false;
        }

        public static string RunXmgmtCommand(string command, ulong userId, string cacheKey)
        {
            string xmgmtcoutput = string.Empty;
            ManagementConsole.Execute(GetUserCacheServerLocation(userId), "e :xconnsrv " + command + " " + cacheKey, out xmgmtcoutput);
            return xmgmtcoutput;
        }
        public static string RunXmgmtCommand(string command, ulong userId)
        {
            string xmgmtcoutput = string.Empty;
            ManagementConsole.Execute(GetUserCacheServerLocation(userId), "e :xconnsrv " + command + " " + userId.ToString(), out xmgmtcoutput);
            return xmgmtcoutput;
        }

        public static bool IsUserSubscribedTo (ulong userId, ulong subscribeeId, DATA_TYPES typ)
        {
            string xmgmtcoutput = RunXmgmtCommand("showuser", userId);

            if (! xmgmtcoutput.Contains("Subscriptions:"))
                return false;

            string subscriptioninfo = xmgmtcoutput.Substring(xmgmtcoutput.IndexOf("Subscriptions:"));   //xmgmtcoutput.Split("Subscriptions:".ToCharArray())[1]; //split the string at subscription.
            string[] subscriptionlines = subscriptioninfo.Split(Environment.NewLine.ToCharArray());

            //might need to add some check for null
            foreach(string line in subscriptionlines)
            {
                if (line.ToLower().Contains(typ.ToString().ToLower()) && line.Contains(String.Format("{0:X}", subscribeeId)))
                    return true;
            }

            return false;
        }

        public static ulong[] GetXmgmtSubscriptionInfoForUser(ulong userId, DATA_TYPES typ)
        {
            return GetXmgmtSubscriptionInfoForUser(userId, (ushort)typ);
        }
        public static ulong[] GetXmgmtSubscriptionInfoForUser(ulong userId, ushort typ)
        {
            string xmgmtcoutput = RunXmgmtCommand("showuser", userId);

            Assert.IsTrue(xmgmtcoutput.Contains("Subscriptions:"), "No connection info for this user.");

            string[] lines = xmgmtcoutput.Split(Environment.NewLine.ToCharArray());
            int iLineUsersStart = 0;
            while (!lines[iLineUsersStart].Contains("Connected users:"))
            {
                iLineUsersStart++;
            }
            iLineUsersStart++;
            iLineUsersStart++;

            // TODO: this should be XOn.XONLINE_MAX_LOGON_USERS
            int iQueriedUser = 0;
            //int numEmptylines = 0;
            for (int iUser = 0; iUser < 4; iUser++)
            {
                //if (string.IsNullOrEmpty(lines[iLineUsersStart + iUser]))
                //    numEmptylines++;
                if (lines[iLineUsersStart + iUser*2].Contains(userId.ToString("X")))
                {
                    // user index for the queried user.
                    iQueriedUser = iUser;
                    //iQueriedUser = iQueriedUser - numEmptylines;
                    break;
                }
            }

            int iLineSub = iLineUsersStart;
            while (!lines[iLineSub].Contains("Subscriptions:"))
            {
                iLineSub++;
            }
            iLineSub++;
            iLineSub++;

            ArrayList alUsers = new ArrayList();
            for (; (iLineSub < lines.Length) && (lines[iLineSub].Contains("(")); iLineSub+=2)
            {
                int iFlagsStart = lines[iLineSub].IndexOf('(') + 1;
                int iFlagsEnd = lines[iLineSub].IndexOf(')');
                string sFlags = lines[iLineSub].Substring(iFlagsStart, iFlagsEnd - iFlagsStart);
                uint dwFlags = uint.Parse(sFlags, System.Globalization.NumberStyles.HexNumber);
                if ((dwFlags & (uint)((uint)1 << iQueriedUser)) == 0)
                {
                    // sub not for this user.
                    continue;
                }

                int iKey = lines[iLineSub].IndexOf(": ") + 2;
                DATA_OBJECT_SPECIFIER doSpec = CacheUtil.GetDataKeyFromString(lines[iLineSub].Substring(iKey));
                if (doSpec.wDataType == typ)
                {
                    alUsers.Add(doSpec.qwOwnerXUID);
                }
            }

            ulong[] rgStupid = new ulong[alUsers.Count];
            for (int iStupid = 0; iStupid < rgStupid.Length; iStupid++)
            {
                rgStupid[iStupid] = (ulong)alUsers[iStupid];
            }
            return rgStupid;
        }

        public static void ReLogOn(PNUser u)
        {
            FriendsCommon fc = new FriendsCommon();
            fc.LogoffUser(u);
            fc.LogonUser(u);
        }

        public static void SetPrivacy(PNUser user, int privacy)
        {
            if (privacy == 0) // Blocked
            {
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE, false);
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, false);
            }
            else if (privacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
            {
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE, true);
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);
            }
            else if (privacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS)
            {
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE, false);
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);
            }
        }

        private static void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            ServerTestFramework.LiveService.UserAccount.UserPrivileges grants = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();
            ServerTestFramework.LiveService.UserAccount.UserPrivileges restrictions = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();

            Thread.Sleep(5000);
        }

        public static DATA_OBJECT_SPECIFIER[] GetFriendsListDataObjectSpecifierArray(ulong qwUserXuid)
        {
            //Get Dataobject Specifier for friends list.
            DATA_OBJECT_SPECIFIER[] friendsSpecifier = new DATA_OBJECT_SPECIFIER[1];
            DATA_OBJECT_SPECIFIER dos = new DATA_OBJECT_SPECIFIER();
            dos.wDataType = (ushort)DATA_TYPES.eFriendsList;
            dos.dwDataSubType = 0;
            dos.qwOwnerXUID = qwUserXuid;
            FriendsList friends = new FriendsList();
            friends.rgUsers = new UserData[100];
            for (int iFriend = 0; iFriend < friends.rgUsers.Length; iFriend++)
            {
                friends.rgUsers[iFriend] = new UserData();
            }
            dos.wObjectSize = (ushort)(friends.Size());
            friendsSpecifier[0] = dos;
            return friendsSpecifier;
        }

        public static string[] GetDataKeyStringArray(DATA_OBJECT_SPECIFIER[] doSpecs)
        {
            string[] doSpecStrings = new string[doSpecs.Length];

            for (int i = 0; i < doSpecs.Length; ++i)
            {
                doSpecStrings[i] = CacheUtil.GetDataKeyString(doSpecs[i]);
            }

            return doSpecStrings;
        }

        public static void SendNotifications(DATA_OBJECT_SPECIFIER doSpec)
        {
            SendNotifications(new DATA_OBJECT_SPECIFIER[] { doSpec });
        }

        public static void SendNotifications(DATA_OBJECT_SPECIFIER[] doSpecs)
        {
            if (MCServerNetwork._memCache.GetType() == typeof(AccelerationCache))
            {
                for (int i = 0; i < doSpecs.Length; ++i)
                {
                    string sKey = CacheUtil.GetDataKeyString(doSpecs[i]);
                    byte[] data = MCServerNetwork._memCache.Get(sKey);
                    MCServerNetwork._memCache.Set(sKey, data);
                } 
            }
            else
            {
                string[] notis = GetDataKeyStringArray(doSpecs);

                MCNotificationResponse response = new MCNotificationResponse(notis);
                MCServerNetwork.Notify(response);
            }

            Global.RO.Info("Notification issued.");
        }

        public static bool VerifyTotalNotificationsReceived(PNConnection connection, uint expectedMinNotifications, uint expectedMaxNotifications)
        {
            uint totalReceived = (uint)connection.GetTotalNotificationsLength();
            
            if (totalReceived < expectedMinNotifications)
            {
                Global.RO.Warn("TotalRecievedNotifications: " + totalReceived + " minExpected: " + expectedMinNotifications);
                return false;
            }
            if (totalReceived > expectedMaxNotifications)
            {
                Global.RO.Warn("TotalRecievedNotifications: " + totalReceived + " maxExpected: " + expectedMaxNotifications);
                return false;
            }
            Global.RO.Info("Correct number of notifications received.");
            return true;
        }

        public static bool VerifyTotalNotificationsReceived(PNConnection connection, uint expectedNotifications)
        {
            return VerifyTotalNotificationsReceived(connection, expectedNotifications, expectedNotifications);
        }

        #region RICH_PRESENCE

        public static Dictionary<string, string> defaultLocales = new Dictionary<string, string>()
        {
            {"de-DE", "THIS IS GERMAN"}, // GERMAN
			{"en-US", "THIS IS ENGLISH"}, // ENGLISH
            {"es-ES", "THIS IS SPANISH"}, // SPANISH
			{"fr-FR", "THIS IS FRENCH"}, // FRENCH
            {"it-IT", "THIS IS ITALIAN"}, // ITALIAN
            {"ja-JP", "THIS IS JAPANESE"}, // JAPANESE
            {"ko-KR", "THIS IS KOREAN"}, // KOREAN
            {"pl-PL", "THIS IS POLISH"}, // POLISH
            {"pt-PT", "THIS IS PORTUGUESE"}, // PORTUGUESE
            {"ru-RU", "THIS IS RUSSIAN"}, // RUSSIAN
            {"zh-CHT", "THIS IS TRADITIONAL CHINESE"}, // TRADITIONAL CHINESE
            {"zh-CN", "THIS IS SIMPLIFIED CHINESE"} // SIMPLIFIED CHINESE
        };

        public static void BuildAndInsertRichPresenceBlob(Dictionary<string, string> localesWithStrings, ulong qwUserID)
        {
            // NOTE: This code was totally haxed from private\common\community\presence\presenceutils.cs

            string[] locales = localesWithStrings.Keys.ToArray();
            string[] rgLocalizedStrings = localesWithStrings.Values.ToArray();
            uint dwHeaderFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | CacheUtil.XONLINE_CACHE_DATA_FLAG_LANGUAGE_SPECIFIC;

            LanguageSpecificData lsBlob = new LanguageSpecificData(DATA_TYPES.eRichPresenceString);
            lsBlob.OwnerID = qwUserID;
            lsBlob.HeaderFlags = dwHeaderFlags;
            lsBlob.rgLocales = locales;
            lsBlob.rgInnerBlobs = new BaseDataHeader[rgLocalizedStrings.Length];

            for (int iInner = 0; iInner < lsBlob.rgInnerBlobs.Length; iInner++)
            {
                RichPresenceData rich = new RichPresenceData();
                rich.header = lsBlob.header;
                rich.sRichPresence = rgLocalizedStrings[iInner];

                lsBlob.rgInnerBlobs[iInner] = rich;
            }

            CacheUtil.OverwriteCache(lsBlob);
        }

        public static unsafe byte[] BuildRichPresenceBlob(Dictionary<string, string> localesWithStrings, ulong qwUserID)
        {
            // get the locales for this title.
            string[] locales = new string[localesWithStrings.Count];
            string[] localeStringsDup = new string[localesWithStrings.Count];
            localesWithStrings.Keys.CopyTo(locales, 0);
            localesWithStrings.Values.CopyTo(localeStringsDup, 0);

            Assert.IsTrue(locales.Length != 0);

            // Remove duplicate strings, retaining order
            List<string> localeStrUniqueList = new List<string>();
            foreach (string rpstr in localeStringsDup)
            {
                if (!localeStrUniqueList.Contains(rpstr))
                    localeStrUniqueList.Add(rpstr);
            }

            LanguageSpecificData lsBlob = new LanguageSpecificData(DATA_TYPES.eRichPresenceString);
            lsBlob.OwnerID = qwUserID;
            lsBlob.rgLocales = localeStrUniqueList.ToArray();
            lsBlob.rgInnerBlobs = new BaseDataHeader[lsBlob.rgLocales.Length];

            for (int iString = 0; iString < lsBlob.rgInnerBlobs.Length; iString++)
            {
                RichPresenceData rich = new RichPresenceData();
                rich.OwnerID = qwUserID;
                rich.HeaderFlags = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE;
                rich.sRichPresence = localeStrUniqueList[iString];
                lsBlob.rgInnerBlobs[iString] = rich;
            }

            byte[] rgbFullData = (byte[])lsBlob;
            byte[] rgbPayloadOnly = new byte[rgbFullData.Length - sizeof(BASE_DATA_HEADER)];
            System.Buffer.BlockCopy(rgbFullData, sizeof(BASE_DATA_HEADER), rgbPayloadOnly, 0, rgbPayloadOnly.Length);

            return rgbPayloadOnly;
        }

        /// <summary>
        /// Used to extract the rich presence string from the SUBSCRIPTION_DATA we received from the notification and then
        /// compare it to the desired string for verification.
        /// </summary>
        /// <param name="subData">data portion of SUBSCRIPTION_NOTIFICATION containing rich presence blob</param>
        /// <param name="expectedResult">expected string result</param>
        /// <returns></returns>
        public static bool VerifyRichPresString(byte[] subData, string expectedResult)
        {
            if (subData.Length == 0)
            {
                if (expectedResult == null || expectedResult == "")
                    return true;

                return false;
            }

            unsafe
            {
                fixed (byte* data = &subData[0])
                {
                    ushort* shortData = (ushort*)data;
                    ushort length = *shortData;

                    if (length != expectedResult.Length * 2) // * 2 because of unicode
                    {
                        Global.RO.Warn("Incorrect string length returned.");
                        return false;
                    }

                    byte[] rp = new byte[length];
                    System.Buffer.BlockCopy(subData, 2, rp, 0, length);

                    System.Text.UnicodeEncoding enc = new System.Text.UnicodeEncoding();
                    string str = enc.GetString(rp);

                    if (str == expectedResult)
                    {
                        Global.RO.Error("Correct language specific stringm \"" + expectedResult + "\" returned.");
                        return true;
                    }

                    Global.RO.Warn("Languge specific string returned does not match the desired string.");
                    Global.RO.Warn("Desired: " + expectedResult);
                    Global.RO.Warn("Actual: " + str);
                    return false;
                }
            }
        }

        #endregion

        /// <summary>
        /// Returns a friendslist for a user
        /// </summary>
        /// <param name="userId"></param>
        /// <param name="friendsUserIds"></param>
        /// <remarks >
        /// 2 friends found for user: 9000002445813
        ///        0: 9000002445815, status = 0
        ///        1: 9000002445816, status = 0
        /// </remarks>
        public static int GetXConnSrvFriendListUsingXMgmtC(ulong userId, out ulong[] friendsUserIds)
        {
            string xmgmtOutput = RunXmgmtCommand("showfriends", userId);
            if (xmgmtOutput.Contains("No friends list found "))
            {
                friendsUserIds = null;
                return 0;
            }
            if (xmgmtOutput.Contains("was last connected to server"))
            {
                friendsUserIds = null;
                return 0;
            }
            int fCount = int.Parse(xmgmtOutput.Substring(0, xmgmtOutput.IndexOf(" ")));
            List<ulong> l = new List<ulong>();
            string[] lines = xmgmtOutput.Split(Environment.NewLine.ToCharArray());
            foreach (string line in lines)
            {
                if (line.Contains("friends found for user:")|| string.IsNullOrEmpty(line) || line == "") 
                    continue;
                string [] splits = line.Split(": ".ToCharArray());
                l.Add(Hexer.fromhex(splits[2].Substring(0, 13)));
            }
            friendsUserIds = l.ToArray();
            return fCount;
        }

        /// <summary>
        /// Return the string server name where this user was last located to.
        /// </summary>
        /// <param name="userId"></param>
        /// <returns>
        /// Output format as below:
        /// User 9000002445813 was last connected to server MATTCHIL-LKG1(10.121.148.121) from client address 10.121.152.246:27099.
        /// </returns>
        public static string GetUserCacheServerLocation(ulong userId)
        {
            string xmgmtcoutput = string.Empty;
            ManagementConsole.Execute(Global.XEnv.GetServerListByComponent("xconnsrv")[0], "e :xconnsrv userlocation " + userId.ToString(), out xmgmtcoutput);
            string verificationString = "User " + userId.ToString("X") + " was last connected to server ";
            Assert.IsTrue( xmgmtcoutput.Contains(verificationString), "xmgmtcoutput: " + xmgmtcoutput);
            int startidx = verificationString.Length;
            int stopidx = xmgmtcoutput.IndexOf("(");
            return xmgmtcoutput.Substring(startidx, stopidx - startidx);
        }

        /// <summary>
        /// Takes the original DATA_OBJECT_SPECIFIER and the expected string, and creates a new DATA_OBJECT_SPECIFIER to represent
        /// the new size we expect based on the string.
        /// </summary>
        /// <param name="originalDOS">Original DATA_OBJECT_SPECIFIER that represents the Rich Presence blob in the cache</param>
        /// <param name="expectedString">The expected Rich Presence string</param>
        /// <returns></returns>
        public static DATA_OBJECT_SPECIFIER[] CreateExpectedRichPresenceDOS(DATA_OBJECT_SPECIFIER originalDOS, string expectedString)
        {
            DATA_OBJECT_SPECIFIER[] expectedDOS = new DATA_OBJECT_SPECIFIER[1];
            expectedDOS[0] = originalDOS;
            unsafe
            {
                expectedDOS[0].wObjectSize = (ushort)(sizeof(BASE_DATA_HEADER) + 2 + expectedString.Length * 2); // ushort size + every other letter
            }

            return expectedDOS;
        }

        public static void PutToVelocity(string key, byte[] data)
        {
            if (MCServerNetwork._memCache.GetType() == typeof(AccelerationCache))
            {
                MCServerNetwork._memCache.Set(key, data);
            }
            else
            {
                //Nothing for FakeMC
            }

            Global.RO.Info("Data Saved in Velocity.");
        }

        public static void ChangeServerLocation(ulong userId, string clientIp, int port, string newLocation)
        {
            // write the location blob to memcache.
            DATA_OBJECT_SPECIFIER doSpec = new DATA_OBJECT_SPECIFIER();
            doSpec.wDataType = (ushort)DATA_TYPES.eConnSrvLocation;
            doSpec.qwOwnerXUID = userId;
            byte[] rgbLocationData = BuildLocationData(userId, IpAddressToDword(IPAddress.Parse(clientIp)), port, newLocation);
            PutToVelocity(CacheUtil.GetDataKeyString(doSpec), rgbLocationData);
        }

        private unsafe static byte[] BuildLocationData(ulong userId, uint clientIPAddressDWord, int clientIPPort, string newLocation)
        {
            ConnSrvLocation location = new ConnSrvLocation();
            location.OwnerID = userId;
            location.dwClientIP = clientIPAddressDWord;
            location.wClientPort = (ushort)clientIPPort;
            IPAddress newLocationIP;
            try
            {
                newLocationIP = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostAddresses(newLocation)[0]).AddressList[0];
            }
            catch (Exception)
            {
                newLocationIP = System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName()).AddressList[0];
            }
            location.dwServerIP = (uint)System.Net.IPAddress.NetworkToHostOrder((int)IpAddressToDword(newLocationIP));
            location.sServerName = newLocation;
            
            return (byte[])location;
        }

        private static uint IpAddressToDword(IPAddress ip)
        {
            byte[] addr = ip.GetAddressBytes();
            return ((uint)addr[3]) + ((uint)addr[2] << 8) + ((uint)addr[1] << 16) + ((uint)addr[0] << 24);
        }

        public static bool VerifyPrivacyInSubscriptionReply(SUBSCRIBE_REPLY subReply, int expectedPrivacy)
        {
            if (expectedPrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
                expectedPrivacy = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS;

            foreach (SUBSCRIPTION_DATA sd in subReply.rgDataObjects)
            {
                if ((sd.dwHeaderFlags & expectedPrivacy) != expectedPrivacy)
                {
                    Global.RO.Warn("Header privacy mismatch. Actual: " + sd.dwHeaderFlags + " != Expected: " + expectedPrivacy);
                    return false;
                }
            }

            return true;
        }

        public static bool VerifyPrivacyInSubscriptionReply(SUBSCRIBE_REPLY subReply, int[] expectedPrivacy, DATA_OBJECT_SPECIFIER[] doSpecs)
        {
            if (subReply.rgDataObjects.Length != expectedPrivacy.Length)
                return false;
            
            for (int i = 0; i < subReply.rgDataObjects.Length; ++i)
            {
                for (int j = 0; j < doSpecs.Length; j++)
                {
                    if (doSpecs[j].qwOwnerXUID == subReply.rgDataObjects[i].qwOwnerXUID)
                    {
                        if (expectedPrivacy[j] == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
                            expectedPrivacy[j] = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS;

                        if ((subReply.rgDataObjects[i].dwHeaderFlags & expectedPrivacy[j]) != expectedPrivacy[j])
                        {
                            Global.RO.Warn("Header privacy mismatch. Actual: " + subReply.rgDataObjects[i].dwHeaderFlags + " != Expected: " + expectedPrivacy[i]);
                            return false;
                        }
                    }
                }
            }

            return true;
        }

        public static string RichPresenceString1 = "Single Player: Medium paddle, Fast ball";
        public static string RichPresenceString2 = "Single Player: Medium paddle, Slow ball";

        public static void SetTitleData(PNUser subscribee)
        {
            subscribee.Xbox.ChangeTitle(Pong.TitleId, 0, 0);

            GIBlob gi = new GIBlob();
            gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.SinglePlayer);
            gi.AddContext((uint)Pong.Context.GameSize, (uint)Pong.GameSize.Medium);
            gi.AddContext((uint)Pong.Context.GameSpeed, (uint)Pong.GameSpeed.Fast);
            subscribee.State = subscribee.State /*& subscribee.State;//*/ | XonPresNoti.P_STATE_ENUM_AWAY;
            subscribee.SetTitleData(gi.GetBytes());
        }

        public static void SetTitleData2(PNUser subscribee)
        {
            subscribee.Xbox.ChangeTitle(Pong.TitleId, 0, 0);

            GIBlob gi = new GIBlob();
            gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.SinglePlayer);
            gi.AddContext((uint)Pong.Context.GameSize, (uint)Pong.GameSize.Medium);
            gi.AddContext((uint)Pong.Context.GameSpeed, (uint)Pong.GameSpeed.Slow);
            subscribee.State = subscribee.State /*& subscribee.State;//*/ | XonPresNoti.P_STATE_ENUM_AWAY;
            subscribee.SetTitleData(gi.GetBytes());
        }

        #region PNCONNECTION_VERIFICATION

        public static bool VerifyIndividualNotificationReceived(PNConnection connection, DATA_OBJECT_SPECIFIER doSpec, uint userIndex, int waitSeconds)
        {
            return VerifyIndividualNotificationReceived(connection, doSpec, userIndex, waitSeconds, XConnSrvTestHelpers.RichPresenceString1);
        }

        public static bool VerifyIndividualNotificationReceived(PNConnection connection, DATA_OBJECT_SPECIFIER doSpec, uint userIndex, int waitSeconds, string richPresenceStringExpected)
        {
            /*
             * poll for some amount of time.
             * in a loop
             * check the queue if there is anything in there.
             * dequeue it and verify against datakeystring
            */

            int headerSize = 0;

            unsafe
            {
                headerSize = sizeof(BASE_DATA_HEADER);
            }

            int sleepTime = 1000;//mili seconds
            int loopctr = sleepTime * waitSeconds;
            for (int i = 0; i <= loopctr; i += 100)
            {
                foreach (DATA_NOTIFICATION d in connection.NotificationsReceived)
                {
                    if (d.dwNumDataObjects != 0)
                    {
                        foreach (SUBSCRIPTION_DATA s in d.rgDataObjects)
                        {
                            if (s.qwOwnerXUID == doSpec.qwOwnerXUID &&
                                s.wDataType == doSpec.wDataType &&
                                //s.wObjectSize == doSpec.wObjectSize &&
                                (doSpec.wObjectSize > headerSize ? (s.wObjectSize > headerSize && s.wObjectSize <= doSpec.wObjectSize) : s.wObjectSize == headerSize) &&
                                (d.header.dwUserIndexFlags & (1 << (int)userIndex)) == (1 << (int)userIndex))
                            {
                                // If it is rich presence, let's verify the string
                                if (doSpec.wDataType == (ushort)DATA_TYPES.eRichPresenceString)
                                {
                                    if (!XConnSrvTestHelpers.VerifyRichPresString(s.data, richPresenceStringExpected))
                                        Assert.IsTrue(false, "Rich Presence string was not valid.");
                                    else
                                        Global.RO.Info("Correct Rich Presence string received.");
                                }

                                //if (s.wObjectSize == doSpec.wObjectSize)
                                return true;
                            }
                        }
                    }
                }
                System.Threading.Thread.Sleep(100);
            }
            Global.RO.Warn("Notification not found for key: " + CacheUtil.GetDataKeyString(doSpec));
            return false;
        }

        public static bool VerifyNotificationsReceived(PNConnection connection, DATA_OBJECT_SPECIFIER[] doSpecs, uint userIndex, int waitSeconds)
        {
            foreach (DATA_OBJECT_SPECIFIER dos in doSpecs)
            {
                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, dos, userIndex, waitSeconds))
                    return false;
            }

            return true;
        }

        public static bool VerifyNotificationsReceived(PNConnection connection, DATA_OBJECT_SPECIFIER[] doSpecs, uint userIndex, int waitSeconds, string richPresenceStringExpected)
        {
            foreach (DATA_OBJECT_SPECIFIER dos in doSpecs)
            {
                if (!XConnSrvTestHelpers.VerifyIndividualNotificationReceived(connection, dos, userIndex, waitSeconds, richPresenceStringExpected))
                    return false;
            }

            return true;
        }

        public static bool VerifyNotificationPrivacy(PNConnection connection, int expectedPrivacy)
        {
            if (expectedPrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
                expectedPrivacy = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS;

            foreach (DATA_NOTIFICATION d in connection.NotificationsReceived)
            {
                if (d.dwNumDataObjects != 0)
                {
                    foreach (SUBSCRIPTION_DATA s in d.rgDataObjects)
                    {
                        bool valid = true;

                        if (s.wDataType == (uint)DATA_TYPES.eRichPresenceString)
                        {
                            if (s.dwHeaderFlags != expectedPrivacy)
                            {
                                valid = false;
                            }
                        }
                        else if ((s.dwHeaderFlags & expectedPrivacy) != expectedPrivacy)
                        {
                            valid = false;
                        }

                        if(valid == false)
                        {
                            if (s.data.Length == 0) continue; //offline notification doesn't matter. it is always share everyone.
                            Global.RO.Warn("Notification privacy mismatch. Type: " + s.wDataType + " Actual: " + s.dwHeaderFlags + " != Expected: " + expectedPrivacy);
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        #endregion // PNCONNECTION_VERIFICATION

        public static bool VerifyFriendsListNotifications(PNConnection connection, PNUser owner, PNUser[] friends)
        {
            return VerifyFriendsListNotifications(connection, owner, friends, new PNUser[] { }, new PNUser[] { });
        }

        public static bool VerifyFriendsListNotifications(PNConnection connection, PNUser owner, PNUser[] friends, PNUser[] requestedFriends, PNUser[] pendingFriends)
        {
            foreach (DATA_NOTIFICATION noti in connection.NotificationsReceived)
            {
                if (noti.dwNumDataObjects != 0)
                {
                    foreach (SUBSCRIPTION_DATA subData in noti.rgDataObjects)
                    {
                        if (subData.qwOwnerXUID == owner.UserId && subData.wDataType == (ushort)DATA_TYPES.eFriendsList)
                        {
                            FriendsList friendsList = (FriendsList)CacheUtil.ReadCacheItemFromBytes((byte[])subData);

                            if (friendsList == null) // This would be a problem...
                                continue;

                            if (friendsList.dwNumUsers != (friends.Length + requestedFriends.Length + pendingFriends.Length))
                                continue;

                            int equalFriendCount = 0;
                            int equalRequestedFriendCount = 0;
                            int equalPendingFriendCount = 0;

                            // Look for matching accepted buddies
                            foreach (PNUser friend in friends)
                            {
                                if (friendsList.IsAcceptedBuddy(friend.UserId))
                                   ++equalFriendCount;
                            }

                            // Look for matching requested buddies
                            foreach (PNUser requestedFriend in requestedFriends)
                            {
                                if(friendsList.IsRequestedBuddy(requestedFriend.UserId))
                                    ++equalRequestedFriendCount;
                            }

                            // Look for pending buddies
                            foreach (PNUser pendingFriend in pendingFriends)
                            {
                                if (friendsList.IsPendingBuddy(pendingFriend.UserId))
                                    ++equalPendingFriendCount;
                            }

                            if (equalFriendCount == friends.Length && equalRequestedFriendCount == requestedFriends.Length && equalPendingFriendCount == pendingFriends.Length)
                                return true;
                        }
                    }
                }
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\XCryptoEncrypt.cs ===
﻿using System;
using System.Web;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.xcrypto.fd
{
    internal sealed class XCryptoEncrypt : XCryptoOperationBase<XCryptoEncryptRequest>
    {
        protected override XRLObject2 PerformCryptoAction(XCryptoEncryptRequest request, CryptoKey ck)
        {
            XCryptoEncryptResponse response = new XCryptoEncryptResponse();
            response.cipher = new XCryptoData(ck.Encrypt(request.clear.data));
            return response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\XCryptoVerifySignature.cs ===
using System;
using System.Web;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.xcrypto.fd
{
    internal sealed class XCryptoVerifySignature : XCryptoOperationBase<XCryptoVerifySignatureRequest>
    {
        protected override XRLObject2 PerformCryptoAction(XCryptoVerifySignatureRequest request, CryptoKey ck)
        {
            XCryptoVerifySignatureResponse response = new XCryptoVerifySignatureResponse();
            byte[] sha1 = request.sha1.data;
            byte[] sig = request.sig.data;
            response.verified = ck.VerifySignature(sha1, sig);
            return response;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\XCryptoMgmt.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.xcrypto;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.Reporting)]
[assembly: XomAreaDefinition(XomAreaName.XCrypto)]

namespace xonline.server.xcrypto.fd
{
    public static class XCryptoMgmt
    {
        private static string _helpString = "XCrypto help:\r\n RefreshCache -- Force the XCrypto cache to refresh";

        static XCryptoMgmt()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XCryptoMgmt.OnControlRequest);
        }
        
        public static void Init()
        {
            // This space intentionally left blank.
            // This empty function is referenced by XCrypto, so it will
            // run the static constructor when the assembly is referenced.
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();
            switch(cmd)
            {
                case "help":
                   XomControlConnection.SendMessage(_helpString, args.RequestId);
                   args.Handled = true;
                   break;
                case "refreshcache":
                   try
                   {
                       CryptoKeyCache.RefreshCache();
                       XomControlConnection.SendMessage("Cache successfully refreshed.", args.RequestId);
                   }
                   catch(Exception e)
                   {
                       XomControlConnection.SendMessage("Cache failed to refresh.  Exception:", args.RequestId);
                       XomControlConnection.SendMessage(e.ToString(), args.RequestId);
                   }

                   args.Handled = true;
                   break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\XCryptoOperationBase.cs ===
using System;
using System.ComponentModel;
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.xcrypto;
using xonline.common.installer;

[assembly: XomIisInstallerAttribute(Interface.xcrypto_int)]
[assembly: ConfigAttribute(xonline.common.config.Component.xcrypto)]

namespace xonline.server.xcrypto.fd
{
    internal abstract class XCryptoOperationBase<TRequest> : IHttpHandler
        where TRequest : XCryptoRequestBase, new()
    {
        ///
        /// Breakpoint: xonline.server.xcrypto.fd.XCryptoSign.ProcessRequest
        ///
        public void ProcessRequest(HttpContext context)
        {
            uint hr = HResult.S_OK;
            bool bSuccess = false;

            try
            {
                CallSource.Check(VirtualInterface.xcrypto_int);

                TRequest request = new TRequest();
                request.ReadFromRequest(context.Request);

                CryptoKey ck = CryptoKeyCache.Cache.GetCryptoKey((EContainerClasses)request.containerClass);
                XRLObject2 response = PerformCryptoAction(request, ck);
                XRLUtil.SetXRLResponse(context.Response, XOService.Crypto, hr, response);
                
                bSuccess = true;
            }
            catch(Exception e)
            {
                throw new XRLException( HResult.XONLINE_E_XCRYPTO_REQUEST_FAILED, 
                                        XEvent.Id.XCRYPTO_REQUEST_FAILED, 
                                        e,
                                        "{0} request failed.  See inner exception for reason.",
                                        typeof(TRequest).Name );
            }
            finally
            {
                string logString = String.Format("{0}|{1}", 
                        typeof(TRequest).Name,
                        bSuccess
                        );

                Xom.Trace(XomAreaName.XCrypto, LogLevel.L_LOW, logString);
                Xom.Log(XomAreaName.log, logString);
            }
        }

        ///
        /// Can this instance be reusable?
        /// Since we hold no state in these requests, the answer is yes.
        ///
        public bool IsReusable { get { return true; } }

        protected abstract XRLObject2 PerformCryptoAction(TRequest request, CryptoKey ck);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\NCipherWrap\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\XCryptoSign.cs ===
using System;
using System.Web;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.xcrypto.fd
{
    internal sealed class XCryptoSign : XCryptoOperationBase<XCryptoSignRequest>
    {
        protected override XRLObject2 PerformCryptoAction(XCryptoSignRequest request, CryptoKey ck)
        {
            XCryptoSignResponse response = new XCryptoSignResponse();
            byte[] sig = ck.Sign(request.sha1.data);
            response.sig = new XCryptoData(sig);
            return response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\fd\XCryptoVerifyConsolePak.cs ===
using System;
using System.Web;
using System.IO;
using System.Security.Cryptography;
using System.Runtime.InteropServices;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities2;

namespace xonline.server.xcrypto.fd
{
    internal sealed class XCryptoVerifyConsolePak : XCryptoOperationBase<XCryptoVerifyConsolePakRequest>
    {
        protected override XRLObject2 PerformCryptoAction(XCryptoVerifyConsolePakRequest request, CryptoKey ck)
        {
            XCryptoVerifyConsolePakResponse response = new XCryptoVerifyConsolePakResponse();

            // Get the Sha1 hash of the consoleid and append it with the first 4 bytes of
            // itself, giving us 24 bytes.  Encrypt that with the master activation key
            // (in the nCipher device). This gives us the primary activation key. However, 
            // the console only uses the first 16 bytes of this when encrypting things.
            byte[] hash = ClearPakFromConsoleId(request.consoleId);
            byte[] pak = EncryptWithMasterActivationKey(hash);
            Array.Resize(ref pak, USED_PAK_SIZE);

            // Only do the encryption if we are supposed to do the real pak test. I'm 
            // doing this test after we call into native side we we get "end-do-end" 
            // testing.
            if (Config.GetBoolSetting(Setting.xcrypto_DoRealPakTest))
            {
                try
                {
                    // Encrypt the clear data with the pak and compare it with the encrypted
                    // data. This will tell us whether the appropriate pak was used for this 
                    // request.
                    byte[] pakEncryptedByUs = EncryptWithPak(request.clear.data, pak);
                    response.verified = ArrayUtil.CompareArrays(pakEncryptedByUs, request.pakEncrypted.data);
                }
                finally
                {
                    Array.Clear(pak, 0, pak.Length);
                }
            }
            else
            {
                response.verified = true;
            }
            return response;
        }

        private static byte[] ClearPakFromConsoleId(UInt64 consoleId)
        {
            SHA1 sha1 = new SHA1Managed();
            byte[]  hash = sha1.ComputeHash(BitConverter.GetBytes(consoleId));
            int origSize = hash.Length;
            Array.Resize(ref hash, WHOLE_PAK_SIZE);
            Array.ConstrainedCopy(hash, 0, hash, origSize, WHOLE_PAK_SIZE - origSize);
            return hash;
        }

        private static byte[] EncryptWithMasterActivationKey(byte[] hash)
        {
            byte[] cipher = new byte[hash.Length];
            UInt32 cipherLen = 0;

            // TODO: Real KeyApp, KeyName and keyType and encryptType
            UInt32 ret = NCW_EncryptBlobWithKey(KEY_APP, KEY_NAME, KEY_TYPE, ENCRYPT_TYPE, hash, (UInt32)hash.Length, cipher, ref cipherLen, (UInt32)cipher.Length);
            if (ret != 0)
            {
                throw new XRLException( HResult.XONLINE_E_XCRYPTO_NCIPHER_ERROR,
                                        XEvent.Id.XCRYPTO_NCIPHER_ERROR,                                
                                        "NCW_EncryptBlobWithKey failed with NCERROR error code of {0}.", 
                                        ret );
            }
            if (cipherLen != cipher.Length)
            {
                throw new XRLException( HResult.XONLINE_E_XCRYPTO_NCIPHER_ERROR,
                                        XEvent.Id.XCRYPTO_NCIPHER_ERROR,
                                        "Cipherlenth mismatch with NCW_EncryptBlobWithKey. Expected size = {0}; Returned size = {0}", 
                                        cipher.Length, 
                                        cipherLen );
            }
            return cipher;
        }

        [DllImport("NCipherWrap.dll", BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern UInt32 NCW_EncryptBlobWithKey(
            [MarshalAs(UnmanagedType.LPStr)]
            string szKeyApp,
            [MarshalAs(UnmanagedType.LPStr)]
            string szKeyName,
            Int32 keyType,
            Int32 encryptType,
            byte[] pbPlainText,
            UInt32 cbPlainText,
            byte[] pbCipherText,
            ref UInt32 pcbCipherText,
            UInt32 cbCipherTextBuffer);
        private const string KEY_APP = "xbox";
        private const string KEY_NAME = "MasterActivationKey";
        private const Int32 KEY_TYPE = 3; // NCKEY_TYPE_SYMMETRIC
        private const Int32 ENCRYPT_TYPE = 2; // NCENCRYPT_TYPE_3DES

        private static byte[] EncryptWithPak(byte[] clear, byte[] pak)
        {
            using (SymmetricAlgorithm sa = new RijndaelManaged())
            {
                sa.Padding = PaddingMode.None;
                sa.Mode = CipherMode.ECB;

                using (ICryptoTransform encryptor = sa.CreateEncryptor(pak, new byte[sa.IV.Length]))
                {
                    byte[] encrypted = new byte[clear.Length];
                    using (MemoryStream ms = new MemoryStream(encrypted))
                    {
                        using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                        {
                            cs.Write(clear, 0, clear.Length);
                        }
                    }
                    return encrypted;
                }
            }
        }

        const int WHOLE_PAK_SIZE = 24;
        const int USED_PAK_SIZE = 16;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\NCipherWrap\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <windows.h>
#include <assert.h>

#include "XeNcipher.h"

#include "NCipherWrap.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\NCipherWrap\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_ncipherwrap_none_12.4.56.0_none_9a393b0260a89fd1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=ncipherwrap
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719.manifest
XP_MANIFEST_PATH=manifests\x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719.cat
XP_CATALOG_PATH=manifests\x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719.cat
XP_PAYLOAD_PATH=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=ncipherwrap,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\NCipherWrap\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// NOTE: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\NCipherWrap\dll\NCipherWrap.h ===
/*
 * NCipherWrap.h
 *
 * Declares exported functions for the NCipherWrap dll.
 *
*/

#include "XeNcipher.h"

NCERROR NCW_EncryptBlobWithKey(
    char const * szKeyApp,
    char const * szKeyName,
    NCKEY_TYPE keyType,
    BYTE const * pbPlainText,
    DWORD cbPlainText,
    BYTE * pbCipherText,
    DWORD * pcbCipherText,
    DWORD cbCipherTextBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\NCipherWrap\dll\NCipherWrap.cpp ===
/*
 * NCipherWrap.cpp
 *
 * Implementation of the NCipherWrap dll functions.
 *
*/

#include "stdafx.h"

#include "NCipherWrap.h"
#include "xmgmt.h"
#include "xeventids.h"
#include <commonconfig.h>
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers

#define ON_NCERROR_GOTO(e, funcName) \
    do \
    { \
        error = (e); \
        if (error != NCERROR_NOERROR) \
        { \
            XomNtEvent(XEVENT_XCRYPTO_NCIPHER_ERROR, "%s failed with error %u", (funcName), error); \
            goto Error; \
        } \
    } while (FALSE) \


#define ON_ERROR_GOTO(_hr)                                                                                                                      \
    do {                                                                                                                                        \
        hr = (_hr);                                                                                                                             \
        if (FAILED(hr)) {                                                                                                                       \
            XomNtEvent(XEVENT_XCRYPTO_GENERIC_ERROR, "Settings failed in NCipherWrapper.cpp. Failure: 0x%08X File: %s Function: %s Line: %d\n", hr, __FILE__, __FUNCTION__, __LINE__); \
            goto Error;                                                                                                                         \
        }                                                                                                                                       \
    } while (FALSE)                                                                                                                             \


#define ON_NO_MEM_GOTO(_p) ON_ERROR_GOTO((_p) ? S_OK : E_OUTOFMEMORY)

//
// Wrapper class for getting settings.
// This isn't as genericly useful as I'd like it to be, so I'm leaving it here instead of 
// putting somewhere central. If I ever come up with a better helper class for this I'll 
// move it.
//
using namespace XblConfig;
class SettingWrapper
{
public:
    SettingWrapper()
        : _hr(E_FAIL)
    {
        HRESULT hr = S_OK;
        ON_ERROR_GOTO(_spiConfig.CoCreateInstance(__uuidof(ConfigInterop)));

Error:
        _hr = hr;
    }

    DWORD GetDWORDSetting(wchar_t const * const wzSettingName, DWORD default)
    {
        HRESULT hr = S_OK;
        DWORD ret = default;
        CComBSTR bstrName;
        CComBSTR bstrValue;

        ON_ERROR_GOTO(_hr);

        ON_NO_MEM_GOTO(bstrName = wzSettingName);
        ON_ERROR_GOTO(_spiConfig->GetSetting(bstrName, &bstrValue));
        ret = wcstoul(bstrValue, NULL, 0);

Error:
        return ret;
    }

private:
    CComPtr<IConfig> _spiConfig;
    HRESULT _hr;
};

static SettingWrapper s_settingWrapper;
static wchar_t const * const s_xcrypto_DoRealPakTest = L"xcrypto_DoRealPakTest";

//
// Wrapper for NCipher initialization. Declare one of these and it will
// keep the ncipher device "initted" until it goes out of scope.
//
class NCipherInitHandler
{
public:
    NCipherInitHandler()
        : error(NCERROR_UNEXPECTED)
    {
        if (s_settingWrapper.GetDWORDSetting(s_xcrypto_DoRealPakTest, 0))
        {
            ON_NCERROR_GOTO(NcInit(), "NcInit");
        }

Error:
        ;
    }

    NCERROR InitError()
    {
        return error;
    }

    ~NCipherInitHandler()
    {
        if (error != NCERROR_NOERROR)
        {
            NcTerm();
        }
    }

private:
    NCERROR error;
};

static NCipherInitHandler s_initHandler;


NCERROR NCW_EncryptBlobWithKey(
    char const * const szKeyApp,
    char const * const szKeyName,
    NCKEY_TYPE const keyType,
    NCENCRYPT_TYPE const encryptType,
    BYTE const * const pbPlainText,
    DWORD const cbPlainText,
    BYTE * const pbCipherText,
    DWORD * const pcbCipherText,
    DWORD const cbCipherTextBuffer)
{
    NCERROR error = NCERROR_NOERROR;
    HNCKEY hKey = 0;

    // Do nothing if we aren't going to do a real pak test. I'm checking this here as well  
    // as in the managed code so we test the "end-to-end" flow even if we don't use 
    // nCipher.
    if (!s_settingWrapper.GetDWORDSetting(s_xcrypto_DoRealPakTest, 0))
    {
        memset(pbCipherText, 0, cbCipherTextBuffer);
        *pcbCipherText = cbCipherTextBuffer;
        goto Error;
    }

    ON_NCERROR_GOTO(s_initHandler.InitError(), "s_initHandler.InitError");

    ON_NCERROR_GOTO(NcOpenKey(const_cast<char*>(szKeyApp), const_cast<char*>(szKeyName), keyType, &hKey), "NcOpenKey");
    ON_NCERROR_GOTO(NcEncrypt(hKey, encryptType, const_cast<BYTE*>(pbPlainText), cbPlainText, pbCipherText, pcbCipherText, cbCipherTextBuffer), "NcEncrypt");

Error:
    if (hKey != 0)
    {
        (void)NcCloseKey(hKey);
    }

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\NCipherWrap\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_ncipherwrap_none_12.4.56.0_none_9a393b0260a89fd1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=ncipherwrap
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719.manifest
XP_MANIFEST_PATH=manifests\x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719.cat
XP_CATALOG_PATH=manifests\x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719.cat
XP_PAYLOAD_PATH=x86_ncipherwrap_no-public-key_12.4.56.0_x-ww_7fe5c719
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=ncipherwrap,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\test\makefile.inc ===
!include $(NTMAKEENV)\msbuild.def
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\test\XRLCryptoVerifyConsolePAK.cs ===
using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService.XCrypto;
using xonline.common.protocol;

namespace XCrypto.Functional
{
    // =====================================================================
    // [VerifyConsolePAK] 
    //      There is no simple way to verify the console PAK without
    //  sending the data in the clear to the server. The way 
    //  we do it using xCrypto can be a bit confusing so I am going 
    //  to describe the situation to the best of my knowledge up
    //  front.
    // ---------------------------------------------------------------------
    //      The PAK is the console Primary Activation Key. This data is 
    //  going to be used to identify a console for IPTV(Carbon). It is 
    //  fair to assume that the PAK is unique per console, and cannot 
    //  easily be derived by the end user. 
    //      The PAK is actually just a hash of the consoleId that is
    //  encrypted with the super secret private master key.
    // ---------------------------------------------------------------------
    //      VerifyConsolePAK can verify that the console PAK is the 
    //  same as what is was originally assigned by following a series of
    //  steps and data calculations.
    //
    //  1. The console needs to verify that the PAK is valid before
    //      allowing a user to perform a certain task. This decision 
    //      is to be made by the Live service.
    //  2. The console takes a chunk of data, and calculates a hash of 
    //      that data.
    //  3. The first 16 bytes of that data are then encrypted with the 
    //      console PAK.
    //  4. A request is made to Live containing the consoleID, encrypted
    //      hash, and data chunk in the clear.
    //  5. The Live service then takes that clear data and calculates
    //      its own hash.
    //  6. The Live hash, ConsoleId, and encrypted hash are sent to xCrypto.
    //  7. xCrypto calculates the PAK based on the received ConsoleId.
    //  8. xCrypto then encrypts the first 16 Bytes of the in the clear
    //      hash from the request, and compares it to the encrypted
    //      hash received from the console.
    //  9. If the hashes match, a response of valid is sent to the client.
    //      If then do not, a response of invalid is sent to the client.
    // 
    // =====================================================================


    // Test data from the console.
    //
    // ConsoleId: 008307777346
    //
    // ConsolePAK[24]: 0xB8, 0xC7, 0xC5, 0xF0, 0x36, 0x7E, 0xEB, 0x6F, 
    //  0xA7,0x6C, 0x3D, 0xB2, 0x81, 0x9D, 0x69, 0x71, 0x53, 0x79, 0xD0, 
    //  0x76, 0xC6, 0x51, 0x85, 0xC0
    //  
    // Clear Data[128]: 0xF4,0x2A,0x54,0x1C,0x3A,0xE9,0x59,0xA3,0xD7,0xD8,
    //  0x48,0x8D,0x4A,0x87,0xD8,0x70,0xFD,0x17,0x3D,0x14,0x47,0xCE,0x70,
    //  0xC4,0x57,0x44,0x07,0xA9,0x82,0x5F,0xEA,0x4D,0x9C,0x6A,0x96,0x76,
    //  0xB4,0xEB,0xB8,0x9C,0x37,0xFF,0x9E,0x6B,0xD1,0xCC,0xFF,0x71,0x83,
    //  0x0E,0xC4,0x9E,0x21,0xBB,0x09,0x79,0x7B,0xBC,0xFB,0xE3,0xD8,0xA7,
    //  0xD6,0x9A,0x9C,0xE7,0x72,0xCB,0x14,0x9C,0xE8,0x66,0x24,0xFD,0xFA,
    //  0x5A,0xFF,0x39,0xB7,0x1E,0xF1,0xA9,0x9B,0xF3,0xFA,0x84,0x57,0x72,
    //  0xB9,0x19,0xDD,0xCD,0xFB,0x1E,0xB9,0x98,0xE2,0x3A,0xB1,0xF0,0x37,
    //  0xC5,0xC8,0x30,0x29,0x07,0x4E,0x51,0x1D,0xCD,0x59,0x3C,0xF4,0x45,
    //  0xE5,0xBB,0xB5,0xF4,0x29,0xC6,0x3B,0xEB,0x97,0xA1,0xD1,0x1E,0x5C,
    //  0x72
    //
    // Hash Data PreEncrypt[20]: 0xCE,0xCC,0xEB,0xFB,0x0D,0x38,0x1F,0x8C,
    //  0xD1,0xFB,0x0F,0xCB,0x62,0xAC,0x48,0xC2,0x87,0x7B,0x45,0x46
    //
    // Hash Data PostEncrypt[16]: 0xA0,0x42,0x0A,0x09,0x85,0x49,0xAD,0xFD,
    //  0xAB,0x4D,0xEC,0x85,0x8C,0x05,0x33,0x91 (Trimmed)
    //
    [TestGroup]
    public class VerifyConsolePak : TestNode
    {
        public static UInt64 consoleId = 008307777346;
        public static byte[] clearHashTrimmed = new byte[] { 0xCE, 0xCC, 0xEB, 0xFB, 0x0D, 0x38, 0x1F, 0x8C, 0xD1, 0xFB, 0x0F, 0xCB, 0x62, 0xAC, 0x48, 0xC2 };
        public static byte[] consoleEncryptedHash = new byte[] { 0xA0, 0x42, 0x0A, 0x09, 0x85, 0x49, 0xAD, 0xFD, 0xAB, 0x4D, 0xEC, 0x85, 0x8C, 0x05, 0x33, 0x91 };

        [TestCase, Description("Mainline testcase. Sends a request to verify that the PAK used to encrypt some blob is valid for that ConsoleId")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_VerifyConsolePAK_BVT : TestNode
        {
            public override void PreRun()
            {
                if (!Global.XEnv.GetBoolSetting("xcrypto_DoRealPakTest"))
                {
                    Global.RO.Warn("Real PAK Test is not enabled, this test will just verify that we can call the API, not that it's working properly.");
                }
            }

            public override void Run()
            {
                XRLXCryptoVerifyConsolePak verifyPak = new XRLXCryptoVerifyConsolePak();

                verifyPak.Request.consoleId = consoleId;
                verifyPak.Request.containerClass = 1;
                verifyPak.Request.clear = new XCryptoData(clearHashTrimmed, clearHashTrimmed.Length);
                verifyPak.Request.pakEncrypted = new XCryptoData(consoleEncryptedHash, consoleEncryptedHash.Length);

                if (!verifyPak.Execute())
                {
                    throw new UnexpectedTestResultException("VerifyConsolePAK request failed: " + verifyPak.GetDumpString());
                }

                Global.RO.Success("VerifyConsolePAK request succeeded: {0}", verifyPak.Response.verified);
            }
        }

        [CompoundCase("TotalInvalidBlob", new Byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f })]
        [CompoundCase("BlobTooShort", new Byte[] { 0x11, 0x22, 0x33, 0x44 })]
        [CompoundCase("BlobTooLong", new Byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11 })]
        [CompoundCase("ZeroLengthBlob", new Byte[0])]
        [CompoundCase("ZeroFilledBlob", new Byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 })]
        [TestCase, Description("Sends a request with an invalid PAK and verifies that the request fails")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        public class InvalidPAKEncryptedBlob : TestNode
        {
            public override void PreRun()
            {
                if (!Global.XEnv.GetBoolSetting("xcrypto_DoRealPakTest"))
                {
                    throw new DidNotExecuteException("The actual PAK test is not enabled in this environment so these tests will fail.");
                }
            }

            public override void Run()
            {
                // Use an 'invalid' PAK, so generate fake data
                byte[] invalidEncryptedHash = (Byte[])MyValues[0];

                XRLXCryptoVerifyConsolePak verifyPak = new XRLXCryptoVerifyConsolePak();

                verifyPak.Request.consoleId = consoleId;
                verifyPak.Request.containerClass = 1;
                verifyPak.Request.clear = new XCryptoData(clearHashTrimmed, clearHashTrimmed.Length);
                verifyPak.Request.pakEncrypted = new XCryptoData(invalidEncryptedHash, invalidEncryptedHash.Length);

                if (!verifyPak.Execute())
                {
                    throw new UnexpectedTestResultException("VerifyConsolePAK request failed: " + verifyPak.GetDumpString());
                }

                if (verifyPak.Response.verified)
                {
                    throw new UnexpectedTestResultException("VerifyConsolePAK succeeded unexpectedly.");
                }

                Global.RO.Success("VerifyConsolePAK failed as expected.");
            }
        }

        [TestCase, Description("Sends a request with an invalid PAK and verifies that the request fails")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_InvalidContainerClass : TestNode
        {
            public override void PreRun()
            {
                if (!Global.XEnv.GetBoolSetting("xcrypto_DoRealPakTest"))
                {
                    throw new DidNotExecuteException("The actual PAK test is not enabled in this environment so these tests will fail.");
                }
            }

            public override void Run()
            {
                XRLXCryptoVerifyConsolePak verifyPak = new XRLXCryptoVerifyConsolePak();

                verifyPak.Request.consoleId = consoleId;
                verifyPak.Request.containerClass = 2;
                verifyPak.Request.clear = new XCryptoData(clearHashTrimmed, clearHashTrimmed.Length);
                verifyPak.Request.pakEncrypted = new XCryptoData(consoleEncryptedHash, consoleEncryptedHash.Length);

                if (!verifyPak.Execute())
                {
                    throw new UnexpectedTestResultException("VerifyConsolePAK request failed: " + verifyPak.GetDumpString());
                }

                if (verifyPak.Response.verified)
                {
                    throw new UnexpectedTestResultException("VerifyConsolePAK succeeded unexpectedly.");
                }

                Global.RO.Success("VerifyConsolePAK failed as expected.");
            }
        }
    }
}

namespace XCrypto.Stress
{
    [TestGroup]
    public class VerifyConsolePak_Stress : TestNode
    {
        public static UInt64 consoleId = 008307777346;
        public static byte[] clearHashTrimmed = new byte[] { 0xCE, 0xCC, 0xEB, 0xFB, 0x0D, 0x38, 0x1F, 0x8C, 0xD1, 0xFB, 0x0F, 0xCB, 0x62, 0xAC, 0x48, 0xC2 };
        public static byte[] consoleEncryptedHash = new byte[] { 0xA0, 0x42, 0x0A, 0x09, 0x85, 0x49, 0xAD, 0xFD, 0xAB, 0x4D, 0xEC, 0x85, 0x8C, 0x05, 0x33, 0x91 };

        [StressTest, Owner("BenRan"), TestFrequency("Full"), Description("Stress tests for CryptoVerifyConsolePAK")]
        public class CryptoVerifyConsolePAK : TestNode
        {
            public override void Run()
            {
                XRLXCryptoVerifyConsolePak verifyPak = new XRLXCryptoVerifyConsolePak();

                verifyPak.Request.consoleId = consoleId;
                verifyPak.Request.containerClass = 1;
                verifyPak.Request.clear = new XCryptoData(clearHashTrimmed, clearHashTrimmed.Length);
                verifyPak.Request.pakEncrypted = new XCryptoData(consoleEncryptedHash, consoleEncryptedHash.Length);

                if (!verifyPak.Execute())
                {
                    throw new UnexpectedTestResultException("VerifyConsolePak request failed: " + verifyPak.GetDumpString());
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\test\XRLCryptoSign.cs ===
﻿using System;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService.XCrypto;
using ServerTestFramework.Utilities;
using xonline.common.protocol;

namespace XCrypto.Functional
{
    [TestGroup]
    public class XCryptoSign : TestNode
    {
        static public string _sigTest = "2F5F9826C3925155189345373BBAE183D630ECC31C67E78CB496486DADDD35946F0B14E4FD6B6C72138D71F7508C706F76C3547CC8CFF5BE6500A9CCC474F8DED773A71BA5F84DCA01A65BCAFB03B0BE6AB31E7A2D4333E906C220E9AE9911E1EFCB5F0B25CEF904CF0D083CC40233427AA93A7A761BA5889202ECB9EA8C3F90013764325F37E63DB5FB87AA2DFEBBABAC3C8F39E3C3A280CDDE06AC009EB79614739D3DBC2A60626BD75AEB272BBAEEAF770BE4C0DCE532A0D3B005C37B4B2280D37D59CED6F865632DFC1648B50288AFCADDD6476094DE8485D821CDBBB0A6E34B78CD8179D474C6E694E980592A184CC4818F88EB39D6504BB943ACB01684";
        static public string _sigNCipher = "12A8C585ECB0342DC6B46DF395FB6079BB526DD712E2120F1746B79AD5AFE9FEBAF4B368218DED769F56A2971B4D829143722530D26CDBC4E55980893CDD7FC68154D9B303C4BA9CDFD720179DBDE4667856B6C754852CC8E94566CC7E4F2FDA1DC5A7663637D6A36062CAEF55FBC581CC8DC7991B292E38C4F1A4897DA8BBA8A8D27A9DD5BCF7B60229567BB8953075B4F77DB5052DDE6551A32B0BE62442F491A0F10633FED5027321B5912A95CC3D1CB9B12135039D365792858B7EC0631AB37C8E657DBBAE36381222DFE887B421D4E6C47A1FEFE46A638CA70635274AE259D3B54168EE05792D05747BBC8B500206334B791375994DD4369CAC39AADD3F";
        
        [TestCase, Owner("BenRan"), TestFrequency("Regression"), Description("Request the service to sign some random data and verifiy that the call succeeds")]
        public class CryptoSignBVT : TestNode
        {
            public override void Run()
            {
                XRLXCryptoSign sign = new XRLXCryptoSign();
                //
                // Random Fake sha1 to sign
                //
                Byte[] sha1 = {0x01, 0x02, 0x03, 0x04,
                               0x01, 0x02, 0x03, 0x04,
                               0x01, 0x02, 0x03, 0x04,
                               0x01, 0x02, 0x03, 0x04,
                               0x01, 0x02, 0x03, 0x04};

                sign.Request.sha1 = new XCryptoData(sha1, sha1.Length);
                sign.Request.containerClass = 1;

                Global.RO.Info("Executing XCryptoSign request...");

                if (!sign.Execute())
                {
                    throw new UnexpectedTestResultException("XCryptoSign request failed: " + sign.GetDumpString());
                }

                //
                // Check to make sure the result was valid against test key or ncipher key
                //
                if (_sigNCipher == Hexer.tohex(sign.Response.sig.data))
                {
                    Global.RO.Success("CryptoSign: Verified against nCipher key");
                }
                else if (_sigTest == Hexer.tohex(sign.Response.sig.data))
                {
                    Global.RO.Success("CryptoSign: Verified against test key");
                }
                else
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append("XCryptoSign response blob did not match an expected value.");
                    sb.AppendLine(" This is most likely a key problem or an npdb configuration issue. Check that commonconfig has the correct npdb value.");
                    sb.AppendLine("Expected Response (Test): " + _sigTest); 
                    sb.AppendLine("or (nCipher): " + _sigNCipher);
                    sb.AppendLine("Actual: " + Hexer.tohex(sign.Response.sig.data));

                    throw new UnexpectedTestResultException(sb.ToString());
                }
            }
        }
    }
}

namespace XCrypto.Stress
{
    [TestGroup]
    public class XCryptoSign_Stress : TestNode
    {
        static public string _sigTest = "2F5F9826C3925155189345373BBAE183D630ECC31C67E78CB496486DADDD35946F0B14E4FD6B6C72138D71F7508C706F76C3547CC8CFF5BE6500A9CCC474F8DED773A71BA5F84DCA01A65BCAFB03B0BE6AB31E7A2D4333E906C220E9AE9911E1EFCB5F0B25CEF904CF0D083CC40233427AA93A7A761BA5889202ECB9EA8C3F90013764325F37E63DB5FB87AA2DFEBBABAC3C8F39E3C3A280CDDE06AC009EB79614739D3DBC2A60626BD75AEB272BBAEEAF770BE4C0DCE532A0D3B005C37B4B2280D37D59CED6F865632DFC1648B50288AFCADDD6476094DE8485D821CDBBB0A6E34B78CD8179D474C6E694E980592A184CC4818F88EB39D6504BB943ACB01684";
        static public string _sigNCipher = "12A8C585ECB0342DC6B46DF395FB6079BB526DD712E2120F1746B79AD5AFE9FEBAF4B368218DED769F56A2971B4D829143722530D26CDBC4E55980893CDD7FC68154D9B303C4BA9CDFD720179DBDE4667856B6C754852CC8E94566CC7E4F2FDA1DC5A7663637D6A36062CAEF55FBC581CC8DC7991B292E38C4F1A4897DA8BBA8A8D27A9DD5BCF7B60229567BB8953075B4F77DB5052DDE6551A32B0BE62442F491A0F10633FED5027321B5912A95CC3D1CB9B12135039D365792858B7EC0631AB37C8E657DBBAE36381222DFE887B421D4E6C47A1FEFE46A638CA70635274AE259D3B54168EE05792D05747BBC8B500206334B791375994DD4369CAC39AADD3F";
        static public string _sigToCompare = null;

        [StressTest, Owner("BenRan"), TestFrequency("Full")]
        public class CryptoSign : TestNode
        {
            // Fake sha1 to sign
            static Byte[] sha1 = {0x01, 0x02, 0x03, 0x04,
                                  0x01, 0x02, 0x03, 0x04,
                                  0x01, 0x02, 0x03, 0x04,
                                  0x01, 0x02, 0x03, 0x04,
                                  0x01, 0x02, 0x03, 0x04};
            XCryptoData cryptoData = null;

            public override void PreRun()
            {
                cryptoData = new XCryptoData(sha1, sha1.Length);
                
                XRLXCryptoSign sign = new XRLXCryptoSign();
                sign.Request.sha1 = cryptoData;
                sign.Request.containerClass = 1;

                if (sign.Execute())
                {
                    String respSig = Hexer.tohex(sign.Response.sig.data);

                    if (_sigNCipher == respSig)
                    {
                        Global.RO.Info("CryptoSign: Using NCipher");
                        _sigToCompare = _sigNCipher;
                    }
                    if (_sigTest == respSig)
                    {
                        Global.RO.Info("CryptoSign: Using TestKey");
                        _sigToCompare = _sigTest;
                    }
                }
                
            }
            public override void Run()
            {
                XRLXCryptoSign sign = new XRLXCryptoSign();
                sign.Request.sha1 = cryptoData;
                sign.Request.containerClass = 1;

                if (!sign.Execute())
                {
                    throw new UnexpectedTestResultException("XCryptoSign Failed: " + sign.GetDumpString());
                }
                if (_sigToCompare != Hexer.tohex(sign.Response.sig.data))
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append("XCryptoSign response blob did not match an expected value.");
                    sb.AppendLine(" This is most likely a key problem or an npdb configuration issue. Check that commonconfig has the correct npdb value.");
                    sb.AppendLine("Expected Response (Test): " + _sigTest);
                    sb.AppendLine("or (nCipher): " + _sigNCipher);
                    sb.AppendLine("Actual: " + Hexer.tohex(sign.Response.sig.data));

                    throw new UnexpectedTestResultException(sb.ToString());
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\test\Encryption.cs ===
using System;
using System.Linq;

using ServerTestFramework;
using ServerTestFramework.LiveService.XCrypto;
using ServerTestFramework.Utilities;

using xonline.common.protocol;
using xonline.common.service;

namespace XCrypto.Functional
{
    [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
    public class Encryption : TestNode
    {
        public static String ClearText = "CCE71BA2197E16285914AF08C06158C03F74CC8708ED68A79858F7E092DE1840AB052BF4FFB35F6A77BC30D7307F89B320C8C0981AD555DE7F730AC18636957AFB6E5DBA3564C18B1461104BBD907718CF43BFCA1E7F26D6B04C758BA89EE34126B5DCC1";
        public static String CipherText = "9B84099FE96F48A142211943901515DCC5DAC24068B7DF53B7F60879E69988003553D5F2CF7AF40CA6CFE86A036D79FD0E0D09513C45F8018676363B90804711C4F9D6095AEE0BBEB0C32123B95E5C52150FC73B17A33779614F5EA491D8D2755F46AF5A6FCD8A09E751FBF855144D1BDE08B0FFC20EDD2B04900C5B61D58D1FD5A2295E67157F797060559168EC86C9B99C093E76307EC5425203BD1FDD3EC0E66D578E06105905161764F725AA03E8E4367E057EE4E57FBAAD604385565EED03B6C4E814E2C1BB8672FC0BE7F9958178C5A8CF68C140F84FC22533C19443E68EFB39D4D8372B0B716AA22EF744C2DDEC187E14DC60A6C66E56FFA972FAF046";

        [TestCase, TestCasePriority(1)]
        [Description("Request the service to encrypt and then decrypt a blob and checks that it's the same")]
        [CompoundCase("BVT", 100)]
        [CompoundCase("MinimumBlobSize", 1)]
        [CompoundCase("MaximumBlobSize", 214)]
        public class EncryptionRoundTrip : TestNode
        {
            public override void Run()
            {
                EncryptDecryptVerify(Convert.ToInt32(MyValues[0]));

                Global.RO.Success("Encryption round trip successful");
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Encrypt and then decrypt an array full of zeros")]
        public class EmptyBlob : TestNode
        {
            public override void Run()
            {
                EncryptDecryptVerify(new Byte[100]);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Attempt to encrypt an array of zero bytes")]
        public class EncryptZeroLengthBlob : TestNode
        {
            public override void Run()
            {
                Encrypt(new Byte[0], HResult.XONLINE_E_XCRYPTO_REQUEST_FAILED);
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Attempt to encrypt a blob that's too large")]
        [CompoundCase("MaxSizePlus1", 215, BugID = 217119, BugDatabase = "ISSAll")]
        [CompoundCase("MaxSizePlus2", 216)]
        [CompoundCase("WayTooLarge", 1024)]
        public class EncryptTooLargeBlob : TestNode
        {
            public override void Run()
            {
                // The maximum size of a blob to encrypt is equal to the modulus - 2 - 2*hashLen
                // This is 256 - 2 - (2*20) = 214
                Encrypt(RandomEx.GlobalRandGen.GenerateRandomBlob(Convert.ToInt32(MyValues[0])), HResult.XONLINE_E_XCRYPTO_REQUEST_FAILED);
            }
        }

        [TestCase, TestCasePriority(2)]
        public class EncryptMultipleTimes : TestNode
        {
            public override void Run()
            {
                Byte[] clear = RandomEx.GlobalRandGen.GenerateRandomBlob(100);

                Int32 count = 5;
                Byte[][] encryptedData = new Byte[count][];
                for (int i = 0; i < count; i++)
                {
                    encryptedData[i] = Encrypt(clear);
                }

                // Compare all of the encrypted values together to make sure they are different
                for (int i = 0; i < count - 1; i++)
                {
                    for (int j = i + 1; j < count; j++)
                    {
                        if (ArrayEx.Compare(encryptedData[i], encryptedData[j]))
                        {
                            throw new UnexpectedTestResultException("Blob was encrypted the same way more than once");
                        }
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2)]
        [Description("Attempt to decrypt a blob that's too large")]
        public class DecryptArbitraryData : TestNode
        {
            public override void Run()
            {
                Decrypt(RandomEx.GlobalRandGen.GenerateRandomBlob(100), HResult.XONLINE_E_XCRYPTO_REQUEST_FAILED);
            }
        }

        public static void EncryptDecryptVerify(Int32 size)
        {
            EncryptDecryptVerify(RandomEx.GlobalRandGen.GenerateRandomBlob(size));
        }

        public static void EncryptDecryptVerify(Byte[] clear)
        {
            Byte[] cipher = Encrypt(clear);
            Byte[] decrypted = Decrypt(cipher);
            
            // Ensure that the data recieved was the same as the original encrypted data
            ValueCheck.Test("DecryptedResponse", clear, decrypted);
        }

        public static Byte[] Encrypt(Byte[] clear)
        {
            return Encrypt(clear, HResult.S_OK);
        }

        public static Byte[] Encrypt(Byte[] clear, UInt32 expectedResult)
        {
            XRLXCryptoEncrypt encrypt = new XRLXCryptoEncrypt();
            encrypt.Request.containerClass = 5;
            encrypt.Request.clear = new XCryptoData(clear);

            if (encrypt.Execute())
            {
                if (encrypt.XErr != expectedResult)
                {
                    throw new UnexpectedTestResultException("Encrypt request succeeded.  Expected: " + (HResult)expectedResult);
                }

                Global.RO.Success("Encrypt request succeeded");
                return encrypt.Response.cipher.data;
            }
            else
            {
                if (encrypt.XErr != expectedResult)
                {
                    throw new UnexpectedTestResultException("Encrypt failed with unexpected error: " + encrypt.GetDumpString());
                }

                Global.RO.Success("Encrypt failed with expected error.");
                return null;
            }

        }

        public static Byte[] Decrypt(Byte[] cipher)
        {
            return Decrypt(cipher, HResult.S_OK);
        }

        public static Byte[] Decrypt(Byte[] cipher, UInt32 expectedResult)
        {
            XRLXCryptoDecrypt decrypt = new XRLXCryptoDecrypt();
            decrypt.Request.containerClass = 5;
            decrypt.Request.cipher = new XCryptoData(cipher);

            if (decrypt.Execute())
            {
                if (decrypt.XErr != expectedResult)
                {
                    throw new UnexpectedTestResultException("Encrypt request succeeded.  Expected: " + (HResult)expectedResult);
                }

                Global.RO.Success("Decrypt request succeeded");
                return decrypt.Response.clear.data;
            }
            else
            {
                if (decrypt.XErr != expectedResult)
                {
                    throw new UnexpectedTestResultException("Encrypt failed with unexpected error: " + decrypt.GetDumpString());
                }
                Global.RO.Success("Decrypt failed with expected error.");
                return null;
            }

            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\MgmtInterface.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: MgmtInterface.cpp
//
//  Implementation of the mgmt interface.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "MgmtInterface.h"

#include "XdsMain.h"
#include "XdsCache.h"
#include "NicMgr.h"

#include <xmgmt.h>
#include <XAlloc.h>
#include <Time.h>
#include <addref.h>

//-----------------------------------------------------------------------------
//  Debugging Areas
//-----------------------------------------------------------------------------
XomDefineArea(XMGMT);

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
#define MAX_MGMT_RESPONSE_SIZE          256

//-----------------------------------------------------------------------------
//  Constant
//-----------------------------------------------------------------------------
const DWORD c_dwDefaultQueueSize        = 400;
const DWORD c_dwDefaultMaxFileSize      = 200000;

//-----------------------------------------------------------------------------
//  Local Function Declaration
//-----------------------------------------------------------------------------
BOOL                StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutes, DWORD *pdwSeconds );
void                StringToLowerCase( char *szResult, char *szSrc, DWORD dwSrcSize );


//-----------------------------------------------------------------------------
// CXMgmtControlCallback provides mgmt interface for XDS service
//-----------------------------------------------------------------------------
class CXMgmtControlCallback : public CXomControlCallback
{
    IMPLEMENT_REFCOUNT_COM;

    CXMgmtControlCallback(CMgmtInterface *pMI) :
        CXomControlCallback(),
        m_pMgmtInterface(pMI)
    {
    }

    virtual ~CXMgmtControlCallback()
    {
    }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );
    
 protected:
    HRESULT ParseArgList(
        IN  LPCSTR pszRequest,
        OUT DWORD *pdwArgc,
        OUT LPCSTR **ppArgv );
    
    CMgmtInterface* m_pMgmtInterface;
    
};


//-----------------------------------------------------------------------------
//  CMgmtInterface Implementation
//-----------------------------------------------------------------------------
CMgmtInterface::CMgmtInterface()
{
    m_dwNumRegCmds = 0;
    m_dwMaxCmds    = 0;
    m_pCmdList     = NULL;
}

CMgmtInterface::~CMgmtInterface(void)
{
    DWORD dwX = 0;

    if ( m_pCmdList )
    {        
        delete[] m_pCmdList;
    }

    m_dwNumRegCmds = 0;
    m_dwMaxCmds    = 0;
    m_pCmdList     = NULL;
}

//-----------------------------------------------------------------------------
//  Initialize:  Creates the node bag.
//-----------------------------------------------------------------------------
HRESULT CMgmtInterface::Initialize( DWORD dwNumOfCmds )
{
    HRESULT hr = S_OK;

    
    XomTrace( XMGMT, L_NORMAL, "CMgmtInterface::Initialize:  Initializing MGMT Interface.");

    // install the mgmt command handler
    m_pMgmtHandler = new CXMgmtControlCallback(this);
    if ( NULL == m_pMgmtHandler )
    {
        // not enough memory to create a mgmt control callback object.
        XomNtEvent( XEVENT_XDS_CODE_0, "CMgmtInterface::Initialize:  Failed to attain memory for the mgmt control callback handler.   Modify the configuration or add more phyical memory to this machine.");
        XomTrace( XMGMT, L_ERROR, "CMgmtInterface::Initialize:  Failed to attain memory for the mgmt control callback handler.   Modify the configuration or add more phyical memory to this machine.");
            
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    XomTrace( XMGMT, L_NORMAL, "CMgmtInterface::Initialize:  Registering mgmt control handler.");
    g_xomcentral.RegisterControlCallback(m_pMgmtHandler);

    m_dwMaxCmds = dwNumOfCmds;
    m_pCmdList = new XomMgmtCmd[dwNumOfCmds];
    m_dwNumRegCmds = 0;
    
Exit:    
    XomTrace( XMGMT, L_LOW, "CMgmtInterface::Initialize:  Complete with result = 0x%X.", hr);
    return hr;
}

//-----------------------------------------------------------------------------
//  RegisterCommand:  Registers a callback command with the interface..
//-----------------------------------------------------------------------------
HRESULT CMgmtInterface::RegisterCommand( XomMgmtCmd newCmd )
{
    HRESULT hr = S_OK;
    XOMASSERT( m_dwNumRegCmds < m_dwMaxCmds );

    // copy information into structure.
    if ( newCmd.szCmdName == NULL )
    {
        // the send request failed.
        XomTrace( XMGMT, L_ERROR, "CMgmtInterface::RegisterCommand:  Registering command must have a name.");
        XOMASSERT( FALSE );        
    }
    
    m_pCmdList[m_dwNumRegCmds].szCmdName = newCmd.szCmdName;
    m_pCmdList[m_dwNumRegCmds].dwCmdNameLen= newCmd.dwCmdNameLen;
    
    // copy pointer values
    m_pCmdList[m_dwNumRegCmds].lpData = newCmd.lpData;
    m_pCmdList[m_dwNumRegCmds].pfnCmdProc = newCmd.pfnCmdProc;

    // copy the help name
    m_pCmdList[m_dwNumRegCmds].szCmdHelp = newCmd.szCmdHelp;
    
    // increase the number of register commands.
    m_dwNumRegCmds++;
    
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdHelp:  help command.  Displays commands
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdHelp(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;

    CHAR szHelpText[MAX_MGMT_RESPONSE_SIZE];
    
    _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
              "XMGMT commands: \n"
              );
    pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szHelpText, (DWORD)-1);

    for (DWORD i=0; i < pMgmtInf->GetNumberOfRegisteredCommands(); i++)
    {
        // don't print help for the help command
        if ( 0 == _strnicmp(pMgmtInf->m_pCmdList[i].szCmdName, argv[0], pMgmtInf->m_pCmdList[i].dwCmdNameLen) )
        {
            continue;
        }
            
        if ( NULL == pMgmtInf->m_pCmdList[i].szCmdHelp )
        {
            _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
                      "  %s\r\n",
                      pMgmtInf->m_pCmdList[i].szCmdName);
        }
        else
        {
            _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
                      "  %s %s\r\n",
                      pMgmtInf->m_pCmdList[i].szCmdName,
                      pMgmtInf->m_pCmdList[i].szCmdHelp);
        }
        
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szHelpText, (DWORD)-1);
    }
    
    // perform the response

    return hr;
}

 
//------------------------------------------------------------------------------
//  MgmtCmdQueryIP:  tells the program to set up a new interface.
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdQueryIP(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;
    char szResp[128] = {0};                         // response buffer.
    DWORD dwIPAddr = 0;
    CXdsMain *pXds = CXdsMain::GetInstance();

    XOMASSERT( pXds );
    XOMASSERT( pXds->GetCache() );
    
    // ensure we have enough args.
    if ( argc < 2 )
    {
        _snprintf( szResp, sizeof(szResp), "Usage:  QueryIP <ipaddr>   (ie. ipaddr = 157.56.12.113 )" );
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*) szResp, sizeof(szResp) );
        goto Exit;
    }

    // get the IP addr in DWORD
    dwIPAddr = StringToIp( (char*)argv[1] );
        
    // get the Cache
    if ( pXds->GetCache()->Find( dwIPAddr ) )
    {
        _snprintf( szResp, sizeof(szResp), "QueryIP:  IP %s was found in cache table.  KEY = 0x%X", argv[1], dwIPAddr );        
    } 
    else
    {
        _snprintf( szResp, sizeof(szResp), "QueryIP:  IP %s is NOT currently in the Cache table or has expired.  KEY = 0x%X", argv[1], dwIPAddr );        
    }

    // output the result.
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*) szResp, sizeof(szResp) );

Exit:
    CXdsMain::ReleaseInstance();
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdClearCache:  tells the program to set up a new interface.
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdClearCache(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;
    char szResp[128] = {0};                         // response buffer.
    DWORD dwIPAddr = 0;
    CXdsMain *pXds = CXdsMain::GetInstance();

    XOMASSERT( pXds );
    XOMASSERT( pXds->GetCache() );
            
    // get the Cache
    hr = pXds->GetCache()->ReInit();
    _snprintf( szResp, sizeof(szResp), "ClearCache:  Completed with RESULT = 0x%X", hr );        
 
    // output the result.
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*) szResp, sizeof(szResp) );

    CXdsMain::ReleaseInstance();
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdUnBanIP:  tells the program to set up a new interface.
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdUnBanIP(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;
    char szResp[128] = {0};                         // response buffer.
    DWORD dwIPAddr = 0;
    CXdsMain *pXds = CXdsMain::GetInstance();

    XOMASSERT( pXds );
    XOMASSERT( pXds->GetCache() );
    
    // ensure we have enough args.
    if ( argc < 2 )
    {
        _snprintf( szResp, sizeof(szResp), "Usage:  UnBanIP <ipaddr>   (ie. ipaddr = 157.56.12.113 )" );
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*) szResp, sizeof(szResp) );
        goto Exit;
    }

    // get the IP addr in DWORD
    dwIPAddr = StringToIp( (char*)argv[1] );
        
    // get the Cache
    if ( pXds->GetCache()->Remove( dwIPAddr ) )
    {
        _snprintf( szResp, sizeof(szResp), "UnBanIP:  IP %s was found and unbanned.  KEY = 0x%X", argv[1], dwIPAddr );        
    } 
    else
    {
        _snprintf( szResp, sizeof(szResp), "UnBanIP:  IP %s is NOT currently in the cache table.  No unbanning could take place.  KEY = 0x%X", argv[1], dwIPAddr );        
    }

    // output the result.
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*) szResp, sizeof(szResp) );

Exit:
    CXdsMain::ReleaseInstance();
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdClearCache:  tells the program to set up a new interface.
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdForceGatewayLookup(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;
    char szResp[128] = {0};                         // response buffer.
    DWORD dwIPAddr = 0;
    CNicMgr* pNicMgr = CNicMgr::GetInstance();

    XOMASSERT( pNicMgr );

    // ensure we have enough args.
    if ( argc < 2 )
    {
        _snprintf( szResp, sizeof(szResp), "Usage:  ForceGatewayLookup <Nic Id>   (ie. Nic Id = 0 )" );
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*) szResp, sizeof(szResp) );
        goto Exit;
    }

            
    // get the Cache
    hr = pNicMgr->SignalARPLookup( atoi(argv[1]) );
    if ( FAILED(hr) )
    {
        _snprintf( szResp, sizeof(szResp), "ForceGatewayLookup:  Failed with RESULT = 0x%X", hr );        
    }
    else
    {
        _snprintf( szResp, sizeof(szResp), "ForceGatewayLookup:  ARP thread signalled for %d.  Completed with RESULT = 0x%X", atoi(argv[1]), hr );        
    }
 
    // output the result.
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*) szResp, sizeof(szResp) );

Exit:
    CNicMgr::ReleaseInstance();
    return hr;
    
}


//------------------------------------------------------------------------------
//  CXMgmtControlCallback Implementation.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//  ParseArgList:  Parses the arguements and calls the correct register function.
//     Code from BaseProvider.cpp
//------------------------------------------------------------------------------
HRESULT CXMgmtControlCallback::ParseArgList(
    IN  LPCSTR pszRequest,
    OUT DWORD *pdwArgc,
    OUT LPCSTR **ppArgv
    )
{
    HRESULT hr = S_OK;
    DWORD dwArgc = 0;
    LPCSTR *pArgv = NULL;

    if ( NULL == pdwArgc || NULL == ppArgv )
    {
        return E_INVALIDARG;
    }
    
    // initialize return params
    *pdwArgc = 0;
    *ppArgv = NULL;
    
    // parse the request into separate arguments
    DWORD dwCmdTextSize = strlen(pszRequest) + 1;
    LPSTR pszCmdText = (LPSTR)XAlloc(dwCmdTextSize);
    if ( NULL == pszCmdText )
    {
        XomNtEvent(XEVENT_XDS_CODE_1, "CXMgmtControlCallback::ParseArgList: Failed to allocate %d bytes.", strlen(pszRequest));
        XomTrace(XMGMT, L_ERROR, "CXMgmtControlCallback::ParseArgList: Failed to allocate %d bytes.",  strlen(pszRequest));
        
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    ZeroMemory(pszCmdText, dwCmdTextSize);
    
    // get rid of leading, trailing, and extra whitespace
    LPCSTR src = pszRequest;
    LPSTR dst = pszCmdText;

    // advance past any leading whitespace
    while ( *src && isspace(*src) )
        src++;

    // copy cmd string eliminating any extra whitespace and putting NUL chars
    // between the arguments
    while ( *src )
    {
        if ( '"' == *src )
        {
            src++;
            while ( *src && '"' != *src )
            {
                *dst++ = *src++;
            }
            
            if ( '"' != *src )
            {
                hr = E_INVALIDARG;
                goto Exit;
            }
            
            // skip any whitespace after the "
            while ( isspace(*++src) )
                ;
            
            *dst++ = '\0';
            dwArgc++;
            continue;
        }

        *dst = *src;

        if ( isspace(*src) )
        {
            *dst = '\0';
            dwArgc++;
            src++;
            while ( *src && isspace(*src) )
            {
                src++;
            }
        }
        else
        {
            src++;
        }
        dst++;
    }

    // if the last character copied wasn't whitespace, increment arg count
    if ( src > pszRequest && !isspace(*(src-1)) && '"' != *(src-1) )
    {
        dwArgc++;
    }
    
    // remove any trailing spaces
    dst = pszCmdText + strlen(pszCmdText) - 1;
    while (*dst && isspace(*dst))
    {
        dst--;
    }

    // allocate and assign the argument list
    if ( dwArgc > 0 )
    {
        DWORD dwSize = dwArgc * sizeof(pArgv[0]);
        DWORD i = 0;
        DWORD j = 0;
        LPCSTR pArg = NULL;
        
        pArgv = (LPCSTR*)XAlloc(dwSize);
        if ( NULL == pArgv )
        {
            XomNtEvent(XEVENT_XDS_CODE_2, "CXMgmtControlCallback::ParseArgList: failed to allocate %d bytes.", dwSize);
            XomTrace(XMGMT, L_ERROR, "CXMgmtControlCallback::ParseArgList: failed to allocate %d bytes.", dwSize);

            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ZeroMemory(pArgv, dwSize);

        pArg = pszCmdText;
        for ( i=0; i < dwArgc; i++ )
        {
            pArgv[i] = pArg;
            pArg = pArg + strlen(pArg) + 1;
        }
    }

    if ( !FAILED(hr) )
    {
        *pdwArgc = dwArgc;
        *ppArgv = pArgv;
    }

Exit:
    return hr;
}


//------------------------------------------------------------------------------
//  OnControlRequest:  Called when cmd received through XMGMT stuff.
//     Code from BaseProvider.cpp
//------------------------------------------------------------------------------
HRESULT CXMgmtControlCallback::OnControlRequest(
    IN  LPCSTR pszRequest,
    IN  DWORD dwRequestId,
    IN  CXomControlResponseInterface* pResponseInterface
    )
{
    HRESULT hr = S_OK;
    DWORD dwArgc = 0;
    LPCSTR *pArgv = NULL;
    DWORD i = 0;

    XOMASSERT( m_pMgmtInterface != NULL );

    hr = ParseArgList(pszRequest, &dwArgc, &pArgv);
    if ( FAILED(hr) )
    {
        CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
        _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1, "CXMgmtControlCallback::OnControlRequest: failed with hr = 0x%08X.\r\n", hr);
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD)-1);
    }
    
    for ( i=0; i < m_pMgmtInterface->GetNumberOfRegisteredCommands(); i++ )
    {
        if ( 0 == _strnicmp(pszRequest, m_pMgmtInterface->m_pCmdList[i].szCmdName, m_pMgmtInterface->m_pCmdList[i].dwCmdNameLen) )
        {
            hr = (*(m_pMgmtInterface->m_pCmdList[i].pfnCmdProc))(
                    m_pMgmtInterface->m_pCmdList[i].lpData,
                    m_pMgmtInterface,
                    dwRequestId,
                    pResponseInterface,
                    dwArgc,
                    pArgv
                    );

            
            if ( FAILED(hr) )
            {
                CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
                _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1, "%s: failed with hr = 0x%08X.\r\n", m_pMgmtInterface->m_pCmdList[i].szCmdName, hr);
                pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD)-1);
            }
            
            break;
        }
    }

    if ( pArgv )
    {
        if ( pArgv[0] )
        {
            XFree((LPVOID)pArgv[0]);
            pArgv[0] = NULL;
        }
        
        XFree((LPVOID)pArgv);
        pArgv = 0;
        dwArgc = 0;
    }
    
    return hr;
}


//------------------------------------------------------------------------------
//  Local Function Implementation
//------------------------------------------------------------------------------
 
//------------------------------------------------------------------
//  StringToTime:  Basic breakdown of an hours, minutes seconds
//          string into a value for hours, minutes and seconds.
//          FORMAT:  All seconds values are followed by s
//                   All minute values are followed by m
//                   All hour values are followed by h
//          Returns fales for invalid params.
//------------------------------------------------------------------
BOOL StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutes, DWORD *pdwSeconds )
{
    int nStrSize = 0;
    BOOL bRes = TRUE;                                   // result value.
    int nCurValSize = 0;
    char *szPos = NULL;
    char *szStart = NULL;

    // ensure values.
    if ( szTimeStr == NULL || 
         pdwHours == NULL  || 
         pdwMinutes == NULL || 
         pdwSeconds == NULL )
    {
        bRes = FALSE;
        goto CleanUp;
    }

    // get the size of the time string.
    nStrSize = (int)strlen( szTimeStr );

    // set up values for scan
    szPos = (char*)szTimeStr;
    szStart = szPos;
    nCurValSize = 0;
    *pdwHours = 0;
    *pdwMinutes = 0;
    *pdwSeconds = 0;

    // scan the string and get what we want
    while ( *szPos != '\0' )
    {        
        if ( *szPos >= '0' && *szPos <= '9'  )
        {
            nCurValSize++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 's' || *szPos == 'S' ) )
        {
            *szPos = '\0';
            *pdwSeconds = atoi(szStart);
            *szPos = 's';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 'h' || *szPos == 'H' ) )
        {
            *szPos = '\0';
            *pdwHours = atoi(szStart);
            *szPos = 'h';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 'm' || *szPos == 'M' ) )
        {
            *szPos = '\0';
            *pdwMinutes = atoi(szStart);
            *szPos = 'm';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else
        {
            // I don't know what's in this buffer... just keep moving.
            szStart = szPos;
            szStart++;
            nCurValSize = 0;
        }
        szPos++;
    }

    // we got some value but we dont' know what  ... assume it means seconds.
    if ( nCurValSize > 0 )
    {
        *pdwSeconds = atoi(szStart);
    }

CleanUp:
    return bRes;

}

//------------------------------------------------------------------
// StringToLowerCase: Change string to lower case.
//------------------------------------------------------------------
void StringToLowerCase( char *szResult, char *szSrc, DWORD dwSrcSize )
{
    DWORD dwX = 0;
    XOMASSERT( szResult != NULL );
    XOMASSERT( szSrc != NULL );

    // for each element in szSrc
    for ( dwX = 0; dwX < dwSrcSize; dwX++ )
    {
        szResult[dwX] = (char)tolower((int)szSrc[dwX]);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\NetStructs.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: NetStructs.h
//
//  Structures for internet/ethernet packets.  NOTE:  these structures and 
//      Macros were acquired from Sg.hand XGGTest.h
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include <xonlinep.h>

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------

#define FINLINE __forceinline

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))
#define BIT(n)                  (1u << (n))
#define ROUNDUP4(count)         (((count) + 3) & ~3)
#define ROUNDUP8(count)         (((count) + 7) & ~7)
#define IsListNull(_ple)        ((_ple)->Flink == NULL)

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

#define ISIEEEHDR(pb) ( NTOHS(((CEnetHdr*)pb)->_wType) <= ENET_DATA_MAXSIZE )

#define ARP_OP_REQUEST      HTONS(1)    // opcodes
#define ARP_OP_REPLY        HTONS(2)

#define ARP_HWTYPE_ENET     HTONS(1)    // hardware address spaces
#define ARP_HWTYPE_802      HTONS(6)

#define ETHERNET_HEADER_TYPE_NORMAL             0
#define ETHERNET_HEADER_TYPE_IEEE               1

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 *   From winsock2.h
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* internet group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256


//-----------------------------------------------------------------------------
//  Functions
//-----------------------------------------------------------------------------

FINLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
FINLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
FINLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
FINLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }


//-----------------------------------------------------------------------------
//  Types/Structures
//-----------------------------------------------------------------------------

#pragma pack (push, 1)

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
const DWORD c_dwARPPacketSize               = 28;
const BYTE  c_rgVMAC[6]                     = {0x00,0x11,0x22,0x33,0x44,0x55};
const DWORD c_dwMAX_MTU_ETHERNET            = 1500;         // 1500 is max size packet

//-----------------------------------------------------------------------------
//
// CIpAddr
//
// This struct was ripped from Dinarte's very functional CIpAddr.  It is in 
// fact the same structure which comes with lots of cool helper functions.
//
// It essentially represents an IP address
//
//-----------------------------------------------------------------------------
struct CIpAddr
{
    union
    {
        BYTE        _ab[4];
        DWORD       _dw;
    };

    #define IPADDR_BROADCAST            CIpAddr(HTONL(0xFFFFFFFF))
    #define IPADDR_LOOPBACK             CIpAddr(HTONL(0x7F000001))
    #define IPADDR_CLASSA_NETMASK       CIpAddr(HTONL(0xFF000000))
    #define IPADDR_CLASSB_NETMASK       CIpAddr(HTONL(0xFFFF0000))
    #define IPADDR_CLASSC_NETMASK       CIpAddr(HTONL(0xFFFFFF00))
    #define IPADDR_CLASSD_NETMASK       CIpAddr(HTONL(0xF0000000))
    #define IPADDR_CLASSD_NETID         CIpAddr(HTONL(0xE0000000))
    #define IPADDR_LOOPBACK_NETID       CIpAddr(HTONL(0x7F000000))

    FINLINE operator DWORD () const { return(_dw); }
    FINLINE DWORD operator = (DWORD & dw) { return(_dw = dw); }
    FINLINE CIpAddr(DWORD dw) { _dw = dw; }
    FINLINE CIpAddr() {}

    FINLINE BOOL IsBroadcast() const { return(_dw == IPADDR_BROADCAST); }
    FINLINE BOOL IsMulticast() const { return(IsClassD() && !IsBroadcast()); }
    FINLINE BOOL IsLoopback() const { return((_dw & IPADDR_CLASSA_NETMASK) == IPADDR_LOOPBACK_NETID); }
    FINLINE BOOL IsClassA() const { return((_dw & HTONL(0x80000000)) == HTONL(0x00000000)); }
    FINLINE BOOL IsClassB() const { return((_dw & HTONL(0xC0000000)) == HTONL(0x80000000)); }
    FINLINE BOOL IsClassC() const { return((_dw & HTONL(0xE0000000)) == HTONL(0xC0000000)); }
    FINLINE BOOL IsClassD() const { return((_dw & HTONL(0xF0000000)) == HTONL(0xE0000000)); }
    FINLINE BOOL IsValidMask() const { DWORD dw = ~NTOHL(_dw); return((dw & (dw + 1)) == 0); }
           BOOL IsValidAddr() const;
    char * Str() const;
};


//-----------------------------------------------------------------------------
//
// CEnetAddr
//
// This represents a very robust ethernet address struct, ripped from Dinarte.
//
//-----------------------------------------------------------------------------
struct CEnetAddr
{
    BYTE _ab[6];

    FINLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    FINLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    FINLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    FINLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    FINLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    FINLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    FINLINE BOOL IsZero() const                { return(*(DWORD *)&_ab[0] == 0 && *(WORD *)&_ab[4] == 0); }
    
    char * Str() const;
};

//-----------------------------------------------------------------------------
//
// CIpHdr
//
// This struct stores an IP header
//
//-----------------------------------------------------------------------------
struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    CIpAddr         _ipaSrc;        // Source address
    CIpAddr         _ipaDst;        // Destination address

    FINLINE UINT    GetHdrLen()     { return((_bVerHdr & 0xF) << 2); }
};

//-----------------------------------------------------------------------------
//
// ENET_HEADER
//
// This struct stores an Ethernet header
//
//-----------------------------------------------------------------------------
#define ENET_DATA_MAXSIZE   1500
#define ENET_TYPE_IP        HTONS_(0x0800)
#define ENET_TYPE_ARP       HTONS_(0x0806)

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIeeeHdr : public CEnetHdr
{
    BYTE            _bDsap;         // 0xAA
    BYTE            _bSsap;         // 0xAA
    BYTE            _bControl;      // 0x03
    BYTE            _bOrgCode[3];   // 0x00 0x00 0x00
    WORD            _wTypeIeee;

    FINLINE BOOL IsEnetFrame()   { return(*(DWORD *)&_bDsap == 0x0003AAAA && *(WORD *)&_bOrgCode[1] == 0); }
    FINLINE BOOL IsValid()       { return(NTOHS(_wType) > ENET_DATA_MAXSIZE || IsEnetFrame()); }
};

// ---------------------------------------------------------------------------------------
// CIpPort
// ---------------------------------------------------------------------------------------

struct CIpPort
{
    WORD    _w;

    FINLINE operator WORD () { return (_w); }
    FINLINE WORD operator = (WORD & w) { return(_w = w); }
    FINLINE CIpPort(WORD w) { _w = w; }
    FINLINE CIpPort() {}
};


// UDP/TCP Pseudo Header in Network Byte Order -------------------------------------------

struct CPseudoHeader
{
    CIpAddr         _ipaSrc;
    CIpAddr         _ipaDst;
    BYTE            _bZero;
    BYTE            _bProtocol;
    WORD            _wLen;
};


//-----------------------------------------------------------------------------
//
// CUdpHdr
//
// This struct stores a UDP header
//
//-----------------------------------------------------------------------------
struct CUdpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum
};


//-----------------------------------------------------------------------------
//
// CArpMsg 
//
// This struct stores an ARP message
//
//-----------------------------------------------------------------------------
struct CArpMsg
{
    WORD            _wHrd;      // hardware address space
    WORD            _wPro;      // protocol address space (ENET_TYPE_IP)
    BYTE            _bHln;      // hardware address length (6)
    BYTE            _bPln;      // protocol address length (4)
    WORD            _wOp;       // opcode
    CEnetAddr       _eaSender;  // sender's hardware address
    DWORD         _ipaSender; // sender's protocol address
    CEnetAddr       _eaTarget;  // target's hardware address
    DWORD         _ipaTarget; // target's protocol address
};


//-----------------------------------------------------------------------------
//
// CIcmpHdr 
//
// ICMP header structure
//
//-----------------------------------------------------------------------------
class CIcmpHdr
{
    // Definitions -----------------------------------------------------------------------

    #define ICMPTYPE_ECHO_REPLY                 0
    #define ICMPTYPE_DESTINATION_UNREACHABLE    3
    #define   ICMPCODE_NET_UNREACHABLE          0
    #define   ICMPCODE_HOST_UNREACHABLE         1
    #define   ICMPCODE_PROTOCOL_UNREACHABLE     2
    #define   ICMPCODE_PORT_UNREACHABLE         3
    #define   ICMPCODE_CANT_FRAGMENT_WITH_DF    4
    #define   ICMPCODE_SRCROUTE_FAILED          5
    #define   ICMPCODE_DEST_NET_UNKNOWN         6
    #define   ICMPCODE_DEST_HOST_UNKNOWN        7
    #define   ICMPCODE_SRC_HOST_ISOLATED        8
    #define   ICMPCODE_DEST_NET_PROHIBITED      9
    #define   ICMPCODE_DEST_HOST_PROHIBITED     10
    #define   ICMPCODE_NET_UNREACHABLE_TOS      11
    #define   ICMPCODE_HOST_UNREACHABLE_TOS     12
    #define ICMPTYPE_SOURCE_QUENCH              4
    #define ICMPTYPE_REDIRECT                   5
    #define   ICMPCODE_REDIRECT_NET             0
    #define   ICMPCODE_REDIRECT_HOST            1
    #define   ICMPCODE_REDIRECT_NET_TOS         2
    #define   ICMPCODE_REDIRECT_HOST_TOS        3
    #define ICMPTYPE_ECHO_REQUEST               8
    #define ICMPTYPE_ROUTER_ADVERTISEMENT       9
    #define ICMPTYPE_ROUTER_SOLICIATION         10
    #define ICMPTYPE_TIME_EXCEEDED              11
    #define   ICMPCODE_TTL_EXCEEDED             0
    #define   ICMPCODE_REASSEMBLY_TIMEOUT       1
    #define ICMPTYPE_PARAMETER_PROBLEM          12
    #define   ICMPCODE_PTR_INDICATES_ERROR      0
    #define   ICMPCODE_MISSING_REQD_OPTION      1
    #define ICMPTYPE_TIMESTAMP_REQUEST          13
    #define ICMPTYPE_TIMESTAMP_REPLY            14
    #define ICMPTYPE_INFORMATION_REQUEST        15
    #define ICMPTYPE_INFORMATION_REPLY          16
    #define ICMPTYPE_ADDRESSMASK_REQUEST        17
    #define ICMPTYPE_ADDRESSMASK_REPLY          18

    // Data ------------------------------------------------------------------------------

public:

    BYTE            _bType;         // One of ICMPTYPE_* above
    BYTE            _bCode;         // One of ICMPCODE_* above
    WORD            _wChecksum;     // Checksum
    DWORD           _dwData;        // Data (depends on _bType)

};


#pragma pack (pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xcrypto\test\XRLCryptoVerifySignature.cs ===
﻿using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using ServerTestFramework.LiveService.XCrypto;
using xonline.common.service;

namespace XCrypto.Functional
{
    [TestGroup]
    public class XCryptoVerifySignature : TestNode
    {
        // Fake hash for sign request
        public static Byte[] sha1 = {0x01, 0x02, 0x03, 0x04,
                                     0x01, 0x02, 0x03, 0x04,
                                     0x01, 0x02, 0x03, 0x04,
                                     0x01, 0x02, 0x03, 0x04,
                                     0x01, 0x02, 0x03, 0x04};

        // Expected signed responses
        static public Byte[] _sigTest = Hexer.unhex("2F5F9826C3925155189345373BBAE183D630ECC31C67E78CB496486DADDD35946F0B14E4FD6B6C72138D71F7508C706F76C3547CC8CFF5BE6500A9CCC474F8DED773A71BA5F84DCA01A65BCAFB03B0BE6AB31E7A2D4333E906C220E9AE9911E1EFCB5F0B25CEF904CF0D083CC40233427AA93A7A761BA5889202ECB9EA8C3F90013764325F37E63DB5FB87AA2DFEBBABAC3C8F39E3C3A280CDDE06AC009EB79614739D3DBC2A60626BD75AEB272BBAEEAF770BE4C0DCE532A0D3B005C37B4B2280D37D59CED6F865632DFC1648B50288AFCADDD6476094DE8485D821CDBBB0A6E34B78CD8179D474C6E694E980592A184CC4818F88EB39D6504BB943ACB01684");
        static public Byte[] _sigNCipher = Hexer.unhex("12A8C585ECB0342DC6B46DF395FB6079BB526DD712E2120F1746B79AD5AFE9FEBAF4B368218DED769F56A2971B4D829143722530D26CDBC4E55980893CDD7FC68154D9B303C4BA9CDFD720179DBDE4667856B6C754852CC8E94566CC7E4F2FDA1DC5A7663637D6A36062CAEF55FBC581CC8DC7991B292E38C4F1A4897DA8BBA8A8D27A9DD5BCF7B60229567BB8953075B4F77DB5052DDE6551A32B0BE62442F491A0F10633FED5027321B5912A95CC3D1CB9B12135039D365792858B7EC0631AB37C8E657DBBAE36381222DFE887B421D4E6C47A1FEFE46A638CA70635274AE259D3B54168EE05792D05747BBC8B500206334B791375994DD4369CAC39AADD3F");

        [TestCase, Owner("BenRan"), TestFrequency("Regression"), Description("Take a valid signature and verify that it is valid against the service")]
        public class VerifySignatureBVT : TestNode
        {
            public override void Run()
            {
                XRLXCryptoVerifySignature verifySig = new XRLXCryptoVerifySignature();

                // Check the test key first
                if (VerifySignature(sha1, _sigTest))
                {
                    Global.RO.Success("XCryptoVerifySignature succeeded with test key.");
                }
                else // Try the nCipher key.
                {
                    if(VerifySignature(sha1, _sigNCipher))
                    {
                        Global.RO.Success("XCryptoVerifySignature succeeded with nCipher key.");
                    }
                }
            }
        }

        [TestCase, Owner("BenRan")]
        [CompoundCase("ZeroHash", new Byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, HResult.S_OK)]
        [CompoundCase("IncorrectHash", new Byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, HResult.S_OK)]
        [CompoundCase("TooShortHash", new Byte[] { 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4 }, HResult.XONLINE_E_XCRYPTO_REQUEST_FAILED)]
        [CompoundCase("TooLongHash", new Byte[] { 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4 }, HResult.XONLINE_E_XCRYPTO_REQUEST_FAILED)]
        [CompoundCase("EmptyHash", new Byte[0], HResult.XONLINE_E_XCRYPTO_REQUEST_FAILED)]
        public class InvalidHash : TestNode
        {
            public override void Run()
            {
                Byte[] hash = (Byte[])MyValues[0];
                UInt32 expectedResult = Convert.ToUInt32(MyValues[1]);

                VerifySignature(hash, _sigTest, expectedResult);
            }
        }

        public static Boolean VerifySignature(Byte[] hash, Byte[] signature)
        {
            return VerifySignature(hash, signature, HResult.S_OK, 1);
        }

        public static Boolean VerifySignature(Byte[] hash, Byte[] signature, UInt32 expectedResult)
        {
            return VerifySignature(hash, signature, expectedResult, 1);
        }

        public static Boolean VerifySignature(Byte[] hash, Byte[] signature, UInt32 expectedResult, UInt32 containerClass)
        {
            XRLXCryptoVerifySignature verifySig = new XRLXCryptoVerifySignature();
            verifySig.Request.sha1 = new XCryptoData(hash);
            verifySig.Request.sig = new XCryptoData(signature);
            verifySig.Request.containerClass = containerClass;

            if (verifySig.Execute())
            {
                if (verifySig.XErr != expectedResult)
                {
                    throw new UnexpectedTestResultException("VerifySignature request succeeded.  Expected: " + (HResult)expectedResult);
                }

                Global.RO.Success("VerifySignature request succeeded");
                return verifySig.Response.verified;
            }
            else
            {
                if (verifySig.XErr != expectedResult)
                {
                    throw new UnexpectedTestResultException("VerifySignature failed with unexpected error: " + verifySig.GetDumpString());
                }

                Global.RO.Success("VerifySignature failed with expected error.");
                return false;
            }
        }
    }
}

namespace XCrypto.Stress
{
    [TestGroup]
    public class XCryptoVerifySignature_Stress : TestNode
    {
        public static Byte[] _sigTest = null;
        public static Byte[] _sigNCipher = null;
        public static Byte[] _sigToCompare = null;

        public static Byte[] sha1 = {0x01, 0x02, 0x03, 0x04,
                       0x01, 0x02, 0x03, 0x04,
                       0x01, 0x02, 0x03, 0x04,
                       0x01, 0x02, 0x03, 0x04,
                       0x01, 0x02, 0x03, 0x04};

        [StressTest, Owner("BenRan"), TestFrequency("Full")]
        public class CryptoVerifySignature : TestNode
        {
            public override void PreRun()
            {
                _sigTest = Hexer.unhex("2F5F9826C3925155189345373BBAE183D630ECC31C67E78CB496486DADDD35946F0B14E4FD6B6C72138D71F7508C706F76C3547CC8CFF5BE6500A9CCC474F8DED773A71BA5F84DCA01A65BCAFB03B0BE6AB31E7A2D4333E906C220E9AE9911E1EFCB5F0B25CEF904CF0D083CC40233427AA93A7A761BA5889202ECB9EA8C3F90013764325F37E63DB5FB87AA2DFEBBABAC3C8F39E3C3A280CDDE06AC009EB79614739D3DBC2A60626BD75AEB272BBAEEAF770BE4C0DCE532A0D3B005C37B4B2280D37D59CED6F865632DFC1648B50288AFCADDD6476094DE8485D821CDBBB0A6E34B78CD8179D474C6E694E980592A184CC4818F88EB39D6504BB943ACB01684");
                _sigNCipher = Hexer.unhex("12A8C585ECB0342DC6B46DF395FB6079BB526DD712E2120F1746B79AD5AFE9FEBAF4B368218DED769F56A2971B4D829143722530D26CDBC4E55980893CDD7FC68154D9B303C4BA9CDFD720179DBDE4667856B6C754852CC8E94566CC7E4F2FDA1DC5A7663637D6A36062CAEF55FBC581CC8DC7991B292E38C4F1A4897DA8BBA8A8D27A9DD5BCF7B60229567BB8953075B4F77DB5052DDE6551A32B0BE62442F491A0F10633FED5027321B5912A95CC3D1CB9B12135039D365792858B7EC0631AB37C8E657DBBAE36381222DFE887B421D4E6C47A1FEFE46A638CA70635274AE259D3B54168EE05792D05747BBC8B500206334B791375994DD4369CAC39AADD3F");

                //
                // Run one to see which key is turned on. In the future 
                // we should look for the override and use that.
                //
                XRLXCryptoVerifySignature verifySig = new XRLXCryptoVerifySignature();

                // Check the NCipherKey
                if (_sigToCompare == null)
                {
                    verifySig.Request.sha1 = new XCryptoData(sha1, sha1.Length);
                    verifySig.Request.sig = new XCryptoData(_sigNCipher, _sigNCipher.Length);
                    verifySig.Request.containerClass = 1;
                    if (verifySig.Execute())
                    {
                        if (verifySig.Response.verified)
                        {
                            Global.RO.Fatal("CryptoVerifySignature: Using NCipher");
                            _sigToCompare = _sigNCipher;
                        }
                    }
                }
                
                // Check the TestKey
                if (_sigToCompare == null)
                {
                    verifySig.Request.sha1 = new XCryptoData(sha1, sha1.Length);
                    verifySig.Request.sig = new XCryptoData(_sigTest, _sigTest.Length);
                    verifySig.Request.containerClass = 1;
                    if (verifySig.Execute())
                    {
                        if (verifySig.Response.verified)
                        {
                            Global.RO.Fatal("CryptoVerifySignature: Using TestKey");
                            _sigToCompare = _sigTest;
                        }
                    }
                }

                if (_sigToCompare == null)
                {
                    Global.RO.Error("CryptoVerifySignature: Signature of returned blob did not match expected. This is most likely a key problem or an npdb configuration issue. Check that commonconfig has the correct npdb value.");
                }
            }

            public override void Run()
            {
                XRLXCryptoVerifySignature verifySig = new XRLXCryptoVerifySignature();

                verifySig.Request.sha1 = new XCryptoData(sha1, sha1.Length);
                verifySig.Request.sig = new XCryptoData(_sigToCompare, _sigToCompare.Length);
                verifySig.Request.containerClass = 1;

                if (!verifySig.Execute())
                {
                    throw new UnexpectedTestResultException("VerifySignature request failed: " + verifySig.GetDumpString());
                }

                if (!verifySig.Response.verified)
                {
                    throw new UnexpectedTestResultException("VerifySignature returned an unexpected response.");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\MgmtInterface.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: MgmtInterface.h
//
//  Interface MgmtInterface Implementation.
//-----------------------------------------------------------------------------

#pragma once
 

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Pre-Declarations
//-----------------------------------------------------------------------------
class CXdsMain;
class CXMgmtControlCallback;
class CMgmtInterface;


//-----------------------------------------------------------------------------
// Types/Structures
//-----------------------------------------------------------------------------
typedef HRESULT (*MgmtCmdHandler)(
    IN LPVOID lpCmdData,
    IN CMgmtInterface *pMgmtInf,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    );

typedef struct _XomMgmtCmd {
    char*           szCmdName;
    DWORD           dwCmdNameLen;
    MgmtCmdHandler  pfnCmdProc;
    char*           szCmdHelp;
    LPVOID          lpData;
} XomMgmtCmd;

//-----------------------------------------------------------------------------
// CMgmtInterface
//-----------------------------------------------------------------------------

class CMgmtInterface
{
public:
    CMgmtInterface( );
    virtual ~CMgmtInterface(void);

    // call before using.
    HRESULT Initialize( DWORD dwNumOfCmds );

    // sycn TCPIP XMGMT connection to specified address.
    HRESULT SendRequest( char *szSG, LPCSTR lpszRequest, char* szResponse, DWORD dwResponseBufferSize, DWORD *pdwBytesRecv, HRESULT *pHr );

    HRESULT RegisterCommand( XomMgmtCmd newCmd );

    DWORD   GetNumberOfRegisteredCommands() { return m_dwNumRegCmds; }

    friend CXMgmtControlCallback;

    static HRESULT MgmtCmdHelp(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdQueryIP(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdClearCache(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdUnBanIP(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdForceGatewayLookup(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    // overrides
    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }
   

protected:
    CXMgmtControlCallback* m_pMgmtHandler;

    XomMgmtCmd *m_pCmdList;
    DWORD m_dwMaxCmds;
    DWORD m_dwNumRegCmds;    
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\NicMgr.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: NicMgr.cpp
//
//  Implementation of the Nic mgr!!!!
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "NicMgr.h"
#include <XAlloc.h>
#include <rawnic.h>

//-----------------------------------------------------------------------------
//  Log Area
//-----------------------------------------------------------------------------

//  TODO : Should I define a log area for here?
XomDefineArea(NicMgr);

//-----------------------------------------------------------------------------
//  Callback Declaration
//-----------------------------------------------------------------------------
void CALLBACK PacketIoComplete(DWORD dwErr, DWORD cb, LPOVERLAPPED lpo);
void PacketXmitComplete(DWORD dwErr, DWORD cb, NicMgrNode* pnmNode);
void PacketRecvComplete(DWORD dwErr, DWORD cb, NicMgrNode* pnmNode);

//-----------------------------------------------------------------------------
//  Static Declarations
//-----------------------------------------------------------------------------
CNicMgr* CNicMgr::m_pInstance = NULL;
DWORD CNicMgr::m_dwRefCount = 0;

//-----------------------------------------------------------------------------
//  Defines
//-----------------------------------------------------------------------------
#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);


//-----------------------------------------------------------------------------
//  CNicMgr Implementation
//-----------------------------------------------------------------------------
CNicMgr::CNicMgr(): m_pAttachList(NULL), m_cNicsCreated(0)
{
}

CNicMgr::~CNicMgr(void)
{
    if ( m_pAttachList != NULL )
    {
        Terminate();
    }
    
    m_cNicsCreated = 0;
    m_pAttachList = NULL;
    m_dwRefCount = 0;
}

//-----------------------------------------------------------------------------
// We need 16-byte aligned allocations for SLIST_HEADER on 64-bit
//-----------------------------------------------------------------------------
void * CNicMgr::operator new(size_t size)
{
    if (size != sizeof(CNicMgr))
        return ::operator new(size);

    return _aligned_malloc(size, 16);
}

//-----------------------------------------------------------------------------
// We need 16-byte aligned allocations for SLIST_HEADER on 64-bit
//-----------------------------------------------------------------------------
void CNicMgr::operator delete(void *p, size_t size)
{
    if (p == 0)
        return;

    if (size != sizeof(CNicMgr))
    {
        ::operator delete(p);
        return;
    }

    free(p);
}


//-----------------------------------------------------------------------------
//  GetInstance:  Gets an instance of the xds
//-----------------------------------------------------------------------------
CNicMgr* CNicMgr::GetInstance()
{
    if ( m_pInstance == NULL )
    {
        XOMASSERT( m_dwRefCount == 0 );
        m_pInstance = new CNicMgr();
        if ( m_pInstance == NULL )
        {
            // not enough memory to create xds instance.
            XomTrace( NicMgr, L_ERROR, "CNicMgr::GetInstance:  Failed to allocate instance memory.  Please ensure machine has enough available RAM to run this program");
            goto Exit;
        }
    }

    InterlockedIncrement( (LPLONG)&(m_pInstance->m_dwRefCount) );

Exit:
    return m_pInstance;
}

//-----------------------------------------------------------------------------
//  ReleaseInstance:  Releases the instance of the xds.
//-----------------------------------------------------------------------------
void CNicMgr::ReleaseInstance()
{
    LONG lValue = 0;
    XOMASSERT( m_pInstance != NULL && m_pInstance->m_dwRefCount > 0  );
    lValue = InterlockedDecrement( (LPLONG)&(m_pInstance->m_dwRefCount) );
    if ( lValue == 0 )
    {
        XomTrace( NicMgr, L_NORMAL, "CNicMgr::ReleaseInstance:  Releasing instance of NicMgr Wrapper.");
        delete m_pInstance;
        m_pInstance = NULL;
    }
}

//-----------------------------------------------------------------------------
//  Initialize:  setup up NicMgr and attachment list.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::Initialize( DWORD dwNumOfNics, BOOL bUseArpThread  )
{
    HRESULT hr = S_OK;   

    CMemAlloc::Init();

    m_pXds = CXdsMain::GetInstance();
    if ( m_pXds == NULL )
    {
        // no xds object.   We can't continue.
        hr = E_NOINTERFACE;
        goto Exit;
    }

    m_pAttachList = new NicMgrNode[ dwNumOfNics ];
    if ( m_pAttachList == NULL )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::Initialize:  Not enough memory for list of NICs.");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    ZeroMemory( m_pAttachList, sizeof( NicMgrNode ) * dwNumOfNics );
    
    // Initialize lookaside list of overlapped structures
    
    m_overlappedLookAside.Init(sizeof(NicMgrNode::XDS_OVERLAPPED), NICMGR_XMIT_MAX_PARALLELIO);
    m_cOverlappedsAllocated = 0;
    
    // initialize NicMgr
    if ( NO_ERROR != RawnicDetectDriver() )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::Initialize:  Failed to intialize RawNic.");
        hr = E_ABORT;        
        goto Exit;
    }

    m_bUseArpThread = bUseArpThread;

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Terminate:  cleans up vlan implementation.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::Terminate()
{
    HRESULT hr = S_OK;
    DWORD dwX = 0;

    WriterLock();

    // just in case no one else did... let's stop the threads.
    hr = TerminateThreads();
    
    // go through the list and remove everything.
    for ( dwX = 0; dwX < m_cNicsCreated ; dwX ++ )
    {
        if (FAILED(DetachNic( (NicMgrNode*)&(m_pAttachList[dwX]) )) )
        {
            XomTrace(  NicMgr, 
                        L_ERROR, 
                        "CNicMgr::Terminate:  Failed to detach Nic id=%d, EA=%X%X%X%X%X%X, IP=%d.%d.%d.%d", 
                        m_pAttachList[dwX]._dwId,
                        DWORD(m_pAttachList[dwX]._eaReal._ab[0]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[1]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[2]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[3]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[4]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[5]),
                        ((BYTE*)&(m_pAttachList[dwX]._dwIP))[0],
                        ((BYTE*)&(m_pAttachList[dwX]._dwIP))[1],
                        ((BYTE*)&(m_pAttachList[dwX]._dwIP))[2],
                        ((BYTE*)&(m_pAttachList[dwX]._dwIP))[3]
                     );            
        }
        else
        {
            XomTrace(  NicMgr, 
                        L_NORMAL, 
                        "CNicMgr::Terminate:  Detached Nic id=%d, EA=%X%X%X%X%X%X, IP=%d.%d.%d.%d", 
                        m_pAttachList[dwX]._dwId,
                        DWORD(m_pAttachList[dwX]._eaReal._ab[0]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[1]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[2]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[3]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[4]),
                        DWORD(m_pAttachList[dwX]._eaReal._ab[5]),
                        ((BYTE*)&(m_pAttachList[dwX]._dwIP))[0],
                        ((BYTE*)&(m_pAttachList[dwX]._dwIP))[1],
                        ((BYTE*)&(m_pAttachList[dwX]._dwIP))[2],
                        ((BYTE*)&(m_pAttachList[dwX]._dwIP))[3]
                     );            
        }

    }

    // give the threads time to finish off.
    Sleep( 2000 );

    // delete the attach list.    
    delete m_pAttachList;
    m_pAttachList = NULL;
    m_cNicsCreated = 0;

    m_overlappedLookAside.Term();

    WriterUnlock();
    
    return hr;
}

//-----------------------------------------------------------------------------
//  TerminateThreads:  Stop and clean all threads.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::TerminateThreads()
{
    HRESULT hr = S_OK;
    DWORD dwX = 0;
    
    // go through the list and terminate all threads
    for ( dwX = 0; dwX < m_cNicsCreated ; dwX ++ )
    {
        // kill our arp threads
        TerminateARPThread( dwX );
    }

    return hr;
}

//-----------------------------------------------------------------------------
//  Add:  Adds another nic to the NicMgr.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::Add(   CEnetAddr eaMacAddr, 
                        DWORD dwIP, 
                        DWORD dwDefaultGatewayIP,                        
                        DWORD dwPollTimeInMilliSecs, 
                        DWORD dwRetryIntervalInMilliSecs, 
                        DWORD dwRetryEventPerRequest,
                        DWORD dwPort,
                        DWORD *pdwId )
{
    HRESULT hr = S_OK;

    XOMASSERT( pdwId != NULL );

    WriterLock();

    // fill in the node
    m_pAttachList[m_cNicsCreated]._dwIP = dwIP;
    m_pAttachList[m_cNicsCreated]._dwId = m_cNicsCreated;
    *pdwId = m_cNicsCreated;
    
    // set teh default gateway ip.
    m_pAttachList[m_cNicsCreated]._dwDefaultGatewayIP   = dwDefaultGatewayIP;
    
    // set initial default gateway ethernet addr value
    ZeroMemory( &(m_pAttachList[m_cNicsCreated]._eaDefaultGatewayEnetAddr), sizeof( CEnetAddr ) );

    // set the thread timer variables.
    m_pAttachList[m_cNicsCreated]._dwPollTime           = dwPollTimeInMilliSecs;
    m_pAttachList[m_cNicsCreated]._dwRetryInterval      = dwRetryIntervalInMilliSecs;    
    m_pAttachList[m_cNicsCreated]._dwRetryEventThrottle = dwRetryEventPerRequest;
    m_pAttachList[m_cNicsCreated]._dwPort               = dwPort;
    m_pAttachList[m_cNicsCreated]._eaReal               = eaMacAddr;

    // generate the virtual address.
    GenerateVirtualNicEthernetAddress(  m_pAttachList[m_cNicsCreated]._eaReal,  
                                        m_pAttachList[m_cNicsCreated]._dwId,
                                        &(m_pAttachList[m_cNicsCreated]._eaVirtual));

    // fill in recv overlapped structs
    
    m_pAttachList[m_cNicsCreated]._recvOverlapped.Reset();
    m_pAttachList[m_cNicsCreated]._recvOverlapped._ioType = NicMgrNode::IO_RECV;
    m_pAttachList[m_cNicsCreated]._recvOverlapped._pNicMgrNode = &m_pAttachList[m_cNicsCreated];

    // attach to Vlan...
    hr = AttachNic( &(m_pAttachList[m_cNicsCreated]));
    if ( FAILED(hr) )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::Add:  Failed to attach VLAN to %s.  Please ensure setting is correct.  Id=%d", 
                                    eaMacAddr.Str(),  
                                    m_pAttachList[m_cNicsCreated]._dwId ); 
        hr = E_FAIL;        
        goto Exit;
    }

    XomTrace( NicMgr, L_LOW, "CNicMgr::Add:  Added new RawNic connection %s.  Ethernet Addr= %X-%X-%X-%X-%X-%X.  Ip = %d.%d.%d.%d", 
            eaMacAddr.Str(),
            m_pAttachList[m_cNicsCreated]._eaVirtual._ab[0],
            m_pAttachList[m_cNicsCreated]._eaVirtual._ab[1],
            m_pAttachList[m_cNicsCreated]._eaVirtual._ab[2],
            m_pAttachList[m_cNicsCreated]._eaVirtual._ab[3],
            m_pAttachList[m_cNicsCreated]._eaVirtual._ab[4],
            m_pAttachList[m_cNicsCreated]._eaVirtual._ab[5],
            ((BYTE*)&(m_pAttachList[m_cNicsCreated]._dwIP))[0],
            ((BYTE*)&(m_pAttachList[m_cNicsCreated]._dwIP))[1],
            ((BYTE*)&(m_pAttachList[m_cNicsCreated]._dwIP))[2],
            ((BYTE*)&(m_pAttachList[m_cNicsCreated]._dwIP))[3]
            ); 

    
    // create ARP thread
    hr = InitializeARPThread( m_cNicsCreated );
    if ( FAILED(hr) )
    {
        XomTrace(  NicMgr, 
                     L_ERROR, 
                     "CNicMgr::Add:  Failed to start ARP thread.  Now cleaning up Vlan attachment.  Id:  NIC#d, RESULT: 0x%X",
                     m_cNicsCreated,
                     hr
                     );

        HRESULT hrDetach = S_OK;
        
        // we failed to start the arp thread.  Clean up the Vlan connection.
        hrDetach = DetachNic( &(m_pAttachList[m_cNicsCreated]) );
        if ( FAILED(hrDetach) )
        {
            XomTrace(  NicMgr, 
                        L_ERROR, 
                        "CNicMgr::Add:  Failed to detach Nic id=%d, EA=%X%X%X%X%X%X, IP=%d.%d.%d.%d, hr = 0x%X", 
                        m_pAttachList[m_cNicsCreated]._dwId,
                        DWORD(m_pAttachList[m_cNicsCreated]._eaReal._ab[0]),
                        DWORD(m_pAttachList[m_cNicsCreated]._eaReal._ab[1]),
                        DWORD(m_pAttachList[m_cNicsCreated]._eaReal._ab[2]),
                        DWORD(m_pAttachList[m_cNicsCreated]._eaReal._ab[3]),
                        DWORD(m_pAttachList[m_cNicsCreated]._eaReal._ab[4]),
                        DWORD(m_pAttachList[m_cNicsCreated]._eaReal._ab[5]),
                        ((BYTE*)&(m_pAttachList[m_cNicsCreated]._dwIP))[0],
                        ((BYTE*)&(m_pAttachList[m_cNicsCreated]._dwIP))[1],
                        ((BYTE*)&(m_pAttachList[m_cNicsCreated]._dwIP))[2],
                        ((BYTE*)&(m_pAttachList[m_cNicsCreated]._dwIP))[3],
                        hrDetach
                     );            
        }

        goto Exit;
    }

    // inc the counter.
    m_cNicsCreated++;

Exit:
    WriterUnlock();
    return hr;
}

//-----------------------------------------------------------------------------
//  ModifyPollTime:  Adds another nic to the NicMgr.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::ModifyPollTime( DWORD dwId, DWORD dwPollTimeInMilliSecs )
{
    HRESULT hr = S_OK;

    WriterLock();

    if ( dwId > m_cNicsCreated )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    m_pAttachList[dwId]._dwPollTime = dwPollTimeInMilliSecs * 1000;
    
Exit:
    WriterUnlock();
    return hr;
}


//-----------------------------------------------------------------------------
//  ModifyRetryInterval:  Adds another nic to the NicMgr.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::ModifyRetryInterval( DWORD dwId, DWORD dwRetryIntervalInMilliSecs )
{
    HRESULT hr = S_OK;

    WriterLock();

    if ( dwId > m_cNicsCreated )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    m_pAttachList[dwId]._dwRetryInterval = dwRetryIntervalInMilliSecs * 1000;
    
Exit:
    WriterUnlock();
    return hr;
}

//-----------------------------------------------------------------------------
//  ModifyEventThrottle:  Adds another nic to the NicMgr.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::ModifyEventThrottle( DWORD dwId, DWORD dwRetryEventPerRequest )
{
    HRESULT hr = S_OK;

    WriterLock();

    if ( dwId > m_cNicsCreated )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    m_pAttachList[dwId]._dwRetryEventThrottle = dwRetryEventPerRequest;
    
Exit:
    WriterUnlock();
    return hr;
}

//-----------------------------------------------------------------------------
//  ManageARP:  Manages ARP connections
//-----------------------------------------------------------------------------
HRESULT CNicMgr::ManageARP( PacketNode* pPacket )
{
    CArpMsg ArpMsg;
    HRESULT hr = S_OK;
    DWORD dwId = 0;
    DWORD dwENetHdrSize = 0;
    PacketNode objPN = {0};

    XOMASSERT ( pPacket != NULL );
    if ( pPacket == NULL )
    {        
        XomTrace( NicMgr, L_ERROR, "CNicMgr::ManageARP:  Why is this packet NULL at this time... DO NOT DO THIS! FIX YOUR CODE!!!" );
        hr = E_INVALIDARG;
        goto Exit;
    }
    dwId = pPacket->m_dwNicId;

    // attain the header size.    
    dwENetHdrSize = PACKET_DATA_OFFSET( pPacket->m_Data );

    //If this is an ARP packet, send an ARP reply
    if( pPacket->m_cData < (sizeof(CArpMsg) + dwENetHdrSize) )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::ManageARP:  Incoming ARP request has invalid size.  SIZE = %d, Id = %d", pPacket->m_cData, dwId );
        hr = E_FAIL;
        goto Exit;
    }
 
    memcpy( &ArpMsg, pPacket->GetArpMsg(), sizeof(CArpMsg) );

    XomTrace( NicMgr, L_LOW, "CNicMgr::ManageARP:  Incoming ARP Message From:%d.%d.%d.%d, For:%d.%d.%d.%d on VLAN=%d (%d.%d.%d.%d).  SIZE = %d", 
                ((BYTE*)&(ArpMsg._ipaSender))[0],
                ((BYTE*)&(ArpMsg._ipaSender))[1],
                ((BYTE*)&(ArpMsg._ipaSender))[2],
                ((BYTE*)&(ArpMsg._ipaSender))[3],
                ((BYTE*)&(ArpMsg._ipaTarget))[0],
                ((BYTE*)&(ArpMsg._ipaTarget))[1],
                ((BYTE*)&(ArpMsg._ipaTarget))[2],
                ((BYTE*)&(ArpMsg._ipaTarget))[3],
                dwId, 
                ((BYTE*)&(m_pAttachList[dwId]._dwIP))[0],
                ((BYTE*)&(m_pAttachList[dwId]._dwIP))[1],
                ((BYTE*)&(m_pAttachList[dwId]._dwIP))[2],
                ((BYTE*)&(m_pAttachList[dwId]._dwIP))[3],
                pPacket->m_cData );
    
    // Service the arp request if it is bound for this machine
    if (ArpMsg._wOp == ARP_OP_REQUEST && (DWORD)(ArpMsg._ipaTarget) == m_pAttachList[dwId]._dwIP )
    {
        CEnetHdr* pEHdr   = (CEnetHdr*)(objPN.m_Data);
        
        pEHdr->_eaDst     = ArpMsg._eaSender;
        memcpy(pEHdr->_eaSrc._ab, &(m_pAttachList[dwId]._eaVirtual), sizeof(CEnetAddr));
        pEHdr->_wType     = ENET_TYPE_ARP;

        ArpMsg._wOp       = ARP_OP_REPLY;
        ArpMsg._eaTarget  = ArpMsg._eaSender;
        ArpMsg._ipaTarget = ArpMsg._ipaSender;
        ArpMsg._ipaSender = m_pAttachList[dwId]._dwIP; 
        memcpy(ArpMsg._eaSender._ab, &(m_pAttachList[dwId]._eaVirtual), sizeof(CEnetAddr));

        // Copy the redefined ethernet header and ARP header into the packet's buffer
        memcpy( (BYTE*)(objPN.GetArpMsg()), &ArpMsg,   sizeof(CArpMsg)     );
        objPN.m_cData = sizeof(CEnetHdr) + sizeof(CArpMsg);

        // Transmit the reply.
        hr = Transmit( dwId, (BYTE*)objPN.m_Data, objPN.m_cData );
        if( !FAILED(hr) )
        {
            XomTrace( NicMgr, L_INFO, "ManageARP:  Processed ARP request successful.  Id= %d", dwId );
        }
        else
        {
            XomTrace( NicMgr, L_WARNING, "ManageARP:  Processed ARP request failed. Id= %d", dwId );
        }
        
    }
    else if ( ArpMsg._wOp == ARP_OP_REPLY                               && 
              (DWORD)(ArpMsg._ipaTarget) == m_pAttachList[dwId]._dwIP  &&
              (DWORD)(ArpMsg._ipaSender) == m_pAttachList[dwId]._dwDefaultGatewayIP )
    {
        XomTrace( NicMgr, L_INFO, "ManageARP:  Received ARP Reply for us.  Id = %d", dwId );
        
        // we received an ARP reply from the default gateway.
        hr = ARPReceived( dwId, &(ArpMsg._eaSender) );
        if ( FAILED(hr) )
        {
            goto Exit;
        }
    }

Exit:
    return hr;
}


//-----------------------------------------------------------------------------
//  ManageARP:  Manages ARP connections
//-----------------------------------------------------------------------------
BOOL CNicMgr::IsPacketForMe( PacketNode* pPacket )
{
    BOOL bRes = TRUE;
    DWORD dwId = 0;

    XOMASSERT ( pPacket != NULL );
    if ( pPacket == NULL )
    {        
        XomTrace( NicMgr, L_ERROR, "CNicMgr::IsPacketForMe:  Why is this packet NULL at this time... DO NOT DO THIS! FIX YOUR CODE!!!" );
        bRes = FALSE;
        goto Exit;
    }
    dwId = pPacket->m_dwNicId;
    
    CEnetHdr *pEnetHdr = pPacket->GetEnetHdr();
    CIpHdr   *pIpHdr   = pPacket->GetIPHdr();
    CUdpHdr  *pUdpHdr  = pPacket->GetUDPHdr();

    XomTrace( NicMgr, L_NORMAL, "CNicMgr::IsPacketForMe:  id:%d,  destip=%d.%d.%d.%d, destport=%d, acceptOn:%d", 
                dwId, 
                ((BYTE*)&(pIpHdr->_ipaDst))[0],
                ((BYTE*)&(pIpHdr->_ipaDst))[1],
                ((BYTE*)&(pIpHdr->_ipaDst))[2],
                ((BYTE*)&(pIpHdr->_ipaDst))[3],                 
                (DWORD)(NTOHS(pUdpHdr->_ipportDst)), 
                m_pAttachList[dwId]._dwPort );

    // check the Ethernet hdr and Ip addr to ensure this is 
    if ( memcmp( &(pEnetHdr->_eaDst), &(m_pAttachList[dwId]._eaVirtual), sizeof( CEnetAddr ) ) != 0 )
    {
        bRes = FALSE;
        goto Exit;
    }

    // check the IP
    if ( pIpHdr->_ipaDst._dw != m_pAttachList[dwId]._dwIP || pIpHdr->_wFragOff != 0 )
    {
        bRes = FALSE;
        goto Exit;
    }

    // check the UDP port.
    if ( NTOHS(pUdpHdr->_ipportDst) != m_pAttachList[dwId]._dwPort )
    {
        bRes = FALSE;
        goto Exit;
    }
    
Exit:
    return bRes;
}

//-----------------------------------------------------------------------------
//  Transmit:  Does the RawNic transmit.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::Transmit( DWORD dwNicId, BYTE *pPacket, DWORD cPacket )
{
    const int	MaxPacketSize = ENET_DATA_MAXSIZE + sizeof(CEnetHdr);

    HRESULT		hr = S_OK;
    DWORD		dwErr = NO_ERROR;
    NicMgrNode::XDS_OVERLAPPED* pXmitOverlapped = NULL;

    XOMASSERT( m_pAttachList != NULL );
    XOMASSERT( m_pAttachList[dwNicId]._hRawNic != NULL );

    // ensure the nic list exists.
    if ( m_pAttachList == NULL )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::Transmit:  Trying to transmit without any attached Nics.");
        hr = E_NOINTERFACE;
        goto Exit;
    }

    // ensure the handle exists.
    if ( m_pAttachList[dwNicId]._hRawNic == NULL )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::Transmit:  Trying to transmit without any attached RawNic handles.");
        hr = E_NOINTERFACE;
        goto Exit;
    }

    // Reasonable packet size?
    if(cPacket == 0 || cPacket > MaxPacketSize)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Get xmit overlapped
    pXmitOverlapped = XmitOverlappedAlloc(&m_pAttachList[dwNicId]);
    if (pXmitOverlapped == NULL)
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::Transmit:  Failed to allocate new XDS_OVERLAPPED from lookaside list.");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Build rawnic send buffer. Packets are prefixed with a WORD containing 
    // their size. Xds only sends one packet at a time so this is a tad bit easier. 

    DWORD cbAvailable = sizeof(pXmitOverlapped->_buffer);
    DWORD cbRequired = sizeof(WORD) + cPacket;
    if (cbRequired > cbAvailable)
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::Transmit:  Buffer not large enough to send packet. Required %d bytes, available %d bytes.", cbRequired, cbAvailable);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    *(WORD*)pXmitOverlapped->_buffer = (WORD)cPacket;
    memcpy(pXmitOverlapped->_buffer + sizeof(WORD), pPacket, cPacket);
    
    // get an instance of the nic mgr for this callback. The callback function is 
    // responsible for releasing it. This is just following the pattern of the Receive 
    // function.
    GetInstance();
    
    // send the packet(s). If NO_ERROR is returned, the call completed immediately. I've 
    // never seen this happen. If ERROR_IO_PENDING is returned, that's good - it means the 
    // request was queued and we have to wait for it to complete asynchronously.
    dwErr = RawAdapterSend( m_pAttachList[dwNicId]._hRawNic, cbRequired, pXmitOverlapped->_buffer, &pXmitOverlapped->_o);
    if (dwErr != NO_ERROR)
    {
        // Bad error?
        if (dwErr != ERROR_IO_PENDING)
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            XomTrace( NicMgr, L_ERROR, "CNicMgr::Transmit:  Failed to transmit packet. Hr=0x%08X", hr);
            goto Exit;
        }
    }
    
    pXmitOverlapped = NULL;

Exit:
    if (pXmitOverlapped != NULL)
    {
        OverlappedFree(pXmitOverlapped);
    }

    return hr;
}

//-----------------------------------------------------------------------------
//  SignalARPLookup:  Signals the ARP thread to perform ARP lookup with
//      default gateway.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::SignalARPLookup( DWORD dwNicId )
{
    HRESULT hr = S_OK;
    m_rwlAttachList.ReadLock();

    XOMASSERT( m_pAttachList != NULL );
    
    if ( m_pAttachList == NULL )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::SignalARPLookup:  Trying to signal arp without any attached Nics.  Id:  %d", dwNicId );
        hr = E_NOINTERFACE;
        goto Exit;
    }

    // this entry doesn't exist.
    if ( dwNicId >= m_cNicsCreated )
   {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::SignalARPLookup:  Signalled Nic does not exist.  Id:  %d", dwNicId );
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    SetEvent( m_pAttachList[dwNicId]._hARPThreadWakeUp );
    
Exit:
    m_rwlAttachList.ReadUnlock();

    return hr;
}

//-----------------------------------------------------------------------------
//  GetDefaultGatewayEnetAddr:  gets the currently stored value for the default
//      gateway ethernet address
//-----------------------------------------------------------------------------
HRESULT CNicMgr::GetDefaultGatewayEnetAddr( DWORD dwNicId, OUT CEnetAddr *pDefaultGatewayEnetAddrBuffer )
{
    HRESULT hr = S_OK;

    m_rwlAttachList.ReadLock();

    if ( m_pAttachList == NULL )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::GetDefaultGatewayEnetAddr:  Trying to get the default gateway without any attached Nics.");
        hr = E_NOINTERFACE;
        goto Exit;
    }

    if ( pDefaultGatewayEnetAddrBuffer == NULL )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::GetDefaultGatewayEnetAddr:  Invalid memory passed to function.");
        hr = E_INVALIDARG;
        goto Exit;
    }
    XOMASSERT( dwNicId < m_cNicsCreated );

    // copy the default gateway we currently have.
    EnterCriticalSection( &( m_pAttachList[dwNicId]._csGatewayEnetAddr ) );
    memcpy( (LPVOID)pDefaultGatewayEnetAddrBuffer, &(m_pAttachList[ dwNicId ]._eaDefaultGatewayEnetAddr), sizeof( CEnetAddr ) );
    LeaveCriticalSection( &( m_pAttachList[dwNicId]._csGatewayEnetAddr ) );
    
Exit:
    m_rwlAttachList.ReadUnlock();

    return hr;
}


//-----------------------------------------------------------------------------
//  GenerateVirtualNicEthernetAddress:  just as the name suggests.  It puts the 
//          virtual address generated into the eaVirtual variable.
//-----------------------------------------------------------------------------
void CNicMgr::GenerateVirtualNicEthernetAddress( CEnetAddr eaReal, DWORD dwId, CEnetAddr *peaVirtual )
{
    XOMASSERT( peaVirtual != NULL );
    peaVirtual->SetZero();
    
    // we may share this nic with TCP/IP, so make a fake ea from the computer
    // name, the normal ea and the nic id.
    
    char * pszComp = getenv("COMPUTERNAME");
    A_SHA_CTX shaCtx;
    BYTE      abHash[A_SHA_DIGEST_LEN];

    A_SHAInit(&shaCtx);
    A_SHAUpdate(&shaCtx, (BYTE *)pszComp, strlen(pszComp));
    A_SHAUpdate(&shaCtx, (BYTE *)&eaReal, sizeof(eaReal));
    A_SHAUpdate(&shaCtx, (BYTE *)&dwId, sizeof(dwId));
    A_SHAFinal(&shaCtx, abHash);
    abHash[0] &= ~3; // zap multicast bit(1), locally administered(2)

    memcpy( peaVirtual->_ab, abHash, sizeof( peaVirtual->_ab ));

}

//-----------------------------------------------------------------------------
//  AttachNic:  Attaches a Nic to the RawNic driver.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::AttachNic( NicMgrNode* pnmNode )
{
    HRESULT hr = S_OK;
    DWORD dwErr = NO_ERROR;

    // open the raw nic adapter
    dwErr = RawAdapterOpen( pnmNode->_eaReal._ab, 
                            pnmNode->_eaVirtual._ab,
                            RN_OPTION_OVERLAPPED | RN_OPTION_BROADCAST_ARP,
                            0,
                            0,
                            (HANDLE *)&pnmNode->_hRawNic);

    if (dwErr != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32( dwErr );
        XomTrace(NicMgr, L_ERROR, "CNicMgr::AttachNic:  RawAdapterOpen '%s' failed, err = %d",
                 pnmNode->_eaReal.Str(), dwErr);
        goto Exit;
    }

    // bind the completion callback
    if ( !BindIoCompletionCallback(pnmNode->_hRawNic, PacketIoComplete, 0) )
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
        XomTrace(NicMgr, L_ERROR,  "CNicMgr::AttachNic: BindIoCompletionCallback '%s' failed, err = %d, id = %d",
                                    pnmNode->_eaVirtual.Str(), 
                                    dwErr,
                                    pnmNode->_dwId );
        goto Exit;
    }

    // initialize the receiver thread.
    hr = InitializeRecvThread( pnmNode->_dwId );
    if ( FAILED (hr) )
    {
        XomTrace(NicMgr, L_ERROR,  "CNicMgr::AttachNic: Initialize Receiver Thread '%s' failed, hr = %d, id= %d",
                                    pnmNode->_eaVirtual.Str(), 
                                    hr,
                                    pnmNode->_dwId );
        goto Exit;
    }

Exit:    
    return hr;
}

//-----------------------------------------------------------------------------
//  DetachNic:  Detaches the Nic driver of the given.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::DetachNic( NicMgrNode* pnmNode )
{
    HRESULT hr = S_OK;

    // release the callback handle.
    CloseHandle( pnmNode->_hRawNic );
    pnmNode->_hRawNic = NULL;

    // terminate the receiver thread.
    TerminateRecvThread( pnmNode->_dwId );

    return hr;
}

//-----------------------------------------------------------------------------
//  RecvPacket:  Receive the packet on the NIC.
//-----------------------------------------------------------------------------
HRESULT CNicMgr::RecvPacket( NicMgrNode* pnmNode )
{
    HRESULT hr = S_OK;
    DWORD dwErr = NO_ERROR;    

    if ( pnmNode->_hRawNic == NULL )
    {
        // process is shutting down, just clean up.
        hr = S_FALSE;
    }

    // get an instance of the nic mgr for this callback.
    GetInstance();
    
    // setup the receive.    
    dwErr = RawAdapterRecv( pnmNode->_hRawNic, sizeof(pnmNode->_recvOverlapped._buffer), pnmNode->_recvOverlapped._buffer, &(pnmNode->_recvOverlapped._o), NULL);    
    if (dwErr != ERROR_IO_PENDING)
    {
        XomTrace( NicMgr, L_WARNING, "NicMgr:(CNicMgr::RecvPacket): RawAdapterRecv failed error %d.  Id= %d", dwErr, pnmNode->_dwId );
        XomNtEvent( XEVENT_XDS_CODE_3,  "NicMgr:(CNicMgr::RecvPacket):  RawAdapterRecv failed error %d.  Id= %d", dwErr, pnmNode->_dwId );

        // didn't work so let's release the instance.
        ReleaseInstance();

        hr = E_FAIL;
        goto Exit;
    }
    
Exit:
    return hr;
}


//------------------------------------------------------------------
// ARP thread implementation


//------------------------------------------------------------------
//  ArpThread:  Thread to send arp requests to the default gateway.
//------------------------------------------------------------------
DWORD WINAPI CNicMgr::ARPThread( LPVOID pId )
{
    // get the object... we need a reference per thread.
    CNicMgr *pThis = CNicMgr::GetInstance();

    // perform arp thread actions.
    pThis->ARPThreadInternal( (DWORD)pId );

    // we're done... release the reference
    pThis->ReleaseInstance();
    
    return 0;
}


//------------------------------------------------------------------
//  ARPThreadInternal: Constructs ARP message and sends it via.
//------------------------------------------------------------------
void CNicMgr::ARPThreadInternal( DWORD dwId )
{
    HRESULT hr = S_OK;
    DWORD dwWaitRes = 0;
    BYTE  byteArpMsgPacket[ sizeof( CEnetHdr ) + sizeof( CArpMsg ) ]; 
    BOOL  bSendArp = TRUE;
    DWORD dwNumOfRetries = 0;

    CArpMsg* pArpMsg = (CArpMsg*)( (BYTE*)&byteArpMsgPacket + sizeof(CEnetHdr) );
    CEnetHdr* pArpEnetAddr = (CEnetHdr*)( (BYTE*)&byteArpMsgPacket);
    
    m_rwlAttachList.ReadLock();

    if ( m_pAttachList == NULL )
    {
        m_rwlAttachList.ReadUnlock();
        return;
    }
    m_pAttachList[dwId]._bEndARPThread = FALSE;
    
    // Genereate a random ARP packet.  Fill it in... we will use this packet for every lookup.    
    pArpEnetAddr->_eaDst.SetBroadcast();
    memcpy(pArpEnetAddr->_eaSrc._ab, &(m_pAttachList[dwId]._eaVirtual), sizeof(CEnetAddr));
    pArpEnetAddr->_wType    = ENET_TYPE_ARP;

    pArpMsg->_wHrd      = ARP_HWTYPE_ENET;
    pArpMsg->_wPro      = ENET_TYPE_IP;
    pArpMsg->_bHln      = sizeof(CEnetAddr);
    pArpMsg->_bPln      = sizeof(CIpAddr);
    pArpMsg->_wOp       = ARP_OP_REQUEST;
    pArpMsg->_eaSender  = m_pAttachList[dwId]._eaVirtual;
    pArpMsg->_eaTarget.SetZero();
    pArpMsg->_ipaSender = m_pAttachList[dwId]._dwIP;
    pArpMsg->_ipaTarget = m_pAttachList[dwId]._dwDefaultGatewayIP;

    m_rwlAttachList.ReadUnlock();

    if ( !m_bUseArpThread )
    {
        XomTrace( NicMgr, L_WARNING,  "NicMgr:(CNicMgr::ARPThreadInternal)  No using arp thread."); 
        return;
    }
        
    // the inner functions of this thread.
    while ( !m_pAttachList[dwId]._bEndARPThread ) 
    {   
        if ( bSendArp )
        {
            // see if we're suppose to send an ARP.
            Transmit( dwId, (BYTE*)byteArpMsgPacket, ARRAY_ELEMENTS(byteArpMsgPacket) );
            XomTrace( NicMgr, L_LOW,  "NicMgr:(CNicMgr::ARPThreadInternal)  ARP request sent to %d.%d.%d.%d.  Id: %d", 
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[0],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[1],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[2],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[3],
                                    dwId );

            // wait for a arp reply.
            dwWaitRes = WaitForSingleObject( m_pAttachList[dwId]._hARPThreadReponseWait, m_pAttachList[dwId]._dwRetryInterval );
            switch( dwWaitRes )
            {            
                case WAIT_OBJECT_0:
                    {
                        XomTrace( NicMgr, L_LOW,  "NicMgr:(CNicMgr::ARPThreadInternal)  ARP thread is awake with an ARP response.  Id: %d", dwId );

                        // we got a response... don't send anymore.
                        bSendArp = FALSE;
                        dwNumOfRetries = 0;
                    }
                    break;
                case WAIT_TIMEOUT:
                    {
                        XomTrace( NicMgr, L_LOW,  "NicMgr:(CNicMgr::ARPThreadInternal)  ARP thread is awake and about to send another ARP request.  Id: %d", dwId );
                        bSendArp = TRUE;
                        dwNumOfRetries++;

                        if ( ( dwNumOfRetries % m_pAttachList[dwId]._dwRetryEventThrottle) == 0 )
                        {
                            XomNtEvent( XEVENT_XDS_COMM_0, "NicMgr:(CNicMgr::ARPThreadInternal)  We've sent %d ARP requests without getting a response from %d.%d.%d.%d.  Please check if the default gateway is configured properly and is operational.  NicId: %d", 
                                    dwNumOfRetries,
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[0],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[1],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[2],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[3],
                                    dwId
                                    );
                            
                            XomTrace( NicMgr, L_ERROR, "NicMgr:(CNicMgr::ARPThreadInternal)  We've sent %d ARP requests without getting a response from %d.%d.%d.%d.  Please check if the default gateway is configured properly and is operational.  NicId: %d",
                                    dwNumOfRetries,
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[0],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[1],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[2],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[3],
                                    dwId
                                    );
                        }
                        else
                        {
                            XomTrace( NicMgr, L_WARNING, "NicMgr:(CNicMgr::ARPThreadInternal)  We've sent %d ARP requests without getting a response from %d.%d.%d.%d.  Please check if the default gateway is configured properly and is operational.  NicId: %d",
                                    dwNumOfRetries,
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[0],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[1],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[2],
                                    ((BYTE*)&(m_pAttachList[dwId]._dwDefaultGatewayIP))[3],
                                    dwId
                                    );
                        }

                    }
                    break;
                case WAIT_ABANDONED:
                    {
                        // ok this should never happen... why?
                        XomTrace( NicMgr, L_ERROR,"NicMgr:(CNicMgr::ARPThreadInternal)  The thread wait was abandoned, this usually means the event has been lost.  Closing ARP thread.  Id:  %d", dwId );
                        XomNtEvent( XEVENT_XDS_CODE_4, "NicMgr:(CNicMgr::ARPThreadInternal)  The thread wait was abandoned, this usually means the event has been lost.  Closing ARP thread.  Id:  %d", dwId );
                        m_pAttachList[dwId]._bEndARPThread = TRUE;
                    }
                    break;
                default:
                    {
                        XOMASSERT( !"Unexpected response from WaitForSingleObject");
                        XomTrace( NicMgr, L_WARNING,  "NicMgr:(CNicMgr::ARPThreadInternal) WaitForSingleObject has returned an unexpected value.  Please investigate this problem.  It may require an update to the NicMgr binaries.  Id:  %d", dwId );
                        XomNtEvent( XEVENT_XDS_CODE_5, "NicMgr:(CNicMgr::ARPThreadInternal) WaitForSingleObject has returned an unexpected value.  Please investigate this problem.  It may require an update to the NicMgr binaries.  Id:  %d",  dwId );
                    }
            }             

        }
        else
        {
            dwWaitRes = WaitForSingleObject( m_pAttachList[dwId]._hARPThreadWakeUp, m_pAttachList[dwId]._dwPollTime );
            switch( dwWaitRes )
            {            
                case WAIT_OBJECT_0:
                case WAIT_TIMEOUT:
                    {
                        XomTrace( NicMgr, L_LOW,  "NicMgr:(CNicMgr::ARPThreadInternal)  ARP thread is awake.  Id: %d", dwId );
                        bSendArp = TRUE;
                        dwNumOfRetries = 0;
                    }
                    break;
                case WAIT_ABANDONED:
                    {
                        // ok this should never happen... why?
                        XomTrace( NicMgr, L_ERROR,"NicMgr:(CNicMgr::ARPThreadInternal)  The thread wait was abandoned, this usually means the event has been lost.  Closing ARP thread.  Id:  %d", dwId );
                        XomNtEvent( XEVENT_XDS_CODE_6, "NicMgr:(CNicMgr::ARPThreadInternal)  The thread wait was abandoned, this usually means the event has been lost.  Closing ARP thread.  Id:  %d", dwId );
                        m_pAttachList[dwId]._bEndARPThread = TRUE;
                    }
                    break;
                default:
                    {
                        XOMASSERT( !"Unexpected response from WaitForSingleObject");
                        XomTrace( NicMgr, L_WARNING,  "NicMgr:(CNicMgr::ARPThreadInternal) WaitForSingleObject has returned an unexpected value.  Please investigate this problem.  It may require an update to the NicMgr binaries.  Id:  %d", dwId );
                        XomNtEvent( XEVENT_XDS_CODE_7, "NicMgr:(CNicMgr::ARPThreadInternal) WaitForSingleObject has returned an unexpected value.  Please investigate this problem.  It may require an update to the NicMgr binaries.  Id:  %d",  dwId );
                    }
            }             
        }
    }
}


//------------------------------------------------------------------
//  InitializeARPThread:  
//------------------------------------------------------------------
HRESULT CNicMgr::InitializeARPThread( DWORD dwId )
{
    HRESULT hr = S_OK;

    // set the flag for managing the life of the ARP thread.
    m_pAttachList[dwId]._bEndARPThread = FALSE;

    // create a critical section to protect the ethernet header 
    InitializeCriticalSection( &( m_pAttachList[dwId]._csGatewayEnetAddr ) );
    
    // create thread ready event.
    if ( ( m_pAttachList[dwId]._hARPThreadWakeUp = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

        XomTrace( NicMgr, L_ERROR, "NicMgr:(CNicMgr::InitializeARPThread)  Failed to create the wake up event for the ARP thread(%d).  Check system resources. Result = 0x%X", dwId, hr );
        XomNtEvent( XEVENT_XDS_CODE_8, "NicMgr:(CNicMgr::InitializeARPThread)  Failed to create the wake up event for the ARP thread(%d).  Check system resources. Result = 0x%X", dwId, hr );

        DeleteCriticalSection( &( m_pAttachList[dwId]._csGatewayEnetAddr ) );

        goto Exit;
    }

    // create thread ready event.
    if ( ( m_pAttachList[dwId]._hARPThreadReponseWait = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

        XomTrace( NicMgr, L_ERROR, "NicMgr:(CNicMgr::InitializeARPThread)  Failed to create the wake up event for the ARP thread(%d).  Check system resources. Result = 0x%X", dwId, hr );
        XomNtEvent( XEVENT_XDS_CODE_9, "NicMgr:(CNicMgr::InitializeARPThread)  Failed to create the wake up event for the ARP thread(%d).  Check system resources. Result = 0x%X", dwId, hr );

        DeleteCriticalSection( &( m_pAttachList[dwId]._csGatewayEnetAddr ) );

        goto Exit;
    }

    // create and start admin ticket thread.  LOG IT
    if ( (m_pAttachList[dwId]._hARPThread = CreateThread( NULL, NULL, ARPThread, (LPVOID)dwId, 0, &m_pAttachList[dwId]._dwARPThreadId ) ) == NULL )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

        XomTrace( NicMgr, L_ERROR, "NicMgr:(CNicMgr::InitializeARPThread)  Failed to create the ARP thread(%d).  Check system resources. Result = 0x%X", dwId, hr );
        XomNtEvent( XEVENT_XDS_CODE_10, "NicMgr:(CNicMgr::InitializeARPThread)  Failed to create the ARP thread(%d).  Check system resources. Result = 0x%X", dwId, hr );

        DeleteCriticalSection( &( m_pAttachList[dwId]._csGatewayEnetAddr ) );

        goto Exit;
    }
    
    XOMASSERT( m_pAttachList[dwId]._hARPThread );
    
Exit:
    return hr;
}

//------------------------------------------------------------------
//  TerminateARPThread:  Terminate the ARP thread.
//------------------------------------------------------------------
void CNicMgr::TerminateARPThread( DWORD dwId )
{
    if ( m_pAttachList != NULL )
    {
        // if the thread exists... wipe it...
        if ( m_pAttachList[dwId]._hARPThread != NULL )
        {
            // flag the thread to complete stage.     
            m_pAttachList[dwId]._bEndARPThread = TRUE;
        
            // signal the wakeup events.
            SetEvent( m_pAttachList[dwId]._hARPThreadWakeUp );
            SetEvent( m_pAttachList[dwId]._hARPThreadReponseWait );
    
            // wait for the thread to stop
            WaitForSingleObject( m_pAttachList[dwId]._hARPThread, 1000 );             // only wait for 1 second

            // close the handles
            CloseHandle( m_pAttachList[dwId]._hARPThreadWakeUp );
            CloseHandle( m_pAttachList[dwId]._hARPThreadReponseWait );
            CloseHandle( m_pAttachList[dwId]._hARPThread );
            m_pAttachList[dwId]._hARPThread = NULL;
            
            DeleteCriticalSection( &( m_pAttachList[dwId]._csGatewayEnetAddr ) );

            XomTrace(NicMgr, L_NORMAL, "NicMgr:(CNicMgr::TerminateARPThread)  ARP thread terminated for %d.\n", dwId );
        }
        
    }

}

//------------------------------------------------------------------
//  ARPReceived:  Informs ARP thread that the expected reply
//      was received.
//------------------------------------------------------------------
HRESULT CNicMgr::ARPReceived( DWORD dwId, CEnetAddr* peaDefaultGateway )
{
    HRESULT hr = S_OK;

    m_rwlAttachList.ReadLock();
    
    if ( m_pAttachList == NULL )
    {
        XomTrace( NicMgr, L_ERROR, "CNicMgr::ARPReceived:  ARP received but we dont' have any nic to receive on.");
        hr = E_NOINTERFACE;
        goto Exit;
    }

    XOMASSERT( peaDefaultGateway != NULL );
    XOMASSERT( dwId < m_cNicsCreated );

    // set the ethernet addr value.  Critical section for atomic operation.
    EnterCriticalSection( &( m_pAttachList[dwId]._csGatewayEnetAddr ) );
    memcpy( &(m_pAttachList[ dwId ]._eaDefaultGatewayEnetAddr), peaDefaultGateway, sizeof( CEnetAddr ) );    
    LeaveCriticalSection( &( m_pAttachList[dwId]._csGatewayEnetAddr ) );
    
    SetEvent( m_pAttachList[ dwId ]._hARPThreadReponseWait );

Exit:
    m_rwlAttachList.ReadUnlock();

    return hr;
}


//------------------------------------------------------------------
// Recv Timer thread implementation

//------------------------------------------------------------------
//  RecvThread:  Thread to send arp requests to the default gateway.
//------------------------------------------------------------------
DWORD WINAPI CNicMgr::RecvThread( LPVOID pId )
{
    // get the object... we need a reference per thread.
    CNicMgr *pThis = CNicMgr::GetInstance();

    // perform arp thread actions.
    pThis->RecvThreadInternal( (DWORD)pId );

    // we're done... release the reference
    pThis->ReleaseInstance();
    
    return 0;
}


//------------------------------------------------------------------
//  RecvThreadInternal: Wakes up when necessary to recall the raw 
//      nic receive.
//------------------------------------------------------------------
void CNicMgr::RecvThreadInternal( DWORD dwId )
{
    HRESULT hr = S_OK;
    DWORD dwWaitRes = 0;
    BOOL  bSendArp = TRUE;
    DWORD dwNumOfRetries = 0;

    // check the attach list.
    m_rwlAttachList.ReadLock();

    if ( m_pAttachList == NULL )
    {
        m_rwlAttachList.ReadUnlock();
        return;
    }
    
    m_pAttachList[dwId]._bEndRecvThread = FALSE;
    
    m_rwlAttachList.ReadUnlock();
    
    // the inner functions of this thread.
    while ( !m_pAttachList[dwId]._bEndRecvThread ) 
    {   
        // setup the receive.
        hr = RecvPacket( &(m_pAttachList[dwId]) );
        if ( FAILED(hr) )
        {
            dwWaitRes = m_pAttachList[dwId]._dwRetryWait;
        }
        else
        {
            dwWaitRes = INFINITE;
            dwNumOfRetries = 0;
        }
            
        // wait for a request to retry the receive.
        // NOTE:  We don't want this thread running unnecesarily... only when required.  
        //      As a result it will only wake when called.
        dwWaitRes = WaitForSingleObject( m_pAttachList[dwId]._hRecvRetry, dwWaitRes );
                
        switch( dwWaitRes )
        {            
            case WAIT_OBJECT_0:
                {
                    XomTrace( NicMgr, L_LOW,  "NicMgr:(CNicMgr::RecvThreadInternal)  The Receiver thread is awake and setting up the raw nic receive.  Id: %d", dwId );
                }
                break;
            case WAIT_TIMEOUT:
                {
                    dwNumOfRetries++;

                    XomTrace( NicMgr, L_ERROR, "NicMgr:(CNicMgr::RecvThreadInternal)  Receiver retry thread Id %d has attempted to bind to rzw nic receive %d number of times.  Please investigate why this is failing.", dwId );

                    // check 
                    if ( ( dwNumOfRetries % m_pAttachList[dwId]._dwRetryEventThrottle) == 0 )
                    {
                        XomNtEvent( XEVENT_XDS_CODE_11, "NicMgr:(CNicMgr::RecvThreadInternal)  Receiver retry thread Id %d has attempted to bind to rzw nic receive %d number of times.  Please investigate why this is failing.", dwId );
                    }
                }
                break;
            case WAIT_ABANDONED:
                {
                    // ok this should never happen... why?
                    XomTrace( NicMgr, L_ERROR, "NicMgr:(CNicMgr::RecvThreadInternal)  The thread wait was abandoned, this usually means the event has been lost.  Closing Recevier Retry thread.  This is catastophic since XDS can no longer recover on failed receives.  Please restart this service.  Id:  %d", dwId );
                    XomNtEvent( XEVENT_XDS_CODE_12, "NicMgr:(CNicMgr::RecvThreadInternal)  The thread wait was abandoned, this usually means the event has been lost.  Closing Recevier Retry thread.  This is catastophic since XDS can no longer recover on failed receives.  Please restart this service.  Id:  %d", dwId );
                    m_pAttachList[dwId]._bEndRecvThread = TRUE;
                }
                break;
            default:
                {
                    XOMASSERT( !"Unexpected response from WaitForSingleObject" );
                    XomTrace( NicMgr, L_WARNING,  "NicMgr:(CNicMgr::RecvThreadInternal) WaitForSingleObject has returned an unexpected value.  Please investigate this problem.  It may require an update to the NicMgr binaries.  Id:  %d", dwId );
                    XomNtEvent( XEVENT_XDS_CODE_13, "NicMgr:(CNicMgr::RecvThreadInternal) WaitForSingleObject has returned an unexpected value.  Please investigate this problem.  It may require an update to the NicMgr binaries.  Id:  %d",  dwId );
                }
        }                     

    }
}


//------------------------------------------------------------------
//  InitializeRecvThread:  
//------------------------------------------------------------------
HRESULT CNicMgr::InitializeRecvThread( DWORD dwId )
{
    HRESULT hr = S_OK;

    // set the flag for managing the life of the ARP thread.
    m_pAttachList[dwId]._bEndRecvThread = FALSE;
    
    // create thread ready event.
    if ( ( m_pAttachList[dwId]._hRecvRetry = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

        XomTrace( NicMgr, L_ERROR, "NicMgr:(CNicMgr::InitializeRecvThread)  Failed to create the retry event for the retry thread(%d).  Check system resources. Result = 0x%X", dwId, hr );
        XomNtEvent( XEVENT_XDS_CODE_14, "NicMgr:(CNicMgr::InitializeRecvThread)  Failed to create the retry event for the retry thread(%d).  Check system resources. Result = 0x%X", dwId, hr );

        goto Exit;
    }

    // create and start admin ticket thread.  LOG IT
    if ( (m_pAttachList[dwId]._hRecvThread = CreateThread( NULL, NULL, RecvThread, (LPVOID)dwId, 0, &m_pAttachList[dwId]._dwRecvThreadId ) ) == NULL )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

        XomTrace( NicMgr, L_ERROR, "NicMgr:(CNicMgr::InitializeRecvThread)  Failed to create the Recv thread(%d).  Check system resources. Result = 0x%X", dwId, hr );
        XomNtEvent( XEVENT_XDS_CODE_15, "NicMgr:(CNicMgr::InitializeRecvThread)  Failed to create the Recv thread(%d).  Check system resources. Result = 0x%X", dwId, hr );

        goto Exit;
    }

    
    XOMASSERT( m_pAttachList[dwId]._hRecvThread );
    
Exit:
    return hr;
}

//------------------------------------------------------------------
//  TerminateRecvThread:  Terminate the Recv retry thread.
//------------------------------------------------------------------
void CNicMgr::TerminateRecvThread( DWORD dwId )
{
    if ( m_pAttachList != NULL )
    {
        // if the thread exists... wipe it...
        if ( m_pAttachList[dwId]._hRecvThread != NULL )
        {
            // flag the thread to complete stage.     
            m_pAttachList[dwId]._bEndRecvThread = TRUE;
        
            // signal the wakeup events.
            SetEvent( m_pAttachList[dwId]._hRecvRetry );
    
            // wait for the thread to stop
            WaitForSingleObject( m_pAttachList[dwId]._hRecvThread, 1000 );             // only wait for 1 second

            // close the handles
            CloseHandle( m_pAttachList[dwId]._hRecvRetry );
            CloseHandle( m_pAttachList[dwId]._hRecvThread );
            m_pAttachList[dwId]._hRecvThread = NULL;
            
            XomTrace(NicMgr, L_NORMAL, "NicMgr:(CNicMgr::TerminateRecvThread)  Recv retry thread terminated for %d.\n", dwId );
        }
        
    }

}


//-----------------------------------------------------------------------------
//  Callback
//-----------------------------------------------------------------------------
void CALLBACK PacketIoComplete(DWORD dwErr, DWORD cbRecv, LPOVERLAPPED lpo)
{
    NicMgrNode::XDS_OVERLAPPED *    pxo     = NULL;
    NicMgrNode *                    pnmNode = NULL;
    
    XOMASSERT( lpo != NULL );
    
    // ensure we have an overlap.
    if ( lpo == NULL )
    {
        XomTrace( NicMgr, L_ERROR, "PacketIoComplete:  The Overlapped structure is NULL.  XDS is unable to determine which Nic had this problem.  A system restart is necessary.  Error=0x%X", dwErr );
        XomNtEvent( XEVENT_XDS_CODE_16, "PacketIoComplete:  The Overlapped structure is NULL.  XDS is unable to determine which Nic had this problem.  A system restart is necessary.  Error=0x%X", dwErr );
        return;
    }

    // Retrieve XDS_OVERLAPPED record holding the overlapped structure. This will tell us 
    // whether it was a xmit or recv IO operation.
    pxo = CONTAINING_RECORD(lpo, NicMgrNode::XDS_OVERLAPPED, _o);    
    XOMASSERT( pxo != NULL );

    // The XDS_OVERLAPPED struct has a pointer back to its parent, so we can retrieve the 
    // NicMgrNode.
    pnmNode = pxo->_pNicMgrNode;
    XOMASSERT( pnmNode != NULL );

    // Determine type of IO operation and call appropriate worker function
    if (pxo->_ioType == NicMgrNode::IO_RECV)
    {
        PacketRecvComplete(dwErr, cbRecv, pnmNode);
    }
    else if (pxo->_ioType == NicMgrNode::IO_XMIT)
    {
        CNicMgr::GetInstance()->OverlappedFree(pxo);
        PacketXmitComplete(dwErr, cbRecv, pnmNode);
    }
    else
    {
        // super duper bad. should never happen.
        XomTrace(NicMgr, L_ERROR, "PacketIoComplete: Unknown IO type.  Error=0x%X", dwErr);
        XOMASSERT( FALSE );
    }

}

//------------------------------------------------------------------
//  PacketXmitComplete:  determine what to do with this packet.
//------------------------------------------------------------------
void PacketXmitComplete(DWORD dwErr, DWORD cbRecv, NicMgrNode *pnmNode)
{
    // not much to do

    // release the instance created in Transmit (don't want to shut down with pending 
    // IO)...
    CNicMgr::ReleaseInstance();
}


//------------------------------------------------------------------
//  PacketRecvComplete:  determine what to do with this packet.
//------------------------------------------------------------------
void PacketRecvComplete(DWORD dwErr, DWORD cbRecv, NicMgrNode *pnmNode)
{
    HRESULT hr = S_OK;
    CNicMgr *pNicMgr = CNicMgr::GetInstance();
    CXdsMain *pXds = CXdsMain::GetInstance();
    PacketNode *pPacket = NULL;
    LIST_ENTRY packetList;
    InitializeListHead(&packetList);

    XOMASSERT( pXds != NULL );
    XOMASSERT( pNicMgr != NULL );

    // release the instance created in RecvPacket... we already have a reference from this point.
    CNicMgr::ReleaseInstance();

    if ( pXds == NULL || pNicMgr == NULL )
    {
        if ( pXds != NULL )
        {
            CXdsMain::ReleaseInstance();
        }
        if ( pNicMgr != NULL )
        {
            CNicMgr::ReleaseInstance();
        }

        return;
    }

    pNicMgr->ReaderLock();
    
    // check the error value.    
    if ( dwErr != NO_ERROR )
    {
        XomTrace( NicMgr, L_ERROR, "PacketRecvComplete:  XDS encountered an error while waiting on this NIC.  Please investigate.  Error=0x%X, Id=%d", dwErr, pnmNode->_dwId );
        XomNtEvent( XEVENT_XDS_CODE_17, "PacketRecvComplete:  XDS encountered an error while waiting on this NIC.  Please investigate.  Error=0x%X, Id=%d", dwErr, pnmNode->_dwId );

        // wake the receiver thread and tell it to retry with this nic
        SetEvent( pnmNode->_hRecvRetry );
        goto Exit;
    }

    // Rawnic returns one or more packets in the buffer. Each packet is 
    // prefixed by a WORD that contains the size of the packet. Process the 
    // buffer and put each packet in a packet node.
    
    BYTE* pb       = pnmNode->_recvOverlapped._buffer;
    DWORD cb       = cbRecv;
    WORD  cbPacket = 0;

    while(cb > 0)
    {
        if(cb < sizeof(WORD))
        {
            XomNtEvent( XEVENT_XDS_CODE_18, "Rawnic returned invalid buffer. cb < sizeof(WORD)");
            break;
        }
        
        cbPacket = *(WORD*)pb;

        if(cbPacket == 0 ||
           cbPacket > sizeof(pPacket->m_Data) ||
           cb < sizeof(WORD) + cbPacket)
        {
            XomNtEvent( XEVENT_XDS_CODE_19, "Rawnic returned invalid buffer. Invalid packet size");
            break;
        }
        
        // allocate packet and copy data
        pPacket = pXds->GetPacketNode();
        if (pPacket == NULL)
        {
            XomNtEvent( XEVENT_XDS_CODE_20,  "Failed to allocate packet. Out of memory?");
            break;
        }
        memcpy(pPacket->m_Data, pb + sizeof(WORD), cbPacket);
        pPacket->m_cData = cbPacket;
        pPacket->m_dwNicId = pnmNode->_dwId;
        
        // put packet in the list
        InsertTailList(&packetList, &pPacket->m_Link);
        pPacket = NULL;

        // adjust
        pb += sizeof(WORD) + cbPacket;
        cb -= sizeof(WORD) + cbPacket;
    }

    if(IsListEmpty(&packetList))
    {
        XomNtEvent( XEVENT_XDS_CODE_21, "Rawnic returned invalid buffer. No packets");
    }
    
    // now that we have the packet(s)... let's allow the nic to receive some 
    // more.  Tell the receiver thread to continue.
    SetEvent( pnmNode->_hRecvRetry );
    
    // process packets
    while(!IsListEmpty(&packetList))
    {
        LIST_ENTRY* ple = RemoveHeadList(&packetList);
        pPacket = CONTAINING_RECORD(ple, PacketNode, m_Link);
        pNicMgr->ProcessPacket(pnmNode, pPacket);
        pXds->ReleasePacketNode( pPacket );
        pPacket = NULL;
    }

Exit:
    
    pNicMgr->ReaderUnlock();
    CXdsMain::ReleaseInstance();
    CNicMgr::ReleaseInstance();
    
    return;
}

void CNicMgr::ProcessPacket(NicMgrNode* pnmNode, PacketNode* pPacket)
{
    CXdsMain *pXds = CXdsMain::GetInstance();
    HRESULT hr;
    USHORT usType = 0;
    DWORD dwEtherHdrSize = sizeof(CEnetHdr);
    DWORD dwEtherHdrType = ETHERNET_HEADER_TYPE_NORMAL;
    CEnetHdr* pEnetHdr = NULL;
    DWORD cb = pPacket->m_cData;
    
    pEnetHdr = pPacket->GetEnetHdr();
    usType = pEnetHdr->_wType;

    // ensure the data received is at least
    if (cb < sizeof(CEnetHdr))
    {
        // make info traces... this isn't important enough for an error log.
        XomTrace( NicMgr, L_ERROR, "PacketRecvComplete:  Frame (%d bytes) is smaller than CEnetHdr (%d bytes).  Id=%d", cb, sizeof(CEnetHdr), pnmNode->_dwId );
        goto Exit;
    }

    // check if it's a Ieee header.
    if ( ISIEEEHDR( pPacket->m_Data ) )
    {
        CIeeeHdr * pIeeeHdr = pPacket->GetIeeeHdr();

        if ( cb < sizeof(CIeeeHdr) )
        {
            // make info traces... this isn't important enough for an error log.
            XomTrace(NicMgr, L_ERROR, "PacketRecvComplete:  Frame (%d bytes) is smaller than CIeeeHdr (%d bytes).  Id=%d", cb, sizeof(CIeeeHdr), pnmNode->_dwId );
            goto Exit;
        }

        if (!pIeeeHdr->IsEnetFrame())
        {
            char szHex[ (sizeof(CIeeeHdr) * 2) + 1 ] = {0};
            BinToHex( (char*)pIeeeHdr, sizeof(CIeeeHdr), szHex );
            XomTrace(NicMgr, L_ERROR, "PacketRecvComplete:  Frame has unrecognized ethernet header (%s).  Id=%d", szHex, pnmNode->_dwId );
            goto Exit;
        }

        // Update the frame type from the IEEE header
        usType = pIeeeHdr->_wTypeIeee;
        dwEtherHdrSize = sizeof(CIeeeHdr);
        dwEtherHdrType = ETHERNET_HEADER_TYPE_IEEE;

    }

    // look at the MAC addrs on the packet.
    XomTrace(NicMgr, L_NORMAL, "PacketRecvComplete:  Packet From:  %.2X-%.2X-%.2X-%.2X-%.2X-%.2X   To: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X.  Type = %d  Id = %d Size = %d",
                                pEnetHdr->_eaSrc._ab[0],
                                pEnetHdr->_eaSrc._ab[1],
                                pEnetHdr->_eaSrc._ab[2],
                                pEnetHdr->_eaSrc._ab[3],
                                pEnetHdr->_eaSrc._ab[4],
                                pEnetHdr->_eaSrc._ab[5],
                                pEnetHdr->_eaDst._ab[0],
                                pEnetHdr->_eaDst._ab[1],
                                pEnetHdr->_eaDst._ab[2],
                                pEnetHdr->_eaDst._ab[3],
                                pEnetHdr->_eaDst._ab[4],
                                pEnetHdr->_eaDst._ab[5],
                                usType,
                                pnmNode->_dwId,
                                cb
            );


    // Determine the type of the packet that we received.
    switch( usType )
    {
    case ENET_TYPE_ARP:
        {
            CArpMsg *parpMsg = pPacket->GetArpMsg();

            // ensure this a valid arp packet
            if ( cb >= ( c_dwARPPacketSize + dwEtherHdrSize )
                &&  parpMsg->_wHrd == ARP_HWTYPE_ENET
                &&  parpMsg->_wPro == ENET_TYPE_IP
                &&  parpMsg->_bHln == sizeof(CEnetAddr)
                &&  parpMsg->_bPln == sizeof(CIpAddr)  )
            {
                XomTrace( NicMgr, L_LOW, "PacketRecvComplete:  Got an ARP.  Id = %d", pnmNode->_dwId );

                // manage the ARP request.
                ManageARP( pPacket );

                break;
            }

            // otherwise, handle like an other packet.
        }
    case ENET_TYPE_IP:
        {
            CIpHdr *pIPHdr = pPacket->GetIPHdr();

            // we only want UDP traffic... toss the rest away.
            if ( pIPHdr->_bProtocol == IPPROTO_UDP )
            {
                // alrighty... we like this guy... let's get him into our buffer and post to the completion port
                hr = pXds->QueuePacket( pPacket );
                if ( FAILED(hr) )
                {
                    XomNtEvent( XEVENT_XDS_CODE_22, "PacketRecvComplete:  Failed to save packet.  0x%X", hr );
                    XomTrace( NicMgr, L_ERROR, "PacketRecvComplete:  Failed to save packet.  0x%X", hr );
                    goto Exit;
                }
            }
            else if( pIPHdr->_bProtocol == IPPROTO_ICMP )
            {
                if(dwEtherHdrType != ETHERNET_HEADER_TYPE_NORMAL)
                {
                    XomNtEvent( XEVENT_XDS_HACK_0, "ProcessPacket: no support for ICMP with IEEE ethernet header");
                    goto Exit;
                }
                RecvIcmp(pnmNode, pPacket);
            }
        }
        break;
    default:
        {
            // TODO:  (lohab) Do I want to log this?
            XomTrace( NicMgr, L_ERROR, "PacketRecvComplete:  Received unknown Ethernet hearder type 0x%X.  Is this expected?  Please investivate.", pEnetHdr->_wType );
        }
    }

Exit:
    
    return;
}

// RecvIcmp
// Process and reply to ICMP echo (ping)
void CNicMgr::RecvIcmp(NicMgrNode* pnmNode, PacketNode* pPacket)
{
    CEnetHdr *   pEnetHdr       = (CEnetHdr*) pPacket->m_Data;
    CIpHdr *     pIpHdr         = (CIpHdr*)   (pEnetHdr + 1);
    CIcmpHdr *   pIcmpHdr       = (CIcmpHdr*) (pIpHdr + 1);
    UINT         cb             = pPacket->m_cData;
    UINT         cbIcmp;
    CEnetAddr    eaT;
    CIpAddr      ipaT;
    
    if (cb < sizeof(CEnetHdr) + sizeof(CIpHdr) + sizeof(CIcmpHdr))
    {
        XomNtEvent( XEVENT_XDS_HACK_1, "RecvIcmp: packet is too smal to be an Icmp packet");
        return;
    }

    cbIcmp = cb - sizeof(CEnetHdr) - sizeof(CIpHdr);

    if (tcpipxsum(0, pIcmpHdr, cbIcmp) != 0xFFFF)
    {
        XomNtEvent( XEVENT_XDS_HACK_2, "RecvIcmp: packet checksum failed");
        return;
    }

    if (pIcmpHdr->_bType != ICMPTYPE_ECHO_REQUEST)
    {
        XomNtEvent( XEVENT_XDS_HACK_3, "RecvIcmp: No support for ICMP <%u/%u>", pIcmpHdr->_bType, pIcmpHdr->_bCode);
        return;
    }

    // Reverse the ethernet addresses
    eaT                  = pEnetHdr->_eaSrc;
    pEnetHdr->_eaSrc     = pEnetHdr->_eaDst;
    pEnetHdr->_eaDst     = eaT;

    // Reverse the IP addresses and recompute the checksum
    ipaT                 = pIpHdr->_ipaSrc;
    pIpHdr->_ipaSrc      = pIpHdr->_ipaDst;
    pIpHdr->_ipaDst      = ipaT;
    pIpHdr->_wChecksum   = 0;
    pIpHdr->_wChecksum   = (WORD)~tcpipxsum(0, pIpHdr, sizeof(CIpHdr));

    // Change the type to ICMPTYPE_ECHO_REPLY and recompute the checksum
    pIcmpHdr->_bType     = ICMPTYPE_ECHO_REPLY;
    pIcmpHdr->_wChecksum = 0;
    pIcmpHdr->_wChecksum = (WORD)~tcpipxsum(0, pIcmpHdr, cbIcmp);

    // Transmit the reply on the same transport as it was received
    Transmit(pnmNode->_dwId, pPacket->m_Data, pPacket->m_cData);

    return;
}    

// ---------------------------------------------------------------------------------------
// CNicMgr::XmitOverlappedAlloc
//
// Allocate a new XDS_OVERLAPPED structure from the lookaside list. This allows 
// simultaneous pending xmits.
// 
// Returns: new XDS_OVERLAPPED ready for immediate use, or NULL if unable to allocate 
// memory.
// ---------------------------------------------------------------------------------------
NicMgrNode::XDS_OVERLAPPED* CNicMgr::XmitOverlappedAlloc(NicMgrNode *pnmNode)
{
    NicMgrNode::XDS_OVERLAPPED *pOverlapped;

    // This check will limit the number of outstanding overlappeds we will allocate.  
    // Without it, we are only limited by available memory.
    if (m_cOverlappedsAllocated >= NICMGR_XMIT_MAX_PARALLELIO)
    {
        return NULL;
    }

    pOverlapped = (NicMgrNode::XDS_OVERLAPPED*)m_overlappedLookAside.Alloc();
    if (pOverlapped)
    {
        pOverlapped->Reset();
        pOverlapped->_ioType = NicMgrNode::IO_XMIT;
        pOverlapped->_pNicMgrNode = pnmNode;
        InterlockedIncrement((LONG*)&m_cOverlappedsAllocated);
    }
    return pOverlapped;
}

// ---------------------------------------------------------------------------------------
// CNicMgr::OverlappedFree
//
// Return item to lookaside list. May end up freeing the memory if too many packets 
// stored.
// ---------------------------------------------------------------------------------------
void CNicMgr::OverlappedFree(NicMgrNode::XDS_OVERLAPPED *pOverlapped)
{
    XOMASSERT(pOverlapped);
    m_overlappedLookAside.Free(pOverlapped);
    InterlockedDecrement((LONG*)&m_cOverlappedsAllocated);
}

//-----------------------------------------------------------------------------
//  Local Function implementation
//-----------------------------------------------------------------------------

char * CEnetAddr::Str() const
{
    STATIC_BUFFER(CEnetAddrStr, 32, 18);
    _snprintf(pch, cch, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\NicMgr.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: NicMgr.h
//
//  Interface NicMgr wrapper Implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <XAlloc.h>
#include "netstructs.h"
#include "xlocks.h"
#include "xdsmain.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const int NICMGR_RECV_BUFFER_LEN = 10240;               // Size of recv buffer (multiple packets can be recv'd at one

const int NICMGR_XMIT_MAX_PARALLELIO = 10000;

//-----------------------------------------------------------------------------
// Pre-declarations
//-----------------------------------------------------------------------------
class CServerSocket;

//-----------------------------------------------------------------------------
// Structs/Types
//-----------------------------------------------------------------------------
   
struct NicMgrNode
{
    // Type of IO operation 
    enum IO_TYPE
    {
        IO_RECV = 1,
        IO_XMIT = 2
    };

    DECLSPEC_ALIGN(16) struct XDS_OVERLAPPED
    {
        CListEntry      leLookAside;    // list-entry lookaside free list
        OVERLAPPED      _o;
        IO_TYPE         _ioType;
        NicMgrNode*     _pNicMgrNode;
        BYTE            _buffer[NICMGR_RECV_BUFFER_LEN];

        // Reset _overlapped field without touching the event 
        void Reset()
        {
            // Clears everything, even the event
            ZeroMemory(&_o, sizeof(_o));
        }
    };

    XDS_OVERLAPPED      _recvOverlapped;

    DWORD               _dwId;
    HANDLE              _hRawNic;
    DWORD               _dwIP;    
    CEnetAddr           _eaReal;
    CEnetAddr           _eaVirtual;
    DWORD               _dwDefaultGatewayIP;
    CEnetAddr           _eaDefaultGatewayEnetAddr;        
    DWORD               _dwPort;

    DWORD               _dwPollTime;                    // poll time in seconds to fire ARP requests.
    DWORD               _dwRetryInterval;               // retry sending arp requests till we get a response.
    DWORD               _dwRetryEventThrottle;          // number of ARP/Recv retries till event fires.

    // ARP thread variables.
    HANDLE              _hARPThread;                    // handle to the ARP thread
    HANDLE              _hARPThreadWakeUp;              // waiting event for ARP activity
    HANDLE              _hARPThreadReponseWait;         // waiting event for ARP replies
    BOOL                _bEndARPThread;                 // ARP thread life indicator
    DWORD               _dwARPThreadId;                 // id of the ARP thread
    CRITICAL_SECTION    _csGatewayEnetAddr;             // critical section to protect enet addr

    // receiver retry thread
    HANDLE              _hRecvThread;                   // handle to the Receiver retry thread
    HANDLE              _hRecvRetry;                    // waiting event for the receiver retry
    BOOL                _bEndRecvThread;                // ARP thread life indicator
    DWORD               _dwRetryWait;                   // amount of time to wait before retry.
    DWORD               _dwRecvThreadId;                // id of the ARP thread
};

//-----------------------------------------------------------------------------
// CNicMgr
//-----------------------------------------------------------------------------

DECLSPEC_ALIGN(16) class CNicMgr
{
public:
    static void *       operator new(size_t size);
    static void         operator delete(void *p, size_t size);

    static CNicMgr*     GetInstance();    
    static void         ReleaseInstance();

    // call before using.
    HRESULT             Initialize( DWORD dwNumOfNics, BOOL bUseArpThread );

    // cleans up implementation.
    HRESULT             Terminate( );

    HRESULT             TerminateThreads();

    // adds NICS for WTNicMgr to attach too.
    HRESULT             Add(    CEnetAddr eaMacAddr, 
                                DWORD dwIP, 
                                DWORD dwDefaultGatewayIP,
                                DWORD dwPollTimeInMilliSecs, 
                                DWORD dwRetryIntervalInMilliSecs, 
                                DWORD dwRetryEventPerRequest,
                                DWORD dwPort,
                                DWORD *pdwId );

    HRESULT             ModifyPollTime( DWORD dwId, DWORD dwPollTimeInMilliSecs );
    HRESULT             ModifyRetryInterval( DWORD dwId, DWORD dwRetryIntervalInMilliSecs );
    HRESULT             ModifyEventThrottle( DWORD dwId, DWORD dwRetryEventPerRequest );

    HRESULT             ManageARP( PacketNode* pPacket );
    BOOL                IsPacketForMe( PacketNode* pPacket );

    HRESULT             Transmit( DWORD dwNicId, BYTE *pPacket, DWORD cPacket );
    
    DWORD               GetNumOfNics() { return m_cNicsCreated; }

    DWORD               GetIpAddr( DWORD dwNicId ) { return m_pAttachList[dwNicId]._dwIP; }

    // wake up the ARP thread.
    HRESULT             SignalARPLookup( DWORD dwNicId );

    HRESULT             GetDefaultGatewayEnetAddr( DWORD dwNicId, OUT CEnetAddr *pDefaultGatewayEnetAddrBuffer );

    // lock functions
    void                ReaderLock() { m_rwlAttachList.ReadLock(); }
    void                ReaderUnlock() { m_rwlAttachList.ReadUnlock(); }
    
    // process packets 
    void                ProcessPacket(NicMgrNode* pnmNode, PacketNode* pPacket);

    // Overlapped structure management

    NicMgrNode::XDS_OVERLAPPED* XmitOverlappedAlloc( NicMgrNode *pnmNode );
    void                        OverlappedFree( NicMgrNode::XDS_OVERLAPPED *overlapped );

protected:
    CNicMgr( );
    virtual ~CNicMgr(void);

    void                WriterLock() { m_rwlAttachList.WriteLock(); }
    void                WriterUnlock() { m_rwlAttachList.WriteUnlock(); }

    // Arp thread methods
    static DWORD WINAPI ARPThread( LPVOID pThis );
    HRESULT             InitializeARPThread( DWORD dwId );
    void                ARPThreadInternal( DWORD dwId );
    void                TerminateARPThread( DWORD dwId );
    HRESULT             ARPReceived( DWORD dwId, CEnetAddr* peaDefaultGateway );

    // receiver thread.
    static DWORD WINAPI RecvThread( LPVOID pId );
    void                RecvThreadInternal( DWORD dwId );
    HRESULT             InitializeRecvThread( DWORD dwId );
    void                TerminateRecvThread( DWORD dwId );

    void                GenerateVirtualNicEthernetAddress( IN CEnetAddr eaReal, IN DWORD dwId, OUT CEnetAddr *peaVirtual );
    HRESULT             AttachNic( NicMgrNode* pnmNode );
    HRESULT             DetachNic( NicMgrNode* pnmNode );
    HRESULT             RecvPacket( NicMgrNode* pnmNode );
    void                RecvIcmp(NicMgrNode* pnmNode, PacketNode* pPacket);

    CReaderWriterLock3  m_rwlAttachList;
    NicMgrNode*         m_pAttachList;
    
    DWORD               m_cNicsCreated;

    CXdsMain*           m_pXds;                         // keep an instance of the main app for mem alloc purposes.

    BOOL                m_bUseArpThread;
    
    // Overlapped structure management

    DECLSPEC_ALIGN(16) CLookAsideList m_overlappedLookAside;
    volatile UINT32             m_cOverlappedsAllocated;

private:
    static CNicMgr*     m_pInstance;
    static DWORD        m_dwRefCount;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\snpool.h ===
#ifndef _SN_POOL_H_
#define _SN_POOL_H_

#include <windows.h>
#include <stddef.h>
#include <XAlloc.h>

// Nice macros to use snpool to override new and delete of an object

#define SN_DECLARE_POOL(parent,maxinstances) \
    public: \
    static CSNPool s___Pool; \
    \
    PVOID operator new( size_t cSize ) \
    { return (PVOID) s___Pool.Alloc(); } \
    \
    void operator delete( PVOID pObj ) \
    { s___Pool.Free(pObj); }


#define SN_DEFINE_POOL(parent) \
    CSNPool parent::s___Pool(sizeof(parent)); 


/******************************************************************************

  CSNPool

  Fixed size memory block cache. Specify the buffer size to the constructor.
  Allocate new memory blocks with Alloc and release them using Free.  Limited 
  number of nodes.
  
******************************************************************************/

class CSNPool
{
public:
    
    CSNPool()
    {
        m_cbBufferSize = 0;
        m_cbNumOfNodes = 0;

        m_pMemBuffer = NULL;
        m_DummyNode.pNext = NULL;
                
        m_ptrHead.p.pPtr = &m_DummyNode;
        m_ptrHead.p.dwCount = 0;
    }

    ~CSNPool()
    {
        XFree( m_pMemBuffer );
    }

    HRESULT Init( DWORD cbBufferSize, DWORD cbNumOfNodes )
    {
        HRESULT hr = S_OK;
        node_t *pArrView = NULL;

        // ensure no prior init.        
        ASSERT( m_pMemBuffer == NULL );

        // set attributes
        m_cbBufferSize = cbBufferSize;
        m_cbNumOfNodes = cbNumOfNodes;

        // allocate the block of memory
        m_pMemBuffer = (void *)XAlloc( (sizeof(node_t) + cbBufferSize)* cbNumOfNodes );
        if ( m_pMemBuffer == NULL )
        {
            return E_OUTOFMEMORY;
        }
        ZeroMemory( m_pMemBuffer, (sizeof(node_t) + cbBufferSize)* cbNumOfNodes );

        // put all the memory into the stack.
        for ( DWORD dwX = 0; dwX < cbNumOfNodes; dwX++ )
        {
            Free( (void*)( ( (BYTE*)m_pMemBuffer + ( (sizeof(node_t) + cbBufferSize) * dwX ) ) + offsetof(node_t, rgBuffer)));            
        }
        
        return hr;
    }
    
    void* Alloc()
    {
        void* pBuf = NULL;
        node_t* pNode = NULL;

        ASSERT( m_pMemBuffer != NULL );

        if ( m_pMemBuffer == NULL ) 
        {
            return pBuf;
        }

        // try to pop a buffer from the pool
        
        pNode = pop();

        if(pNode != NULL)
        {            
            // pop or malloc succeeded, return the buffer
            
            pBuf = (void*) pNode->rgBuffer;
        }

        return pBuf;
    }

    void Free(void* pBuffer)
    {
        
        // param check
        
        if(pBuffer != NULL)
        {
            
            // adjust pointer to node_t

            node_t* pNode = (node_t*) (((BYTE*)pBuffer) - offsetof(node_t, rgBuffer));
    
            // put the buffer in the pool.
            
            push(pNode);
        }
    }

protected:

    struct node_t;
    union pointer_t;

    void push(node_t* pNode)
    {
        for(;;)
        {
            
            // Collect the current Head pointer for the consistency check.
            
            pointer_t ptrHead = m_ptrHead;

            // The new node points to the current head.
            
            pNode->pNext = ptrHead.p.pPtr;

            // Insert node by swapping the Head pointer by the new node pointer, but only if
            // the head pointer is still the same pointer as it was at the beginning of the 
            // operation. To avoid the problems that come with memory reutilization, we're 
            // going to use a counter attached to the pointer and we'll increment it every 
            // time we change it.
            
            if(ptrHead.i64 == InterlockedCompareExchange64(&m_ptrHead.i64, MakePointer(pNode, m_ptrHead.p.dwCount + 1), ptrHead.i64))
            {
                
                // Node successfully inserted
                
                break;
            }
        }
    }

    node_t* pop()
    {
        node_t* pR = NULL;

        for(;;)
        {
            
            // Collect the current Head pointer for the consistency check.
            
            pointer_t ptrHead = m_ptrHead;

            // Check if Head is not pointing to the DummyNode (which indicates the end
            // of the stack)
            
            if(ptrHead.p.pPtr != &m_DummyNode)
            {
                
                // Try to remove the current Head and replace it by the next link
                // using the same consistency checking as 'push'.
                
                if(ptrHead.i64 == (InterlockedCompareExchange64(&m_ptrHead.i64, 
                    MakePointer(ptrHead.p.pPtr->pNext, ptrHead.p.dwCount + 1), ptrHead.i64)))
                {
                    
                    // Success. The pointer to the dettached node lies in ptrHead.
                    
                    pR = ptrHead.p.pPtr;
                    break;
                }
            }
            else
            {
                
                // stack is empty

                break;
            }
        }

        return pR;
    }

    __int64 MakePointer(
        node_t* pNode,
        DWORD dwCount
    )
    {
        pointer_t ptrNewPointer;
        ptrNewPointer.p.pPtr = pNode;
        ptrNewPointer.p.dwCount = dwCount;
        return ptrNewPointer.i64;
    }

    // Special pointer structure with a counter
    
    union pointer_t
    {
        __int64 i64;

        struct {
            node_t* pPtr;
            DWORD dwCount;
        } p;
    };

    // node structure
    
    struct node_t
    {
        node_t* pNext;
        unsigned char rgBuffer[1];
    };

    // Pointer to the stack    
    pointer_t m_ptrHead;

    // Dummy Node. It will indicate the end of the stack
    node_t m_DummyNode;

    // size of node.    
    DWORD m_cbBufferSize;

    // master memory block
    void *m_pMemBuffer;

    // number of nodes in pool.
    DWORD m_cbNumOfNodes;
    
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// NetworkReader.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once
#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>

#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <wsockntp.h>
#include <Iphlpapi.h>

#include <xonlinep.h>
#include <winsock2.h>
#include <xmgmt.h>
#include <xeventids.h>

#include <xlocks.h>
#include <xalloc.h>

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
#include <commonconfig.h>

#ifndef ASSERT
#define ASSERT XOMASSERT
#endif

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x)/sizeof(x[0]))
#endif

using namespace xlocks;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\XdsCache.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsCache.cpp
//
//  Implementation for the Xds memory cache.
//-----------------------------------------------------------------------------

//--------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------
#include "StdAfx.h"

#include "XdsMain.h"
#include "NetStructs.h"

#include "XdsCache.h"


//--------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------

// used for logging and debugging
XomDefineArea(DOS);

//--------------------------------------------------------------------
// CONSTANTS
//--------------------------------------------------------------------
const UINT c_iHashTableOverheadPct = 100;   // percent overhead to add to hash tables
const DWORD c_dwInfractionInterval = 60;    // infractions per # of seconds

//--------------------------------------------------------------------
//  HashTable -- definitions.
//--------------------------------------------------------------------

DECLARE_HASH_TABLE(XdsCache);

DWORD XdsCacheHashCompute( CXdsCacheNode *pCacheNode )
{
    ASSERT( pCacheNode );
    return ( 26821 ^ pCacheNode->_dwIP ^ 250682837  );
}

BOOL XdsCacheHashCompare( CXdsCacheNode *pCNode1, CXdsCacheNode *pCNode2)
{
    ASSERT( pCNode1 );
    ASSERT( pCNode2 );
    return ( pCNode1->_dwIP == pCNode2->_dwIP );
}


//--------------------------------------------------------------------
//  Local Function Declarations
//--------------------------------------------------------------------
DWORD GetCurrentTimeInSeconds();

//--------------------------------------------------------------------
// Class:  CHashTable
//--------------------------------------------------------------------

//--------------------------------------------------------------------
// Class:  CHashTable
//--------------------------------------------------------------------
BOOL CHashTable::Init(UINT cEnt, PFNHCOMPUTE pfnCompute, PFNHCOMPARE pfnCompare)
{
    // Base the number of buckets we allocate on the maximum number of entries, scaled
    // up by a constant factor and then rounded up to the next highest prime number.
    // The idea is to keep hash collisions to a minimum at the cost of additional memory.

    UINT cBucket = cEnt * (100 + c_iHashTableOverheadPct) / 100;

    static DWORD s_adwPrimes[] = { 37,59,89,139,227,359,577,929,1499,2423,3919,6337,10253,16573,
        26821,43391,70207,113591,183797,297377,481171,778541,1259701,2038217,3297913,5336129,
        8633983,13970093,22604069,36574151,59178199,95752333,154930511,250682837,405613333,
        656296153,1061909479,1718205583,2780115059,0xFFFFFFFF};

    DWORD * pdwPrime = s_adwPrimes;
    for (; cBucket > *pdwPrime; pdwPrime++) ;
    cBucket = *pdwPrime;

    _ple = new LIST_ENTRY[cBucket];

    if (_ple == NULL)
    {
        return(FALSE);
    }

    ZeroMemory(_ple, cBucket * sizeof(LIST_ENTRY));
    
    _cBucket    = cBucket;
    _cEnt       = 0;
    _pfnCompute = pfnCompute;
    _pfnCompare = pfnCompare;

    for (LIST_ENTRY * ple = _ple; cBucket > 0; --cBucket, ++ple)
    {
        InitializeListHead(ple);
    }

    return(TRUE);
}

//--------------------------------------------------------------------
// CHashTable::Term
//--------------------------------------------------------------------
void CHashTable::Term()
{
    delete _ple;
    _ple = NULL;
}

//--------------------------------------------------------------------
// CHashTable::Lookup
//--------------------------------------------------------------------
LIST_ENTRY * CHashTable::Lookup(LIST_ENTRY * pleLok)
{
    LIST_ENTRY * pleHead = &_ple[_pfnCompute(pleLok) % _cBucket];
    
    for (LIST_ENTRY * ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        if (_pfnCompare(pleLok, ple))
        {
            return(ple);
        }
    }

    return(NULL);
}

//--------------------------------------------------------------------
// CHashTable::Insert
//--------------------------------------------------------------------
void CHashTable::Insert(LIST_ENTRY * pleIns)
{
    ASSERT( NULL == pleIns->Flink );
    LIST_ENTRY * pleHead = &_ple[_pfnCompute(pleIns) % _cBucket];
    InsertTailList(pleHead, pleIns);
    _cEnt += 1;
}

//--------------------------------------------------------------------
// CHashTable::Delete
//--------------------------------------------------------------------
void CHashTable::Delete(LIST_ENTRY * pleDel)
{
    ASSERT( pleDel->Flink );
    ASSERT( pleDel == Lookup(pleDel) );
    RemoveEntryList(pleDel);
    pleDel->Flink = NULL;

    ASSERT(_cEnt > 0);
    _cEnt -= 1;
}


//--------------------------------------------------------------------
// Class:  CXdsCache
//--------------------------------------------------------------------

CXdsCache::CXdsCache( )
{
    m_pMCHash       = NULL; 
    m_pMCList       = NULL; 
    m_cCacheSize    = 0;    
    ZeroMemory( &m_leMCLru, sizeof( m_leMCLru ) ); 
    m_cEntryLifeTime = 0;
}

CXdsCache::~CXdsCache()
{
    // if the hash still exists... call terminate.
    if ( m_pMCHash ) 
    {
        Term();
    }
}

//--------------------------------------------------------------------
// Init: Initialize the cache 
//--------------------------------------------------------------------
HRESULT CXdsCache::Init( DWORD dwEntryLifeInSeconds, DWORD cCacheSize, DWORD cHashSize, DWORD dwAcceptableInfactionLimit )
{
    HRESULT hr = S_OK;
    
    // save the entry life time.
    m_cEntryLifeTime = dwEntryLifeInSeconds;

    // save the cache size
    m_cCacheSize = cCacheSize;

    // save the hash size
    m_cHashSize = cHashSize;

    // save the infraction limit.
    m_cInfractionLimit = dwAcceptableInfactionLimit;

    InitializeListHead( &m_leMCLru );

    m_rwMCListLock.WriteLock();
    
    // allocate and zero-fill the cache nodes
    m_pMCList = new CXdsCacheNode[cCacheSize];
    if ( NULL == m_pMCList )
    {
        XomNtEvent(XEVENT_XDS_CODE_25, "CXdsCache::Init(): failed to allocate %d bytes for Cache Nodes entries.", cCacheSize*sizeof(CXdsCacheNode));
        hr = E_FAIL;
        goto Exit;
    }
    ZeroMemory(m_pMCList, cCacheSize * sizeof(CXdsCacheNode));

    // initialize the list.
    for ( DWORD dwX = 0; dwX < cCacheSize; dwX ++ )
    {
        m_pMCList[dwX]._dwFirstAccess  = 0;
        m_pMCList[dwX]._dwIP = 0;
        m_pMCList[dwX]._hash.Blink = m_pMCList[dwX]._hash.Flink = NULL;
        InsertHeadList( &m_leMCLru, &(m_pMCList[dwX]._lru) );
    }

    // create the hash table.
    m_pMCHash = new CXdsCacheHash;
    if ( NULL == m_pMCHash || !m_pMCHash->Init(cHashSize) )
    {
        XomNtEvent(XEVENT_XDS_CODE_26, "CXdsCache::Init(): failed to allocate hash table.");
        hr = E_FAIL;
        goto Exit;
    }

    XomTrace(DOS, L_NORMAL, "CXdsCache::Init(): configured cache hash table with %d entries in %d hash buckets.", cHashSize, m_pMCHash->GetBucketCount());

Exit:

    m_rwMCListLock.WriteUnlock();

    return hr;

}

//--------------------------------------------------------------------
// ReInit: re-initialize the cache -- blow away evrythign and start 
//      over.  Use the old setting though...
//--------------------------------------------------------------------
HRESULT CXdsCache::ReInit()
{
    return ReInit( m_cEntryLifeTime, m_cCacheSize, m_cHashSize , m_cInfractionLimit );
}

//--------------------------------------------------------------------
// ReInit: re-initialize the cache -- blow away evrythign and start 
//      over.
//--------------------------------------------------------------------
HRESULT CXdsCache::ReInit( DWORD dwEntryLifeInSeconds, DWORD cCacheSize, DWORD cHashSize, DWORD dwAcceptableInfactionLimit )
{
    HRESULT hr = S_OK;
    
    // save the entry life time.
    m_cEntryLifeTime = dwEntryLifeInSeconds;

    // save the cache size
    m_cCacheSize = cCacheSize;

    // save the hash size
    m_cHashSize = cHashSize;

    // save the infraction limit.
    m_cInfractionLimit = dwAcceptableInfactionLimit;
    
    InitializeListHead( &m_leMCLru );

    m_rwMCListLock.WriteLock();

    delete m_pMCHash; 
    delete m_pMCList;

    m_pMCHash = NULL;
    m_pMCList = NULL;
    
    // allocate and zero-fill the cache nodes
    m_pMCList = new CXdsCacheNode[cCacheSize];
    if ( NULL == m_pMCList )
    {
        XomNtEvent(XEVENT_XDS_CODE_27, "CXdsCache::Init(): failed to allocate %d bytes for Cache Nodes entries.", cCacheSize*sizeof(CXdsCacheNode));
        hr = E_FAIL;
        goto Exit;
    }
    ZeroMemory(m_pMCList, cCacheSize * sizeof(CXdsCacheNode));

    // initialize the list.
    for ( DWORD dwX = 0; dwX < cCacheSize; dwX ++ )
    {
        m_pMCList[dwX]._dwFirstAccess  = 0;
        m_pMCList[dwX]._dwIP = 0;
        m_pMCList[dwX]._hash.Blink = m_pMCList[dwX]._hash.Flink = NULL;
        InsertHeadList( &m_leMCLru, &(m_pMCList[dwX]._lru) );
    }

    // create the hash table.
    m_pMCHash = new CXdsCacheHash;
    if ( NULL == m_pMCHash || !m_pMCHash->Init(cHashSize) )
    {
        XomNtEvent(XEVENT_XDS_CODE_28, "CXdsCache::Init(): failed to allocate hash table.");
        hr = E_FAIL;
        goto Exit;
    }

    XomTrace(DOS, L_NORMAL, "CXdsCache::Init(): configured cache hash table with %d entries in %d hash buckets.", cHashSize, m_pMCHash->GetBucketCount());

Exit:

    m_rwMCListLock.WriteUnlock();

    return hr;

}


//--------------------------------------------------------------------
// Term:  terminate the cache
//--------------------------------------------------------------------
void CXdsCache::Term()
{
    m_rwMCListLock.WriteLock();
    delete m_pMCHash; 
    delete m_pMCList;

    m_pMCHash = NULL;
    m_pMCList = NULL;

    m_rwMCListLock.WriteUnlock();

    m_cCacheSize = 0;    
    ZeroMemory( &m_leMCLru, sizeof( m_leMCLru ) ); 
    m_cEntryLifeTime = 0;
    
}
    
//--------------------------------------------------------------------
// Add:  Add this key to the cache list.
//--------------------------------------------------------------------
HRESULT CXdsCache::Add( DWORD dwIP )
{
    HRESULT hr = S_OK;
    CXdsCacheNode *pNewNode = NULL;
    CXdsCacheNode mcDummy = {0};
    
    m_rwMCListLock.WriteLock();

    // ensure we have objects.
    if ( m_pMCList == NULL )
    {
        // no lists... so just let it do the regular path.
        hr = S_OK;
        goto Exit;
    }

    // see if this entry already exists... if it does... just update it.
    mcDummy._dwIP = dwIP;
    pNewNode = m_pMCHash->Lookup( &mcDummy );
    if ( pNewNode == NULL )
    {
        // get the last entry in the list.
        LIST_ENTRY* ple = RemoveTailList( &m_leMCLru );
        pNewNode = CONTAINING_RECORD( ple, CXdsCacheNode, _lru );
        ASSERT( pNewNode != NULL );
    
        if ( pNewNode->_hash.Blink != NULL )
        {
            m_pMCHash->Delete( pNewNode );
        }        

        // set the key
        pNewNode->_dwIP = dwIP;
        pNewNode->_dwInfractions = pNewNode->_dwFirstAccess = GetCurrentTimeInSeconds();
        pNewNode->_dwFirstAccess = 0;

        // insert in the hash table.
        m_pMCHash->Insert( pNewNode );
    }

    // setup the new node.
    pNewNode->_dwInfractions++;
    if ( pNewNode->_dwInfractions > m_cInfractionLimit &&
        pNewNode->_dwFirstAccess < GetCurrentTimeInSeconds() + c_dwInfractionInterval ) 
    {
        pNewNode->_dwFirstAccess = GetCurrentTimeInSeconds();
        pNewNode->_dwInfractions = 0;
    }

    // insert in the front of the lru list.
    InsertHeadList( &m_leMCLru, &(pNewNode->_lru) );

Exit:
    
    // put the node at the front of the list.
    m_rwMCListLock.WriteUnlock();

    pNewNode = NULL;

    return hr;
    
}
    
//--------------------------------------------------------------------
// Find:  Lookup the key in the cache list.
//--------------------------------------------------------------------
BOOL CXdsCache::Find( DWORD dwIP )
{
    CXdsCacheNode *pNewNode = NULL;
    CXdsCacheNode mcItem = {0};
    BOOL bRes = TRUE;
    DWORD dwTimeDiff = 0;
    DWORD dwCurrentTimeInSecs = 0;
    
    m_rwMCListLock.ReadLock();

    // ensure we have objects.
    if ( m_pMCList == NULL )
    {
        // no lists... so just let it do the regular path.
        bRes = FALSE;
        goto Exit;
    }
    
    // look for the entry
    mcItem._dwIP = dwIP;
    pNewNode = m_pMCHash->Lookup( &mcItem );
    if ( pNewNode == NULL )
    {
        // doesn't exist... return false.
        bRes = FALSE;
        goto Exit;
    }

    // check the time... 
    dwCurrentTimeInSecs = GetCurrentTimeInSeconds();
    dwTimeDiff = dwCurrentTimeInSecs - pNewNode->_dwFirstAccess;

    // see if the difference is greater than the interval.
    if ( m_cEntryLifeTime < dwTimeDiff || ( pNewNode->_dwInfractions != 0 ) )
    {
        bRes = FALSE;
        goto Exit;
    }

Exit:    
    m_rwMCListLock.ReadUnlock();

    return bRes;
}

//--------------------------------------------------------------------
// Remove:  remove the entry from teh cache list.
//--------------------------------------------------------------------
BOOL CXdsCache::Remove( DWORD dwIP )
{
    CXdsCacheNode *pNewNode = NULL;
    CXdsCacheNode mcItem = {0};
    BOOL bRes = TRUE;
    DWORD dwTimeDiff = 0;
    DWORD dwCurrentTimeInSecs = 0;
    
    m_rwMCListLock.WriteLock();

    // ensure we have objects.
    if ( m_pMCList == NULL )
    {
        // no lists... so just let it do the regular path.
        bRes = FALSE;
        goto Exit;
    }
    
    // look for the entry
    mcItem._dwIP = dwIP;
    pNewNode = m_pMCHash->Lookup( &mcItem );
    if ( pNewNode == NULL )
    {
        // doesn't exist... return false.
        bRes = FALSE;
        goto Exit;
    }

    // check the time... 
    pNewNode->_dwFirstAccess = 0;
    pNewNode->_dwInfractions = 1;

Exit:    
    m_rwMCListLock.WriteUnlock();

    return bRes;
}
    
//--------------------------------------------------------------------
//  Local Functions
//--------------------------------------------------------------------

DWORD GetCurrentTimeInSeconds()
{
    time_t curtime = {0};
    curtime = time( &curtime );
    return (DWORD)curtime;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\XdsAction.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsAction.h
//
//  Interface XdsAction Implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <Compport.h>

//-----------------------------------------------------------------------------
// Class Pre-Declaration
//-----------------------------------------------------------------------------
class CXdsMain;

    
//-----------------------------------------------------------------------------
// CXdsAction:  Nodes managed by the completion port to handle xds
//      business.
//-----------------------------------------------------------------------------
class CXdsAction     : public LIST_ENTRY,
                      public CCompletionContext, 
                      public CCompletionHandler
                   
{
public:
    enum ActionType
    {
        NONE = 0,
        PACKET = 1,
        TERMINATE = 2
    };
    
    CXdsAction( CXdsMain *pXds ) : 
        m_pXds(pXds)
    {
        Flink = (NULL);
        Blink = (NULL);
    }

    virtual void Clean()
    {
        m_nAction = NONE;
        m_pData   = NULL;
    }

    virtual ULONG AddRef() { return 0; }

    virtual ULONG Release() { return 0; }

    
    virtual void Setup( ActionType act, LPBYTE pData )
        {
            m_nAction = act;
            m_pData   = pData;
        }
    
    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void OnIoCompletion( 
        DWORD dwError, 
        DWORD cbTransferred, 
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx );

protected:
    CXdsMain*   m_pXds;
    LPBYTE      m_pData;
    ActionType  m_nAction;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\xds.cpp ===
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm).
//
//  xds.cpp : Defines the entry point for the XDS nt service application.
//

//-----------------------------------------------------------------------------
//  Includes
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "cryptohelper.h"
#include <windows.h>

#include "XDSMain.h"

//-----------------------------------------------------------------------------
//  Local Functions
//-----------------------------------------------------------------------------
void BinToHex( char *szString, DWORD dwStringSize, char **szHexString );
void HexToBin( char *szHexString, DWORD dwStringSize, BYTE **ppBinData );
BOOL StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutess, DWORD *pdwSeconds );

//-----------------------------------------------------------------------------
//  GLOBAL VARIABLES
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  CONSTANTS
//-----------------------------------------------------------------------------

void logtofile2(char* file, char* fmt, ...)
{

	va_list argptr;

	char buffer[512];
	va_start(argptr, fmt);
	
	vsprintf(buffer, fmt, argptr);

	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" ); 
	fprintf( Log2, buffer);  
	fclose( Log2 ); 
}

//-----------------------------------------------------------------------------
//  IMPLEMENTATION
//-----------------------------------------------------------------------------

int __cdecl wmain(int argc, WCHAR* argv[])
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    CXdsMain* pXds = NULL;
    int nResult = 0;
	
	SC_HANDLE hServiceControl;
	
	if (argc > 1)
	{
		if (wcscmp(argv[1], L"install") == 0)
		{
			hServiceControl = OpenSCManager(0, 0, SC_MANAGER_CREATE_SERVICE);

			if (!hServiceControl)
			{
				return 1;
			}

			TCHAR strPath[MAX_PATH];
			if (GetModuleFileName(NULL, strPath, MAX_PATH) > 0)
			{
				SC_HANDLE hService = CreateService(
					hServiceControl,
					"XDK", "XDK",
					SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
					SERVICE_AUTO_START, SERVICE_ERROR_IGNORE, strPath,
					0, 0, 0, 0, 0 );

				if (!hService)
				{
					return 1;
				}

				CloseServiceHandle( hService );
			}

			CloseServiceHandle( hServiceControl );

			return 0;
		}
		if (wcscmp(argv[1], L"uninstall") == 0)
		{
			hServiceControl = OpenSCManager(0, 0, SC_MANAGER_CONNECT);

			if (!hServiceControl)
			{
				return 1;
			}

			SC_HANDLE hService = OpenService(hServiceControl, "XDK", SERVICE_QUERY_STATUS | DELETE);

			if (!hService)
			{
				return 1;
			}

			SERVICE_STATUS ServiceStatus;
			if (QueryServiceStatus(hService, &ServiceStatus))
			{
				if (ServiceStatus.dwCurrentState == SERVICE_STOPPED)
					DeleteService(hService);
			}

			CloseServiceHandle(hService);
			CloseServiceHandle(hServiceControl);

			return 0;
		}
		else
		{
			printf("Invalid command\n");
			return 1;
		}

		return 0;
	}
	
    // initialize COM for OLEDB wrapper code
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED(hr) ) {
		printf("XDS: Failed CoInitializeEx.  XDS Failed to start.  Hresult = 0xX\n", hr );
        // error time!!!! --- something bad happened... make note and do what you can.
        XomNtEvent( XEVENT_XDS_CONFIG_0, "XDS: Failed CoInitializeEx.  XDS Failed to start.  Hresult = 0xX", hr );

        nResult = 1;
        goto Exit;
    }

    // attach the debugging information.
    hr = g_xomcentral.Init( "xds" );
    if ( FAILED(hr) )
    {
		printf("Failed to initialize the xom stuff. 0x%X\n", hr);
        XomNtEvent( XEVENT_XDS_CODE_23, "Failed to initialize the xom stuff. 0x%X", hr);
        nResult = 1;
        goto Exit;
    }

    pXds = CXdsMain::GetInstance();

    dwErr = pXds->ProcessMain( (DWORD)argc, argv );
    if ( ERROR_SUCCESS != dwErr ){
		logtofile2("c:\\kdc\\xdk.log","Failed to start properly. 0x%X\n", dwErr);
		printf("Failed to start properly. 0x%X\n", dwErr);
        XomNtEvent( XEVENT_XDS_CODE_24, "Failed to start properly. 0x%X", dwErr);
        nResult = 1;
        goto Exit;
    }

    CXdsMain::ReleaseInstance();

    // terminate the logging and debugging.
    g_xomcentral.Term();

    CoUninitialize();

Exit:    
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\XdsAction.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm).
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsAction.cpp
//
//  Implementation of the action class for completion port access.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"
#include "XdsAction.h"
#include "XdsMain.h"

//-----------------------------------------------------------------------------
//  DEBUG Areas
//-----------------------------------------------------------------------------
XomImportArea(Xds);

//-----------------------------------------------------------------------------
//  CXdsAction Implementation
//-----------------------------------------------------------------------------
void CXdsAction::OnIoCompletion(
                    DWORD dwError,
                    DWORD cbTransferred,
                    ULONG_PTR ulpKey,
                    CCompletionContext *pCtx )
{
    CXdsAction *pAction = NULL;
    HRESULT hr = S_OK;

    // get the action handler.
    pAction  = ( CXdsAction* )pCtx;

    // we're done but someone is still sending us messages... ignore them.
    if ( m_pXds->IsComplete() )
    {
        goto Exit;
    }

    // TODO:  (lohab)  Add more logging here.

    switch (pAction->m_nAction)
    {
        case PACKET:
            {
                m_pXds->ProcessPacket( (PacketNode*)pAction->m_pData );
            }
            break;
        case NONE:
            {
                // ok... what the?
                XomTrace( Xds, L_WARNING, "CXdsAction::OnIoCompletion:  We've received a action to do NOTHING.  Please correct this.");
            }
            break;
        default:
            {
                // why are we here... this isn't valid.
                XOMASSERT( FALSE );
            }
            break;
    };

    m_pXds->ReleaseAction( pAction );

Exit:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\XdsCache.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsCache.h
//
//  Definition of the Xds ip cache.
//-----------------------------------------------------------------------------

#pragma once

//--------------------------------------------------------------------
//  Includes
//--------------------------------------------------------------------
#include <time.h>

#include "xlocks.h"
#include "xalloc.h"

//--------------------------------------------------------------------
//  Definitions
//--------------------------------------------------------------------
#ifndef INLINE
#define INLINE __forceinline
#endif

#define DECLARE_NEW_DELETE(class) \
   INLINE void * operator new(size_t cb) { return(XAlloc(cb)); } \
   INLINE void operator delete(void * pv) { XFree(pv); }

#define DECLARE_HASH_TABLE(_type) \
    DWORD _type##HashCompute(C##_type##Node *); \
    BOOL  _type##HashCompare(C##_type##Node *, C##_type##Node *); \
    class C##_type##Hash : public CHashTable { public: DECLARE_NEW_DELETE(C##_type##Node); \
    INLINE BOOL Init(UINT cEnt) { return(CHashTable::Init(cEnt, (PFNHCOMPUTE)_type##HashCompute, (PFNHCOMPARE)_type##HashCompare)); } \
    INLINE C##_type##Node * Lookup(C##_type##Node * pvEnt) { return((C##_type##Node *)CHashTable::Lookup((LIST_ENTRY *)pvEnt)); } \
    INLINE void  Insert(C##_type##Node * pvEnt) { CHashTable::Insert((LIST_ENTRY *)pvEnt); } \
    INLINE void  Delete(C##_type##Node * pvEnt) { CHashTable::Delete((LIST_ENTRY *)pvEnt); } \
    }; \


//--------------------------------------------------------------------
//  Constants
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  TYPES/STRUCTURES
//--------------------------------------------------------------------
typedef DWORD (*PFNHCOMPUTE)(LIST_ENTRY * ple);
typedef BOOL  (*PFNHCOMPARE)(LIST_ENTRY * ple1, void * ple2);

//--------------------------------------------------------------------
//  Global functions.
//--------------------------------------------------------------------

// This code is a slight variation on dinartem's hash code for
// the security gateways in sgstate.cpp.  Anyone wishing to reuse
// this code should first look at sgstate.cpp.

// ----------------------------------------------------------------------------
// CHashTable
// ----------------------------------------------------------------------------

class CHashTable
{

public:
    
    INLINE          CHashTable() { _ple = NULL; }
    INLINE          ~CHashTable() { Term(); }
    BOOL            Init(UINT cBucket, PFNHCOMPUTE pfnCompute, PFNHCOMPARE pfnCompare);
    void            Term();
    LIST_ENTRY *    Lookup(LIST_ENTRY * pleLok);
    void            Insert(LIST_ENTRY * pleIns);
    void            Delete(LIST_ENTRY * pleDel);
    INLINE UINT     GetCount() const                { return(_cEnt); }
    INLINE UINT     GetBucketCount() const          { return(_cBucket); }

private:

    LIST_ENTRY *    _ple;               // Vector of hash buckets
    UINT            _cBucket;           // Number of buckets in the table
    UINT            _cEnt;              // Number of entries in the table
    PFNHCOMPUTE     _pfnCompute;        // Function to compute a 32-bit hash from an entry
    PFNHCOMPARE     _pfnCompare;        // Function to compare two entries for equality

};

//--------------------------------------------------------------------
//  Cache hash implementation.
//--------------------------------------------------------------------

typedef struct _CXdsCacheNode
{
    LIST_ENTRY      _hash;
    DWORD           _dwIP;
    DWORD           _dwInfractions;
    DWORD           _dwFirstAccess;
    LIST_ENTRY      _lru;
} CXdsCacheNode;

class CXdsCacheHash;

//--------------------------------------------------------------------
//  Class:  CXdsCache
//--------------------------------------------------------------------

class CXdsCache  
{
public:
    CXdsCache();
    virtual ~CXdsCache();

    HRESULT Init( DWORD dwEntryLifeInSeconds, DWORD cCacheSize, DWORD cHashSize, DWORD dwInfractionLimit );

    HRESULT ReInit( DWORD dwEntryLifeInSeconds, DWORD cCacheSize, DWORD cHashSize, DWORD dwInfractionLimit );
    HRESULT ReInit();

    void    Term();
    
    HRESULT Add( DWORD dwIP );
    
    BOOL Find( DWORD dwIP );

    BOOL Remove( DWORD dwIP );
    
protected:

    CXdsCacheHash*              m_pMCHash;          // Hash table mapping PUID to CMachineCache
    CXdsCacheNode*              m_pMCList;          // Vector of all CMachineCache structures
    UINT                        m_cCacheSize;       // Number of CMachineCache structures allocated
    LIST_ENTRY                  m_leMCLru;          // Queue of CMachineCache structures in use in LRU order
    xlocks::CReaderWriterLock3  m_rwMCListLock;     // reader writer lock for list protection.
    UINT                        m_cEntryLifeTime;   // lifetime of nodes.
    UINT                        m_cHashSize;        // size of the hash table.
    UINT                        m_cInfractionLimit; // total number of infractions before blacklisting.

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\xds\server\XdsMain.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) Xbox Diagnostics Server (XDS) (tm).
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: XdsMain.cpp
//
//  Implementation of the main diagnostic server.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"

#include "XdsMain.h"
#include "NetStructs.h"
#include "MgmtInterface.h"
#include "XdsAction.h"
#include "NicMgr.h"
#include "XdsCache.h"
#include "XdsPerfCtrs.h"
#include "XdsPerf.h"

#include <xonlinep.h>

#include <rawnic.h>

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
XomDefineArea(log);
XomDefineArea(Xds);

void logtofile3(char* file, char* fmt, ...)
{

	va_list argptr;

	char buffer[512];
	va_start(argptr, fmt);
	
	vsprintf(buffer, fmt, argptr);

	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" ); 
	fprintf( Log2, "\n"); 
	fprintf( Log2, buffer);  
	fclose( Log2 ); 
}


//-----------------------------------------------------------------------------
//  Static Declarations
//-----------------------------------------------------------------------------
CXdsMain* CXdsMain::m_pInstance = NULL;
DWORD     CXdsMain::m_dwRefCount = 0;

CNTService* g_pService = NULL;

CPERFCounters g_Counters;

//-----------------------------------------------------------------------------
//  Pre-Declarations for local functions
//-----------------------------------------------------------------------------
void    GetXOMSetting( char** pszValue, const char *c_szArea, const char *c_szDefault );
void    GetXOMSetting( DWORD* pdwValue, const char *c_szArea, DWORD c_dwDefault );
DWORD   TranslateAddr( char * sz );
void    XcHMAC( IN PBYTE pbKeyMaterial, IN ULONG cbKeyMaterial, IN PBYTE pbData, IN ULONG cbData, IN PBYTE pbData2, IN ULONG cbData2, OUT PBYTE HmacData);
BOOL    IsPrintable( BYTE *pbArr, DWORD cbArr );
BOOL    IsNumericASCII( BYTE *pbArr, DWORD cbArr );
void    MakePresentableOutput( char *szName, DWORD dwNameSize, char *pszSrc );
void    SetupEthernetHeader( PacketNode* pPacket, BYTE* pBuffer, DWORD cBuffer );


//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
const XomMgmtCmd c_aCmdList[] = {
    { "help",               strlen("help"),                 CMgmtInterface::MgmtCmdHelp,                NULL,   NULL },
    { "QueryIP",            strlen("QueryIP"),              CMgmtInterface::MgmtCmdQueryIP,             NULL,   NULL },
    { "UnBanIP",            strlen("UnBanIP"),              CMgmtInterface::MgmtCmdUnBanIP,             NULL,   NULL },
    { "ForceGatewayLookup", strlen("ForceGatewayLookup"),   CMgmtInterface::MgmtCmdForceGatewayLookup,  NULL,   NULL },
};

const DWORD c_dwNumOfCommands               = ARRAY_ELEMENTS(c_aCmdList);


const DWORD c_dwDefaultPacketBufferSize     = 1000;
const DWORD c_dwDefaultNumOfNics            = 1;
const DWORD c_dwDefaultCacheSize            = 10000;            // 10000 entries as a default cache size.
const DWORD c_dwDefaultCacheLifetime        = 1200;             // 20 minute default lifetime for the cache.
const DWORD c_dwDefaultSkewTime             = 360000;           // 5 minute default skew time.
const DWORD c_dwDefaultNumberofThreads      = 64;               // 64 default threads
const DWORD c_dwDefaultHashTableSize        = 26821;            // 26821 default number of hash table entries.
const DWORD c_dwDefaultPort                 = 3074;
const DWORD c_dwDefaultMaxLogLength         = 64;               // 64 bytes as a default log length maximum.
const DWORD c_dwDefaultMinLogRequestLength  = sizeof( XDS_LOG_REQUEST );
const DWORD c_dwDefaultMinICMPRequestLength = sizeof( XDS_ICMP_REQUEST );
const DWORD c_dwDefaultTOS                  = 0;
const DWORD c_dwDefaultTTL                  = 64;
const DWORD c_dwDefaultInfractionLimit      = 1;
const char  c_szDefaultICMPReplyAddr[]      = "10.10.10.10";    // default ICMP reply address
const DWORD c_dwDefaultGatewayInterval      = 300;              // 5 minutes between ARP lookups
const DWORD c_dwDefaultRetryInterval        = 10;               // retry arp lookups every 10 seconds
const DWORD c_dwDefaultEventThrottle        = 5;                // fire an event every 5 retries.

const DWORD c_dwLatestProtocolVersion       = 1;                // 1 is the current accepted protocol version.


const DWORD c_ShutdownTime                  = 1200000;          // 20 seconds to free memory and shut down.

const WCHAR c_szServiceName[]               = L"XDS";
const WCHAR c_szServiceDisplayName[]        = L"Xbox Diagnostics Service";
const WCHAR c_szServiceDescription[]        = L"Xbox Diagnostics Service";
const WCHAR c_szPerfBaseName[]              = L"XDSPerf";

const char  c_szNumOfNics[]                 = "XDS.NumOfNics";

const char  c_szLocalIP[]                   = "Nic%d.LocalIP";
const char  c_szVLanMACAddr[]               = "Nic%d.VLanMACAddr";
const char  c_szGatewayLookupInterval[]     = "Nic%d.GatewayLookupIntervalInSeconds";
const char  c_szRetryInterval[]             = "Nic%d.ARPRetryIntervalInSeconds";
const char  c_szRetryEventThrottle[]        = "Nic%d.ARPRetryEventThrottle";
const char  c_szDefaultGateway[]            = "Nic%d.DefaultGateway";


//-----------------------------------------------------------------------------
//  CXdsMain Implementation
//-----------------------------------------------------------------------------
CXdsMain::CXdsMain(void) : CNTService( c_szServiceName, c_szServiceDisplayName, c_szServiceDescription, c_szPerfBaseName, Component_xds )
{
    m_pPacketBuffer             = NULL;
    m_bIsComplete               = TRUE;
    m_pMgmtInterface            = NULL;
    m_pNicMgr                   = NULL;
    m_dwCacheSize               = 0;
    m_dwCacheLifetime           = 0;
    m_pCache                    = NULL;
    m_dwInfractionLimit         = 0;
    m_dwGatewayLookupInterval   = 0;
    m_dwARPRetryInterval        = 0;
    m_dwRetryEventThrottle      = 0;
    m_dwSkewTimeInMilliSecs     = 0;
    m_dwMaxLogLength            = 0;
    m_dwMinICMPRequestLength    = 0;
    m_dwMinLogRequestLength     = 0;
}

CXdsMain::~CXdsMain(void)
{
    m_pPacketBuffer = NULL;
    m_bIsComplete = TRUE;
    m_pMgmtInterface = NULL;
    m_pNicMgr = NULL;
    m_pCache = NULL;
    m_dwInfractionLimit = 0;
}

//-----------------------------------------------------------------------------
//  GetInstance:  Gets an instance of the XDS
//-----------------------------------------------------------------------------
CXdsMain* CXdsMain::GetInstance()
{
    if ( m_pInstance == NULL )
    {
        XOMASSERT( m_dwRefCount == 0 );
        m_pInstance = new CXdsMain();
        g_pService = m_pInstance;
        if ( m_pInstance == NULL )
        {
            // not enough memory to create XDS instance.
            XomNtEvent( XEVENT_XDS_CODE_29, "CXdsMain::GetInstance:  Failed to allocate instance memory.  Please ensure machine has enough available RAM to run this program");
            XomTrace( Xds, L_ERROR, "CXdsMain::GetInstance:  Failed to allocate instance memory.  Please ensure machine has enough available RAM to run this program");
            goto Exit;
        }
    }

    InterlockedIncrement( (LPLONG)&(m_dwRefCount) );

Exit:
    return m_pInstance;
}

//-----------------------------------------------------------------------------
//  ReleaseInstance:  Releases the instance of the Xds.
//-----------------------------------------------------------------------------
void CXdsMain::ReleaseInstance()
{
    LONG lValue = 0;
    XOMASSERT( m_dwRefCount > 0 && m_pInstance != NULL );
    lValue = InterlockedDecrement( (LPLONG)&(m_dwRefCount) );
    if ( lValue == 0 )
    {
        delete m_pInstance;
        m_pInstance = NULL;
    }
}

// Install / Uninstall return codes:
//
// 0: success
// 1: success, but reboot required
// 2: failure, reboot required then try again
// 3: failure, driver install (rawnic) failed
// 4: failure, service install failed, see install output
//
    
#define XDS_ERROR_SUCCESS                 0
#define XDS_ERROR_SUCCESS_REBOOT_REQUIRED 1
#define XDS_ERROR_FAILURE_REBOOT_REQUIRED 2
#define XDS_ERROR_FAILURE_DRIVER          3
#define XDS_ERROR_FAILURE_SERVICE         4

DWORD MapToReturnCode(BOOL fServiceSucceeded, BOOL fDriverSucceeded, BOOL fRebootRequired)
{
    // Map error conditions to return codes
    if (fRebootRequired)
    {
        return fDriverSucceeded && fServiceSucceeded 
            ? XDS_ERROR_SUCCESS_REBOOT_REQUIRED 
            : XDS_ERROR_FAILURE_REBOOT_REQUIRED;
    }
    else
    {
        if (!fServiceSucceeded)
            return XDS_ERROR_FAILURE_SERVICE;
        else if (!fDriverSucceeded)
            return XDS_ERROR_FAILURE_DRIVER;
        else
            return XDS_ERROR_SUCCESS;
    }
}

//-----------------------------------------------------------------------------
//  Install:  Handle all aspects of service installation.
//-----------------------------------------------------------------------------
DWORD CXdsMain::Install()
{
    DWORD dwRes;
    BOOL fRebootRequired   = FALSE;
    BOOL fDriverSucceeded  = TRUE;
    BOOL fServiceSucceeded = TRUE;
    CLargeStr strLog;

    // install the raw nic driver.
    fDriverSucceeded = RawnicInstallDriver( L"Xbox Live Diagnostic Service", &fRebootRequired, &strLog );
    InstallInfo("RawnicInstallDriver says reboot is%s required", fRebootRequired ? "" : " not");
    InstallInfo("%s", strLog.cstr());
    if (!fDriverSucceeded)
    {
        InstallInfo("Warning: RAWNIC driver install failed (reboot is%s required)", fRebootRequired ? "" : " not");
        InstallInfo("The XDS will not function without the RAWNIC driver, but it may be installed later.");
    }

    // install the xds service
    dwRes = CNTService::Install();    
    if( ERROR_SUCCESS != dwRes )
    {
        InstallInfo("Warning: Service install failed with Win32 error %d", dwRes);
        fServiceSucceeded = FALSE;
    }

    return MapToReturnCode(fServiceSucceeded, fDriverSucceeded, fRebootRequired);
}

//-----------------------------------------------------------------------------
//  Uninstall:  Handle all aspects of service uninstallation.
//-----------------------------------------------------------------------------
DWORD CXdsMain::Uninstall()
{
    DWORD dwRes;
    BOOL fRebootRequired   = FALSE;
    BOOL fDriverSucceeded  = TRUE;
    BOOL fServiceSucceeded = TRUE;
    CLargeStr strLog;

    // uninstall the xds service
    dwRes = CNTService::Uninstall();
    if( ERROR_FILE_NOT_FOUND == dwRes )
    {
        InstallInfo("Warning: XDS service appears to not be installed, skipping");
    }
    else if( ERROR_SUCCESS != dwRes )
    {
        InstallInfo("Warning: Service uninstall failed with Win32 error %d", dwRes);
        fServiceSucceeded = FALSE;
    }

    // uninstall the rawnic driver.
    fDriverSucceeded = RawnicUninstallDriver( L"Xbox Live Diagnostic Service", &fRebootRequired, &strLog );
    InstallInfo("RawnicUnistallDriver says reboot is%s required", fRebootRequired ? "" : " not");
    InstallInfo("%s", strLog.cstr());
    if (!fDriverSucceeded)
    {
        InstallInfo("Warning: RAWNIC driver uninstall failed (reboot is%s required)", fRebootRequired ? "" : " not");
    }

    return MapToReturnCode(fServiceSucceeded, fDriverSucceeded, fRebootRequired);
}

//-----------------------------------------------------------------------------
//  Start:  Initializes and starts the Xds service.
//-----------------------------------------------------------------------------
HRESULT CXdsMain::Start()
{
    HRESULT hr = S_OK;

    XOMASSERT( m_pPacketBuffer == NULL );
    XOMASSERT( m_pMgmtInterface == NULL );
    XOMASSERT( m_bIsComplete == TRUE );

    if ( !m_bIsComplete )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Xds service already started.\n");
        // the xds server is already running.
        XomNtEvent( XEVENT_XDS_CODE_32, "CXdsMain::Start:  Xds service already started.");
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Xds service already started.");
        hr = E_FAIL;
        goto Exit;
    }

	logtofile3("c:\\xds.log","CXdsMain::Start:  Starting Xds.\n");
    XomTrace( Xds, L_NORMAL, "CXdsMain::Start:  Starting Xds.");

    //-------------------------------------------------------------
    // CONFIG
	logtofile3("c:\\xds.log","CXdsMain::Start:  Reading config data.\n");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Reading config data.");
    hr = LoadConfig();
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to successfully load config data.  Please investigate this situation.  RESULT = %X\n", hr);
        // not enough memory to create Xds instance.
        XomNtEvent( XEVENT_XDS_CODE_33, "CXdsMain::Start:  Failed to successfully load config data.  Please investigate this situation.  RESULT = %X", hr);
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to successfully load config data.  Please investigate this situation.  RESULT = %X", hr);
        goto Exit;
    }

    // no shutdown event ... bummer.
    m_hShutdown = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( m_hShutdown == NULL )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
			logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to create handle.  Please investigate this situation.  RESULT = %X\n", hr);
        XomNtEvent( XEVENT_XDS_CODE_34, "CXdsMain::Start:  Failed to create handle.  Please investigate this situation.  RESULT = %X", hr);
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to create handle.  Please investigate this situation.  RESULT = %X", hr);
        goto Exit;
    }

    //-------------------------------------------------------------
    // Initialize the perf counters
    //hr = g_Counters.Init();
    //if ( FAILED(hr) )
    //{
   //     XomNtEvent( XEVENT_XDS_CODE_35, "CXdsMain::Start:  Failed to initialize Perf Counters.  RESULT = 0x%X.", hr);
    //    XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to initialize Perf Counters.  RESULT = 0x%X.", hr);
    //    goto Exit;
    //}

    //-------------------------------------------------------------
    // Initialize completion port.
	logtofile3("c:\\xds.log","CXdsMain::Start:  Creating the completion port.\n");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Creating the completion port.");
    hr = CCompletionPort::CreateInstance( 0, m_dwNumOfThreads, THREAD_PRIORITY_ABOVE_NORMAL, &m_pCompletionPort);
    if(FAILED(hr))
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  CompletionPort CreateInstance Failed with RESULT = 0x%X.\n", hr);
        XomNtEvent( XEVENT_XDS_CODE_36, "CXdsMain::Start:  CompletionPort CreateInstance Failed with RESULT = 0x%X.", hr);
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  CompletionPort CreateInstance Failed with RESULT = 0x%X.", hr);
        goto Exit;
    }

    //-------------------------------------------------------------
    // Initialize the session key
	logtofile3("c:\\xds.log","CXdsMain::Start:  Creating the session key.\n");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Creating the session key.");
    HCRYPTPROV hRandCryptProv = NULL;
    if(!CryptAcquireContext( &hRandCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        if(!CryptAcquireContext( &hRandCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT  | CRYPT_NEWKEYSET))
        {
            hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32,  GetLastError() );
			logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to create cryptcontext. RESULT = 0x%X.\n", hr);
            XomNtEvent( XEVENT_XDS_CODE_37, "CXdsMain::Start:  Failed to create cryptcontext. RESULT = 0x%X.", hr);
            XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to create cryptcontext.  RESULT = 0x%X.", hr);
            goto Exit;
        }
    }
    if ( !CryptGenRandom( hRandCryptProv, sizeof(m_abSessionKey), (BYTE*)m_abSessionKey ) )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32,  GetLastError() );
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to generate session key.  RESULT = 0x%X.\n", hr);
        XomNtEvent( XEVENT_XDS_CODE_38, "CXdsMain::Start:  Failed to generate session key.  RESULT = 0x%X.", hr);
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to generate session key.  RESULT = 0x%X.", hr);
        goto Exit;
    }


    //-------------------------------------------------------------
    //  PACKET-BUFFER
	logtofile3("c:\\xds.log","CXdsMain::Start:  Creating packet buffer object.");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Creating packet buffer object.");
    // create a new node bag.
    m_pPacketBuffer = new CSNPool();
    if ( m_pPacketBuffer == NULL )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to allocated memory for the packet buffer handle.  Please ensure machine has enough available RAM to run this program.\n");
        // not enough memory to create Xds instance.
        XomNtEvent( XEVENT_XDS_CODE_39, "CXdsMain::Start:  Failed to allocated memory for the packet buffer handle.  Please ensure machine has enough available RAM to run this program.");
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to allocated memory for the packet buffer handle.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
	
	logtofile3("c:\\xds.log","CXdsMain::Start:  Initialize the packet buffer.");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Initialize the packet buffer.");
    hr = m_pPacketBuffer->Init( sizeof(PacketNode) , m_dwPacketBufferSize );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to allocated memory for the packet buffer.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.\n");
        // not enough memory to create Xds instance.
        XomNtEvent( XEVENT_XDS_CODE_40, "CXdsMain::Start:  Failed to allocated memory for the packet buffer.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.");
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to allocated memory for the packet buffer.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.");
        goto Exit;
    }

    //-------------------------------------------------------------
    // ActionNode Bag
	logtofile3("c:\\xds.log","CXdsMain::Start:  Setting up the Action Nodes.\n");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Setting up the Action Nodes.");
    // create a tap listr
    hr = InitializeActionNodes();
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to initialize the Action Node Bag Buffer.  Please investigate.  RESULT = 0x%X\n", hr);
        // not enough memory to create Xds instance.
        XomNtEvent( XEVENT_XDS_CODE_41, "CXdsMain::Start:  Failed to initialize the Action Node Bag Buffer.  Please investigate.  RESULT = 0x%X", hr);
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to initialize the Action Node Bag Buffer.  Please investigate.  RESULT = 0x%X", hr);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //-------------------------------------------------------------
    // Cache
	logtofile3("c:\\xds.log","CXdsMain::Start:  Generating the cache.\n");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Generating the cache.");
    m_pCache = new CXdsCache();
    if ( m_pCache == NULL )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to allocate enough memory for IP Cache.\n");
        // not enough memory to create ip cache.
        XomNtEvent( XEVENT_XDS_CODE_42, "CXdsMain::Start:  Failed to allocate enough memory for IP Cache.");
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to allocate enough memory for IP Cache.");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // initialize the cache
    hr = m_pCache->Init( m_dwCacheLifetime, m_dwCacheSize, m_dwCacheHashTableSize, m_dwInfractionLimit );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to initialize the cache.  RESULT = 0x%X\n", hr);
        // not enough memory to create ip cache.
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to initialize the cache.  RESULT = 0x%X", hr);
        goto Exit;
    }


    //-------------------------------------------------------------
    // Mgmt Interface
	logtofile3("c:\\xds.log","CXdsMain::Start:  Creating the XMGMT Interface.\n");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Creating the XMGMT Interface.");
    // create a new mgmt interface
    m_pMgmtInterface = new CMgmtInterface();
    if ( m_pMgmtInterface == NULL )
    {
		logtofile3("c:\\xds.log", "CXdsMain::Start:  Failed to allocated memory for the Mgmt interface.  Please ensure machine has enough available RAM to run this program.\n");
        // not enough memory to create Xds instance.
        XomNtEvent( XEVENT_XDS_CODE_43, "CXdsMain::Start:  Failed to allocated memory for the Mgmt interface.  Please ensure machine has enough available RAM to run this program.");
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to allocated memory for the Mgmt interface.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = m_pMgmtInterface->Initialize( c_dwNumOfCommands );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log", "CXdsMain::Start:  Failed to initialize the Mgmt interface.  RESULT = 0x%X\n", hr );
        // not enough memory to create Xds instance.
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to initialize the Mgmt interface.  RESULT = 0x%X", hr );
        goto Exit;
    }

    // intialize mgmt the callbacks
    InitializeCallbacks();

    //-------------------------------------------------------------
    //  NicMgr/Vlan
	logtofile3("c:\\xds.log", "CXdsMain::Start:  Initializing NicMgr.\n");
    XomTrace( Xds, L_LOW, "CXdsMain::Start:  Initializing NicMgr.");
    m_pNicMgr = CNicMgr::GetInstance();

    hr = m_pNicMgr->Initialize( m_dwNumOfNics, m_bUseArpThread );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to initialize the Nic Mgr.  Result= 0x%X\n", hr);
        // not enough memory to create Xds instance.
        XomNtEvent( XEVENT_XDS_CODE_44, "CXdsMain::Start:  Failed to initialize the Nic Mgr.  Result= 0x%X", hr);
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to initialize the Nic Mgr.  Result= 0x%X", hr);
        goto Exit;
    }

    // load the nic configuration.
    hr = LoadNicConfig();
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::Start:  Failed to configure the Nic Mgr.  Result= 0x%X\n", hr);
        // not enough memory to create Xds instance.
        XomNtEvent( XEVENT_XDS_CODE_45, "CXdsMain::Start:  Failed to configure the Nic Mgr.  Result= 0x%X", hr);
        XomTrace( Xds, L_ERROR, "CXdsMain::Start:  Failed to configure the Nic Mgr.  Result= 0x%X", hr);
        goto Exit;
    }

    // create the health interop instances. do this last after everything else has been 
    // initialized, so we don't get any false positives.
    hr = m_pHealthInterop.CoCreateInstance( __uuidof(HealthInterop) );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadConfig failed to instantiate HealthInterop "
            "with hr: 0x%08X. Verify xblhealthcheck.dll is in the GAC and it "
            "has been registered with regasm.exe, making sure to use the proper "
            "32 or 64 bit version.  Also verify the various XBL platform DLLs are "
            "in the GAC as well.", 
            hr);
        XomNtEvent(XEVENT_XDS_CONFIG_HEALTHINTEROP_CREATE,
            "CXdsMain::LoadConfig failed to instantiate HealthInterop "
            "with hr: 0x%08X. Verify xblhealthcheck.dll is in the GAC and it "
            "has been registered with regasm.exe, making sure to use the proper "
            "32 or 64 bit version.  Also verify the various XBL platform DLLs are "
            "in the GAC as well.", 
            hr);
        goto Exit;
    }

    // and fire up the http health listener for this component
    hr = m_pHealthInterop->Initialize(Component_xds, (LONG_PTR)::GetModuleHandle(NULL));
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadConfig failed to call Initialize on the "
            "HealthInterop instance for component %S with hr: 0x%08X.",
            (BSTR)Component_xds, hr);
			
        XomNtEvent(XEVENT_XDS_CONFIG_HEALTHINTEROP_INIT,
            "CXdsMain::LoadConfig failed to call Initialize on the "
            "HealthInterop instance for component %S with hr: 0x%08X.",
            (BSTR)Component_xds, hr);
        goto Exit;
    }
	
    logtofile3("c:\\xds.log","CXdsMain::Start:  Successfully started Xds.");
    XomNtEvent( XEVENT_XDS_INFO_0, "CXdsMain::Start:  Successfully started Xds.");
    XomTrace( Xds, L_NORMAL, "CXdsMain::Start:  Successfully started Xds.");
    m_bIsComplete = FALSE;

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Run:  runs until everything is quit.
//-----------------------------------------------------------------------------
HRESULT CXdsMain::Run()
{
    HRESULT hr = S_OK;

    WaitForSingleObject( ShutdownEvent(), INFINITE );

    return hr;
}

//-----------------------------------------------------------------------------
//  Term:  Termintates Xds service.
//-----------------------------------------------------------------------------
HRESULT CXdsMain::Term()
{
    HRESULT hr = S_OK;

    XOMASSERT( m_pActionBag != NULL );
    XOMASSERT( m_pMgmtInterface != NULL);
    XOMASSERT( m_pCompletionPort != NULL );
    XOMASSERT( m_pNicMgr != NULL );

    //-----
    m_pNicMgr->TerminateThreads();
    CNicMgr::ReleaseInstance();
    m_pNicMgr = NULL;

    // TODO:  (lohab) I should block here until the completion port thread is dead....

    // blow away the completion port
    if ( m_pCompletionPort )
    {
        m_pCompletionPort->Shutdown();
        hr = m_pCompletionPort->Release();
        if ( FAILED(hr) )
        {
            XomNtEvent( XEVENT_XDS_CODE_46, "CXdsMain::RunService:  We experienced troubles release down the completion port.  RESULT = 0x%X", hr );
            XomTrace( Xds, L_ERROR, "CXdsMain::RunService:  We experienced troubles release down the completion port.  RESULT = 0x%X", hr );
        }

        m_pCompletionPort = NULL;
    }

    // Mgmt Interface
    if ( m_pMgmtInterface )
    {
        delete m_pMgmtInterface;
        m_pMgmtInterface = NULL;
    }

    // get ride of the action nodes.
    hr = CleanActionNodes();
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XDS_CODE_47, "CXdsMain::RunService:  Failed to destroy the Action node bag during termination.  Please investigate.  RESULT = 0x%X", hr );
        XomTrace( Xds, L_ERROR, "CXdsMain::RunService:  Failed to destroy the Action node bag during termination.  Please investigate.  RESULT = 0x%X", hr );
    }


    // blow away the cache.
    m_pCache->Term();
    delete m_pCache;
    m_pCache = NULL;


    // delete the packet buffer.
    delete m_pPacketBuffer;

    m_bIsComplete = TRUE;

    XomNtEvent( XEVENT_XDS_INFO_1 ,"CXdsMain::Term:  Successfully terminated Xds service.");
    XomTrace( Xds, L_NORMAL ,"CXdsMain::Term:  Successfully terminated Xds service.");

    return hr;
}


//-----------------------------------------------------------------------------
//  InitService:  initialize the Xds service
//      overrides:  Initializes the service.
//-----------------------------------------------------------------------------
HRESULT CXdsMain::InitService( DWORD dwArgc, LPWSTR *pszArgv )
{
    return Start();
}

//-----------------------------------------------------------------------------
//  InitService:  initialize the Xds service
//      overrides:  run the service.
//-----------------------------------------------------------------------------
HRESULT CXdsMain::RunService( BOOL *pfServiceRan )
{
    HRESULT hr = S_OK;
    CXdsAction* pAction = NULL;

    hr = Run();
    if ( FAILED( hr ) )
    {
		logtofile3("c:\\xds.log","CXdsMain::RunService:  Failed to stop properly. 0x%X\n", hr);
        XomNtEvent( XEVENT_XDS_CODE_48, "CXdsMain::RunService:  Failed to stop properly. 0x%X", hr);
        goto Exit;
    }
    *pfServiceRan = TRUE;

    Term();
Exit:
    return hr;
}


//-----------------------------------------------------------------------------
//  LoadConfig:  Loads config data from Xds.ini
//-----------------------------------------------------------------------------
HRESULT CXdsMain::LoadConfig()
{
    HRESULT hr = S_OK;

    XomLog(Xds, "---------------------------------------------------" );
    XomLog(Xds, "   XDS Config Settings" );
    XomLog(Xds, "---------------------------------------------------" );

    // create the config db instance for all KDCs
    hr = m_pConfig.CoCreateInstance(  __uuidof(ConfigInterop) );
    if ( FAILED(hr) )
    {
        XomTrace(Xds, L_ERROR, "CXdsMain::LoadConfig: Failed to create instance of the configDB interface.  Please investigate.  hr = 0x%X", hr);
        XomNtEvent( XEVENT_XDS_CODE_49, "CXdsMain::LoadConfig: Failed to create instance of the configDB interface.  Please investigate.  hr = 0x%X", hr);
        goto Exit;
    }

    // Setup notification handler for changed values
    m_pConfigListener = new CXDSConfigListener();
    if (m_pConfigListener != NULL)
    {
        hr = m_pConfig->putref_ConfigListener(m_pConfigListener);
        if (FAILED(hr))
        {
            XomNtEvent( XEVENT_XDS_CODE_49, "(%s:%d) CXdsMain::LoadConfig: failed to register CXBaseConfigListener object, hr=0x%08X", 
                __FILE__,
                __LINE__,
                hr
                );

            hr = HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED);
            goto Exit;
        }
    }
    else
    {
        XomTrace( Xds, L_ERROR, "(%s:%d) CXdsMain::LoadConfig:: failed to instantiate CXBaseConfigListener.",
            __FILE__,
            __LINE__
            );

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //------------------------------------------------------------------
    //  Get the packet size buffer.
    m_dwPacketBufferSize      = GetDWORDSetting( Setting_xds_packetBufferSize, c_dwDefaultPacketBufferSize );

    //------------------------------------------------------------------
    //  Read cache table size.
    m_dwCacheSize             = GetDWORDSetting( Setting_xds_cacheSize,  c_dwDefaultCacheSize );

    //------------------------------------------------------------------
    //  Read cache table size.
    m_dwCacheHashTableSize    = GetDWORDSetting( Setting_xds_cacheHashTableSize, c_dwDefaultHashTableSize );

    //------------------------------------------------------------------
    //  Read cache lifetime (seconds)
    m_dwCacheLifetime         = GetDWORDSetting( Setting_xds_eventCacheThrottleLifeTimeInSeconds, c_dwDefaultCacheLifetime );

    //------------------------------------------------------------------
    //  Read the number of threads in completion port.
    m_dwNumOfThreads          = GetDWORDSetting( Setting_xds_numberOfProcessingThreads , c_dwDefaultNumberofThreads );

    //------------------------------------------------------------------
    //  Load the port we want to read from all the time.
    m_dwPort                  = GetDWORDSetting( Setting_xds_port , c_dwDefaultPort );

    //------------------------------------------------------------------
    //  get the infraction limit.
    m_dwInfractionLimit       = GetDWORDSetting( Setting_xds_infactionLimitPerMinute , c_dwDefaultInfractionLimit );

    m_dwGatewayLookupInterval = GetDWORDSetting( Setting_xds_gatewayLookupIntervalInSeconds, c_dwDefaultGatewayInterval );
    m_dwARPRetryInterval      = GetDWORDSetting( Setting_xds_ARPRetryIntervalInSeconds, c_dwDefaultRetryInterval );
    m_dwRetryEventThrottle    = GetDWORDSetting( Setting_xds_ARPRetryEventThrottle,  c_dwDefaultEventThrottle );
    if ( m_dwRetryEventThrottle == 0 )
    {
        m_dwARPRetryInterval = c_dwDefaultEventThrottle;
        XomTrace(Xds, L_WARNING, "CXdsMain::LoadConfig: The ARP retry interval cannot be zero.  The value has been modified to the server default %d.", c_dwDefaultEventThrottle);
        XomNtEvent( XEVENT_XDS_CONFIG_5, "CXdsMain::LoadConfig: The ARP retry interval cannot be zero.  The value has been modified to the server default %d.", c_dwDefaultEventThrottle);
    }

    m_bTOS                    = (BYTE)GetDWORDSetting( Setting_xds_TOS , c_dwDefaultTOS );
    m_bTTL                    = (BYTE)GetDWORDSetting( Setting_xds_TTL , c_dwDefaultTTL );

    m_dwSkewTimeInMilliSecs   = GetDWORDSetting( Setting_xds_skewTimeInMilliSecs, c_dwDefaultSkewTime );
    m_dwMaxLogLength          = GetDWORDSetting( Setting_xds_maxLogLength , c_dwDefaultMaxLogLength );
    m_dwMinICMPRequestLength  = GetDWORDSetting( Setting_xds_minICMPRequestLength , c_dwDefaultMinICMPRequestLength);
    m_dwMinLogRequestLength   = GetDWORDSetting( Setting_xds_minLogRequestLength , c_dwDefaultMinLogRequestLength);
    

    //------------------------------------------------------------------
    //  Arp thread usage flag.
    m_bUseArpThread = TRUE;

    //------------------------------------------------------------------
    //  Read the ICMP reply IP address.
    char szIpAddr[64];
    ZeroMemory( szIpAddr , sizeof( szIpAddr ) );
    GetStringSetting( (LPSTR)szIpAddr, ARRAY_ELEMENTS(szIpAddr), Setting_xds_ICMPReplyAddr, c_szDefaultICMPReplyAddr );
    m_dwICMPReplyAddr = (DWORD)StringToIp( szIpAddr );

    m_dwNumOfNics = c_dwDefaultNumOfNics;
 
    XomLog(Xds, "---------------------------------------------------" );
    
Exit:
    return hr;    
}


//  -- this implements a possible XDS configuration using common config
//-----------------------------------------------------------------------------
//  LoadNicConfig:  Loads config data from Xds.ini for Nic Mgr
//-----------------------------------------------------------------------------
HRESULT CXdsMain::LoadNicConfig()
{
    HRESULT hr      = S_OK;
    BOOL    bRes    = TRUE;
    DWORD   dwNumOfNics = 0;
    DWORD   dwX     = 0;
    char*   szBuf;

    XomLog(Xds, "---------------------------------------------------" );
    XomLog(Xds, "   XDS Config Nic Settings" );
    XomLog(Xds, "---------------------------------------------------" );
        
    //------------------------------------------------------------------
    //  Read and build interfaces for all nics.
    GetXOMSetting( &m_dwNumOfNics, c_szNumOfNics, c_dwDefaultNumOfNics );

    XOMASSERT( m_pNicMgr != NULL );
    
    // for each nic...
    for ( dwX = 0; dwX < m_dwNumOfNics; dwX++ )
    {
        char szParamName[32];
        DWORD dwIP = 0;
        DWORD dwId = 0;
        DWORD dwGatewayIP = 0;
        DWORD m_dwGatewayLookupInterval = 0;
        DWORD m_dwARPRetryInterval = 0;
        DWORD m_dwRetryEventThrottle = 0;
        char* pszMacAddr = NULL;
        CEnetAddr eaAddr;
        BYTE * pEthernetAddr = NULL;

        // collect the params.        
        _snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szLocalIP, dwX );
        GetXOMSetting( &szBuf, szParamName, "192.168.1.149" );
        XOMASSERT( szBuf != NULL );
        dwIP = (DWORD)StringToIp( szBuf );
        if ( dwIP == 0 )
        {
            // invalid IP?  
            continue;
        }

        _snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szDefaultGateway, dwX );
        GetXOMSetting( &szBuf, szParamName, "192.168.1.1" );
        XOMASSERT( szBuf != NULL );
        dwGatewayIP = (DWORD)StringToIp( szBuf );
        if ( dwGatewayIP == 0 )
        {
            // invalid IP?  
            continue;
        }
        
        _snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szVLanMACAddr, dwX );
        GetXOMSetting( &pszMacAddr, szParamName, "00155D019102" );
        HexToBin( pszMacAddr, strlen(pszMacAddr), &pEthernetAddr);

        eaAddr.SetZero();
        memcpy( eaAddr._ab, pEthernetAddr, sizeof(eaAddr) );
        delete pEthernetAddr;

        _snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szGatewayLookupInterval, dwX );
        GetXOMSetting( &m_dwGatewayLookupInterval, szParamName, c_dwDefaultGatewayInterval );

        _snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szRetryInterval, dwX );
        GetXOMSetting( &m_dwARPRetryInterval, szParamName, c_dwDefaultRetryInterval );

        _snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szRetryEventThrottle, dwX );
        GetXOMSetting( &m_dwRetryEventThrottle, szParamName, c_dwDefaultEventThrottle );

        // add a new node to the nic mgr.  Dont' forget to change to milliseconds.
        hr = m_pNicMgr->Add(    eaAddr, 
                                dwIP, 
                                dwGatewayIP, 
                                m_dwGatewayLookupInterval *1000, 
                                m_dwARPRetryInterval * 1000, 
                                m_dwRetryEventThrottle,
                                m_dwPort,
                                &dwId );
        if ( FAILED(hr) )
        {
            XomTrace(Xds, L_WARNING, "CXdsMain::LoadNicConfig:  Failed to add Nic #%d.  Result = 0x%X", dwX, hr );
            continue;
        }
        
    }

    // make sure we at least have 1 nic
    if ( m_pNicMgr->GetNumOfNics() == 0 )
    {
        XomTrace(Xds, L_WARNING, "CXdsMain::LoadNicConfig:  No Nics present.  Please make sure this is properly configured." );
        hr = E_FAIL;
        goto Exit;
    }
 
    XomLog(Xds, "---------------------------------------------------" );

Exit:
    return hr;    
}

/*
HRESULT CXdsMain::LoadNicConfig()
{
    HRESULT hr      = S_OK;
    BOOL    bRes    = TRUE;
    DWORD   dwNumOfNics = 0;
    DWORD   dwX     = 0;
    char*   szBuf;
    char szParamName[32];
    CComBSTR bstrIPAddr;
    CComBSTR bstrDefaultGatewayAddr;
    CComBSTR bstrMacStr;
    DWORD dwIP = 0;
    DWORD dwId = 0;
    DWORD dwPort = 0;
    DWORD dwGatewayIP = 0;
    char* pszVlanMacAddr = NULL;
    CComBSTR bstrServerName;
    CComPtr<IInterfaceInfo> pInterfaceInfo;    
    CEnetAddr eaAddr;
    BYTE * pEthernetAddr = NULL;
	logtofile3("c:\\xds.log","---------------------------------------------------\n" );
    XomLog(Xds, "---------------------------------------------------" );
	logtofile3("c:\\xds.log","   XDS Config Nic Settings\n" );
    XomLog(Xds, "   XDS Config Nic Settings" );
	logtofile3("c:\\xds.log","---------------------------------------------------\n" );
    XomLog(Xds, "---------------------------------------------------" );


    XOMASSERT( m_pNicMgr != NULL );

    // TODO:  Add interface enumeration should it become available.
    
    hr = m_pConfig->get_Server( &bstrServerName );
    if (FAILED(hr))
    {
		logtofile3("c:\\xds.log","CUAMain::LoadConfig  Failed to get the server name for XDS.  RESULT = 0x%X\n", hr);
        XomTrace( Xds, L_WARNING, "CUAMain::LoadConfig  Failed to get the server name for XDS.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_XDS_CODE_50, "CUAMain::LoadConfig  Failed to get the server name for XDS.  RESULT = 0x%X", hr);
        goto Exit;
    }
    
    hr = m_pConfig->GetInterface( bstrServerName, Interface_xds, &pInterfaceInfo);
    if (FAILED(hr))
    {
		logtofile3("c:\\xds.log","CUAMain::LoadConfig  Failed to get config interface for XDS.  RESULT = 0x%X", hr);
        XomTrace( Xds, L_WARNING, "CUAMain::LoadConfig  Failed to get config interface for XDS.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_XDS_CODE_51, "CUAMain::LoadConfig  Failed to get config interface for XDS.  RESULT = 0x%X", hr);
        goto Exit;
    }

    //------------------------------------------------------------------
    //  Read the ip address
    hr = pInterfaceInfo->get_IPAddressString( &bstrIPAddr );
    if ( FAILED(hr) || bstrIPAddr.m_str == NULL )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadConfig  Failed to get a valid IP address for Xds.  RESULT = 0x%X", hr);
        XomTrace( Xds, L_WARNING, "CXdsMain::LoadConfig  Failed to get a valid IP address for Xds.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_XDS_CODE_52, "CXdsMain::LoadConfig  Failed to get a valid IP address for Xds.  RESULT = 0x%X", hr);
        goto Exit;
    }
	logtofile3("c:\\xds.log","CXdsMain::LoadConfig  IPAddr=%S.  ", bstrIPAddr );
    XomTrace( Xds, L_NORMAL, "CXdsMain::LoadConfig  IPAddr=%S.  ", bstrIPAddr );
    dwIP = (DWORD)StringToIp( CW2A(bstrIPAddr) );
    if ( dwIP == 0 )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadConfig:  The given IP address is invalid (IPAddr = %S).  RESULT = 0x%X", bstrIPAddr, hr);
        XomTrace( Xds, L_WARNING, "CXdsMain::LoadConfig:  The given IP address is invalid (IPAddr = %S).  RESULT = 0x%X", bstrIPAddr, hr);
        XomNtEvent( XEVENT_XDS_CONFIG_1, "CXdsMain::LoadConfig:  The given IP address is invalid (IPAddr = %S).  RESULT = 0x%X", bstrIPAddr, hr);
        goto Exit;
    }

    //------------------------------------------------------------------
    //  Read the default gateway ipaddress
    hr = pInterfaceInfo->get_IPDefaultGatewayString( &bstrDefaultGatewayAddr );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadConfig:  Failed to get the info 1 setting with the default gateway ip address.  Using default of 1.  RESULT = 0x%X", hr);
        XomTrace( Xds, L_WARNING, "CXdsMain::LoadConfig:  Failed to get the info 1 setting with the default gateway ip address.  Using default of 1.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_XDS_CODE_53, "CXdsMain::LoadConfig:  Failed to get the info 1 setting with the default gateway ip address.  Using default of 1.  RESULT = 0x%X", hr);
        goto Exit;
    }
    XomTrace( Xds, L_NORMAL, "CXdsMain::LoadConfig  Default Gateway Ip=.  ", bstrDefaultGatewayAddr );
    dwGatewayIP = (DWORD)StringToIp( CW2A(bstrDefaultGatewayAddr) );
    if ( dwGatewayIP == 0 )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadConfig:  The given Default Gateway address is invalid (IPAddr = %S).  RESULT = 0x%X", bstrIPAddr, hr);
        XomTrace( Xds, L_WARNING, "CXdsMain::LoadConfig:  The given Default Gateway address is invalid (IPAddr = %S).  RESULT = 0x%X", bstrIPAddr, hr);
        XomNtEvent( XEVENT_XDS_CONFIG_2, "CXdsMain::LoadConfig:  The given Default Gateway address is invalid (IPAddr = %S).  RESULT = 0x%X", bstrIPAddr, hr);
        goto Exit;
    }
        
    //------------------------------------------------------------------
    //  Read the mac address for this interface.
    hr = pInterfaceInfo->get_Mac( &bstrMacStr );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadConfig:  Failed to get the Mac setting containing the MacAddr string.  Using default of 1.  RESULT = 0x%X", hr);
        XomTrace( Xds, L_WARNING, "CXdsMain::LoadConfig:  Failed to get the Mac setting containing the MacAddr string.  Using default of 1.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_XDS_CODE_54, "CXdsMain::LoadConfig:  Failed to get the Mac setting containing the MacAddr string.  Using default of 1.  RESULT = 0x%X", hr);
        goto Exit;
    }
	logtofile3("c:\\xds.log","CXdsMain::LoadConfig:  Vlan Config String=%S.  ", bstrMacStr );
    XomTrace( Xds, L_NORMAL, "CXdsMain::LoadConfig:  Vlan Config String=%S.  ", bstrMacStr );
    HexToBin( CW2A(bstrMacStr), bstrMacStr.Length(), &pEthernetAddr);

    eaAddr.SetZero();
    memcpy( eaAddr._ab, pEthernetAddr, sizeof(eaAddr) );
    delete pEthernetAddr;

    //------------------------------------------------------------------
    //  Read the port for this interface.
    hr = pInterfaceInfo->get_Port( (long*)&dwPort );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadConfig:  Failed to get the info 2 setting containing the Vlan Configuration string.  Using default of 1.  RESULT = 0x%X", hr);
        XomTrace( Xds, L_WARNING, "CXdsMain::LoadConfig:  Failed to get the info 2 setting containing the Vlan Configuration string.  Using default of 1.  RESULT = 0x%X", hr);
        XomNtEvent( XEVENT_XDS_CODE_55, "CXdsMain::LoadConfig:  Failed to get the info 2 setting containing the Vlan Configuration string.  Using default of 1.  RESULT = 0x%X", hr);
        goto Exit;
    }
    
    // add a new node to the nic mgr.  Dont' forget to change to milliseconds.
    hr = m_pNicMgr->Add(    eaAddr, 
                            dwIP, 
                            dwGatewayIP, 
                            m_dwGatewayLookupInterval *1000, 
                            m_dwARPRetryInterval * 1000, 
                            m_dwRetryEventThrottle, 
                            dwPort,
                            &dwId );
    if ( FAILED(hr) )
    {
		logtofile3("c:\\xds.log","CXdsMain::LoadNicConfig:  Failed to add Nic.  Result = 0x%X", dwX, hr );
        XomTrace(Xds, L_WARNING, "CXdsMain::LoadNicConfig:  Failed to add Nic.  Result = 0x%X", dwX, hr );
        goto Exit;
    }
	logtofile3("c:\\xds.log","---------------------------------------------------" );
    XomLog(Xds, "---------------------------------------------------" );

Exit:
    return hr;
}
*/

HRESULT CXdsMain::Reload(struct ISettingChangeEventArgs * eventArgs)
{
    CComBSTR SettingChange;
    CComBSTR bsValueNew = CComBSTR(NULL);
    HRESULT hr = S_OK;

    if (eventArgs == NULL)
    {
        hr = E_POINTER;
        goto lDone;
    }

    hr = eventArgs->get_Setting(&SettingChange);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = eventArgs->get_ValueNew(&bsValueNew);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = ReloadSetting( SettingChange, bsValueNew );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

//------------------------------------------------------------------
// ReloadSetting:  Taking the setting Id... this function will update 
//   the system setting to the new value.
//------------------------------------------------------------------
HRESULT CXdsMain::ReloadSetting( CComBSTR SettingChange, CComBSTR bsValueNew )
{
	HRESULT hr = S_OK;

	if (Setting_xds_infactionLimitPerMinute == SettingChange)
	{
		//  get the infraction limit.
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &m_dwInfractionLimit );
	}
	else if (Setting_xds_gatewayLookupIntervalInSeconds == SettingChange)
	{
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &m_dwGatewayLookupInterval );
		hr = m_pNicMgr->ModifyPollTime( 0, m_dwGatewayLookupInterval );
	}
	else if (Setting_xds_ARPRetryIntervalInSeconds == SettingChange)
	{
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &m_dwARPRetryInterval );
		hr = m_pNicMgr->ModifyRetryInterval( 0, m_dwARPRetryInterval );
	}
	else if (Setting_xds_ARPRetryEventThrottle == SettingChange)
	{
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &m_dwRetryEventThrottle );
		if ( m_dwRetryEventThrottle == 0 )
		{
			m_dwARPRetryInterval = c_dwDefaultEventThrottle;
			XomTrace(Xds, L_WARNING, "CXdsMain::LoadConfig: The ARP retry interval cannot be zero.  The value has been modified to the server default %d.", c_dwDefaultEventThrottle);
			XomNtEvent( XEVENT_XDS_CONFIG_5, "CXdsMain::LoadConfig: The ARP retry interval cannot be zero.  The value has been modified to the server default %d.", c_dwDefaultEventThrottle);
		}

		// change the event throttle for all nics.
		//  note that we only have one at this time.
		hr = m_pNicMgr->ModifyEventThrottle( 0, m_dwRetryEventThrottle );
	}
	else if (Setting_xds_TOS == SettingChange)
	{
		DWORD dwTemp = 0;
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &dwTemp );
		m_bTOS = (BYTE)dwTemp;
	}
	else if (Setting_xds_skewTimeInMilliSecs == SettingChange)
	{
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &m_dwSkewTimeInMilliSecs );
	}
	else if (Setting_xds_maxLogLength == SettingChange)
	{
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &m_dwMaxLogLength );
	}
	else if (Setting_xds_minICMPRequestLength == SettingChange)
	{
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &m_dwMinICMPRequestLength );
	}
	else if (Setting_xds_minLogRequestLength == SettingChange)
	{
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &m_dwMinLogRequestLength );
	}        
	else if (Setting_xds_TTL == SettingChange)
	{
		DWORD dwTemp = 0;
		_snwscanf( bsValueNew.m_str, bsValueNew.Length(), L"%u", &dwTemp );
		m_bTTL = (BYTE)dwTemp;
	}
	else if (Setting_xds_ICMPReplyAddr == SettingChange)
	{
		//  Read the ICMP reply IP address.
		char szIpAddr[64];
		ZeroMemory( szIpAddr , sizeof( szIpAddr ) );
		_snprintf( szIpAddr, ARRAYSIZE( szIpAddr ), "%S", bsValueNew.m_str );
		m_dwICMPReplyAddr = (DWORD)StringToIp( szIpAddr );        
	}
	else
	{
		XomTrace( Xds, L_WARNING, "CXdsMain::LoadConfig:  A new setting has been detected in the npdb however XDS does not support it's dynamic reload.  A restart of the service is required to engage this change.");
		XomNtEvent( XEVENT_XDS_CODE_49, "CXdsMain::LoadConfig:  A new setting has been detected in the npdb however XDS does not support it's dynamic reload.  A restart of the service is required to engage this change.");
	}

	return hr;
}


//------------------------------------------------------------------
// QueuePacket:  Gets a node from the buffer and puts the packet
//          on the processing IOCompletion port queue.
//------------------------------------------------------------------
HRESULT CXdsMain::QueuePacket( PacketNode* pPacket )
{
    HRESULT hr = S_OK;
    DWORD dwPacketSize = 0;
    DWORD dwSrcIP = 0;
    CXdsAction* pAction = NULL;
    CIpHdr *pIPHdr = NULL;

    XOMASSERT( pPacket != NULL );
    if ( pPacket == NULL )
    {        
        XomTrace( Xds, L_ERROR, "CXdsMain::QueuePacket:  Why is this packet NULL at this time... DO NOT DO THIS! FIX YOUR CODE!!!" );
        hr = E_INVALIDARG;
        goto Exit;
    }    

    // check if this packet is big enough for me to look at.
    if (( pPacket->m_cData < sizeof(CEnetAddr) + sizeof(CIpHdr) + sizeof(CUdpHdr) ) || (! m_pNicMgr->IsPacketForMe( pPacket ) ))
    {
        // silly this packet isn't for you... don't process any further.
        goto Exit;
    }

    // perf counter number of requests.
    g_Counters.IncrementValue32( XDS_REQUESTS_PER_SEC_COUNTER, 1);
    g_Counters.IncrementValue64( XDS_REQUESTS_COUNTER, 1);

    // check the size of the packet
    if ( pPacket->m_cData < sizeof( XDS_REQUEST_HEADER ) + sizeof(CEnetAddr) + sizeof(CIpHdr) + sizeof(CUdpHdr) )
    {
        XomTrace( Xds, L_LOW, "CXdsMain::QueuePacket:  Packet is too small, doesn't meet minimum requirements. Size = %d.  SrcIP = %d.%d.%d.%d.",
            pPacket->m_cData,
            ((BYTE*)&(dwSrcIP))[0],
            ((BYTE*)&(dwSrcIP))[1],
            ((BYTE*)&(dwSrcIP))[2],
            ((BYTE*)&(dwSrcIP))[3] );
        g_Counters.IncrementValue32( XDS_INVALID_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( XDS_INVALID_REQUESTS_COUNTER, 1);
        goto Exit;
    }
    
    pIPHdr = (CIpHdr*)(pPacket->GetIPHdr());

    XomTrace(Xds, L_LOW, "CXdsMain::QueuePacket:  Queueing Packet.  SIZE:%d  FROM:%d.%d.%d.%d  TO:%d.%d.%d.%d, Id= %d",
                                dwPacketSize,
                                (DWORD)(((BYTE*)&(pIPHdr->_ipaSrc))[0]),
                                (DWORD)(((BYTE*)&(pIPHdr->_ipaSrc))[1]),
                                (DWORD)(((BYTE*)&(pIPHdr->_ipaSrc))[2]),
                                (DWORD)(((BYTE*)&(pIPHdr->_ipaSrc))[3]),
                                (DWORD)(((BYTE*)&(pIPHdr->_ipaDst))[0]),
                                (DWORD)(((BYTE*)&(pIPHdr->_ipaDst))[1]),
                                (DWORD)(((BYTE*)&(pIPHdr->_ipaDst))[2]),
                                (DWORD)(((BYTE*)&(pIPHdr->_ipaDst))[3]),
                                pPacket->m_dwNicId );

    // add a reference to the packet... let the main threads handle it.
    AddRefPacketNode( pPacket );

    // get an action node
    pAction = GetAction();
    if ( pAction == NULL )
    {
        XomNtEvent( XEVENT_XDS_CODE_56, "CXdsMain::QueuePacket:  There are no more Action nodes.  This packet will be dropped.  Please re-config with more memory to avoid this.");
        XomTrace( Xds, L_ERROR, "CXdsMain::QueuePacket:  There are no more Action nodes.  This packet will be dropped.  Please re-config with more memory to avoid this.");

        ReleasePacketNode( (PacketNode*)pPacket );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // set up the action
    pAction->Setup(  CXdsAction::PACKET, (LPBYTE)pPacket );

    // post the action to the completion port.
    hr = m_pCompletionPort->PostCompletion( (CCompletionContext*) pAction, sizeof(CXdsAction), NULL );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XDS_CODE_57, "CXdsMain::QueuePacket: Failed to post this packet to the completion port.  RESULT = 0x%X.", hr );
        XomTrace( Xds, L_ERROR, "CXdsMain::QueuePacket: Failed to post this packet to the completion port.  RESULT = 0x%X.", hr );

        ReleaseAction( pAction );
        ReleasePacketNode( (PacketNode*)pPacket );
        goto Exit;
    }

Exit:
    return hr;
}


//------------------------------------------------------------------
// AddRef:  Increments the reference counter for this node.
//------------------------------------------------------------------
void CXdsMain::AddRefPacketNode( PacketNode *pNode )
{
    InterlockedIncrement( (LPLONG)&(pNode->m_dwRefCount) );
}

//------------------------------------------------------------------
// Release:  removes the reference counter for this node.  Also,
//    Zero's out memory fo node when complete.
//------------------------------------------------------------------
void CXdsMain::ReleasePacketNode( PacketNode *pNode )
{
    LONG lValue = 0;

    if ( pNode == NULL )
    {
        return;
    }

    XOMASSERT( pNode->m_dwRefCount > 0 );

    lValue = InterlockedDecrement( (LPLONG)&(pNode->m_dwRefCount) );
    if ( lValue == 0 )
    {
        ZeroMemory( pNode, sizeof(PacketNode) );
        m_pPacketBuffer->Free( (void*)pNode );
    }
}

//------------------------------------------------------------------
// GetPacketNode:  returns a packet node
//------------------------------------------------------------------
PacketNode* CXdsMain::GetPacketNode()
{
    PacketNode *pNode = NULL;

    // get a node for this job
    pNode = (PacketNode*)m_pPacketBuffer->Alloc();
    if ( pNode != NULL )
    {
        pNode->m_dwRefCount = 0;
        AddRefPacketNode(pNode);
    }

    return pNode;
}

//------------------------------------------------------------------
//  ProcessPacket:  figure out what to do with the packet
//------------------------------------------------------------------
HRESULT CXdsMain::ProcessPacket( PacketNode *pNode )
{
    HRESULT hr = S_OK;
    XDS_REQUEST_HEADER* prHdr = NULL;
    CUdpHdr *pUdpHdr = NULL;
    BYTE abResp[sizeof(CEnetHdr) + c_dwMAX_MTU_ETHERNET] = {0};
    DWORD cResp = sizeof(abResp);

    prHdr = (XDS_REQUEST_HEADER*)pNode->GetMsg();

    // check the protocol version
    if ( prHdr->_wProtocolVersion < 1 || prHdr->_wProtocolVersion > c_dwLatestProtocolVersion )
    {
        // perf counter invalid request
        g_Counters.IncrementValue32( XDS_INVALID_REQUESTS_PER_SEC_COUNTER, 1);
        g_Counters.IncrementValue64( XDS_INVALID_REQUESTS_COUNTER, 1);

        XomTrace( Xds, L_ERROR, "CXdsMain::ProcessPacket:  The given packet from %d.%d.%d.%d has an invalid protocol version of %d.  Blacklisting events for IP.",
            ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[0],
            ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[1],
            ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[2],
            ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[3],
            prHdr->_wProtocolVersion
            );
        hr = EventThrottle( pNode->GetIPHdr()->_ipaSrc );
        if ( hr == S_OK )
        {
            XomNtEvent( XEVENT_XDS_HACK_4, "CXdsMain::ProcessPacket:  Packet has invalid Protocol version. Version = %d.  SrcIP = %d.%d.%d.%d.",
                prHdr->_wProtocolVersion,
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[0],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[1],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[2],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[3]);
        }
        goto Exit;
    }

    // SPECIAL NOTE:  The logging in most of these areas seems to ignore the invalid packet size. This isn't
    //      true since each packet is on a zero initialized memory buffer of a fixed size.  Thus all the
    //      memory references here are still within the buffer.


    // check the request type.
    switch( prHdr->_wRequestType )
    {
    case REFLECT_SAMEIPPORT:
#ifdef XDS_FULLY_FUCNTIONAL
    case REFLECT_DIFFERENTIP:
    case REFLECT_SAMEIP_DIFFERENTPORT:
#endif
        {
            XDS_REFLECTION_REQUEST* pReq = (XDS_REFLECTION_REQUEST*)(pNode->GetMsg());
            DWORD cReq = pNode->m_cData - sizeof(CIpHdr) - sizeof(CUdpHdr);

            // perf counter for reflection
            g_Counters.IncrementValue32( XDS_REFLECTIONS_REQUESTS_PER_SEC_COUNTER, 1);
            g_Counters.IncrementValue64( XDS_REFLECTIONS_REQUESTS_COUNTER, 1);

            // make sure the given is ok.
            hr = ValidateReflectionRequest( pReq, cReq, pNode->GetIPHdr()->_ipaSrc );
            if ( FAILED(hr) )
            {
                // perf counter invalid request
                g_Counters.IncrementValue32( XDS_INVALID_REQUESTS_PER_SEC_COUNTER, 1);
                g_Counters.IncrementValue64( XDS_INVALID_REQUESTS_COUNTER, 1);

                goto Exit;
            }

            ConstructReflectionResponse( pNode, (BYTE*)abResp, &cResp );
        }
        break;
    case REFLECT_ICMP:
        {
            XDS_ICMP_REQUEST* pReq = (XDS_ICMP_REQUEST*)(pNode->GetMsg());
            DWORD cReq = pNode->m_cData - sizeof(CIpHdr) - sizeof(CUdpHdr);

            // perf counter for ICMP
            g_Counters.IncrementValue32( XDS_ICMP_REQUESTS_PER_SEC_COUNTER, 1);
            g_Counters.IncrementValue64( XDS_ICMP_REQUESTS_COUNTER, 1);

            // make sure the given is ok.
            hr = ValidateICMPRequest( pReq, cReq, pNode->GetIPHdr()->_ipaSrc );
            if ( FAILED(hr) )
            {
                // perf counter invalid request
                g_Counters.IncrementValue32( XDS_INVALID_REQUESTS_PER_SEC_COUNTER, 1);
                g_Counters.IncrementValue64( XDS_INVALID_REQUESTS_COUNTER, 1);

                goto Exit;
            }

            ConstructICMPResponse( pNode, (BYTE*)abResp, &cResp );
        }
        break;
#ifdef XDS_FULLY_FUCNTIONAL
    case REFLECT_LOG:
        {
            XDS_LOG_REQUEST* pReq = (XDS_LOG_REQUEST*)(pNode->GetMsg());
            DWORD cReq = pNode->m_cData - sizeof(CIpHdr) - sizeof(CUdpHdr);

            // perf counter for logging
            g_Counters.IncrementValue32( XDS_LOG_REQUESTS_PER_SEC_COUNTER, 1);
            g_Counters.IncrementValue64( XDS_LOG_REQUESTS_COUNTER, 1);

            // make sure the given is ok.
            hr = ValidateLogRequest( pReq, cReq, pNode->GetIPHdr()->_ipaSrc );
            if ( FAILED(hr) )
            {
                // perf counter invalid request
                g_Counters.IncrementValue32( XDS_INVALID_REQUESTS_PER_SEC_COUNTER, 1);
                g_Counters.IncrementValue64( XDS_INVALID_REQUESTS_COUNTER, 1);

                goto Exit;
            }

            // log this request.
            char szHexPPA1[ (sizeof(pReq->_abPPA1) * 2) + 1] = {0};
            char szPayload[ c_dwMAX_MTU_ETHERNET - sizeof(CIpHdr) - sizeof(CUdpHdr) - sizeof(XDS_LOG_REQUEST) ] = {0};

            BinToHex( (char*)pReq->_abPPA1, sizeof(pReq->_abPPA1), (char*)szHexPPA1 );
            MakePresentableOutput( (char*)szPayload, pReq->_cLogPayload, (char*)( pNode->GetMsg() + sizeof(XDS_LOG_REQUEST) ));

            XomLog( XdsLog, "XDSPKT|%I64X|%d.%d.%d.%d|%12.12s|%s|%d|%s",
                    pReq->_qwTimeStamp,
                    ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[0],
                    ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[1],
                    ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[2],
                    ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[3],
                    pReq->_acXboxSerialNumber,
                    szHexPPA1,
                    pReq->_wProtocolVersion,
                    szPayload
                );

            ConstructLogResponse( pNode, (BYTE*)abResp, &cResp );
        }
        break;
#endif
    default:
        {
            XomTrace( Xds, L_ERROR, "CXdsMain::ProcessPacket:  The given packet from IP:%d.%d.%d.%d has an invalid request type of %d.  Blacklisting events for IP.",
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[0],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[1],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[2],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[3],
                prHdr->_wRequestType
                );

            hr = EventThrottle( pNode->GetIPHdr()->_ipaSrc );
            if ( hr == S_OK )
            {
                XomNtEvent( XEVENT_XDS_HACK_5, "CXdsMain::ProcessPacket:  The given packet from IP:%d.%d.%d.%d has an invalid request type of %d.  Blacklisting events for IP.",
                        ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[0],
                        ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[1],
                        ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[2],
                        ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[3],
                        prHdr->_wRequestType
                        );
            }

            // perf counter invalid request
            g_Counters.IncrementValue32( XDS_INVALID_REQUESTS_PER_SEC_COUNTER, 1);
            g_Counters.IncrementValue64( XDS_INVALID_REQUESTS_COUNTER, 1);

            goto Exit;
        }
        break;
    };

    // transmit the response here
    hr = m_pNicMgr->Transmit( pNode->m_dwNicId, (BYTE*)abResp, cResp );
    if ( FAILED(hr) )
    {
            XomTrace( Xds, L_ERROR, "CXdsMain::ProcessPacket:  Failed to send packet to IP:%d.%d.%d.%d/Port:0x%X.",
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[0],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[1],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[2],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[3],
                (DWORD)(pNode->GetUDPHdr()->_ipportSrc)
                );

            XomNtEvent( XEVENT_XDS_HACK_6, "CXdsMain::ProcessPacket:  Failed to send packet to IP:%d.%d.%d.%d/Port:0x%X.",
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[0],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[1],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[2],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[3],
                (DWORD)(pNode->GetUDPHdr()->_ipportSrc)
                );
            goto Exit;
    }

    XomTrace( Xds, L_LOW, "CXdsMain::ProcessPacket:  Successful Response to IP:%d.%d.%d.%d/Port:0x%X.",
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[0],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[1],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[2],
                ((BYTE*)&(pNode->GetIPHdr()->_ipaSrc))[3],
                (DWORD)(pNode->GetUDPHdr()->_ipportSrc)
                );

    g_Counters.IncrementValue32( XDS_SUCCESSFUL_REQUESTS_PER_SEC_COUNTER, 1);
    g_Counters.IncrementValue64( XDS_SUCCESSFUL_REQUESTS_COUNTER, 1);

Exit:
    ReleasePacketNode( pNode );
    return hr;
}



//------------------------------------------------------------------
//  EventThrottle:  Puts the given IP in the cache.  If the entry
//      already exists... returns S_FALSE;
//------------------------------------------------------------------
HRESULT CXdsMain::EventThrottle( DWORD dwIP )
{
    HRESULT hr = S_OK;

    // check the cache... don't process any further if this packet is unwanted.
    if ( m_pCache->Find( dwIP ) )
    {
        hr = S_FALSE;
        goto Exit;
    }

    // put this in the Cache.
    hr = m_pCache->Add( dwIP );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XDS_CODE_58 , "CXdsMain::EventThrottle:  Failed to blacklist IP %d.%d.%d.%d.  Result = 0x%X",
                        ((BYTE*)&(dwIP))[0],
                        ((BYTE*)&(dwIP))[1],
                        ((BYTE*)&(dwIP))[2],
                        ((BYTE*)&(dwIP))[3],
                        hr );
        XomTrace( Xds, L_ERROR, "CXdsMain::EventThrottle:  Failed to blacklist IP %d.%d.%d.%d.  Result = 0x%X",
                        ((BYTE*)&(dwIP))[0],
                        ((BYTE*)&(dwIP))[1],
                        ((BYTE*)&(dwIP))[2],
                        ((BYTE*)&(dwIP))[3],
                        hr );
        goto Exit;
    }

Exit:
     return hr;
}


//------------------------------------------------------------------
//  SHA1HMAC:  The SHA1-HMAC for XDS.
//------------------------------------------------------------------
void CXdsMain::SHA1HMAC( DWORD dwSrcIP, ULONGLONG qwTimeStamp,  BYTE *pDigest )
{
    XOMASSERT( pDigest != NULL );

    //
    // Calculate and return SHA( HMAC key( srcIP | timestamp ) ) as pDigest
    //
    XcHMAC(
        (BYTE *)m_abSessionKey,
        sizeof( m_abSessionKey ),
        (BYTE *) &dwSrcIP,
        sizeof( dwSrcIP ),
        (BYTE *) &qwTimeStamp,
        sizeof(qwTimeStamp),
        pDigest );

}

//------------------------------------------------------------------
//  ConstructReflectionResponse:  Builds the reply packet to the
//      client.
//   TODO:  WHAT ABOUT THE CHECKSUM FOR IP AND UDP.
//-------------------------------------------